!!!fork: marlin4Due

**--**-**--merge: BlinkM.cpp

#if defined (upstream) && defined (BLINKM)
Wire.write(grn);
#endif
++++++
#if defined (marlin4Due) && defined (BLINKM)
// Wire.write(grn);
#endif
++++++
#if defined (upstream)
/*
  BlinkM.cpp - Library for controlling a BlinkM over i2c
  Created by Tim Koster, August 21 2013.
*/
#endif
++++++
#if defined (marlin4Due)
/*
  blinkm.cpp - Library for controlling a BlinkM over i2c
  Created by Tim Koster, August 21 2013.
*/
#endif
++++++
#if defined (upstream) && ((ARDUINO >= 100) && defined (BLINKM) )
# include "Arduino.h"
#endif
++++++
#if defined (marlin4Due) && defined (BLINKM)
#include "blinkm.h"
#endif
++++++
#if defined (upstream) && (!(ARDUINO >= 100) && defined (BLINKM) )
# include "WProgram.h"
#endif
++++++
#if defined (upstream) && defined (BLINKM)
#include "BlinkM.h"
#endif
++++++


**--**-**--merge: cardreader.cpp

#if defined (upstream) && defined (SDSUPPORT)
autostart_atmillis=0;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lastnr=0;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
autostart_index = 0;
#endif
++++++
#if defined (upstream) && (SDPOWER > -1 && defined (SDSUPPORT) )
SET_OUTPUT(SDPOWER);
#endif
++++++
#if defined (marlin4Due) && (SDPOWER > -1 && defined (SDSUPPORT) )
OUT_WRITE(SDPOWER, HIGH);
#endif
++++++
#if defined (upstream) && (SDPOWER > -1 && defined (SDSUPPORT) )
WRITE(SDPOWER,HIGH);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
autostart_atmillis=millis()+5000;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
next_autostart_ms = millis() + 5000;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//buffer>12characters
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)

      *pos++='.';
    

#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)*pos++ = '.';
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//buffer > 12characters
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//buffer>12characters
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char path[13*2];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Get the short name for the item, which we know is a folder
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lfilename[13];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char lfilename[FILENAME_LENGTH];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
path[0]=0;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Allocate enough stack space for the full path to a folder, trailing slash, and nul
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(strlen(prepend)==0) //avoid leading / if already in prepend
      {
       strcat(path,"/");
      }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
boolean prepend_is_empty = (prepend[0] == '\0');
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
strcat(path,prepend);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
int len = (prepend_is_empty ? 1 : strlen(prepend)) + strlen(lfilename) + 1 + 1;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char path[len];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Append the FOLDERNAME12/ to the passed string.
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// It contains the full path to the "parent" argument.
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// We now have the full path to the item in this folder.
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
strcpy(path, prepend_is_empty ? "/" : prepend);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// root slash if prepend is empty
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// FILENAME_LENGTH-1 characters maximum
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// 1 character
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Get a new directory object using the full path
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// and dive recursively into it.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//close done automatically by destructor of SdFile
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// close() is done automatically by destructor of SdFile
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char path[len];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// FILENAME_LENGTH-1 characters maximum
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// 1 character
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Get a new directory object using the full path
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// hence LS_SerialPrint
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(pn0 == DIR_NAME_DELETED || pn0 == '.' || pn0 == '_')
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
(pn0 == DIR_NAME_DELETED || pn0 == '.')
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lf0 = longFilename[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(lf0 == '.' || lf0 == '_')
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
(longFilename[0] == '.')
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(!filenameIsDir)
      {
        if(p.name[8]!='G') continue;
        if(p.name[9]=='~') continue;
      }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (!filenameIsDir && (p.name[8] != 'G' || p.name[9] == '~')) continue;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//if(cnt++!=nr) continue;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
switch (lsAction) {
        case LS_Count:
          nrFiles++;
          break;
        case LS_SerialPrint:
          createFilename(filename, p);
          SERIAL_PROTOCOL(prepend);
          SERIAL_PROTOCOLLN(filename);
          break;
        case LS_GetFilename:
          createFilename(filename, p);
          if (match != NULL) {
            if (strcasecmp(match, filename) == 0) return;
          }
          else if (cnt == nrFiles) return;
          cnt++;
          break;
      }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
createFilename(filename,p);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(lsAction==LS_SerialPrint)
      {
        SERIAL_PROTOCOL(prepend);
        SERIAL_PROTOCOLLN(filename);
      }
      else if(lsAction==LS_Count)
      {
        nrFiles++;
      } 
      else if(lsAction==LS_GetFilename)
      {
        if (match != NULL) {
          if (strcasecmp(match, filename) == 0) return;
        }
        else if (cnt == nrFiles) return;
        cnt++;
        
      }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lf0 = longFilename[0];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// If the entry is a directory and the action is LS_SerialPrint
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Read the next entry from a directory
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// while readDir
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(lsAction==LS_Count)
  nrFiles=0;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)

    sdprinting = false;
  

#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)sdprinting = false;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(cnt<MAXPATHNAMELENGTH-13)
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
(cnt < MAXPATHNAMELENGTH - FILENAME_LENGTH)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
for(uint8_t i=0;i<workDirDepth;i++)
  {
    workDirParents[i].getFilename(t); //SDBaseFile.getfilename!
    while(*t!=0 && cnt< MAXPATHNAMELENGTH) 
    {t++;cnt++;}  //crawl counter forward.
  }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
for (uint8_t i = 0; i < workDirDepth; i++) {
    workDirParents[i].getFilename(t); //SDBaseFile.getfilename!
    while(*t && cnt < MAXPATHNAMELENGTH) { t++; cnt++; } //crawl counter forward.
  }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//replacing current file by new file, or subfile call
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if((int)file_subcall_ctr>(int)SD_PROCEDURE_DEPTH-1)
     {
       SERIAL_ERROR_START;
       SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
       SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
       kill();
       return;
     }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (file_subcall_ctr > SD_PROCEDURE_DEPTH - 1) {
       SERIAL_ERROR_START;
       SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
       SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
       kill(PSTR(MSG_KILLED));
       return;
     }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//replacing current file by new file, or subfile call
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//replacing current file by new file, or subfile call
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//opening fresh file
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//opening fresh file
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//opening fresh file
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
dirname_start=strchr(name,'/')+1;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
dirname_start = &name[1];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char subdirname[13];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char subdirname[FILENAME_LENGTH];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLNPGM(".");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
SERIAL_PROTOCOLCHAR('.');
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// the remainder after all /fsa/fdsa/ is the filename
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//SERIAL_ECHOLN("remaider");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//SERIAL_ECHOLN("remainder");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// the remainder after all /fsa/fdsa/ is the filename
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// the reminder after all /fsa/fdsa/ is the filename
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//relative path
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//relative path
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//relative path
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLNPGM(".");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
SERIAL_PROTOCOLPGM(".\n");
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLNPGM(".");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
SERIAL_PROTOCOLPGM(".\n");
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char subdirname[13];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char subdirname[FILENAME_LENGTH];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLNPGM(".");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
SERIAL_PROTOCOLCHAR('.');
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// the remainder after all /fsa/fdsa/ is the filename
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//SERIAL_ECHOLN("remaider");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//SERIAL_ECHOLN("remainder");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// the remainder after all /fsa/fdsa/ is the filename
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// the reminder after all /fsa/fdsa/ is the filename
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// relative path
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// relative path
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//relative path
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLNPGM(".");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
SERIAL_PROTOCOLCHAR('.');
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLPGM("/");
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
SERIAL_PROTOCOLCHAR('/');
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//fail
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//fail
#endif
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// fail
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// fail
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
for(int8_t i=0;i<(int8_t)strlen((char*)p.name);i++)
    p.name[i]=tolower(p.name[i]);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
for (int8_t i = 0; i < (int8_t)strlen((char*)p.name); i++) p.name[i] = tolower(p.name[i]);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//Serial.print((char*)p.name);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (p.name[9] != '~' && strncmp((char*)p.name, autoname, 5) == 0) {
      char cmd[4 + (FILENAME_LENGTH + 1) * MAX_DIR_DEPTH + 2];
      sprintf_P(cmd, PSTR("M23 %s"), autoname);
      enqueuecommand(cmd);
      enqueuecommands_P(PSTR("M24"));
      found = true;
    }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//Serial.print(" ");
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lastnr=-1;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
autostart_index = -1;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lastnr++;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
autostart_index++;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(!force)
  {
    if(!autostart_stilltocheck)
      return;
    if(autostart_atmillis<millis())
      return;
  }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (!force && (!autostart_stilltocheck || next_autostart_ms < millis()))
    return;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char autoname[30];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char autoname[10];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
sprintf_P(autoname, PSTR("auto%i.g"), lastnr);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
sprintf_P(autoname, PSTR("auto%i.g"), autostart_index);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
for(int8_t i=0;i<(int8_t)strlen(autoname);i++)
    autoname[i]=tolower(autoname[i]);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
for (int8_t i = 0; i < (int8_t)strlen(autoname); i++) autoname[i] = tolower(autoname[i]);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
saving = false;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
saving = logging = false;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
logging = false;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
for (int d = ++workDirDepth; d--;)
        workDirParents[d+1] = workDirParents[d];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
++workDirDepth;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
for (int d = workDirDepth; d--;) workDirParents[d + 1] = workDirParents[d];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
for (int d = workDirDepth; d--;) workDirParents[d + 1] = workDirParents[d];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
int d;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
for (uint16_t d = 0; d < workDirDepth; d++)
      workDirParents[d] = workDirParents[d+1];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
for (int d = 0; d < workDirDepth; d++)
      workDirParents[d] = workDirParents[d+1];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Heading up to a parent file that called current as a procedure.
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Heading up to a parent file that called current as a procedure.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//heading up to a parent file that called current as a procedure.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
quickStop();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
enqueuecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
quickStop();
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
/**
 * Dive into a folder and recurse depth-first to perform a pre-set operation lsAction:
 *   LS_Count       - Add +1 to nrFiles for every file within the parent
 *   LS_GetFilename - Get the filename of the file indexed by nrFiles
 *   LS_SerialPrint - Print the full path of each file to serial output
 */
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (LONG_FILENAME_HOST_SUPPORT) )
/**
   * Get a long pretty path based on a DOS 8.3 path
   */
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// LONG_FILENAME_HOST_SUPPORT
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
/**
 * Get the name of a file in the current directory by index
 */
#endif
++++++


**--**-**--merge: ConfigurationStore.cpp



**--**-**--merge: digipot_mcp4451.cpp

#if defined (upstream) && defined (DIGIPOT_I2C)
for(int i=0;i<=sizeof(digipot_motor_current)/sizeof(float);i++) {
        digipot_i2c_set_current(i, digipot_motor_current[i]);
    }
#endif
++++++
#if defined (marlin4Due) && defined (DIGIPOT_I2C)
for(int i = 0; i < COUNT(digipot_motor_current); i++) {
    digipot_i2c_set_current(i, digipot_motor_current[i]);
  }
#endif
++++++
#if defined (marlin4Due)
//DIGIPOT_I2C
#endif
++++++


**--**-**--merge: LiquidCrystalRus.cpp



**--**-**--merge: Marlin_main.cpp

#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
WRITE(KILL_PIN,HIGH);
#endif
++++++
#if defined (marlin4Due) && HAS_KILL
PULLUP(KILL_PIN, HIGH);
#endif
++++++
#if defined (upstream) && (defined(HOME_PIN) && HOME_PIN > -1)
WRITE(HOME_PIN,HIGH);
#endif
++++++
#if defined (marlin4Due) && HAS_HOME
PULLUP(HOME_PIN, HIGH);
#endif
++++++
#if defined (upstream) && (defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN > -1)
SET_OUTPUT(PHOTOGRAPH_PIN);
#endif
++++++
#if defined (marlin4Due) && HAS_PHOTOGRAPH
OUT_WRITE(PHOTOGRAPH_PIN, LOW);
#endif
++++++
#if defined (upstream) && (defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN > -1)
WRITE(PHOTOGRAPH_PIN, LOW);
#endif
++++++
#if defined (upstream) && (defined(SUICIDE_PIN) && SUICIDE_PIN > -1)
SET_OUTPUT(SUICIDE_PIN);
#endif
++++++
#if defined (marlin4Due) && HAS_SUICIDE
OUT_WRITE(SUICIDE_PIN, HIGH);
#endif
++++++
#if defined (upstream) && (defined(SUICIDE_PIN) && SUICIDE_PIN > -1)
WRITE(SUICIDE_PIN, HIGH);
#endif
++++++
#if defined (marlin4Due) && (HAS_POWER_SWITCH && ENABLED(PS_DEFAULT_OFF) )
OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
#endif
++++++
#if defined (upstream) && (defined(PS_ON_PIN) && PS_ON_PIN > -1)
SET_OUTPUT(PS_ON_PIN);
#endif
++++++
#if defined (marlin4Due) && (HAS_POWER_SWITCH && !ENABLED(PS_DEFAULT_OFF) )
OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
#endif
++++++
#if defined (upstream) && (defined(PS_DEFAULT_OFF) && (defined(PS_ON_PIN) && PS_ON_PIN > -1 &)
WRITE(PS_ON_PIN, PS_ON_ASLEEP);
#endif
++++++
#if defined (upstream) && ((defined(PS_ON_PIN) && PS_ON_PIN > -1 && )!defined(PS_DEFAULT_OFF) )
WRITE(PS_ON_PIN, PS_ON_AWAKE);
#endif
++++++
#if defined (upstream) && (defined(SUICIDE_PIN) && SUICIDE_PIN > -1)
SET_OUTPUT(SUICIDE_PIN);
#endif
++++++
#if defined (marlin4Due) && HAS_SUICIDE
OUT_WRITE(SUICIDE_PIN, LOW);
#endif
++++++
#if defined (upstream) && (defined(SUICIDE_PIN) && SUICIDE_PIN > -1)
WRITE(SUICIDE_PIN, LOW);
#endif
++++++
#if defined (upstream) && ((NUM_SERVOS >= 1) && defined(SERVO0_PIN) && (SERVO0_PIN > -1))
servos[0].attach(SERVO0_PIN);
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 1 && HAS_SERVO_0)
servo[0].attach(SERVO0_PIN);
#endif
++++++
#if defined (upstream) && ((NUM_SERVOS >= 2) && defined(SERVO1_PIN) && (SERVO1_PIN > -1))
servos[1].attach(SERVO1_PIN);
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 1 && HAS_SERVO_0)
servo[0].detach();
#endif
++++++
#if defined (upstream) && ((NUM_SERVOS >= 3) && defined(SERVO2_PIN) && (SERVO2_PIN > -1))
servos[2].attach(SERVO2_PIN);
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 1 && HAS_SERVO_0)
// Just set up the pin. We don't have a position yet. Don't move to a random position.
#endif
++++++
#if defined (upstream) && ((NUM_SERVOS >= 4) && defined(SERVO3_PIN) && (SERVO3_PIN > -1))
servos[3].attach(SERVO3_PIN);
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 2 && HAS_SERVO_1)
servo[1].attach(SERVO1_PIN);
#endif
++++++
#if defined (upstream) && (NUM_SERVOS >= 5)
#error "TODO: enter initalisation code for more servos"
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 2 && HAS_SERVO_1)
servo[1].detach();
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 3 && HAS_SERVO_2)
servo[2].attach(SERVO2_PIN);
#endif
++++++
#if defined (marlin4Due) && (NUM_SERVOS >= 4 && HAS_SERVO_3)
servo[3].attach(SERVO3_PIN);
#endif
++++++
#if defined (upstream) && defined (SERVO_ENDSTOPS)
for(int8_t i = 0; i < 3; i++)
  {
    if(servo_endstops[i] > -1) {
      servos[servo_endstops[i]].write(servo_endstop_angles[i * 2 + 1]);
    }
  }
#endif
++++++
#if defined (marlin4Due) && HAS_SERVO_ENDSTOPS
for (int i = 0; i < 3; i++)
      if (servo_endstop_id[i] >= 0)
        servo[servo_endstop_id[i]].move(servo_endstop_angle[i][1]);
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0))
delay(PROBE_SERVO_DEACTIVATION_DELAY);
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)fromsd[i] = false;
#endif
++++++
#if defined (marlin4Due)
setup_filrunoutpin();
#endif
++++++
#if defined (marlin4Due) && HAS_STEPPER_RESET
disableStepperDrivers();
#endif
++++++
#if defined (upstream)
SERIAL_ECHOLNPGM(VERSION_STRING);
#endif
++++++
#if defined (marlin4Due)
SERIAL_ECHOLNPGM(" " BUILD_VERSION);
#endif
++++++
#if defined (upstream) && (defined (STRING_CONFIG_H_AUTHOR) && defined (STRING_VERSION_CONFIG_H) )
SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);
#endif
++++++
#if defined (marlin4Due) && (defined (STRING_DISTRIBUTION_DATE) && defined (STRING_CONFIG_H_AUTHOR) )
SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
#endif
++++++
#if defined (marlin4Due) && defined (STRING_DISTRIBUTION_DATE)
// STRING_CONFIG_H_AUTHOR
#endif
++++++
#if defined (marlin4Due)
// STRING_DISTRIBUTION_DATE
#endif
++++++
#if defined (marlin4Due)
lcd_init();
#endif
++++++
#if defined (upstream)
lcd_init();
#endif
++++++
#if defined (marlin4Due)
init_fsr_values();
#endif
++++++
#if defined (upstream)
_delay_ms(1000);
#endif
++++++
#if defined (marlin4Due) && HAS_STEPPER_RESET
enableStepperDrivers();
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
pinMode(SERVO0_PIN, OUTPUT);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
pinMode(SLED_PIN, OUTPUT);
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
digitalWrite(SERVO0_PIN, LOW);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
digitalWrite(SLED_PIN, LOW);
#endif
++++++
#if defined (marlin4Due) && defined (STAT_LED_RED)
pinMode(STAT_LED_RED, OUTPUT);
#endif
++++++
#if defined (marlin4Due) && defined (STAT_LED_BLUE)
pinMode(STAT_LED_BLUE, OUTPUT);
#endif
++++++
#if defined (upstream)
(buflen < (BUFSIZE-1))
#endif
++++++
#if defined (marlin4Due)
(commands_in_queue < BUFSIZE - 1)
#endif
++++++
#if defined (upstream)
//check heater every n milliseconds
#endif
++++++
#if defined (upstream)
lcd_update();
#endif
++++++
#if defined (marlin4Due)
idle();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(buflen==0)
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)
(commands_in_queue == 0)
#endif
++++++
#if defined (upstream)
while( MYSERIAL.available() > 0  && buflen < BUFSIZE) {
    serial_char = MYSERIAL.read();
    if(serial_char == '\n' ||
       serial_char == '\r' ||
       (serial_char == ':' && comment_mode == false) ||
       serial_count >= (MAX_CMD_SIZE - 1) )
    {
      if(!serial_count) { //if empty line
        comment_mode = false; //for new command
        return;
      }
      cmdbuffer[bufindw][serial_count] = 0; //terminate string
      if(!comment_mode){
        comment_mode = false; //for new command
        fromsd[bufindw] = false;
        if(strchr(cmdbuffer[bufindw], 'N') != NULL)
        {
          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');
          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));
          if(gcode_N != gcode_LastN+1 && (strstr_P(cmdbuffer[bufindw], PSTR("M110")) == NULL) ) {
            SERIAL_ERROR_START;
            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);
            SERIAL_ERRORLN(gcode_LastN);
            //Serial.println(gcode_N);
            FlushSerialRequestResend();
            serial_count = 0;
            return;
          }

          if(strchr(cmdbuffer[bufindw], '*') != NULL)
          {
            byte checksum = 0;
            byte count = 0;
            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];
            strchr_pointer = strchr(cmdbuffer[bufindw], '*');

            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {
              SERIAL_ERROR_START;
              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);
              SERIAL_ERRORLN(gcode_LastN);
              FlushSerialRequestResend();
              serial_count = 0;
              return;
            }
            //if no errors, continue parsing
          }
          else
          {
            SERIAL_ERROR_START;
            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);
            SERIAL_ERRORLN(gcode_LastN);
            FlushSerialRequestResend();
            serial_count = 0;
            return;
          }

          gcode_LastN = gcode_N;
          //if no errors, continue parsing
        }
        else  // if we don't receive 'N' but still see '*'
        {
          if((strchr(cmdbuffer[bufindw], '*') != NULL))
          {
            SERIAL_ERROR_START;
            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);
            SERIAL_ERRORLN(gcode_LastN);
            serial_count = 0;
            return;
          }
        }
        if((strchr(cmdbuffer[bufindw], 'G') != NULL)){
          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');
          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){
          case 0:
          case 1:
          case 2:
          case 3:
            if (Stopped == true) {
              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
              LCD_MESSAGEPGM(MSG_STOPPED);
            }
            break;
          default:
            break;
          }

        }

        //If command was e-stop process now
        if(strcmp(cmdbuffer[bufindw], "M112") == 0)
          kill();
        
        bufindw = (bufindw + 1)%BUFSIZE;
        buflen += 1;
      }
      serial_count = 0; //clear buffer
    }
    else
    {
      if(serial_char == ';') comment_mode = true;
      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
    }
  }
#endif
++++++
#if defined (marlin4Due)
if (drain_queued_commands_P()) return;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(!card.sdprinting || serial_count!=0){
    return;
  }
#endif
++++++
#if defined (marlin4Due)
// priority is given to non-serial commands
#endif
++++++
#if defined (marlin4Due) && ENABLED(NO_TIMEOUTS)
static millis_t last_command_time = 0;
#endif
++++++
#if defined (marlin4Due)
//
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)
if (!card.sdprinting || serial_count) return;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
while( !card.eof()  && buflen < BUFSIZE && !stop_buffering) {
    int16_t n=card.get();
    serial_char = (char)n;
    if(serial_char == '\n' ||
       serial_char == '\r' ||
       (serial_char == '#' && comment_mode == false) ||
       (serial_char == ':' && comment_mode == false) ||
       serial_count >= (MAX_CMD_SIZE - 1)||n==-1)
    {
      if(card.eof()){
        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
        stoptime=millis();
        char time[30];
        unsigned long t=(stoptime-starttime)/1000;
        int hours, minutes;
        minutes=(t/60)%60;
        hours=t/60/60;
        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);
        SERIAL_ECHO_START;
        SERIAL_ECHOLN(time);
        lcd_setstatus(time);
        card.printingHasFinished();
        card.checkautostart(true);

      }
      if(serial_char=='#')
        stop_buffering=true;

      if(!serial_count)
      {
        comment_mode = false; //for new command
        return; //if empty line
      }
      cmdbuffer[bufindw][serial_count] = 0; //terminate string
//      if(!comment_mode){
        fromsd[bufindw] = true;
        buflen += 1;
        bufindw = (bufindw + 1)%BUFSIZE;
//      }
      comment_mode = false; //for new command
      serial_count = 0; //clear buffer
    }
    else
    {
      if(serial_char == ';') comment_mode = true;
      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
    }
  }
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)
while (!card.eof() && commands_in_queue < BUFSIZE && !stop_buffering) {
      int16_t n = card.get();
      serial_char = (char)n;
      if (serial_char == '\n' || serial_char == '\r' ||
          ((serial_char == '#' || serial_char == ':') && !comment_mode) ||
          serial_count >= (MAX_CMD_SIZE - 1) || n == -1
      ) {
        if (card.eof()) {
          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
          print_job_stop_ms = millis();
          char time[30];
          millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;
          int hours = t / 60 / 60, minutes = (t / 60) % 60;
          sprintf_P(time, PSTR("%i " MSG_END_HOUR " %i " MSG_END_MINUTE), hours, minutes);
          SERIAL_ECHO_START;
          SERIAL_ECHOLN(time);
          lcd_setstatus(time, true);
          card.printingHasFinished();
          card.checkautostart(true);
        }
        if (serial_char == '#') stop_buffering = true;

        if (!serial_count) {
          comment_mode = false; //for new command
          return; //if empty line
        }
        command_queue[cmd_queue_index_w][serial_count] = 0; //terminate string
        // if (!comment_mode) {
        fromsd[cmd_queue_index_w] = true;
        commands_in_queue += 1;
        cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;
        // }
        comment_mode = false; //for new command
        serial_count = 0; //clear buffer
      }
      else {
        if (serial_char == ';') comment_mode = true;
        if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;
      }
    }
#endif
++++++
#if defined (upstream)
return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL));
#endif
++++++
#if defined (marlin4Due)
float ret;
#endif
++++++
#if defined (upstream)
return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10));
#endif
++++++
#if defined (marlin4Due)
return strtol(seen_pointer + 1, NULL, 10);
#endif
++++++
#if defined (upstream)
strchr_pointer = strchr(cmdbuffer[bufindr], code);
#endif
++++++
#if defined (marlin4Due)
seen_pointer = strchr(current_command_args, code);
#endif
++++++
#if defined (upstream)
return (strchr_pointer != NULL);
#endif
++++++
#if defined (marlin4Due)
return (seen_pointer != NULL);
#endif
++++++
#if defined (upstream)
//Return True if a character was found
#endif
++++++
#if defined (marlin4Due)
// Return TRUE if the code-letter was found
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
return base_home_pos(X_AXIS) + add_homing[X_AXIS];
#endif
++++++
#if defined (marlin4Due) && ENABLED(DUAL_X_CARRIAGE)
return base_home_pos(X_AXIS) + home_offset[X_AXIS];
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && defined (AUTO_BED_LEVELING_GRID) )
// put the bed at 0 so we don't go below it.
#endif
++++++
#if defined (marlin4Due) && (DISABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(AUTO_BED_LEVELING_GRID) )
sync_plan_position();
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && defined (AUTO_BED_LEVELING_GRID) )
current_position[Z_AXIS] = zprobe_zoffset;
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
vector_3 from_2_to_1 = (pt1 - pt2).get_normal();
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(AUTO_BED_LEVELING_GRID) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
vector_3 planeNormal = vector_3::cross(pt1 - pt2, pt3 - pt2).get_normal();
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
vector_3 from_2_to_3 = (pt3 - pt2).get_normal();
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(AUTO_BED_LEVELING_GRID) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
if (planeNormal.z < 0) {
        planeNormal.x = -planeNormal.x;
        planeNormal.y = -planeNormal.y;
        planeNormal.z = -planeNormal.z;
      }
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
vector_3 planeNormal = vector_3::cross(from_2_to_1, from_2_to_3).get_normal();
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
// put the bed at 0 so we don't go below it.
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(AUTO_BED_LEVELING_GRID) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
sync_plan_position();
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
current_position[Z_AXIS] = zprobe_zoffset;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
float start_z = current_position[Z_AXIS];
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
// !DELTA
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// move down until you find the bed
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
// Move down until the probe (or endstop?) is triggered
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
float zPosition = -10;
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
float zPosition = -(Z_MAX_LENGTH + 10);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
line_to_z(zPosition);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// we have to let the planner know where we are right now as it is not where we said to go.
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
// Tell the planner where we ended up - Get this from the stepper handler
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
zPosition += home_retract_mm(Z_AXIS);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
zPosition += home_bump_mm(Z_AXIS);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
line_to_z(zPosition);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
endstops_hit_on_purpose();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
feedrate = homing_feedrate[Z_AXIS]/4;
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
set_homing_bump_feedrate(Z_AXIS);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
zPosition -= home_retract_mm(Z_AXIS) * 2;
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
zPosition -= home_bump_mm(Z_AXIS) * 2;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
line_to_z(zPosition);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
endstops_hit_on_purpose();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// make sure the planner knows where we are as it may be a bit different than we last said to move to
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
sync_plan_position();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
// !DELTA
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
feedrate = XY_TRAVEL_SPEED;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate/60, active_extruder);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
line_to_current_position();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
feedrate = XY_TRAVEL_SPEED;
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
feedrate = xy_travel_speed;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate/60, active_extruder);
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DELTA) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
line_to_current_position();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
feedmultiply = saved_feedmultiply;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
feedrate_multiplier = saved_feedrate_multiplier;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
previous_millis_cmd = millis();
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
refresh_cmd_timeout();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
(float x, float y, float z_before)
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
(float x, float y, float z_before, ProbeAction probe_action=ProbeDeployAndStow, int verbose_level=1)
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// move to right place
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
// Move Z up to the z_before height, then move the probe to the given XY
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z_before);
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
do_blocking_move_to_z(z_before);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
do_blocking_move_to(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
// this also updates current_position
#endif
++++++
#if defined (upstream) && (!defined (Z_PROBE_SLED) && defined (ENABLE_AUTO_BED_LEVELING) )
engage_z_probe();
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
do_blocking_move_to_xy(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER);
#endif
++++++
#if defined (upstream) && (!defined (Z_PROBE_SLED) && defined (ENABLE_AUTO_BED_LEVELING) )
// Engage Z Servo endstop if available
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
// this also updates current_position
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// Z_PROBE_SLED
#endif
++++++
#if defined (marlin4Due) && ((DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY) && )ENABLED(ENABLE_AUTO_BED_LEVELING) )
if (probe_action & ProbeDeploy) deploy_z_probe();
#endif
++++++
#if defined (upstream) && (!defined (Z_PROBE_SLED) && defined (ENABLE_AUTO_BED_LEVELING) )
retract_z_probe();
#endif
++++++
#if defined (marlin4Due) && ((DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY) && )ENABLED(ENABLE_AUTO_BED_LEVELING) )
if (probe_action & ProbeStow) stow_z_probe();
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// Z_PROBE_SLED
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
if (verbose_level > 2) {
      SERIAL_PROTOCOLPGM("Bed X: ");
      SERIAL_PROTOCOL_F(x, 3);
      SERIAL_PROTOCOLPGM(" Y: ");
      SERIAL_PROTOCOL_F(y, 3);
      SERIAL_PROTOCOLPGM(" Z: ");
      SERIAL_PROTOCOL_F(measured_z, 3);
      SERIAL_PROTOCOLPGM(" real Z: ");
      SERIAL_PROTOCOL(st_get_position(Z_AXIS));
      SERIAL_EOL;
    }
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOLPGM(MSG_BED);
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
(!((axis_known_position[X_AXIS]) && (axis_known_position[Y_AXIS])))
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
(!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS])
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
                       current_position[Y_AXIS],
                       current_position[Z_AXIS]);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Z_PROBE_SLED) && Z_RAISE_AFTER_PROBING > 0 )
do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Z_PROBE_SLED) && Z_RAISE_AFTER_PROBING > 0 )
// raise Z
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
// Dock sled a bit closer to ensure proper capturing
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
digitalWrite(SLED_PIN, LOW);
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
digitalWrite(SERVO0_PIN, LOW);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Z_PROBE_SLED) && Z_RAISE_AFTER_PROBING > 0 )
// raise Z
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
digitalWrite(SERVO0_PIN, LOW);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
float z_loc = current_position[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
(current_position[Z_AXIS] < (Z_RAISE_BEFORE_PROBING + 5))
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
(z_loc < Z_RAISE_BEFORE_PROBING + 5)
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
else
     z_loc = current_position[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
else
     z_loc = current_position[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
                       Y_PROBE_OFFSET_FROM_EXTRUDER, z_loc);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset, current_position[Y_AXIS], z_loc);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
// this also updates current_position
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
digitalWrite(SLED_PIN, HIGH);
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
digitalWrite(SERVO0_PIN, HIGH);
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
float z_loc = current_position[Z_AXIS];
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
// this also updates current_position
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
digitalWrite(SERVO0_PIN, HIGH);
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
int z_loc;
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
float oldXpos = current_position[X_AXIS];
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
do_blocking_move_to_x(oldXpos);
#endif
++++++
#if defined (upstream)
/* -*- c++ -*- */
#endif
++++++
#if defined (marlin4Due)
/**
 * Marlin Firmware
 *
 * Based on Sprinter and grbl.
 * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * About Marlin
 *
 * This firmware is a mashup between Sprinter and grbl.
 *  - https://github.com/kliment/Sprinter
 *  - https://github.com/simen/grbl/tree
 *
 * It has preliminary support for Matthew Roberts advance algorithm
 *  - http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
 */
#endif
++++++
#if defined (upstream)
/*
    Reprap firmware based on Sprinter and grbl.
 Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#endif
++++++
#if defined (marlin4Due) && ENABLED(MESH_BED_LEVELING)
#include "mesh_bed_leveling.h"
#endif
++++++
#if defined (upstream)
#include "motion_control.h"
#endif
++++++
#if defined (upstream)
#include "ConfigurationStore.h"
#endif
++++++
#if defined (marlin4Due)
#include "configuration_store.h"
#endif
++++++
#if defined (upstream) && defined (BLINKM)
#include "BlinkM.h"
#endif
++++++
#if defined (marlin4Due)
#include "buzzer.h"
#endif
++++++
#if defined (marlin4Due) && ENABLED(BLINKM)
#include "blinkm.h"
#endif
++++++
#if defined (upstream) && NUM_SERVOS > 0
#include "Servo.h"
#endif
++++++
#if defined (marlin4Due) && HAS_SERVOS
#include "servo.h"
#endif
++++++
#if defined (upstream)
#define VERSION_STRING  "1.0.2"
#endif
++++++
#if defined (marlin4Due)
/**
 * Look here for descriptions of G-codes:
 *  - http://linuxcnc.org/handbook/gcode/g-code.html
 *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
 *
 * Help us document these G-codes online:
 *  - http://www.marlinfirmware.org/index.php/G-Code
 *  - http://reprap.org/wiki/G-code
 *
 * -----------------
 * Implemented Codes
 * -----------------
 *
 * "G" Codes
 *
 * G0  -> G1
 * G1  - Coordinated Movement X Y Z E
 * G2  - CW ARC
 * G3  - CCW ARC
 * G4  - Dwell S<seconds> or P<milliseconds>
 * G10 - retract filament according to settings of M207
 * G11 - retract recover filament according to settings of M208
 * G28 - Home one or more axes
 * G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
 * G30 - Single Z Probe, probes bed at current XY location.
 * G31 - Dock sled (Z_PROBE_SLED only)
 * G32 - Undock sled (Z_PROBE_SLED only)
 * G90 - Use Absolute Coordinates
 * G91 - Use Relative Coordinates
 * G92 - Set current position to coordinates given
 *
 * "M" Codes
 *
 * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
 * M1   - Same as M0
 * M17  - Enable/Power all stepper motors
 * M18  - Disable all stepper motors; same as M84
 * M20  - List SD card
 * M21  - Init SD card
 * M22  - Release SD card
 * M23  - Select SD file (M23 filename.g)
 * M24  - Start/resume SD print
 * M25  - Pause SD print
 * M26  - Set SD position in bytes (M26 S12345)
 * M27  - Report SD print status
 * M28  - Start SD write (M28 filename.g)
 * M29  - Stop SD write
 * M30  - Delete file from SD (M30 filename.g)
 * M31  - Output time since last M109 or SD card start to serial
 * M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
 *        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
 *        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).
 *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
 * M33  - Get the longname version of a path
 * M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
 * M48  - Measure Z_Probe repeatability. M48 [P # of points] [X position] [Y position] [V_erboseness #] [E_ngage Probe] [L # of legs of travel]
 * M80  - Turn on Power Supply
 * M81  - Turn off Power Supply
 * M82  - Set E codes absolute (default)
 * M83  - Set E codes relative while in Absolute Coordinates (G90) mode
 * M84  - Disable steppers until next move,
 *        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
 * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
 * M92  - Set axis_steps_per_unit - same syntax as G92
 * M104 - Set extruder target temp
 * M105 - Read current temp
 * M106 - Fan on
 * M107 - Fan off
 * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
 *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
 *        IF AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
 * M110 - Set the current line number
 * M111 - Set debug flags with S<mask>. See flag bits defined in Marlin.h.
 * M112 - Emergency stop
 * M114 - Output current position to serial port
 * M115 - Capabilities string
 * M117 - Display a message on the controller screen
 * M119 - Output Endstop status to serial port
 * M120 - Enable endstop detection
 * M121 - Disable endstop detection
 * M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
 * M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
 * M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 * M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
 * M140 - Set bed target temp
 * M145 - Set the heatup state H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
 * M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
 * M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
 *        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
 * M200 - set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).:D<millimeters>- 
 * M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
 * M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
 * M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 * M204 - Set default acceleration: P for Printing moves, R for Retract only (no X, Y, Z) moves and T for Travel (non printing) moves (ex. M204 P800 T3000 R9000) in mm/sec^2
 * M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
 * M206 - Set additional homing offset
 * M207 - Set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
 * M208 - Set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
 * M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
 * M218 - Set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
 * M220 - Set speed factor override percentage: S<factor in percent>
 * M221 - Set extrude factor override percentage: S<factor in percent>
 * M226 - Wait until the specified pin reaches the state required: P<pin number> S<pin state>
 * M240 - Trigger a camera to take a photograph
 * M250 - Set LCD contrast C<contrast value> (value 0..63)
 * M280 - Set servo position absolute. P: servo index, S: angle or microseconds
 * M300 - Play beep sound S<frequency Hz> P<duration ms>
 * M301 - Set PID parameters P I and D
 * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
 * M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
 * M304 - Set bed PID parameters P I and D
 * M380 - Activate solenoid on active extruder
 * M381 - Disable all solenoids
 * M400 - Finish all moves
 * M401 - Lower z-probe if present
 * M402 - Raise z-probe if present
 * M404 - N<dia in mm> Enter the nominal filament width (3mm, 1.75mm ) or will display nominal filament width without parameters
 * M405 - Turn on Filament Sensor extrusion control.  Optional D<delay in cm> to set delay in centimeters between sensor and extruder
 * M406 - Turn off Filament Sensor extrusion control
 * M407 - Display measured filament diameter
 * M410 - Quickstop. Abort all the planned moves
 * M420 - Enable/Disable Mesh Leveling (with current values) S1=enable S0=disable
 * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<mm> Y<mm> Z<mm>
 * M428 - Set the home_offset logically based on the current_position
 * M500 - Store parameters in EEPROM
 * M501 - Read parameters from EEPROM (if you need reset them after you changed them temporarily).
 * M502 - Revert to the default "factory settings". You still need to store them in EEPROM afterwards if you want to.
 * M503 - Print the current settings (from memory not from EEPROM). Use S0 to leave off headings.
 * M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
 * M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
 * M665 - Set delta configurations: L<diagonal rod> R<delta radius> S<segments/s>
 * M666 - Set delta endstop adjustment
 * M605 - Set dual x-carriage movement mode: S<mode> [ X<duplication x-offset> R<duplication temp offset> ]
 * M907 - Set digital trimpot motor current using axis codes.
 * M908 - Control digital trimpot directly.
 * M350 - Set microstepping mode.
 * M351 - Toggle MS1 MS2 pins directly.
 *
 * ************ SCARA Specific - This can change to suit future G-code regulations
 * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
 * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
 * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
 * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
 * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
 * M365 - SCARA calibration: Scaling factor, X, Y, Z axis
 * ************* SCARA End ***************
 *
 * ************ Custom codes - This can change to suit future G-code regulations
 * M100 - Watch Free Memory (For Debugging Only)
 * M851 - Set probe's Z offset (mm above extruder -- The value will always be negative)


 * M928 - Start SD logging (M928 filename.g) - ended by M29
 * M999 - Restart after being stopped by error
 *
 * "T" Codes
 *
 * T0-T3 - Select a tool by index (usually an extruder) [ F<mm/min> ]
 *
 */
#endif
++++++
#if defined (upstream)
// look here for descriptions of G-codes: http://linuxcnc.org/handbook/gcode/g-code.html
#endif
++++++
#if defined (marlin4Due) && ENABLED(M100_FREE_MEMORY_WATCHER)
void gcode_M100();
#endif
++++++
#if defined (upstream)
// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
#endif
++++++
#if defined (upstream)
float homing_feedrate[] = HOMING_FEEDRATE;
#endif
++++++
#if defined (marlin4Due)
bool Running = true;
#endif
++++++
#if defined (upstream)
int feedmultiply=100;
#endif
++++++
#if defined (marlin4Due)
int feedrate_multiplier = 100;
#endif
++++++
#if defined (upstream)
int saved_feedmultiply;
#endif
++++++
#if defined (marlin4Due)
int saved_feedrate_multiplier;
#endif
++++++
#if defined (upstream)
int extrudemultiply=100;
#endif
++++++
#if defined (marlin4Due)
int extruder_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
#endif
++++++
#if defined (upstream)
//100->1 200->2
#endif
++++++
#if defined (upstream)
float filament_size[EXTRUDERS] = { DEFAULT_NOMINAL_FILAMENT_DIA
  #if EXTRUDERS > 1
      , DEFAULT_NOMINAL_FILAMENT_DIA
    #if EXTRUDERS > 2
       , DEFAULT_NOMINAL_FILAMENT_DIA
    #endif
  #endif
};
#endif
++++++
#if defined (marlin4Due)
float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA);
#endif
++++++
#if defined (upstream)
float volumetric_multiplier[EXTRUDERS] = {1.0
  #if EXTRUDERS > 1
    , 1.0
    #if EXTRUDERS > 2
      , 1.0
    #endif
  #endif
};
#endif
++++++
#if defined (marlin4Due)
float volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);
#endif
++++++
#if defined (upstream)
float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };
#endif
++++++
#if defined (marlin4Due)
float home_offset[3] = { 0 };
#endif
++++++
#if defined (upstream)
float add_homing[3]={0,0,0};
#endif
++++++
#if defined (upstream) && defined (DELTA)
float endstop_adj[3]={0,0,0};
#endif
++++++
#if defined (upstream)
bool axis_known_position[3] = {false, false, false};
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && !defined (DUAL_X_CARRIAGE) )
#define NUM_EXTRUDER_OFFSETS 2
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
#define NUM_EXTRUDER_OFFSETS 3
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
float extruder_offset[NUM_EXTRUDER_OFFSETS][EXTRUDERS] = {
#if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)
  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y
#endif
};
#endif
++++++
#if defined (upstream) && defined (SERVO_ENDSTOPS)
int servo_endstops[] = SERVO_ENDSTOPS;
#endif
++++++
#if defined (marlin4Due)
bool cancel_heatup = false;
#endif
++++++
#if defined (upstream) && defined (SERVO_ENDSTOPS)
int servo_endstop_angles[] = SERVO_ENDSTOP_ANGLES;
#endif
++++++
#if defined (marlin4Due)
const char errormagic[] PROGMEM = "Error:";
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
int xy_travel_speed = XY_TRAVEL_SPEED;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA))
float z_endstop_adj = 0;
#endif
++++++
#if defined (marlin4Due)
// Extruder offsets
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && !defined (EXTRUDER_OFFSET_X) )
#define EXTRUDER_OFFSET_X { 0 }
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && !defined (EXTRUDER_OFFSET_Y) )
#define EXTRUDER_OFFSET_Y { 0 }
#endif
++++++
#if defined (marlin4Due) && EXTRUDERS > 1
float extruder_offset[][EXTRUDERS] = {
    EXTRUDER_OFFSET_X,
    EXTRUDER_OFFSET_Y
    #if ENABLED(DUAL_X_CARRIAGE)
      , { 0 } // supports offsets in XYZ plane
    #endif
  };
#endif
++++++
#if defined (marlin4Due) && HAS_SERVO_ENDSTOPS
const int servo_endstop_id[] = SERVO_ENDSTOP_IDS;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
bool retracted[EXTRUDERS]={false
    #if EXTRUDERS > 1
    , false
     #if EXTRUDERS > 2
      , false
     #endif
  #endif
  };
#endif
++++++
#if defined (marlin4Due) && ENABLED(FWRETRACT)
bool retracted[EXTRUDERS] = { false };
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
bool retracted_swap[EXTRUDERS]={false
    #if EXTRUDERS > 1
    , false
     #if EXTRUDERS > 2
      , false
     #endif
  #endif
  };
#endif
++++++
#if defined (marlin4Due) && ENABLED(FWRETRACT)
bool retracted_swap[EXTRUDERS] = { false };
#endif
++++++
#if defined (upstream) && (defined (ULTIPANEL) && defined (PS_DEFAULT_OFF) )
bool powersupply = false;
#endif
++++++
#if defined (marlin4Due)
// FWRETRACT
#endif
++++++
#if defined (upstream) && (!defined (PS_DEFAULT_OFF) && defined (ULTIPANEL) )
bool powersupply = true;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && HAS_POWER_SWITCH)
bool powersupply = 
    #if ENABLED(PS_DEFAULT_OFF)
      false
    #else
      true
    #endif
  ;
#endif
++++++
#if defined (upstream) && defined (DELTA)
float delta[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (marlin4Due) && ENABLED(DELTA)
float delta[3] = { 0 };
#endif
++++++
#if defined (marlin4Due) && ENABLED(DELTA)
float endstop_adj[3] = { 0 };
#endif
++++++
#if defined (upstream) && defined (DELTA)
float delta_tower3_x= 0.0;
#endif
++++++
#if defined (marlin4Due) && ENABLED(DELTA)
float delta_tower3_x = 0;
#endif
++++++
#if defined (upstream) && defined (SCARA)
// Build size scaling
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
int delta_grid_spacing[2] = { 0, 0 };
#endif
++++++
#if defined (marlin4Due) && !ENABLED(DELTA)
static bool home_all_axis = true;
#endif
++++++
#if defined (marlin4Due) && ENABLED(SCARA)
float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
#endif
++++++
#if defined (upstream)
bool cancel_heatup = false ;
#endif
++++++
#if defined (upstream)
const char errormagic[] PROGMEM = "Error:";
#endif
++++++
#if defined (marlin4Due) && ENABLED(FILAMENT_RUNOUT_SENSOR)
static bool filrunoutEnqueued = false;
#endif
++++++
#if defined (upstream)
const char echomagic[] PROGMEM = "echo:";
#endif
++++++
#if defined (upstream) && !defined (DELTA)
static float delta[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (upstream)
static float offset[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (upstream)
static int bufindr = 0;
#endif
++++++
#if defined (marlin4Due) && HAS_SERVOS
Servo servo[NUM_SERVOS];
#endif
++++++
#if defined (upstream)
static int bufindw = 0;
#endif
++++++
#if defined (upstream) && NUM_SERVOS > 0
Servo servos[NUM_SERVOS];
#endif
++++++
#if defined (upstream)
bool CooldownNoWait = true;
#endif
++++++
#if defined (upstream)
//=============================Routines======================================
#endif
++++++
#if defined (marlin4Due)
//================================ Functions ================================
#endif
++++++
#if defined (upstream)
void get_arc_coordinates();
#endif
++++++
#if defined (marlin4Due)
void process_next_command();
#endif
++++++
#if defined (marlin4Due)
void serial_echopair_P(const char *s_P, int v)           { serialprintPGM(s_P); SERIAL_ECHO(v); }
#endif
++++++
#if defined (marlin4Due) && ENABLED(PREVENT_DANGEROUS_EXTRUDE)
float extrude_min_temp = EXTRUDE_MINTEMP;
#endif
++++++
#if defined (marlin4Due) && defined (__AVR__)
// HAL for Due
#endif
++++++
#if defined (upstream)
//adds an command to the main command buffer
#endif
++++++
#if defined (marlin4Due)
/**
 * Inject the next command from the command queue, when possible
 * Return false only if no command was pending
 */
#endif
++++++
#if defined (upstream)
//thats really done in a non-safe way.
#endif
++++++
#if defined (marlin4Due)
static bool drain_queued_commands_P() {
  if (!queued_commands_P) return false;

  // Get the next 30 chars from the sequence of gcodes to run
  char cmd[30];
  strncpy_P(cmd, queued_commands_P, sizeof(cmd) - 1);
  cmd[sizeof(cmd) - 1] = '\0';

  // Look for the end of line, or the end of sequence
  size_t i = 0;
  char c;
  while((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
  cmd[i] = '\0';
  if (enqueuecommand(cmd)) {      // buffer was not full (else we will retry later)
    if (c)
      queued_commands_P += i + 1; // move to next command
    else
      queued_commands_P = NULL;   // will have no more commands in the sequence
  }
  return true;
}
#endif
#if defined (marlin4Due)
static bool drain_queued_commands_P() {
  if (!queued_commands_P) return false;

  // Get the next 30 chars from the sequence of gcodes to run
  char cmd[30];
  strncpy_P(cmd, queued_commands_P, sizeof(cmd) - 1);
  cmd[sizeof(cmd) - 1] = '\0';

  // Look for the end of line, or the end of sequence
  size_t i = 0;
  char c;
  while((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
  cmd[i] = '\0';
  if (enqueuecommand(cmd)) {      // buffer was not full (else we will retry later)
    if (c)
      queued_commands_P += i + 1; // move to next command
    else
      queued_commands_P = NULL;   // will have no more commands in the sequence
  }
  return true;
}
#endif
++++++
#if defined (upstream)
//needs overworking someday
#endif
++++++
#if defined (marlin4Due)
/**
 * Record one or many commands to run from program memory.
 * Aborts the current queue, if any.
 * Note: drain_queued_commands_P() must be called repeatedly to drain the commands afterwards
 */
#endif
++++++
#if defined (upstream)
void enquecommand(const char *cmd)
{
  if(buflen < BUFSIZE)
  {
    //this is dangerous if a mixing of serial and this happens
    strcpy(&(cmdbuffer[bufindw][0]),cmd);
    SERIAL_ECHO_START;
    SERIAL_ECHOPGM(MSG_Enqueing);
    SERIAL_ECHO(cmdbuffer[bufindw]);
    SERIAL_ECHOLNPGM("\"");
    bufindw= (bufindw + 1)%BUFSIZE;
    buflen += 1;
  }
}
#endif
++++++
#if defined (marlin4Due)
void enqueuecommands_P(const char* pgcode) {
  queued_commands_P = pgcode;
  drain_queued_commands_P(); // first command executed asap (when possible)
}
#endif
++++++
#if defined (upstream)
void enquecommand_P(const char *cmd)
{
  if(buflen < BUFSIZE)
  {
    //this is dangerous if a mixing of serial and this happens
    strcpy_P(&(cmdbuffer[bufindw][0]),cmd);
    SERIAL_ECHO_START;
    SERIAL_ECHOPGM(MSG_Enqueing);
    SERIAL_ECHO(cmdbuffer[bufindw]);
    SERIAL_ECHOLNPGM("\"");
    bufindw= (bufindw + 1)%BUFSIZE;
    buflen += 1;
  }
}
#endif
++++++
#if defined (marlin4Due)
/**
 * Copy a command directly into the main command buffer, from RAM.
 *
 * This is done in a non-safe way and needs a rework someday.
 * Returns false if it doesn't add any command
 */
#endif
++++++
#if defined (marlin4Due)
void setup_filrunoutpin() {
  #if HAS_FILRUNOUT
    SET_INPUT(FILRUNOUT_PIN);
    #ifdef ENDSTOPPULLUP_FIL_RUNOUT
      PULLUP(FILRUNOUT_PIN, HIGH);
    #endif
  #endif
}
#endif
++++++
#if defined (marlin4Due)
/**
 * Stepper Reset (RigidBoard, et.al.)
 */
#endif
++++++
#if defined (marlin4Due) && HAS_STEPPER_RESET
void disableStepperDrivers() {
    pinMode(STEPPER_RESET_PIN, OUTPUT);
    digitalWrite(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
  }
#endif
++++++
#if defined (marlin4Due)
/**
 * Marlin entry-point: Set up before the program loop
 *  - Set up the kill pin, filament runout, power hold
 *  - Start the serial port
 *  - Print startup messages and diagnostics
 *  - Get EEPROM or default settings
 *  - Initialize managers for:
 *     temperature
 *     planner
 *     watchdog
 *     stepper
 *     photo pin
 *     servos
 *     LCD controller
 *     Digipot I2C
 *     Z probe sled
 *     status LEDs
 */
#endif
++++++
#if defined (marlin4Due)
/**
 * The main Marlin program loop
 *
 *  - Save or log commands to SD
 *  - Process available commands (if not saving)
 *  - Call heater manager
 *  - Call inactivity manager
 *  - Call endstop manager
 *  - Call LCD update
 */
#endif
++++++
#if defined (marlin4Due)
void gcode_line_error(const char *err, bool doFlush=true) {
  SERIAL_ERROR_START;
  serialprintPGM(err);
  SERIAL_ERRORLN(gcode_LastN);
  //Serial.println(gcode_N);
  if (doFlush) FlushSerialRequestResend();
  serial_count = 0;
}
#endif
++++++
#if defined (marlin4Due)
bool code_has_value() {
  int i = 1;
  char c = seen_pointer[i];
  if (c == '-' || c == '+') c = seen_pointer[++i];
  if (c == '.') c = seen_pointer[++i];
  return (c >= '0' && c <= '9');
}
#endif
++++++
#if defined (marlin4Due)
int16_t code_value_short() { return (int16_t)strtol(seen_pointer + 1, NULL, 10); }
#endif
++++++
#if defined (upstream)
XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);
#endif
++++++
#if defined (marlin4Due)
XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
#endif
++++++
#if defined (upstream) && (defined (DUAL_X_CARRIAGE) && (EXTRUDERS == 1 || defined(COREXY) \
      || !defined(X2_ENABLE_PIN) || !defined(X2_STEP_PIN) || !defined(X2_DIR_PIN) \
      || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \
      || !defined(X_MAX_PIN) || X_MAX_PIN < 0 &)
#error "Missing or invalid definitions for DUAL_X_CARRIAGE mode."
#endif
++++++
#if defined (upstream) && (defined (DUAL_X_CARRIAGE) && (X_HOME_DIR != -1 || X2_HOME_DIR != 1 &)
#error "Please use canonical x-carriage assignment"
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
static unsigned long delayed_move_time = 0;
#endif
++++++
#if defined (marlin4Due) && ENABLED(DUAL_X_CARRIAGE)
static millis_t delayed_move_time = 0;
#endif
++++++
#if defined (upstream)
static void axis_is_at_home(int axis) {
#ifdef DUAL_X_CARRIAGE
  if (axis == X_AXIS) {
    if (active_extruder != 0) {
      current_position[X_AXIS] = x_home_pos(active_extruder);
      min_pos[X_AXIS] =          X2_MIN_POS;
      max_pos[X_AXIS] =          max(extruder_offset[X_AXIS][1], X2_MAX_POS);
      return;
    }
    else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
      current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homing[X_AXIS];
      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homing[X_AXIS];
      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homing[X_AXIS],
                                  max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
      return;
    }
  }
#endif
#ifdef SCARA
   float homeposition[3];
   char i;
   
   if (axis < 2)
   {
   
     for (i=0; i<3; i++)
     {
        homeposition[i] = base_home_pos(i); 
     }  
	// SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);
   //  SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);
   // Works out real Homeposition angles using inverse kinematics, 
   // and calculates homing offset using forward kinematics
     calculate_delta(homeposition);
     
    // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
     for (i=0; i<2; i++)
     {
        delta[i] -= add_homing[i];
     } 
     
    // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homing[X_AXIS]);
	// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homing[Y_AXIS]);
    // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
      
     calculate_SCARA_forward_Transform(delta);
     
    // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
    current_position[axis] = delta[axis];
    
    // SCARA home positions are based on configuration since the actual limits are determined by the 
    // inverse kinematic transform.
    min_pos[axis] =          base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));
    max_pos[axis] =          base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));
   } 
   else
   {
      current_position[axis] = base_home_pos(axis) + add_homing[axis];
      min_pos[axis] =          base_min_pos(axis) + add_homing[axis];
      max_pos[axis] =          base_max_pos(axis) + add_homing[axis];
   }
#else
  current_position[axis] = base_home_pos(axis) + add_homing[axis];
  min_pos[axis] =          base_min_pos(axis) + add_homing[axis];
  max_pos[axis] =          base_max_pos(axis) + add_homing[axis];
#endif
}
#endif
++++++
#if defined (marlin4Due)
static void set_axis_is_at_home(AxisEnum axis) {

  #if ENABLED(DUAL_X_CARRIAGE)
    if (axis == X_AXIS) {
      if (active_extruder != 0) {
        current_position[X_AXIS] = x_home_pos(active_extruder);
                 min_pos[X_AXIS] = X2_MIN_POS;
                 max_pos[X_AXIS] = max(extruder_offset[X_AXIS][1], X2_MAX_POS);
        return;
      }
      else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
        float xoff = home_offset[X_AXIS];
        current_position[X_AXIS] = base_home_pos(X_AXIS) + xoff;
                 min_pos[X_AXIS] = base_min_pos(X_AXIS) + xoff;
                 max_pos[X_AXIS] = min(base_max_pos(X_AXIS) + xoff, max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
        return;
      }
    }
  #endif

  #if ENABLED(SCARA)
   
    if (axis == X_AXIS || axis == Y_AXIS) {

      float homeposition[3];
      for (int i = 0; i < 3; i++) homeposition[i] = base_home_pos(i);

      // SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);
      // SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);
      // Works out real Homeposition angles using inverse kinematics, 
      // and calculates homing offset using forward kinematics
      calculate_delta(homeposition);
     
      // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);
      // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
      for (int i = 0; i < 2; i++) delta[i] -= home_offset[i];
     
      // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(home_offset[X_AXIS]);
      // SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(home_offset[Y_AXIS]);
      // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
      // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
      
      calculate_SCARA_forward_Transform(delta);
     
      // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);
      // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
      current_position[axis] = delta[axis];
    
      // SCARA home positions are based on configuration since the actual limits are determined by the 
      // inverse kinematic transform.
      min_pos[axis] = base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));
      max_pos[axis] = base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));
    }
    else
  #endif
  {
    current_position[axis] = base_home_pos(axis) + home_offset[axis];
    min_pos[axis] = base_min_pos(axis) + home_offset[axis];
    max_pos[axis] = base_max_pos(axis) + home_offset[axis];

    #if ENABLED(ENABLE_AUTO_BED_LEVELING) && Z_HOME_DIR < 0
      if (axis == Z_AXIS) current_position[Z_AXIS] -= zprobe_zoffset;
    #endif
  }
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(DELTA) || ENABLED(SCARA))
inline void sync_plan_position_delta() {
    calculate_delta(current_position);
    plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
  }
#endif
++++++
#if defined (marlin4Due)
inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
/**
     * Calculate delta, start a line, and set current_position to destination
     */
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
// not AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(AUTO_BED_LEVELING_GRID) )
// !DELTA
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(AUTO_BED_LEVELING_GRID) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
// !AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
// !AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
/**
   *  Plan a move to (X, Y, Z) and set the current_position
   *  The final current_position may not be the one that was requested
   */
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
static void do_blocking_move_relative(float offset_x, float offset_y, float offset_z) {
    do_blocking_move_to(current_position[X_AXIS] + offset_x, current_position[Y_AXIS] + offset_y, current_position[Z_AXIS] + offset_z);
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
inline void do_blocking_move_to_xy(float x, float y) { do_blocking_move_to(x, y, current_position[Z_AXIS]); }
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
static void setup_for_endstop_move() {
    saved_feedrate = feedrate;
    saved_feedmultiply = feedmultiply;
    feedmultiply = 100;
    previous_millis_cmd = millis();

    enable_endstops(true);
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
inline void do_blocking_move_to_x(float x) { do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS]); }
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
static void engage_z_probe() {
    // Engage Z Servo endstop if enabled
    #ifdef SERVO_ENDSTOPS
    if (servo_endstops[Z_AXIS] > -1) {
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
        servos[servo_endstops[Z_AXIS]].attach(0);
#endif
        servos[servo_endstops[Z_AXIS]].write(servo_endstop_angles[Z_AXIS * 2]);
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
        delay(PROBE_SERVO_DEACTIVATION_DELAY);
        servos[servo_endstops[Z_AXIS]].detach();
#endif
    }
    #endif
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
static void deploy_z_probe() {

    #if HAS_SERVO_ENDSTOPS

      // Engage Z Servo endstop if enabled
      if (servo_endstop_id[Z_AXIS] >= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);

    #elif ENABLED(Z_PROBE_ALLEN_KEY)
      feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE;

      // If endstop is already false, the probe is deployed
      #if ENABLED(Z_PROBE_ENDSTOP)
        bool z_probe_endstop = (READ(Z_PROBE_PIN) != Z_PROBE_ENDSTOP_INVERTING);
        if (z_probe_endstop)
      #else
        bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
        if (z_min_endstop)
      #endif
        {

          // Move to the start position to initiate deployment
          destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_X;
          destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Y;
          destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Z;
          prepare_move_raw(); // this will also set_current_to_destination

          // Move to engage deployment
          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE) {
            feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE;
          }
          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_X != Z_PROBE_ALLEN_KEY_DEPLOY_1_X) {
            destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_X;
          }
          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Y != Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) {
            destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Y;
          }
          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Z != Z_PROBE_ALLEN_KEY_DEPLOY_1_Z) {
            destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Z;
          }
          prepare_move_raw();

          #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE) {
              feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;
            }

            // Move to trigger deployment
            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE) {
              feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;
            }
            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_X != Z_PROBE_ALLEN_KEY_DEPLOY_2_X) {
              destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_X;
            }
            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Y != Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) {
              destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Y;
            }
            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Z != Z_PROBE_ALLEN_KEY_DEPLOY_2_Z) {
              destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Z;
            }
            prepare_move_raw();
          #endif
      }

      // Partially Home X,Y for safety
      destination[X_AXIS] = destination[X_AXIS]*0.75;
      destination[Y_AXIS] = destination[Y_AXIS]*0.75;
      prepare_move_raw(); // this will also set_current_to_destination

      st_synchronize();

      #if ENABLED(Z_PROBE_ENDSTOP)
        z_probe_endstop = (READ(Z_PROBE_PIN) != Z_PROBE_ENDSTOP_INVERTING);
        if (z_probe_endstop)
      #else
        z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
        if (z_min_endstop)
      #endif
        {
          if (IsRunning()) {
            SERIAL_ERROR_START;
            SERIAL_ERRORLNPGM("Z-Probe failed to engage!");
            LCD_ALERTMESSAGEPGM("Err: ZPROBE");
          }
          Stop();
        }

    #endif // Z_PROBE_ALLEN_KEY

  }
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
static void retract_z_probe() {
    // Retract Z Servo endstop if enabled
    #ifdef SERVO_ENDSTOPS
    if (servo_endstops[Z_AXIS] > -1) {
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
        servos[servo_endstops[Z_AXIS]].attach(0);
#endif
        servos[servo_endstops[Z_AXIS]].write(servo_endstop_angles[Z_AXIS * 2 + 1]);
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
        delay(PROBE_SERVO_DEACTIVATION_DELAY);
        servos[servo_endstops[Z_AXIS]].detach();
#endif
    }
    #endif
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
static void stow_z_probe(bool doRaise=true) {

    #if HAS_SERVO_ENDSTOPS

      // Retract Z Servo endstop if enabled
      if (servo_endstop_id[Z_AXIS] >= 0) {

        #if Z_RAISE_AFTER_PROBING > 0
          if (doRaise) {
            do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING); // this also updates current_position
            st_synchronize();
          }
        #endif

        // Change the Z servo angle
        servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][1]);
      }

    #elif ENABLED(Z_PROBE_ALLEN_KEY)

      // Move up for safety
      feedrate = Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE;

      #if Z_RAISE_AFTER_PROBING > 0
        destination[Z_AXIS] = current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING;
        prepare_move_raw(); // this will also set_current_to_destination
      #endif

      // Move to the start position to initiate retraction
      destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_X;
      destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Y;
      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Z;
      prepare_move_raw();

      // Move the nozzle down to push the probe into retracted position
      if (Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE) {
        feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;
      }
      if (Z_PROBE_ALLEN_KEY_STOW_2_X != Z_PROBE_ALLEN_KEY_STOW_1_X) {
        destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_X;
      }
      if (Z_PROBE_ALLEN_KEY_STOW_2_Y != Z_PROBE_ALLEN_KEY_STOW_1_Y) {
        destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Y;
      }
      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Z;
      prepare_move_raw();
      
      // Move up for safety
      if (Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE) {
        feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;
      }
      if (Z_PROBE_ALLEN_KEY_STOW_3_X != Z_PROBE_ALLEN_KEY_STOW_2_X) {
        destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_X;
      }
      if (Z_PROBE_ALLEN_KEY_STOW_3_Y != Z_PROBE_ALLEN_KEY_STOW_2_Y) {
        destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Y;
      }
      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Z;
      prepare_move_raw();
      
      // Home XY for safety
      feedrate = homing_feedrate[X_AXIS]/2;
      destination[X_AXIS] = 0;
      destination[Y_AXIS] = 0;
      prepare_move_raw(); // this will also set_current_to_destination
      
      st_synchronize();

      #if ENABLED(Z_PROBE_ENDSTOP)
        bool z_probe_endstop = (READ(Z_PROBE_PIN) != Z_PROBE_ENDSTOP_INVERTING);
        if (!z_probe_endstop)
      #else
        bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
        if (!z_min_endstop)
      #endif
        {
          if (IsRunning()) {
            SERIAL_ERROR_START;
            SERIAL_ERRORLNPGM("Z-Probe failed to retract!");
            LCD_ALERTMESSAGEPGM("Err: ZPROBE");
          }
          Stop();
        }

    #endif // Z_PROBE_ALLEN_KEY

  }
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
/// Probe bed height at position (x,y), returns the measured z value
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
enum ProbeAction {
    ProbeStay          = 0,
    ProbeDeploy        = BIT(0),
    ProbeStow          = BIT(1),
    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)
  };
#endif
++++++
#if defined (upstream)
// #ifdef ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
/**
     * All DELTA leveling in the Marlin uses NONLINEAR_BED_LEVELING
     */
#endif
++++++
#if defined (upstream)
static void homeaxis(int axis) {
#define HOMEAXIS_DO(LETTER) \
  ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))

  if (axis==X_AXIS ? HOMEAXIS_DO(X) :
      axis==Y_AXIS ? HOMEAXIS_DO(Y) :
      axis==Z_AXIS ? HOMEAXIS_DO(Z) :
      0) {
    int axis_home_dir = home_dir(axis);
#ifdef DUAL_X_CARRIAGE
    if (axis == X_AXIS)
      axis_home_dir = x_home_dir(active_extruder);
#endif

    current_position[axis] = 0;
    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);


#ifndef Z_PROBE_SLED
    // Engage Servo endstop if enabled
    #ifdef SERVO_ENDSTOPS
      #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
        if (axis==Z_AXIS) {
          engage_z_probe();
        }
	    else
      #endif
      if (servo_endstops[axis] > -1) {
        servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2]);
      }
    #endif
#endif // Z_PROBE_SLED
    destination[axis] = 1.5 * max_length(axis) * axis_home_dir;
    feedrate = homing_feedrate[axis];
    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
    st_synchronize();

    current_position[axis] = 0;
    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
    destination[axis] = -home_retract_mm(axis) * axis_home_dir;
    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
    st_synchronize();

    destination[axis] = 2*home_retract_mm(axis) * axis_home_dir;
#ifdef DELTA
    feedrate = homing_feedrate[axis]/10;
#else
    feedrate = homing_feedrate[axis]/2 ;
#endif
    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
    st_synchronize();
#ifdef DELTA
    // retrace by the amount specified in endstop_adj
    if (endstop_adj[axis] * axis_home_dir < 0) {
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      destination[axis] = endstop_adj[axis];
      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
      st_synchronize();
    }
#endif
    axis_is_at_home(axis);
    destination[axis] = current_position[axis];
    feedrate = 0.0;
    endstops_hit_on_purpose();
    axis_known_position[axis] = true;

    // Retract Servo endstop if enabled
    #ifdef SERVO_ENDSTOPS
      if (servo_endstops[axis] > -1) {
        servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2 + 1]);
      }
    #endif
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
  #ifndef Z_PROBE_SLED
    if (axis==Z_AXIS) retract_z_probe();
  #endif
#endif

  }
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
static void extrapolate_one_point(int x, int y, int xdir, int ydir) {
      if (bed_level[x][y] != 0.0) {
        return;  // Don't overwrite good values.
      }
      float a = 2*bed_level[x+xdir][y] - bed_level[x+xdir*2][y];  // Left to right.
      float b = 2*bed_level[x][y+ydir] - bed_level[x][y+ydir*2];  // Front to back.
      float c = 2*bed_level[x+xdir][y+ydir] - bed_level[x+xdir*2][y+ydir*2];  // Diagonal.
      float median = c;  // Median is robust (ignores outliers).
      if (a < b) {
        if (b < c) median = b;
        if (c < a) median = a;
      } else {  // b <= a
        if (c < b) median = b;
        if (a < c) median = a;
      }
      bed_level[x][y] = median;
    }
#endif
++++++
#if defined (upstream)
#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
// Fill in the unprobed points (corners of circular print surface)
#endif
++++++
#if defined (upstream)
void refresh_cmd_timeout(void)
{
  previous_millis_cmd = millis();
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
// using linear extrapolation, away from the center.
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
void retract(bool retracting, bool swapretract = false) {
    if(retracting && !retracted[active_extruder]) {
      destination[X_AXIS]=current_position[X_AXIS];
      destination[Y_AXIS]=current_position[Y_AXIS];
      destination[Z_AXIS]=current_position[Z_AXIS];
      destination[E_AXIS]=current_position[E_AXIS];
      if (swapretract) {
        current_position[E_AXIS]+=retract_length_swap/volumetric_multiplier[active_extruder];
      } else {
        current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
      }
      plan_set_e_position(current_position[E_AXIS]);
      float oldFeedrate = feedrate;
      feedrate=retract_feedrate*60;
      retracted[active_extruder]=true;
      prepare_move();
      current_position[Z_AXIS]-=retract_zlift;
#ifdef DELTA
      calculate_delta(current_position); // change cartesian kinematic to  delta kinematic;
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#else
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
      prepare_move();
      feedrate = oldFeedrate;
    } else if(!retracting && retracted[active_extruder]) {
      destination[X_AXIS]=current_position[X_AXIS];
      destination[Y_AXIS]=current_position[Y_AXIS];
      destination[Z_AXIS]=current_position[Z_AXIS];
      destination[E_AXIS]=current_position[E_AXIS];
      current_position[Z_AXIS]+=retract_zlift;
#ifdef DELTA
      calculate_delta(current_position); // change cartesian kinematic  to  delta kinematic;
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#else
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
      //prepare_move();
      if (swapretract) {
        current_position[E_AXIS]-=(retract_length_swap+retract_recover_length_swap)/volumetric_multiplier[active_extruder]; 
      } else {
        current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
      }
      plan_set_e_position(current_position[E_AXIS]);
      float oldFeedrate = feedrate;
      feedrate=retract_recover_feedrate*60;
      retracted[active_extruder]=false;
      prepare_move();
      feedrate = oldFeedrate;
    }
  }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
static void extrapolate_unprobed_bed_level() {
      int half = (AUTO_BED_LEVELING_GRID_POINTS-1)/2;
      for (int y = 0; y <= half; y++) {
        for (int x = 0; x <= half; x++) {
          if (x + y < 3) continue;
          extrapolate_one_point(half-x, half-y, x>1?+1:0, y>1?+1:0);
          extrapolate_one_point(half+x, half-y, x>1?-1:0, y>1?+1:0);
          extrapolate_one_point(half-x, half+y, x>1?+1:0, y>1?-1:0);
          extrapolate_one_point(half+x, half+y, x>1?-1:0, y>1?-1:0);
        }
      }
    }
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
//retract
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
// Print calibration results for plotting or manual frame adjustment.
#endif
++++++
#if defined (upstream)
//FWRETRACT
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
static void print_bed_level() {
      for (int y = 0; y < AUTO_BED_LEVELING_GRID_POINTS; y++) {
        for (int x = 0; x < AUTO_BED_LEVELING_GRID_POINTS; x++) {
          SERIAL_PROTOCOL_F(bed_level[x][y], 2);
          SERIAL_PROTOCOLCHAR(' ');
        }
        SERIAL_EOL;
      }
    }
#endif
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
static void print_bed_level() {
      for (int y = 0; y < AUTO_BED_LEVELING_GRID_POINTS; y++) {
        for (int x = 0; x < AUTO_BED_LEVELING_GRID_POINTS; x++) {
          SERIAL_PROTOCOL_F(bed_level[x][y], 2);
          SERIAL_PROTOCOLCHAR(' ');
        }
        SERIAL_EOL;
      }
    }
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
// Reset calibration results to zero.
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
// Method to dock/undock a sled designed by Charles Bell.
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
void reset_bed_level() {
      for (int y = 0; y < AUTO_BED_LEVELING_GRID_POINTS; y++) {
        for (int x = 0; x < AUTO_BED_LEVELING_GRID_POINTS; x++) {
          bed_level[x][y] = 0.0;
        }
      }
    }
#endif
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
void reset_bed_level() {
      for (int y = 0; y < AUTO_BED_LEVELING_GRID_POINTS; y++) {
        for (int x = 0; x < AUTO_BED_LEVELING_GRID_POINTS; x++) {
          bed_level[x][y] = 0.0;
        }
      }
    }
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
// DELTA
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
// dock[in]     If true, move to MAX_X and engage the electromagnet
#endif
++++++
#if defined (marlin4Due)
// ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
// offset[in]   The additional distance to move to adjust docking location
#endif
++++++
#if defined (marlin4Due) && (!defined (SLED_DOCKING_OFFSET) && ENABLED(Z_PROBE_SLED) )
#define SLED_DOCKING_OFFSET 0
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_PROBE_SLED)
/**
   * Method to dock/undock a sled designed by Charles Bell.
   *
   * dock[in]     If true, move to MAX_X and engage the electromagnet
   * offset[in]   The additional distance to move to adjust docking location
   */
#endif
++++++
#if defined (upstream)
void process_commands()
{
  unsigned long codenum; //throw away variable
  char *starpos = NULL;
#ifdef ENABLE_AUTO_BED_LEVELING
  float x_tmp, y_tmp, z_tmp, real_z;
#endif
  if(code_seen('G'))
  {
    switch((int)code_value())
    {
    case 0: // G0 -> G1
    case 1: // G1
      if(Stopped == false) {
        get_coordinates(); // For X Y Z E F
          #ifdef FWRETRACT
            if(autoretract_enabled)
            if( !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
              float echange=destination[E_AXIS]-current_position[E_AXIS];
              if((echange<-MIN_RETRACT && !retracted) || (echange>MIN_RETRACT && retracted)) { //move appears to be an attempt to retract or recover
                  current_position[E_AXIS] = destination[E_AXIS]; //hide the slicer-generated retract/recover from calculations
                  plan_set_e_position(current_position[E_AXIS]); //AND from the planner
                  retract(!retracted);
                  return;
              }
            }
          #endif //FWRETRACT
        prepare_move();
        //ClearToSend();
      }
      break;
#ifndef SCARA //disable arc support
    case 2: // G2  - CW ARC
      if(Stopped == false) {
        get_arc_coordinates();
        prepare_arc_move(true);
      }
      break;
    case 3: // G3  - CCW ARC
      if(Stopped == false) {
        get_arc_coordinates();
        prepare_arc_move(false);
      }
      break;
#endif
    case 4: // G4 dwell
      LCD_MESSAGEPGM(MSG_DWELL);
      codenum = 0;
      if(code_seen('P')) codenum = code_value(); // milliseconds to wait
      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait

      st_synchronize();
      codenum += millis();  // keep track of when we started waiting
      previous_millis_cmd = millis();
      while(millis() < codenum) {
        manage_heater();
        manage_inactivity();
        lcd_update();
      }
      break;
      #ifdef FWRETRACT
      case 10: // G10 retract
       #if EXTRUDERS > 1
        retracted_swap[active_extruder]=(code_seen('S') && code_value_long() == 1); // checks for swap retract argument
        retract(true,retracted_swap[active_extruder]);
       #else
        retract(true);
       #endif
      break;
      case 11: // G11 retract_recover
       #if EXTRUDERS > 1
        retract(false,retracted_swap[active_extruder]);
       #else
        retract(false);
       #endif 
      break;
      #endif //FWRETRACT
    case 28: //G28 Home all Axis one at a time
#ifdef ENABLE_AUTO_BED_LEVELING
      plan_bed_level_matrix.set_to_identity();  //Reset the plane ("erase" all leveling data)
#endif //ENABLE_AUTO_BED_LEVELING

      saved_feedrate = feedrate;
      saved_feedmultiply = feedmultiply;
      feedmultiply = 100;
      previous_millis_cmd = millis();

      enable_endstops(true);

      for(int8_t i=0; i < NUM_AXIS; i++) {
        destination[i] = current_position[i];
      }
      feedrate = 0.0;

#ifdef DELTA
          // A delta can only safely home all axis at the same time
          // all axis have to home at the same time

          // Move all carriages up together until the first endstop is hit.
          current_position[X_AXIS] = 0;
          current_position[Y_AXIS] = 0;
          current_position[Z_AXIS] = 0;
          plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);

          destination[X_AXIS] = 3 * Z_MAX_LENGTH;
          destination[Y_AXIS] = 3 * Z_MAX_LENGTH;
          destination[Z_AXIS] = 3 * Z_MAX_LENGTH;
          feedrate = 1.732 * homing_feedrate[X_AXIS];
          plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
          st_synchronize();
          endstops_hit_on_purpose();

          current_position[X_AXIS] = destination[X_AXIS];
          current_position[Y_AXIS] = destination[Y_AXIS];
          current_position[Z_AXIS] = destination[Z_AXIS];

          // take care of back off and rehome now we are all at the top
          HOMEAXIS(X);
          HOMEAXIS(Y);
          HOMEAXIS(Z);

          calculate_delta(current_position);
          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);

#else // NOT DELTA

      home_all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS])));

      #if Z_HOME_DIR > 0                      // If homing away from BED do Z first
      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
        HOMEAXIS(Z);
      }
      #endif

      #ifdef QUICK_HOME
      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move
      {
        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;

       #ifndef DUAL_X_CARRIAGE
        int x_axis_home_dir = home_dir(X_AXIS);
       #else
        int x_axis_home_dir = x_home_dir(active_extruder);
        extruder_duplication_enabled = false;
       #endif

        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
        destination[X_AXIS] = 1.5 * max_length(X_AXIS) * x_axis_home_dir;destination[Y_AXIS] = 1.5 * max_length(Y_AXIS) * home_dir(Y_AXIS);
        feedrate = homing_feedrate[X_AXIS];
        if(homing_feedrate[Y_AXIS]<feedrate)
          feedrate = homing_feedrate[Y_AXIS];
        if (max_length(X_AXIS) > max_length(Y_AXIS)) {
          feedrate *= sqrt(pow(max_length(Y_AXIS) / max_length(X_AXIS), 2) + 1);
        } else {
          feedrate *= sqrt(pow(max_length(X_AXIS) / max_length(Y_AXIS), 2) + 1);
        }
        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
        st_synchronize();

        axis_is_at_home(X_AXIS);
        axis_is_at_home(Y_AXIS);
        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
        destination[X_AXIS] = current_position[X_AXIS];
        destination[Y_AXIS] = current_position[Y_AXIS];
        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
        feedrate = 0.0;
        st_synchronize();
        endstops_hit_on_purpose();

        current_position[X_AXIS] = destination[X_AXIS];
        current_position[Y_AXIS] = destination[Y_AXIS];
		#ifndef SCARA
        current_position[Z_AXIS] = destination[Z_AXIS];
		#endif
      }
      #endif

      if((home_all_axis) || (code_seen(axis_codes[X_AXIS])))
      {
      #ifdef DUAL_X_CARRIAGE
        int tmp_extruder = active_extruder;
        extruder_duplication_enabled = false;
        active_extruder = !active_extruder;
        HOMEAXIS(X);
        inactive_extruder_x_pos = current_position[X_AXIS];
        active_extruder = tmp_extruder;
        HOMEAXIS(X);
        // reset state used by the different modes
        memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
        delayed_move_time = 0;
        active_extruder_parked = true;
      #else
        HOMEAXIS(X);
      #endif
      }

      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {
        HOMEAXIS(Y);
      }

      if(code_seen(axis_codes[X_AXIS]))
      {
        if(code_value_long() != 0) {
		#ifdef SCARA
		   current_position[X_AXIS]=code_value();
		#else
		   current_position[X_AXIS]=code_value()+add_homing[X_AXIS];
		#endif
        }
      }

      if(code_seen(axis_codes[Y_AXIS])) {
        if(code_value_long() != 0) {
         #ifdef SCARA
		   current_position[Y_AXIS]=code_value();
		#else
		   current_position[Y_AXIS]=code_value()+add_homing[Y_AXIS];
		#endif
        }
      }

      #if Z_HOME_DIR < 0                      // If homing towards BED do Z last
        #ifndef Z_SAFE_HOMING
          if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
            #if defined (Z_RAISE_BEFORE_HOMING) && (Z_RAISE_BEFORE_HOMING > 0)
              destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
              feedrate = max_feedrate[Z_AXIS];
              plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
              st_synchronize();
            #endif
            HOMEAXIS(Z);
          }
        #else                      // Z Safe mode activated.
          if(home_all_axis) {
            destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);
            destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);
            destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
            feedrate = XY_TRAVEL_SPEED/60;
            current_position[Z_AXIS] = 0;

            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
            plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
            st_synchronize();
            current_position[X_AXIS] = destination[X_AXIS];
            current_position[Y_AXIS] = destination[Y_AXIS];

            HOMEAXIS(Z);
          }
                                                // Let's see if X and Y are homed and probe is inside bed area.
          if(code_seen(axis_codes[Z_AXIS])) {
            if ( (axis_known_position[X_AXIS]) && (axis_known_position[Y_AXIS]) \
              && (current_position[X_AXIS]+X_PROBE_OFFSET_FROM_EXTRUDER >= X_MIN_POS) \
              && (current_position[X_AXIS]+X_PROBE_OFFSET_FROM_EXTRUDER <= X_MAX_POS) \
              && (current_position[Y_AXIS]+Y_PROBE_OFFSET_FROM_EXTRUDER >= Y_MIN_POS) \
              && (current_position[Y_AXIS]+Y_PROBE_OFFSET_FROM_EXTRUDER <= Y_MAX_POS)) {

              current_position[Z_AXIS] = 0;
              plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
              destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS) * (-1);    // Set destination away from bed
              feedrate = max_feedrate[Z_AXIS];
              plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate, active_extruder);
              st_synchronize();

              HOMEAXIS(Z);
            } else if (!((axis_known_position[X_AXIS]) && (axis_known_position[Y_AXIS]))) {
                LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
                SERIAL_ECHO_START;
                SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
            } else {
                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
                SERIAL_ECHO_START;
                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
            }
          }
        #endif
      #endif



      if(code_seen(axis_codes[Z_AXIS])) {
        if(code_value_long() != 0) {
          current_position[Z_AXIS]=code_value()+add_homing[Z_AXIS];
        }
      }
      #ifdef ENABLE_AUTO_BED_LEVELING
        if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {
          current_position[Z_AXIS] += zprobe_zoffset;  //Add Z_Probe offset (the distance is negative)
        }
      #endif
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif // else DELTA

#ifdef SCARA
	  calculate_delta(current_position);
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#endif // SCARA

      #ifdef ENDSTOPS_ONLY_FOR_HOMING
        enable_endstops(false);
      #endif

      feedrate = saved_feedrate;
      feedmultiply = saved_feedmultiply;
      previous_millis_cmd = millis();
      endstops_hit_on_purpose();
      break;

#ifdef ENABLE_AUTO_BED_LEVELING
    case 29: // G29 Detailed Z-Probe, probes the bed at 3 or more points.
        {
            #if Z_MIN_PIN == -1
            #error "You must have a Z_MIN endstop in order to enable Auto Bed Leveling feature!!! Z_MIN_PIN must point to a valid hardware pin."
            #endif

            // Prevent user from running a G29 without first homing in X and Y
            if (! (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS]) )
            {
                LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
                SERIAL_ECHO_START;
                SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
                break; // abort G29, since we don't know where we are
            }

#ifdef Z_PROBE_SLED
            dock_sled(false);
#endif // Z_PROBE_SLED
            st_synchronize();
            // make sure the bed_level_rotation_matrix is identity or the planner will get it incorectly
            //vector_3 corrected_position = plan_get_position_mm();
            //corrected_position.debug("position before G29");
            plan_bed_level_matrix.set_to_identity();
            vector_3 uncorrected_position = plan_get_position();
            //uncorrected_position.debug("position durring G29");
            current_position[X_AXIS] = uncorrected_position.x;
            current_position[Y_AXIS] = uncorrected_position.y;
            current_position[Z_AXIS] = uncorrected_position.z;
            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
            setup_for_endstop_move();

            feedrate = homing_feedrate[Z_AXIS];
#ifdef AUTO_BED_LEVELING_GRID
            // probe at the points of a lattice grid

            int xGridSpacing = (RIGHT_PROBE_BED_POSITION - LEFT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS-1);
            int yGridSpacing = (BACK_PROBE_BED_POSITION - FRONT_PROBE_BED_POSITION) / (AUTO_BED_LEVELING_GRID_POINTS-1);


            // solve the plane equation ax + by + d = z
            // A is the matrix with rows [x y 1] for all the probed points
            // B is the vector of the Z positions
            // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
            // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z

            // "A" matrix of the linear system of equations
            double eqnAMatrix[AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS*3];
            // "B" vector of Z points
            double eqnBVector[AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS];


            int probePointCounter = 0;
            bool zig = true;

            for (int yProbe=FRONT_PROBE_BED_POSITION; yProbe <= BACK_PROBE_BED_POSITION; yProbe += yGridSpacing)
            {
              int xProbe, xInc;
              if (zig)
              {
                xProbe = LEFT_PROBE_BED_POSITION;
                //xEnd = RIGHT_PROBE_BED_POSITION;
                xInc = xGridSpacing;
                zig = false;
              } else // zag
              {
                xProbe = RIGHT_PROBE_BED_POSITION;
                //xEnd = LEFT_PROBE_BED_POSITION;
                xInc = -xGridSpacing;
                zig = true;
              }

              for (int xCount=0; xCount < AUTO_BED_LEVELING_GRID_POINTS; xCount++)
              {
                float z_before;
                if (probePointCounter == 0)
                {
                  // raise before probing
                  z_before = Z_RAISE_BEFORE_PROBING;
                } else
                {
                  // raise extruder
                  z_before = current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS;
                }

                float measured_z = probe_pt(xProbe, yProbe, z_before);

                eqnBVector[probePointCounter] = measured_z;

                eqnAMatrix[probePointCounter + 0*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = xProbe;
                eqnAMatrix[probePointCounter + 1*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = yProbe;
                eqnAMatrix[probePointCounter + 2*AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS] = 1;
                probePointCounter++;
                xProbe += xInc;
              }
            }
            clean_up_after_endstop_move();

            // solve lsq problem
            double *plane_equation_coefficients = qr_solve(AUTO_BED_LEVELING_GRID_POINTS*AUTO_BED_LEVELING_GRID_POINTS, 3, eqnAMatrix, eqnBVector);

            SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
            SERIAL_PROTOCOL(plane_equation_coefficients[0]);
            SERIAL_PROTOCOLPGM(" b: ");
            SERIAL_PROTOCOL(plane_equation_coefficients[1]);
            SERIAL_PROTOCOLPGM(" d: ");
            SERIAL_PROTOCOLLN(plane_equation_coefficients[2]);


            set_bed_level_equation_lsq(plane_equation_coefficients);

            free(plane_equation_coefficients);

#else // AUTO_BED_LEVELING_GRID not defined

            // Probe at 3 arbitrary points
            // probe 1
            float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING);

            // probe 2
            float z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);

            // probe 3
            float z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);

            clean_up_after_endstop_move();

            set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);


#endif // AUTO_BED_LEVELING_GRID
            st_synchronize();

            // The following code correct the Z height difference from z-probe position and hotend tip position.
            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend.
            // When the bed is uneven, this height must be corrected.
            real_z = float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS];  //get the real Z (since the auto bed leveling is already correcting the plane)
            x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER;
            y_tmp = current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER;
            z_tmp = current_position[Z_AXIS];

            apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp);         //Apply the correction sending the probe offset
            current_position[Z_AXIS] = z_tmp - real_z + current_position[Z_AXIS];   //The difference is added to current position and sent to planner.
            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#ifdef Z_PROBE_SLED
            dock_sled(true, -SLED_DOCKING_OFFSET); // correct for over travel.
#endif // Z_PROBE_SLED
        }
        break;
#ifndef Z_PROBE_SLED
    case 30: // G30 Single Z Probe
        {
            engage_z_probe(); // Engage Z Servo endstop if available
            st_synchronize();
            // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
            setup_for_endstop_move();

            feedrate = homing_feedrate[Z_AXIS];

            run_z_probe();
            SERIAL_PROTOCOLPGM(MSG_BED);
            SERIAL_PROTOCOLPGM(" X: ");
            SERIAL_PROTOCOL(current_position[X_AXIS]);
            SERIAL_PROTOCOLPGM(" Y: ");
            SERIAL_PROTOCOL(current_position[Y_AXIS]);
            SERIAL_PROTOCOLPGM(" Z: ");
            SERIAL_PROTOCOL(current_position[Z_AXIS]);
            SERIAL_PROTOCOLPGM("\n");

            clean_up_after_endstop_move();
            retract_z_probe(); // Retract Z Servo endstop if available
        }
        break;
#else
    case 31: // dock the sled
        dock_sled(true);
        break;
    case 32: // undock the sled
        dock_sled(false);
        break;
#endif // Z_PROBE_SLED
#endif // ENABLE_AUTO_BED_LEVELING
    case 90: // G90
      relative_mode = false;
      break;
    case 91: // G91
      relative_mode = true;
      break;
    case 92: // G92
      if(!code_seen(axis_codes[E_AXIS]))
        st_synchronize();
      for(int8_t i=0; i < NUM_AXIS; i++) {
        if(code_seen(axis_codes[i])) {
           if(i == E_AXIS) {
             current_position[i] = code_value();
             plan_set_e_position(current_position[E_AXIS]);
           }
           else {
#ifdef SCARA
		if (i == X_AXIS || i == Y_AXIS) {
                	current_position[i] = code_value();  
		}
		else {
                current_position[i] = code_value()+add_homing[i];  
            	}  
#else
		current_position[i] = code_value()+add_homing[i];
#endif
            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
           }
        }
      }
      break;
    }
  }

  else if(code_seen('M'))
  {
    switch( (int)code_value() )
    {
#ifdef ULTIPANEL
    case 0: // M0 - Unconditional stop - Wait for user button press on LCD
    case 1: // M1 - Conditional stop - Wait for user button press on LCD
    {
      char *src = strchr_pointer + 2;

      codenum = 0;

      bool hasP = false, hasS = false;
      if (code_seen('P')) {
        codenum = code_value(); // milliseconds to wait
        hasP = codenum > 0;
      }
      if (code_seen('S')) {
        codenum = code_value() * 1000; // seconds to wait
        hasS = codenum > 0;
      }
      starpos = strchr(src, '*');
      if (starpos != NULL) *(starpos) = '\0';
      while (*src == ' ') ++src;
      if (!hasP && !hasS && *src != '\0') {
        lcd_setstatus(src);
      } else {
        LCD_MESSAGEPGM(MSG_USERWAIT);
      }

      lcd_ignore_click();
      st_synchronize();
      previous_millis_cmd = millis();
      if (codenum > 0){
        codenum += millis();  // keep track of when we started waiting
        while(millis() < codenum && !lcd_clicked()){
          manage_heater();
          manage_inactivity();
          lcd_update();
        }
        lcd_ignore_click(false);
      }else{
          if (!lcd_detected())
            break;
        while(!lcd_clicked()){
          manage_heater();
          manage_inactivity();
          lcd_update();
        }
      }
      if (IS_SD_PRINTING)
        LCD_MESSAGEPGM(MSG_RESUMING);
      else
        LCD_MESSAGEPGM(WELCOME_MSG);
    }
    break;
#endif
    case 17:
        LCD_MESSAGEPGM(MSG_NO_MOVE);
        enable_x();
        enable_y();
        enable_z();
        enable_e0();
        enable_e1();
        enable_e2();
      break;

#ifdef SDSUPPORT
    case 20: // M20 - list SD card
      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
      card.ls();
      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
      break;
    case 21: // M21 - init SD card

      card.initsd();

      break;
    case 22: //M22 - release SD card
      card.release();

      break;
    case 23: //M23 - Select file
      starpos = (strchr(strchr_pointer + 4,'*'));
      if(starpos!=NULL)
        *(starpos)='\0';
      card.openFile(strchr_pointer + 4,true);
      break;
    case 24: //M24 - Start SD print
      card.startFileprint();
      starttime=millis();
      break;
    case 25: //M25 - Pause SD print
      card.pauseSDPrint();
      break;
    case 26: //M26 - Set SD index
      if(card.cardOK && code_seen('S')) {
        card.setIndex(code_value_long());
      }
      break;
    case 27: //M27 - Get SD status
      card.getStatus();
      break;
    case 28: //M28 - Start SD write
      starpos = (strchr(strchr_pointer + 4,'*'));
      if(starpos != NULL){
        char* npos = strchr(cmdbuffer[bufindr], 'N');
        strchr_pointer = strchr(npos,' ') + 1;
        *(starpos) = '\0';
      }
      card.openFile(strchr_pointer+4,false);
      break;
    case 29: //M29 - Stop SD write
      //processed in write to file routine above
      //card,saving = false;
      break;
    case 30: //M30 <filename> Delete File
      if (card.cardOK){
        card.closefile();
        starpos = (strchr(strchr_pointer + 4,'*'));
        if(starpos != NULL){
          char* npos = strchr(cmdbuffer[bufindr], 'N');
          strchr_pointer = strchr(npos,' ') + 1;
          *(starpos) = '\0';
        }
        card.removeFile(strchr_pointer + 4);
      }
      break;
    case 32: //M32 - Select file and start SD print
    {
      if(card.sdprinting) {
        st_synchronize();

      }
      starpos = (strchr(strchr_pointer + 4,'*'));

      char* namestartpos = (strchr(strchr_pointer + 4,'!'));   //find ! to indicate filename string start.
      if(namestartpos==NULL)
      {
        namestartpos=strchr_pointer + 4; //default name position, 4 letters after the M
      }
      else
        namestartpos++; //to skip the '!'

      if(starpos!=NULL)
        *(starpos)='\0';

      bool call_procedure=(code_seen('P'));

      if(strchr_pointer>namestartpos)
        call_procedure=false;  //false alert, 'P' found within filename

      if( card.cardOK )
      {
        card.openFile(namestartpos,true,!call_procedure);
        if(code_seen('S'))
          if(strchr_pointer<namestartpos) //only if "S" is occuring _before_ the filename
            card.setIndex(code_value_long());
        card.startFileprint();
        if(!call_procedure)
          starttime=millis(); //procedure calls count as normal print time.
      }
    } break;
    case 928: //M928 - Start SD write
      starpos = (strchr(strchr_pointer + 5,'*'));
      if(starpos != NULL){
        char* npos = strchr(cmdbuffer[bufindr], 'N');
        strchr_pointer = strchr(npos,' ') + 1;
        *(starpos) = '\0';
      }
      card.openLogFile(strchr_pointer+5);
      break;

#endif //SDSUPPORT

    case 31: //M31 take time since the start of the SD print or an M109 command
      {
      stoptime=millis();
      char time[30];
      unsigned long t=(stoptime-starttime)/1000;
      int sec,min;
      min=t/60;
      sec=t%60;
      sprintf_P(time, PSTR("%i min, %i sec"), min, sec);
      SERIAL_ECHO_START;
      SERIAL_ECHOLN(time);
      lcd_setstatus(time);
      autotempShutdown();
      }
      break;
    case 42: //M42 -Change pin status via gcode
      if (code_seen('S'))
      {
        int pin_status = code_value();
        int pin_number = LED_PIN;
        if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
          pin_number = code_value();
        for(int8_t i = 0; i < (int8_t)(sizeof(sensitive_pins)/sizeof(int)); i++)
        {
          if (sensitive_pins[i] == pin_number)
          {
            pin_number = -1;
            break;
          }
        }
      #if defined(FAN_PIN) && FAN_PIN > -1
        if (pin_number == FAN_PIN)
          fanSpeed = pin_status;
      #endif
        if (pin_number > -1)
        {
          pinMode(pin_number, OUTPUT);
          digitalWrite(pin_number, pin_status);
          analogWrite(pin_number, pin_status);
        }
      }
     break;

// M48 Z-Probe repeatability measurement function.
//
// Usage:   M48 <n #_samples> <X X_position_for_samples> <Y Y_position_for_samples> <V Verbose_Level> <Engage_probe_for_each_reading> <L legs_of_movement_prior_to_doing_probe>
//	
// This function assumes the bed has been homed.  Specificaly, that a G28 command
// as been issued prior to invoking the M48 Z-Probe repeatability measurement function.
// Any information generated by a prior G29 Bed leveling command will be lost and need to be
// regenerated.
//
// The number of samples will default to 10 if not specified.  You can use upper or lower case
// letters for any of the options EXCEPT n.  n must be in lower case because Marlin uses a capital
// N for its communication protocol and will get horribly confused if you send it a capital N.
//

#ifdef ENABLE_AUTO_BED_LEVELING
#ifdef Z_PROBE_REPEATABILITY_TEST 

    case 48: // M48 Z-Probe repeatability
        {
            #if Z_MIN_PIN == -1
            #error "You must have a Z_MIN endstop in order to enable calculation of Z-Probe repeatability."
            #endif

	double sum=0.0; 
	double mean=0.0; 
	double sigma=0.0;
	double sample_set[50];
	int verbose_level=1, n=0, j, n_samples = 10, n_legs=0, engage_probe_for_each_reading=0 ;
	double X_current, Y_current, Z_current;
	double X_probe_location, Y_probe_location, Z_start_location, ext_position;
	
	if (code_seen('V') || code_seen('v')) {
        	verbose_level = code_value();
		if (verbose_level<0 || verbose_level>4 ) {
			SERIAL_PROTOCOLPGM("?Verbose Level not plausable.\n");
			goto Sigma_Exit;
		}
	}

	if (verbose_level > 0)   {
		SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test.   Version 2.00\n");
		SERIAL_PROTOCOLPGM("Full support at: http://3dprintboard.com/forum.php\n");
	}

	if (code_seen('n')) {
        	n_samples = code_value();
		if (n_samples<4 || n_samples>50 ) {
			SERIAL_PROTOCOLPGM("?Specified sample size not plausable.\n");
			goto Sigma_Exit;
		}
	}

	X_current = X_probe_location = st_get_position_mm(X_AXIS);
	Y_current = Y_probe_location = st_get_position_mm(Y_AXIS);
	Z_current = st_get_position_mm(Z_AXIS);
	Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;
	ext_position	 = st_get_position_mm(E_AXIS);

	if (code_seen('E') || code_seen('e') ) 
		engage_probe_for_each_reading++;

	if (code_seen('X') || code_seen('x') ) {
        	X_probe_location = code_value() -  X_PROBE_OFFSET_FROM_EXTRUDER;
		if (X_probe_location<X_MIN_POS || X_probe_location>X_MAX_POS ) {
			SERIAL_PROTOCOLPGM("?Specified X position out of range.\n");
			goto Sigma_Exit;
		}
	}

	if (code_seen('Y') || code_seen('y') ) {
        	Y_probe_location = code_value() -  Y_PROBE_OFFSET_FROM_EXTRUDER;
		if (Y_probe_location<Y_MIN_POS || Y_probe_location>Y_MAX_POS ) {
			SERIAL_PROTOCOLPGM("?Specified Y position out of range.\n");
			goto Sigma_Exit;
		}
	}

	if (code_seen('L') || code_seen('l') ) {
        	n_legs = code_value();
		if ( n_legs==1 ) 
			n_legs = 2;
		if ( n_legs<0 || n_legs>15 ) {
			SERIAL_PROTOCOLPGM("?Specified number of legs in movement not plausable.\n");
			goto Sigma_Exit;
		}
	}

//
// Do all the preliminary setup work.   First raise the probe.
//

        st_synchronize();
        plan_bed_level_matrix.set_to_identity();
	plan_buffer_line( X_current, Y_current, Z_start_location,
			ext_position,
    			homing_feedrate[Z_AXIS]/60,
			active_extruder);
        st_synchronize();

//
// Now get everything to the specified probe point So we can safely do a probe to
// get us close to the bed.  If the Z-Axis is far from the bed, we don't want to 
// use that as a starting point for each probe.
//
	if (verbose_level > 2) 
		SERIAL_PROTOCOL("Positioning probe for the test.\n");

	plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,
			ext_position,
    			homing_feedrate[X_AXIS]/60,
			active_extruder);
        st_synchronize();

	current_position[X_AXIS] = X_current = st_get_position_mm(X_AXIS);
	current_position[Y_AXIS] = Y_current = st_get_position_mm(Y_AXIS);
	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
	current_position[E_AXIS] = ext_position = st_get_position_mm(E_AXIS);

// 
// OK, do the inital probe to get us close to the bed.
// Then retrace the right amount and use that in subsequent probes
//

        engage_z_probe();	

	setup_for_endstop_move();
	run_z_probe();

	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
	Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;

	plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,
			ext_position,
    			homing_feedrate[X_AXIS]/60,
			active_extruder);
        st_synchronize();
	current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);

	if (engage_probe_for_each_reading)
        	retract_z_probe();

        for( n=0; n<n_samples; n++) {

		do_blocking_move_to( X_probe_location, Y_probe_location, Z_start_location); // Make sure we are at the probe location

		if ( n_legs)  {
		double radius=0.0, theta=0.0, x_sweep, y_sweep;
		int rotational_direction, l;

			rotational_direction = (unsigned long) millis() & 0x0001;			// clockwise or counter clockwise
			radius = (unsigned long) millis() % (long) (X_MAX_LENGTH/4); 			// limit how far out to go 
			theta = (float) ((unsigned long) millis() % (long) 360) / (360./(2*3.1415926));	// turn into radians

//SERIAL_ECHOPAIR("starting radius: ",radius);
//SERIAL_ECHOPAIR("   theta: ",theta);
//SERIAL_ECHOPAIR("   direction: ",rotational_direction);
//SERIAL_PROTOCOLLNPGM("");

			for( l=0; l<n_legs-1; l++) {
				if (rotational_direction==1)
					theta += (float) ((unsigned long) millis() % (long) 20) / (360.0/(2*3.1415926)); // turn into radians
				else
					theta -= (float) ((unsigned long) millis() % (long) 20) / (360.0/(2*3.1415926)); // turn into radians

				radius += (float) ( ((long) ((unsigned long) millis() % (long) 10)) - 5);
				if ( radius<0.0 )
					radius = -radius;

				X_current = X_probe_location + cos(theta) * radius;
				Y_current = Y_probe_location + sin(theta) * radius;

				if ( X_current<X_MIN_POS)		// Make sure our X & Y are sane
					 X_current = X_MIN_POS;
				if ( X_current>X_MAX_POS)
					 X_current = X_MAX_POS;

				if ( Y_current<Y_MIN_POS)		// Make sure our X & Y are sane
					 Y_current = Y_MIN_POS;
				if ( Y_current>Y_MAX_POS)
					 Y_current = Y_MAX_POS;

				if (verbose_level>3 ) {
					SERIAL_ECHOPAIR("x: ", X_current);
					SERIAL_ECHOPAIR("y: ", Y_current);
					SERIAL_PROTOCOLLNPGM("");
				}

				do_blocking_move_to( X_current, Y_current, Z_current );
			}
			do_blocking_move_to( X_probe_location, Y_probe_location, Z_start_location); // Go back to the probe location
		}

		if (engage_probe_for_each_reading)  {
        		engage_z_probe();	
          		delay(1000);
		}

		setup_for_endstop_move();
                run_z_probe();

		sample_set[n] = current_position[Z_AXIS];

//
// Get the current mean for the data points we have so far
//
		sum=0.0; 
		for( j=0; j<=n; j++) {
			sum = sum + sample_set[j];
		}
		mean = sum / (double (n+1));
//
// Now, use that mean to calculate the standard deviation for the
// data points we have so far
//

		sum=0.0; 
		for( j=0; j<=n; j++) {
			sum = sum + (sample_set[j]-mean) * (sample_set[j]-mean);
		}
		sigma = sqrt( sum / (double (n+1)) );

		if (verbose_level > 1) {
			SERIAL_PROTOCOL(n+1);
			SERIAL_PROTOCOL(" of ");
			SERIAL_PROTOCOL(n_samples);
			SERIAL_PROTOCOLPGM("   z: ");
			SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
		}

		if (verbose_level > 2) {
			SERIAL_PROTOCOL(" mean: ");
			SERIAL_PROTOCOL_F(mean,6);

			SERIAL_PROTOCOL("   sigma: ");
			SERIAL_PROTOCOL_F(sigma,6);
		}

		if (verbose_level > 0) 
			SERIAL_PROTOCOLPGM("\n");

		plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location, 
				  current_position[E_AXIS], homing_feedrate[Z_AXIS]/60, active_extruder);
        	st_synchronize();

		if (engage_probe_for_each_reading)  {
        		retract_z_probe();	
          		delay(1000);
		}
	}

        retract_z_probe();
	delay(1000);

        clean_up_after_endstop_move();

//      enable_endstops(true);

	if (verbose_level > 0) {
		SERIAL_PROTOCOLPGM("Mean: ");
		SERIAL_PROTOCOL_F(mean, 6);
		SERIAL_PROTOCOLPGM("\n");
	}

SERIAL_PROTOCOLPGM("Standard Deviation: ");
SERIAL_PROTOCOL_F(sigma, 6);
SERIAL_PROTOCOLPGM("\n\n");

Sigma_Exit:
        break;
	}
#endif		// Z_PROBE_REPEATABILITY_TEST 
#endif		// ENABLE_AUTO_BED_LEVELING

    case 104: // M104
      if(setTargetedHotend(104)){
        break;
      }
      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);
#ifdef DUAL_X_CARRIAGE
      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
        setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
#endif
      setWatch();
      break;
    case 112: //  M112 -Emergency Stop
      kill();
      break;
    case 140: // M140 set bed temp
      if (code_seen('S')) setTargetBed(code_value());
      break;
    case 105 : // M105
      if(setTargetedHotend(105)){
        break;
        }
      #if defined(TEMP_0_PIN) && TEMP_0_PIN > -1
        SERIAL_PROTOCOLPGM("ok T:");
        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);
        SERIAL_PROTOCOLPGM(" /");
        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1);
        #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
          SERIAL_PROTOCOLPGM(" B:");
          SERIAL_PROTOCOL_F(degBed(),1);
          SERIAL_PROTOCOLPGM(" /");
          SERIAL_PROTOCOL_F(degTargetBed(),1);
        #endif //TEMP_BED_PIN
        for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder) {
          SERIAL_PROTOCOLPGM(" T");
          SERIAL_PROTOCOL(cur_extruder);
          SERIAL_PROTOCOLPGM(":");
          SERIAL_PROTOCOL_F(degHotend(cur_extruder),1);
          SERIAL_PROTOCOLPGM(" /");
          SERIAL_PROTOCOL_F(degTargetHotend(cur_extruder),1);
        }
      #else
        SERIAL_ERROR_START;
        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
      #endif

        SERIAL_PROTOCOLPGM(" @:");
      #ifdef EXTRUDER_WATTS
        SERIAL_PROTOCOL((EXTRUDER_WATTS * getHeaterPower(tmp_extruder))/127);
        SERIAL_PROTOCOLPGM("W");
      #else
        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));
      #endif

        SERIAL_PROTOCOLPGM(" B@:");
      #ifdef BED_WATTS
        SERIAL_PROTOCOL((BED_WATTS * getHeaterPower(-1))/127);
        SERIAL_PROTOCOLPGM("W");
      #else
        SERIAL_PROTOCOL(getHeaterPower(-1));
      #endif

        #ifdef SHOW_TEMP_ADC_VALUES
          #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
            SERIAL_PROTOCOLPGM("    ADC B:");
            SERIAL_PROTOCOL_F(degBed(),1);
            SERIAL_PROTOCOLPGM("C->");
            SERIAL_PROTOCOL_F(rawBedTemp()/OVERSAMPLENR,0);
          #endif
          for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder) {
            SERIAL_PROTOCOLPGM("  T");
            SERIAL_PROTOCOL(cur_extruder);
            SERIAL_PROTOCOLPGM(":");
            SERIAL_PROTOCOL_F(degHotend(cur_extruder),1);
            SERIAL_PROTOCOLPGM("C->");
            SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder)/OVERSAMPLENR,0);
          }
        #endif

        SERIAL_PROTOCOLLN("");
      return;
      break;
    case 109:
    {// M109 - Wait for extruder heater to reach target.
      if(setTargetedHotend(109)){
        break;
      }
      LCD_MESSAGEPGM(MSG_HEATING);
      #ifdef AUTOTEMP
        autotemp_enabled=false;
      #endif
      if (code_seen('S')) {
        setTargetHotend(code_value(), tmp_extruder);
#ifdef DUAL_X_CARRIAGE
        if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
          setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
#endif
        CooldownNoWait = true;
      } else if (code_seen('R')) {
        setTargetHotend(code_value(), tmp_extruder);
#ifdef DUAL_X_CARRIAGE
        if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)
          setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);
#endif
        CooldownNoWait = false;
      }
      #ifdef AUTOTEMP
        if (code_seen('S')) autotemp_min=code_value();
        if (code_seen('B')) autotemp_max=code_value();
        if (code_seen('F'))
        {
          autotemp_factor=code_value();
          autotemp_enabled=true;
        }
      #endif

      setWatch();
      codenum = millis();

      /* See if we are heating up or cooling down */
      target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling

      cancel_heatup = false;

      #ifdef TEMP_RESIDENCY_TIME
        long residencyStart;
        residencyStart = -1;
        /* continue to loop until we have reached the target temp
          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
        while((!cancel_heatup)&&((residencyStart == -1) ||
              (residencyStart >= 0 && (((unsigned int) (millis() - residencyStart)) < (TEMP_RESIDENCY_TIME * 1000UL)))) ) {
      #else
        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {
      #endif //TEMP_RESIDENCY_TIME
          if( (millis() - codenum) > 1000UL )
          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down
            SERIAL_PROTOCOLPGM("T:");
            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);
            SERIAL_PROTOCOLPGM(" E:");
            SERIAL_PROTOCOL((int)tmp_extruder);
            #ifdef TEMP_RESIDENCY_TIME
              SERIAL_PROTOCOLPGM(" W:");
              if(residencyStart > -1)
              {
                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;
                 SERIAL_PROTOCOLLN( codenum );
              }
              else
              {
                 SERIAL_PROTOCOLLN( "?" );
              }
            #else
              SERIAL_PROTOCOLLN("");
            #endif
            codenum = millis();
          }
          manage_heater();
          manage_inactivity();
          lcd_update();
        #ifdef TEMP_RESIDENCY_TIME
            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
              or when current temp falls outside the hysteresis after target temp was reached */
          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) >= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||
              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) <= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||
              (residencyStart > -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) > TEMP_HYSTERESIS) )
          {
            residencyStart = millis();
          }
        #endif //TEMP_RESIDENCY_TIME
        }
        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
        starttime=millis();
        previous_millis_cmd = millis();
      }
      break;
    case 190: // M190 - Wait for bed heater to reach target.
    #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
        LCD_MESSAGEPGM(MSG_BED_HEATING);
        if (code_seen('S')) {
          setTargetBed(code_value());
          CooldownNoWait = true;
        } else if (code_seen('R')) {
          setTargetBed(code_value());
          CooldownNoWait = false;
        }
        codenum = millis();
        
        cancel_heatup = false;
        target_direction = isHeatingBed(); // true if heating, false if cooling

        while ( (target_direction)&&(!cancel_heatup) ? (isHeatingBed()) : (isCoolingBed()&&(CooldownNoWait==false)) )
        {
          if(( millis() - codenum) > 1000 ) //Print Temp Reading every 1 second while heating up.
          {
            float tt=degHotend(active_extruder);
            SERIAL_PROTOCOLPGM("T:");
            SERIAL_PROTOCOL(tt);
            SERIAL_PROTOCOLPGM(" E:");
            SERIAL_PROTOCOL((int)active_extruder);
            SERIAL_PROTOCOLPGM(" B:");
            SERIAL_PROTOCOL_F(degBed(),1);
            SERIAL_PROTOCOLLN("");
            codenum = millis();
          }
          manage_heater();
          manage_inactivity();
          lcd_update();
        }
        LCD_MESSAGEPGM(MSG_BED_DONE);
        previous_millis_cmd = millis();
    #endif
        break;

    #if defined(FAN_PIN) && FAN_PIN > -1
      case 106: //M106 Fan On
        if (code_seen('S')){
           fanSpeed=constrain(code_value(),0,255);
        }
        else {
          fanSpeed=255;
        }
        break;
      case 107: //M107 Fan Off
        fanSpeed = 0;
        break;
    #endif //FAN_PIN
    #ifdef BARICUDA
      // PWM for HEATER_1_PIN
      #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1
        case 126: //M126 valve open
          if (code_seen('S')){
             ValvePressure=constrain(code_value(),0,255);
          }
          else {
            ValvePressure=255;
          }
          break;
        case 127: //M127 valve closed
          ValvePressure = 0;
          break;
      #endif //HEATER_1_PIN

      // PWM for HEATER_2_PIN
      #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1
        case 128: //M128 valve open
          if (code_seen('S')){
             EtoPPressure=constrain(code_value(),0,255);
          }
          else {
            EtoPPressure=255;
          }
          break;
        case 129: //M129 valve closed
          EtoPPressure = 0;
          break;
      #endif //HEATER_2_PIN
    #endif

    #if defined(PS_ON_PIN) && PS_ON_PIN > -1
      case 80: // M80 - Turn on Power Supply
        SET_OUTPUT(PS_ON_PIN); //GND
        WRITE(PS_ON_PIN, PS_ON_AWAKE);

        // If you have a switch on suicide pin, this is useful
        // if you want to start another print with suicide feature after
        // a print without suicide...
        #if defined SUICIDE_PIN && SUICIDE_PIN > -1
            SET_OUTPUT(SUICIDE_PIN);
            WRITE(SUICIDE_PIN, HIGH);
        #endif

        #ifdef ULTIPANEL
          powersupply = true;
          LCD_MESSAGEPGM(WELCOME_MSG);
          lcd_update();
        #endif
        break;
      #endif

      case 81: // M81 - Turn off Power Supply
        disable_heater();
        st_synchronize();
        disable_e0();
        disable_e1();
        disable_e2();
        finishAndDisableSteppers();
        fanSpeed = 0;
        delay(1000); // Wait a little before to switch off
      #if defined(SUICIDE_PIN) && SUICIDE_PIN > -1
        st_synchronize();
        suicide();
      #elif defined(PS_ON_PIN) && PS_ON_PIN > -1
        SET_OUTPUT(PS_ON_PIN);
        WRITE(PS_ON_PIN, PS_ON_ASLEEP);
      #endif
      #ifdef ULTIPANEL
        powersupply = false;
        LCD_MESSAGEPGM(MACHINE_NAME" "MSG_OFF".");
        lcd_update();
      #endif
	  break;

    case 82:
      axis_relative_modes[3] = false;
      break;
    case 83:
      axis_relative_modes[3] = true;
      break;
    case 18: //compatibility
    case 84: // M84
      if(code_seen('S')){
        stepper_inactive_time = code_value() * 1000;
      }
      else
      {
        bool all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS]))|| (code_seen(axis_codes[E_AXIS])));
        if(all_axis)
        {
          st_synchronize();
          disable_e0();
          disable_e1();
          disable_e2();
          finishAndDisableSteppers();
        }
        else
        {
          st_synchronize();
          if(code_seen('X')) disable_x();
          if(code_seen('Y')) disable_y();
          if(code_seen('Z')) disable_z();
          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
            if(code_seen('E')) {
              disable_e0();
              disable_e1();
              disable_e2();
            }
          #endif
        }
      }
      break;
    case 85: // M85
      if(code_seen('S')) {
        max_inactive_time = code_value() * 1000;
      }
      break;
    case 92: // M92
      for(int8_t i=0; i < NUM_AXIS; i++)
      {
        if(code_seen(axis_codes[i]))
        {
          if(i == 3) { // E
            float value = code_value();
            if(value < 20.0) {
              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
              max_e_jerk *= factor;
              max_feedrate[i] *= factor;
              axis_steps_per_sqr_second[i] *= factor;
            }
            axis_steps_per_unit[i] = value;
          }
          else {
            axis_steps_per_unit[i] = code_value();
          }
        }
      }
      break;
    case 115: // M115
      SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
      break;
    case 117: // M117 display message
      starpos = (strchr(strchr_pointer + 5,'*'));
      if(starpos!=NULL)
        *(starpos)='\0';
      lcd_setstatus(strchr_pointer + 5);
      break;
    case 114: // M114
      SERIAL_PROTOCOLPGM("X:");
      SERIAL_PROTOCOL(current_position[X_AXIS]);
      SERIAL_PROTOCOLPGM(" Y:");
      SERIAL_PROTOCOL(current_position[Y_AXIS]);
      SERIAL_PROTOCOLPGM(" Z:");
      SERIAL_PROTOCOL(current_position[Z_AXIS]);
      SERIAL_PROTOCOLPGM(" E:");
      SERIAL_PROTOCOL(current_position[E_AXIS]);

      SERIAL_PROTOCOLPGM(MSG_COUNT_X);
      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);
      SERIAL_PROTOCOLPGM(" Y:");
      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);
      SERIAL_PROTOCOLPGM(" Z:");
      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);

      SERIAL_PROTOCOLLN("");
#ifdef SCARA
	  SERIAL_PROTOCOLPGM("SCARA Theta:");
      SERIAL_PROTOCOL(delta[X_AXIS]);
      SERIAL_PROTOCOLPGM("   Psi+Theta:");
      SERIAL_PROTOCOL(delta[Y_AXIS]);
      SERIAL_PROTOCOLLN("");
      
      SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");
      SERIAL_PROTOCOL(delta[X_AXIS]+add_homing[X_AXIS]);
      SERIAL_PROTOCOLPGM("   Psi+Theta (90):");
      SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+add_homing[Y_AXIS]);
      SERIAL_PROTOCOLLN("");
      
      SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");
      SERIAL_PROTOCOL(delta[X_AXIS]/90*axis_steps_per_unit[X_AXIS]);
      SERIAL_PROTOCOLPGM("   Psi+Theta:");
      SERIAL_PROTOCOL((delta[Y_AXIS]-delta[X_AXIS])/90*axis_steps_per_unit[Y_AXIS]);
      SERIAL_PROTOCOLLN("");
      SERIAL_PROTOCOLLN("");
#endif
      break;
    case 120: // M120
      enable_endstops(false) ;
      break;
    case 121: // M121
      enable_endstops(true) ;
      break;
    case 119: // M119
    SERIAL_PROTOCOLLN(MSG_M119_REPORT);
      #if defined(X_MIN_PIN) && X_MIN_PIN > -1
        SERIAL_PROTOCOLPGM(MSG_X_MIN);
        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
      #endif
      #if defined(X_MAX_PIN) && X_MAX_PIN > -1
        SERIAL_PROTOCOLPGM(MSG_X_MAX);
        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
      #endif
      #if defined(Y_MIN_PIN) && Y_MIN_PIN > -1
        SERIAL_PROTOCOLPGM(MSG_Y_MIN);
        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
      #endif
      #if defined(Y_MAX_PIN) && Y_MAX_PIN > -1
        SERIAL_PROTOCOLPGM(MSG_Y_MAX);
        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
      #endif
      #if defined(Z_MIN_PIN) && Z_MIN_PIN > -1
        SERIAL_PROTOCOLPGM(MSG_Z_MIN);
        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
      #endif
      #if defined(Z_MAX_PIN) && Z_MAX_PIN > -1
        SERIAL_PROTOCOLPGM(MSG_Z_MAX);
        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));
      #endif
      break;
      //TODO: update for all axis, use for loop
    #ifdef BLINKM
    case 150: // M150
      {
        byte red;
        byte grn;
        byte blu;

        if(code_seen('R')) red = code_value();
        if(code_seen('U')) grn = code_value();
        if(code_seen('B')) blu = code_value();

        SendColors(red,grn,blu);
      }
      break;
    #endif //BLINKM
    case 200: // M200 D<millimeters> set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
      {

        tmp_extruder = active_extruder;
        if(code_seen('T')) {
          tmp_extruder = code_value();
          if(tmp_extruder >= EXTRUDERS) {
            SERIAL_ECHO_START;
            SERIAL_ECHO(MSG_M200_INVALID_EXTRUDER);
            break;
          }
        }

        float area = .0;
        if(code_seen('D')) {
		  float diameter = (float)code_value();
		  if (diameter == 0.0) {
			// setting any extruder filament size disables volumetric on the assumption that
			// slicers either generate in extruder values as cubic mm or as as filament feeds
			// for all extruders
		    volumetric_enabled = false;
		  } else {
            filament_size[tmp_extruder] = (float)code_value();
			// make sure all extruders have some sane value for the filament size
			filament_size[0] = (filament_size[0] == 0.0 ? DEFAULT_NOMINAL_FILAMENT_DIA : filament_size[0]);
            #if EXTRUDERS > 1
			filament_size[1] = (filament_size[1] == 0.0 ? DEFAULT_NOMINAL_FILAMENT_DIA : filament_size[1]);
            #if EXTRUDERS > 2
			filament_size[2] = (filament_size[2] == 0.0 ? DEFAULT_NOMINAL_FILAMENT_DIA : filament_size[2]);
            #endif
            #endif
			volumetric_enabled = true;
		  }
        } else {
          //reserved for setting filament diameter via UFID or filament measuring device
          break;
        }
		calculate_volumetric_multipliers();
      }
      break;
    case 201: // M201
      for(int8_t i=0; i < NUM_AXIS; i++)
      {
        if(code_seen(axis_codes[i]))
        {
          max_acceleration_units_per_sq_second[i] = code_value();
        }
      }
      // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
      reset_acceleration_rates();
      break;
    #if 0 // Not used for Sprinter/grbl gen6
    case 202: // M202
      for(int8_t i=0; i < NUM_AXIS; i++) {
        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
      }
      break;
    #endif
    case 203: // M203 max feedrate mm/sec
      for(int8_t i=0; i < NUM_AXIS; i++) {
        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();
      }
      break;
    case 204: // M204 acclereration S normal moves T filmanent only moves
      {
        if(code_seen('S')) acceleration = code_value() ;
        if(code_seen('T')) retract_acceleration = code_value() ;
      }
      break;
    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
    {
      if(code_seen('S')) minimumfeedrate = code_value();
      if(code_seen('T')) mintravelfeedrate = code_value();
      if(code_seen('B')) minsegmenttime = code_value() ;
      if(code_seen('X')) max_xy_jerk = code_value() ;
      if(code_seen('Z')) max_z_jerk = code_value() ;
      if(code_seen('E')) max_e_jerk = code_value() ;
    }
    break;
    case 206: // M206 additional homing offset
      for(int8_t i=0; i < 3; i++)
      {
        if(code_seen(axis_codes[i])) add_homing[i] = code_value();
      }
	  #ifdef SCARA
	   if(code_seen('T'))       // Theta
      {
        add_homing[X_AXIS] = code_value() ;
      }
      if(code_seen('P'))       // Psi
      {
        add_homing[Y_AXIS] = code_value() ;
      }
	  #endif
      break;
    #ifdef DELTA
	case 665: // M665 set delta configurations L<diagonal_rod> R<delta_radius> S<segments_per_sec>
		if(code_seen('L')) {
			delta_diagonal_rod= code_value();
		}
		if(code_seen('R')) {
			delta_radius= code_value();
		}
		if(code_seen('S')) {
			delta_segments_per_second= code_value();
		}
		
		recalc_delta_settings(delta_radius, delta_diagonal_rod);
		break;
    case 666: // M666 set delta endstop adjustemnt
      for(int8_t i=0; i < 3; i++)
      {
        if(code_seen(axis_codes[i])) endstop_adj[i] = code_value();
      }
      break;
    #endif
    #ifdef FWRETRACT
    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop]
    {
      if(code_seen('S'))
      {
        retract_length = code_value() ;
      }
      if(code_seen('F'))
      {
        retract_feedrate = code_value()/60 ;
      }
      if(code_seen('Z'))
      {
        retract_zlift = code_value() ;
      }
    }break;
    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
    {
      if(code_seen('S'))
      {
        retract_recover_length = code_value() ;
      }
      if(code_seen('F'))
      {
        retract_recover_feedrate = code_value()/60 ;
      }
    }break;
    case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
    {
      if(code_seen('S'))
      {
        int t= code_value() ;
        switch(t)
        {
          case 0: 
          {
            autoretract_enabled=false;
            retracted[0]=false;
            #if EXTRUDERS > 1
              retracted[1]=false;
            #endif
            #if EXTRUDERS > 2
              retracted[2]=false;
            #endif
          }break;
          case 1: 
          {
            autoretract_enabled=true;
            retracted[0]=false;
            #if EXTRUDERS > 1
              retracted[1]=false;
            #endif
            #if EXTRUDERS > 2
              retracted[2]=false;
            #endif
          }break;
          default:
            SERIAL_ECHO_START;
            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
            SERIAL_ECHO(cmdbuffer[bufindr]);
            SERIAL_ECHOLNPGM("\"");
        }
      }

    }break;
    #endif // FWRETRACT
    #if EXTRUDERS > 1
    case 218: // M218 - set hotend offset (in mm), T<extruder_number> X<offset_on_X> Y<offset_on_Y>
    {
      if(setTargetedHotend(218)){
        break;
      }
      if(code_seen('X'))
      {
        extruder_offset[X_AXIS][tmp_extruder] = code_value();
      }
      if(code_seen('Y'))
      {
        extruder_offset[Y_AXIS][tmp_extruder] = code_value();
      }
      #ifdef DUAL_X_CARRIAGE
      if(code_seen('Z'))
      {
        extruder_offset[Z_AXIS][tmp_extruder] = code_value();
      }
      #endif
      SERIAL_ECHO_START;
      SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
      for(tmp_extruder = 0; tmp_extruder < EXTRUDERS; tmp_extruder++)
      {
         SERIAL_ECHO(" ");
         SERIAL_ECHO(extruder_offset[X_AXIS][tmp_extruder]);
         SERIAL_ECHO(",");
         SERIAL_ECHO(extruder_offset[Y_AXIS][tmp_extruder]);
      #ifdef DUAL_X_CARRIAGE
         SERIAL_ECHO(",");
         SERIAL_ECHO(extruder_offset[Z_AXIS][tmp_extruder]);
      #endif
      }
      SERIAL_ECHOLN("");
    }break;
    #endif
    case 220: // M220 S<factor in percent>- set speed factor override percentage
    {
      if(code_seen('S'))
      {
        feedmultiply = code_value() ;
      }
    }
    break;
    case 221: // M221 S<factor in percent>- set extrude factor override percentage
    {
      if(code_seen('S'))
      {
        int tmp_code = code_value();
        if (code_seen('T'))
        {
          if(setTargetedHotend(221)){
            break;
          }
          extruder_multiply[tmp_extruder] = tmp_code;
        }
        else
        {
          extrudemultiply = tmp_code ;
        }
      }
    }
    break;

	case 226: // M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
	{
      if(code_seen('P')){
        int pin_number = code_value(); // pin number
        int pin_state = -1; // required pin state - default is inverted

        if(code_seen('S')) pin_state = code_value(); // required pin state

        if(pin_state >= -1 && pin_state <= 1){

          for(int8_t i = 0; i < (int8_t)(sizeof(sensitive_pins)/sizeof(int)); i++)
          {
            if (sensitive_pins[i] == pin_number)
            {
              pin_number = -1;
              break;
            }
          }

          if (pin_number > -1)
          {
            int target = LOW;

            st_synchronize();

            pinMode(pin_number, INPUT);

            switch(pin_state){
            case 1:
              target = HIGH;
              break;

            case 0:
              target = LOW;
              break;

            case -1:
              target = !digitalRead(pin_number);
              break;
            }

            while(digitalRead(pin_number) != target){
              manage_heater();
              manage_inactivity();
              lcd_update();
            }
          }
        }
      }
    }
    break;

    #if NUM_SERVOS > 0
    case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
      {
        int servo_index = -1;
        int servo_position = 0;
        if (code_seen('P'))
          servo_index = code_value();
        if (code_seen('S')) {
          servo_position = code_value();
          if ((servo_index >= 0) && (servo_index < NUM_SERVOS)) {
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
		      servos[servo_index].attach(0);
#endif
            servos[servo_index].write(servo_position);
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
              delay(PROBE_SERVO_DEACTIVATION_DELAY);
              servos[servo_index].detach();
#endif
          }
          else {
            SERIAL_ECHO_START;
            SERIAL_ECHO("Servo ");
            SERIAL_ECHO(servo_index);
            SERIAL_ECHOLN(" out of range");
          }
        }
        else if (servo_index >= 0) {
          SERIAL_PROTOCOL(MSG_OK);
          SERIAL_PROTOCOL(" Servo ");
          SERIAL_PROTOCOL(servo_index);
          SERIAL_PROTOCOL(": ");
          SERIAL_PROTOCOL(servos[servo_index].read());
          SERIAL_PROTOCOLLN("");
        }
      }
      break;
    #endif // NUM_SERVOS > 0

    #if (LARGE_FLASH == true && ( BEEPER > 0 || defined(ULTRALCD) || defined(LCD_USE_I2C_BUZZER)))
    case 300: // M300
    {
      int beepS = code_seen('S') ? code_value() : 110;
      int beepP = code_seen('P') ? code_value() : 1000;
      if (beepS > 0)
      {
        #if BEEPER > 0
          tone(BEEPER, beepS);
          delay(beepP);
          noTone(BEEPER);
        #elif defined(ULTRALCD)
		  lcd_buzz(beepS, beepP);
		#elif defined(LCD_USE_I2C_BUZZER)
		  lcd_buzz(beepP, beepS);
        #endif
      }
      else
      {
        delay(beepP);
      }
    }
    break;
    #endif // M300

    #ifdef PIDTEMP
    case 301: // M301
      {
        if(code_seen('P')) Kp = code_value();
        if(code_seen('I')) Ki = scalePID_i(code_value());
        if(code_seen('D')) Kd = scalePID_d(code_value());

        #ifdef PID_ADD_EXTRUSION_RATE
        if(code_seen('C')) Kc = code_value();
        #endif

        updatePID();
        SERIAL_PROTOCOL(MSG_OK);
        SERIAL_PROTOCOL(" p:");
        SERIAL_PROTOCOL(Kp);
        SERIAL_PROTOCOL(" i:");
        SERIAL_PROTOCOL(unscalePID_i(Ki));
        SERIAL_PROTOCOL(" d:");
        SERIAL_PROTOCOL(unscalePID_d(Kd));
        #ifdef PID_ADD_EXTRUSION_RATE
        SERIAL_PROTOCOL(" c:");
        //Kc does not have scaling applied above, or in resetting defaults
        SERIAL_PROTOCOL(Kc);
        #endif
        SERIAL_PROTOCOLLN("");
      }
      break;
    #endif //PIDTEMP
    #ifdef PIDTEMPBED
    case 304: // M304
      {
        if(code_seen('P')) bedKp = code_value();
        if(code_seen('I')) bedKi = scalePID_i(code_value());
        if(code_seen('D')) bedKd = scalePID_d(code_value());

        updatePID();
        SERIAL_PROTOCOL(MSG_OK);
        SERIAL_PROTOCOL(" p:");
        SERIAL_PROTOCOL(bedKp);
        SERIAL_PROTOCOL(" i:");
        SERIAL_PROTOCOL(unscalePID_i(bedKi));
        SERIAL_PROTOCOL(" d:");
        SERIAL_PROTOCOL(unscalePID_d(bedKd));
        SERIAL_PROTOCOLLN("");
      }
      break;
    #endif //PIDTEMP
    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
     {
     	#ifdef CHDK
       
         SET_OUTPUT(CHDK);
         WRITE(CHDK, HIGH);
         chdkHigh = millis();
         chdkActive = true;
       
       #else
     	
      	#if defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN > -1
	const uint8_t NUM_PULSES=16;
	const float PULSE_LENGTH=0.01524;
	for(int i=0; i < NUM_PULSES; i++) {
        WRITE(PHOTOGRAPH_PIN, HIGH);
        _delay_ms(PULSE_LENGTH);
        WRITE(PHOTOGRAPH_PIN, LOW);
        _delay_ms(PULSE_LENGTH);
        }
        delay(7.33);
        for(int i=0; i < NUM_PULSES; i++) {
        WRITE(PHOTOGRAPH_PIN, HIGH);
        _delay_ms(PULSE_LENGTH);
        WRITE(PHOTOGRAPH_PIN, LOW);
        _delay_ms(PULSE_LENGTH);
        }
      	#endif
      #endif //chdk end if
     }
    break;
#ifdef DOGLCD
    case 250: // M250  Set LCD contrast value: C<value> (value 0..63)
     {
	  if (code_seen('C')) {
	   lcd_setcontrast( ((int)code_value())&63 );
          }
          SERIAL_PROTOCOLPGM("lcd contrast value: ");
          SERIAL_PROTOCOL(lcd_contrast);
          SERIAL_PROTOCOLLN("");
     }
    break;
#endif
    #ifdef PREVENT_DANGEROUS_EXTRUDE
    case 302: // allow cold extrudes, or set the minimum extrude temperature
    {
	  float temp = .0;
	  if (code_seen('S')) temp=code_value();
      set_extrude_min_temp(temp);
    }
    break;
	#endif
    case 303: // M303 PID autotune
    {
      float temp = 150.0;
      int e=0;
      int c=5;
      if (code_seen('E')) e=code_value();
        if (e<0)
          temp=70;
      if (code_seen('S')) temp=code_value();
      if (code_seen('C')) c=code_value();
      PID_autotune(temp, e, c);
    }
    break;
	#ifdef SCARA
	case 360:  // M360 SCARA Theta pos1
      SERIAL_ECHOLN(" Cal: Theta 0 ");
      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
      //SERIAL_ECHOLN(" Soft endstops disabled ");
      if(Stopped == false) {
        //get_coordinates(); // For X Y Z E F
        delta[X_AXIS] = 0;
        delta[Y_AXIS] = 120;
        calculate_SCARA_forward_Transform(delta);
        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
        
        prepare_move();
        //ClearToSend();
        return;
      }
    break;

    case 361:  // SCARA Theta pos2
      SERIAL_ECHOLN(" Cal: Theta 90 ");
      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
      //SERIAL_ECHOLN(" Soft endstops disabled ");
      if(Stopped == false) {
        //get_coordinates(); // For X Y Z E F
        delta[X_AXIS] = 90;
        delta[Y_AXIS] = 130;
        calculate_SCARA_forward_Transform(delta);
        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
        
        prepare_move();
        //ClearToSend();
        return;
      }
    break;
    case 362:  // SCARA Psi pos1
      SERIAL_ECHOLN(" Cal: Psi 0 ");
      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
      //SERIAL_ECHOLN(" Soft endstops disabled ");
      if(Stopped == false) {
        //get_coordinates(); // For X Y Z E F
        delta[X_AXIS] = 60;
        delta[Y_AXIS] = 180;
        calculate_SCARA_forward_Transform(delta);
        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
        
        prepare_move();
        //ClearToSend();
        return;
      }
    break;
    case 363:  // SCARA Psi pos2
      SERIAL_ECHOLN(" Cal: Psi 90 ");
      //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
      //SERIAL_ECHOLN(" Soft endstops disabled ");
      if(Stopped == false) {
        //get_coordinates(); // For X Y Z E F
        delta[X_AXIS] = 50;
        delta[Y_AXIS] = 90;
        calculate_SCARA_forward_Transform(delta);
        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
        
        prepare_move();
        //ClearToSend();
        return;
      }
    break;
    case 364:  // SCARA Psi pos3 (90 deg to Theta)
      SERIAL_ECHOLN(" Cal: Theta-Psi 90 ");
     // SoftEndsEnabled = false;              // Ignore soft endstops during calibration
      //SERIAL_ECHOLN(" Soft endstops disabled ");
      if(Stopped == false) {
        //get_coordinates(); // For X Y Z E F
        delta[X_AXIS] = 45;
        delta[Y_AXIS] = 135;
        calculate_SCARA_forward_Transform(delta);
        destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
        destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS]; 
        
        prepare_move();
        //ClearToSend();
        return;
      }
    break;
    case 365: // M364  Set SCARA scaling for X Y Z
      for(int8_t i=0; i < 3; i++) 
      {
        if(code_seen(axis_codes[i])) 
        {
          
            axis_scaling[i] = code_value();
          
        }
      }
      break;
	#endif
    case 400: // M400 finish all moves
    {
      st_synchronize();
    }
    break;
#if defined(ENABLE_AUTO_BED_LEVELING) && defined(SERVO_ENDSTOPS) && not defined(Z_PROBE_SLED)
    case 401:
    {
        engage_z_probe();    // Engage Z Servo endstop if available
    }
    break;

    case 402:
    {
        retract_z_probe();    // Retract Z Servo endstop if enabled
    }
    break;
#endif

#ifdef FILAMENT_SENSOR
case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width 
    {
    #if (FILWIDTH_PIN > -1) 
    if(code_seen('N')) filament_width_nominal=code_value();
    else{
    SERIAL_PROTOCOLPGM("Filament dia (nominal mm):"); 
    SERIAL_PROTOCOLLN(filament_width_nominal); 
    }
    #endif
    }
    break; 
    
    case 405:  //M405 Turn on filament sensor for control 
    {
    
    
    if(code_seen('D')) meas_delay_cm=code_value();
       
       if(meas_delay_cm> MAX_MEASUREMENT_DELAY)
       	meas_delay_cm = MAX_MEASUREMENT_DELAY;
    
       if(delay_index2 == -1)  //initialize the ring buffer if it has not been done since startup
    	   {
    	   int temp_ratio = widthFil_to_size_ratio(); 
       	    
       	    for (delay_index1=0; delay_index1<(MAX_MEASUREMENT_DELAY+1); ++delay_index1 ){
       	              measurement_delay[delay_index1]=temp_ratio-100;  //subtract 100 to scale within a signed byte
       	        }
       	    delay_index1=0;
       	    delay_index2=0;	
    	   }
    
    filament_sensor = true ; 
    
    //SERIAL_PROTOCOLPGM("Filament dia (measured mm):"); 
    //SERIAL_PROTOCOL(filament_width_meas); 
    //SERIAL_PROTOCOLPGM("Extrusion ratio(%):"); 
    //SERIAL_PROTOCOL(extrudemultiply); 
    } 
    break; 
    
    case 406:  //M406 Turn off filament sensor for control 
    {      
    filament_sensor = false ; 
    } 
    break; 
  
    case 407:   //M407 Display measured filament diameter 
    { 
     
    
    
    SERIAL_PROTOCOLPGM("Filament dia (measured mm):"); 
    SERIAL_PROTOCOLLN(filament_width_meas);   
    } 
    break; 
    #endif
    




    case 500: // M500 Store settings in EEPROM
    {
        Config_StoreSettings();
    }
    break;
    case 501: // M501 Read settings from EEPROM
    {
        Config_RetrieveSettings();
    }
    break;
    case 502: // M502 Revert to default settings
    {
        Config_ResetDefault();
    }
    break;
    case 503: // M503 print settings currently in memory
    {
        Config_PrintSettings();
    }
    break;
    #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
    case 540:
    {
        if(code_seen('S')) abort_on_endstop_hit = code_value() > 0;
    }
    break;
    #endif

    #ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET
    case CUSTOM_M_CODE_SET_Z_PROBE_OFFSET:
    {
      float value;
      if (code_seen('Z'))
      {
        value = code_value();
        if ((Z_PROBE_OFFSET_RANGE_MIN <= value) && (value <= Z_PROBE_OFFSET_RANGE_MAX))
        {
          zprobe_zoffset = -value; // compare w/ line 278 of ConfigurationStore.cpp
          SERIAL_ECHO_START;
          SERIAL_ECHOLNPGM(MSG_ZPROBE_ZOFFSET " " MSG_OK);
          SERIAL_PROTOCOLLN("");
        }
        else
        {
          SERIAL_ECHO_START;
          SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET);
          SERIAL_ECHOPGM(MSG_Z_MIN);
          SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MIN);
          SERIAL_ECHOPGM(MSG_Z_MAX);
          SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MAX);
          SERIAL_PROTOCOLLN("");
        }
      }
      else
      {
          SERIAL_ECHO_START;
          SERIAL_ECHOLNPGM(MSG_ZPROBE_ZOFFSET " : ");
          SERIAL_ECHO(-zprobe_zoffset);
          SERIAL_PROTOCOLLN("");
      }
      break;
    }
    #endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET

    #ifdef FILAMENTCHANGEENABLE
    case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
    {
        float target[4];
        float lastpos[4];
        target[X_AXIS]=current_position[X_AXIS];
        target[Y_AXIS]=current_position[Y_AXIS];
        target[Z_AXIS]=current_position[Z_AXIS];
        target[E_AXIS]=current_position[E_AXIS];
        lastpos[X_AXIS]=current_position[X_AXIS];
        lastpos[Y_AXIS]=current_position[Y_AXIS];
        lastpos[Z_AXIS]=current_position[Z_AXIS];
        lastpos[E_AXIS]=current_position[E_AXIS];
        //retract by E
        if(code_seen('E'))
        {
          target[E_AXIS]+= code_value();
        }
        else
        {
          #ifdef FILAMENTCHANGE_FIRSTRETRACT
            target[E_AXIS]+= FILAMENTCHANGE_FIRSTRETRACT ;
          #endif
        }
        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);

        //lift Z
        if(code_seen('Z'))
        {
          target[Z_AXIS]+= code_value();
        }
        else
        {
          #ifdef FILAMENTCHANGE_ZADD
            target[Z_AXIS]+= FILAMENTCHANGE_ZADD ;
          #endif
        }
        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);

        //move xy
        if(code_seen('X'))
        {
          target[X_AXIS]+= code_value();
        }
        else
        {
          #ifdef FILAMENTCHANGE_XPOS
            target[X_AXIS]= FILAMENTCHANGE_XPOS ;
          #endif
        }
        if(code_seen('Y'))
        {
          target[Y_AXIS]= code_value();
        }
        else
        {
          #ifdef FILAMENTCHANGE_YPOS
            target[Y_AXIS]= FILAMENTCHANGE_YPOS ;
          #endif
        }

        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);

        if(code_seen('L'))
        {
          target[E_AXIS]+= code_value();
        }
        else
        {
          #ifdef FILAMENTCHANGE_FINALRETRACT
            target[E_AXIS]+= FILAMENTCHANGE_FINALRETRACT ;
          #endif
        }

        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);

        //finish moves
        st_synchronize();
        //disable extruder steppers so filament can be removed
        disable_e0();
        disable_e1();
        disable_e2();
        delay(100);
        LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);
        uint8_t cnt=0;
        while(!lcd_clicked()){
          cnt++;
          manage_heater();
          manage_inactivity(true);
          lcd_update();
          if(cnt==0)
          {
          #if BEEPER > 0
            SET_OUTPUT(BEEPER);

            WRITE(BEEPER,HIGH);
            delay(3);
            WRITE(BEEPER,LOW);
            delay(3);
          #else
			#if !defined(LCD_FEEDBACK_FREQUENCY_HZ) || !defined(LCD_FEEDBACK_FREQUENCY_DURATION_MS)
              lcd_buzz(1000/6,100);
			#else
			  lcd_buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS,LCD_FEEDBACK_FREQUENCY_HZ);
			#endif
          #endif
          }
        }

        //return to normal
        if(code_seen('L'))
        {
          target[E_AXIS]+= -code_value();
        }
        else
        {
          #ifdef FILAMENTCHANGE_FINALRETRACT
            target[E_AXIS]+=(-1)*FILAMENTCHANGE_FINALRETRACT ;
          #endif
        }
        current_position[E_AXIS]=target[E_AXIS]; //the long retract of L is compensated by manual filament feeding
        plan_set_e_position(current_position[E_AXIS]);
        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //should do nothing
        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move xy back
        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move z back
        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], lastpos[E_AXIS], feedrate/60, active_extruder); //final untretract
    }
    break;
    #endif //FILAMENTCHANGEENABLE
    #ifdef DUAL_X_CARRIAGE
    case 605: // Set dual x-carriage movement mode:
              //    M605 S0: Full control mode. The slicer has full control over x-carriage movement
              //    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
              //    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
              //                         millimeters x-offset and an optional differential hotend temperature of
              //                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
              //                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
              //
              //    Note: the X axis should be homed after changing dual x-carriage mode.
    {
        st_synchronize();

        if (code_seen('S'))
          dual_x_carriage_mode = code_value();

        if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
        {
          if (code_seen('X'))
            duplicate_extruder_x_offset = max(code_value(),X2_MIN_POS - x_home_pos(0));

          if (code_seen('R'))
            duplicate_extruder_temp_offset = code_value();

          SERIAL_ECHO_START;
          SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
          SERIAL_ECHO(" ");
          SERIAL_ECHO(extruder_offset[X_AXIS][0]);
          SERIAL_ECHO(",");
          SERIAL_ECHO(extruder_offset[Y_AXIS][0]);
          SERIAL_ECHO(" ");
          SERIAL_ECHO(duplicate_extruder_x_offset);
          SERIAL_ECHO(",");
          SERIAL_ECHOLN(extruder_offset[Y_AXIS][1]);
        }
        else if (dual_x_carriage_mode != DXC_FULL_CONTROL_MODE && dual_x_carriage_mode != DXC_AUTO_PARK_MODE)
        {
          dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
        }

        active_extruder_parked = false;
        extruder_duplication_enabled = false;
        delayed_move_time = 0;
    }
    break;
    #endif //DUAL_X_CARRIAGE

    case 907: // M907 Set digital trimpot motor current using axis codes.
    {
      #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
        for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());
        if(code_seen('B')) digipot_current(4,code_value());
        if(code_seen('S')) for(int i=0;i<=4;i++) digipot_current(i,code_value());
      #endif
      #ifdef MOTOR_CURRENT_PWM_XY_PIN
        if(code_seen('X')) digipot_current(0, code_value());
      #endif
      #ifdef MOTOR_CURRENT_PWM_Z_PIN
        if(code_seen('Z')) digipot_current(1, code_value());
      #endif
      #ifdef MOTOR_CURRENT_PWM_E_PIN
        if(code_seen('E')) digipot_current(2, code_value());
      #endif
      #ifdef DIGIPOT_I2C
        // this one uses actual amps in floating point
        for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value());
        // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
        for(int i=NUM_AXIS;i<DIGIPOT_I2C_NUM_CHANNELS;i++) if(code_seen('B'+i-NUM_AXIS)) digipot_i2c_set_current(i, code_value());
      #endif
    }
    break;
    case 908: // M908 Control digital trimpot directly.
    {
      #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN > -1
        uint8_t channel,current;
        if(code_seen('P')) channel=code_value();
        if(code_seen('S')) current=code_value();
        digitalPotWrite(channel, current);
      #endif
    }
    break;
    case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
    {
      #if defined(X_MS1_PIN) && X_MS1_PIN > -1
        if(code_seen('S')) for(int i=0;i<=4;i++) microstep_mode(i,code_value());
        for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());
        if(code_seen('B')) microstep_mode(4,code_value());
        microstep_readings();
      #endif
    }
    break;
    case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
    {
      #if defined(X_MS1_PIN) && X_MS1_PIN > -1
      if(code_seen('S')) switch((int)code_value())
      {
        case 1:
          for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);
          if(code_seen('B')) microstep_ms(4,code_value(),-1);
          break;
        case 2:
          for(int i=0;i<NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());
          if(code_seen('B')) microstep_ms(4,-1,code_value());
          break;
      }
      microstep_readings();
      #endif
    }
    break;
    case 999: // M999: Restart after being stopped
      Stopped = false;
      lcd_reset_alert_level();
      gcode_LastN = Stopped_gcode_LastN;
      FlushSerialRequestResend();
    break;
    }
  }

  else if(code_seen('T'))
  {
    tmp_extruder = code_value();
    if(tmp_extruder >= EXTRUDERS) {
      SERIAL_ECHO_START;
      SERIAL_ECHO("T");
      SERIAL_ECHO(tmp_extruder);
      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
    }
    else {
      boolean make_move = false;
      if(code_seen('F')) {
        make_move = true;
        next_feedrate = code_value();
        if(next_feedrate > 0.0) {
          feedrate = next_feedrate;
        }
      }
      #if EXTRUDERS > 1
      if(tmp_extruder != active_extruder) {
        // Save current position to return to after applying extruder offset
        memcpy(destination, current_position, sizeof(destination));
      #ifdef DUAL_X_CARRIAGE
        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false &&
            (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))
        {
          // Park old head: 1) raise 2) move to park position 3) lower
          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
          st_synchronize();
        }

        // apply Y & Z extruder offset (x offset is already used in determining home pos)
        current_position[Y_AXIS] = current_position[Y_AXIS] -
                     extruder_offset[Y_AXIS][active_extruder] +
                     extruder_offset[Y_AXIS][tmp_extruder];
        current_position[Z_AXIS] = current_position[Z_AXIS] -
                     extruder_offset[Z_AXIS][active_extruder] +
                     extruder_offset[Z_AXIS][tmp_extruder];

        active_extruder = tmp_extruder;

        // This function resets the max/min values - the current position may be overwritten below.
        axis_is_at_home(X_AXIS);

        if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE)
        {
          current_position[X_AXIS] = inactive_extruder_x_pos;
          inactive_extruder_x_pos = destination[X_AXIS];
        }
        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
        {
          active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
          if (active_extruder == 0 || active_extruder_parked)
            current_position[X_AXIS] = inactive_extruder_x_pos;
          else
            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
          inactive_extruder_x_pos = destination[X_AXIS];
          extruder_duplication_enabled = false;
        }
        else
        {
          // record raised toolhead position for use by unpark
          memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
          raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
          active_extruder_parked = true;
          delayed_move_time = 0;
        }
      #else
        // Offset extruder (only by XY)
        int i;
        for(i = 0; i < 2; i++) {
           current_position[i] = current_position[i] -
                                 extruder_offset[i][active_extruder] +
                                 extruder_offset[i][tmp_extruder];
        }
        // Set the new active extruder and position
        active_extruder = tmp_extruder;
      #endif //else DUAL_X_CARRIAGE
#ifdef DELTA 

  calculate_delta(current_position); // change cartesian kinematic  to  delta kinematic;
   //sent position to plan_set_position();
  plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],current_position[E_AXIS]);
            
#else
        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);

#endif
        // Move to the old position if 'F' was in the parameters
        if(make_move && Stopped == false) {
           prepare_move();
        }
      }
      #endif
      SERIAL_ECHO_START;
      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
      SERIAL_PROTOCOLLN((int)active_extruder);
    }
  }

  else
  {
    SERIAL_ECHO_START;
    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
    SERIAL_ECHO(cmdbuffer[bufindr]);
    SERIAL_ECHOLNPGM("\"");
  }

  ClearToSend();
}

void FlushSerialRequestResend()
{
  //char cmdbuffer[bufindr][100]="Resend:";
  MYSERIAL.flush();
  SERIAL_PROTOCOLPGM(MSG_RESEND);
  SERIAL_PROTOCOLLN(gcode_LastN + 1);
  ClearToSend();
}

void ClearToSend()
{
  previous_millis_cmd = millis();
  #ifdef SDSUPPORT
  if(fromsd[bufindr])
    return;
  #endif //SDSUPPORT
  SERIAL_PROTOCOLLNPGM(MSG_OK);
}

void get_coordinates()
{
  bool seen[4]={false,false,false,false};
  for(int8_t i=0; i < NUM_AXIS; i++) {
    if(code_seen(axis_codes[i]))
    {
      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];
      seen[i]=true;
    }
    else destination[i] = current_position[i]; //Are these else lines really needed?
  }
  if(code_seen('F')) {
    next_feedrate = code_value();
    if(next_feedrate > 0.0) feedrate = next_feedrate;
  }
}

void get_arc_coordinates()
{
#ifdef SF_ARC_FIX
   bool relative_mode_backup = relative_mode;
   relative_mode = true;
#endif
   get_coordinates();
#ifdef SF_ARC_FIX
   relative_mode=relative_mode_backup;
#endif

   if(code_seen('I')) {
     offset[0] = code_value();
   }
   else {
     offset[0] = 0.0;
   }
   if(code_seen('J')) {
     offset[1] = code_value();
   }
   else {
     offset[1] = 0.0;
   }
}

void clamp_to_software_endstops(float target[3])
{
  if (min_software_endstops) {
    if (target[X_AXIS] < min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];
    if (target[Y_AXIS] < min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];
    
    float negative_z_offset = 0;
    #ifdef ENABLE_AUTO_BED_LEVELING
      if (Z_PROBE_OFFSET_FROM_EXTRUDER < 0) negative_z_offset = negative_z_offset + Z_PROBE_OFFSET_FROM_EXTRUDER;
      if (add_homing[Z_AXIS] < 0) negative_z_offset = negative_z_offset + add_homing[Z_AXIS];
    #endif
    
    if (target[Z_AXIS] < min_pos[Z_AXIS]+negative_z_offset) target[Z_AXIS] = min_pos[Z_AXIS]+negative_z_offset;
  }

  if (max_software_endstops) {
    if (target[X_AXIS] > max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];
    if (target[Y_AXIS] > max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];
    if (target[Z_AXIS] > max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];
  }
}

#ifdef DELTA
void recalc_delta_settings(float radius, float diagonal_rod)
{
	 delta_tower1_x= -SIN_60*radius; // front left tower
	 delta_tower1_y= -COS_60*radius;	   
	 delta_tower2_x=  SIN_60*radius; // front right tower
	 delta_tower2_y= -COS_60*radius;	   
	 delta_tower3_x= 0.0;                  // back middle tower
	 delta_tower3_y= radius;
	 delta_diagonal_rod_2= sq(diagonal_rod);
}

void calculate_delta(float cartesian[3])
{
  delta[X_AXIS] = sqrt(delta_diagonal_rod_2
                       - sq(delta_tower1_x-cartesian[X_AXIS])
                       - sq(delta_tower1_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
  delta[Y_AXIS] = sqrt(delta_diagonal_rod_2
                       - sq(delta_tower2_x-cartesian[X_AXIS])
                       - sq(delta_tower2_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
  delta[Z_AXIS] = sqrt(delta_diagonal_rod_2
                       - sq(delta_tower3_x-cartesian[X_AXIS])
                       - sq(delta_tower3_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
  /*
  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);

  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
  */
}
#endif

void prepare_move()
{
  clamp_to_software_endstops(destination);
  previous_millis_cmd = millis();
  
  #ifdef SCARA //for now same as delta-code

float difference[NUM_AXIS];
for (int8_t i=0; i < NUM_AXIS; i++) {
	difference[i] = destination[i] - current_position[i];
}

float cartesian_mm = sqrt(	sq(difference[X_AXIS]) +
							sq(difference[Y_AXIS]) +
							sq(difference[Z_AXIS]));
if (cartesian_mm < 0.000001) { cartesian_mm = abs(difference[E_AXIS]); }
if (cartesian_mm < 0.000001) { return; }
float seconds = 6000 * cartesian_mm / feedrate / feedmultiply;
int steps = max(1, int(scara_segments_per_second * seconds));
 //SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);
 //SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);
 //SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);
for (int s = 1; s <= steps; s++) {
	float fraction = float(s) / float(steps);
	for(int8_t i=0; i < NUM_AXIS; i++) {
		destination[i] = current_position[i] + difference[i] * fraction;
	}

	
	calculate_delta(destination);
         //SERIAL_ECHOPGM("destination[X_AXIS]="); SERIAL_ECHOLN(destination[X_AXIS]);
         //SERIAL_ECHOPGM("destination[Y_AXIS]="); SERIAL_ECHOLN(destination[Y_AXIS]);
         //SERIAL_ECHOPGM("destination[Z_AXIS]="); SERIAL_ECHOLN(destination[Z_AXIS]);
         //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);
         //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
         //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);
         
	plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
	destination[E_AXIS], feedrate*feedmultiply/60/100.0,
	active_extruder);
}
#endif // SCARA
  
#ifdef DELTA
  float difference[NUM_AXIS];
  for (int8_t i=0; i < NUM_AXIS; i++) {
    difference[i] = destination[i] - current_position[i];
  }
  float cartesian_mm = sqrt(sq(difference[X_AXIS]) +
                            sq(difference[Y_AXIS]) +
                            sq(difference[Z_AXIS]));
  if (cartesian_mm < 0.000001) { cartesian_mm = abs(difference[E_AXIS]); }
  if (cartesian_mm < 0.000001) { return; }
  float seconds = 6000 * cartesian_mm / feedrate / feedmultiply;
  int steps = max(1, int(delta_segments_per_second * seconds));
  // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);
  // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);
  // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);
  for (int s = 1; s <= steps; s++) {
    float fraction = float(s) / float(steps);
    for(int8_t i=0; i < NUM_AXIS; i++) {
      destination[i] = current_position[i] + difference[i] * fraction;
    }
    calculate_delta(destination);
    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
                     destination[E_AXIS], feedrate*feedmultiply/60/100.0,
                     active_extruder);
  }
  
#endif // DELTA

#ifdef DUAL_X_CARRIAGE
  if (active_extruder_parked)
  {
    if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0)
    {
      // move duplicate extruder into correct duplication position.
      plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS],
          current_position[E_AXIS], max_feedrate[X_AXIS], 1);
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      st_synchronize();
      extruder_duplication_enabled = true;
      active_extruder_parked = false;
    }
    else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) // handle unparking of head
    {
      if (current_position[E_AXIS] == destination[E_AXIS])
      {
        // this is a travel move - skit it but keep track of current position (so that it can later
        // be used as start of first non-travel move)
        if (delayed_move_time != 0xFFFFFFFFUL)
        {
          memcpy(current_position, destination, sizeof(current_position));
          if (destination[Z_AXIS] > raised_parked_position[Z_AXIS])
            raised_parked_position[Z_AXIS] = destination[Z_AXIS];
          delayed_move_time = millis();
          return;
        }
      }
      delayed_move_time = 0;
      // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
      plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS],    current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS],
          current_position[E_AXIS], min(max_feedrate[X_AXIS],max_feedrate[Y_AXIS]), active_extruder);
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
          current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
      active_extruder_parked = false;
    }
  }
#endif //DUAL_X_CARRIAGE

#if ! (defined DELTA || defined SCARA)
  // Do not use feedmultiply for E or Z only moves
  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {
      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);
  }
  else {
    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);
  }
#endif // !(DELTA || SCARA)

  for(int8_t i=0; i < NUM_AXIS; i++) {
    current_position[i] = destination[i];
  }
}

void prepare_arc_move(char isclockwise) {
  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc

  // Trace the arc
  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);

  // As far as the parser is concerned, the position is now == target. In reality the
  // motion control system might still be processing the action and the real tool position
  // in any intermediate location.
  for(int8_t i=0; i < NUM_AXIS; i++) {
    current_position[i] = destination[i];
  }
  previous_millis_cmd = millis();
}

#if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1

#if defined(FAN_PIN)
  #if CONTROLLERFAN_PIN == FAN_PIN
    #error "You cannot set CONTROLLERFAN_PIN equal to FAN_PIN"
  #endif
#endif

unsigned long lastMotor = 0; //Save the time for when a motor was turned on last
unsigned long lastMotorCheck = 0;

void controllerFan()
{
  if ((millis() - lastMotorCheck) >= 2500) //Not a time critical function, so we only check every 2500ms
  {
    lastMotorCheck = millis();

    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN) || (soft_pwm_bed > 0)
    #if EXTRUDERS > 2
       || !READ(E2_ENABLE_PIN)
    #endif
    #if EXTRUDER > 1
      #if defined(X2_ENABLE_PIN) && X2_ENABLE_PIN > -1
       || !READ(X2_ENABLE_PIN)
      #endif
       || !READ(E1_ENABLE_PIN)
    #endif
       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...
    {
      lastMotor = millis(); //... set time to NOW so the fan will turn on
    }

    if ((millis() - lastMotor) >= (CONTROLLERFAN_SECS*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...
    {
        digitalWrite(CONTROLLERFAN_PIN, 0);
        analogWrite(CONTROLLERFAN_PIN, 0);
    }
    else
    {
        // allows digital or PWM fan output to be used (see M42 handling)
        digitalWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);
        analogWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);
    }
  }
}
#endif

#ifdef SCARA
void calculate_SCARA_forward_Transform(float f_scara[3])
{
  // Perform forward kinematics, and place results in delta[3]
  // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
  
  float x_sin, x_cos, y_sin, y_cos;
  
    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);
    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);
  
    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
   
  //  SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);
  //  SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);
  //  SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);
  //  SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);
  
    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta
    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi
	
    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);
    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
}  

void calculate_delta(float cartesian[3]){
  //reverse kinematics.
  // Perform reversed kinematics, and place results in delta[3]
  // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
  
  float SCARA_pos[2];
  static float SCARA_C2, SCARA_S2, SCARA_K1, SCARA_K2, SCARA_theta, SCARA_psi; 
  
  SCARA_pos[X_AXIS] = cartesian[X_AXIS] * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y
  SCARA_pos[Y_AXIS] = cartesian[Y_AXIS] * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.
  
  #if (Linkage_1 == Linkage_2)
    SCARA_C2 = ( ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) ) / (2 * (float)L1_2) ) - 1;
  #else
    SCARA_C2 =   ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) - (float)L1_2 - (float)L2_2 ) / 45000; 
  #endif
  
  SCARA_S2 = sqrt( 1 - sq(SCARA_C2) );
  
  SCARA_K1 = Linkage_1 + Linkage_2 * SCARA_C2;
  SCARA_K2 = Linkage_2 * SCARA_S2;
  
  SCARA_theta = ( atan2(SCARA_pos[X_AXIS],SCARA_pos[Y_AXIS])-atan2(SCARA_K1, SCARA_K2) ) * -1;
  SCARA_psi   =   atan2(SCARA_S2,SCARA_C2);
  
  delta[X_AXIS] = SCARA_theta * SCARA_RAD2DEG;  // Multiply by 180/Pi  -  theta is support arm angle
  delta[Y_AXIS] = (SCARA_theta + SCARA_psi) * SCARA_RAD2DEG;  //       -  equal to sub arm angle (inverted motor)
  delta[Z_AXIS] = cartesian[Z_AXIS];
  
  /*
  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);
  
  SERIAL_ECHOPGM("scara x="); SERIAL_ECHO(SCARA_pos[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHOLN(SCARA_pos[Y_AXIS]);
  
  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
  
  SERIAL_ECHOPGM("C2="); SERIAL_ECHO(SCARA_C2);
  SERIAL_ECHOPGM(" S2="); SERIAL_ECHO(SCARA_S2);
  SERIAL_ECHOPGM(" Theta="); SERIAL_ECHO(SCARA_theta);
  SERIAL_ECHOPGM(" Psi="); SERIAL_ECHOLN(SCARA_psi);
  SERIAL_ECHOLN(" ");*/
}

#endif

#ifdef TEMP_STAT_LEDS
static bool blue_led = false;
static bool red_led = false;
static uint32_t stat_update = 0;

void handle_status_leds(void) {
  float max_temp = 0.0;
  if(millis() > stat_update) {
    stat_update += 500; // Update every 0.5s
    for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder) {
       max_temp = max(max_temp, degHotend(cur_extruder));
       max_temp = max(max_temp, degTargetHotend(cur_extruder));
    }
    #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
      max_temp = max(max_temp, degTargetBed());
      max_temp = max(max_temp, degBed());
    #endif
    if((max_temp > 55.0) && (red_led == false)) {
      digitalWrite(STAT_LED_RED, 1);
      digitalWrite(STAT_LED_BLUE, 0);
      red_led = true;
      blue_led = false;
    }
    if((max_temp < 54.0) && (blue_led == false)) {
      digitalWrite(STAT_LED_RED, 0);
      digitalWrite(STAT_LED_BLUE, 1);
      red_led = false;
      blue_led = true;
    }
  }
}
#endif

void manage_inactivity(bool ignore_stepper_queue/*=false*/) //default argument set in Marlin.h
{
	
#if defined(KILL_PIN) && KILL_PIN > -1
	static int killCount = 0;   // make the inactivity button a bit less responsive
   const int KILL_DELAY = 10000;
#endif

#if defined(HOME_PIN) && HOME_PIN > -1
   static int homeDebounceCount = 0;   // poor man's debouncing count
   const int HOME_DEBOUNCE_DELAY = 10000;
#endif
   
	
  if(buflen < (BUFSIZE-1))
    get_command();

  if( (millis() - previous_millis_cmd) >  max_inactive_time )
    if(max_inactive_time)
      kill();
  if(stepper_inactive_time)  {
    if( (millis() - previous_millis_cmd) >  stepper_inactive_time )
    {
      if(blocks_queued() == false && ignore_stepper_queue == false) {
        disable_x();
        disable_y();
        disable_z();
        disable_e0();
        disable_e1();
        disable_e2();
      }
    }
  }
  
  #ifdef CHDK //Check if pin should be set to LOW after M240 set it to HIGH
    if (chdkActive && (millis() - chdkHigh > CHDK_DELAY))
    {
      chdkActive = false;
      WRITE(CHDK, LOW);
    }
  #endif
  
  #if defined(KILL_PIN) && KILL_PIN > -1
    
    // Check if the kill button was pressed and wait just in case it was an accidental
    // key kill key press
    // -------------------------------------------------------------------------------
    if( 0 == READ(KILL_PIN) )
    {
       killCount++;
    }
    else if (killCount > 0)
    {
       killCount--;
    }
    // Exceeded threshold and we can confirm that it was not accidental
    // KILL the machine
    // ----------------------------------------------------------------
    if ( killCount >= KILL_DELAY)
    {
       kill();
    }
  #endif

#if defined(HOME_PIN) && HOME_PIN > -1
    // Check to see if we have to home, use poor man's debouncer
    // ---------------------------------------------------------
    if ( 0 == READ(HOME_PIN) )
    {
       if (homeDebounceCount == 0)
       {
          enquecommand_P((PSTR("G28")));
          homeDebounceCount++;
          LCD_ALERTMESSAGEPGM(MSG_AUTO_HOME);
       }
       else if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
       {
          homeDebounceCount++;
       }
       else
       {
          homeDebounceCount = 0;
       }
    }
#endif
    
  #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1
    controllerFan(); //Check if fan should be turned on to cool stepper drivers down
  #endif
  #ifdef EXTRUDER_RUNOUT_PREVENT
    if( (millis() - previous_millis_cmd) >  EXTRUDER_RUNOUT_SECONDS*1000 )
    if(degHotend(active_extruder)>EXTRUDER_RUNOUT_MINTEMP)
    {
     bool oldstatus=READ(E0_ENABLE_PIN);
     enable_e0();
     float oldepos=current_position[E_AXIS];
     float oldedes=destination[E_AXIS];
     plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
     current_position[E_AXIS]=oldepos;
     destination[E_AXIS]=oldedes;
     plan_set_e_position(oldepos);
     previous_millis_cmd=millis();
     st_synchronize();
     WRITE(E0_ENABLE_PIN,oldstatus);
    }
  #endif
  #if defined(DUAL_X_CARRIAGE)
    // handle delayed move timeout
    if (delayed_move_time != 0 && (millis() - delayed_move_time) > 1000 && Stopped == false)
    {
      // travel moves have been received so enact them
      delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
      memcpy(destination,current_position,sizeof(destination));
      prepare_move();
    }
  #endif
  #ifdef TEMP_STAT_LEDS
      handle_status_leds();
  #endif
  check_axes_activity();
}

void kill()
{
  cli(); // Stop interrupts
  disable_heater();

  disable_x();
  disable_y();
  disable_z();
  disable_e0();
  disable_e1();
  disable_e2();

#if defined(PS_ON_PIN) && PS_ON_PIN > -1
  pinMode(PS_ON_PIN,INPUT);
#endif
  SERIAL_ERROR_START;
  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
  LCD_ALERTMESSAGEPGM(MSG_KILLED);
  
  // FMC small patch to update the LCD before ending
  sei();   // enable interrupts
  for ( int i=5; i--; lcd_update())
  {
     delay(200);	
  }
  cli();   // disable interrupts
  suicide();
  while(1) { /* Intentionally left empty */ } // Wait for reset
}

void Stop()
{
  disable_heater();
  if(Stopped == false) {
    Stopped = true;
    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
    SERIAL_ERROR_START;
    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
    LCD_MESSAGEPGM(MSG_STOPPED);
  }
}

bool IsStopped() { return Stopped; };

#ifdef FAST_PWM_FAN
void setPwmFrequency(uint8_t pin, int val)
{
  val &= 0x07;
  switch(digitalPinToTimer(pin))
  {

    #if defined(TCCR0A)
    case TIMER0A:
    case TIMER0B:
//         TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));
//         TCCR0B |= val;
         break;
    #endif

    #if defined(TCCR1A)
    case TIMER1A:
    case TIMER1B:
//         TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
//         TCCR1B |= val;
         break;
    #endif

    #if defined(TCCR2)
    case TIMER2:
    case TIMER2:
         TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
         TCCR2 |= val;
         break;
    #endif

    #if defined(TCCR2A)
    case TIMER2A:
    case TIMER2B:
         TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));
         TCCR2B |= val;
         break;
    #endif

    #if defined(TCCR3A)
    case TIMER3A:
    case TIMER3B:
    case TIMER3C:
         TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));
         TCCR3B |= val;
         break;
    #endif

    #if defined(TCCR4A)
    case TIMER4A:
    case TIMER4B:
    case TIMER4C:
         TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));
         TCCR4B |= val;
         break;
   #endif

    #if defined(TCCR5A)
    case TIMER5A:
    case TIMER5B:
    case TIMER5C:
         TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));
         TCCR5B |= val;
         break;
   #endif

  }
}
#endif //FAST_PWM_FAN

bool setTargetedHotend(int code){
  tmp_extruder = active_extruder;
  if(code_seen('T')) {
    tmp_extruder = code_value();
    if(tmp_extruder >= EXTRUDERS) {
      SERIAL_ECHO_START;
      switch(code){
        case 104:
          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);
          break;
        case 105:
          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);
          break;
        case 109:
          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);
          break;
        case 218:
          SERIAL_ECHO(MSG_M218_INVALID_EXTRUDER);
          break;
        case 221:
          SERIAL_ECHO(MSG_M221_INVALID_EXTRUDER);
          break;
      }
      SERIAL_ECHOLN(tmp_extruder);
      return true;
    }
  }
  return false;
}


float calculate_volumetric_multiplier(float diameter) {
	float area = .0;
	float radius = .0;

	radius = diameter * .5;
	if (! volumetric_enabled || radius == 0) {
		area = 1;
	}
	else {
		area = M_PI * pow(radius, 2);
	}

	return 1.0 / area;
}

void calculate_volumetric_multipliers() {
	volumetric_multiplier[0] = calculate_volumetric_multiplier(filament_size[0]);
#if EXTRUDERS > 1
	volumetric_multiplier[1] = calculate_volumetric_multiplier(filament_size[1]);
#if EXTRUDERS > 2
	volumetric_multiplier[2] = calculate_volumetric_multiplier(filament_size[2]);
#endif
#endif
}
#endif
++++++
#if defined (marlin4Due)
// Z_PROBE_SLED
#endif
++++++
#if defined (marlin4Due) && ENABLED(FWRETRACT)
void retract(bool retracting, bool swapping=false) {

    if (retracting == retracted[active_extruder]) return;

    float oldFeedrate = feedrate;

    set_destination_to_current();

    if (retracting) {

      feedrate = retract_feedrate * 60;
      current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
      plan_set_e_position(current_position[E_AXIS]);
      prepare_move();

      if (retract_zlift > 0.01) {
        current_position[Z_AXIS] -= retract_zlift;
        #if ENABLED(DELTA)
          sync_plan_position_delta();
        #else
          sync_plan_position();
        #endif
        prepare_move();
      }
    }
    else {

      if (retract_zlift > 0.01) {
        current_position[Z_AXIS] += retract_zlift;
        #if ENABLED(DELTA)
          sync_plan_position_delta();
        #else
          sync_plan_position();
        #endif
        //prepare_move();
      }

      feedrate = retract_recover_feedrate * 60;
      float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
      current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
      plan_set_e_position(current_position[E_AXIS]);
      prepare_move();
    }

    feedrate = oldFeedrate;
    retracted[active_extruder] = retracting;

  }
#endif
++++++
#if defined (marlin4Due)
// FWRETRACT
#endif
++++++
#if defined (marlin4Due) && ENABLED(FWRETRACT)
/**
   * G10 - Retract filament according to settings of M207
   * G11 - Recover filament according to settings of M208
   */
#endif
++++++
#if defined (marlin4Due)
//FWRETRACT
#endif
++++++
#if defined (marlin4Due) && ENABLED(MESH_BED_LEVELING)
enum MeshLevelingState { MeshReport, MeshStart, MeshNext, MeshSet };
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
void out_of_range_error(const char *p_edge) {
    SERIAL_PROTOCOLPGM("?Probe ");
    serialprintPGM(p_edge);
    SERIAL_PROTOCOLLNPGM(" position out of range.");
  }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && DISABLED(Z_PROBE_SLED) )
inline void gcode_G30() {
      deploy_z_probe(); // Engage Z Servo endstop if available
      st_synchronize();
      // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly
      setup_for_endstop_move();

      feedrate = homing_feedrate[Z_AXIS];

      run_z_probe();
      SERIAL_PROTOCOLPGM("Bed X: ");
      SERIAL_PROTOCOL(current_position[X_AXIS] + 0.0001);
      SERIAL_PROTOCOLPGM(" Y: ");
      SERIAL_PROTOCOL(current_position[Y_AXIS] + 0.0001);
      SERIAL_PROTOCOLPGM(" Z: ");
      SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);
      SERIAL_EOL;

      clean_up_after_endstop_move();
      stow_z_probe(); // Retract Z Servo endstop if available
    }
#endif
++++++
#if defined (marlin4Due) && ENABLED(ENABLE_AUTO_BED_LEVELING)
//!Z_PROBE_SLED
#endif
++++++
#if defined (marlin4Due)
//ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTIPANEL)
/**
   * M0: // M0 - Unconditional stop - Wait for user button press on LCD
   * M1: // M1 - Conditional stop - Wait for user button press on LCD
   */
#endif
++++++
#if defined (marlin4Due)
// ULTIPANEL
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)
/**
   * M20: List SD card to serial output
   */
#endif
++++++
#if defined (marlin4Due)
/**
 * M31: Get the time since the start of SD Print (or last M109)
 */
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)
/**
   * M32: Select file and start SD Print
   */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(SDSUPPORT) && ENABLED(LONG_FILENAME_HOST_SUPPORT) )
/**
     * M33: Get the long full path of a file or folder
     *
     * Parameters:
     *   <dospath> Case-insensitive DOS-style path to a file or folder
     *
     * Example:
     *   M33 miscel~1/armchair/armcha~1.gco
     *
     * Output:
     *   /Miscellaneous/Armchair/Armchair.gcode
     */
#endif
++++++
#if defined (marlin4Due) && ENABLED(SDSUPPORT)
/**
   * M928: Start SD Write
   */
#endif
++++++
#if defined (marlin4Due)
// SDSUPPORT
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(Z_PROBE_REPEATABILITY_TEST))
// This is redundant since the SanityCheck.h already checks for a valid Z_PROBE_PIN, but here for clarity.
#endif
++++++
#if defined (marlin4Due) && ((ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(Z_PROBE_REPEATABILITY_TEST) && )ENABLED(Z_PROBE_ENDSTOP) && !HAS_Z_PROBE )
#error You must define Z_PROBE_PIN to enable Z-Probe repeatability calculation.
#endif
++++++
#if defined (marlin4Due) && ((ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(Z_PROBE_REPEATABILITY_TEST) && )!HAS_Z_MIN )
#error You must define Z_MIN_PIN to enable Z-Probe repeatability calculation.
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(Z_PROBE_REPEATABILITY_TEST))
/**
   * M48: Z-Probe repeatability measurement function.
   *
   * Usage:
   *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
   *     P = Number of sampled points (4-50, default 10)
   *     X = Sample X position
   *     Y = Sample Y position
   *     V = Verbose level (0-4, default=1)
   *     E = Engage probe for each reading
   *     L = Number of legs of movement before probe
   *  
   * This function assumes the bed has been homed.  Specifically, that a G28 command
   * as been issued prior to invoking the M48 Z-Probe repeatability measurement function.
   * Any information generated by a prior G29 Bed leveling command will be lost and need to be
   * regenerated.
   */
#endif
++++++
#if defined (marlin4Due)
// ENABLE_AUTO_BED_LEVELING && Z_PROBE_REPEATABILITY_TEST
#endif
++++++
#if defined (marlin4Due) && HAS_FAN
/**
   * M106: Set Fan Speed
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_FAN
#endif
++++++
#if defined (marlin4Due) && HAS_TEMP_BED
/**
   * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
   *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_TEMP_BED
#endif
++++++
#if defined (marlin4Due) && (ENABLED(BARICUDA) && HAS_HEATER_1 )
/**
     * M126: Heater 1 valve open
     */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(BARICUDA) && HAS_HEATER_2 )
/**
     * M128: Heater 2 valve open
     */
#endif
++++++
#if defined (marlin4Due)
//BARICUDA
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTIPANEL)
/**
   * M145: Set the heatup state for a material in the LCD menu
   *   S<material> (0=PLA, 1=ABS)
   *   H<hotend temp>
   *   B<bed temp>
   *   F<fan speed>
   */
#endif
++++++
#if defined (marlin4Due) && HAS_POWER_SWITCH
/**
   * M80: Turn on Power Supply
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_POWER_SWITCH
#endif
++++++
#if defined (marlin4Due) && ENABLED(BLINKM)
/**
   * M150: Set Status LED Color - Use R-U-B for R-G-B
   */
#endif
++++++
#if defined (marlin4Due)
// BLINKM
#endif
++++++
#if defined (marlin4Due) && 0
// Not used for Sprinter/grbl gen6
#endif
++++++
#if defined (marlin4Due)
/**
 * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
 */
#endif
++++++
#if defined (marlin4Due) && ENABLED(DELTA)
/**
   * M665: Set delta configurations
   *
   *    L = diagonal rod
   *    R = delta radius
   *    S = segments per second
   */
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_DUAL_ENDSTOPS)
// !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
#endif
++++++
#if defined (marlin4Due)
// !DELTA && Z_DUAL_ENDSTOPS
#endif
++++++
#if defined (marlin4Due) && ENABLED(FWRETRACT)
/**
   * M207: Set firmware retraction values
   *
   *   S[+mm]    retract_length
   *   W[+mm]    retract_length_swap (multi-extruder)
   *   F[mm/min] retract_feedrate
   *   Z[mm]     retract_zlift
   */
#endif
++++++
#if defined (marlin4Due)
// FWRETRACT
#endif
++++++
#if defined (marlin4Due) && EXTRUDERS > 1
/**
   * M218 - set hotend offset (in mm), T<extruder_number> X<offset_on_X> Y<offset_on_Y>
   */
#endif
++++++
#if defined (marlin4Due)
// EXTRUDERS > 1
#endif
++++++
#if defined (marlin4Due) && HAS_SERVOS
/**
   * M280: Get or set servo position. P<index> S<angle>
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_SERVOS
#endif
++++++
#if defined (marlin4Due) && HAS_BUZZER
/**
   * M300: Play beep sound S<frequency Hz> P<duration ms>
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_BUZZER
#endif
++++++
#if defined (marlin4Due) && ENABLED(PIDTEMP)
/**
   * M301: Set PID parameters P I D (and optionally C)
   */
#endif
++++++
#if defined (marlin4Due)
// PIDTEMP
#endif
++++++
#if defined (marlin4Due) && ENABLED(PIDTEMPBED)
inline void gcode_M304() {
    if (code_seen('P')) bedKp = code_value();
    if (code_seen('I')) bedKi = scalePID_i(code_value());
    if (code_seen('D')) bedKd = scalePID_d(code_value());

    updatePID();
    SERIAL_PROTOCOL(MSG_OK);
    SERIAL_PROTOCOL(" p:");
    SERIAL_PROTOCOL(bedKp);
    SERIAL_PROTOCOL(" i:");
    SERIAL_PROTOCOL(unscalePID_i(bedKi));
    SERIAL_PROTOCOL(" d:");
    SERIAL_PROTOCOL(unscalePID_d(bedKd));
    SERIAL_EOL;
  }
#endif
++++++
#if defined (marlin4Due)
// PIDTEMPBED
#endif
++++++
#if defined (marlin4Due) && (defined(CHDK) || HAS_PHOTOGRAPH)
/**
   * M240: Trigger a camera by emulating a Canon RC-1
   *       See http://www.doc-diy.net/photo/rc-1_hacked/
   */
#endif
++++++
#if defined (marlin4Due)
// CHDK || PHOTOGRAPH_PIN
#endif
++++++
#if defined (marlin4Due) && ENABLED(HAS_LCD_CONTRAST)
/**
   * M250: Read and optionally set the LCD contrast
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_LCD_CONTRAST
#endif
++++++
#if defined (marlin4Due) && ENABLED(PREVENT_DANGEROUS_EXTRUDE)
void set_extrude_min_temp(float temp) { extrude_min_temp = temp; }
#endif
++++++
#if defined (marlin4Due)
// PREVENT_DANGEROUS_EXTRUDE
#endif
++++++
#if defined (marlin4Due) && ENABLED(SCARA)
bool SCARA_move_to_cal(uint8_t delta_x, uint8_t delta_y) {
    //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
    //SERIAL_ECHOLN(" Soft endstops disabled ");
    if (IsRunning()) {
      //gcode_get_destination(); // For X Y Z E F
      delta[X_AXIS] = delta_x;
      delta[Y_AXIS] = delta_y;
      calculate_SCARA_forward_Transform(delta);
      destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];
      destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];
      prepare_move();
      //ok_to_send();
      return true;
    }
    return false;
  }
#endif
++++++
#if defined (marlin4Due)
// SCARA
#endif
++++++
#if defined (marlin4Due) && ENABLED(EXT_SOLENOID)
void enable_solenoid(uint8_t num) {
    switch(num) {
      case 0:
        OUT_WRITE(SOL0_PIN, HIGH);
        break;
        #if HAS_SOLENOID_1
          case 1:
            OUT_WRITE(SOL1_PIN, HIGH);
            break;
        #endif
        #if HAS_SOLENOID_2
          case 2:
            OUT_WRITE(SOL2_PIN, HIGH);
            break;
        #endif
        #if HAS_SOLENOID_3
          case 3:
            OUT_WRITE(SOL3_PIN, HIGH);
            break;
        #endif
      default:
        SERIAL_ECHO_START;
        SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
        break;
    }
  }
#endif
++++++
#if defined (marlin4Due)
// EXT_SOLENOID
#endif
++++++
#if defined (marlin4Due) && ((ENABLED(ENABLE_AUTO_BED_LEVELING) && DISABLED(Z_PROBE_SLED) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY)) && )HAS_SERVO_ENDSTOPS )
void raise_z_for_servo() {
      float zpos = current_position[Z_AXIS], z_dest = Z_RAISE_BEFORE_HOMING;
      z_dest += axis_known_position[Z_AXIS] ? zprobe_zoffset : zpos;
      if (zpos < z_dest) do_blocking_move_to_z(z_dest); // also updates current_position
    }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && DISABLED(Z_PROBE_SLED) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY)))
/**
   * M401: Engage Z Servo endstop if available
   */
#endif
++++++
#if defined (marlin4Due)
// ENABLE_AUTO_BED_LEVELING && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
#endif
++++++
#if defined (marlin4Due) && ENABLED(FILAMENT_SENSOR)
/**
   * M404: Display or set the nominal filament width (3mm, 1.75mm ) W<3.0>
   */
#endif
++++++
#if defined (marlin4Due)
// FILAMENT_SENSOR
#endif
++++++
#if defined (marlin4Due) && ENABLED(MESH_BED_LEVELING)
/**
   * M420: Enable/Disable Mesh Bed Leveling
   */
#endif
++++++
#if defined (marlin4Due)
/**
 * M428: Set home_offset based on the distance between the
 *       current_position and the nearest "reference point."
 *       If an axis is past center its endstop position
 *       is the reference-point. Otherwise it uses 0. This allows
 *       the Z offset to be set near the bed when using a max endstop.
 *
 *       M428 can't be used more than 2cm away from 0 or an endstop.
 *
 *       Use M206 to set these values directly.
 */
#endif
++++++
#if defined (marlin4Due) && ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
/**
   * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
   */
#endif
++++++
#if defined (marlin4Due)
// ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
#endif
++++++
#if defined (marlin4Due) && defined (CUSTOM_M_CODE_SET_Z_PROBE_OFFSET)
inline void gcode_SET_Z_PROBE_OFFSET() {
    float value;
    if (code_seen('Z')) {
      value = code_value();
      if (Z_PROBE_OFFSET_RANGE_MIN <= value && value <= Z_PROBE_OFFSET_RANGE_MAX) {
        zprobe_zoffset = value;
        SERIAL_ECHO_START;
        SERIAL_ECHOLNPGM(MSG_ZPROBE_ZOFFSET " " MSG_OK);
        SERIAL_EOL;
      }
      else {
        SERIAL_ECHO_START;
        SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET);
        SERIAL_ECHOPGM(MSG_Z_MIN);
        SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MIN);
        SERIAL_ECHOPGM(MSG_Z_MAX);
        SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MAX);
        SERIAL_EOL;
      }
    }
    else {
      SERIAL_ECHO_START;
      SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET " : ");
      SERIAL_ECHO(zprobe_zoffset);
      SERIAL_EOL;
    }
  }
#endif
++++++
#if defined (marlin4Due)
// CUSTOM_M_CODE_SET_Z_PROBE_OFFSET
#endif
++++++
#if defined (marlin4Due) && ENABLED(FILAMENTCHANGEENABLE)
/**
   * M600: Pause for filament change
   *
   *  E[distance] - Retract the filament this far (negative value)
   *  Z[distance] - Move the Z axis by this distance
   *  X[position] - Move to this X position, with Y
   *  Y[position] - Move to this Y position, with X
   *  L[distance] - Retract distance for removal (manual reload)
   *
   *  Default values are used for omitted arguments.
   *
   */
#endif
++++++
#if defined (marlin4Due)
// FILAMENTCHANGEENABLE
#endif
++++++
#if defined (marlin4Due) && ENABLED(DUAL_X_CARRIAGE)
/**
   * M605: Set dual x-carriage movement mode
   *
   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
   *                         millimeters x-offset and an optional differential hotend temperature of
   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
   *
   *    Note: the X axis should be homed after changing dual x-carriage mode.
   */
#endif
++++++
#if defined (marlin4Due)
// DUAL_X_CARRIAGE
#endif
++++++
#if defined (marlin4Due) && HAS_DIGIPOTSS
/**
   * M908: Control digital trimpot directly (M908 P<pin> S<current>)
   */
#endif
++++++
#if defined (marlin4Due)
// HAS_DIGIPOTSS
#endif
++++++
#if defined (marlin4Due) && HAS_MICROSTEPS
// M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
#endif
++++++
#if defined (marlin4Due)
// HAS_MICROSTEPS
#endif
++++++
#if defined (marlin4Due) && ENABLED(DELTA)
void recalc_delta_settings(float radius, float diagonal_rod) {
    delta_tower1_x = -SIN_60 * radius;  // front left tower
    delta_tower1_y = -COS_60 * radius;
    delta_tower2_x =  SIN_60 * radius;  // front right tower
    delta_tower2_y = -COS_60 * radius;
    delta_tower3_x = 0.0;               // back middle tower
    delta_tower3_y = radius;
    delta_diagonal_rod_2 = sq(diagonal_rod);
  }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENABLE_AUTO_BED_LEVELING) && ENABLED(DELTA) )
// Adjust print surface height by linear interpolation over the bed_level array.
#endif
++++++
#if defined (marlin4Due) && ENABLED(DELTA)
// ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (marlin4Due)
// DELTA
#endif
++++++
#if defined (marlin4Due) && ENABLED(MESH_BED_LEVELING)
// This function is used to split lines on mesh borders so each segment is only part of one mesh area
#endif
++++++
#if defined (marlin4Due)
// MESH_BED_LEVELING
#endif
++++++
#if defined (marlin4Due) && ENABLED(PREVENT_DANGEROUS_EXTRUDE)
inline void prevent_dangerous_extrude(float &curr_e, float &dest_e) {
    if (marlin_debug_flags & DEBUG_DRYRUN) return;
    float de = dest_e - curr_e;
    if (de) {
      if (degHotend(active_extruder) < extrude_min_temp) {
        curr_e = dest_e; // Behave as if the move really took place, but ignore E part
        SERIAL_ECHO_START;
        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
      }
      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
        if (labs(de) > EXTRUDE_MAXLENGTH) {
          curr_e = dest_e; // Behave as if the move really took place, but ignore E part
          SERIAL_ECHO_START;
          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        }
      #endif
    }
  }
#endif
++++++
#if defined (marlin4Due)
// PREVENT_DANGEROUS_EXTRUDE
#endif
++++++
#if defined (marlin4Due) && (ENABLED(DELTA) || ENABLED(SCARA))
inline bool prepare_move_delta(float target[NUM_AXIS]) {
    float difference[NUM_AXIS];
    for (int8_t i=0; i < NUM_AXIS; i++) difference[i] = target[i] - current_position[i];

    float cartesian_mm = sqrt(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
    if (cartesian_mm < 0.000001) cartesian_mm = abs(difference[E_AXIS]);
    if (cartesian_mm < 0.000001) return false;
    float seconds = 6000 * cartesian_mm / feedrate / feedrate_multiplier;
    int steps = max(1, int(delta_segments_per_second * seconds));

    // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);
    // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);
    // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);

    for (int s = 1; s <= steps; s++) {

      float fraction = float(s) / float(steps);

      for (int8_t i = 0; i < NUM_AXIS; i++)
        target[i] = current_position[i] + difference[i] * fraction;

      calculate_delta(target);

      #if ENABLED(ENABLE_AUTO_BED_LEVELING)
        adjust_delta(target);
      #endif

      //SERIAL_ECHOPGM("target[X_AXIS]="); SERIAL_ECHOLN(target[X_AXIS]);
      //SERIAL_ECHOPGM("target[Y_AXIS]="); SERIAL_ECHOLN(target[Y_AXIS]);
      //SERIAL_ECHOPGM("target[Z_AXIS]="); SERIAL_ECHOLN(target[Z_AXIS]);
      //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);
      //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
      //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);

      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feedrate/60*feedrate_multiplier/100.0, active_extruder);
    }
    return true;
  }
#endif
++++++
#if defined (marlin4Due)
// DELTA || SCARA
#endif
++++++
#if defined (marlin4Due) && ENABLED(SCARA)
inline bool prepare_move_scara(float target[NUM_AXIS]) { return prepare_move_delta(target); }
#endif
++++++
#if defined (marlin4Due) && ENABLED(DUAL_X_CARRIAGE)
inline bool prepare_move_dual_x_carriage() {
    if (active_extruder_parked) {
      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
        // move duplicate extruder into correct duplication position.
        plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
        plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,
          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[X_AXIS], 1);
        sync_plan_position();
        st_synchronize();
        extruder_duplication_enabled = true;
        active_extruder_parked = false;
      }
      else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) { // handle unparking of head
        if (current_position[E_AXIS] == destination[E_AXIS]) {
          // This is a travel move (with no extrusion)
          // Skip it, but keep track of the current position
          // (so it can be used as the start of the next non-travel move)
          if (delayed_move_time != 0xFFFFFFFFUL) {
            set_current_to_destination();
            NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
            delayed_move_time = millis();
            return false;
          }
        }
        delayed_move_time = 0;
        // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
        plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], min(max_feedrate[X_AXIS], max_feedrate[Y_AXIS]), active_extruder);
        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
        active_extruder_parked = false;
      }
    }
    return true;
  }
#endif
++++++
#if defined (marlin4Due)
// DUAL_X_CARRIAGE
#endif
++++++
#if defined (marlin4Due) && (DISABLED(DELTA) && DISABLED(SCARA))
inline bool prepare_move_cartesian() {
    // Do not use feedrate_multiplier for E or Z only moves
    if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) {
      line_to_destination();
    }
    else {
      #if ENABLED(MESH_BED_LEVELING)
        mesh_plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], (feedrate/60)*(feedrate_multiplier/100.0), active_extruder);
        return false;
      #else
        line_to_destination(feedrate * feedrate_multiplier / 100.0);
      #endif
    }
    return true;
  }
#endif
++++++
#if defined (marlin4Due)
// !DELTA && !SCARA
#endif
++++++
#if defined (marlin4Due) && HAS_CONTROLLERFAN
void controllerFan() {
    static millis_t lastMotor = 0;      // Last time a motor was turned on
    static millis_t lastMotorCheck = 0; // Last time the state was checked
    millis_t ms = millis();
    if (ms >= lastMotorCheck + 2500) { // Not a time critical function, so we only check every 2500ms
      lastMotorCheck = ms;
      if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || soft_pwm_bed > 0
        || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
        #if EXTRUDERS > 1
          || E1_ENABLE_READ == E_ENABLE_ON
          #if HAS_X2_ENABLE
            || X2_ENABLE_READ == X_ENABLE_ON
          #endif
          #if EXTRUDERS > 2
            || E2_ENABLE_READ == E_ENABLE_ON
            #if EXTRUDERS > 3
              || E3_ENABLE_READ == E_ENABLE_ON
            #endif
          #endif
        #endif
      ) {
        lastMotor = ms; //... set time to NOW so the fan will turn on
      }
      
  // Dawson - try to get the motor/controller card fan control working with RAMPS-FD v1
  // #ifdef INVERTED_HEATER_PINS
  #ifdef INVERTED_MOSFET_CHANNELS
      uint8_t speed = (lastMotor == 0 || ms >= lastMotor + (CONTROLLERFAN_SECS * 1000UL)) ? 255 : (255 - CONTROLLERFAN_SPEED);
  #else
      uint8_t speed = (lastMotor == 0 || ms >= lastMotor + (CONTROLLERFAN_SECS * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
  #endif
 
      // allows digital or PWM fan output to be used (see M42 handling)
      digitalWrite(CONTROLLERFAN_PIN, speed);
      analogWrite(CONTROLLERFAN_PIN, speed);
    }
  }
#endif
++++++
#if defined (marlin4Due)
// HAS_CONTROLLERFAN
#endif
++++++
#if defined (marlin4Due) && ENABLED(SCARA)
void calculate_SCARA_forward_Transform(float f_scara[3]) {
    // Perform forward kinematics, and place results in delta[3]
    // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014

    float x_sin, x_cos, y_sin, y_cos;

    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);
    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);

    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;

    //SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);
    //SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);
    //SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);
    //SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);

    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta
    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi

    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);
    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
  }
#endif
++++++
#if defined (marlin4Due)
// SCARA
#endif
++++++
#if defined (marlin4Due) && ENABLED(TEMP_STAT_LEDS)
static bool red_led = false;
#endif
++++++
#if defined (marlin4Due)
void enable_all_steppers() {
  enable_x();
  enable_y();
  enable_z();
  enable_e0();
  enable_e1();
  enable_e2();
  enable_e3();
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(FILAMENT_RUNOUT_SENSOR)
void filrunout() {
    if (!filrunoutEnqueued) {
      filrunoutEnqueued = true;
      enqueuecommands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
      st_synchronize();
    }
  }
#endif
++++++
#if defined (marlin4Due)
// FILAMENT_RUNOUT_SENSOR
#endif
++++++
#if defined (marlin4Due) && ENABLED(FAST_PWM_FAN)
void setPwmFrequency(uint8_t pin, int val) {
    val &= 0x07;
    switch (digitalPinToTimer(pin)) {

      #if defined(TCCR0A)
        case TIMER0A:
        case TIMER0B:
             // TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));
             // TCCR0B |= val;
             break;
      #endif

      #if defined(TCCR1A)
        case TIMER1A:
        case TIMER1B:
             // TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
             // TCCR1B |= val;
             break;
      #endif

      #if defined(TCCR2)
        case TIMER2:
        case TIMER2:
             TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
             TCCR2 |= val;
             break;
      #endif

      #if defined(TCCR2A)
        case TIMER2A:
        case TIMER2B:
             TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));
             TCCR2B |= val;
             break;
      #endif

      #if defined(TCCR3A)
        case TIMER3A:
        case TIMER3B:
        case TIMER3C:
             TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));
             TCCR3B |= val;
             break;
      #endif

      #if defined(TCCR4A)
        case TIMER4A:
        case TIMER4B:
        case TIMER4C:
             TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));
             TCCR4B |= val;
             break;
      #endif

      #if defined(TCCR5A)
        case TIMER5A:
        case TIMER5B:
        case TIMER5C:
             TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));
             TCCR5B |= val;
             break;
      #endif

    }
  }
#endif
++++++
#if defined (marlin4Due)
// FAST_PWM_FAN
#endif
++++++


**--**-**--merge: MarlinSerial.cpp



**--**-**--merge: motion_control.cpp



**--**-**--merge: planner.cpp

#if defined (upstream)
/*
  planner.c - buffers movement commands and manages the acceleration profile plan
 Part of Grbl
 
 Copyright (c) 2009-2011 Simen Svale Skogsrud
 
 Grbl is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 Grbl is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
 */

/* The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis. */

/*  
 Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
 
 s == speed, a == acceleration, t == time, d == distance
 
 Basic definitions:
 
 Speed[s_, a_, t_] := s + (a*t) 
 Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
 
 Distance to reach a specific speed with a constant acceleration:
 
 Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
 d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
 
 Speed after a given distance of travel with constant acceleration:
 
 Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
 m -> Sqrt[2 a d + s^2]    
 
 DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
 
 When to start braking (di) to reach a specified destionation speed (s2) after accelerating
 from initial speed s1 without ever stopping at a plateau:
 
 Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
 di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
 
 IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
 */

#include "Marlin.h"
#include "planner.h"
#include "stepper.h"
#include "temperature.h"
#include "ultralcd.h"
#include "language.h"

//===========================================================================
//=============================public variables ============================
//===========================================================================

unsigned long minsegmenttime;
float max_feedrate[NUM_AXIS]; // set the max speeds
float axis_steps_per_unit[NUM_AXIS];
unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
float minimumfeedrate;
float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX
float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX
float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.
float max_z_jerk;
float max_e_jerk;
float mintravelfeedrate;
unsigned long axis_steps_per_sqr_second[NUM_AXIS];

#ifdef ENABLE_AUTO_BED_LEVELING
// this holds the required transform to compensate for bed level
matrix_3x3 plan_bed_level_matrix = {
	1.0, 0.0, 0.0,
	0.0, 1.0, 0.0,
	0.0, 0.0, 1.0,
};
#endif // #ifdef ENABLE_AUTO_BED_LEVELING

// The current position of the tool in absolute steps
long position[NUM_AXIS];   //rescaled from extern when axis_steps_per_unit are changed by gcode
static float previous_speed[NUM_AXIS]; // Speed of previous path line segment
static float previous_nominal_speed; // Nominal speed of previous path line segment

#ifdef AUTOTEMP
float autotemp_max=250;
float autotemp_min=210;
float autotemp_factor=0.1;
bool autotemp_enabled=false;
#endif

unsigned char g_uc_extruder_last_move[3] = {0,0,0};

//===========================================================================
//=================semi-private variables, used in inline  functions    =====
//===========================================================================
block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions
volatile unsigned char block_buffer_head;           // Index of the next block to be pushed
volatile unsigned char block_buffer_tail;           // Index of the block to process now

//===========================================================================
//=============================private variables ============================
//===========================================================================
#ifdef PREVENT_DANGEROUS_EXTRUDE
float extrude_min_temp=EXTRUDE_MINTEMP;
#endif
#ifdef XY_FREQUENCY_LIMIT
#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
// Used for the frequency limit
static unsigned char old_direction_bits = 0;               // Old direction bits. Used for speed calculations
static long x_segment_time[3]={MAX_FREQ_TIME + 1,0,0};     // Segment times (in us). Used for speed calculations
static long y_segment_time[3]={MAX_FREQ_TIME + 1,0,0};
#endif

#ifdef FILAMENT_SENSOR
 static char meas_sample; //temporary variable to hold filament measurement sample
#endif

// Returns the index of the next block in the ring buffer
// NOTE: Removed modulo (%) operator, which uses an expensive divide and multiplication.
static int8_t next_block_index(int8_t block_index) {
  block_index++;
  if (block_index == BLOCK_BUFFER_SIZE) { 
    block_index = 0; 
  }
  return(block_index);
}


// Returns the index of the previous block in the ring buffer
static int8_t prev_block_index(int8_t block_index) {
  if (block_index == 0) { 
    block_index = BLOCK_BUFFER_SIZE; 
  }
  block_index--;
  return(block_index);
}

//===========================================================================
//=============================functions         ============================
//===========================================================================

// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the 
// given acceleration:
FORCE_INLINE float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration)
{
  if (acceleration!=0) {
    return((target_rate*target_rate-initial_rate*initial_rate)/
      (2.0*acceleration));
  }
  else {
    return 0.0;  // acceleration was 0, set acceleration distance to 0
  }
}

// This function gives you the point at which you must start braking (at the rate of -acceleration) if 
// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after
// a total travel of distance. This can be used to compute the intersection point between acceleration and
// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)

FORCE_INLINE float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) 
{
  if (acceleration!=0) {
    return((2.0*acceleration*distance-initial_rate*initial_rate+final_rate*final_rate)/
      (4.0*acceleration) );
  }
  else {
    return 0.0;  // acceleration was 0, set intersection distance to 0
  }
}

// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.

void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exit_factor) {
  unsigned long initial_rate = ceil(block->nominal_rate*entry_factor); // (step/min)
  unsigned long final_rate = ceil(block->nominal_rate*exit_factor); // (step/min)

  // Limit minimal step rate (Otherwise the timer will overflow.)
  if(initial_rate <120) {
    initial_rate=120; 
  }
  if(final_rate < 120) {
    final_rate=120;  
  }

  long acceleration = block->acceleration_st;
  int32_t accelerate_steps =
    ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, acceleration));
  int32_t decelerate_steps =
    floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -acceleration));

  // Calculate the size of Plateau of Nominal Rate.
  int32_t plateau_steps = block->step_event_count-accelerate_steps-decelerate_steps;

  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
  // have to use intersection_distance() to calculate when to abort acceleration and start braking
  // in order to reach the final_rate exactly at the end of this block.
  if (plateau_steps < 0) {
    accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, acceleration, block->step_event_count));
    accelerate_steps = max(accelerate_steps,0); // Check limits due to numerical round-off
    accelerate_steps = min((uint32_t)accelerate_steps,block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
    plateau_steps = 0;
  }

#ifdef ADVANCE
  volatile long initial_advance = block->advance*entry_factor*entry_factor; 
  volatile long final_advance = block->advance*exit_factor*exit_factor;
#endif // ADVANCE

  // block->accelerate_until = accelerate_steps;
  // block->decelerate_after = accelerate_steps+plateau_steps;
  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
  if(block->busy == false) { // Don't update variables if block is busy.
    block->accelerate_until = accelerate_steps;
    block->decelerate_after = accelerate_steps+plateau_steps;
    block->initial_rate = initial_rate;
    block->final_rate = final_rate;
#ifdef ADVANCE
    block->initial_advance = initial_advance;
    block->final_advance = final_advance;
#endif //ADVANCE
  }
  CRITICAL_SECTION_END;
}                    

// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the 
// acceleration within the allotted distance.
FORCE_INLINE float max_allowable_speed(float acceleration, float target_velocity, float distance) {
  return  sqrt(target_velocity*target_velocity-2*acceleration*distance);
}

// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
// This method will calculate the junction jerk as the euclidean distance between the nominal 
// velocities of the respective blocks.
//inline float junction_jerk(block_t *before, block_t *after) {
//  return sqrt(
//    pow((before->speed_x-after->speed_x), 2)+pow((before->speed_y-after->speed_y), 2));
//}


// The kernel called by planner_recalculate() when scanning the plan from last to first entry.
void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {
  if(!current) { 
    return; 
  }

  if (next) {
    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
    // check for maximum allowable speed reductions to ensure maximum possible planned speed.
    if (current->entry_speed != current->max_entry_speed) {

      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
      // for max allowable speed if block is decelerating and nominal length is false.
      if ((!current->nominal_length_flag) && (current->max_entry_speed > next->entry_speed)) {
        current->entry_speed = min( current->max_entry_speed,
        max_allowable_speed(-current->acceleration,next->entry_speed,current->millimeters));
      } 
      else {
        current->entry_speed = current->max_entry_speed;
      }
      current->recalculate_flag = true;

    }
  } // Skip last block. Already initialized and set for recalculation.
}

// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
// implements the reverse pass.
void planner_reverse_pass() {
  uint8_t block_index = block_buffer_head;
  
  //Make a local copy of block_buffer_tail, because the interrupt can alter it
  CRITICAL_SECTION_START;
  unsigned char tail = block_buffer_tail;
  CRITICAL_SECTION_END
  
  if(((block_buffer_head-tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1)) > 3) {
    block_index = (block_buffer_head - 3) & (BLOCK_BUFFER_SIZE - 1);
    block_t *block[3] = { 
      NULL, NULL, NULL         };
    while(block_index != tail) { 
      block_index = prev_block_index(block_index); 
      block[2]= block[1];
      block[1]= block[0];
      block[0] = &block_buffer[block_index];
      planner_reverse_pass_kernel(block[0], block[1], block[2]);
    }
  }
}

// The kernel called by planner_recalculate() when scanning the plan from first to last entry.
void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {
  if(!previous) { 
    return; 
  }

  // If the previous block is an acceleration block, but it is not long enough to complete the
  // full speed change within the block, we need to adjust the entry speed accordingly. Entry
  // speeds have already been reset, maximized, and reverse planned by reverse planner.
  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
  if (!previous->nominal_length_flag) {
    if (previous->entry_speed < current->entry_speed) {
      double entry_speed = min( current->entry_speed,
      max_allowable_speed(-previous->acceleration,previous->entry_speed,previous->millimeters) );

      // Check for junction speed change
      if (current->entry_speed != entry_speed) {
        current->entry_speed = entry_speed;
        current->recalculate_flag = true;
      }
    }
  }
}

// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
// implements the forward pass.
void planner_forward_pass() {
  uint8_t block_index = block_buffer_tail;
  block_t *block[3] = { 
    NULL, NULL, NULL   };

  while(block_index != block_buffer_head) {
    block[0] = block[1];
    block[1] = block[2];
    block[2] = &block_buffer[block_index];
    planner_forward_pass_kernel(block[0],block[1],block[2]);
    block_index = next_block_index(block_index);
  }
  planner_forward_pass_kernel(block[1], block[2], NULL);
}

// Recalculates the trapezoid speed profiles for all blocks in the plan according to the 
// entry_factor for each junction. Must be called by planner_recalculate() after 
// updating the blocks.
void planner_recalculate_trapezoids() {
  int8_t block_index = block_buffer_tail;
  block_t *current;
  block_t *next = NULL;

  while(block_index != block_buffer_head) {
    current = next;
    next = &block_buffer[block_index];
    if (current) {
      // Recalculate if current block entry or exit junction speed has changed.
      if (current->recalculate_flag || next->recalculate_flag) {
        // NOTE: Entry and exit factors always > 0 by all previous logic operations.
        calculate_trapezoid_for_block(current, current->entry_speed/current->nominal_speed,
        next->entry_speed/current->nominal_speed);
        current->recalculate_flag = false; // Reset current only to ensure next trapezoid is computed
      }
    }
    block_index = next_block_index( block_index );
  }
  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
  if(next != NULL) {
    calculate_trapezoid_for_block(next, next->entry_speed/next->nominal_speed,
    MINIMUM_PLANNER_SPEED/next->nominal_speed);
    next->recalculate_flag = false;
  }
}

// Recalculates the motion plan according to the following algorithm:
//
//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) 
//      so that:
//     a. The junction jerk is within the set limit
//     b. No speed reduction within one block requires faster deceleration than the one, true constant 
//        acceleration.
//   2. Go over every block in chronological order and dial down junction speed reduction values if 
//     a. The speed increase within one block would require faster accelleration than the one, true 
//        constant acceleration.
//
// When these stages are complete all blocks have an entry_factor that will allow all speed changes to 
// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than 
// the set limit. Finally it will:
//
//   3. Recalculate trapezoids for all blocks.

void planner_recalculate() {   
  planner_reverse_pass();
  planner_forward_pass();
  planner_recalculate_trapezoids();
}

void plan_init() {
  block_buffer_head = 0;
  block_buffer_tail = 0;
  memset(position, 0, sizeof(position)); // clear position
  previous_speed[0] = 0.0;
  previous_speed[1] = 0.0;
  previous_speed[2] = 0.0;
  previous_speed[3] = 0.0;
  previous_nominal_speed = 0.0;
}




#ifdef AUTOTEMP
void getHighESpeed()
{
  static float oldt=0;
  if(!autotemp_enabled){
    return;
  }
  if(degTargetHotend0()+2<autotemp_min) {  //probably temperature set to zero.
    return; //do nothing
  }

  float high=0.0;
  uint8_t block_index = block_buffer_tail;

  while(block_index != block_buffer_head) {
    if((block_buffer[block_index].steps_x != 0) ||
      (block_buffer[block_index].steps_y != 0) ||
      (block_buffer[block_index].steps_z != 0)) {
      float se=(float(block_buffer[block_index].steps_e)/float(block_buffer[block_index].step_event_count))*block_buffer[block_index].nominal_speed;
      //se; mm/sec;
      if(se>high)
      {
        high=se;
      }
    }
    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
  }

  float g=autotemp_min+high*autotemp_factor;
  float t=g;
  if(t<autotemp_min)
    t=autotemp_min;
  if(t>autotemp_max)
    t=autotemp_max;
  if(oldt>t)
  {
    t=AUTOTEMP_OLDWEIGHT*oldt+(1-AUTOTEMP_OLDWEIGHT)*t;
  }
  oldt=t;
  setTargetHotend0(t);
}
#endif

void check_axes_activity()
{
  unsigned char x_active = 0;
  unsigned char y_active = 0;  
  unsigned char z_active = 0;
  unsigned char e_active = 0;
  unsigned char tail_fan_speed = fanSpeed;
  #ifdef BARICUDA
  unsigned char tail_valve_pressure = ValvePressure;
  unsigned char tail_e_to_p_pressure = EtoPPressure;
  #endif
  block_t *block;

  if(block_buffer_tail != block_buffer_head)
  {
    uint8_t block_index = block_buffer_tail;
    tail_fan_speed = block_buffer[block_index].fan_speed;
    #ifdef BARICUDA
    tail_valve_pressure = block_buffer[block_index].valve_pressure;
    tail_e_to_p_pressure = block_buffer[block_index].e_to_p_pressure;
    #endif
    while(block_index != block_buffer_head)
    {
      block = &block_buffer[block_index];
      if(block->steps_x != 0) x_active++;
      if(block->steps_y != 0) y_active++;
      if(block->steps_z != 0) z_active++;
      if(block->steps_e != 0) e_active++;
      block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);
    }
  }
  if((DISABLE_X) && (x_active == 0)) disable_x();
  if((DISABLE_Y) && (y_active == 0)) disable_y();
  if((DISABLE_Z) && (z_active == 0)) disable_z();
  if((DISABLE_E) && (e_active == 0))
  {
    disable_e0();
    disable_e1();
    disable_e2(); 
  }
#if defined(FAN_PIN) && FAN_PIN > -1
  #ifdef FAN_KICKSTART_TIME
    static unsigned long fan_kick_end;
    if (tail_fan_speed) {
      if (fan_kick_end == 0) {
        // Just starting up fan - run at full power.
        fan_kick_end = millis() + FAN_KICKSTART_TIME;
        tail_fan_speed = 255;
      } else if (fan_kick_end > millis())
        // Fan still spinning up.
        tail_fan_speed = 255;
    } else {
      fan_kick_end = 0;
    }
  #endif//FAN_KICKSTART_TIME
  #ifdef FAN_SOFT_PWM
  fanSpeedSoftPwm = tail_fan_speed;
  #else
  analogWrite(FAN_PIN,tail_fan_speed);
  #endif//!FAN_SOFT_PWM
#endif//FAN_PIN > -1
#ifdef AUTOTEMP
  getHighESpeed();
#endif

#ifdef BARICUDA
  #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1
      analogWrite(HEATER_1_PIN,tail_valve_pressure);
  #endif

  #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1
      analogWrite(HEATER_2_PIN,tail_e_to_p_pressure);
  #endif
#endif
}


float junction_deviation = 0.1;
// Add a new linear movement to the buffer. steps_x, _y and _z is the absolute position in 
// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration
// calculation the caller must also provide the physical length of the line in millimeters.
#ifdef ENABLE_AUTO_BED_LEVELING
void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t &extruder)
#else
void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t &extruder)
#endif  //ENABLE_AUTO_BED_LEVELING
{
  // Calculate the buffer head after we push this byte
  int next_buffer_head = next_block_index(block_buffer_head);

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Rest here until there is room in the buffer.
  while(block_buffer_tail == next_buffer_head)
  {
    manage_heater(); 
    manage_inactivity(); 
    lcd_update();
  }

#ifdef ENABLE_AUTO_BED_LEVELING
  apply_rotation_xyz(plan_bed_level_matrix, x, y, z);
#endif // ENABLE_AUTO_BED_LEVELING

  // The target position of the tool in absolute steps
  // Calculate target position in absolute steps
  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
  long target[4];
  target[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);
  target[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
  target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
  target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);

  #ifdef PREVENT_DANGEROUS_EXTRUDE
  if(target[E_AXIS]!=position[E_AXIS])
  {
    if(degHotend(active_extruder)<extrude_min_temp)
    {
      position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
      SERIAL_ECHO_START;
      SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
    }
    
    #ifdef PREVENT_LENGTHY_EXTRUDE
    if(labs(target[E_AXIS]-position[E_AXIS])>axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)
    {
      position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part
      SERIAL_ECHO_START;
      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
    }
    #endif
  }
  #endif

  // Prepare to set up new block
  block_t *block = &block_buffer[block_buffer_head];

  // Mark block as not busy (Not executed by the stepper interrupt)
  block->busy = false;

  // Number of steps for each axis
#ifndef COREXY
// default non-h-bot planning
block->steps_x = labs(target[X_AXIS]-position[X_AXIS]);
block->steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);
#else
// corexy planning
// these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
block->steps_x = labs((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]));
block->steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]));
#endif
  block->steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);
  block->steps_e = labs(target[E_AXIS]-position[E_AXIS]);
  block->steps_e *= volumetric_multiplier[active_extruder];
  block->steps_e *= extrudemultiply;
  block->steps_e /= 100;
  block->step_event_count = max(block->steps_x, max(block->steps_y, max(block->steps_z, block->steps_e)));

  // Bail if this is a zero-length block
  if (block->step_event_count <= dropsegments)
  { 
    return; 
  }

  block->fan_speed = fanSpeed;
  #ifdef BARICUDA
  block->valve_pressure = ValvePressure;
  block->e_to_p_pressure = EtoPPressure;
  #endif

  // Compute direction bits for this block 
  block->direction_bits = 0;
#ifndef COREXY
  if (target[X_AXIS] < position[X_AXIS])
  {
    block->direction_bits |= (1<<X_AXIS); 
  }
  if (target[Y_AXIS] < position[Y_AXIS])
  {
    block->direction_bits |= (1<<Y_AXIS); 
  }
#else
  if ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]) < 0)
  {
    block->direction_bits |= (1<<X_AXIS); 
  }
  if ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]) < 0)
  {
    block->direction_bits |= (1<<Y_AXIS); 
  }
#endif
  if (target[Z_AXIS] < position[Z_AXIS])
  {
    block->direction_bits |= (1<<Z_AXIS); 
  }
  if (target[E_AXIS] < position[E_AXIS])
  {
    block->direction_bits |= (1<<E_AXIS); 
  }

  block->active_extruder = extruder;

  //enable active axes
  #ifdef COREXY
  if((block->steps_x != 0) || (block->steps_y != 0))
  {
    enable_x();
    enable_y();
  }
  #else
  if(block->steps_x != 0) enable_x();
  if(block->steps_y != 0) enable_y();
  #endif
#ifndef Z_LATE_ENABLE
  if(block->steps_z != 0) enable_z();
#endif

  // Enable extruder(s)
  if(block->steps_e != 0)
  {
    if (DISABLE_INACTIVE_EXTRUDER) //enable only selected extruder
    {

      if(g_uc_extruder_last_move[0] > 0) g_uc_extruder_last_move[0]--;
      if(g_uc_extruder_last_move[1] > 0) g_uc_extruder_last_move[1]--;
      if(g_uc_extruder_last_move[2] > 0) g_uc_extruder_last_move[2]--;
      
      switch(extruder)
      {
        case 0: 
          enable_e0(); 
          g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE*2;
          
          if(g_uc_extruder_last_move[1] == 0) disable_e1(); 
          if(g_uc_extruder_last_move[2] == 0) disable_e2(); 
        break;
        case 1:
          enable_e1(); 
          g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE*2;
          
          if(g_uc_extruder_last_move[0] == 0) disable_e0(); 
          if(g_uc_extruder_last_move[2] == 0) disable_e2(); 
        break;
        case 2:
          enable_e2(); 
          g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE*2;
          
          if(g_uc_extruder_last_move[0] == 0) disable_e0(); 
          if(g_uc_extruder_last_move[1] == 0) disable_e1(); 
        break;        
      }
    }
    else //enable all
    {
      enable_e0();
      enable_e1();
      enable_e2(); 
    }
  }

  if (block->steps_e == 0)
  {
    if(feed_rate<mintravelfeedrate) feed_rate=mintravelfeedrate;
  }
  else
  {
    if(feed_rate<minimumfeedrate) feed_rate=minimumfeedrate;
  } 

/* This part of the code calculates the total length of the movement. 
For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head. 
Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
*/ 
  #ifndef COREXY
    float delta_mm[4];
    delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
    delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
  #else
    float delta_mm[6];
    delta_mm[X_HEAD] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];
    delta_mm[Y_HEAD] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];
    delta_mm[X_AXIS] = ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[X_AXIS];
    delta_mm[Y_AXIS] = ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[Y_AXIS];
  #endif
  delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];
  delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*volumetric_multiplier[active_extruder]*extrudemultiply/100.0;
  if ( block->steps_x <=dropsegments && block->steps_y <=dropsegments && block->steps_z <=dropsegments )
  {
    block->millimeters = fabs(delta_mm[E_AXIS]);
  } 
  else
  {
    #ifndef COREXY
      block->millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));
	#else
	  block->millimeters = sqrt(square(delta_mm[X_HEAD]) + square(delta_mm[Y_HEAD]) + square(delta_mm[Z_AXIS]));
    #endif	
  }
  float inverse_millimeters = 1.0/block->millimeters;  // Inverse millimeters to remove multiple divides 

    // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.
  float inverse_second = feed_rate * inverse_millimeters;

  int moves_queued=(block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);

  // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill
#ifdef OLD_SLOWDOWN
  if(moves_queued < (BLOCK_BUFFER_SIZE * 0.5) && moves_queued > 1)
    feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); 
#endif

#ifdef SLOWDOWN
  //  segment time im micro seconds
  unsigned long segment_time = lround(1000000.0/inverse_second);
  if ((moves_queued > 1) && (moves_queued < (BLOCK_BUFFER_SIZE * 0.5)))
  {
    if (segment_time < minsegmenttime)
    { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
      inverse_second=1000000.0/(segment_time+lround(2*(minsegmenttime-segment_time)/moves_queued));
      #ifdef XY_FREQUENCY_LIMIT
         segment_time = lround(1000000.0/inverse_second);
      #endif
    }
  }
#endif
  //  END OF SLOW DOWN SECTION    


  block->nominal_speed = block->millimeters * inverse_second; // (mm/sec) Always > 0
  block->nominal_rate = ceil(block->step_event_count * inverse_second); // (step/sec) Always > 0

#ifdef FILAMENT_SENSOR
  //FMM update ring buffer used for delay with filament measurements
  
  
    if((extruder==FILAMENT_SENSOR_EXTRUDER_NUM) && (delay_index2 > -1))  //only for extruder with filament sensor and if ring buffer is initialized
  	  {
    delay_dist = delay_dist + delta_mm[E_AXIS];  //increment counter with next move in e axis
  
    while (delay_dist >= (10*(MAX_MEASUREMENT_DELAY+1)))  //check if counter is over max buffer size in mm
      	  delay_dist = delay_dist - 10*(MAX_MEASUREMENT_DELAY+1);  //loop around the buffer
    while (delay_dist<0)
    	  delay_dist = delay_dist + 10*(MAX_MEASUREMENT_DELAY+1); //loop around the buffer
      
    delay_index1=delay_dist/10.0;  //calculate index
    
    //ensure the number is within range of the array after converting from floating point
    if(delay_index1<0)
    	delay_index1=0;
    else if (delay_index1>MAX_MEASUREMENT_DELAY)
    	delay_index1=MAX_MEASUREMENT_DELAY;
    	
    if(delay_index1 != delay_index2)  //moved index
  	  {
    	meas_sample=widthFil_to_size_ratio()-100;  //subtract off 100 to reduce magnitude - to store in a signed char
  	  }
    while( delay_index1 != delay_index2)
  	  {
  	  delay_index2 = delay_index2 + 1;
  	if(delay_index2>MAX_MEASUREMENT_DELAY)
  			  delay_index2=delay_index2-(MAX_MEASUREMENT_DELAY+1);  //loop around buffer when incrementing
  	  if(delay_index2<0)
  		delay_index2=0;
  	  else if (delay_index2>MAX_MEASUREMENT_DELAY)
  		delay_index2=MAX_MEASUREMENT_DELAY;  
  	  
  	  measurement_delay[delay_index2]=meas_sample;
  	  }
    	
    
  	  }
#endif


  // Calculate and limit speed in mm/sec for each axis
  float current_speed[4];
  float speed_factor = 1.0; //factor <=1 do decrease speed
  for(int i=0; i < 4; i++)
  {
    current_speed[i] = delta_mm[i] * inverse_second;
    if(fabs(current_speed[i]) > max_feedrate[i])
      speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));
  }

  // Max segement time in us.
#ifdef XY_FREQUENCY_LIMIT
#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
  // Check and limit the xy direction change frequency
  unsigned char direction_change = block->direction_bits ^ old_direction_bits;
  old_direction_bits = block->direction_bits;
  segment_time = lround((float)segment_time / speed_factor);
  
  if((direction_change & (1<<X_AXIS)) == 0)
  {
    x_segment_time[0] += segment_time;
  }
  else
  {
    x_segment_time[2] = x_segment_time[1];
    x_segment_time[1] = x_segment_time[0];
    x_segment_time[0] = segment_time;
  }
  if((direction_change & (1<<Y_AXIS)) == 0)
  {
    y_segment_time[0] += segment_time;
  }
  else
  {
    y_segment_time[2] = y_segment_time[1];
    y_segment_time[1] = y_segment_time[0];
    y_segment_time[0] = segment_time;
  }
  long max_x_segment_time = max(x_segment_time[0], max(x_segment_time[1], x_segment_time[2]));
  long max_y_segment_time = max(y_segment_time[0], max(y_segment_time[1], y_segment_time[2]));
  long min_xy_segment_time =min(max_x_segment_time, max_y_segment_time);
  if(min_xy_segment_time < MAX_FREQ_TIME)
    speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);
#endif

  // Correct the speed  
  if( speed_factor < 1.0)
  {
    for(unsigned char i=0; i < 4; i++)
    {
      current_speed[i] *= speed_factor;
    }
    block->nominal_speed *= speed_factor;
    block->nominal_rate *= speed_factor;
  }

  // Compute and limit the acceleration rate for the trapezoid generator.  
  float steps_per_mm = block->step_event_count/block->millimeters;
  if(block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0)
  {
    block->acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
  }
  else
  {
    block->acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
    // Limit acceleration per axis
    if(((float)block->acceleration_st * (float)block->steps_x / (float)block->step_event_count) > axis_steps_per_sqr_second[X_AXIS])
      block->acceleration_st = axis_steps_per_sqr_second[X_AXIS];
    if(((float)block->acceleration_st * (float)block->steps_y / (float)block->step_event_count) > axis_steps_per_sqr_second[Y_AXIS])
      block->acceleration_st = axis_steps_per_sqr_second[Y_AXIS];
    if(((float)block->acceleration_st * (float)block->steps_e / (float)block->step_event_count) > axis_steps_per_sqr_second[E_AXIS])
      block->acceleration_st = axis_steps_per_sqr_second[E_AXIS];
    if(((float)block->acceleration_st * (float)block->steps_z / (float)block->step_event_count ) > axis_steps_per_sqr_second[Z_AXIS])
      block->acceleration_st = axis_steps_per_sqr_second[Z_AXIS];
  }
  block->acceleration = block->acceleration_st / steps_per_mm;
  block->acceleration_rate = (long)((float)block->acceleration_st * (16777216.0 / (F_CPU / 8.0)));

#if 0  // Use old jerk for now
  // Compute path unit vector
  double unit_vec[3];

  unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;
  unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;
  unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;

  // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
  // Let a circle be tangent to both previous and current path line segments, where the junction
  // deviation is defined as the distance from the junction to the closest edge of the circle,
  // colinear with the circle center. The circular segment joining the two paths represents the
  // path of centripetal acceleration. Solve for max velocity based on max acceleration about the
  // radius of the circle, defined indirectly by junction deviation. This may be also viewed as
  // path width or max_jerk in the previous grbl version. This approach does not actually deviate
  // from path, but used as a robust way to compute cornering speeds, as it takes into account the
  // nonlinearities of both the junction angle and junction velocity.
  double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed

  // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
  if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed > 0.0)) {
    // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
    // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
    double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
      - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
      - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;

    // Skip and use default max junction speed for 0 degree acute junction.
    if (cos_theta < 0.95) {
      vmax_junction = min(previous_nominal_speed,block->nominal_speed);
      // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
      if (cos_theta > -0.95) {
        // Compute maximum junction velocity based on maximum acceleration and junction deviation
        double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.
        vmax_junction = min(vmax_junction,
        sqrt(block->acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );
      }
    }
  }
#endif
  // Start with a safe speed
  float vmax_junction = max_xy_jerk/2; 
  float vmax_junction_factor = 1.0; 
  if(fabs(current_speed[Z_AXIS]) > max_z_jerk/2) 
    vmax_junction = min(vmax_junction, max_z_jerk/2);
  if(fabs(current_speed[E_AXIS]) > max_e_jerk/2) 
    vmax_junction = min(vmax_junction, max_e_jerk/2);
  vmax_junction = min(vmax_junction, block->nominal_speed);
  float safe_speed = vmax_junction;

  if ((moves_queued > 1) && (previous_nominal_speed > 0.0001)) {
    float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));
    //    if((fabs(previous_speed[X_AXIS]) > 0.0001) || (fabs(previous_speed[Y_AXIS]) > 0.0001)) {
    vmax_junction = block->nominal_speed;
    //    }
    if (jerk > max_xy_jerk) {
      vmax_junction_factor = (max_xy_jerk/jerk);
    } 
    if(fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) > max_z_jerk) {
      vmax_junction_factor= min(vmax_junction_factor, (max_z_jerk/fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS])));
    } 
    if(fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]) > max_e_jerk) {
      vmax_junction_factor = min(vmax_junction_factor, (max_e_jerk/fabs(current_speed[E_AXIS] - previous_speed[E_AXIS])));
    } 
    vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed
  }
  block->max_entry_speed = vmax_junction;

  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
  double v_allowable = max_allowable_speed(-block->acceleration,MINIMUM_PLANNER_SPEED,block->millimeters);
  block->entry_speed = min(vmax_junction, v_allowable);

  // Initialize planner efficiency flags
  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
  // the current block and next block junction speeds are guaranteed to always be at their maximum
  // junction speeds in deceleration and acceleration, respectively. This is due to how the current
  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
  // the reverse and forward planners, the corresponding block junction speed will always be at the
  // the maximum junction speed and may always be ignored for any speed reduction checks.
  if (block->nominal_speed <= v_allowable) { 
    block->nominal_length_flag = true; 
  }
  else { 
    block->nominal_length_flag = false; 
  }
  block->recalculate_flag = true; // Always calculate trapezoid for new block

  // Update previous path unit_vector and nominal speed
  memcpy(previous_speed, current_speed, sizeof(previous_speed)); // previous_speed[] = current_speed[]
  previous_nominal_speed = block->nominal_speed;


#ifdef ADVANCE
  // Calculate advance rate
  if((block->steps_e == 0) || (block->steps_x == 0 && block->steps_y == 0 && block->steps_z == 0)) {
    block->advance_rate = 0;
    block->advance = 0;
  }
  else {
    long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_st);
    float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * 
      (current_speed[E_AXIS] * current_speed[E_AXIS] * EXTRUSION_AREA * EXTRUSION_AREA)*256;
    block->advance = advance;
    if(acc_dist == 0) {
      block->advance_rate = 0;
    } 
    else {
      block->advance_rate = advance / (float)acc_dist;
    }
  }
  /*
    SERIAL_ECHO_START;
   SERIAL_ECHOPGM("advance :");
   SERIAL_ECHO(block->advance/256.0);
   SERIAL_ECHOPGM("advance rate :");
   SERIAL_ECHOLN(block->advance_rate/256.0);
   */
#endif // ADVANCE

  calculate_trapezoid_for_block(block, block->entry_speed/block->nominal_speed,
  safe_speed/block->nominal_speed);

  // Move buffer head
  block_buffer_head = next_buffer_head;

  // Update position
  memcpy(position, target, sizeof(target)); // position[] = target[]

  planner_recalculate();

  st_wake_up();
}

#ifdef ENABLE_AUTO_BED_LEVELING
vector_3 plan_get_position() {
	vector_3 position = vector_3(st_get_position_mm(X_AXIS), st_get_position_mm(Y_AXIS), st_get_position_mm(Z_AXIS));

	//position.debug("in plan_get position");
	//plan_bed_level_matrix.debug("in plan_get bed_level");
	matrix_3x3 inverse = matrix_3x3::transpose(plan_bed_level_matrix);
	//inverse.debug("in plan_get inverse");
	position.apply_rotation(inverse);
	//position.debug("after rotation");

	return position;
}
#endif // ENABLE_AUTO_BED_LEVELING

#ifdef ENABLE_AUTO_BED_LEVELING
void plan_set_position(float x, float y, float z, const float &e)
{
  apply_rotation_xyz(plan_bed_level_matrix, x, y, z);
#else
void plan_set_position(const float &x, const float &y, const float &z, const float &e)
{
#endif // ENABLE_AUTO_BED_LEVELING

  position[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);
  position[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);
  position[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     
  position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  
  st_set_position(position[X_AXIS], position[Y_AXIS], position[Z_AXIS], position[E_AXIS]);
  previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.
  previous_speed[0] = 0.0;
  previous_speed[1] = 0.0;
  previous_speed[2] = 0.0;
  previous_speed[3] = 0.0;
}

void plan_set_e_position(const float &e)
{
  position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  
  st_set_e_position(position[E_AXIS]);
}

uint8_t movesplanned()
{
  return (block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);
}

#ifdef PREVENT_DANGEROUS_EXTRUDE
void set_extrude_min_temp(float temp)
{
  extrude_min_temp=temp;
}
#endif

// Calculate the steps/s^2 acceleration rates, based on the mm/s^s
void reset_acceleration_rates()
{
	for(int8_t i=0; i < NUM_AXIS; i++)
        {
        axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
        }
}




























































#endif
++++++
#if defined (marlin4Due)
/**
 * planner.cpp - Buffer movement commands and manage the acceleration profile plan
 * Part of Grbl
 * 
 * Copyright (c) 2009-2011 Simen Svale Skogsrud
 *
 * Grbl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Grbl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.
 *
 *
 * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
 *
 * s == speed, a == acceleration, t == time, d == distance
 *
 * Basic definitions:
 *   Speed[s_, a_, t_] := s + (a*t)
 *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
 *
 * Distance to reach a specific speed with a constant acceleration:
 *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
 *   d -> (m^2 - s^2)/(2 a) --> estimate_acceleration_distance()
 *
 * Speed after a given distance of travel with constant acceleration:
 *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
 *   m -> Sqrt[2 a d + s^2]
 *
 * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
 *
 * When to start braking (di) to reach a specified destination speed (s2) after accelerating
 * from initial speed s1 without ever stopping at a plateau:
 *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
 *   di -> (2 a d - s1^2 + s2^2)/(4 a) --> intersection_distance()
 *
 * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
 *
 */

#include "Marlin.h"
#include "planner.h"
#include "stepper.h"
#include "temperature.h"
#include "ultralcd.h"
#include "language.h"

#if ENABLED(MESH_BED_LEVELING)
  #include "mesh_bed_leveling.h"
#endif

//===========================================================================
//============================= public variables ============================
//===========================================================================

millis_t minsegmenttime;
float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute
float axis_steps_per_unit[NUM_AXIS];
unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software
float minimumfeedrate;
float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX
float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX
float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX
float max_xy_jerk;          // The largest speed change requiring no acceleration
float max_z_jerk;
float max_e_jerk;
float mintravelfeedrate;
unsigned long axis_steps_per_sqr_second[NUM_AXIS];

#if ENABLED(ENABLE_AUTO_BED_LEVELING)
  // Transform required to compensate for bed level
  matrix_3x3 plan_bed_level_matrix = {
    1.0, 0.0, 0.0,
    0.0, 1.0, 0.0,
    0.0, 0.0, 1.0
  };
#endif // ENABLE_AUTO_BED_LEVELING

#if ENABLED(AUTOTEMP)
  float autotemp_max = 250;
  float autotemp_min = 210;
  float autotemp_factor = 0.1;
  bool autotemp_enabled = false;
#endif

//===========================================================================
//============ semi-private variables, used in inline functions =============
//===========================================================================

block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions
volatile unsigned char block_buffer_head;           // Index of the next block to be pushed
volatile unsigned char block_buffer_tail;           // Index of the block to process now

//===========================================================================
//============================ private variables ============================
//===========================================================================

// The current position of the tool in absolute steps
long position[NUM_AXIS];               // Rescaled from extern when axis_steps_per_unit are changed by gcode
static float previous_speed[NUM_AXIS]; // Speed of previous path line segment
static float previous_nominal_speed;   // Nominal speed of previous path line segment

unsigned char g_uc_extruder_last_move[4] = {0,0,0,0};

#ifdef XY_FREQUENCY_LIMIT
  // Used for the frequency limit
  #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)
  // Old direction bits. Used for speed calculations
  static unsigned char old_direction_bits = 0;
  // Segment times (in s). Used for speed calculations
  static long axis_segment_time[2][3] = { {MAX_FREQ_TIME+1,0,0}, {MAX_FREQ_TIME+1,0,0} };
#endif

#if ENABLED(FILAMENT_SENSOR)
  static char meas_sample; //temporary variable to hold filament measurement sample
#endif

//===========================================================================
//================================ functions ================================
//===========================================================================

// Get the next / previous index of the next block in the ring buffer
// NOTE: Using & here (not %) because BLOCK_BUFFER_SIZE is always a power of 2
FORCE_INLINE int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }
FORCE_INLINE int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }

// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the 
// given acceleration:
FORCE_INLINE float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {
  if (acceleration == 0) return 0; // acceleration was 0, set acceleration distance to 0
  return (target_rate * target_rate - initial_rate * initial_rate) / (acceleration * 2);
}

// This function gives you the point at which you must start braking (at the rate of -acceleration) if 
// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after
// a total travel of distance. This can be used to compute the intersection point between acceleration and
// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)

FORCE_INLINE float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {
  if (acceleration == 0) return 0; // acceleration was 0, set intersection distance to 0
  return (acceleration * 2 * distance - initial_rate * initial_rate + final_rate * final_rate) / (acceleration * 4);
}

// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.

void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exit_factor) {
  unsigned long initial_rate = ceil(block->nominal_rate * entry_factor); // (step/min)
  unsigned long final_rate = ceil(block->nominal_rate * exit_factor); // (step/min)

  // Limit minimal step rate (Otherwise the timer will overflow.)
  NOLESS(initial_rate, 120);
  NOLESS(final_rate, 120);

  long acceleration = block->acceleration_st;
  int32_t accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block->nominal_rate, acceleration));
  int32_t decelerate_steps = floor(estimate_acceleration_distance(block->nominal_rate, final_rate, -acceleration));

  // Calculate the size of Plateau of Nominal Rate.
  int32_t plateau_steps = block->step_event_count - accelerate_steps - decelerate_steps;

  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will
  // have to use intersection_distance() to calculate when to abort acceleration and start braking
  // in order to reach the final_rate exactly at the end of this block.
  if (plateau_steps < 0) {
    accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, acceleration, block->step_event_count));
    accelerate_steps = max(accelerate_steps, 0); // Check limits due to numerical round-off
    accelerate_steps = min((uint32_t)accelerate_steps, block->step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)
    plateau_steps = 0;
  }

#if ENABLED(ADVANCE)
  volatile long initial_advance = block->advance * entry_factor * entry_factor; 
  volatile long final_advance = block->advance * exit_factor * exit_factor;
#endif // ADVANCE

  // block->accelerate_until = accelerate_steps;
  // block->decelerate_after = accelerate_steps+plateau_steps;
  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section
  if (!block->busy) { // Don't update variables if block is busy.
    block->accelerate_until = accelerate_steps;
    block->decelerate_after = accelerate_steps+plateau_steps;
    block->initial_rate = initial_rate;
    block->final_rate = final_rate;
    #if ENABLED(ADVANCE)
      block->initial_advance = initial_advance;
      block->final_advance = final_advance;
    #endif
  }
  CRITICAL_SECTION_END;
}                    

// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the 
// acceleration within the allotted distance.
FORCE_INLINE float max_allowable_speed(float acceleration, float target_velocity, float distance) {
  return sqrt(target_velocity * target_velocity - 2 * acceleration * distance);
}

// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.
// This method will calculate the junction jerk as the euclidean distance between the nominal 
// velocities of the respective blocks.
//inline float junction_jerk(block_t *before, block_t *after) {
//  return sqrt(
//    pow((before->speed_x-after->speed_x), 2)+pow((before->speed_y-after->speed_y), 2));
//}


// The kernel called by planner_recalculate() when scanning the plan from last to first entry.
void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {
  if (!current) return;

  if (next) {
    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.
    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and
    // check for maximum allowable speed reductions to ensure maximum possible planned speed.
    if (current->entry_speed != current->max_entry_speed) {

      // If nominal length true, max junction speed is guaranteed to be reached. Only compute
      // for max allowable speed if block is decelerating and nominal length is false.
      if (!current->nominal_length_flag && current->max_entry_speed > next->entry_speed) {
        current->entry_speed = min(current->max_entry_speed,
          max_allowable_speed(-current->acceleration, next->entry_speed, current->millimeters));
      } 
      else {
        current->entry_speed = current->max_entry_speed;
      }
      current->recalculate_flag = true;

    }
  } // Skip last block. Already initialized and set for recalculation.
}

// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This 
// implements the reverse pass.
void planner_reverse_pass() {
  uint8_t block_index = block_buffer_head;
  
  //Make a local copy of block_buffer_tail, because the interrupt can alter it
  CRITICAL_SECTION_START;
    unsigned char tail = block_buffer_tail;
  CRITICAL_SECTION_END
  
  if (BLOCK_MOD(block_buffer_head - tail + BLOCK_BUFFER_SIZE) > 3) { // moves queued
    block_index = BLOCK_MOD(block_buffer_head - 3);
    block_t *block[3] = { NULL, NULL, NULL };
    while (block_index != tail) {
      block_index = prev_block_index(block_index);
      block[2]= block[1];
      block[1]= block[0];
      block[0] = &block_buffer[block_index];
      planner_reverse_pass_kernel(block[0], block[1], block[2]);
    }
  }
}

// The kernel called by planner_recalculate() when scanning the plan from first to last entry.
void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {
  if (!previous) return;

  // If the previous block is an acceleration block, but it is not long enough to complete the
  // full speed change within the block, we need to adjust the entry speed accordingly. Entry
  // speeds have already been reset, maximized, and reverse planned by reverse planner.
  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.
  if (!previous->nominal_length_flag) {
    if (previous->entry_speed < current->entry_speed) {
      double entry_speed = min(current->entry_speed,
        max_allowable_speed(-previous->acceleration, previous->entry_speed, previous->millimeters));

      // Check for junction speed change
      if (current->entry_speed != entry_speed) {
        current->entry_speed = entry_speed;
        current->recalculate_flag = true;
      }
    }
  }
}

// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This
// implements the forward pass.
void planner_forward_pass() {
  uint8_t block_index = block_buffer_tail;
  block_t *block[3] = { NULL, NULL, NULL };

  while (block_index != block_buffer_head) {
    block[0] = block[1];
    block[1] = block[2];
    block[2] = &block_buffer[block_index];
    planner_forward_pass_kernel(block[0], block[1], block[2]);
    block_index = next_block_index(block_index);
  }
  planner_forward_pass_kernel(block[1], block[2], NULL);
}

// Recalculates the trapezoid speed profiles for all blocks in the plan according to the 
// entry_factor for each junction. Must be called by planner_recalculate() after 
// updating the blocks.
void planner_recalculate_trapezoids() {
  int8_t block_index = block_buffer_tail;
  block_t *current;
  block_t *next = NULL;

  while (block_index != block_buffer_head) {
    current = next;
    next = &block_buffer[block_index];
    if (current) {
      // Recalculate if current block entry or exit junction speed has changed.
      if (current->recalculate_flag || next->recalculate_flag) {
        // NOTE: Entry and exit factors always > 0 by all previous logic operations.
        float nom = current->nominal_speed;
        calculate_trapezoid_for_block(current, current->entry_speed / nom, next->entry_speed / nom);
        current->recalculate_flag = false; // Reset current only to ensure next trapezoid is computed
      }
    }
    block_index = next_block_index( block_index );
  }
  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.
  if (next) {
    float nom = next->nominal_speed;
    calculate_trapezoid_for_block(next, next->entry_speed / nom, MINIMUM_PLANNER_SPEED / nom);
    next->recalculate_flag = false;
  }
}

// Recalculates the motion plan according to the following algorithm:
//
//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) 
//      so that:
//     a. The junction jerk is within the set limit
//     b. No speed reduction within one block requires faster deceleration than the one, true constant 
//        acceleration.
//   2. Go over every block in chronological order and dial down junction speed reduction values if 
//     a. The speed increase within one block would require faster acceleration than the one, true 
//        constant acceleration.
//
// When these stages are complete all blocks have an entry_factor that will allow all speed changes to 
// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than 
// the set limit. Finally it will:
//
//   3. Recalculate trapezoids for all blocks.

void planner_recalculate() {   
  planner_reverse_pass();
  planner_forward_pass();
  planner_recalculate_trapezoids();
}

void plan_init() {
  block_buffer_head = block_buffer_tail = 0;
  memset(position, 0, sizeof(position)); // clear position
  for (int i=0; i<NUM_AXIS; i++) previous_speed[i] = 0.0; 
  previous_nominal_speed = 0.0;
}


#if ENABLED(AUTOTEMP)
  void getHighESpeed() {
    static float oldt = 0;

    if (!autotemp_enabled) return;
    if (degTargetHotend0() + 2 < autotemp_min) return; // probably temperature set to zero.

    float high = 0.0;
    uint8_t block_index = block_buffer_tail;

    while (block_index != block_buffer_head) {
      block_t *block = &block_buffer[block_index];
      if (block->steps[X_AXIS] || block->steps[Y_AXIS] || block->steps[Z_AXIS]) {
        float se = (float)block->steps[E_AXIS] / block->step_event_count * block->nominal_speed; // mm/sec;
        if (se > high) high = se;
      }
      block_index = next_block_index(block_index);
    }

    float t = autotemp_min + high * autotemp_factor;
    t = constrain(t, autotemp_min, autotemp_max);
    if (oldt > t) {
      t *= (1 - AUTOTEMP_OLDWEIGHT);
      t += AUTOTEMP_OLDWEIGHT * oldt;
    }
    oldt = t;
    setTargetHotend0(t);
  }
#endif

void check_axes_activity() {
  unsigned char axis_active[NUM_AXIS] = { 0 },
                tail_fan_speed = fanSpeed;
  #if ENABLED(BARICUDA)
    unsigned char tail_valve_pressure = ValvePressure,
                  tail_e_to_p_pressure = EtoPPressure;
  #endif

  block_t *block;

  if (blocks_queued()) {
    uint8_t block_index = block_buffer_tail;
    tail_fan_speed = block_buffer[block_index].fan_speed;
    #if ENABLED(BARICUDA)
      block = &block_buffer[block_index];
      tail_valve_pressure = block->valve_pressure;
      tail_e_to_p_pressure = block->e_to_p_pressure;
    #endif
    while (block_index != block_buffer_head) {
      block = &block_buffer[block_index];
      for (int i=0; i<NUM_AXIS; i++) if (block->steps[i]) axis_active[i]++;
      block_index = next_block_index(block_index);
    }
  }
  if (DISABLE_X && !axis_active[X_AXIS]) disable_x();
  if (DISABLE_Y && !axis_active[Y_AXIS]) disable_y();
  if (DISABLE_Z && !axis_active[Z_AXIS]) disable_z();
  if (DISABLE_E && !axis_active[E_AXIS]) {
    disable_e0();
    disable_e1();
    disable_e2();
    disable_e3();
  }

  #if HAS_FAN
    #ifdef FAN_KICKSTART_TIME
      static millis_t fan_kick_end;
      if (tail_fan_speed) {
        millis_t ms = millis();
        if (fan_kick_end == 0) {
          // Just starting up fan - run at full power.
          fan_kick_end = ms + FAN_KICKSTART_TIME;
          tail_fan_speed = 255;
        } else if (fan_kick_end > ms)
          // Fan still spinning up.
          tail_fan_speed = 255;
        } else {
          fan_kick_end = 0;
        }
    #endif //FAN_KICKSTART_TIME
    #if ENABLED(FAN_MIN_PWM)
      #define CALC_FAN_SPEED (tail_fan_speed ? ( FAN_MIN_PWM + (tail_fan_speed * (255 - FAN_MIN_PWM)) / 255 ) : 0)
    #else
      #define CALC_FAN_SPEED tail_fan_speed
    #endif // FAN_MIN_PWM
    #if ENABLED(FAN_SOFT_PWM)
      fanSpeedSoftPwm = CALC_FAN_SPEED;
    #else
      analogWrite(FAN_PIN, CALC_FAN_SPEED);
    #endif // FAN_SOFT_PWM
  #endif // HAS_FAN

  #if ENABLED(AUTOTEMP)
    getHighESpeed();
  #endif

  #if ENABLED(BARICUDA)
    #if HAS_HEATER_1
      analogWrite(HEATER_1_PIN,tail_valve_pressure);
    #endif
    #if HAS_HEATER_2
      analogWrite(HEATER_2_PIN,tail_e_to_p_pressure);
    #endif
  #endif
}


float junction_deviation = 0.1;
// Add a new linear movement to the buffer. steps[X_AXIS], _y and _z is the absolute position in 
// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration
// calculation the caller must also provide the physical length of the line in millimeters.
#if ENABLED(ENABLE_AUTO_BED_LEVELING) || ENABLED(MESH_BED_LEVELING)
  void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t extruder)
#else
  void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t extruder)
#endif  // ENABLE_AUTO_BED_LEVELING
{
  // Calculate the buffer head after we push this byte
  int next_buffer_head = next_block_index(block_buffer_head);

  // If the buffer is full: good! That means we are well ahead of the robot. 
  // Rest here until there is room in the buffer.
  while (block_buffer_tail == next_buffer_head) idle();

  #if ENABLED(MESH_BED_LEVELING)
    if (mbl.active) z += mbl.get_z(x, y);
  #elif ENABLED(ENABLE_AUTO_BED_LEVELING)
    apply_rotation_xyz(plan_bed_level_matrix, x, y, z);
  #endif

  // The target position of the tool in absolute steps
  // Calculate target position in absolute steps
  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow
  long target[NUM_AXIS];
  target[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]);
  target[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]);
  target[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]);     
  target[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);

  float dx = target[X_AXIS] - position[X_AXIS],
        dy = target[Y_AXIS] - position[Y_AXIS],
        dz = target[Z_AXIS] - position[Z_AXIS];

  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied
  if (marlin_debug_flags & DEBUG_DRYRUN)
    position[E_AXIS] = target[E_AXIS];

  float de = target[E_AXIS] - position[E_AXIS];

  #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
    if (de) {
      if (degHotend(extruder) < extrude_min_temp) {
        position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
        de = 0; // no difference
        SERIAL_ECHO_START;
        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
      }
      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
        if (labs(de) > axis_steps_per_unit[E_AXIS] * EXTRUDE_MAXLENGTH) {
          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part
          de = 0; // no difference
          SERIAL_ECHO_START;
          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        }
      #endif
    }
  #endif

  // Prepare to set up new block
  block_t *block = &block_buffer[block_buffer_head];

  // Mark block as not busy (Not executed by the stepper interrupt)
  block->busy = false;

  // Number of steps for each axis
  #if ENABLED(COREXY)
    // corexy planning
    // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
    block->steps[A_AXIS] = labs(dx + dy);
    block->steps[B_AXIS] = labs(dx - dy);
    block->steps[Z_AXIS] = labs(dz);
  #elif defined(COREXZ)
    // corexz planning
    block->steps[A_AXIS] = labs(dx + dz);
    block->steps[Y_AXIS] = labs(dy);
    block->steps[C_AXIS] = labs(dx - dz);
  #else
    // default non-h-bot planning
    block->steps[X_AXIS] = labs(dx);
    block->steps[Y_AXIS] = labs(dy);
    block->steps[Z_AXIS] = labs(dz);
  #endif

  block->steps[E_AXIS] = labs(de);
  block->steps[E_AXIS] *= volumetric_multiplier[extruder];
  block->steps[E_AXIS] *= extruder_multiplier[extruder];
  block->steps[E_AXIS] /= 100;
  block->step_event_count = max(block->steps[X_AXIS], max(block->steps[Y_AXIS], max(block->steps[Z_AXIS], block->steps[E_AXIS])));

  // Bail if this is a zero-length block
  if (block->step_event_count <= dropsegments) return;

  block->fan_speed = fanSpeed;
  #if ENABLED(BARICUDA)
    block->valve_pressure = ValvePressure;
    block->e_to_p_pressure = EtoPPressure;
  #endif

  // Compute direction bits for this block 
  uint8_t db = 0;
  #if ENABLED(COREXY)
    if (dx < 0) db |= BIT(X_HEAD); // Save the real Extruder (head) direction in X Axis
    if (dy < 0) db |= BIT(Y_HEAD); // ...and Y
    if (dz < 0) db |= BIT(Z_AXIS);
    if (dx + dy < 0) db |= BIT(A_AXIS); // Motor A direction
    if (dx - dy < 0) db |= BIT(B_AXIS); // Motor B direction
  #elif defined(COREXZ)
    if (dx < 0) db |= BIT(X_HEAD); // Save the real Extruder (head) direction in X Axis
    if (dy < 0) db |= BIT(Y_AXIS);
    if (dz < 0) db |= BIT(Z_HEAD); // ...and Z
    if (dx + dz < 0) db |= BIT(A_AXIS); // Motor A direction
    if (dx - dz < 0) db |= BIT(C_AXIS); // Motor B direction
  #else
    if (dx < 0) db |= BIT(X_AXIS);
    if (dy < 0) db |= BIT(Y_AXIS); 
    if (dz < 0) db |= BIT(Z_AXIS);
  #endif
  if (de < 0) db |= BIT(E_AXIS); 
  block->direction_bits = db;

  block->active_extruder = extruder;

  //enable active axes
  #if ENABLED(COREXY)
    if (block->steps[A_AXIS] || block->steps[B_AXIS]) {
      enable_x();
      enable_y();
    }
    #ifndef Z_LATE_ENABLE
      if (block->steps[Z_AXIS]) enable_z();
    #endif
  #elif defined(COREXZ)
    if (block->steps[A_AXIS] || block->steps[C_AXIS]) {
      enable_x();
      enable_z();
    }
    if (block->steps[Y_AXIS]) enable_y();
  #else
    if (block->steps[X_AXIS]) enable_x();
    if (block->steps[Y_AXIS]) enable_y();
    #ifndef Z_LATE_ENABLE
      if (block->steps[Z_AXIS]) enable_z();
    #endif
  #endif

  // Enable extruder(s)
  if (block->steps[E_AXIS]) {
    if (DISABLE_INACTIVE_EXTRUDER) { //enable only selected extruder

      for (int i=0; i<EXTRUDERS; i++)
        if (g_uc_extruder_last_move[i] > 0) g_uc_extruder_last_move[i]--;
      
      switch(extruder) {
        case 0:
          enable_e0();
          g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE * 2;
          #if EXTRUDERS > 1
            if (g_uc_extruder_last_move[1] == 0) disable_e1();
            #if EXTRUDERS > 2
              if (g_uc_extruder_last_move[2] == 0) disable_e2();
              #if EXTRUDERS > 3
                if (g_uc_extruder_last_move[3] == 0) disable_e3();
              #endif
            #endif
          #endif
        break;
        #if EXTRUDERS > 1
          case 1:
            enable_e1();
            g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE * 2;
            if (g_uc_extruder_last_move[0] == 0) disable_e0();
            #if EXTRUDERS > 2
              if (g_uc_extruder_last_move[2] == 0) disable_e2();
              #if EXTRUDERS > 3
                if (g_uc_extruder_last_move[3] == 0) disable_e3();
              #endif
            #endif
          break;
          #if EXTRUDERS > 2
            case 2:
              enable_e2();
              g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE * 2;
              if (g_uc_extruder_last_move[0] == 0) disable_e0();
              if (g_uc_extruder_last_move[1] == 0) disable_e1();
              #if EXTRUDERS > 3
                if (g_uc_extruder_last_move[3] == 0) disable_e3();
              #endif
            break;
            #if EXTRUDERS > 3
              case 3:
                enable_e3();
                g_uc_extruder_last_move[3] = BLOCK_BUFFER_SIZE * 2;
                if (g_uc_extruder_last_move[0] == 0) disable_e0();
                if (g_uc_extruder_last_move[1] == 0) disable_e1();
                if (g_uc_extruder_last_move[2] == 0) disable_e2();
              break;
            #endif // EXTRUDERS > 3
          #endif // EXTRUDERS > 2
        #endif // EXTRUDERS > 1
      }
    }
    else { // enable all
      enable_e0();
      enable_e1();
      enable_e2();
      enable_e3();
    }
  }

  if (block->steps[E_AXIS])
    NOLESS(feed_rate, minimumfeedrate);
  else
    NOLESS(feed_rate, mintravelfeedrate);

  /**
   * This part of the code calculates the total length of the movement. 
   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.
   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS
   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.
   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head. 
   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.
   */ 
  #if ENABLED(COREXY)
    float delta_mm[6];
    delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];
    delta_mm[Y_HEAD] = dy / axis_steps_per_unit[B_AXIS];
    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];
    delta_mm[A_AXIS] = (dx + dy) / axis_steps_per_unit[A_AXIS];
    delta_mm[B_AXIS] = (dx - dy) / axis_steps_per_unit[B_AXIS];
  #elif defined(COREXZ)
    float delta_mm[6];
    delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];
    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];
    delta_mm[Z_HEAD] = dz / axis_steps_per_unit[C_AXIS];
    delta_mm[A_AXIS] = (dx + dz) / axis_steps_per_unit[A_AXIS];
    delta_mm[C_AXIS] = (dx - dz) / axis_steps_per_unit[C_AXIS];
  #else
    float delta_mm[4];
    delta_mm[X_AXIS] = dx / axis_steps_per_unit[X_AXIS];
    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];
    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];
  #endif
  delta_mm[E_AXIS] = (de / axis_steps_per_unit[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder] / 100.0;

  if (block->steps[X_AXIS] <= dropsegments && block->steps[Y_AXIS] <= dropsegments && block->steps[Z_AXIS] <= dropsegments) {
    block->millimeters = fabs(delta_mm[E_AXIS]);
  } 
  else {
    block->millimeters = sqrt(
      #if ENABLED(COREXY)
        square(delta_mm[X_HEAD]) + square(delta_mm[Y_HEAD]) + square(delta_mm[Z_AXIS])
      #elif ENABLED(COREXZ)
        square(delta_mm[X_HEAD]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_HEAD])
      #else
        square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS])
      #endif
    );
  }
  float inverse_millimeters = 1.0 / block->millimeters;  // Inverse millimeters to remove multiple divides 

  // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.
  float inverse_second = feed_rate * inverse_millimeters;

  int moves_queued = movesplanned();

  // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill
  #if ENABLED(OLD_SLOWDOWN) || ENABLED(SLOWDOWN)
    bool mq = moves_queued > 1 && moves_queued < BLOCK_BUFFER_SIZE / 2;
    #if ENABLED(OLD_SLOWDOWN)
      if (mq) feed_rate *= 2.0 * moves_queued / BLOCK_BUFFER_SIZE;
    #endif
    #if ENABLED(SLOWDOWN)
      //  segment time im micro seconds
      unsigned long segment_time = lround(1000000.0/inverse_second);
      if (mq) {
        if (segment_time < minsegmenttime) {
          // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.
          inverse_second = 1000000.0 / (segment_time + lround(2 * (minsegmenttime - segment_time) / moves_queued));
          #ifdef XY_FREQUENCY_LIMIT
            segment_time = lround(1000000.0 / inverse_second);
          #endif
        }
      }
    #endif
  #endif

  block->nominal_speed = block->millimeters * inverse_second; // (mm/sec) Always > 0
  block->nominal_rate = ceil(block->step_event_count * inverse_second); // (step/sec) Always > 0

  #if ENABLED(FILAMENT_SENSOR)
    //FMM update ring buffer used for delay with filament measurements
  
    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && delay_index2 > -1) {  //only for extruder with filament sensor and if ring buffer is initialized

      const int MMD = MAX_MEASUREMENT_DELAY + 1, MMD10 = MMD * 10;

      delay_dist += delta_mm[E_AXIS];  // increment counter with next move in e axis
      while (delay_dist >= MMD10) delay_dist -= MMD10; // loop around the buffer
      while (delay_dist < 0) delay_dist += MMD10;

      delay_index1 = delay_dist / 10.0;  // calculate index
      delay_index1 = constrain(delay_index1, 0, MAX_MEASUREMENT_DELAY); // (already constrained above)

      if (delay_index1 != delay_index2) { // moved index
        meas_sample = widthFil_to_size_ratio() - 100;  // Subtract 100 to reduce magnitude - to store in a signed char
        while (delay_index1 != delay_index2) {
          // Increment and loop around buffer
          if (++delay_index2 >= MMD) delay_index2 -= MMD;
          delay_index2 = constrain(delay_index2, 0, MAX_MEASUREMENT_DELAY);
          measurement_delay[delay_index2] = meas_sample;
        }
      }
    }
  #endif

  // Calculate and limit speed in mm/sec for each axis
  float current_speed[NUM_AXIS];
  float speed_factor = 1.0; //factor <=1 do decrease speed
  for (int i = 0; i < NUM_AXIS; i++) {
    current_speed[i] = delta_mm[i] * inverse_second;
    float cs = fabs(current_speed[i]), mf = max_feedrate[i];
    if (cs > mf) speed_factor = min(speed_factor, mf / cs);
  }

  // Max segement time in us.
  #ifdef XY_FREQUENCY_LIMIT
    #define MAX_FREQ_TIME (1000000.0 / XY_FREQUENCY_LIMIT)

    // Check and limit the xy direction change frequency
    unsigned char direction_change = block->direction_bits ^ old_direction_bits;
    old_direction_bits = block->direction_bits;
    segment_time = lround((float)segment_time / speed_factor);
  
    long xs0 = axis_segment_time[X_AXIS][0],
         xs1 = axis_segment_time[X_AXIS][1],
         xs2 = axis_segment_time[X_AXIS][2],
         ys0 = axis_segment_time[Y_AXIS][0],
         ys1 = axis_segment_time[Y_AXIS][1],
         ys2 = axis_segment_time[Y_AXIS][2];

    if ((direction_change & BIT(X_AXIS)) != 0) {
      xs2 = axis_segment_time[X_AXIS][2] = xs1;
      xs1 = axis_segment_time[X_AXIS][1] = xs0;
      xs0 = 0;
    }
    xs0 = axis_segment_time[X_AXIS][0] = xs0 + segment_time;

    if ((direction_change & BIT(Y_AXIS)) != 0) {
      ys2 = axis_segment_time[Y_AXIS][2] = axis_segment_time[Y_AXIS][1];
      ys1 = axis_segment_time[Y_AXIS][1] = axis_segment_time[Y_AXIS][0];
      ys0 = 0;
    }
    ys0 = axis_segment_time[Y_AXIS][0] = ys0 + segment_time;

    long max_x_segment_time = max(xs0, max(xs1, xs2)),
         max_y_segment_time = max(ys0, max(ys1, ys2)),
         min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);
    if (min_xy_segment_time < MAX_FREQ_TIME) {
      float low_sf = speed_factor * min_xy_segment_time / MAX_FREQ_TIME;
      speed_factor = min(speed_factor, low_sf);
    }
  #endif // XY_FREQUENCY_LIMIT

  // Correct the speed  
  if (speed_factor < 1.0) {
    for (unsigned char i = 0; i < NUM_AXIS; i++) current_speed[i] *= speed_factor;
    block->nominal_speed *= speed_factor;
    block->nominal_rate *= speed_factor;
  }

  // Compute and limit the acceleration rate for the trapezoid generator.  
  float steps_per_mm = block->step_event_count / block->millimeters;
  long bsx = block->steps[X_AXIS], bsy = block->steps[Y_AXIS], bsz = block->steps[Z_AXIS], bse = block->steps[E_AXIS];
  if (bsx == 0 && bsy == 0 && bsz == 0) {
    block->acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
  }
  else if (bse == 0) {
    block->acceleration_st = ceil(travel_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
  }
  else {
    block->acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2
  }
  // Limit acceleration per axis
  unsigned long acc_st = block->acceleration_st,
                xsteps = axis_steps_per_sqr_second[X_AXIS],
                ysteps = axis_steps_per_sqr_second[Y_AXIS],
                zsteps = axis_steps_per_sqr_second[Z_AXIS],
                esteps = axis_steps_per_sqr_second[E_AXIS];
  if ((float)acc_st * bsx / block->step_event_count > xsteps) acc_st = xsteps;
  if ((float)acc_st * bsy / block->step_event_count > ysteps) acc_st = ysteps;
  if ((float)acc_st * bsz / block->step_event_count > zsteps) acc_st = zsteps;
  if ((float)acc_st * bse / block->step_event_count > esteps) acc_st = esteps;
 
  block->acceleration_st = acc_st;
  block->acceleration = acc_st / steps_per_mm;
  block->acceleration_rate = (long)(acc_st * ( 4294967296.0 / HAL_TIMER_RATE));

  #if 0  // Use old jerk for now
    // Compute path unit vector
    double unit_vec[3];

    unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;
    unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;
    unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;

    // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
    // Let a circle be tangent to both previous and current path line segments, where the junction
    // deviation is defined as the distance from the junction to the closest edge of the circle,
    // colinear with the circle center. The circular segment joining the two paths represents the
    // path of centripetal acceleration. Solve for max velocity based on max acceleration about the
    // radius of the circle, defined indirectly by junction deviation. This may be also viewed as
    // path width or max_jerk in the previous grbl version. This approach does not actually deviate
    // from path, but used as a robust way to compute cornering speeds, as it takes into account the
    // nonlinearities of both the junction angle and junction velocity.
    double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed

    // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.
    if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed > 0.0)) {
      // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)
      // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.
      double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]
        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]
        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;

      // Skip and use default max junction speed for 0 degree acute junction.
      if (cos_theta < 0.95) {
        vmax_junction = min(previous_nominal_speed,block->nominal_speed);
        // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.
        if (cos_theta > -0.95) {
          // Compute maximum junction velocity based on maximum acceleration and junction deviation
          double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.
          vmax_junction = min(vmax_junction,
          sqrt(block->acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );
        }
      }
    }
  #endif

  // Start with a safe speed
  float vmax_junction = max_xy_jerk / 2;
  float vmax_junction_factor = 1.0; 
  float mz2 = max_z_jerk / 2, me2 = max_e_jerk / 2;
  float csz = current_speed[Z_AXIS], cse = current_speed[E_AXIS];
  if (fabs(csz) > mz2) vmax_junction = min(vmax_junction, mz2);
  if (fabs(cse) > me2) vmax_junction = min(vmax_junction, me2);
  vmax_junction = min(vmax_junction, block->nominal_speed);
  float safe_speed = vmax_junction;

  if ((moves_queued > 1) && (previous_nominal_speed > 0.0001)) {
    float dx = current_speed[X_AXIS] - previous_speed[X_AXIS],
          dy = current_speed[Y_AXIS] - previous_speed[Y_AXIS],
          dz = fabs(csz - previous_speed[Z_AXIS]),
          de = fabs(cse - previous_speed[E_AXIS]),
          jerk = sqrt(dx * dx + dy * dy);

    //    if ((fabs(previous_speed[X_AXIS]) > 0.0001) || (fabs(previous_speed[Y_AXIS]) > 0.0001)) {
    vmax_junction = block->nominal_speed;
    //    }
    if (jerk > max_xy_jerk) vmax_junction_factor = max_xy_jerk / jerk;
    if (dz > max_z_jerk) vmax_junction_factor = min(vmax_junction_factor, max_z_jerk / dz);
    if (de > max_e_jerk) vmax_junction_factor = min(vmax_junction_factor, max_e_jerk / de);

    vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed
  }
  block->max_entry_speed = vmax_junction;

  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.
  double v_allowable = max_allowable_speed(-block->acceleration, MINIMUM_PLANNER_SPEED, block->millimeters);
  block->entry_speed = min(vmax_junction, v_allowable);

  // Initialize planner efficiency flags
  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.
  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then
  // the current block and next block junction speeds are guaranteed to always be at their maximum
  // junction speeds in deceleration and acceleration, respectively. This is due to how the current
  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both
  // the reverse and forward planners, the corresponding block junction speed will always be at the
  // the maximum junction speed and may always be ignored for any speed reduction checks.
  block->nominal_length_flag = (block->nominal_speed <= v_allowable); 
  block->recalculate_flag = true; // Always calculate trapezoid for new block

  // Update previous path unit_vector and nominal speed
  for (int i = 0; i < NUM_AXIS; i++) previous_speed[i] = current_speed[i];
  previous_nominal_speed = block->nominal_speed;

  #if ENABLED(ADVANCE)
    // Calculate advance rate
    if (!bse || (!bsx && !bsy && !bsz)) {
      block->advance_rate = 0;
      block->advance = 0;
    }
    else {
      long acc_dist = estimate_acceleration_distance(0, block->nominal_rate, block->acceleration_st);
      float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * (cse * cse * EXTRUSION_AREA * EXTRUSION_AREA) * 256;
      block->advance = advance;
      block->advance_rate = acc_dist ? advance / (float)acc_dist : 0;
    }
    /*
      SERIAL_ECHO_START;
     SERIAL_ECHOPGM("advance :");
     SERIAL_ECHO(block->advance/256.0);
     SERIAL_ECHOPGM("advance rate :");
     SERIAL_ECHOLN(block->advance_rate/256.0);
     */
  #endif // ADVANCE

  calculate_trapezoid_for_block(block, block->entry_speed / block->nominal_speed, safe_speed / block->nominal_speed);

  // Move buffer head
  block_buffer_head = next_buffer_head;

  // Update position
  for (int i = 0; i < NUM_AXIS; i++) position[i] = target[i];

  planner_recalculate();

  st_wake_up();

} // plan_buffer_line()

#if ENABLED(ENABLE_AUTO_BED_LEVELING) && DISABLED(DELTA)
  vector_3 plan_get_position() {
    vector_3 position = vector_3(st_get_position_mm(X_AXIS), st_get_position_mm(Y_AXIS), st_get_position_mm(Z_AXIS));

    //position.debug("in plan_get position");
    //plan_bed_level_matrix.debug("in plan_get_position");
    matrix_3x3 inverse = matrix_3x3::transpose(plan_bed_level_matrix);
    //inverse.debug("in plan_get inverse");
    position.apply_rotation(inverse);
    //position.debug("after rotation");

    return position;
  }
#endif // ENABLE_AUTO_BED_LEVELING && !DELTA

#if ENABLED(ENABLE_AUTO_BED_LEVELING) || ENABLED(MESH_BED_LEVELING)
  void plan_set_position(float x, float y, float z, const float &e)
#else
  void plan_set_position(const float &x, const float &y, const float &z, const float &e)
#endif // ENABLE_AUTO_BED_LEVELING || MESH_BED_LEVELING
  {
    #if ENABLED(MESH_BED_LEVELING)
      if (mbl.active) z += mbl.get_z(x, y);
    #elif ENABLED(ENABLE_AUTO_BED_LEVELING)
      apply_rotation_xyz(plan_bed_level_matrix, x, y, z);
    #endif

    float nx = position[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]),
          ny = position[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]),
          nz = position[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]),
          ne = position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);
    st_set_position(nx, ny, nz, ne);
    previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.

    for (int i=0; i<NUM_AXIS; i++) previous_speed[i] = 0.0;
  }

void plan_set_e_position(const float &e) {
  position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);  
  st_set_e_position(position[E_AXIS]);
}

// Calculate the steps/s^2 acceleration rates, based on the mm/s^s
void reset_acceleration_rates() {
  for (int i = 0; i < NUM_AXIS; i++)
    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];
}





#endif
++++++


**--**-**--merge: qr_solve.cpp

#if defined (upstream) && defined (AUTO_BED_LEVELING_GRID)
double value;
#endif
++++++
#if defined (upstream) && defined (AUTO_BED_LEVELING_GRID)
double *work;
#endif
++++++
#if defined (marlin4Due) && defined (AUTO_BED_LEVELING_GRID)
double work[n];
#endif
++++++
#if defined (upstream) && defined (AUTO_BED_LEVELING_GRID)
work = ( double * ) malloc ( n * sizeof ( double ) );
#endif
++++++
#if defined (upstream) && defined (AUTO_BED_LEVELING_GRID)
free ( work );
#endif
++++++
#if defined (upstream) && defined (AUTO_BED_LEVELING_GRID)
double *r8mat_copy_new ( int m, int n, double a1[] )

/******************************************************************************/
/*
  Purpose:

    R8MAT_COPY_NEW copies one R8MAT to a "new" R8MAT.

  Discussion:

    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
    in column-major order.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    26 July 2008

  Author:

    John Burkardt

  Parameters:

    Input, int M, N, the number of rows and columns.

    Input, double A1[M*N], the matrix to be copied.

    Output, double R8MAT_COPY_NEW[M*N], the copy of A1.
*/
{
  double *a2;
  int i;
  int j;

  a2 = ( double * ) malloc ( m * n * sizeof ( double ) );

  for ( j = 0; j < n; j++ )
  {
    for ( i = 0; i < m; i++ )
    {
      a2[i+j*m] = a1[i+j*m];
    }
  }

  return a2;
}
#endif
++++++
#if defined (marlin4Due) && defined (AUTO_BED_LEVELING_GRID)
void r8mat_copy( double a2[], int m, int n, double a1[] )

/******************************************************************************/
/*
  Purpose:

    R8MAT_COPY_NEW copies one R8MAT to a "new" R8MAT.

  Discussion:

    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector
    in column-major order.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    26 July 2008

  Author:

    John Burkardt

  Parameters:

    Input, int M, N, the number of rows and columns.

    Input, double A1[M*N], the matrix to be copied.

    Output, double R8MAT_COPY_NEW[M*N], the copy of A1.
*/
{
  int i;
  int j;

  for ( j = 0; j < n; j++ )
  {
    for ( i = 0; i < m; i++ )
    {
      a2[i+j*m] = a1[i+j*m];
    }
  }
}
#endif
++++++
#if defined (upstream) && defined (AUTO_BED_LEVELING_GRID)
double *qr_solve ( int m, int n, double a[], double b[] )

/******************************************************************************/
/*
  Purpose:

    QR_SOLVE solves a linear system in the least squares sense.

  Discussion:

    If the matrix A has full column rank, then the solution X should be the
    unique vector that minimizes the Euclidean norm of the residual.

    If the matrix A does not have full column rank, then the solution is
    not unique; the vector X will minimize the residual norm, but so will
    various other vectors.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    11 September 2012

  Author:

    John Burkardt

  Reference:

    David Kahaner, Cleve Moler, Steven Nash,
    Numerical Methods and Software,
    Prentice Hall, 1989,
    ISBN: 0-13-627258-4,
    LC: TA345.K34.

  Parameters:

    Input, int M, the number of rows of A.

    Input, int N, the number of columns of A.

    Input, double A[M*N], the matrix.

    Input, double B[M], the right hand side.

    Output, double QR_SOLVE[N], the least squares solution.
*/
{
  double *a_qr;
  int ind;
  int itask;
  int *jpvt;
  int kr;
  int lda;
  double *qraux;
  double *r;
  double tol;
  double *x;

  a_qr = r8mat_copy_new ( m, n, a );
  lda = m;
  tol = r8_epsilon ( ) / r8mat_amax ( m, n, a_qr );
  x = ( double * ) malloc ( n * sizeof ( double ) );
  jpvt = ( int * ) malloc ( n * sizeof ( int ) );
  qraux = ( double * ) malloc ( n * sizeof ( double ) );
  r = ( double * ) malloc ( m * sizeof ( double ) );
  itask = 1;

  ind = dqrls ( a_qr, lda, m, n, tol, &kr, b, x, r, jpvt, qraux, itask );

  free ( a_qr );
  free ( jpvt );
  free ( qraux ); 
  free ( r );

  return x;
}
#endif
++++++
#if defined (marlin4Due) && defined (AUTO_BED_LEVELING_GRID)
void qr_solve ( double x[], int m, int n, double a[], double b[] )

/******************************************************************************/
/*
  Purpose:

    QR_SOLVE solves a linear system in the least squares sense.

  Discussion:

    If the matrix A has full column rank, then the solution X should be the
    unique vector that minimizes the Euclidean norm of the residual.

    If the matrix A does not have full column rank, then the solution is
    not unique; the vector X will minimize the residual norm, but so will
    various other vectors.

  Licensing:

    This code is distributed under the GNU LGPL license.

  Modified:

    11 September 2012

  Author:

    John Burkardt

  Reference:

    David Kahaner, Cleve Moler, Steven Nash,
    Numerical Methods and Software,
    Prentice Hall, 1989,
    ISBN: 0-13-627258-4,
    LC: TA345.K34.

  Parameters:

    Input, int M, the number of rows of A.

    Input, int N, the number of columns of A.

    Input, double A[M*N], the matrix.

    Input, double B[M], the right hand side.

    Output, double QR_SOLVE[N], the least squares solution.
*/
{
  double a_qr[n*m];
  int ind;
  int itask;
  int jpvt[n];
  int kr;
  int lda;
  double qraux[n];
  double r[m];
  double tol;

  r8mat_copy( a_qr, m, n, a );
  lda = m;
  tol = r8_epsilon ( ) / r8mat_amax ( m, n, a_qr );
  itask = 1;

  ind = dqrls ( a_qr, lda, m, n, tol, &kr, b, x, r, jpvt, qraux, itask );
}
#endif
++++++


**--**-**--merge: Sd2Card.cpp

#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
(uint8_t spiRate)
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
(void)
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
// See avr processor documentation
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
SPI.end();
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
SPCR = (1 << SPE) | (1 << MSTR) | (spiRate >> 1);
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
//todo: check these settings
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
SPSR = spiRate & 1 || spiRate == 6 ? 0 : 1 << SPI2X;
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
SPI.begin();
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
SPDR = 0XFF;
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
return SPI.transfer(0xFF);
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
while (!(SPSR & (1 << SPIF))) { /* Intentionally left empty */ }
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
(uint8_t data)
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
(uint8_t b)
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
// no interrupts during byte send - about 8 us
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
SPI.transfer(b);
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
cli();
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
spiInit();
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
spiRate_ = SPI_SD_INIT_RATE;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
setSckRate(SPI_SD_INIT_RATE);
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
spiInit(spiRate_);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// SOFTWARE_SPI
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
// SOFTWARE_SPI
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// SOFTWARE_SPI
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if (sckRateID > 6) {
    error(SD_CARD_ERROR_SCK_RATE);
    return false;
  }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
spiSetSckRate (sckRateID);
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
//------------------------------------------------------------------------------
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
// make sure SPCR rate is in expected bits
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
#include <SPI.h>
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && ((SPR0 != 0 || SPR1 != 1) && )defined (SDSUPPORT) )
#error unexpected SPCR bits
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
/**
 * Initialize hardware SPI
 * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]
 */
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
//------------------------------------------------------------------------------
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
static void spiSetSckRate (uint8_t spiRate) {
	SPI.setClockDivider(spiRate);
}
#endif
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
static void spiSetSckRate (uint8_t spiRate) {
	SPI.setClockDivider(spiRate);
}
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
/** SPI receive a byte */
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
//------------------------------------------------------------------------------
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
static inline __attribute__((always_inline))
void spiRead(uint8_t* buf, uint16_t nbyte) {

	while (nbyte--)
		*buf++ = spiRec();

}
#endif
++++++
#if defined (upstream) && (!defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
/** SPI read data - only one call so force inline */
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
// SOFTWARE_SPI
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
//------------------------------------------------------------------------------
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (ARDUINO_ARCH_SAM) )
static inline __attribute__((always_inline))
  void spiSendBlock(uint8_t token, const uint8_t* buf) {

  spiSend (token);
  for (uint16_t i = 0; i < 512; i += 2) {
	spiSend (buf[i]);
	spiSend (buf[i+1]);
  }
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
/** Soft SPI send block */
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && !defined (ARDUINO_ARCH_SAM) )
#error Unsupported architecture
#endif
++++++
#if defined (upstream) && (defined (SOFTWARE_SPI) && defined (SDSUPPORT) )
void spiSendBlock(uint8_t token, const uint8_t* buf) {
  spiSend(token);
  for (uint16_t i = 0; i < 512; i++) {
    spiSend(buf[i]);
  }
}
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// SOFTWARE_SPI
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {
  // select card
  chipSelectLow();

  // wait up to 300 ms if busy
  waitNotBusy(300);

  // send command
  spiSend(cmd | 0x40);

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
  spiSend(crc);

  // skip stuff byte for stop read
  if (cmd == CMD12) spiRec();

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }
  return status_;
}
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
Sd2Card
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
uint32_t Sd2Card::cardSize() {
  csd_t csd;
  if (!readCSD(&csd)) return 0;
  if (csd.v1.csd_ver == 0) {
    uint8_t read_bl_len = csd.v1.read_bl_len;
    uint16_t c_size = (csd.v1.c_size_high << 10)
                      | (csd.v1.c_size_mid << 2) | csd.v1.c_size_low;
    uint8_t c_size_mult = (csd.v1.c_size_mult_high << 1)
                          | csd.v1.c_size_mult_low;
    return (uint32_t)(c_size + 1) << (c_size_mult + read_bl_len - 7);
  } else if (csd.v2.csd_ver == 1) {
    uint32_t c_size = ((uint32_t)csd.v2.c_size_high << 16)
                      | (csd.v2.c_size_mid << 8) | csd.v2.c_size_low;
    return (c_size + 1) << 10;
  } else {
    error(SD_CARD_ERROR_BAD_CSD);
    return 0;
  }
}
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
Sd2Card
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
void Sd2Card::chipSelectHigh() {
  digitalWrite(chipSelectPin_, HIGH);
}
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
Sd2Card
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//------------------------------------------------------------------------------
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
::chipSelectHigh() {
  digitalWrite(chipSelectPin_, HIGH);
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow() {
  setSckRate(spiRate_);
  digitalWrite(chipSelectPin_, LOW);
}
//------------------------------------------------------------------------------
/** Erase a range of blocks.
 *
 * \param[in] firstBlock The address of the first block in the range.
 * \param[in] lastBlock The address of the last block in the range.
 *
 * \note This function requests the SD card to do a flash erase for a
 * range of blocks.  The data on the card after an erase operation is
 * either 0 or 1, depends on the card vendor.  The card must support
 * single block erase.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
  csd_t csd;
  if (!readCSD(&csd)) goto fail;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
void Sd2Card::chipSelectLow() {
#ifndef SOFTWARE_SPI
  spiInit(spiRate_);
#endif  // SOFTWARE_SPI
  digitalWrite(chipSelectPin_, LOW);
}
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// check for single block erase
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//------------------------------------------------------------------------------
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
      goto fail;
    }
  }
#endif
#if defined (marlin4Due) && defined (SDSUPPORT)
if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
      goto fail;
    }
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
/** Erase a range of blocks.
 *
 * \param[in] firstBlock The address of the first block in the range.
 * \param[in] lastBlock The address of the last block in the range.
 *
 * \note This function requests the SD card to do a flash erase for a
 * range of blocks.  The data on the card after an erase operation is
 * either 0 or 1, depends on the card vendor.  The card must support
 * single block erase.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (type_ != SD_CARD_TYPE_SDHC) {
    firstBlock <<= 9;
    lastBlock <<= 9;
  }
#endif
#if defined (marlin4Due) && defined (SDSUPPORT)
if (type_ != SD_CARD_TYPE_SDHC) {
    firstBlock <<= 9;
    lastBlock <<= 9;
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {
  csd_t csd;
  if (!readCSD(&csd)) goto fail;
  // check for single block erase
  if (!csd.v1.erase_blk_en) {
    // erase size mask
    uint8_t m = (csd.v1.sector_size_high << 1) | csd.v1.sector_size_low;
    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {
      // error card can't erase specified area
      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);
      goto fail;
    }
  }
  if (type_ != SD_CARD_TYPE_SDHC) {
    firstBlock <<= 9;
    lastBlock <<= 9;
  }
  if (cardCommand(CMD32, firstBlock)
    || cardCommand(CMD33, lastBlock)
    || cardCommand(CMD38, 0)) {
      error(SD_CARD_ERROR_ERASE);
      goto fail;
  }
  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {
    error(SD_CARD_ERROR_ERASE_TIMEOUT);
    goto fail;
  }
  chipSelectHigh();
  return true;

 fail:
  chipSelectHigh();
  return false;
}
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (cardCommand(CMD32, firstBlock)
    || cardCommand(CMD33, lastBlock)
    || cardCommand(CMD38, 0)) {
      error(SD_CARD_ERROR_ERASE);
      goto fail;
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
bool Sd2Card::eraseSingleBlockEnable() {
  csd_t csd;
  return readCSD(&csd) ? csd.v1.erase_blk_en : false;
}
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
Sd2Card
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
/**
 * Set the SPI clock rate.
 *
 * \param[in] sckRateID A value in the range [0, 6].
 *
 * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum
 * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128
 * for \a scsRateID = 6.
 *
 * \return The value one, true, is returned for success and the value zero,
 * false, is returned for an invalid value of \a sckRateID.
 */
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
/**
 * Set the SPI clock rate.
 *
 * \param[in] sckRateID A value in a range depending on platform
 *
 * \return The value one, true, is returned for success and the value zero,
 * false, is returned for an invalid value of \a sckRateID.
 */
#endif
++++++


**--**-**--merge: SdBaseFile.cpp

#if defined (upstream) && defined (SDSUPPORT)
(fpos_t* pos)
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
(FatPos_t* pos)
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (__AVR__) )
// store chars in flash
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
goto fail;
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (__AVR__) )
{
        goto fail;
      }
#endif
++++++
#if defined (marlin4Due) && (!defined (__AVR__) && defined (SDSUPPORT) )
// __AVR__
#endif
++++++
#if defined (marlin4Due) && (!defined (__AVR__) && defined (SDSUPPORT) )
// store chars in RAM
#endif
++++++
#if defined (marlin4Due) && (!defined (__AVR__) && defined (SDSUPPORT) )
if (strchr("|<>^+=?/[];,*\"\\", c)) {
        goto fail;
      }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// __AVR__
#endif
++++++
#if defined (marlin4Due) && (defined (SDSUPPORT) && defined (__AVR__) )
// store chars in flash
#endif
++++++
#if defined (marlin4Due) && (!defined (__AVR__) && defined (SDSUPPORT) )
// __AVR__
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// __AVR__
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
fpos_t pos;
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
FatPos_t pos;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char name[13];
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
char name[FILENAME_LENGTH];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)

  	longFilename[0] = '\0';
  

#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)longFilename[0] = '\0';
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//Fill the long filename if we have a long filename entry,
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Fill the long filename if we have a long filename entry.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// long filename entries are stored before the actual filename.
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Long filename entries are stored before the short filename.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if (DIR_IS_LONG_NAME(dir) && longFilename != NULL)
    {
    	vfat_t *VFAT = (vfat_t*)dir;
		//Sanity check the VFAT entry. The first cluster is always set to zero. And th esequence number should be higher then 0
    	if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES)
    	{
			//TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
    		n = ((VFAT->sequenceNumber & 0x1F) - 1) * 13;
			longFilename[n+0] = VFAT->name1[0];
			longFilename[n+1] = VFAT->name1[1];
			longFilename[n+2] = VFAT->name1[2];
			longFilename[n+3] = VFAT->name1[3];
			longFilename[n+4] = VFAT->name1[4];
			longFilename[n+5] = VFAT->name2[0];
			longFilename[n+6] = VFAT->name2[1];
			longFilename[n+7] = VFAT->name2[2];
			longFilename[n+8] = VFAT->name2[3];
			longFilename[n+9] = VFAT->name2[4];
			longFilename[n+10] = VFAT->name2[5];
			longFilename[n+11] = VFAT->name3[0];
			longFilename[n+12] = VFAT->name3[1];
			//If this VFAT entry is the last one, add a NUL terminator at the end of the string
			if (VFAT->sequenceNumber & 0x40)
				longFilename[n+13] = '\0';
		}
    }
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
if (longFilename != NULL && DIR_IS_LONG_NAME(dir)) {
      vfat_t *VFAT = (vfat_t*)dir;
      // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
      if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES) {
        // TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
        n = ((VFAT->sequenceNumber & 0x1F) - 1) * FILENAME_LENGTH;
        for (uint8_t i=0; i<FILENAME_LENGTH; i++)
          longFilename[n+i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i-5] : VFAT->name3[i-11];
        // If this VFAT entry is the last one, add a NUL terminator at the end of the string
        if (VFAT->sequenceNumber & 0x40) longFilename[n+FILENAME_LENGTH] = '\0';
      }
    }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// return if normal file or subdirectory
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
// Return if normal file or subdirectory
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(fpos_t* pos)
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
(FatPos_t* pos)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//------------------------------------------------------------------------------
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
/**
 * Read the next entry in a directory.
 *
 * \param[out] dir The dir_t struct that will receive the data.
 *
 * \return For success readDir() returns the number of bytes read.
 * A value of zero will be returned if end of file is reached.
 * If an error occurs, readDir() returns -1.  Possible errors include
 * readDir() called before a directory has been opened, this is not
 * a directory file or an I/O error occurred.
 */
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
/** Read the next directory entry from a directory file.
 *
 * \param[out] dir The dir_t struct that will receive the data.
 *
 * \return For success readDir() returns the number of bytes read.
 * A value of zero will be returned if end of file is reached.
 * If an error occurs, readDir() returns -1.  Possible errors include
 * readDir() called before a directory has been opened, this is not
 * a directory file or an I/O error occurred.
 */
#endif
++++++


**--**-**--merge: SdFatUtil.cpp



**--**-**--merge: SdFile.cpp



**--**-**--merge: SdVolume.cpp

#if defined (upstream) && defined (SDSUPPORT)
(blocksPerCluster_ != (1 << clusterSizeShift_))
#endif
++++++
#if defined (marlin4Due) && defined (SDSUPPORT)
(blocksPerCluster_ != BIT(clusterSizeShift_))
#endif
++++++


**--**-**--merge: Servo.cpp

#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer1) )_initISR(TC_FOR_TIMER1, CHANNEL_FOR_TIMER1, ID_TC_FOR_TIMER1, IRQn_FOR_TIMER1);
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer3) )_initISR(TC_FOR_TIMER3, CHANNEL_FOR_TIMER3, ID_TC_FOR_TIMER3, IRQn_FOR_TIMER3);
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined (_useTimer4) )

    TCCR4A = 0;             // normal counting mode
    TCCR4B = _BV(CS41);     // set prescaler of 8
    TCNT4 = 0;              // clear the timer count
    TIFR4 = _BV(OCF4A);     // clear any pending interrupts;
    TIMSK4 =  _BV(OCIE4A) ; // enable the output compare interrupt
  

#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer4) )_initISR(TC_FOR_TIMER4, CHANNEL_FOR_TIMER4, ID_TC_FOR_TIMER4, IRQn_FOR_TIMER4);
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined (_useTimer5) )

    TCCR5A = 0;             // normal counting mode
    TCCR5B = _BV(CS51);     // set prescaler of 8
    TCNT5 = 0;              // clear the timer count
    TIFR5 = _BV(OCF5A);     // clear any pending interrupts;
    TIMSK5 =  _BV(OCIE5A) ; // enable the output compare interrupt
  

#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer5) )_initISR(TC_FOR_TIMER5, CHANNEL_FOR_TIMER5, ID_TC_FOR_TIMER5, IRQn_FOR_TIMER5);
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer2) )
if (timer == _timer2)
        _initISR(TC_FOR_TIMER2, CHANNEL_FOR_TIMER2, ID_TC_FOR_TIMER2, IRQn_FOR_TIMER2);
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
//disable use of the given timer
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer1) )
TC_Stop(TC_FOR_TIMER1, CHANNEL_FOR_TIMER1);
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined WIRING )
// Wiring
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer2) )
TC_Stop(TC_FOR_TIMER2, CHANNEL_FOR_TIMER2);
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer3) )
TC_Stop(TC_FOR_TIMER3, CHANNEL_FOR_TIMER3);
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && !defined WIRING )
//For arduino - in future: call here to a currently undefined function to reset the timer
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer4) )
TC_Stop(TC_FOR_TIMER4, CHANNEL_FOR_TIMER4);
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer5) )
TC_Stop(TC_FOR_TIMER5, CHANNEL_FOR_TIMER5);
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
(SERVO(timer,channel).Pin.isActive == true)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
(SERVO(timer,channel).Pin.isActive)
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
servos[this->servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
servo_info[this->servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
(isTimerActive(timer) == false)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
(!isTimerActive(timer))
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
servos[this->servoIndex].Pin.isActive = false;
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
servo_info[this->servoIndex].Pin.isActive = false;
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// ensure channel is valid
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// convert to ticks after compensating for interrupt overhead - 12 Aug 2009
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// convert to ticks after compensating for interrupt overhead
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
uint8_t oldSREG = SREG;
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
servo_info[channel].ticks = value;
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
cli();
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
servos[channel].ticks = value;
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
SREG = oldSREG;
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// ensure channel is valid
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// ensure channel is valid
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// return the value as degrees
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// return the value as degrees
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
unsigned int pulsewidth;
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
return (this->servoIndex == INVALID_SERVO) ? 0 : ticksToUs(servo_info[this->servoIndex].ticks) + TRIM_DURATION;
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
if( this->servoIndex != INVALID_SERVO )
    pulsewidth = ticksToUs(servos[this->servoIndex].ticks)  + TRIM_DURATION ;   // 12 aug 2009
  else
    pulsewidth  = 0;
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
return servos[this->servoIndex].Pin.isActive ;
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
return servo_info[this->servoIndex].Pin.isActive;
#endif
++++++
#if defined (upstream)
/*
 Servo.cpp - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2
 Copyright (c) 2009 Michael Margolis.  All right reserved.

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#endif
++++++
#if defined (marlin4Due)
/*
  Copyright (c) 2013 Arduino LLC. All right reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */
#endif
++++++
#if defined (upstream)
/*

 A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.
 The servos are pulsed in the background using the value most recently written using the write() method

 Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
 Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.

 The methods are:

 Servo - Class for manipulating servo motors connected to Arduino pins.

 attach(pin )  - Attaches a servo motor to an i/o pin.
 attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds
 default min is 544, max is 2400

 write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)
 writeMicroseconds() - Sets the servo pulse width in microseconds
 read()      - Gets the last written servo pulse width as an angle between 0 and 180.
 readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)
 attached()  - Returns true if there is a servo attached.
 detach()    - Stops an attached servos from pulsing its i/o pin.

*/
#endif
++++++
#if defined (marlin4Due)
/*

 A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.
 The servos are pulsed in the background using the value most recently written using the write() method

 Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.
 Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.

 The methods are:

 Servo - Class for manipulating servo motors connected to Arduino pins.

 attach(pin )  - Attaches a servo motor to an i/o pin.
 attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds
 default min is 544, max is 2400

 write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)
 writeMicroseconds() - Sets the servo pulse width in microseconds
 move(pin, angle) - Sequence of attach(pin), write(angle).
                    With DEACTIVATE_SERVOS_AFTER_MOVE it waits SERVO_DEACTIVATION_DELAY and detaches.
 read()      - Gets the last written servo pulse width as an angle between 0 and 180.
 readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)
 attached()  - Returns true if there is a servo attached.
 detach()    - Stops an attached servos from pulsing its i/o pin.

 */
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
#include <avr/interrupt.h>
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
#include "Servo.h"
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
#include "servo.h"
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
#define usToTicks(_us)    (( clockCyclesPerMicrosecond()* _us) / 8)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
#define usToTicks(_us)    (( clockCyclesPerMicrosecond() * _us) / 32)
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// converts microseconds to tick (assumes prescale of 8)  // 12 Aug 2009
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// converts microseconds to tick
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
#define ticksToUs(_ticks) (( (unsigned)_ticks * 8)/ clockCyclesPerMicrosecond() )
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
#define ticksToUs(_ticks) (( (unsigned)_ticks * 32)/ clockCyclesPerMicrosecond() )
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// compensation ticks to trim adjust for digitalWrite delays // 12 August 2009
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// compensation ticks to trim adjust for digitalWrite delays
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
//#define NBR_TIMERS        (MAX_SERVOS / SERVOS_PER_TIMER)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
static ServoInfo_t servo_info[MAX_SERVOS];
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
static servo_t servos[MAX_SERVOS];
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// static array of servo info structures
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
// static array of servo structures
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
#define SERVO(_timer,_channel)  (servos[SERVO_INDEX(_timer,_channel)])
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
#define SERVO(_timer,_channel)  (servo_info[SERVO_INDEX(_timer,_channel)])
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)
{
  if( Channel[timer] < 0 )
    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer
  else{
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated
  }

  Channel[timer]++;    // increment to the next channel
  if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;
    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated
      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
  }
  else {
    // finished all channels so wait for the refresh period to expire before starting over
    if( ((unsigned)*TCNTn) + 4 < usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed
      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);
    else
      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed
    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
  }
}
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
//------------------------------------------------------------------------------
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && !defined (WIRING) )
// Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
/// Interrupt handler for the TC0 channel 1.
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && !defined (WIRING) )
// Interrupt handlers for Arduino
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
//------------------------------------------------------------------------------
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer1) && !defined (WIRING) )
SIGNAL (TIMER1_COMPA_vect)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
void Servo_Handler(timer16_Sequence_t timer, Tc *pTc, uint8_t channel);
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer1) && !defined (WIRING) )

  handle_interrupts(_timer1, &TCNT1, &OCR1A);


#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer1) )void HANDLER_FOR_TIMER1(void) {
    Servo_Handler(_timer1, TC_FOR_TIMER1, CHANNEL_FOR_TIMER1);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer3) && !defined (WIRING) )
SIGNAL (TIMER3_COMPA_vect)
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer2) )
void HANDLER_FOR_TIMER2(void) {
    Servo_Handler(_timer2, TC_FOR_TIMER2, CHANNEL_FOR_TIMER2);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer3) && !defined (WIRING) )

  handle_interrupts(_timer3, &TCNT3, &OCR3A);


#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer3) )void HANDLER_FOR_TIMER3(void) {
    Servo_Handler(_timer3, TC_FOR_TIMER3, CHANNEL_FOR_TIMER3);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer4) && !defined (WIRING) )
SIGNAL (TIMER4_COMPA_vect)
#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer4) )
void HANDLER_FOR_TIMER4(void) {
    Servo_Handler(_timer4, TC_FOR_TIMER4, CHANNEL_FOR_TIMER4);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer4) && !defined (WIRING) )

  handle_interrupts(_timer4, &TCNT4, &OCR4A);


#endif
++++++
#if defined (marlin4Due) && (defined (NUM_SERVOS) && defined (_useTimer5) )void HANDLER_FOR_TIMER5(void) {
    Servo_Handler(_timer5, TC_FOR_TIMER5, CHANNEL_FOR_TIMER5);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer5) && !defined (WIRING) )
SIGNAL (TIMER5_COMPA_vect)
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
void Servo_Handler(timer16_Sequence_t timer, Tc *tc, uint8_t channel)
{
    // clear interrupt
    tc->TC_CHANNEL[channel].TC_SR;
    if (Channel[timer] < 0) {
        tc->TC_CHANNEL[channel].TC_CCR |= TC_CCR_SWTRG; // channel set to -1 indicated that refresh interval completed so reset the timer
    } else {
        if (SERVO_INDEX(timer,Channel[timer]) < ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true) {
            digitalWrite(SERVO(timer,Channel[timer]).Pin.nbr, LOW); // pulse this channel low if activated
        }
    }

    Channel[timer]++;    // increment to the next channel
    if( SERVO_INDEX(timer,Channel[timer]) < ServoCount && Channel[timer] < SERVOS_PER_TIMER) {
        tc->TC_CHANNEL[channel].TC_RA = tc->TC_CHANNEL[channel].TC_CV + SERVO(timer,Channel[timer]).ticks;
        if(SERVO(timer,Channel[timer]).Pin.isActive) {    // check if activated
            digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high
        }
    }
    else {
        // finished all channels so wait for the refresh period to expire before starting over
        if( (tc->TC_CHANNEL[channel].TC_CV) + 4 < usToTicks(REFRESH_INTERVAL) ) { // allow a few ticks to ensure the next OCR1A not missed
            tc->TC_CHANNEL[channel].TC_RA = (unsigned int)usToTicks(REFRESH_INTERVAL);
        }
        else {
            tc->TC_CHANNEL[channel].TC_RA = tc->TC_CHANNEL[channel].TC_CV + 4;  // at least REFRESH_INTERVAL has elapsed
        }
        Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel
    }
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer5) && !defined (WIRING) )

  handle_interrupts(_timer5, &TCNT5, &OCR5A);


#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)static void _initISR(Tc *tc, uint32_t channel, uint32_t id, IRQn_Type irqn)
{
    pmc_enable_periph_clk(id);
    TC_Configure(tc, channel,
   TC_CMR_TCCLKS_TIMER_CLOCK3 | // MCK/32
            TC_CMR_WAVE |                // Waveform mode
            TC_CMR_WAVSEL_UP_RC );       // Counter running up and reset when equals to RC

    /* 84MHz, MCK/32, for 1.5ms: 3937 */
    TC_SetRA(tc, channel, 2625); // 1ms

    /* Configure and enable interrupt */
    NVIC_EnableIRQ(irqn);
    // TC_IER_CPAS: RA Compare
    tc->TC_CHANNEL[channel].TC_IER = TC_IER_CPAS;

    // Enables the timer clock and performs a software reset to start the counting
    TC_Start(tc, channel);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined WIRING )
// Interrupt handlers for Wiring
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer1) && defined WIRING )
void Timer1Service()
{
  handle_interrupts(_timer1, &TCNT1, &OCR1A);
}
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && defined(_useTimer3) && defined WIRING )
void Timer3Service()
{
  handle_interrupts(_timer3, &TCNT3, &OCR3A);
}
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
uint8_t Servo::attach(int pin)
{
  return this->attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
}
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
int8_t Servo::attach(int pin) {
  return this->attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);
}
#endif
++++++
#if defined (upstream) && defined (NUM_SERVOS)
uint8_t Servo::attach(int pin, int min, int max)
{
  if(this->servoIndex < MAX_SERVOS ) {
#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
    if (pin > 0) this->pin = pin; else pin = this->pin;
#endif
    pinMode( pin, OUTPUT) ;                                   // set servo pin to output
    servos[this->servoIndex].Pin.nbr = pin;
    // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 < 128
    this->min  = (MIN_PULSE_WIDTH - min)/4; //resolution of min/max is 4 uS
    this->max  = (MAX_PULSE_WIDTH - max)/4;
    // initialize the timer if it has not already been initialized
    timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
    if(isTimerActive(timer) == false)
      initISR(timer);
    servos[this->servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive
  }
  return this->servoIndex ;
}
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
int8_t Servo::attach(int pin, int min, int max) {

  if (this->servoIndex >= MAX_SERVOS) return -1;

  if (pin > 0) servo_info[this->servoIndex].Pin.nbr = pin;
  pinMode(servo_info[this->servoIndex].Pin.nbr, OUTPUT); // set servo pin to output

  // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 < 128
  this->min = (MIN_PULSE_WIDTH - min) / 4; //resolution of min/max is 4 uS
  this->max = (MAX_PULSE_WIDTH - max) / 4;

  // initialize the timer if it has not already been initialized
  timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);
  if (!isTimerActive(timer)) initISR(timer);
  servo_info[this->servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive

  return this->servoIndex;
}
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
// return the value as degrees
#endif
++++++
#if defined (marlin4Due) && defined (NUM_SERVOS)
void Servo::move(int value) {
  if (this->attach(0) >= 0) {
    this->write(value);
    #ifdef DEACTIVATE_SERVOS_AFTER_MOVE
      delay(SERVO_DEACTIVATION_DELAY);
      this->detach();
    #endif
  }
}
#endif
++++++


**--**-**--merge: stepper.cpp

#if defined (upstream)
/*
  stepper.c - stepper motor driver: executes motion plans using stepper motors
  Part of Grbl

  Copyright (c) 2009-2011 Simen Svale Skogsrud

  Grbl is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Grbl is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
*/
#endif
++++++
#if defined (marlin4Due)
/**
 * stepper.cpp - stepper motor driver: executes motion plans using stepper motors
 * Marlin Firmware
 *
 * Derived from Grbl
 * Copyright (c) 2009-2011 Simen Svale Skogsrud
 *
 * Grbl is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Grbl is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
 */
#endif
++++++
#if defined (upstream)
#include "speed_lookuptable.h"
#endif
++++++
#if defined (upstream)
//=============================private variables ============================
#endif
++++++
#if defined (marlin4Due)
//============================= private variables ===========================
#endif
++++++
#if defined (upstream)
//static makes it inpossible to be called from outside of this file by extern.!
#endif
++++++
#if defined (marlin4Due)
//static makes it impossible to be called from outside of this file by extern.!
#endif
++++++
#if defined (upstream)
static unsigned char out_bits;
#endif
++++++
#if defined (marlin4Due)
static unsigned char out_bits = 0;
#endif
++++++
#if defined (upstream)
static long counter_x,       // Counter variables for the bresenham line tracer
            counter_y,
            counter_z,
            counter_e;
#endif
++++++
#if defined (marlin4Due)
static unsigned int cleaning_buffer_counter;
#endif
++++++
#if defined (marlin4Due) && ENABLED(Z_DUAL_ENDSTOPS)
static bool performing_homing = false, 
              locked_z_motor = false, 
              locked_z2_motor = false;
#endif
++++++
#if defined (marlin4Due)
// Counter variables for the Bresenham line tracer
#endif
++++++
#if defined (upstream) && defined (ADVANCE)
static long e_steps[3];
#endif
++++++
#if defined (marlin4Due) && ENABLED(ADVANCE)
static long e_steps[4];
#endif
++++++
#if defined (upstream)
static unsigned short acc_step_rate;
#endif
++++++
#if defined (marlin4Due)
static unsigned long acc_step_rate;
#endif
++++++
#if defined (upstream)
static unsigned short OCR1A_nominal;
#endif
++++++
#if defined (marlin4Due)
static unsigned long OCR1A_nominal;
#endif
++++++
#if defined (upstream)
volatile long endstops_trigsteps[3]={0,0,0};
#endif
++++++
#if defined (marlin4Due)
volatile long endstops_trigsteps[3] = { 0 };
#endif
++++++
#if defined (upstream)
static volatile bool endstop_x_hit=false;
#endif
++++++
#if defined (marlin4Due)
static volatile char endstop_hit_bits = 0;
#endif
++++++
#if defined (upstream)
static volatile bool endstop_y_hit=false;
#endif
++++++
#if defined (marlin4Due)
// use X_MIN, Y_MIN, Z_MIN and Z_PROBE as BIT value
#endif
++++++
#if defined (upstream)
static volatile bool endstop_z_hit=false;
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
static byte
#else
  static uint16_t
#endif
  old_endstop_bits = 0;
#endif
++++++
#if defined (upstream)
static bool old_x_min_endstop=false;
#endif
++++++
#if defined (upstream)
volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
volatile long count_position[NUM_AXIS] = { 0 };
#endif
++++++
#if defined (upstream)
//=============================functions         ============================
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
//================================ functions ================================
#endif
++++++
#if defined (upstream)
#define CHECK_ENDSTOPS  if(check_endstops)
#endif
++++++
#if defined (marlin4Due) && (DISABLED(Z_DUAL_ENDSTOPS) && ENABLED(DUAL_X_CARRIAGE) )
#define X_APPLY_DIR(v,ALWAYS) \
    if (extruder_duplication_enabled || ALWAYS) { \
      X_DIR_WRITE(v); \
      X2_DIR_WRITE(v); \
    } \
    else { \
      if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
    }
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(DUAL_X_CARRIAGE) && DISABLED(Z_DUAL_ENDSTOPS) )
#define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Y_DUAL_STEPPER_DRIVERS) && DISABLED(Z_DUAL_ENDSTOPS) )
#define Y_APPLY_DIR(v,Q) { Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(Y_DUAL_STEPPER_DRIVERS) && DISABLED(Z_DUAL_ENDSTOPS) )
#define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Z_DUAL_STEPPER_DRIVERS) && DISABLED(Z_DUAL_ENDSTOPS) )
#define Z_APPLY_DIR(v,Q) { Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(Z_DUAL_ENDSTOPS) && ENABLED(Z_DUAL_STEPPER_DRIVERS) && DISABLED(Z_DUAL_ENDSTOPS) )
#define Z_APPLY_STEP(v,Q) \
    if (performing_homing) { \
      if (Z_HOME_DIR > 0) {\
        if (!(TEST(old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
        if (!(TEST(old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] > 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
      } else {\
        if (!(TEST(old_endstop_bits, Z_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z_motor) Z_STEP_WRITE(v); \
        if (!(TEST(old_endstop_bits, Z2_MIN) && (count_direction[Z_AXIS] < 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \
      } \
    } else { \
      Z_STEP_WRITE(v); \
      Z2_STEP_WRITE(v); \
    }
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(Z_DUAL_ENDSTOPS) && ENABLED(Z_DUAL_STEPPER_DRIVERS) && DISABLED(Z_DUAL_ENDSTOPS) )
#define Z_APPLY_STEP(v,Q) { Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }
#endif
++++++
#if defined (marlin4Due) && (!ENABLED(Z_DUAL_STEPPER_DRIVERS) && DISABLED(Z_DUAL_ENDSTOPS) )
#define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
#define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)
#endif
++++++
#if defined (upstream)
// uses:
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
#define MultiU16X8toH16(intRes, charIn1, intIn2)   intRes = ((charIn1) * (intIn2)) >> 16
#endif
++++++
#if defined (upstream)
// r26 to store 0
#endif
++++++
#if defined (upstream)
// uses:
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
#define MultiU32X32toH32(intRes, longIn1, longIn2) intRes = ((uint64_t)longIn1 * longIn2 + 0x80000000) >> 32
#endif
++++++
#if defined (upstream)
// r26 to store 0
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
void endstops_hit_on_purpose() {
  endstop_hit_bits = 0;
}
#endif
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
void endstops_hit_on_purpose() {
  endstop_hit_bits = 0;
}
#endif
++++++
#if defined (upstream)
// r27 to store the byte 1 of the 48bit result
#endif
++++++
#if defined (upstream)
void endstops_hit_on_purpose()
{
  endstop_x_hit=false;
  endstop_y_hit=false;
  endstop_z_hit=false;
}
#endif
++++++
#if defined (upstream)
//         __________________________
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
// Check endstops
#endif
++++++
#if defined (upstream)
//        /|                        |\     _________________         ^
#endif
++++++
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
inline void update_endstops() {

  #ifdef Z_DUAL_ENDSTOPS
    uint16_t
  #else
    byte
  #endif
      current_endstop_bits = 0;

  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
  #define _AXIS(AXIS) AXIS ##_AXIS
  #define _ENDSTOP_HIT(AXIS) endstop_hit_bits |= BIT(_ENDSTOP(AXIS, MIN))
  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX

  // SET_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
  #define SET_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
  // COPY_BIT: copy the value of COPY_BIT to BIT in bits
  #define COPY_BIT(bits, COPY_BIT, BIT) SET_BIT(bits, BIT, TEST(bits, COPY_BIT))
  // TEST_ENDSTOP: test the old and the current status of an endstop
  #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP) && TEST(old_endstop_bits, ENDSTOP))

  #define UPDATE_ENDSTOP(AXIS,MINMAX) \
    SET_ENDSTOP_BIT(AXIS, MINMAX); \
    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))  && (current_block->steps[_AXIS(AXIS)] > 0)) { \
      endstops_trigsteps[_AXIS(AXIS)] = count_position[_AXIS(AXIS)]; \
      _ENDSTOP_HIT(AXIS); \
      step_events_completed = current_block->step_event_count; \
    }

  #ifdef COREXY
    // Head direction in -X axis for CoreXY bots.
    // If DeltaX == -DeltaY, the movement is only in Y axis
    if ((current_block->steps[A_AXIS] != current_block->steps[B_AXIS]) || (TEST(out_bits, A_AXIS) == TEST(out_bits, B_AXIS))) {
      if (TEST(out_bits, X_HEAD))
  #elif defined(COREXZ)
    // Head direction in -X axis for CoreXZ bots.
    // If DeltaX == -DeltaZ, the movement is only in Z axis
    if ((current_block->steps[A_AXIS] != current_block->steps[C_AXIS]) || (TEST(out_bits, A_AXIS) == TEST(out_bits, C_AXIS))) {
      if (TEST(out_bits, X_HEAD))
  #else
      if (TEST(out_bits, X_AXIS))   // stepping along -X axis (regular Cartesian bot)
  #endif
      { // -direction
        #ifdef DUAL_X_CARRIAGE
          // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder
          if ((current_block->active_extruder == 0 && X_HOME_DIR == -1) || (current_block->active_extruder != 0 && X2_HOME_DIR == -1))
        #endif
          {
            #if HAS_X_MIN
              UPDATE_ENDSTOP(X, MIN);
            #endif
          }
      }
      else { // +direction
        #ifdef DUAL_X_CARRIAGE
          // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder
          if ((current_block->active_extruder == 0 && X_HOME_DIR == 1) || (current_block->active_extruder != 0 && X2_HOME_DIR == 1))
        #endif
          {
            #if HAS_X_MAX
              UPDATE_ENDSTOP(X, MAX);
            #endif
          }
      }
  #if defined(COREXY) || defined(COREXZ)
    }
  #endif

  #ifdef COREXY
    // Head direction in -Y axis for CoreXY bots.
    // If DeltaX == DeltaY, the movement is only in X axis
    if ((current_block->steps[A_AXIS] != current_block->steps[B_AXIS]) || (TEST(out_bits, A_AXIS) != TEST(out_bits, B_AXIS))) {
      if (TEST(out_bits, Y_HEAD))
  #else
      if (TEST(out_bits, Y_AXIS))   // -direction
  #endif
      { // -direction
        #if HAS_Y_MIN
          UPDATE_ENDSTOP(Y, MIN);
        #endif
      }
      else { // +direction
        #if HAS_Y_MAX
          UPDATE_ENDSTOP(Y, MAX);
        #endif
      }
  #if defined(COREXY)
    }
  #endif

  #ifdef COREXZ
    // Head direction in -Z axis for CoreXZ bots.
    // If DeltaX == DeltaZ, the movement is only in X axis
    if ((current_block->steps[A_AXIS] != current_block->steps[C_AXIS]) || (TEST(out_bits, A_AXIS) != TEST(out_bits, C_AXIS))) {
      if (TEST(out_bits, Z_HEAD))
  #else
      if (TEST(out_bits, Z_AXIS))
  #endif
      { // z -direction
        #if HAS_Z_MIN

          #ifdef Z_DUAL_ENDSTOPS
            SET_ENDSTOP_BIT(Z, MIN);
              #if HAS_Z2_MIN
                SET_ENDSTOP_BIT(Z2, MIN);
              #else
                COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
              #endif

            byte z_test = TEST_ENDSTOP(Z_MIN) << 0 + TEST_ENDSTOP(Z2_MIN) << 1; // bit 0 for Z, bit 1 for Z2

            if (z_test && current_block->steps[Z_AXIS] > 0) { // z_test = Z_MIN || Z2_MIN
              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
              endstop_hit_bits |= BIT(Z_MIN);
              if (!performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
                step_events_completed = current_block->step_event_count;
            }
          #else // !Z_DUAL_ENDSTOPS

            UPDATE_ENDSTOP(Z, MIN);
          #endif // !Z_DUAL_ENDSTOPS
        #endif // Z_MIN_PIN

        #ifdef Z_PROBE_ENDSTOP
          UPDATE_ENDSTOP(Z, PROBE);

          if (TEST_ENDSTOP(Z_PROBE))
          {
            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
            endstop_hit_bits |= BIT(Z_PROBE);
          }
        #endif
      }
      else { // z +direction
        #if HAS_Z_MAX

          #ifdef Z_DUAL_ENDSTOPS

            SET_ENDSTOP_BIT(Z, MAX);
              #if HAS_Z2_MAX
                SET_ENDSTOP_BIT(Z2, MAX);
              #else
                COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX)
              #endif

            byte z_test = TEST_ENDSTOP(Z_MAX) << 0 + TEST_ENDSTOP(Z2_MAX) << 1; // bit 0 for Z, bit 1 for Z2

            if (z_test && current_block->steps[Z_AXIS] > 0) {  // t_test = Z_MAX || Z2_MAX
              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
              endstop_hit_bits |= BIT(Z_MIN);
              if (!performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
                step_events_completed = current_block->step_event_count;
            }

          #else // !Z_DUAL_ENDSTOPS

            UPDATE_ENDSTOP(Z, MAX);

          #endif // !Z_DUAL_ENDSTOPS
        #endif // Z_MAX_PIN

        #ifdef Z_PROBE_ENDSTOP
          UPDATE_ENDSTOP(Z, PROBE);

          if (TEST_ENDSTOP(Z_PROBE))
          {
            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
            endstop_hit_bits |= BIT(Z_PROBE);
          }
        #endif
      }
  #if defined(COREXZ)
    }
  #endif
  old_endstop_bits = current_endstop_bits;
}

//         __________________________
//        /|                        |\     _________________         ^
//       / |                        | \   /|               |\        |
//      /  |                        |  \ / |               | \       s
//     /   |                        |   |  |               |  \      p
//    /    |                        |   |  |               |   \     e
//   +-----+------------------------+---+--+---------------+----+    e
//   |               BLOCK 1            |      BLOCK 2          |    d
//
//                           time ----->
//
//  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
//  first block->accelerate_until step_events_completed, then keeps going at constant speed until
//  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
//  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.

void st_wake_up() {
  //  TCNT1 = 0;
  ENABLE_STEPPER_DRIVER_INTERRUPT();
}

FORCE_INLINE unsigned long calc_timer(unsigned long step_rate) {
  unsigned long timer;
  if (step_rate > MAX_STEP_FREQUENCY) step_rate = MAX_STEP_FREQUENCY;

  #if defined(ENABLE_HIGH_SPEED_STEPPING)
    if(step_rate > (2 * DOUBLE_STEP_FREQUENCY)) { // If steprate > 2*DOUBLE_STEP_FREQUENCY >> step 4 times
      step_rate = (step_rate >> 2);
      step_loops = 4;
    }
    else if(step_rate > DOUBLE_STEP_FREQUENCY) { // If steprate > DOUBLE_STEP_FREQUENCY >> step 2 times
      step_rate = (step_rate >> 1);
      step_loops = 2;
    }
    else
  #endif
  {
    step_loops = 1;
  }

  timer = HAL_TIMER_RATE / step_rate;
  
  return timer;
}

/**
 * Set the stepper direction of each axis
 *
 *   X_AXIS=A_AXIS and Y_AXIS=B_AXIS for COREXY
 *   X_AXIS=A_AXIS and Z_AXIS=C_AXIS for COREXZ
 */
void set_stepper_direction() {

  if (TEST(out_bits, X_AXIS)) { // A_AXIS
    X_APPLY_DIR(INVERT_X_DIR, 0);
    count_direction[X_AXIS] = -1;
  }
  else {
    X_APPLY_DIR(!INVERT_X_DIR, 0);
    count_direction[X_AXIS] = 1;
  }

  if (TEST(out_bits, Y_AXIS)) { // B_AXIS
    Y_APPLY_DIR(INVERT_Y_DIR, 0);
    count_direction[Y_AXIS] = -1;
  }
  else {
    Y_APPLY_DIR(!INVERT_Y_DIR, 0);
    count_direction[Y_AXIS] = 1;
  }
  
  if (TEST(out_bits, Z_AXIS)) { // C_AXIS
    Z_APPLY_DIR(INVERT_Z_DIR, 0);
    count_direction[Z_AXIS] = -1;
  }
  else {
    Z_APPLY_DIR(!INVERT_Z_DIR, 0);
    count_direction[Z_AXIS] = 1;
  }
  
  #if DISABLED(ADVANCE)
    if (TEST(out_bits, E_AXIS)) {
      REV_E_DIR();
      count_direction[E_AXIS] = -1;
    }
    else {
      NORM_E_DIR();
      count_direction[E_AXIS] = 1;
    }
  #endif //!ADVANCE
}

// Initializes the trapezoid generator from the current block. Called whenever a new
// block begins.

TcChannel *stepperChannel = (STEP_TIMER_COUNTER->TC_CHANNEL + STEP_TIMER_CHANNEL);

FORCE_INLINE
void HAL_timer_stepper_count(uint32_t count) {

  uint32_t counter_value = stepperChannel->TC_CV + 42;  // we need time for other stuff!
  //if(count < 105) count = 105;
  stepperChannel->TC_RC = (counter_value <= count) ? count : counter_value;
}

FORCE_INLINE void trapezoid_generator_reset() {

  if (current_block->direction_bits != out_bits) {
    out_bits = current_block->direction_bits;
    set_stepper_direction();
  }
  
  #if ENABLED(ADVANCE)
    advance = current_block->initial_advance;
    final_advance = current_block->final_advance;
    // Do E steps + advance steps
    e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
    old_advance = advance >>8;
  #endif
  deceleration_time = 0;
  // step_rate to timer interval
  OCR1A_nominal = calc_timer(current_block->nominal_rate);
  // make a note of the number of step loops required at nominal speed
  step_loops_nominal = step_loops;
  acc_step_rate = current_block->initial_rate;
  acceleration_time = calc_timer(acc_step_rate);
  //HAL_timer_stepper_count(acceleration_time);

  // SERIAL_ECHO_START;
  // SERIAL_ECHOPGM("advance :");
  // SERIAL_ECHO(current_block->advance/256.0);
  // SERIAL_ECHOPGM("advance rate :");
  // SERIAL_ECHO(current_block->advance_rate/256.0);
  // SERIAL_ECHOPGM("initial advance :");
  // SERIAL_ECHO(current_block->initial_advance/256.0);
  // SERIAL_ECHOPGM("final advance :");
  // SERIAL_ECHOLN(current_block->final_advance/256.0);
}

// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.
// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.

HAL_STEP_TIMER_ISR {

  //STEP_TIMER_COUNTER->TC_CHANNEL[STEP_TIMER_CHANNEL].TC_SR;
  stepperChannel->TC_SR;
  //stepperChannel->TC_RC = 1000000;

  if (cleaning_buffer_counter)
  {
    current_block = NULL;
    plan_discard_current_block();
    #ifdef SD_FINISHED_RELEASECOMMAND
      if ((cleaning_buffer_counter == 1) && (SD_FINISHED_STEPPERRELEASE)) enqueuecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
    #endif
    cleaning_buffer_counter--;
    HAL_timer_stepper_count(HAL_TIMER_RATE / 200); //5ms wait
    return;
  }

  // If there is no current block, attempt to pop one from the buffer
  if (!current_block) {
    // Anything in the buffer?
    current_block = plan_get_current_block();
    if (current_block) {
      current_block->busy = true;
      trapezoid_generator_reset();
      counter_x = -(current_block->step_event_count >> 1);
      counter_y = counter_z = counter_e = counter_x;
      step_events_completed = 0;

      #if ENABLED(Z_LATE_ENABLE)
        if (current_block->steps[Z_AXIS] > 0) {
          enable_z();
          HAL_timer_set_count (STEP_TIMER_COUNTER, STEP_TIMER_CHANNEL, HAL_TIMER_RATE / 1000); //1ms wait
          return;
        }
      #endif

      // #if ENABLED(ADVANCE)
      //   e_steps[current_block->active_extruder] = 0;
      // #endif
    }
    else {
        HAL_timer_stepper_count(HAL_TIMER_RATE / 1000); // 1kHz
    }
  }

  if (current_block != NULL) {

	// Update endstops state, if enabled
	  if (check_endstops) update_endstops();

	#define _COUNTER(axis) counter_## axis
	#define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
	#define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN

	#define STEP_START(axis, AXIS) \
	  _COUNTER(axis) += current_block->steps[_AXIS(AXIS)]; \
	  if (_COUNTER(axis) > 0) { \
		_APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); \
		_COUNTER(axis) -= current_block->step_event_count; \
		count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; }

	#define STEP_END(axis, AXIS) _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0)

    #if defined(ENABLE_HIGH_SPEED_STEPPING)
      // Take multiple steps per interrupt (For high speed moves)
      for (int8_t i = 0; i < step_loops; i++) {

        #ifdef ADVANCE
          counter_e += current_block->steps[E_AXIS];
          if (counter_e > 0) {
            counter_e -= current_block->step_event_count;
            e_steps[current_block->active_extruder] += TEST(out_bits, E_AXIS) ? -1 : 1;
          }
        #endif //ADVANCE

        STEP_START(x,X);
        STEP_START(y,Y);
        STEP_START(z,Z);
        #ifndef ADVANCE
          STEP_START(e,E);
        #endif

        STEP_END(x, X);
        STEP_END(y, Y);
        STEP_END(z, Z);
        #ifndef ADVANCE
          STEP_END(e, E);
        #endif

        step_events_completed++;
        if (step_events_completed >= current_block->step_event_count) break;
      }
    #else
      STEP_START(x,X);
      STEP_START(y,Y);
      STEP_START(z,Z);
      #ifndef ADVANCE
        STEP_START(e,E);
      #endif
      step_events_completed++;
    #endif
    // Calculate new timer value
    unsigned long timer;
    unsigned long step_rate;
    if (step_events_completed <= (unsigned long)current_block->accelerate_until) {

      MultiU32X32toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
      acc_step_rate += current_block->initial_rate;

      // upper limit
      if (acc_step_rate > current_block->nominal_rate)
        acc_step_rate = current_block->nominal_rate;

      // step_rate to timer interval
      timer = calc_timer(acc_step_rate);
      acceleration_time += timer;
      #if ENABLED(ADVANCE)
        for(int8_t i=0; i < step_loops; i++) {
          advance += advance_rate;
        }
        //if (advance > current_block->advance) advance = current_block->advance;
        // Do E steps + advance steps
        e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
        old_advance = advance >>8;

      #endif
    }
    else if (step_events_completed > (unsigned long)current_block->decelerate_after) {
      
      MultiU32X32toH32(step_rate, deceleration_time, current_block->acceleration_rate);

      if (step_rate > acc_step_rate) { // Check step_rate stays positive
        step_rate = current_block->final_rate;
      }
      else {
        step_rate = acc_step_rate - step_rate; // Decelerate from aceleration end point.
      }

      // lower limit
      if (step_rate < current_block->final_rate)
        step_rate = current_block->final_rate;

      // step_rate to timer interval
      timer = calc_timer(step_rate);
      deceleration_time += timer;
      #if ENABLED(ADVANCE)
        for(int8_t i=0; i < step_loops; i++) {
          advance -= advance_rate;
        }
        if (advance < final_advance) advance = final_advance;
        // Do E steps + advance steps
        e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
        old_advance = advance >>8;
      #endif //ADVANCE
    }
    else {
      timer = OCR1A_nominal;
      // ensure we're running at the correct step rate, even if we just came off an acceleration
      step_loops = step_loops_nominal;
    }
    #if !defined(ENABLE_HIGH_SPEED_STEPPING)
      STEP_END(x, X);
      STEP_END(y, Y);
      STEP_END(z, Z);
      #ifndef ADVANCE
        STEP_END(e, E);
      #endif
    #endif

    HAL_timer_stepper_count(timer);

    // If current block is finished, reset pointer
    if (step_events_completed >= current_block->step_event_count) {
      current_block = NULL;
      plan_discard_current_block();
    }
  } // current_block != NULL
}

#if ENABLED(ADVANCE)
  unsigned char old_OCR0A;
  // Timer interrupt for E. e_steps is set in the main routine;
  // Timer 0 is shared with millies
  ISR(TIMER0_COMPA_vect)
  {
    old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)
    OCR0A = old_OCR0A;
    // Set E direction (Depends on E direction + advance)
    for(unsigned char i=0; i<4;i++) {
      if (e_steps[0] != 0) {
        E0_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[0] < 0) {
          E0_DIR_WRITE(INVERT_E0_DIR);
          e_steps[0]++;
          E0_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[0] > 0) {
          E0_DIR_WRITE(!INVERT_E0_DIR);
          e_steps[0]--;
          E0_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #if EXTRUDERS > 1
      if (e_steps[1] != 0) {
        E1_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[1] < 0) {
          E1_DIR_WRITE(INVERT_E1_DIR);
          e_steps[1]++;
          E1_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[1] > 0) {
          E1_DIR_WRITE(!INVERT_E1_DIR);
          e_steps[1]--;
          E1_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #endif
 #if EXTRUDERS > 2
      if (e_steps[2] != 0) {
        E2_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[2] < 0) {
          E2_DIR_WRITE(INVERT_E2_DIR);
          e_steps[2]++;
          E2_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[2] > 0) {
          E2_DIR_WRITE(!INVERT_E2_DIR);
          e_steps[2]--;
          E2_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #endif
 #if EXTRUDERS > 3
      if (e_steps[3] != 0) {
        E3_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[3] < 0) {
          E3_DIR_WRITE(INVERT_E3_DIR);
          e_steps[3]++;
          E3_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[3] > 0) {
          E3_DIR_WRITE(!INVERT_E3_DIR);
          e_steps[3]--;
          E3_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #endif

    }
  }
#endif // ADVANCE

void st_init() {
  digipot_init(); //Initialize Digipot Motor Current
  microstep_init(); //Initialize Microstepping Pins

  // initialise TMC Steppers
  #if ENABLED(HAVE_TMCDRIVER)
    tmc_init();
  #endif
    // initialise L6470 Steppers
  #if ENABLED(HAVE_L6470DRIVER)
    L6470_init();
  #endif

  // Initialize Dir Pins
  #if HAS_X_DIR
    X_DIR_INIT;
  #endif
  #if HAS_X2_DIR
    X2_DIR_INIT;
  #endif
  #if HAS_Y_DIR
    Y_DIR_INIT;
    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
      Y2_DIR_INIT;
    #endif
  #endif
  #if HAS_Z_DIR
    Z_DIR_INIT;
    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR
      Z2_DIR_INIT;
    #endif
  #endif
  #if HAS_E0_DIR
    E0_DIR_INIT;
  #endif
  #if HAS_E1_DIR
    E1_DIR_INIT;
  #endif
  #if HAS_E2_DIR
    E2_DIR_INIT;
  #endif
  #if HAS_E3_DIR
    E3_DIR_INIT;
  #endif

  //Initialize Enable Pins - steppers default to disabled.

  #if HAS_X_ENABLE
    X_ENABLE_INIT;
    if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_X2_ENABLE
    X2_ENABLE_INIT;
    if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_Y_ENABLE
    Y_ENABLE_INIT;
    if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);

  #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
    Y2_ENABLE_INIT;
    if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
  #endif
  #endif
  #if HAS_Z_ENABLE
    Z_ENABLE_INIT;
    if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);

    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE
      Z2_ENABLE_INIT;
      if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
    #endif
  #endif
  #if HAS_E0_ENABLE
    E0_ENABLE_INIT;
    if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_E1_ENABLE
    E1_ENABLE_INIT;
    if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_E2_ENABLE
    E2_ENABLE_INIT;
    if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_E3_ENABLE
    E3_ENABLE_INIT;
    if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
  #endif

  //endstops and pullups

  #if HAS_X_MIN
    SET_INPUT(X_MIN_PIN);
    #ifdef ENDSTOPPULLUP_XMIN
      PULLUP(X_MIN_PIN,HIGH);
    #endif
  #endif

  #if HAS_Y_MIN
    SET_INPUT(Y_MIN_PIN);
    #ifdef ENDSTOPPULLUP_YMIN
      PULLUP(Y_MIN_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z_MIN
    SET_INPUT(Z_MIN_PIN);
    #ifdef ENDSTOPPULLUP_ZMIN
      PULLUP(Z_MIN_PIN,HIGH);
    #endif
  #endif

  #if HAS_X_MAX
    SET_INPUT(X_MAX_PIN);
    #ifdef ENDSTOPPULLUP_XMAX
      PULLUP(X_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Y_MAX
    SET_INPUT(Y_MAX_PIN);
    #ifdef ENDSTOPPULLUP_YMAX
      PULLUP(Y_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z_MAX
    SET_INPUT(Z_MAX_PIN);
    #ifdef ENDSTOPPULLUP_ZMAX
      PULLUP(Z_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z2_MAX
    SET_INPUT(Z2_MAX_PIN);
    #ifdef ENDSTOPPULLUP_ZMAX
      PULLUP(Z2_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z_PROBE && ENABLED(Z_PROBE_ENDSTOP) // Check for Z_PROBE_ENDSTOP so we don't pull a pin high unless it's to be used.
    SET_INPUT(Z_PROBE_PIN);
    #ifdef ENDSTOPPULLUP_ZPROBE
    PULLUP(Z_PROBE_PIN,HIGH);
    #endif
  #endif

  #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
  #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
  #define _DISABLE(axis) disable_## axis()

  #define AXIS_INIT(axis, AXIS, PIN) \
    _STEP_INIT(AXIS); \
    _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
    _DISABLE(axis)

  #define E_AXIS_INIT(NUM) AXIS_INIT(e## NUM, E## NUM, E)

  // Initialize Step Pins
  #if HAS_X_STEP
    AXIS_INIT(x, X, X);
  #endif
  #if HAS_X2_STEP
    AXIS_INIT(x, X2, X);
  #endif
  #if HAS_Y_STEP
    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_STEP
      Y2_STEP_INIT;
      Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
    #endif
    AXIS_INIT(y, Y, Y);
  #endif
  #if HAS_Z_STEP
    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_STEP
      Z2_STEP_INIT;
      Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
    #endif
    AXIS_INIT(z, Z, Z);
  #endif
  #if HAS_E0_STEP
    E_AXIS_INIT(0);
  #endif
  #if HAS_E1_STEP
    E_AXIS_INIT(1);
  #endif
  #if HAS_E2_STEP
    E_AXIS_INIT(2);
  #endif
  #if HAS_E3_STEP
    E_AXIS_INIT(3);
  #endif

  HAL_step_timer_start();
  ENABLE_STEPPER_DRIVER_INTERRUPT();

  #if 0 // old AVR-stuff; needs rework
  #ifdef ADVANCE
    #if defined(TCCR0A) && defined(WGM01)
      TCCR0A &= ~BIT(WGM01);
      TCCR0A &= ~BIT(WGM00);
    #endif
    e_steps[0] = e_steps[1] = e_steps[2] = e_steps[3] = 0;
    TIMSK0 |= BIT(OCIE0A);
  #endif //ADVANCE
  #endif

  enable_endstops(true); // Start with endstops active. After homing they can be disabled
  sei();
  
  set_stepper_direction(); // Init directions to out_bits = 0
}


/**
 * Block until all buffered steps are executed
 */
void st_synchronize() { while (blocks_queued()) idle(); }

void st_set_position(const long &x, const long &y, const long &z, const long &e) {
  CRITICAL_SECTION_START;
  count_position[X_AXIS] = x;
  count_position[Y_AXIS] = y;
  count_position[Z_AXIS] = z;
  count_position[E_AXIS] = e;
  CRITICAL_SECTION_END;
}

void st_set_e_position(const long &e) {
  CRITICAL_SECTION_START;
  count_position[E_AXIS] = e;
  CRITICAL_SECTION_END;
}

long st_get_position(uint8_t axis) {
  long count_pos;
  CRITICAL_SECTION_START;
  count_pos = count_position[axis];
  CRITICAL_SECTION_END;
  return count_pos;
}

float st_get_position_mm(AxisEnum axis) { return st_get_position(axis) / axis_steps_per_unit[axis]; }

void finishAndDisableSteppers() {
  st_synchronize();
  disable_all_steppers();
}

void quickStop() {
  cleaning_buffer_counter = 5000;
  DISABLE_STEPPER_DRIVER_INTERRUPT();
  while (blocks_queued()) plan_discard_current_block();
  current_block = NULL;
  ENABLE_STEPPER_DRIVER_INTERRUPT();
}

#if ENABLED(BABYSTEPPING)

  // MUST ONLY BE CALLED BY AN ISR,
  // No other ISR should ever interrupt this!
  void babystep(const uint8_t axis, const bool direction) {

    #define _ENABLE(axis) enable_## axis()
    #define _READ_DIR(AXIS) AXIS ##_DIR_READ
    #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
    #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)

    #define BABYSTEP_AXIS(axis, AXIS, INVERT) { \
        _ENABLE(axis); \
        uint8_t old_pin = _READ_DIR(AXIS); \
        _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \
        _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
        delayMicroseconds(2); \
        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true); \
        _APPLY_DIR(AXIS, old_pin); \
      }

    switch(axis) {

      case X_AXIS:
        BABYSTEP_AXIS(x, X, false);
        break;

      case Y_AXIS:
        BABYSTEP_AXIS(y, Y, false);
        break;
 
      case Z_AXIS: {

        #if DISABLED(DELTA)

          BABYSTEP_AXIS(z, Z, BABYSTEP_INVERT_Z);

        #else // DELTA

          bool z_direction = direction ^ BABYSTEP_INVERT_Z;

          enable_x();
          enable_y();
          enable_z();
          uint8_t old_x_dir_pin = X_DIR_READ,
                  old_y_dir_pin = Y_DIR_READ,
                  old_z_dir_pin = Z_DIR_READ;
          //setup new step
          X_DIR_WRITE(INVERT_X_DIR^z_direction);
          Y_DIR_WRITE(INVERT_Y_DIR^z_direction);
          Z_DIR_WRITE(INVERT_Z_DIR^z_direction);
          //perform step 
          X_STEP_WRITE(!INVERT_X_STEP_PIN);
          Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
          Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
          _delay_us(1U);
          X_STEP_WRITE(INVERT_X_STEP_PIN); 
          Y_STEP_WRITE(INVERT_Y_STEP_PIN); 
          Z_STEP_WRITE(INVERT_Z_STEP_PIN);
          //get old pin state back.
          X_DIR_WRITE(old_x_dir_pin);
          Y_DIR_WRITE(old_y_dir_pin);
          Z_DIR_WRITE(old_z_dir_pin);

        #endif

      } break;
 
      default: break;
    }
  }

#endif //BABYSTEPPING

// From Arduino DigitalPotControl example
void digitalPotWrite(int address, int value) {
  #if HAS_DIGIPOTSS
    digitalWrite(DIGIPOTSS_PIN,LOW); // take the SS pin low to select the chip
    SPI.transfer(address); //  send in the address and value via SPI:
    SPI.transfer(value);
    digitalWrite(DIGIPOTSS_PIN,HIGH); // take the SS pin high to de-select the chip:
    //delay(10);
  #endif
}

// Initialize Digipot Motor Current
void digipot_init() {
  #if HAS_DIGIPOTSS
    const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;

    SPI.begin();
    pinMode(DIGIPOTSS_PIN, OUTPUT);
    for (int i = 0; i <= 4; i++) {
      //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
      digipot_current(i,digipot_motor_current[i]);
    }
  #endif
  #ifdef MOTOR_CURRENT_PWM_XY_PIN
    pinMode(MOTOR_CURRENT_PWM_XY_PIN, OUTPUT);
    pinMode(MOTOR_CURRENT_PWM_Z_PIN, OUTPUT);
    pinMode(MOTOR_CURRENT_PWM_E_PIN, OUTPUT);
    digipot_current(0, motor_current_setting[0]);
    digipot_current(1, motor_current_setting[1]);
    digipot_current(2, motor_current_setting[2]);
    //Set timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
    TCCR5B = (TCCR5B & ~(_BV(CS50) | _BV(CS51) | _BV(CS52))) | _BV(CS50);
  #endif
}

void digipot_current(uint8_t driver, int current) {
  #if HAS_DIGIPOTSS
    const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
    digitalPotWrite(digipot_ch[driver], current);
  #endif
  #ifdef MOTOR_CURRENT_PWM_XY_PIN
    switch(driver) {
      case 0: analogWrite(MOTOR_CURRENT_PWM_XY_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;
      case 1: analogWrite(MOTOR_CURRENT_PWM_Z_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;
      case 2: analogWrite(MOTOR_CURRENT_PWM_E_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;
    }
  #endif
}

void microstep_init() {
  #if HAS_MICROSTEPS_E1
    pinMode(E1_MS1_PIN,OUTPUT);
    pinMode(E1_MS2_PIN,OUTPUT);
  #endif

  #if HAS_MICROSTEPS
    pinMode(X_MS1_PIN,OUTPUT);
    pinMode(X_MS2_PIN,OUTPUT);
    pinMode(Y_MS1_PIN,OUTPUT);
    pinMode(Y_MS2_PIN,OUTPUT);
    pinMode(Z_MS1_PIN,OUTPUT);
    pinMode(Z_MS2_PIN,OUTPUT);
    pinMode(E0_MS1_PIN,OUTPUT);
    pinMode(E0_MS2_PIN,OUTPUT);
    const uint8_t microstep_modes[] = MICROSTEP_MODES;
    for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
      microstep_mode(i, microstep_modes[i]);
  #endif
}

void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2) {
  if (ms1 >= 0) switch(driver) {
    case 0: digitalWrite(X_MS1_PIN, ms1); break;
    case 1: digitalWrite(Y_MS1_PIN, ms1); break;
    case 2: digitalWrite(Z_MS1_PIN, ms1); break;
    case 3: digitalWrite(E0_MS1_PIN, ms1); break;
    #if HAS_MICROSTEPS_E1
      case 4: digitalWrite(E1_MS1_PIN, ms1); break;
    #endif
  }
  if (ms2 >= 0) switch(driver) {
    case 0: digitalWrite(X_MS2_PIN, ms2); break;
    case 1: digitalWrite(Y_MS2_PIN, ms2); break;
    case 2: digitalWrite(Z_MS2_PIN, ms2); break;
    case 3: digitalWrite(E0_MS2_PIN, ms2); break;
    #if PIN_EXISTS(E1_MS2)
      case 4: digitalWrite(E1_MS2_PIN, ms2); break;
    #endif
  }
}

void microstep_mode(uint8_t driver, uint8_t stepping_mode) {
  switch(stepping_mode) {
    case 1: microstep_ms(driver,MICROSTEP1); break;
    case 2: microstep_ms(driver,MICROSTEP2); break;
    case 4: microstep_ms(driver,MICROSTEP4); break;
    case 8: microstep_ms(driver,MICROSTEP8); break;
    case 16: microstep_ms(driver,MICROSTEP16); break;
  }
}

void microstep_readings() {
  SERIAL_PROTOCOLPGM("MS1,MS2 Pins\n");
  SERIAL_PROTOCOLPGM("X: ");
  SERIAL_PROTOCOL(digitalRead(X_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(X_MS2_PIN));
  SERIAL_PROTOCOLPGM("Y: ");
  SERIAL_PROTOCOL(digitalRead(Y_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(Y_MS2_PIN));
  SERIAL_PROTOCOLPGM("Z: ");
  SERIAL_PROTOCOL(digitalRead(Z_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(Z_MS2_PIN));
  SERIAL_PROTOCOLPGM("E0: ");
  SERIAL_PROTOCOL(digitalRead(E0_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(E0_MS2_PIN));
  #if HAS_MICROSTEPS_E1
    SERIAL_PROTOCOLPGM("E1: ");
    SERIAL_PROTOCOL(digitalRead(E1_MS1_PIN));
    SERIAL_PROTOCOLLN(digitalRead(E1_MS2_PIN));
  #endif
}

#if ENABLED(Z_DUAL_ENDSTOPS)
  void In_Homing_Process(bool state) { performing_homing = state; }
  void Lock_z_motor(bool state) { locked_z_motor = state; }
  void Lock_z2_motor(bool state) { locked_z2_motor = state; }
#endif
#if defined (marlin4Due) && DISABLED(Z_DUAL_ENDSTOPS)
inline void update_endstops() {

  #ifdef Z_DUAL_ENDSTOPS
    uint16_t
  #else
    byte
  #endif
      current_endstop_bits = 0;

  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
  #define _AXIS(AXIS) AXIS ##_AXIS
  #define _ENDSTOP_HIT(AXIS) endstop_hit_bits |= BIT(_ENDSTOP(AXIS, MIN))
  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX

  // SET_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
  #define SET_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
  // COPY_BIT: copy the value of COPY_BIT to BIT in bits
  #define COPY_BIT(bits, COPY_BIT, BIT) SET_BIT(bits, BIT, TEST(bits, COPY_BIT))
  // TEST_ENDSTOP: test the old and the current status of an endstop
  #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP) && TEST(old_endstop_bits, ENDSTOP))

  #define UPDATE_ENDSTOP(AXIS,MINMAX) \
    SET_ENDSTOP_BIT(AXIS, MINMAX); \
    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))  && (current_block->steps[_AXIS(AXIS)] > 0)) { \
      endstops_trigsteps[_AXIS(AXIS)] = count_position[_AXIS(AXIS)]; \
      _ENDSTOP_HIT(AXIS); \
      step_events_completed = current_block->step_event_count; \
    }

  #ifdef COREXY
    // Head direction in -X axis for CoreXY bots.
    // If DeltaX == -DeltaY, the movement is only in Y axis
    if ((current_block->steps[A_AXIS] != current_block->steps[B_AXIS]) || (TEST(out_bits, A_AXIS) == TEST(out_bits, B_AXIS))) {
      if (TEST(out_bits, X_HEAD))
  #elif defined(COREXZ)
    // Head direction in -X axis for CoreXZ bots.
    // If DeltaX == -DeltaZ, the movement is only in Z axis
    if ((current_block->steps[A_AXIS] != current_block->steps[C_AXIS]) || (TEST(out_bits, A_AXIS) == TEST(out_bits, C_AXIS))) {
      if (TEST(out_bits, X_HEAD))
  #else
      if (TEST(out_bits, X_AXIS))   // stepping along -X axis (regular Cartesian bot)
  #endif
      { // -direction
        #ifdef DUAL_X_CARRIAGE
          // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder
          if ((current_block->active_extruder == 0 && X_HOME_DIR == -1) || (current_block->active_extruder != 0 && X2_HOME_DIR == -1))
        #endif
          {
            #if HAS_X_MIN
              UPDATE_ENDSTOP(X, MIN);
            #endif
          }
      }
      else { // +direction
        #ifdef DUAL_X_CARRIAGE
          // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder
          if ((current_block->active_extruder == 0 && X_HOME_DIR == 1) || (current_block->active_extruder != 0 && X2_HOME_DIR == 1))
        #endif
          {
            #if HAS_X_MAX
              UPDATE_ENDSTOP(X, MAX);
            #endif
          }
      }
  #if defined(COREXY) || defined(COREXZ)
    }
  #endif

  #ifdef COREXY
    // Head direction in -Y axis for CoreXY bots.
    // If DeltaX == DeltaY, the movement is only in X axis
    if ((current_block->steps[A_AXIS] != current_block->steps[B_AXIS]) || (TEST(out_bits, A_AXIS) != TEST(out_bits, B_AXIS))) {
      if (TEST(out_bits, Y_HEAD))
  #else
      if (TEST(out_bits, Y_AXIS))   // -direction
  #endif
      { // -direction
        #if HAS_Y_MIN
          UPDATE_ENDSTOP(Y, MIN);
        #endif
      }
      else { // +direction
        #if HAS_Y_MAX
          UPDATE_ENDSTOP(Y, MAX);
        #endif
      }
  #if defined(COREXY)
    }
  #endif

  #ifdef COREXZ
    // Head direction in -Z axis for CoreXZ bots.
    // If DeltaX == DeltaZ, the movement is only in X axis
    if ((current_block->steps[A_AXIS] != current_block->steps[C_AXIS]) || (TEST(out_bits, A_AXIS) != TEST(out_bits, C_AXIS))) {
      if (TEST(out_bits, Z_HEAD))
  #else
      if (TEST(out_bits, Z_AXIS))
  #endif
      { // z -direction
        #if HAS_Z_MIN

          #ifdef Z_DUAL_ENDSTOPS
            SET_ENDSTOP_BIT(Z, MIN);
              #if HAS_Z2_MIN
                SET_ENDSTOP_BIT(Z2, MIN);
              #else
                COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
              #endif

            byte z_test = TEST_ENDSTOP(Z_MIN) << 0 + TEST_ENDSTOP(Z2_MIN) << 1; // bit 0 for Z, bit 1 for Z2

            if (z_test && current_block->steps[Z_AXIS] > 0) { // z_test = Z_MIN || Z2_MIN
              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
              endstop_hit_bits |= BIT(Z_MIN);
              if (!performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
                step_events_completed = current_block->step_event_count;
            }
          #else // !Z_DUAL_ENDSTOPS

            UPDATE_ENDSTOP(Z, MIN);
          #endif // !Z_DUAL_ENDSTOPS
        #endif // Z_MIN_PIN

        #ifdef Z_PROBE_ENDSTOP
          UPDATE_ENDSTOP(Z, PROBE);

          if (TEST_ENDSTOP(Z_PROBE))
          {
            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
            endstop_hit_bits |= BIT(Z_PROBE);
          }
        #endif
      }
      else { // z +direction
        #if HAS_Z_MAX

          #ifdef Z_DUAL_ENDSTOPS

            SET_ENDSTOP_BIT(Z, MAX);
              #if HAS_Z2_MAX
                SET_ENDSTOP_BIT(Z2, MAX);
              #else
                COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX)
              #endif

            byte z_test = TEST_ENDSTOP(Z_MAX) << 0 + TEST_ENDSTOP(Z2_MAX) << 1; // bit 0 for Z, bit 1 for Z2

            if (z_test && current_block->steps[Z_AXIS] > 0) {  // t_test = Z_MAX || Z2_MAX
              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
              endstop_hit_bits |= BIT(Z_MIN);
              if (!performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
                step_events_completed = current_block->step_event_count;
            }

          #else // !Z_DUAL_ENDSTOPS

            UPDATE_ENDSTOP(Z, MAX);

          #endif // !Z_DUAL_ENDSTOPS
        #endif // Z_MAX_PIN

        #ifdef Z_PROBE_ENDSTOP
          UPDATE_ENDSTOP(Z, PROBE);

          if (TEST_ENDSTOP(Z_PROBE))
          {
            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];
            endstop_hit_bits |= BIT(Z_PROBE);
          }
        #endif
      }
  #if defined(COREXZ)
    }
  #endif
  old_endstop_bits = current_endstop_bits;
}

//         __________________________
//        /|                        |\     _________________         ^
//       / |                        | \   /|               |\        |
//      /  |                        |  \ / |               | \       s
//     /   |                        |   |  |               |  \      p
//    /    |                        |   |  |               |   \     e
//   +-----+------------------------+---+--+---------------+----+    e
//   |               BLOCK 1            |      BLOCK 2          |    d
//
//                           time ----->
//
//  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
//  first block->accelerate_until step_events_completed, then keeps going at constant speed until
//  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
//  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.

void st_wake_up() {
  //  TCNT1 = 0;
  ENABLE_STEPPER_DRIVER_INTERRUPT();
}

FORCE_INLINE unsigned long calc_timer(unsigned long step_rate) {
  unsigned long timer;
  if (step_rate > MAX_STEP_FREQUENCY) step_rate = MAX_STEP_FREQUENCY;

  #if defined(ENABLE_HIGH_SPEED_STEPPING)
    if(step_rate > (2 * DOUBLE_STEP_FREQUENCY)) { // If steprate > 2*DOUBLE_STEP_FREQUENCY >> step 4 times
      step_rate = (step_rate >> 2);
      step_loops = 4;
    }
    else if(step_rate > DOUBLE_STEP_FREQUENCY) { // If steprate > DOUBLE_STEP_FREQUENCY >> step 2 times
      step_rate = (step_rate >> 1);
      step_loops = 2;
    }
    else
  #endif
  {
    step_loops = 1;
  }

  timer = HAL_TIMER_RATE / step_rate;
  
  return timer;
}

/**
 * Set the stepper direction of each axis
 *
 *   X_AXIS=A_AXIS and Y_AXIS=B_AXIS for COREXY
 *   X_AXIS=A_AXIS and Z_AXIS=C_AXIS for COREXZ
 */
void set_stepper_direction() {

  if (TEST(out_bits, X_AXIS)) { // A_AXIS
    X_APPLY_DIR(INVERT_X_DIR, 0);
    count_direction[X_AXIS] = -1;
  }
  else {
    X_APPLY_DIR(!INVERT_X_DIR, 0);
    count_direction[X_AXIS] = 1;
  }

  if (TEST(out_bits, Y_AXIS)) { // B_AXIS
    Y_APPLY_DIR(INVERT_Y_DIR, 0);
    count_direction[Y_AXIS] = -1;
  }
  else {
    Y_APPLY_DIR(!INVERT_Y_DIR, 0);
    count_direction[Y_AXIS] = 1;
  }
  
  if (TEST(out_bits, Z_AXIS)) { // C_AXIS
    Z_APPLY_DIR(INVERT_Z_DIR, 0);
    count_direction[Z_AXIS] = -1;
  }
  else {
    Z_APPLY_DIR(!INVERT_Z_DIR, 0);
    count_direction[Z_AXIS] = 1;
  }
  
  #if DISABLED(ADVANCE)
    if (TEST(out_bits, E_AXIS)) {
      REV_E_DIR();
      count_direction[E_AXIS] = -1;
    }
    else {
      NORM_E_DIR();
      count_direction[E_AXIS] = 1;
    }
  #endif //!ADVANCE
}

// Initializes the trapezoid generator from the current block. Called whenever a new
// block begins.

TcChannel *stepperChannel = (STEP_TIMER_COUNTER->TC_CHANNEL + STEP_TIMER_CHANNEL);

FORCE_INLINE
void HAL_timer_stepper_count(uint32_t count) {

  uint32_t counter_value = stepperChannel->TC_CV + 42;  // we need time for other stuff!
  //if(count < 105) count = 105;
  stepperChannel->TC_RC = (counter_value <= count) ? count : counter_value;
}

FORCE_INLINE void trapezoid_generator_reset() {

  if (current_block->direction_bits != out_bits) {
    out_bits = current_block->direction_bits;
    set_stepper_direction();
  }
  
  #if ENABLED(ADVANCE)
    advance = current_block->initial_advance;
    final_advance = current_block->final_advance;
    // Do E steps + advance steps
    e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
    old_advance = advance >>8;
  #endif
  deceleration_time = 0;
  // step_rate to timer interval
  OCR1A_nominal = calc_timer(current_block->nominal_rate);
  // make a note of the number of step loops required at nominal speed
  step_loops_nominal = step_loops;
  acc_step_rate = current_block->initial_rate;
  acceleration_time = calc_timer(acc_step_rate);
  //HAL_timer_stepper_count(acceleration_time);

  // SERIAL_ECHO_START;
  // SERIAL_ECHOPGM("advance :");
  // SERIAL_ECHO(current_block->advance/256.0);
  // SERIAL_ECHOPGM("advance rate :");
  // SERIAL_ECHO(current_block->advance_rate/256.0);
  // SERIAL_ECHOPGM("initial advance :");
  // SERIAL_ECHO(current_block->initial_advance/256.0);
  // SERIAL_ECHOPGM("final advance :");
  // SERIAL_ECHOLN(current_block->final_advance/256.0);
}

// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.
// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.

HAL_STEP_TIMER_ISR {

  //STEP_TIMER_COUNTER->TC_CHANNEL[STEP_TIMER_CHANNEL].TC_SR;
  stepperChannel->TC_SR;
  //stepperChannel->TC_RC = 1000000;

  if (cleaning_buffer_counter)
  {
    current_block = NULL;
    plan_discard_current_block();
    #ifdef SD_FINISHED_RELEASECOMMAND
      if ((cleaning_buffer_counter == 1) && (SD_FINISHED_STEPPERRELEASE)) enqueuecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
    #endif
    cleaning_buffer_counter--;
    HAL_timer_stepper_count(HAL_TIMER_RATE / 200); //5ms wait
    return;
  }

  // If there is no current block, attempt to pop one from the buffer
  if (!current_block) {
    // Anything in the buffer?
    current_block = plan_get_current_block();
    if (current_block) {
      current_block->busy = true;
      trapezoid_generator_reset();
      counter_x = -(current_block->step_event_count >> 1);
      counter_y = counter_z = counter_e = counter_x;
      step_events_completed = 0;

      #if ENABLED(Z_LATE_ENABLE)
        if (current_block->steps[Z_AXIS] > 0) {
          enable_z();
          HAL_timer_set_count (STEP_TIMER_COUNTER, STEP_TIMER_CHANNEL, HAL_TIMER_RATE / 1000); //1ms wait
          return;
        }
      #endif

      // #if ENABLED(ADVANCE)
      //   e_steps[current_block->active_extruder] = 0;
      // #endif
    }
    else {
        HAL_timer_stepper_count(HAL_TIMER_RATE / 1000); // 1kHz
    }
  }

  if (current_block != NULL) {

	// Update endstops state, if enabled
	  if (check_endstops) update_endstops();

	#define _COUNTER(axis) counter_## axis
	#define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP
	#define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN

	#define STEP_START(axis, AXIS) \
	  _COUNTER(axis) += current_block->steps[_AXIS(AXIS)]; \
	  if (_COUNTER(axis) > 0) { \
		_APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); \
		_COUNTER(axis) -= current_block->step_event_count; \
		count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; }

	#define STEP_END(axis, AXIS) _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0)

    #if defined(ENABLE_HIGH_SPEED_STEPPING)
      // Take multiple steps per interrupt (For high speed moves)
      for (int8_t i = 0; i < step_loops; i++) {

        #ifdef ADVANCE
          counter_e += current_block->steps[E_AXIS];
          if (counter_e > 0) {
            counter_e -= current_block->step_event_count;
            e_steps[current_block->active_extruder] += TEST(out_bits, E_AXIS) ? -1 : 1;
          }
        #endif //ADVANCE

        STEP_START(x,X);
        STEP_START(y,Y);
        STEP_START(z,Z);
        #ifndef ADVANCE
          STEP_START(e,E);
        #endif

        STEP_END(x, X);
        STEP_END(y, Y);
        STEP_END(z, Z);
        #ifndef ADVANCE
          STEP_END(e, E);
        #endif

        step_events_completed++;
        if (step_events_completed >= current_block->step_event_count) break;
      }
    #else
      STEP_START(x,X);
      STEP_START(y,Y);
      STEP_START(z,Z);
      #ifndef ADVANCE
        STEP_START(e,E);
      #endif
      step_events_completed++;
    #endif
    // Calculate new timer value
    unsigned long timer;
    unsigned long step_rate;
    if (step_events_completed <= (unsigned long)current_block->accelerate_until) {

      MultiU32X32toH32(acc_step_rate, acceleration_time, current_block->acceleration_rate);
      acc_step_rate += current_block->initial_rate;

      // upper limit
      if (acc_step_rate > current_block->nominal_rate)
        acc_step_rate = current_block->nominal_rate;

      // step_rate to timer interval
      timer = calc_timer(acc_step_rate);
      acceleration_time += timer;
      #if ENABLED(ADVANCE)
        for(int8_t i=0; i < step_loops; i++) {
          advance += advance_rate;
        }
        //if (advance > current_block->advance) advance = current_block->advance;
        // Do E steps + advance steps
        e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
        old_advance = advance >>8;

      #endif
    }
    else if (step_events_completed > (unsigned long)current_block->decelerate_after) {
      
      MultiU32X32toH32(step_rate, deceleration_time, current_block->acceleration_rate);

      if (step_rate > acc_step_rate) { // Check step_rate stays positive
        step_rate = current_block->final_rate;
      }
      else {
        step_rate = acc_step_rate - step_rate; // Decelerate from aceleration end point.
      }

      // lower limit
      if (step_rate < current_block->final_rate)
        step_rate = current_block->final_rate;

      // step_rate to timer interval
      timer = calc_timer(step_rate);
      deceleration_time += timer;
      #if ENABLED(ADVANCE)
        for(int8_t i=0; i < step_loops; i++) {
          advance -= advance_rate;
        }
        if (advance < final_advance) advance = final_advance;
        // Do E steps + advance steps
        e_steps[current_block->active_extruder] += ((advance >>8) - old_advance);
        old_advance = advance >>8;
      #endif //ADVANCE
    }
    else {
      timer = OCR1A_nominal;
      // ensure we're running at the correct step rate, even if we just came off an acceleration
      step_loops = step_loops_nominal;
    }
    #if !defined(ENABLE_HIGH_SPEED_STEPPING)
      STEP_END(x, X);
      STEP_END(y, Y);
      STEP_END(z, Z);
      #ifndef ADVANCE
        STEP_END(e, E);
      #endif
    #endif

    HAL_timer_stepper_count(timer);

    // If current block is finished, reset pointer
    if (step_events_completed >= current_block->step_event_count) {
      current_block = NULL;
      plan_discard_current_block();
    }
  } // current_block != NULL
}

#if ENABLED(ADVANCE)
  unsigned char old_OCR0A;
  // Timer interrupt for E. e_steps is set in the main routine;
  // Timer 0 is shared with millies
  ISR(TIMER0_COMPA_vect)
  {
    old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)
    OCR0A = old_OCR0A;
    // Set E direction (Depends on E direction + advance)
    for(unsigned char i=0; i<4;i++) {
      if (e_steps[0] != 0) {
        E0_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[0] < 0) {
          E0_DIR_WRITE(INVERT_E0_DIR);
          e_steps[0]++;
          E0_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[0] > 0) {
          E0_DIR_WRITE(!INVERT_E0_DIR);
          e_steps[0]--;
          E0_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #if EXTRUDERS > 1
      if (e_steps[1] != 0) {
        E1_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[1] < 0) {
          E1_DIR_WRITE(INVERT_E1_DIR);
          e_steps[1]++;
          E1_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[1] > 0) {
          E1_DIR_WRITE(!INVERT_E1_DIR);
          e_steps[1]--;
          E1_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #endif
 #if EXTRUDERS > 2
      if (e_steps[2] != 0) {
        E2_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[2] < 0) {
          E2_DIR_WRITE(INVERT_E2_DIR);
          e_steps[2]++;
          E2_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[2] > 0) {
          E2_DIR_WRITE(!INVERT_E2_DIR);
          e_steps[2]--;
          E2_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #endif
 #if EXTRUDERS > 3
      if (e_steps[3] != 0) {
        E3_STEP_WRITE(INVERT_E_STEP_PIN);
        if (e_steps[3] < 0) {
          E3_DIR_WRITE(INVERT_E3_DIR);
          e_steps[3]++;
          E3_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
        else if (e_steps[3] > 0) {
          E3_DIR_WRITE(!INVERT_E3_DIR);
          e_steps[3]--;
          E3_STEP_WRITE(!INVERT_E_STEP_PIN);
        }
      }
 #endif

    }
  }
#endif // ADVANCE

void st_init() {
  digipot_init(); //Initialize Digipot Motor Current
  microstep_init(); //Initialize Microstepping Pins

  // initialise TMC Steppers
  #if ENABLED(HAVE_TMCDRIVER)
    tmc_init();
  #endif
    // initialise L6470 Steppers
  #if ENABLED(HAVE_L6470DRIVER)
    L6470_init();
  #endif

  // Initialize Dir Pins
  #if HAS_X_DIR
    X_DIR_INIT;
  #endif
  #if HAS_X2_DIR
    X2_DIR_INIT;
  #endif
  #if HAS_Y_DIR
    Y_DIR_INIT;
    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
      Y2_DIR_INIT;
    #endif
  #endif
  #if HAS_Z_DIR
    Z_DIR_INIT;
    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR
      Z2_DIR_INIT;
    #endif
  #endif
  #if HAS_E0_DIR
    E0_DIR_INIT;
  #endif
  #if HAS_E1_DIR
    E1_DIR_INIT;
  #endif
  #if HAS_E2_DIR
    E2_DIR_INIT;
  #endif
  #if HAS_E3_DIR
    E3_DIR_INIT;
  #endif

  //Initialize Enable Pins - steppers default to disabled.

  #if HAS_X_ENABLE
    X_ENABLE_INIT;
    if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_X2_ENABLE
    X2_ENABLE_INIT;
    if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_Y_ENABLE
    Y_ENABLE_INIT;
    if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);

  #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
    Y2_ENABLE_INIT;
    if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
  #endif
  #endif
  #if HAS_Z_ENABLE
    Z_ENABLE_INIT;
    if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);

    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE
      Z2_ENABLE_INIT;
      if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
    #endif
  #endif
  #if HAS_E0_ENABLE
    E0_ENABLE_INIT;
    if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_E1_ENABLE
    E1_ENABLE_INIT;
    if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_E2_ENABLE
    E2_ENABLE_INIT;
    if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
  #endif
  #if HAS_E3_ENABLE
    E3_ENABLE_INIT;
    if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
  #endif

  //endstops and pullups

  #if HAS_X_MIN
    SET_INPUT(X_MIN_PIN);
    #ifdef ENDSTOPPULLUP_XMIN
      PULLUP(X_MIN_PIN,HIGH);
    #endif
  #endif

  #if HAS_Y_MIN
    SET_INPUT(Y_MIN_PIN);
    #ifdef ENDSTOPPULLUP_YMIN
      PULLUP(Y_MIN_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z_MIN
    SET_INPUT(Z_MIN_PIN);
    #ifdef ENDSTOPPULLUP_ZMIN
      PULLUP(Z_MIN_PIN,HIGH);
    #endif
  #endif

  #if HAS_X_MAX
    SET_INPUT(X_MAX_PIN);
    #ifdef ENDSTOPPULLUP_XMAX
      PULLUP(X_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Y_MAX
    SET_INPUT(Y_MAX_PIN);
    #ifdef ENDSTOPPULLUP_YMAX
      PULLUP(Y_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z_MAX
    SET_INPUT(Z_MAX_PIN);
    #ifdef ENDSTOPPULLUP_ZMAX
      PULLUP(Z_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z2_MAX
    SET_INPUT(Z2_MAX_PIN);
    #ifdef ENDSTOPPULLUP_ZMAX
      PULLUP(Z2_MAX_PIN,HIGH);
    #endif
  #endif

  #if HAS_Z_PROBE && ENABLED(Z_PROBE_ENDSTOP) // Check for Z_PROBE_ENDSTOP so we don't pull a pin high unless it's to be used.
    SET_INPUT(Z_PROBE_PIN);
    #ifdef ENDSTOPPULLUP_ZPROBE
    PULLUP(Z_PROBE_PIN,HIGH);
    #endif
  #endif

  #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
  #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
  #define _DISABLE(axis) disable_## axis()

  #define AXIS_INIT(axis, AXIS, PIN) \
    _STEP_INIT(AXIS); \
    _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
    _DISABLE(axis)

  #define E_AXIS_INIT(NUM) AXIS_INIT(e## NUM, E## NUM, E)

  // Initialize Step Pins
  #if HAS_X_STEP
    AXIS_INIT(x, X, X);
  #endif
  #if HAS_X2_STEP
    AXIS_INIT(x, X2, X);
  #endif
  #if HAS_Y_STEP
    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_STEP
      Y2_STEP_INIT;
      Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
    #endif
    AXIS_INIT(y, Y, Y);
  #endif
  #if HAS_Z_STEP
    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_STEP
      Z2_STEP_INIT;
      Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
    #endif
    AXIS_INIT(z, Z, Z);
  #endif
  #if HAS_E0_STEP
    E_AXIS_INIT(0);
  #endif
  #if HAS_E1_STEP
    E_AXIS_INIT(1);
  #endif
  #if HAS_E2_STEP
    E_AXIS_INIT(2);
  #endif
  #if HAS_E3_STEP
    E_AXIS_INIT(3);
  #endif

  HAL_step_timer_start();
  ENABLE_STEPPER_DRIVER_INTERRUPT();

  #if 0 // old AVR-stuff; needs rework
  #ifdef ADVANCE
    #if defined(TCCR0A) && defined(WGM01)
      TCCR0A &= ~BIT(WGM01);
      TCCR0A &= ~BIT(WGM00);
    #endif
    e_steps[0] = e_steps[1] = e_steps[2] = e_steps[3] = 0;
    TIMSK0 |= BIT(OCIE0A);
  #endif //ADVANCE
  #endif

  enable_endstops(true); // Start with endstops active. After homing they can be disabled
  sei();
  
  set_stepper_direction(); // Init directions to out_bits = 0
}


/**
 * Block until all buffered steps are executed
 */
void st_synchronize() { while (blocks_queued()) idle(); }

void st_set_position(const long &x, const long &y, const long &z, const long &e) {
  CRITICAL_SECTION_START;
  count_position[X_AXIS] = x;
  count_position[Y_AXIS] = y;
  count_position[Z_AXIS] = z;
  count_position[E_AXIS] = e;
  CRITICAL_SECTION_END;
}

void st_set_e_position(const long &e) {
  CRITICAL_SECTION_START;
  count_position[E_AXIS] = e;
  CRITICAL_SECTION_END;
}

long st_get_position(uint8_t axis) {
  long count_pos;
  CRITICAL_SECTION_START;
  count_pos = count_position[axis];
  CRITICAL_SECTION_END;
  return count_pos;
}

float st_get_position_mm(AxisEnum axis) { return st_get_position(axis) / axis_steps_per_unit[axis]; }

void finishAndDisableSteppers() {
  st_synchronize();
  disable_all_steppers();
}

void quickStop() {
  cleaning_buffer_counter = 5000;
  DISABLE_STEPPER_DRIVER_INTERRUPT();
  while (blocks_queued()) plan_discard_current_block();
  current_block = NULL;
  ENABLE_STEPPER_DRIVER_INTERRUPT();
}

#if ENABLED(BABYSTEPPING)

  // MUST ONLY BE CALLED BY AN ISR,
  // No other ISR should ever interrupt this!
  void babystep(const uint8_t axis, const bool direction) {

    #define _ENABLE(axis) enable_## axis()
    #define _READ_DIR(AXIS) AXIS ##_DIR_READ
    #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
    #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)

    #define BABYSTEP_AXIS(axis, AXIS, INVERT) { \
        _ENABLE(axis); \
        uint8_t old_pin = _READ_DIR(AXIS); \
        _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \
        _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \
        delayMicroseconds(2); \
        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true); \
        _APPLY_DIR(AXIS, old_pin); \
      }

    switch(axis) {

      case X_AXIS:
        BABYSTEP_AXIS(x, X, false);
        break;

      case Y_AXIS:
        BABYSTEP_AXIS(y, Y, false);
        break;
 
      case Z_AXIS: {

        #if DISABLED(DELTA)

          BABYSTEP_AXIS(z, Z, BABYSTEP_INVERT_Z);

        #else // DELTA

          bool z_direction = direction ^ BABYSTEP_INVERT_Z;

          enable_x();
          enable_y();
          enable_z();
          uint8_t old_x_dir_pin = X_DIR_READ,
                  old_y_dir_pin = Y_DIR_READ,
                  old_z_dir_pin = Z_DIR_READ;
          //setup new step
          X_DIR_WRITE(INVERT_X_DIR^z_direction);
          Y_DIR_WRITE(INVERT_Y_DIR^z_direction);
          Z_DIR_WRITE(INVERT_Z_DIR^z_direction);
          //perform step 
          X_STEP_WRITE(!INVERT_X_STEP_PIN);
          Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
          Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
          _delay_us(1U);
          X_STEP_WRITE(INVERT_X_STEP_PIN); 
          Y_STEP_WRITE(INVERT_Y_STEP_PIN); 
          Z_STEP_WRITE(INVERT_Z_STEP_PIN);
          //get old pin state back.
          X_DIR_WRITE(old_x_dir_pin);
          Y_DIR_WRITE(old_y_dir_pin);
          Z_DIR_WRITE(old_z_dir_pin);

        #endif

      } break;
 
      default: break;
    }
  }

#endif //BABYSTEPPING

// From Arduino DigitalPotControl example
void digitalPotWrite(int address, int value) {
  #if HAS_DIGIPOTSS
    digitalWrite(DIGIPOTSS_PIN,LOW); // take the SS pin low to select the chip
    SPI.transfer(address); //  send in the address and value via SPI:
    SPI.transfer(value);
    digitalWrite(DIGIPOTSS_PIN,HIGH); // take the SS pin high to de-select the chip:
    //delay(10);
  #endif
}

// Initialize Digipot Motor Current
void digipot_init() {
  #if HAS_DIGIPOTSS
    const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;

    SPI.begin();
    pinMode(DIGIPOTSS_PIN, OUTPUT);
    for (int i = 0; i <= 4; i++) {
      //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
      digipot_current(i,digipot_motor_current[i]);
    }
  #endif
  #ifdef MOTOR_CURRENT_PWM_XY_PIN
    pinMode(MOTOR_CURRENT_PWM_XY_PIN, OUTPUT);
    pinMode(MOTOR_CURRENT_PWM_Z_PIN, OUTPUT);
    pinMode(MOTOR_CURRENT_PWM_E_PIN, OUTPUT);
    digipot_current(0, motor_current_setting[0]);
    digipot_current(1, motor_current_setting[1]);
    digipot_current(2, motor_current_setting[2]);
    //Set timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
    TCCR5B = (TCCR5B & ~(_BV(CS50) | _BV(CS51) | _BV(CS52))) | _BV(CS50);
  #endif
}

void digipot_current(uint8_t driver, int current) {
  #if HAS_DIGIPOTSS
    const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
    digitalPotWrite(digipot_ch[driver], current);
  #endif
  #ifdef MOTOR_CURRENT_PWM_XY_PIN
    switch(driver) {
      case 0: analogWrite(MOTOR_CURRENT_PWM_XY_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;
      case 1: analogWrite(MOTOR_CURRENT_PWM_Z_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;
      case 2: analogWrite(MOTOR_CURRENT_PWM_E_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;
    }
  #endif
}

void microstep_init() {
  #if HAS_MICROSTEPS_E1
    pinMode(E1_MS1_PIN,OUTPUT);
    pinMode(E1_MS2_PIN,OUTPUT);
  #endif

  #if HAS_MICROSTEPS
    pinMode(X_MS1_PIN,OUTPUT);
    pinMode(X_MS2_PIN,OUTPUT);
    pinMode(Y_MS1_PIN,OUTPUT);
    pinMode(Y_MS2_PIN,OUTPUT);
    pinMode(Z_MS1_PIN,OUTPUT);
    pinMode(Z_MS2_PIN,OUTPUT);
    pinMode(E0_MS1_PIN,OUTPUT);
    pinMode(E0_MS2_PIN,OUTPUT);
    const uint8_t microstep_modes[] = MICROSTEP_MODES;
    for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
      microstep_mode(i, microstep_modes[i]);
  #endif
}

void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2) {
  if (ms1 >= 0) switch(driver) {
    case 0: digitalWrite(X_MS1_PIN, ms1); break;
    case 1: digitalWrite(Y_MS1_PIN, ms1); break;
    case 2: digitalWrite(Z_MS1_PIN, ms1); break;
    case 3: digitalWrite(E0_MS1_PIN, ms1); break;
    #if HAS_MICROSTEPS_E1
      case 4: digitalWrite(E1_MS1_PIN, ms1); break;
    #endif
  }
  if (ms2 >= 0) switch(driver) {
    case 0: digitalWrite(X_MS2_PIN, ms2); break;
    case 1: digitalWrite(Y_MS2_PIN, ms2); break;
    case 2: digitalWrite(Z_MS2_PIN, ms2); break;
    case 3: digitalWrite(E0_MS2_PIN, ms2); break;
    #if PIN_EXISTS(E1_MS2)
      case 4: digitalWrite(E1_MS2_PIN, ms2); break;
    #endif
  }
}

void microstep_mode(uint8_t driver, uint8_t stepping_mode) {
  switch(stepping_mode) {
    case 1: microstep_ms(driver,MICROSTEP1); break;
    case 2: microstep_ms(driver,MICROSTEP2); break;
    case 4: microstep_ms(driver,MICROSTEP4); break;
    case 8: microstep_ms(driver,MICROSTEP8); break;
    case 16: microstep_ms(driver,MICROSTEP16); break;
  }
}

void microstep_readings() {
  SERIAL_PROTOCOLPGM("MS1,MS2 Pins\n");
  SERIAL_PROTOCOLPGM("X: ");
  SERIAL_PROTOCOL(digitalRead(X_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(X_MS2_PIN));
  SERIAL_PROTOCOLPGM("Y: ");
  SERIAL_PROTOCOL(digitalRead(Y_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(Y_MS2_PIN));
  SERIAL_PROTOCOLPGM("Z: ");
  SERIAL_PROTOCOL(digitalRead(Z_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(Z_MS2_PIN));
  SERIAL_PROTOCOLPGM("E0: ");
  SERIAL_PROTOCOL(digitalRead(E0_MS1_PIN));
  SERIAL_PROTOCOLLN(digitalRead(E0_MS2_PIN));
  #if HAS_MICROSTEPS_E1
    SERIAL_PROTOCOLPGM("E1: ");
    SERIAL_PROTOCOL(digitalRead(E1_MS1_PIN));
    SERIAL_PROTOCOLLN(digitalRead(E1_MS2_PIN));
  #endif
}

#if ENABLED(Z_DUAL_ENDSTOPS)
  void In_Homing_Process(bool state) { performing_homing = state; }
  void Lock_z_motor(bool state) { locked_z_motor = state; }
  void Lock_z2_motor(bool state) { locked_z2_motor = state; }
#endif
++++++
#if defined (upstream)
//       / |                        | \   /|               |\        |
#endif
++++++


**--**-**--merge: temperature.cpp



**--**-**--merge: ultralcd.cpp

#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )

              ignore_click = wait_for_unclick = false;
          

#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )ignore_click = wait_for_unclick = false;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )

              current_click = false;
          

#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )current_click = false;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_main_menu);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
lcd_goto_menu(lcd_main_menu, true);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (FILAMENT_LCD_DISPLAY) && defined (ULTIPANEL) )
message_millis = millis();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(ULTRA_LCD) )
previous_lcd_status_ms = millis();
#endif
++++++
#if defined (upstream) && ((defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && )defined (ULTRA_LCD) )
uint16_t mil = millis();
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
encoderRateMultiplierEnabled = false;
#endif
++++++
#if defined (upstream) && ((defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && )defined (ULTRA_LCD) && !defined (PROGRESS_MSG_ONCE) )
if (mil > progressBarTick + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME) {
        progressBarTick = mil;
      }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(LCD_PROGRESS_BAR) && ENABLED(ULTRA_LCD) )
millis_t ms = millis();
#endif
++++++
#if defined (upstream) && ((defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && )PROGRESS_MSG_EXPIRE > 0 && defined (ULTRA_LCD) )
// keep the message alive if paused, count down otherwise
#endif
++++++
#if defined (marlin4Due) && (ENABLED(LCD_PROGRESS_BAR) && !defined (PROGRESS_MSG_ONCE) && ENABLED(ULTRA_LCD) )
if (ms > progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME) {
        progress_bar_ms = ms;
      }
#endif
++++++
#if defined (upstream) && ((defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT) && )PROGRESS_MSG_EXPIRE > 0 && defined (ULTRA_LCD) )
if (messageTick > 0) {
        if (card.isFileOpen()) {
          if (IS_SD_PRINTING) {
            if ((mil-messageTick) >= PROGRESS_MSG_EXPIRE) {
              lcd_status_message[0] = '\0';
              messageTick = 0;
            }
          }
          else {
            messageTick += LCD_UPDATE_INTERVAL;
          }
        }
        else {
          messageTick = 0;
        }
      }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0 && ENABLED(ULTRA_LCD) )
// Handle message expire
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
if (lcd_status_update_delay)
        lcd_status_update_delay--;
    else
        lcdDrawUpdate = 1;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
lcd_implementation_status_screen();
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
if (lcdDrawUpdate)
    {
        lcd_implementation_status_screen();
        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL_FEEDMULTIPLY) && defined (ULTIPANEL) )
if ((feedmultiply < 100 && (feedmultiply + int(encoderPosition)) > 100) ||
            (feedmultiply > 100 && (feedmultiply + int(encoderPosition)) < 100))
    {
        encoderPosition = 0;
        feedmultiply = 100;
    }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTIPANEL_FEEDMULTIPLY) && ENABLED(ULTRA_LCD) )
if ((feedrate_multiplier < 100 && (feedrate_multiplier + int(encoderPosition)) > 100) ||
              (feedrate_multiplier > 100 && (feedrate_multiplier + int(encoderPosition)) < 100)) {
        encoderPosition = 0;
        feedrate_multiplier = 100;
      }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL_FEEDMULTIPLY) && defined (ULTIPANEL) )
if (feedmultiply == 100 && int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;
    }
    else if (feedmultiply == 100 && int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;
    }
    else if (feedmultiply != 100)
    {
        feedmultiply += int(encoderPosition);
        encoderPosition = 0;
    }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTIPANEL_FEEDMULTIPLY) && ENABLED(ULTRA_LCD) )
if (feedrate_multiplier == 100) {
        if (int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE) {
          feedrate_multiplier += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;
          encoderPosition = 0;
        }
        else if (int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE) {
          feedrate_multiplier += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
          encoderPosition = 0;
        }
      }
      else {
        feedrate_multiplier += int(encoderPosition);
        encoderPosition = 0;
      }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (feedmultiply < 10)
        feedmultiply = 10;
    else if (feedmultiply > 999)
        feedmultiply = 999;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
feedrate_multiplier = constrain(feedrate_multiplier, 10, 999);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_status_screen, 0, false);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
lcd_goto_menu(lcd_status_screen);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && defined (SDSUPPORT) )
quickStop();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
quickStop();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_setstatus(MSG_PRINT_ABORTED);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && defined (SDSUPPORT) )
lcd_setstatus(MSG_PRINT_ABORTED, true);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_status_screen);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//SDSUPPORT
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (SDSUPPORT) && defined (ULTIPANEL) )
card.lastnr=0;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && (ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART) &)
card.autostart_index = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
for(int8_t i=0; i < NUM_AXIS; i++) {
      if (i != E_AXIS) {
        add_homing[i] -= current_position[i];
        current_position[i] = 0.0;
      }
    }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// M428 Command
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
plan_set_position(0.0, 0.0, 0.0, current_position[E_AXIS]);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
enqueuecommands_P(PSTR("M428"));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// Audio feedback
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_main_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_SPEED, &feedmultiply, 10, 999);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_0 != 0 )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_1 != 0 )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15)
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE2, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_1 != 0 )
;
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_BED != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_2 != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_2 != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW, &extrudemultiply, 10, 999);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_3 != 0 )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW0, &extruder_multiply[0], 10, 999);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_3 != 0 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW1, &extruder_multiply[1], 10, 999);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_BED != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW2, &extruder_multiply[2], 10, 999);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_1 != 0 )
MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &extruder_multiplier[1], 10, 999)
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_2 != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &extruder_multiplier[2], 10, 999)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_3 != 0 )
MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &extruder_multiplier[3], 10, 999)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetHotend0(plaPreheatHotendTemp);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetBed(plaPreheatHPBTemp);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetHotend0(absPreheatHotendTemp);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetBed(absPreheatHPBTemp);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
setTargetHotend1(plaPreheatHotendTemp);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
setTargetBed(plaPreheatHPBTemp);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
setTargetHotend1(absPreheatHotendTemp);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
setTargetBed(absPreheatHPBTemp);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetHotend2(plaPreheatHotendTemp);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetBed(plaPreheatHPBTemp);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetHotend2(absPreheatHotendTemp);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetBed(absPreheatHPBTemp);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetBed(plaPreheatHPBTemp);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_BED != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
fanSpeed = plaPreheatFanSpeed;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetBed(absPreheatHPBTemp);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_BED != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
fanSpeed = absPreheatFanSpeed;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_prepare_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA0, lcd_preheat_pla0);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS == 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
//2 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA1, lcd_preheat_pla1);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1)
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA2, lcd_preheat_pla2);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
//all extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA012, lcd_preheat_pla012);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_prepare_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS0, lcd_preheat_abs0);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS == 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
//2 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS1, lcd_preheat_abs1);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1)
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS2, lcd_preheat_abs2);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
//all extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS012, lcd_preheat_abs012);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !EXTRUDERS == 1 )
MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetHotend0(0);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
disable_all_heaters();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
setTargetHotend1(0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && PS_ON_PIN > -1 && defined (ULTIPANEL) )

        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
    

#endif
++++++
#if defined (marlin4Due) && (HAS_POWER_SWITCH && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && PS_ON_PIN > -1 && defined (ULTIPANEL) )

        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
    

#endif
++++++
#if defined (marlin4Due) && (HAS_POWER_SWITCH && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_main_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (MENU_ADDAUTOSTART) && defined (SDSUPPORT) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// Auto Home
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS])
      MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G29"));
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && (ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART) &)
MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(DELTA_CALIBRATION_MENU) )
START_MENU(lcd_main_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
(const char *name, int axis, int min, int max)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
(const char *name, AxisEnum axis, int min, int max)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA) && defined (ULTIPANEL) )
calculate_delta(current_position);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
line_to_current(axis);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("X"), X_AXIS, X_MIN_POS, X_MAX_POS);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_move(PSTR(MSG_MOVE_X), X_AXIS, X_MIN_POS, X_MAX_POS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("Y"), Y_AXIS, Y_MIN_POS, Y_MAX_POS);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, Y_MIN_POS, Y_MAX_POS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("Z"), Z_AXIS, Z_MIN_POS, Z_MAX_POS);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
_lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, Z_MIN_POS, Z_MAX_POS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA) && defined (ULTIPANEL) )
calculate_delta(current_position);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
line_to_current(E_AXIS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )

        lcd_implementation_drawedit(PSTR("Extruder"), ftostr31(current_position[E_AXIS]));
    

#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )lcd_implementation_drawedit(PSTR(MSG_MOVE_E), ftostr31(current_position[E_AXIS]));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_move_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_prepare_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_main_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
// set up temp variables - undo the default scaling
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_control_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
raw_Ki = unscalePID_i(Ki);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
raw_Kd = unscalePID_d(Kd);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// ^ Control
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// Nozzle, Nozzle 2, Nozzle 3, Nozzle 4
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE2, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_BED != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_0 != 0 )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_1 != 0 )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15)
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_2 != 0 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15)
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_3 != 0 )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15)
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// EXTRUDERS > 3
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// EXTRUDERS > 2
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// EXTRUDERS > 1
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_BED != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float52, MSG_PID_P, &Kp, 1, 9990);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
// set up temp variables - undo the default scaling
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(PID_ADD_EXTRUSION_RATE) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(float3, MSG_PID_C, &PID_PARAM(Kc,0), 1, 9990);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//PID_ADD_EXTRUSION_RATE
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
// set up temp variables - undo the default scaling
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(PID_ADD_EXTRUSION_RATE) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(float3, MSG_PID_C MSG_E2, &PID_PARAM(Kc,1), 1, 9990)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//PID_ADD_EXTRUSION_RATE
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
// set up temp variables - undo the default scaling
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(PID_ADD_EXTRUSION_RATE) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(float3, MSG_PID_C MSG_E3, &PID_PARAM(Kc,2), 1, 9990)
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//PID_ADD_EXTRUSION_RATE
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
// set up temp variables - undo the default scaling
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I, &raw_Ki, 0.01, 9990, copy_and_scalePID_i);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I MSG_E4, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E4)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D, &raw_Kd, 1, 9990, copy_and_scalePID_d);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined ( PID_ADD_EXTRUSION_RATE) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float3, MSG_PID_C, &Kc, 1, 9990);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D MSG_E4, &raw_Kd, 1, 9990, copy_and_scalePID_d_E4)
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(PID_ADD_EXTRUSION_RATE) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(float3, MSG_PID_C MSG_E4, &PID_PARAM(Kc,3), 1, 9990)
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 3
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 2
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 1
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(PIDTEMP) && ENABLED(ULTRA_LCD) )
//PID_PARAMS_PER_EXTRUDER
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_control_temperature_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_0 != 0 )
MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_BED != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, 0, BED_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_BED != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_control_temperature_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && TEMP_SENSOR_0 != 0 )
MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_BED != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, 0, BED_MAXTEMP - 15);
#endif
++++++
#if defined (marlin4Due) && (TEMP_SENSOR_BED != 0 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_control_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ENABLE_AUTO_BED_LEVELING) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(ENABLE_AUTO_BED_LEVELING) )
MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 10, 99000);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000, reset_acceleration_rates)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 10, 99000, reset_acceleration_rates)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &travel_acceleration, 100, 99000);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_0, &filament_size[0], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_0, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_1, &filament_size[1], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_1, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_2, &filament_size[2], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_2, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_3, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 3
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 2
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 1
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_3, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 3
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 2
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//EXTRUDERS > 1
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_control_menu);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(U8GLIB_LM6059_AF) && ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) )
lcd_contrast += encoderPosition;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(U8GLIB_LM6059_AF) && ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) )
lcd_contrast &= 0xFF;
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (lcd_contrast < 0) lcd_contrast = 0;
        else if (lcd_contrast > 63) lcd_contrast = 63;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) && !ENABLED(U8GLIB_LM6059_AF) )
lcd_contrast &= 0x3F;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(U8GLIB_LM6059_AF) && ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) )
lcd_contrast += encoderPosition;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(U8GLIB_LM6059_AF) && ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) )
lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr3(lcd_contrast));
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(U8GLIB_LM6059_AF) && ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) )
lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr3(lcd_contrast));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (FWRETRACT) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(FWRETRACT) && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
START_MENU(lcd_control_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
START_MENU();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && defined (SDSUPPORT) )
START_MENU(lcd_main_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
enquecommand_P((PSTR("G28")));
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(REPRAPWORLD_KEYPAD) )
enqueuecommands_P((PSTR("G28")));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
(menuFunc_t data)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
(menuFunc_t func)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(data);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
lcd_goto_menu(func);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
(menuFunc_t data)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
(menuFunc_t func)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(data);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
lcd_goto_menu(func);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enquecommand_P(pgcode);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
enqueuecommands_P(pgcode);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
(menuFunc_t data)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
(menuFunc_t func)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
(*data)();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
(*func)();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enquecommand(cmd);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && defined (SDSUPPORT) )
enqueuecommand(cmd);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enquecommand_P(PSTR("M24"));
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && defined (SDSUPPORT) )
enqueuecommands_P(PSTR("M24"));
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
WRITE(BTN_EN1,HIGH);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL) )
PULLUP(BTN_EN1,HIGH);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
WRITE(BTN_EN2,HIGH);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL) )
PULLUP(BTN_EN2,HIGH);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && BTN_ENC > 0 )
WRITE(BTN_ENC,HIGH);
#endif
++++++
#if defined (marlin4Due) && (BTN_ENC > 0 && ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL) )
PULLUP(BTN_ENC,HIGH);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) )
WRITE(SHIFT_OUT,HIGH);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(REPRAPWORLD_KEYPAD) && ENABLED(NEWPANEL) )
PULLUP(SHIFT_OUT,HIGH);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) )
WRITE(SHIFT_LD,HIGH);
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(REPRAPWORLD_KEYPAD) && ENABLED(NEWPANEL) )
PULLUP(SHIFT_LD,HIGH);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined(SHIFT_CLK) && !defined (NEWPANEL) )
WRITE(SHIFT_OUT,HIGH);
#endif
++++++
#if defined (marlin4Due) && (defined(SHIFT_CLK) && ENABLED(ULTRA_LCD) && !ENABLED(NEWPANEL) )
PULLUP(SHIFT_OUT,HIGH);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined(SHIFT_CLK) && !defined (NEWPANEL) )
WRITE(SHIFT_LD,HIGH);
#endif
++++++
#if defined (marlin4Due) && (defined(SHIFT_CLK) && ENABLED(ULTRA_LCD) && !ENABLED(NEWPANEL) )
PULLUP(SHIFT_LD,HIGH);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined(SHIFT_CLK) && !defined (NEWPANEL) )
WRITE(SHIFT_EN,LOW);
#endif
++++++
#if defined (marlin4Due) && (defined(SHIFT_CLK) && ENABLED(ULTRA_LCD) && !ENABLED(NEWPANEL) )
PULLUP(SHIFT_EN,LOW);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) && !defined(SHIFT_CLK) && defined (ULTIPANEL) )
#error ULTIPANEL requires an encoder
#endif
++++++
#if defined (upstream) && ((defined (SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0) && )defined (ULTRA_LCD) )
WRITE(SDCARDDETECT, HIGH);
#endif
++++++
#if defined (marlin4Due) && ((ENABLED(SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0) && )ENABLED(ULTRA_LCD) )
PULLUP(SDCARDDETECT, HIGH);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
static unsigned long timeoutToStatus = 0;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
static millis_t return_to_status_ms = 0;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
millis_t ms = millis();
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
()
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
(bool persist=false)
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
(const char* message)
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
(const char* message, bool persist)
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
strncpy(lcd_status_message, message, LCD_WIDTH);
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
strncpy(lcd_status_message, message, 3*LCD_WIDTH);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_finishstatus();
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
set_utf_strlen(lcd_status_message, LCD_WIDTH);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
(const char* message)
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
(const char* message, uint8_t level)
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
if (lcd_status_message_level > 0)
        return;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
if (level >= lcd_status_message_level) {
    strncpy_P(lcd_status_message, message, 3*LCD_WIDTH);
    set_utf_strlen(lcd_status_message, LCD_WIDTH);
    lcd_status_message_level = level;
    lcd_finishstatus(level > 0);
  }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
strncpy_P(lcd_status_message, message, LCD_WIDTH);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_setstatuspgm(message);
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
lcd_setstatuspgm(message, 1);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_status_message_level = 1;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
//ULTIPANEL
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
lcd_contrast = value & 63;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(HAS_LCD_CONTRAST) )
lcd_contrast = value & 0x3F;
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && BTN_ENC > 0 && defined (ULTIPANEL) )
((blocking_enc<millis()) && (READ(BTN_ENC)==0))
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && BTN_ENC > 0 && ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL) )
(ms > next_button_update_ms && READ(BTN_ENC) == 0)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && BTN_ENC > 0 && ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL) )
millis_t ms = millis();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && BTN_ENC > 0 && (defined(BTN_BACK) && BTN_BACK > 0 && )ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL) )
if (ms > next_button_update_ms && READ(BTN_BACK) == 0) newbutton |= EN_D;
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
for(int8_t i=0;i<8;i++) {
          newbutton_reprapworld_keypad = newbutton_reprapworld_keypad>>1;
          if(READ(SHIFT_OUT))
              newbutton_reprapworld_keypad|=(1<<7);
          WRITE(SHIFT_CLK,HIGH);
          WRITE(SHIFT_CLK,LOW);
      }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(REPRAPWORLD_KEYPAD) && ENABLED(NEWPANEL) )
for(int8_t i = 0; i < 8; i++) {
          newbutton_reprapworld_keypad >>= 1;
          if (READ(SHIFT_OUT)) newbutton_reprapworld_keypad |= BIT(7);
          WRITE(SHIFT_CLK, HIGH);
          WRITE(SHIFT_CLK, LOW);
        }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) && defined (ULTIPANEL) )
for(int8_t i=0;i<8;i++)
    {
        newbutton = newbutton>>1;
        if(READ(SHIFT_OUT))
            newbutton|=(1<<7);
        WRITE(SHIFT_CLK,HIGH);
        WRITE(SHIFT_CLK,LOW);
    }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && !ENABLED(NEWPANEL) )
for(int8_t i=0; i<8; i++) {
        newbutton >>= 1;
        if (READ(SHIFT_OUT)) newbutton |= BIT(7);
        WRITE(SHIFT_CLK, HIGH);
        WRITE(SHIFT_CLK, LOW);
      }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[1]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[1] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
int xx=x*10;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
int xx = abs(x * 10);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0]=(xx>=0)?'+':'-';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[0] = (x >= 0) ? '+' : '-';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
xx=abs(xx);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[5]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[5] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
int xx=x*10;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
int xx = abs(x * 10);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
//conv[0]=(xx>=0)?'+':'-';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[4]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[4] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
long xx=x*100;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
long xx = abs(x * 100);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
if (xx >= 0)
    conv[0]=(xx/10000)%10+'0';
  else
    conv[0]='-';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[0] = x >= 0 ? (xx / 10000) % 10 + '0' : '-';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
xx=abs(xx);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[5]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[5] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[0] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[1] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[2]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[2] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[2]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[2] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[1]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[1] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[0] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
long xx=x*10;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
long xx = abs(x * 10);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0]=(xx>=0)?'+':'-';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[0] = (x >= 0) ? '+' : '-';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
xx=abs(xx);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[6]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[6] = xx % 10 + '0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
long xx=x*100;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[0] = (x >= 0) ? '+' : '-';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0]=(xx>=0)?'+':'-';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
long xx = abs(x * 100);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
xx=abs(xx);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[6]=(xx)%10+'0';
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
conv[6] = xx % 10 + '0';
#endif
++++++
#if defined (upstream)
#include "temperature.h"
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
#include "ConfigurationStore.h"
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
#include "configuration_store.h"
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/* encoderDiff is updated from interrupt context and added to encoderPosition every LCD update */
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// updated from interrupt context and added to encoderPosition every LCD update
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/* Configuration settings */
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
bool encoderRateMultiplierEnabled;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (FILAMENT_LCD_DISPLAY) )
unsigned long message_millis = 0;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(FILAMENT_LCD_DISPLAY) && ENABLED(ULTRA_LCD) )
millis_t previous_lcd_status_ms = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static float manual_feedrate[] = MANUAL_FEEDRATE;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// ULTIPANEL
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
char lcd_status_message[LCD_WIDTH+1] = WELCOME_MSG;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
char lcd_status_message[3*LCD_WIDTH+1] = WELCOME_MSG;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/** forward declarations **/
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// The main status screen
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void copy_and_scalePID_i();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
const float manual_feedrate[] = MANUAL_FEEDRATE;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
#include "mesh_bed_leveling.h"
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_quick_feedback();
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
static void _lcd_level_bed();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//Cause an LCD refresh, and give the user visual or audible feedback that something has happened
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
static void _lcd_level_bed_homing();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define START_MENU() do { \
    if (encoderPosition > 0x8000) encoderPosition = 0; \
    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM < currentMenuViewOffset) currentMenuViewOffset = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM;\
    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
    bool wasClicked = LCD_CLICKED;\
    for(uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
        _menuItemNr = 0;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
   * START_MENU generates the init code for a menu function
   */
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define MENU_ITEM(type, label, args...) do { \
    if (_menuItemNr == _lineNr) { \
        if (lcdDrawUpdate) { \
            const char* _label_pstr = PSTR(label); \
            if ((encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \
                lcd_implementation_drawmenu_ ## type ## _selected (_drawLineNr, _label_pstr , ## args ); \
            }else{\
                lcd_implementation_drawmenu_ ## type (_drawLineNr, _label_pstr , ## args ); \
            }\
        }\
        if (wasClicked && (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) {\
            lcd_quick_feedback(); \
            menu_action_ ## type ( args ); \
            return;\
        }\
    }\
    _menuItemNr++;\
} while(0)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && (defined(BTN_BACK) && BTN_BACK > 0 &)
#define START_MENU(last_menu) do { \
    encoderRateMultiplierEnabled = false; \
    if (encoderPosition > 0x8000) encoderPosition = 0; \
    uint8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
    if (encoderLine < currentMenuViewOffset) currentMenuViewOffset = encoderLine; \
    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
    bool wasClicked = LCD_CLICKED, itemSelected; \
    bool wasBackClicked = LCD_BACK_CLICKED; \
    if (wasBackClicked) { \
      lcd_quick_feedback(); \
      menu_action_back( last_menu ); \
      return; } \
    for (uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
      _menuItemNr = 0;
#endif
++++++
#if defined (marlin4Due) && ((!defined(BTN_BACK) && BTN_BACK > 0 && )ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
#define START_MENU(last_menu) do { \
    encoderRateMultiplierEnabled = false; \
    if (encoderPosition > 0x8000) encoderPosition = 0; \
    uint8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \
    if (encoderLine < currentMenuViewOffset) currentMenuViewOffset = encoderLine; \
    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
    bool wasClicked = LCD_CLICKED, itemSelected; \
    for (uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
      _menuItemNr = 0;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
   * MENU_ITEM generates draw & handler code for a menu item, potentially calling:
   *
   *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)
   *   menu_action_[type](arg3...)
   *
   * Examples:
   *   MENU_ITEM(back, MSG_WATCH, lcd_status_screen)
   *     lcd_implementation_drawmenu_back(sel, row, PSTR(MSG_WATCH), lcd_status_screen)
   *     menu_action_back(lcd_status_screen)
   *
   *   MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause)
   *     lcd_implementation_drawmenu_function(sel, row, PSTR(MSG_PAUSE_PRINT), lcd_sdcard_pause)
   *     menu_action_function(lcd_sdcard_pause)
   *
   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999)
   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
   *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
   *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)
   *
   */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENCODER_RATE_MULTIPLIER) && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//ENCODER_RATE_MULTIPLIER
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define END_MENU() \
    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM >= _menuItemNr) encoderPosition = _menuItemNr * ENCODER_STEPS_PER_MENU_ITEM - 1; \
    if ((uint8_t)(encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) >= currentMenuViewOffset + LCD_HEIGHT) { currentMenuViewOffset = (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) - LCD_HEIGHT + 1; lcdDrawUpdate = 1; _lineNr = currentMenuViewOffset - 1; _drawLineNr = -1; } \
    } } while(0)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ENCODER_RATE_MULTIPLIER) && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
#define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && !ENABLED(ENCODER_RATE_MULTIPLIER) && ENABLED(ULTRA_LCD) )
//!ENCODER_RATE_MULTIPLIER
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//!ENCODER_RATE_MULTIPLIER
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
//Contains the bits of the currently pressed buttons.
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//the last checked buttons in a bit array.
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
// to store the reprapworld_keypad shift register values
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(REPRAPWORLD_KEYPAD) )
// to store the keypad shift register values
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (LCD_HAS_SLOW_BUTTONS) )
//Contains the bits of the currently pressed buttons.
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(LCD_HAS_SLOW_BUTTONS) )
// Bits of the pressed buttons.
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
uint32_t blocking_enc;
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
millis_t next_button_update_ms;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
uint32_t lcd_next_update_millis;
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
millis_t next_lcd_update_ms;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
static void lcd_goto_menu(menuFunc_t menu, const uint32_t encoder=0, const bool feedback=true) {
  if (currentMenu != menu) {
    currentMenu = menu;
    encoderPosition = encoder;
    if (feedback) lcd_quick_feedback();

    // For LCD_PROGRESS_BAR re-initialize the custom characters
    #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT)
      lcd_set_custom_characters(menu == lcd_status_screen);
    #endif
  }
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
/**
 * General function to go directly to a menu
 */
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependent */
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
static void lcd_goto_menu(menuFunc_t menu, const bool feedback=false, const uint32_t encoder=0) {
  if (currentMenu != menu) {
    currentMenu = menu;
    #if ENABLED(NEWPANEL)
      encoderPosition = encoder;
      if (feedback) lcd_quick_feedback();
    #endif
    // For LCD_PROGRESS_BAR re-initialize the custom characters
    #if ENABLED(LCD_PROGRESS_BAR)
      lcd_set_custom_characters(menu == lcd_status_screen);
    #endif
  }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
/* Menu implementation */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Main" menu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 * Set the home offset based on the current_position
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Tune" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {
  if (temph > 0) setTargetHotend(temph, endnum);
  #if TEMP_SENSOR_BED != 0
    setTargetBed(tempb);
  #endif
  fanSpeed = fan;
  lcd_return_to_status();
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
//2nd extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2nd extruder preheat
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
#endif
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
//more than one extruder present
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
#endif
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
void lcd_preheat_pla012()
{
    setTargetHotend0(plaPreheatHotendTemp);
    setTargetHotend1(plaPreheatHotendTemp);
    setTargetHotend2(plaPreheatHotendTemp);
    setTargetBed(plaPreheatHPBTemp);
    fanSpeed = plaPreheatFanSpeed;
    lcd_return_to_status();
    setWatch(); // heater sanity check timer
}
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_preheat_pla0123() {
    setTargetHotend0(plaPreheatHotendTemp);
    setTargetHotend1(plaPreheatHotendTemp);
    setTargetHotend2(plaPreheatHotendTemp);
    _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);
  }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
void lcd_preheat_abs012()
{
    setTargetHotend0(absPreheatHotendTemp);
    setTargetHotend1(absPreheatHotendTemp);
    setTargetHotend2(absPreheatHotendTemp);
    setTargetBed(absPreheatHPBTemp);
    fanSpeed = absPreheatFanSpeed;
    lcd_return_to_status();
    setWatch(); // heater sanity check timer
}
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_preheat_abs0123() {
    setTargetHotend0(absPreheatHotendTemp);
    setTargetHotend1(absPreheatHotendTemp);
    setTargetHotend2(absPreheatHotendTemp);
    _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);
  }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//more than one extruder present
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// EXTRUDERS > 1
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Prepare" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
inline void line_to_current(AxisEnum axis) {
  #if ENABLED(DELTA)
    calculate_delta(current_position);
    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
  #else
    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
  #endif
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Prepare" > "Move Xmm" > "Move XYZ" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Prepare" > "Move Axis" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Control" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Temperature" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
// Helpers for editing PID Ki & Kd values
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
void copy_and_scalePID_i_E2() { copy_and_scalePID_i(1); }
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
void copy_and_scalePID_i_E3() { copy_and_scalePID_i(2); }
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 3 && EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
void copy_and_scalePID_i_E4() { copy_and_scalePID_i(3); }
#endif
++++++
#if defined (marlin4Due) && (EXTRUDERS > 2 && ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
//EXTRUDERS > 3
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS > 1 && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
//EXTRUDERS > 2
#endif
++++++
#if defined (marlin4Due) && (ENABLED(PID_PARAMS_PER_EXTRUDER) && ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
//EXTRUDERS > 1
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(PIDTEMP) )
//PID_PARAMS_PER_EXTRUDER
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
//PIDTEMP
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Temperature" > "Preheat PLA conf" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Temperature" > "Preheat ABS conf" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Control" > "Motion" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Control" > "Filament" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * "Control" > "Contrast" submenu
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// HAS_LCD_CONTRAST
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && defined (SDSUPPORT) )
/**
 *
 * "Print from SD" submenu
 *
 */
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define menu_edit_type(_type, _name, _strFunc, scale) \
    void menu_edit_ ## _name () \
    { \
        if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
        if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
        if (lcdDrawUpdate) \
            lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
        if (LCD_CLICKED) \
        { \
            *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
            lcd_goto_menu(prevMenu, prevEncoderPosition); \
        } \
    } \
    void menu_edit_callback_ ## _name () { \
        menu_edit_ ## _name (); \
        if (LCD_CLICKED) (*callbackFunc)(); \
    } \
    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale - minEditValue; \
        encoderPosition = (*ptr) * scale - minEditValue; \
    }\
    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_callback_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale - minEditValue; \
        encoderPosition = (*ptr) * scale - minEditValue; \
        callbackFunc = callback;\
    }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * Functions for editing single values
 *
 */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * Handlers for RepRap World Keypad input
 *
 */
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
/** End of menus **/
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
// REPRAPWORLD_KEYPAD
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_quick_feedback()
{
    lcdDrawUpdate = 2;
    blocking_enc = millis() + 500;
    lcd_implementation_quick_feedback();
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
 *
 * Audio feedback for controller clicks
 *
 */
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
/** Menu action functions **/
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(LCD_USE_I2C_BUZZER) )
void lcd_buzz(long duration, uint16_t freq) { // called from buzz() in Marlin_main.cpp where lcd is unknown
    lcd.buzz(duration, freq);
  }
#endif
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && ENABLED(LCD_USE_I2C_BUZZER) )
void lcd_buzz(long duration, uint16_t freq) { // called from buzz() in Marlin_main.cpp where lcd is unknown
    lcd.buzz(duration, freq);
  }
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
void lcd_quick_feedback() {
  lcdDrawUpdate = 2;
  next_button_update_ms = millis() + 500;
    
  #if ENABLED(LCD_USE_I2C_BUZZER)
    #ifndef LCD_FEEDBACK_FREQUENCY_HZ
      #define LCD_FEEDBACK_FREQUENCY_HZ 100
    #endif
    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS (1000/6)
    #endif    
    lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
  #elif defined(BEEPER) && BEEPER >= 0
    #ifndef LCD_FEEDBACK_FREQUENCY_HZ
      #define LCD_FEEDBACK_FREQUENCY_HZ 5000
    #endif
    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2
    #endif
    buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);
  #else
    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS
      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2
    #endif
    delay(LCD_FEEDBACK_FREQUENCY_DURATION_MS);
  #endif
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
int lcd_strlen(char *s) {
  int i = 0, j = 0;
  while (s[i]) {
    if ((s[i] & 0xc0) != 0x80) j++;
    i++;
  }
  return j;
}
#endif
++++++
#if defined (marlin4Due) && ((ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0 && )ENABLED(ULTRA_LCD) )
void dontExpireStatus() { expire_status_ms = 0; }
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
void set_utf_strlen(char *s, uint8_t n) {
  uint8_t i = 0, j = 0;
  while (s[i] && (j < n)) {
    if ((s[i] & 0xc0u) != 0x80u) j++;
    i++;
  }
  while (j++ < n) s[i++] = ' ';
  s[i] = 0;
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
/* Warning: This function is called from interrupt context */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
   * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)
   * These values are independent of which pins are used for EN_A and EN_B indications
   * The rotary encoder part is also independent to the chipset used for the LCD
   */
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) && (defined(EN_A) && defined(EN_B) &)
#define encrot0 0
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTIPANEL) && ENABLED(ULTRA_LCD) )
/**
   * Read encoder buttons from the hardware registers
   * Warning: This function is called from interrupt context!
   */
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_buzz(long duration, uint16_t freq)
{
#ifdef LCD_USE_I2C_BUZZER
  lcd.buzz(duration,freq);
#endif
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/********************************/
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
/*********************************/
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/** Float conversion utilities **/
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
/** Number to string conversion **/
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/********************************/
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
/*********************************/
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
//  convert float to string with +123.4 format
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert float to string with +123.4 format
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert int to string with 12 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 123.4 format, dropping sign
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert float to string with +123.4 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 123.4 format
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert float to string with 123.4 format, dropping sign
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert float to string with 123.4 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
//Float to string with 1.23 format
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert float to string with 1.23 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
//  convert float to space-padded string with -_23.4_ format
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert float to space-padded string with -_23.4_ format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
char *itostr31(const int &xx)
{
  conv[0]=(xx>=0)?'+':'-';
  conv[1]=(xx/1000)%10+'0';
  conv[2]=(xx/100)%10+'0';
  conv[3]=(xx/10)%10+'0';
  conv[4]='.';
  conv[5]=(xx)%10+'0';
  conv[6]=0;
  return conv;
}
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// Convert int to lj string with +123.0 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Callback for after editing PID i value
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
static int _lcd_level_bed_position;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// grab the PID i value out of the temp variable; scale it; then update the PID driver
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
/**
   * MBL Wait for controller movement and clicks:
   *   - Movement adjusts the Z axis
   *   - Click saves the Z and goes to the next mesh point
   */
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void copy_and_scalePID_i()
{
#ifdef PIDTEMP
  Ki = scalePID_i(raw_Ki);
  updatePID();
#endif
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
static void _lcd_level_bed() {
    if (encoderPosition != 0) {
      refresh_cmd_timeout();
      current_position[Z_AXIS] += float((int)encoderPosition) * MBL_Z_STEP;
      if (min_software_endstops && current_position[Z_AXIS] < Z_MIN_POS) current_position[Z_AXIS] = Z_MIN_POS;
      if (max_software_endstops && current_position[Z_AXIS] > Z_MAX_POS) current_position[Z_AXIS] = Z_MAX_POS;
      encoderPosition = 0;
      line_to_current(Z_AXIS);
      lcdDrawUpdate = 2;
    }
    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("Z"), ftostr43(current_position[Z_AXIS]));
    static bool debounce_click = false;
    if (LCD_CLICKED) {
      if (!debounce_click) {
        debounce_click = true;
        int ix = _lcd_level_bed_position % MESH_NUM_X_POINTS,
            iy = _lcd_level_bed_position / MESH_NUM_X_POINTS;
        if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // Zig zag
        mbl.set_z(ix, iy, current_position[Z_AXIS]);
        _lcd_level_bed_position++;
        if (_lcd_level_bed_position == MESH_NUM_X_POINTS*MESH_NUM_Y_POINTS) {
          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
          line_to_current(Z_AXIS);
          mbl.active = 1;
          enqueuecommands_P(PSTR("G28"));
          lcd_return_to_status();
        }
        else {
          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
          line_to_current(Z_AXIS);
          ix = _lcd_level_bed_position % MESH_NUM_X_POINTS;
          iy = _lcd_level_bed_position / MESH_NUM_X_POINTS;
          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // Zig zag
          current_position[X_AXIS] = mbl.get_x(ix);
          current_position[Y_AXIS] = mbl.get_y(iy);
          line_to_current(manual_feedrate[X_AXIS] <= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);
          lcdDrawUpdate = 2;
        }
      }
    }
    else {
      debounce_click = false;
    }
  }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Callback for after editing PID d value
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
/**
   * MBL Move to mesh starting point
   */
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// grab the PID d value out of the temp variable; scale it; then update the PID driver
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
static void _lcd_level_bed_homing() {
    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("XYZ"), "Homing");
    if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]) {
      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      current_position[X_AXIS] = MESH_MIN_X;
      current_position[Y_AXIS] = MESH_MIN_Y;
      line_to_current(manual_feedrate[X_AXIS] <= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);
      _lcd_level_bed_position = 0;
      lcd_goto_menu(_lcd_level_bed);
    }
    lcdDrawUpdate = 2;
  }
#endif
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
static void _lcd_level_bed_homing() {
    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("XYZ"), "Homing");
    if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]) {
      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      current_position[X_AXIS] = MESH_MIN_X;
      current_position[Y_AXIS] = MESH_MIN_Y;
      line_to_current(manual_feedrate[X_AXIS] <= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);
      _lcd_level_bed_position = 0;
      lcd_goto_menu(_lcd_level_bed);
    }
    lcdDrawUpdate = 2;
  }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void copy_and_scalePID_d()
{
#ifdef PIDTEMP
  Kd = scalePID_d(raw_Kd);
  updatePID();
#endif
}
#endif
++++++
#if defined (marlin4Due) && (ENABLED(ULTRA_LCD) && ENABLED(MANUAL_BED_LEVELING) )
/**
   * MBL entry-point
   */
#endif
++++++
#if defined (marlin4Due) && ENABLED(ULTRA_LCD)
// MANUAL_BED_LEVELING
#endif
++++++


**--**-**--merge: vector_3.cpp

#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
float length = sqrt((x * x) + (y * y) + (z * z));
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
return sqrt((x * x) + (y * y) + (z * z));
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
return length;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
(char* title)
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
(const char title[])
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL(x);
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL_F(x, 6);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL(y);
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL_F(y, 6);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL(z);
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL_F(z, 6);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOLPGM("\n");
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_EOL;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
(char* title)
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
(const char title[])
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL(matrix[count]);
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
if (matrix[count] >= 0.0) SERIAL_PROTOCOLCHAR('+');
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOLPGM(" ");
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL_F(matrix[count], 6);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOLPGM("\n");
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_EOL;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL(title);
#endif
++++++
#if defined (marlin4Due) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOLLN(title);
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
SERIAL_PROTOCOL("\n");
#endif
++++++
#if defined (upstream)
// #ifdef ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (marlin4Due)
// ENABLE_AUTO_BED_LEVELING
#endif
++++++


**--**-**--merge: watchdog.cpp

#if defined (upstream) && (defined (WATCHDOG_RESET_MANUAL) && defined (USE_WATCHDOG) )
//We enable the watchdog timer, but only for the interrupt.
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
const uint32_t wdtTicks = 256;
#endif
++++++
#if defined (upstream) && (defined (WATCHDOG_RESET_MANUAL) && defined (USE_WATCHDOG) )
//Take care, as this requires the correct order of operation, with interrupts disabled. See the datasheet of any AVR chip for details.
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
// number of watchdog ticks @ 32768Hz/128 before the watchdog times out (max 4095)
#endif
++++++
#if defined (upstream) && (defined (WATCHDOG_RESET_MANUAL) && defined (USE_WATCHDOG) )
wdt_reset();
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
WDT_Enable(WDT, (wdtTicks << WDT_MR_WDV_Pos) | (wdtTicks << WDT_MR_WDD_Pos) | WDT_MR_WDRSTEN);
#endif
++++++
#if defined (upstream) && (defined (WATCHDOG_RESET_MANUAL) && defined (USE_WATCHDOG) )
_WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
// enable watchdog, reset the mcu if it times out
#endif
++++++
#if defined (upstream) && (defined (WATCHDOG_RESET_MANUAL) && defined (USE_WATCHDOG) )
_WD_CONTROL_REG = _BV(WDIE) | WDTO_4S;
#endif
++++++
#if defined (upstream) && (!defined (WATCHDOG_RESET_MANUAL) && defined (USE_WATCHDOG) )
wdt_enable(WDTO_4S);
#endif
++++++
#if defined (upstream) && defined (USE_WATCHDOG)
wdt_reset();
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
WDT_Restart(WDT);
#endif
++++++
#if defined (upstream) && defined (USE_WATCHDOG)
#include <avr/wdt.h>
#endif
++++++
#if defined (upstream) && defined (USE_WATCHDOG)
//=============================private variables  ============================
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
//============================ private variables ============================
#endif
++++++
#if defined (upstream) && defined (USE_WATCHDOG)
//=============================functinos         ============================
#endif
++++++
#if defined (marlin4Due) && defined (USE_WATCHDOG)
//================================ functions ================================
#endif
++++++
#if defined (upstream) && defined (USE_WATCHDOG)
//===========================================================================
#endif
++++++
#if defined (upstream) && (defined (USE_WATCHDOG) && defined (WATCHDOG_RESET_MANUAL) )
ISR(WDT_vect)
#endif
++++++
#if defined (upstream) && defined (USE_WATCHDOG)
//RESET_MANUAL
#endif
++++++
#if defined (upstream)
//USE_WATCHDOG
#endif
++++++
