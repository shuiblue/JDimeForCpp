!!!fork: drsdre

**--**-**--merge: BlinkM.cpp



**--**-**--merge: cardreader.cpp

#if defined (upstream) && defined (SDSUPPORT)
logging = false;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
workDirDepth = 0;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//the SD start is delayed, because otherwise the serial cannot answer fast enough to make contact with the host software.
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
//the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(const char *prepend, SdFile parent, const char * const match/*=NULL*/)
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
(const char *prepend,SdFile parent)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char pn0 = p.name[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(pn0 == DIR_NAME_FREE)
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
(p.name[0] == DIR_NAME_FREE)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(pn0 == DIR_NAME_DELETED || pn0 == '.' || pn0 == '_')
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
(p.name[0] == DIR_NAME_DELETED || p.name[0] == '.'|| p.name[0] == '_')
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lf0 = longFilename[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(lf0 == '.' || lf0 == '_')
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
(longFilename[0] != '\0' &&
          (longFilename[0] == '.' || longFilename[0] == '_'))
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
if ( p.name[0] == '.')
      {
        if ( p.name[1] != '.')
        continue;
      }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if (match != NULL) {
          if (strcasecmp(match, filename) == 0) return;
        }
        else if (cnt == nrFiles) return;
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
if(cnt==nrFiles)
          return;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char pn0 = p.name[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lf0 = longFilename[0];
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
if ( p.name[0] == '.')
      {
        if ( p.name[1] != '.')
        continue;
      }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(char* name,bool read, bool replace_current/*=true*/)
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
(char* name,bool read)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
getfilename(0, fname);
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
lcd_setstatus(fname);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lcd_setstatus(longFilename[0] ? longFilename : fname);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(file.isOpen())  //replacing current file by new file, or subfile call
  {
    if(!replace_current)
    {
     if((int)file_subcall_ctr>(int)SD_PROCEDURE_DEPTH-1)
     {
       SERIAL_ERROR_START;
       SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
       SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
       kill();
       return;
     }
     
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("SUBROUTINE CALL target:\"");
     SERIAL_ECHO(name);
     SERIAL_ECHOPGM("\" parent:\"");
     
     //store current filename and position
     getAbsFilename(filenames[file_subcall_ctr]);
     
     SERIAL_ECHO(filenames[file_subcall_ctr]);
     SERIAL_ECHOPGM("\" pos");
     SERIAL_ECHOLN(sdpos);
     filespos[file_subcall_ctr]=sdpos;
     file_subcall_ctr++;
    }
    else
    {
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("Now doing file: ");
     SERIAL_ECHOLN(name);
    }
    file.close();
  }
  else //opening fresh file
  {
    file_subcall_ctr=0; //resetting procedure depth in case user cancels print while in procedure
    SERIAL_ECHO_START;
    SERIAL_ECHOPGM("Now fresh file: ");
    SERIAL_ECHOLN(name);
  }
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
file.close();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLN(fname);
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
SERIAL_PROTOCOL(fname);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(bool store_location)
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
()
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
logging = false;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(uint16_t nr, const char * const match/*=NULL*/)
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
(const uint8_t nr)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lsDive("",*curDir,match);
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
lsDive("",*curDir);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if (workDirDepth < MAX_DIR_DEPTH) {
      for (int d = ++workDirDepth; d--;)
        workDirParents[d+1] = workDirParents[d];
      workDirParents[0]=*parent;
    }
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
workDirParentParent=workDirParent;
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
workDirParent=*parent;
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
workDirParent=*parent;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(workDirDepth > 0)
  {
    --workDirDepth;
    workDir = workDirParents[0];
    int d;
    for (int d = 0; d < workDirDepth; d++)
      workDirParents[d] = workDirParents[d+1];
  }
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
if(!workDir.isRoot())
  {
    workDir=workDirParent;
    workDirParent=workDirParentParent;
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(file_subcall_ctr>0) //heading up to a parent file that called current as a procedure.
    {
      file.close();
      file_subcall_ctr--;
      openFile(filenames[file_subcall_ctr],true,true);
      setIndex(filespos[file_subcall_ctr]);
      startFileprint();
    }
    else
    {
      quickStop();
      file.close();
      sdprinting = false;
      if(SD_FINISHED_STEPPERRELEASE)
      {
          //finishAndDisableSteppers();
          enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));
      }
      autotempShutdown();
    }
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
quickStop();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
void CardReader::openLogFile(char* name)
{
  logging = true;
  openFile(name, false);
}
#endif
++++++


**--**-**--merge: ConfigurationStore.cpp

#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,add_homing);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,add_homeing);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,endstop_adj);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,zprobe_zoffset);
#endif
++++++
#if defined (upstream) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
float dummy = 3000.0f;
#endif
++++++
#if defined (drsdre) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,3000);
#endif
++++++
#if defined (upstream) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,dummy);
#endif
++++++
#if defined (drsdre) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,0);
#endif
++++++
#if defined (upstream) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
dummy = 0.0f;
#endif
++++++
#if defined (drsdre) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,0);
#endif
++++++
#if defined (upstream) && (!defined (PIDTEMP) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,dummy);
#endif
++++++
#if defined (upstream) && (!defined (DOGLCD) && defined (EEPROM_SETTINGS) )
int lcd_contrast = 32;
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,lcd_contrast);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,axis_scaling);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,autoretract_enabled);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_feedrate);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_recover_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_recover_feedrate);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// Save filament sizes
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i, filament_size[1]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i, filament_size[2]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOLNPGM("Scaling factors:");
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR("  M365 X",axis_scaling[X_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" Y",axis_scaling[Y_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" Z",axis_scaling[Z_AXIS]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR("  M203 X", max_feedrate[X_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Y", max_feedrate[Y_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y",max_feedrate[1] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Z", max_feedrate[Z_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z", max_feedrate[2] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" E", max_feedrate[E_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" E", max_feedrate[3]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[X_AXIS] );
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[Y_AXIS] );
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[Z_AXIS] );
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[E_AXIS]);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum XY jerk (mm/s),  Z=maximum Z jerk (mm/s),  E=maximum E jerk (mm/s)");
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum xY jerk (mm/s),  Z=maximum Z jerk (mm/s)");
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR("  M665 L",delta_diagonal_rod );
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" R" ,delta_radius );
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" S" ,delta_segments_per_second );
#endif
++++++
#if defined (drsdre) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
#endif
++++++
#if defined (upstream) && (defined (PIDTEMP) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" I" ,unscalePID_i(Ki));
#endif
++++++
#if defined (drsdre) && (defined (EEPROM_CHITCHAT) && defined (PIDTEMP) )
SERIAL_ECHOPAIR(" I" ,Ki/PID_dT);
#endif
++++++
#if defined (upstream) && (defined (PIDTEMP) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" D" ,unscalePID_d(Kd));
#endif
++++++
#if defined (drsdre) && (defined (EEPROM_CHITCHAT) && defined (PIDTEMP) )
SERIAL_ECHOPAIR(" D" ,Kd*PID_dT);
#endif
++++++
#if defined (upstream) && (defined (PIDTEMP) && !defined (DISABLE_M503) )
SERIAL_ECHOLN("");
#endif
++++++
#if defined (upstream) && (!defined (DISABLE_M503) && defined (FWRETRACT) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && !defined (DISABLE_M503) && defined (FWRETRACT) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (!defined (DISABLE_M503) && defined (FWRETRACT) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
reset_acceleration_rates();
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,add_homing);
#endif
++++++
#if defined (drsdre) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,add_homeing);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,endstop_adj);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,delta_radius);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,delta_diagonal_rod);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,delta_segments_per_second);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,zprobe_zoffset);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// do not need to scale PID values as the values in EEPROM are already scaled		
#endif
++++++
#if defined (upstream) && (!defined (DOGLCD) && defined (EEPROM_SETTINGS) )
int lcd_contrast;
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,lcd_contrast);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,axis_scaling);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,autoretract_enabled);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_length);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_feedrate);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_zlift);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_length);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_feedrate);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i, volumetric_enabled);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i, filament_size[0]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[1]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[2]);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
calculate_volumetric_multipliers();
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// Call updatePID (similar to when we have processed M301)
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
updatePID();
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
SERIAL_ECHOLNPGM("Stored settings retrieved");
#endif
++++++
#if defined (drsdre) && defined (EEPROM_SETTINGS)
SERIAL_ECHOLNPGM("Stored settings retreived:");
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,endstop_adj);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,zprobe_zoffset);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// do not need to scale PID values as the values in EEPROM are already scaled		
#endif
++++++
#if defined (upstream) && (!defined (DOGLCD) && defined (EEPROM_SETTINGS) )
int lcd_contrast;
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,lcd_contrast);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,axis_scaling);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,autoretract_enabled);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_feedrate);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_feedrate);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i, volumetric_enabled);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[1]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[2]);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
calculate_volumetric_multipliers();
#endif
++++++
#if defined (drsdre) && defined (EEPROM_SETTINGS)
SERIAL_ECHO_START;
#endif
++++++
#if defined (drsdre) && defined (EEPROM_SETTINGS)
SERIAL_ECHOLN("Using Default settings:");
#endif
++++++
#if defined (drsdre) && defined (EEPROM_SETTINGS)
SERIAL_ECHO_START;
#endif
++++++
#if defined (drsdre)
for (short i=0;i<4;i++) 
    {
        axis_steps_per_unit[i]=tmp1[i];  
        max_feedrate[i]=tmp2[i];  
        max_acceleration_units_per_sq_second[i]=tmp3[i];
    }
#endif
++++++
#if defined (upstream)
// steps per sq second need to be updated to agree with the units per sq second
#endif
++++++
#if defined (upstream)
add_homing[X_AXIS] = add_homing[Y_AXIS] = add_homing[Z_AXIS] = 0;
#endif
++++++
#if defined (drsdre)
add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
#endif
++++++
#if defined (upstream) && defined (DELTA)
endstop_adj[X_AXIS] = endstop_adj[Y_AXIS] = endstop_adj[Z_AXIS] = 0;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
zprobe_zoffset = -Z_PROBE_OFFSET_FROM_EXTRUDER;
#endif
++++++
#if defined (upstream) && defined (DOGLCD)
lcd_contrast = DEFAULT_LCD_CONTRAST;
#endif
++++++
#if defined (upstream) && defined (PIDTEMP)
Ki = scalePID_i(DEFAULT_Ki);
#endif
++++++
#if defined (drsdre) && defined (PIDTEMP)
Ki = (DEFAULT_Ki*PID_dT);
#endif
++++++
#if defined (upstream) && defined (PIDTEMP)
Kd = scalePID_d(DEFAULT_Kd);
#endif
++++++
#if defined (drsdre) && defined (PIDTEMP)
Kd = (DEFAULT_Kd/PID_dT);
#endif
++++++
#if defined (upstream) && defined (PIDTEMP)
// call updatePID (similar to when we have processed M301)
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
autoretract_enabled = false;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (FWRETRACT) )
retract_length_swap = RETRACT_LENGTH_SWAP;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
retract_feedrate = RETRACT_FEEDRATE;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (FWRETRACT) )
retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;
#endif
++++++
#if defined (upstream)
volumetric_enabled = false;
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
filament_size[1] = DEFAULT_NOMINAL_FILAMENT_DIA;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 )
filament_size[2] = DEFAULT_NOMINAL_FILAMENT_DIA;
#endif
++++++
#if defined (upstream)
calculate_volumetric_multipliers();
#endif
++++++
#if defined (upstream)
#define EEPROM_VERSION "V13"
#endif
++++++
#if defined (drsdre)
#define EEPROM_VERSION "V07"
#endif
++++++


**--**-**--merge: digipot_mcp4451.cpp



**--**-**--merge: LiquidCrystalRus.cpp

#if defined (upstream)
#include "LiquidCrystalRus.h"

#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <avr/pgmspace.h>

#if defined(ARDUINO) && ARDUINO >= 100
  #include "Arduino.h"
#else
  #include "WProgram.h"
#endif

// it is a Russian alphabet translation
// except 0401 --> 0xa2 = â, 0451 --> 0xb5
const PROGMEM uint8_t utf_recode[] = 
       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
        };     

// When the display powers up, it is configured as follows:
//
// 1. Display clear
// 2. Function set: 
//    DL = 1; 8-bit interface data 
//    N = 0; 1-line display 
//    F = 0; 5x8 dot character font 
// 3. Display on/off control: 
//    D = 0; Display off 
//    C = 0; Cursor off 
//    B = 0; Blinking off 
// 4. Entry mode set: 
//    I/D = 1; Increment by 1 
//    S = 0; No shift 
//
// Note, however, that resetting the Arduino doesn't reset the LCD, so we
// can't assume that it's in that state when a sketch starts (and the
// LiquidCrystal constructor is called).
// 
// modified 27 Jul 2011
// by Ilya V. Danilov http://mk90.ru/


LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  _rs_pin = rs;
  _rw_pin = rw;
  _enable_pin = enable;
  
  _data_pins[0] = d0;
  _data_pins[1] = d1;
  _data_pins[2] = d2;
  _data_pins[3] = d3; 
  _data_pins[4] = d4;
  _data_pins[5] = d5;
  _data_pins[6] = d6;
  _data_pins[7] = d7; 

  pinMode(_rs_pin, OUTPUT);
  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
  if (_rw_pin != 255) { 
    pinMode(_rw_pin, OUTPUT);
  }
  pinMode(_enable_pin, OUTPUT);
  
  if (fourbitmode)
    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
  else 
    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
  
  begin(16, 1);  
}

void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
  if (lines > 1) {
    _displayfunction |= LCD_2LINE;
  }
  _numlines = lines;
  _currline = 0;

  // for some 1 line displays you can select a 10 pixel high font
  if ((dotsize != 0) && (lines == 1)) {
    _displayfunction |= LCD_5x10DOTS;
  }

  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
  // according to datasheet, we need at least 40ms after power rises above 2.7V
  // before sending commands. Arduino can turn on way before 4.5V so we'll wait 50
  delayMicroseconds(50000); 
  // Now we pull both RS and R/W low to begin commands
  digitalWrite(_rs_pin, LOW);
  digitalWrite(_enable_pin, LOW);
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  //put the LCD into 4 bit or 8 bit mode
  if (! (_displayfunction & LCD_8BITMODE)) {
    // this is according to the Hitachi HD44780 datasheet
    // figure 24, pg 46

    // we start in 8bit mode, try to set 4 bit mode
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms

    // second try
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms
    
    // third go!
    writeNbits(0x03,4); 
    delayMicroseconds(150);

    // finally, set to 8-bit interface
    writeNbits(0x02,4); 
  } else {
    // this is according to the Hitachi HD44780 datasheet
    // page 45 figure 23

    // Send function set command sequence
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(4500);  // wait more than 4.1ms

    // second try
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(150);

    // third go
    command(LCD_FUNCTIONSET | _displayfunction);
  }

  // finally, set # lines, font size, etc.
  command(LCD_FUNCTIONSET | _displayfunction);  

  // turn the display on with no cursor or blinking default
  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
  display();

  // clear it off
  clear();

  // Initialize to default text direction (for romance languages)
  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
  // set the entry mode
  command(LCD_ENTRYMODESET | _displaymode);

}

void LiquidCrystalRus::setDRAMModel(uint8_t model) {
  _dram_model = model;
}

/********** high level commands, for the user! */
void LiquidCrystalRus::clear()
{
  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::home()
{
  command(LCD_RETURNHOME);  // set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)
{
  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  if ( row >= _numlines ) {
    row = _numlines-1;    // we count rows starting w/0
  }
  
  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}

// Turn the display on/off (quickly)
void LiquidCrystalRus::noDisplay() {
  _displaycontrol &= ~LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::display() {
  _displaycontrol |= LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turns the underline cursor on/off
void LiquidCrystalRus::noCursor() {
  _displaycontrol &= ~LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::cursor() {
  _displaycontrol |= LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turn on and off the blinking cursor
void LiquidCrystalRus::noBlink() {
  _displaycontrol &= ~LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::blink() {
  _displaycontrol |= LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// These commands scroll the display without changing the RAM
void LiquidCrystalRus::scrollDisplayLeft(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
void LiquidCrystalRus::scrollDisplayRight(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}

// This is for text that flows Left to Right
void LiquidCrystalRus::leftToRight(void) {
  _displaymode |= LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This is for text that flows Right to Left
void LiquidCrystalRus::rightToLeft(void) {
  _displaymode &= ~LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'right justify' text from the cursor
void LiquidCrystalRus::autoscroll(void) {
  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'left justify' text from the cursor
void LiquidCrystalRus::noAutoscroll(void) {
  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// Allows us to fill the first 8 CGRAM locations
// with custom characters
void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {
  location &= 0x7; // we only have 8 locations 0-7
  command(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++) {
    write(charmap[i]);
  }
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystalRus::command(uint8_t value) {
  send(value, LOW);
}

#if defined(ARDUINO) && ARDUINO >= 100
  size_t LiquidCrystalRus::write(uint8_t value)
#else
  void   LiquidCrystalRus::write(uint8_t value)
#endif
{
  uint8_t out_char=value;

  if (_dram_model == LCD_DRAM_WH1601) {  
    uint8_t ac=recv(LOW) & 0x7f;
    if (ac>7 && ac<0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));
  }

  if (value>=0x80) { // UTF-8 handling
    if (value >= 0xc0) {
      utf_hi_char = value - 0xd0;
    } else {
      value &= 0x3f;
      if (!utf_hi_char && (value == 1)) 
        send(0xa2,HIGH); // â
      else if ((utf_hi_char == 1) && (value == 0x11)) 
        send(0xb5,HIGH); // â¦
      else 
        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char<<6) - 0x10), HIGH);
    }    
  } else send(out_char, HIGH);
#if defined(ARDUINO) && ARDUINO >= 100
  return 1; // assume success 
#endif
}

/************ low level data pushing commands **********/

// write either command or data, with automatic 4/8-bit selection
void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    writeNbits(value,8); 
  } else {
    writeNbits(value>>4,4);
    writeNbits(value,4);
  }
}

// read  data, with automatic 4/8-bit selection
uint8_t LiquidCrystalRus::recv(uint8_t mode) {
  uint8_t retval;
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, HIGH);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    retval = readNbits(8); 
  } else {
    retval = readNbits(4) << 4;
    retval |= readNbits(4);
  }
  return retval;
}
void LiquidCrystalRus::pulseEnable() {
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(100);   // commands need > 37us to settle
}

void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], OUTPUT);
    digitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  pulseEnable();
}

uint8_t LiquidCrystalRus::readNbits(uint8_t n) {
  uint8_t retval=0;
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], INPUT);
  }

  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  
  for (int i = 0; i < n; i++) {
    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 << i):0;
  }

  digitalWrite(_enable_pin, LOW);

  return retval;
}


































































































































































































































#endif
++++++
#if defined (drsdre)
#include "LiquidCrystalRus.h"

#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <avr/pgmspace.h>

#if defined(ARDUINO) && ARDUINO >= 100
  #include "Arduino.h"
#else
  #include "WProgram.h"
#endif

// it is a russian alphabet translation
// except 0401 --> 0xa2 = â, 0451 --> 0xb5
const PROGMEM uint8_t utf_recode[] = 
       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
        };     

// When the display powers up, it is configured as follows:
//
// 1. Display clear
// 2. Function set: 
//    DL = 1; 8-bit interface data 
//    N = 0; 1-line display 
//    F = 0; 5x8 dot character font 
// 3. Display on/off control: 
//    D = 0; Display off 
//    C = 0; Cursor off 
//    B = 0; Blinking off 
// 4. Entry mode set: 
//    I/D = 1; Increment by 1 
//    S = 0; No shift 
//
// Note, however, that resetting the Arduino doesn't reset the LCD, so we
// can't assume that its in that state when a sketch starts (and the
// LiquidCrystal constructor is called).
// 
// modified 27 Jul 2011
// by Ilya V. Danilov http://mk90.ru/


LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  _rs_pin = rs;
  _rw_pin = rw;
  _enable_pin = enable;
  
  _data_pins[0] = d0;
  _data_pins[1] = d1;
  _data_pins[2] = d2;
  _data_pins[3] = d3; 
  _data_pins[4] = d4;
  _data_pins[5] = d5;
  _data_pins[6] = d6;
  _data_pins[7] = d7; 

  pinMode(_rs_pin, OUTPUT);
  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
  if (_rw_pin != 255) { 
    pinMode(_rw_pin, OUTPUT);
  }
  pinMode(_enable_pin, OUTPUT);
  
  if (fourbitmode)
    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
  else 
    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
  
  begin(16, 1);  
}

void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
  if (lines > 1) {
    _displayfunction |= LCD_2LINE;
  }
  _numlines = lines;
  _currline = 0;

  // for some 1 line displays you can select a 10 pixel high font
  if ((dotsize != 0) && (lines == 1)) {
    _displayfunction |= LCD_5x10DOTS;
  }

  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
  // according to datasheet, we need at least 40ms after power rises above 2.7V
  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
  delayMicroseconds(50000); 
  // Now we pull both RS and R/W low to begin commands
  digitalWrite(_rs_pin, LOW);
  digitalWrite(_enable_pin, LOW);
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  //put the LCD into 4 bit or 8 bit mode
  if (! (_displayfunction & LCD_8BITMODE)) {
    // this is according to the hitachi HD44780 datasheet
    // figure 24, pg 46

    // we start in 8bit mode, try to set 4 bit mode
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms

    // second try
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms
    
    // third go!
    writeNbits(0x03,4); 
    delayMicroseconds(150);

    // finally, set to 8-bit interface
    writeNbits(0x02,4); 
  } else {
    // this is according to the hitachi HD44780 datasheet
    // page 45 figure 23

    // Send function set command sequence
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(4500);  // wait more than 4.1ms

    // second try
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(150);

    // third go
    command(LCD_FUNCTIONSET | _displayfunction);
  }

  // finally, set # lines, font size, etc.
  command(LCD_FUNCTIONSET | _displayfunction);  

  // turn the display on with no cursor or blinking default
  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
  display();

  // clear it off
  clear();

  // Initialize to default text direction (for romance languages)
  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
  // set the entry mode
  command(LCD_ENTRYMODESET | _displaymode);

}

void LiquidCrystalRus::setDRAMModel(uint8_t model) {
  _dram_model = model;
}

/********** high level commands, for the user! */
void LiquidCrystalRus::clear()
{
  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::home()
{
  command(LCD_RETURNHOME);  // set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)
{
  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  if ( row >= _numlines ) {
    row = _numlines-1;    // we count rows starting w/0
  }
  
  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}

// Turn the display on/off (quickly)
void LiquidCrystalRus::noDisplay() {
  _displaycontrol &= ~LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::display() {
  _displaycontrol |= LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turns the underline cursor on/off
void LiquidCrystalRus::noCursor() {
  _displaycontrol &= ~LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::cursor() {
  _displaycontrol |= LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turn on and off the blinking cursor
void LiquidCrystalRus::noBlink() {
  _displaycontrol &= ~LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::blink() {
  _displaycontrol |= LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// These commands scroll the display without changing the RAM
void LiquidCrystalRus::scrollDisplayLeft(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
void LiquidCrystalRus::scrollDisplayRight(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}

// This is for text that flows Left to Right
void LiquidCrystalRus::leftToRight(void) {
  _displaymode |= LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This is for text that flows Right to Left
void LiquidCrystalRus::rightToLeft(void) {
  _displaymode &= ~LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'right justify' text from the cursor
void LiquidCrystalRus::autoscroll(void) {
  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'left justify' text from the cursor
void LiquidCrystalRus::noAutoscroll(void) {
  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// Allows us to fill the first 8 CGRAM locations
// with custom characters
void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {
  location &= 0x7; // we only have 8 locations 0-7
  command(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++) {
    write(charmap[i]);
  }
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystalRus::command(uint8_t value) {
  send(value, LOW);
}

#if defined(ARDUINO) && ARDUINO >= 100
  size_t LiquidCrystalRus::write(uint8_t value)
#else
  void   LiquidCrystalRus::write(uint8_t value)
#endif
{
  uint8_t out_char=value;

  if (_dram_model == LCD_DRAM_WH1601) {  
    uint8_t ac=recv(LOW) & 0x7f;
    if (ac>7 && ac<0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));
  }

  if (value>=0x80) { // UTF-8 handling
    if (value >= 0xc0) {
      utf_hi_char = value - 0xd0;
    } else {
      value &= 0x3f;
      if (!utf_hi_char && (value == 1)) 
        send(0xa2,HIGH); // â
      else if ((utf_hi_char == 1) && (value == 0x11)) 
        send(0xb5,HIGH); // â¦
      else 
        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char<<6) - 0x10), HIGH);
    }    
  } else send(out_char, HIGH);
#if defined(ARDUINO) && ARDUINO >= 100
  return 1; // assume sucess 
#endif
}

/************ low level data pushing commands **********/

// write either command or data, with automatic 4/8-bit selection
void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    writeNbits(value,8); 
  } else {
    writeNbits(value>>4,4);
    writeNbits(value,4);
  }
}

// read  data, with automatic 4/8-bit selection
uint8_t LiquidCrystalRus::recv(uint8_t mode) {
  uint8_t retval;
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, HIGH);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    retval = readNbits(8); 
  } else {
    retval = readNbits(4) << 4;
    retval |= readNbits(4);
  }
  return retval;
}
void LiquidCrystalRus::pulseEnable() {
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(100);   // commands need > 37us to settle
}

void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], OUTPUT);
    digitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  pulseEnable();
}

uint8_t LiquidCrystalRus::readNbits(uint8_t n) {
  uint8_t retval=0;
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], INPUT);
  }

  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  
  for (int i = 0; i < n; i++) {
    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 << i):0;
  }

  digitalWrite(_enable_pin, LOW);

  return retval;
}






























#endif
++++++


**--**-**--merge: Marlin_main.cpp

#if defined (upstream)
//this is dangerous if a mixing of serial and this happens
#endif
++++++
#if defined (drsdre)
//this is dangerous if a mixing of serial and this happsens
#endif
++++++
#if defined (upstream)
SERIAL_ECHOPGM(MSG_Enqueing);
#endif
++++++
#if defined (drsdre)
SERIAL_ECHOPGM("enqueing \"");
#endif
++++++
#if defined (upstream)
//this is dangerous if a mixing of serial and this happens
#endif
++++++
#if defined (drsdre)
//this is dangerous if a mixing of serial and this happsens
#endif
++++++
#if defined (upstream)
SERIAL_ECHOPGM(MSG_Enqueing);
#endif
++++++
#if defined (drsdre)
SERIAL_ECHOPGM("enqueing \"");
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
SET_INPUT(KILL_PIN);
#endif
++++++
#if defined (drsdre) &&  KILL_PIN>-1 )
pinMode(KILL_PIN,INPUT);
#endif
++++++
#if defined (upstream) && (defined(PS_DEFAULT_OFF) && (defined(PS_ON_PIN) && PS_ON_PIN > -1 &)
WRITE(PS_ON_PIN, PS_ON_ASLEEP);
#endif
++++++
#if defined (upstream)
// loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
#endif
++++++
#if defined (drsdre)
// loads data from EEPROM if available
#endif
++++++
#if defined (upstream)
servo_init();
#endif
++++++
#if defined (upstream)
_delay_ms(1000);
#endif
++++++
#if defined (upstream) && (defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1)
SET_OUTPUT(CONTROLLERFAN_PIN);
#endif
++++++
#if defined (upstream) && defined (DIGIPOT_I2C)
digipot_i2c_init();
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
pinMode(SERVO0_PIN, OUTPUT);
#endif
++++++
#if defined (upstream)
// Z_PROBE_SLED
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(card.logging)
          {
            process_commands();
          }
          else
          {
            SERIAL_PROTOCOLLNPGM(MSG_OK);
          }
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
SERIAL_PROTOCOLLNPGM(MSG_OK);
#endif
++++++
#if defined (upstream)
if (Stopped == true) {
              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
              LCD_MESSAGEPGM(MSG_STOPPED);
            }
#endif
++++++
#if defined (upstream)
//If command was e-stop process now
#endif
++++++
#if defined (upstream)
if(strcmp(cmdbuffer[bufindw], "M112") == 0)
          kill();
#endif
++++++
#if defined (upstream)
//If command was e-stop process now
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//'#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
while( !card.eof()  && buflen < BUFSIZE) {
    int16_t n=card.get();
    serial_char = (char)n;
    if(serial_char == '\n' || 
       serial_char == '\r' || 
       (serial_char == ':' && comment_mode == false) || 
       serial_count >= (MAX_CMD_SIZE - 1)||n==-1) 
    {
      if(card.eof()){
        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
        stoptime=millis();
        char time[30];
        unsigned long t=(stoptime-starttime)/1000;
        int hours, minutes;
        minutes=(t/60)%60;
        hours=t/60/60;
        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);
        SERIAL_ECHO_START;
        SERIAL_ECHOLN(time);
        lcd_setstatus(time);
        card.printingHasFinished();
        card.checkautostart(true);
        
      }
      if(!serial_count)
      {
        comment_mode = false; //for new command
        return; //if empty line
      }
      cmdbuffer[bufindw][serial_count] = 0; //terminate string
//      if(!comment_mode){
        fromsd[bufindw] = true;
        buflen += 1;
        bufindw = (bufindw + 1)%BUFSIZE;
//      }     
      comment_mode = false; //for new command
      serial_count = 0; //clear buffer
    }
    else
    {
      if(serial_char == ';') comment_mode = true;
      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
    }
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// if it occurs, stop_buffering is triggered and the buffer is ran dry.
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
if (axis == X_AXIS) {
    if (active_extruder != 0) {
      current_position[X_AXIS] = x_home_pos(active_extruder);
      min_pos[X_AXIS] =          X2_MIN_POS;
      max_pos[X_AXIS] =          max(extruder_offset[X_AXIS][1], X2_MAX_POS);
      return;
    }
    else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
      current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homing[X_AXIS];
      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homing[X_AXIS];
      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homing[X_AXIS],
                                  max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
      return;
    }
  }
#endif
++++++
#if defined (drsdre)
current_position[axis] = base_home_pos(axis) + add_homeing[axis];
#endif
++++++
#if defined (upstream) && defined (SCARA)
float homeposition[3];
#endif
++++++
#if defined (drsdre)
min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
#endif
++++++
#if defined (upstream) && defined (SCARA)
char i;
#endif
++++++
#if defined (drsdre)
max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];
#endif
++++++
#if defined (upstream) && defined (SCARA)
if (axis < 2)
   {
   
     for (i=0; i<3; i++)
     {
        homeposition[i] = base_home_pos(i); 
     }  
	// SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);
   //  SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);
   // Works out real Homeposition angles using inverse kinematics, 
   // and calculates homing offset using forward kinematics
     calculate_delta(homeposition);
     
    // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
     for (i=0; i<2; i++)
     {
        delta[i] -= add_homing[i];
     } 
     
    // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homing[X_AXIS]);
	// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homing[Y_AXIS]);
    // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
      
     calculate_SCARA_forward_Transform(delta);
     
    // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
    current_position[axis] = delta[axis];
    
    // SCARA home positions are based on configuration since the actual limits are determined by the 
    // inverse kinematic transform.
    min_pos[axis] =          base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));
    max_pos[axis] =          base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));
   } 
   else
   {
      current_position[axis] = base_home_pos(axis) + add_homing[axis];
      min_pos[axis] =          base_min_pos(axis) + add_homing[axis];
      max_pos[axis] =          base_max_pos(axis) + add_homing[axis];
   }
#endif
++++++
#if defined (upstream) && !defined (SCARA)
current_position[axis] = base_home_pos(axis) + add_homing[axis];
#endif
++++++
#if defined (drsdre)
return;
#endif
++++++
#if defined (drsdre)
return;
#endif
++++++
#if defined (upstream)
break;
#endif
++++++
#if defined (upstream)
break;
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
retracted_swap[active_extruder]=(code_seen('S') && code_value_long() == 1);
#endif
++++++
#if defined (drsdre)
if(!retracted) 
      {
        destination[X_AXIS]=current_position[X_AXIS];
        destination[Y_AXIS]=current_position[Y_AXIS];
        destination[Z_AXIS]=current_position[Z_AXIS]; 
        current_position[Z_AXIS]+=-retract_zlift;
        destination[E_AXIS]=current_position[E_AXIS]-retract_length; 
        feedrate=retract_feedrate;
        retracted=true;
        prepare_move();
      }
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
// checks for swap retract argument
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
retract(true,retracted_swap[active_extruder]);
#endif
++++++
#if defined (upstream) && !EXTRUDERS > 1
retract(true);
#endif
++++++
#if defined (upstream) && !EXTRUDERS > 1
retract(true);
#endif
++++++
#if defined (upstream)

#endif
++++++
#if defined (upstream)

#endif
++++++
#if defined (upstream)

#endif
++++++
#if defined (upstream)

#endif
++++++
#if defined (upstream)

#endif
:#endif
++++++
#if defined (upstream) && defined (SCARA)
if (i == X_AXIS || i == Y_AXIS) {
                	current_position[i] = code_value();  
		}
		else {
                current_position[i] = code_value()+add_homing[i];  
            	}
#endif
++++++
#if defined (drsdre)
current_position[i] = code_value()+add_homeing[i];
#endif
++++++
#if defined (upstream) && !defined (SCARA)
current_position[i] = code_value()+add_homing[i];
#endif
++++++
#if defined (upstream) && !defined (SCARA)
current_position[i] = code_value()+add_homing[i];
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false &&
            (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))
        {
          // Park old head: 1) raise 2) move to park position 3) lower
          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
          st_synchronize();
        }
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
// apply Y & Z extruder offset (x offset is already used in determining home pos)
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
current_position[Y_AXIS] = current_position[Y_AXIS] -
                     extruder_offset[Y_AXIS][active_extruder] +
                     extruder_offset[Y_AXIS][tmp_extruder];
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
current_position[Z_AXIS] = current_position[Z_AXIS] -
                     extruder_offset[Z_AXIS][active_extruder] +
                     extruder_offset[Z_AXIS][tmp_extruder];
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
active_extruder = tmp_extruder;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
// This function resets the max/min values - the current position may be overwritten below.
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
axis_is_at_home(X_AXIS);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE)
        {
          current_position[X_AXIS] = inactive_extruder_x_pos;
          inactive_extruder_x_pos = destination[X_AXIS];
        }
        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)
        {
          active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
          if (active_extruder == 0 || active_extruder_parked)
            current_position[X_AXIS] = inactive_extruder_x_pos;
          else
            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
          inactive_extruder_x_pos = destination[X_AXIS];
          extruder_duplication_enabled = false;
        }
        else
        {
          // record raised toolhead position for use by unpark
          memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
          raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
          active_extruder_parked = true;
          delayed_move_time = 0;
        }
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
//else DUAL_X_CARRIAGE
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
calculate_delta(current_position);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
// change cartesian kinematic  to  delta kinematic;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
//sent position to plan_set_position();
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],current_position[E_AXIS]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false &&
            (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))
        {
          // Park old head: 1) raise 2) move to park position 3) lower
          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
                current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
          st_synchronize();
        }
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
//else DUAL_X_CARRIAGE
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
calculate_delta(current_position);
#endif
++++++
#if defined (drsdre) && defined (FWRETRACT)
if(autoretract_enabled)
  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
  {
    float echange=destination[E_AXIS]-current_position[E_AXIS];
    if(echange<-MIN_RETRACT) //retract
    {
      if(!retracted) 
      {
      
      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
      float correctede=-echange-retract_length;
      //to generate the additional steps, not the destination is changed, but inversely the current position
      current_position[E_AXIS]+=-correctede; 
      feedrate=retract_feedrate;
      retracted=true;
      }
      
    }
    else 
      if(echange>MIN_RETRACT) //retract_recover
    {
      if(retracted) 
      {
      //current_position[Z_AXIS]+=-retract_zlift;
      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
      feedrate=retract_recover_feedrate;
      retracted=false;
      }
    }
    
  }
#endif
++++++
#if defined (drsdre)
//FWRETRACT
#endif
++++++
#if defined (upstream)
float negative_z_offset = 0;
#endif
++++++
#if defined (drsdre)
if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
if (Z_PROBE_OFFSET_FROM_EXTRUDER < 0) negative_z_offset = negative_z_offset + Z_PROBE_OFFSET_FROM_EXTRUDER;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
if (add_homing[Z_AXIS] < 0) negative_z_offset = negative_z_offset + add_homing[Z_AXIS];
#endif
++++++
#if defined (upstream)
if (target[Z_AXIS] < min_pos[Z_AXIS]+negative_z_offset) target[Z_AXIS] = min_pos[Z_AXIS]+negative_z_offset;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
if (Z_PROBE_OFFSET_FROM_EXTRUDER < 0) negative_z_offset = negative_z_offset + Z_PROBE_OFFSET_FROM_EXTRUDER;
#endif
++++++
#if defined (upstream)
if (target[Z_AXIS] < min_pos[Z_AXIS]+negative_z_offset) target[Z_AXIS] = min_pos[Z_AXIS]+negative_z_offset;
#endif
++++++
#if defined (upstream) && defined (SCARA)
//for now same as delta-code
#endif
++++++
#if defined (upstream)
// SCARA
#endif
++++++
#if defined (upstream) && defined (DELTA)
float difference[NUM_AXIS];
#endif
++++++
#if defined (upstream)
// DELTA
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
if (active_extruder_parked)
  {
    if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0)
    {
      // move duplicate extruder into correct duplication position.
      plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS],
          current_position[E_AXIS], max_feedrate[X_AXIS], 1);
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
      st_synchronize();
      extruder_duplication_enabled = true;
      active_extruder_parked = false;
    }
    else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) // handle unparking of head
    {
      if (current_position[E_AXIS] == destination[E_AXIS])
      {
        // this is a travel move - skit it but keep track of current position (so that it can later
        // be used as start of first non-travel move)
        if (delayed_move_time != 0xFFFFFFFFUL)
        {
          memcpy(current_position, destination, sizeof(current_position));
          if (destination[Z_AXIS] > raised_parked_position[Z_AXIS])
            raised_parked_position[Z_AXIS] = destination[Z_AXIS];
          delayed_move_time = millis();
          return;
        }
      }
      delayed_move_time = 0;
      // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
      plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS],    current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS],
          current_position[E_AXIS], min(max_feedrate[X_AXIS],max_feedrate[Y_AXIS]), active_extruder);
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
          current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
      active_extruder_parked = false;
    }
  }
#endif
++++++
#if defined (upstream)
//DUAL_X_CARRIAGE
#endif
++++++
#if defined (upstream)
// !(DELTA || SCARA)
#endif
++++++
#if defined (upstream) && (defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1)
if ((millis() - lastMotor) >= (CONTROLLERFAN_SECS*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...
    {
        digitalWrite(CONTROLLERFAN_PIN, 0);
        analogWrite(CONTROLLERFAN_PIN, 0);
    }
    else
    {
        // allows digital or PWM fan output to be used (see M42 handling)
        digitalWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);
        analogWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);
    }
#endif
++++++
#if defined (drsdre) && defined (CONTROLLERFAN_PIN)
if ((millis() - lastMotor) >= (CONTROLLERFAN_SEC*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...   
    {
      WRITE(CONTROLLERFAN_PIN, LOW); //... turn the fan off
    }
    else
    {
      WRITE(CONTROLLERFAN_PIN, HIGH); //... turn the fan on
    }
#endif
++++++
#if defined (upstream)
(bool ignore_stepper_queue/*=false*/)
#endif
++++++
#if defined (drsdre)
()
#endif
++++++
#if defined (upstream)
//default argument set in Marlin.h
#endif
++++++
#if defined (upstream)
(blocks_queued() == false && ignore_stepper_queue == false)
#endif
++++++
#if defined (drsdre)
(blocks_queued() == false)
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)

       killCount++;
    

#endif
++++++
#if defined (drsdre) &&  KILL_PIN>-1 )kill();
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
else if (killCount > 0)
    {
       killCount--;
    }
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
else if (killCount > 0)
    {
       killCount--;
    }
#endif
++++++
#if defined (upstream) && defined (EXTRUDER_RUNOUT_PREVENT)
plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
#endif
++++++
#if defined (drsdre) && defined (EXTRUDER_RUNOUT_PREVENT)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], 
                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], 
                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
static int killCount = 0;
#endif
++++++
#if defined (upstream) && (defined(HOME_PIN) && HOME_PIN > -1)
static int homeDebounceCount = 0;
#endif
++++++
#if defined (upstream)
if(buflen < (BUFSIZE-1))
    get_command();
#endif
++++++
#if defined (upstream) && defined (CHDK)
//Check if pin should be set to LOW after M240 set it to HIGH
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
// Check if the kill button was pressed and wait just in case it was an accidental
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
// Exceeded threshold and we can confirm that it was not accidental
#endif
++++++
#if defined (upstream) && (defined(HOME_PIN) && HOME_PIN > -1)
// Check to see if we have to home, use poor man's debouncer
#endif
++++++
#if defined (upstream) && defined(DUAL_X_CARRIAGE)
// handle delayed move timeout
#endif
++++++
#if defined (upstream) && defined (TEMP_STAT_LEDS)
handle_status_leds();
#endif
++++++
#if defined (upstream) && (defined(PS_ON_PIN) && PS_ON_PIN > -1)
pinMode(PS_ON_PIN,INPUT);
#endif
++++++
#if defined (drsdre)
if(PS_ON_PIN > -1) pinMode(PS_ON_PIN,INPUT);
#endif
++++++
#if defined (upstream)
// FMC small patch to update the LCD before ending
#endif
++++++
#if defined (upstream)
case 221:
          SERIAL_ECHO(MSG_M221_INVALID_EXTRUDER);
          break;
      
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
float x_tmp, y_tmp, z_tmp, real_z;
#endif
++++++
#if defined (drsdre)
void set_extskipwindow_coordinates()
{
  float a = 0, b = 0, c = 0, d = 0;
  if(code_seen('A')) {
    a = code_value();
    if(code_seen('B')) {
      b = code_value();
      if(code_seen('C')) {
        c = code_value();
        if(code_seen('D')) {
          d = code_value();         
        }
      }
    }
  }
  set_extuderskip_window(a, b, c, d);
}
#endif
++++++
#if defined (upstream) && defined (DELTA)
void recalc_delta_settings(float radius, float diagonal_rod)
{
	 delta_tower1_x= -SIN_60*radius; // front left tower
	 delta_tower1_y= -COS_60*radius;	   
	 delta_tower2_x=  SIN_60*radius; // front right tower
	 delta_tower2_y= -COS_60*radius;	   
	 delta_tower3_x= 0.0;                  // back middle tower
	 delta_tower3_y= radius;
	 delta_diagonal_rod_2= sq(diagonal_rod);
}
#endif
++++++
#if defined (upstream) && (defined(FAN_PIN) && CONTROLLERFAN_PIN == FAN_PIN && (defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN > -1 &)
#error "You cannot set CONTROLLERFAN_PIN equal to FAN_PIN"
#endif
++++++
#if defined (upstream) && defined (SCARA)
void calculate_SCARA_forward_Transform(float f_scara[3])
{
  // Perform forward kinematics, and place results in delta[3]
  // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
  
  float x_sin, x_cos, y_sin, y_cos;
  
    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);
    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);
  
    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
   
  //  SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);
  //  SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);
  //  SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);
  //  SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);
  
    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta
    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi
	
    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);
    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
}
#endif
++++++
#if defined (upstream) && defined (TEMP_STAT_LEDS)
static bool blue_led = false;
#endif
++++++
#if defined (upstream)
float calculate_volumetric_multiplier(float diameter) {
	float area = .0;
	float radius = .0;

	radius = diameter * .5;
	if (! volumetric_enabled || radius == 0) {
		area = 1;
	}
	else {
		area = M_PI * pow(radius, 2);
	}

	return 1.0 / area;
}
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
#include "vector_3.h"
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && defined (AUTO_BED_LEVELING_GRID) )
#include "qr_solve.h"
#endif
++++++
#if defined (upstream)
// ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (upstream)
#include "math.h"
#endif
++++++
#if defined (upstream) && defined (BLINKM)
#include "BlinkM.h"
#endif
++++++
#if defined (upstream) && NUM_SERVOS > 0
#include "Servo.h"
#endif
++++++
#if defined (upstream)
#define VERSION_STRING  "1.0.2"
#endif
++++++
#if defined (drsdre)
#define VERSION_STRING  "1.0.0"
#endif
++++++
#if defined (upstream)
// look here for descriptions of G-codes: http://linuxcnc.org/handbook/gcode/g-code.html
#endif
++++++
#if defined (drsdre)
// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
#endif
++++++
#if defined (upstream)
// G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
#endif
++++++
#if defined (upstream)
// G92 - Set current position to coordinates given
#endif
++++++
#if defined (drsdre)
// G92 - Set current position to cordinates given
#endif
++++++
#if defined (upstream)
// M Codes
#endif
++++++
#if defined (drsdre)
//RepRap M Codes
#endif
++++++
#if defined (drsdre)
// M104 - Set extruder target temp
#endif
++++++
#if defined (upstream)
// M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
#endif
++++++
#if defined (upstream)
// M104 - Set extruder target temp
#endif
++++++
#if defined (upstream)
// M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
#endif
++++++
#if defined (upstream)
// M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
#endif
++++++
#if defined (drsdre)
// M190 - Wait for bed current temp to reach target temp.
#endif
++++++
#if defined (upstream)
// M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
#endif
++++++
#if defined (drsdre)
// M200 - Set filament diameter
#endif
++++++
#if defined (upstream)
//        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
#endif
++++++
#if defined (upstream)
// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
#endif
++++++
#if defined (drsdre)
// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
#endif
++++++
#if defined (upstream)
// M206 - set additional homing offset
#endif
++++++
#if defined (drsdre)
// M206 - set additional homeing offset
#endif
++++++
#if defined (upstream)
// M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
#endif
++++++
#if defined (drsdre)
// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
#endif
++++++
#if defined (upstream)
// M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
#endif
++++++
#if defined (upstream)
// M250 - Set LCD contrast C<contrast value> (value 0..63)
#endif
++++++
#if defined (upstream)
// M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
#endif
++++++
#if defined (drsdre)
// M302 - Allow cold extrudes
#endif
++++++
#if defined (upstream)
// M401 - Lower z-probe if present
#endif
++++++
#if defined (drsdre)
// M500 - stores paramters in EEPROM
#endif
++++++
#if defined (upstream)
// M402 - Raise z-probe if present
#endif
++++++
#if defined (upstream)
// M503 - print the current settings (from memory not from EEPROM)
#endif
++++++
#if defined (drsdre)
// M503 - print the current settings (from memory not from eeprom)
#endif
++++++
#if defined (upstream)
// M665 - set delta configurations
#endif
++++++
#if defined (upstream)
// ************ SCARA Specific - This can change to suit future G-code regulations
#endif
++++++
#if defined (upstream)
int extruder_multiply[EXTRUDERS] = {100
  #if EXTRUDERS > 1
    , 100
    #if EXTRUDERS > 2
      , 100
    #endif
  #endif
};
#endif
++++++
#if defined (upstream)
float add_homing[3]={0,0,0};
#endif
++++++
#if defined (drsdre)
float add_homeing[3]={0,0,0};
#endif
++++++
#if defined (upstream) && defined (DELTA)
float endstop_adj[3]={0,0,0};
#endif
++++++
#if defined (upstream)
bool axis_known_position[3] = {false, false, false};
#endif
++++++
#if defined (drsdre)
// Extruder offset, only in XY plane
#endif
++++++
#if defined (upstream)
float zprobe_zoffset;
#endif
++++++
#if defined (drsdre) && EXTRUDERS > 1
float extruder_offset[2][EXTRUDERS] = { 
#if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)
  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y 
#endif
};
#endif
++++++
#if defined (upstream)
// Extruder offset
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && !defined (DUAL_X_CARRIAGE) )
#define NUM_EXTRUDER_OFFSETS 2
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DUAL_X_CARRIAGE) )
#define NUM_EXTRUDER_OFFSETS 3
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
float extruder_offset[NUM_EXTRUDER_OFFSETS][EXTRUDERS] = {
#if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)
  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y
#endif
};
#endif
++++++
#if defined (upstream) && defined (SERVO_ENDSTOPS)
int servo_endstops[] = SERVO_ENDSTOPS;
#endif
++++++
#if defined (drsdre) && defined (FWRETRACT)
bool autoretract_enabled=true;
#endif
++++++
#if defined (upstream) && defined (SERVO_ENDSTOPS)
int servo_endstop_angles[] = SERVO_ENDSTOP_ANGLES;
#endif
++++++
#if defined (drsdre) && defined (FWRETRACT)
bool retracted=false;
#endif
++++++
#if defined (upstream) && defined (BARICUDA)
int ValvePressure=0;
#endif
++++++
#if defined (drsdre) && defined (FWRETRACT)
float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
#endif
++++++
#if defined (upstream) && defined (BARICUDA)
int EtoPPressure=0;
#endif
++++++
#if defined (drsdre) && defined (FWRETRACT)
float retract_recover_length=0, retract_recover_feedrate=8*60;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
bool autoretract_enabled=false;
#endif
++++++
#if defined (upstream) && (defined (ULTIPANEL) && defined (PS_DEFAULT_OFF) )
bool powersupply = false;
#endif
++++++
#if defined (upstream) && (!defined (PS_DEFAULT_OFF) && defined (ULTIPANEL) )
bool powersupply = true;
#endif
++++++
#if defined (upstream) && defined (DELTA)
float delta[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (upstream) && defined (SCARA)
// Build size scaling
#endif
++++++
#if defined (upstream)
bool cancel_heatup = false ;
#endif
++++++
#if defined (upstream) && defined (FILAMENT_SENSOR)
//Variables for Filament Sensor input 
#endif
++++++
#if defined (upstream)
const char errormagic[] PROGMEM = "Error:";
#endif
++++++
#if defined (upstream)
//=============================Private Variables=============================
#endif
++++++
#if defined (drsdre)
//=============================private variables=============================
#endif
++++++
#if defined (upstream) && !defined (DELTA)
static float delta[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (upstream)
// just a pointer to find chars in the command string like X, Y, Z, E, etc
#endif
++++++
#if defined (drsdre)
// just a pointer to find chars in the cmd string like X, Y, Z, E, etc
#endif
++++++
#if defined (upstream) && NUM_SERVOS > 0
Servo servos[NUM_SERVOS];
#endif
++++++
#if defined (upstream)
bool CooldownNoWait = true;
#endif
++++++
#if defined (upstream) && defined (CHDK)
unsigned long chdkHigh = 0;
#endif
++++++
#if defined (upstream)
//=============================Routines======================================
#endif
++++++
#if defined (drsdre)
//=============================ROUTINES=============================
#endif
++++++
#if defined (drsdre)
void set_extskipwindow_coordinates();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
#include "SdFatUtil.h"
#endif
++++++
#if defined (upstream)
//!SDSUPPORT
#endif
++++++
#if defined (upstream)
// Set home pin
#endif
++++++
#if defined (upstream)
void servo_init()
{
  #if (NUM_SERVOS >= 1) && defined(SERVO0_PIN) && (SERVO0_PIN > -1)
    servos[0].attach(SERVO0_PIN);
  #endif
  #if (NUM_SERVOS >= 2) && defined(SERVO1_PIN) && (SERVO1_PIN > -1)
    servos[1].attach(SERVO1_PIN);
  #endif
  #if (NUM_SERVOS >= 3) && defined(SERVO2_PIN) && (SERVO2_PIN > -1)
    servos[2].attach(SERVO2_PIN);
  #endif
  #if (NUM_SERVOS >= 4) && defined(SERVO3_PIN) && (SERVO3_PIN > -1)
    servos[3].attach(SERVO3_PIN);
  #endif
  #if (NUM_SERVOS >= 5)
    #error "TODO: enter initalisation code for more servos"
  #endif

  // Set position of Servo Endstops that are defined
  #ifdef SERVO_ENDSTOPS
  for(int8_t i = 0; i < 3; i++)
  {
    if(servo_endstops[i] > -1) {
      servos[servo_endstops[i]].write(servo_endstop_angles[i * 2 + 1]);
    }
  }
  #endif

  #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0)
  delay(PROBE_SERVO_DEACTIVATION_DELAY);
  servos[servo_endstops[Z_AXIS]].detach();
  #endif
}
#endif
++++++
#if defined (upstream) && (defined (DUAL_X_CARRIAGE) && (EXTRUDERS == 1 || defined(COREXY) \
      || !defined(X2_ENABLE_PIN) || !defined(X2_STEP_PIN) || !defined(X2_DIR_PIN) \
      || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \
      || !defined(X_MAX_PIN) || X_MAX_PIN < 0 &)
#error "Missing or invalid definitions for DUAL_X_CARRIAGE mode."
#endif
++++++
#if defined (upstream) && (defined (DUAL_X_CARRIAGE) && (X_HOME_DIR != -1 || X2_HOME_DIR != 1 &)
#error "Please use canonical x-carriage assignment"
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
#define DXC_FULL_CONTROL_MODE 0
#endif
++++++
#if defined (upstream)
//DUAL_X_CARRIAGE
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && defined (AUTO_BED_LEVELING_GRID) )
static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
{
    vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);
    planeNormal.debug("planeNormal");
    plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
    //bedLevel.debug("bedLevel");

    //plan_bed_level_matrix.debug("bed level before");
    //vector_3 uncorrected_position = plan_get_position_mm();
    //uncorrected_position.debug("position before");

    vector_3 corrected_position = plan_get_position();
//    corrected_position.debug("position after");
    current_position[X_AXIS] = corrected_position.x;
    current_position[Y_AXIS] = corrected_position.y;
    current_position[Z_AXIS] = corrected_position.z;

    // put the bed at 0 so we don't go below it.
    current_position[Z_AXIS] = zprobe_zoffset; // in the lsq we reach here after raising the extruder due to the loop structure

    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
}
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
// not AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (upstream)
// #ifdef ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (upstream)
void refresh_cmd_timeout(void)
{
  previous_millis_cmd = millis();
}
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
void retract(bool retracting, bool swapretract = false) {
    if(retracting && !retracted[active_extruder]) {
      destination[X_AXIS]=current_position[X_AXIS];
      destination[Y_AXIS]=current_position[Y_AXIS];
      destination[Z_AXIS]=current_position[Z_AXIS];
      destination[E_AXIS]=current_position[E_AXIS];
      if (swapretract) {
        current_position[E_AXIS]+=retract_length_swap/volumetric_multiplier[active_extruder];
      } else {
        current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
      }
      plan_set_e_position(current_position[E_AXIS]);
      float oldFeedrate = feedrate;
      feedrate=retract_feedrate*60;
      retracted[active_extruder]=true;
      prepare_move();
      current_position[Z_AXIS]-=retract_zlift;
#ifdef DELTA
      calculate_delta(current_position); // change cartesian kinematic to  delta kinematic;
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#else
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
      prepare_move();
      feedrate = oldFeedrate;
    } else if(!retracting && retracted[active_extruder]) {
      destination[X_AXIS]=current_position[X_AXIS];
      destination[Y_AXIS]=current_position[Y_AXIS];
      destination[Z_AXIS]=current_position[Z_AXIS];
      destination[E_AXIS]=current_position[E_AXIS];
      current_position[Z_AXIS]+=retract_zlift;
#ifdef DELTA
      calculate_delta(current_position); // change cartesian kinematic  to  delta kinematic;
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#else
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
      //prepare_move();
      if (swapretract) {
        current_position[E_AXIS]-=(retract_length_swap+retract_recover_length_swap)/volumetric_multiplier[active_extruder]; 
      } else {
        current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
      }
      plan_set_e_position(current_position[E_AXIS]);
      float oldFeedrate = feedrate;
      feedrate=retract_recover_feedrate*60;
      retracted[active_extruder]=false;
      prepare_move();
      feedrate = oldFeedrate;
    }
  }
#endif
++++++
#if defined (upstream)
//FWRETRACT
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++


**--**-**--merge: MarlinSerial.cpp

#if defined (upstream) && ((F_CPU == 16000000UL && SERIAL_PORT == 0 && )(defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H) && )!defined (AT90USB) )
// hard-coded exception for compatibility with the bootloader shipped
#endif
++++++
#if defined (drsdre) && ((F_CPU == 16000000UL && SERIAL_PORT == 0 && )(defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H) && )!defined (AT90USB) )
// hardcoded exception for compatibility with the bootloader shipped
#endif
++++++
#if defined (upstream) && !defined (AT90USB)
// this is so I can support Attiny series and any other chip without a UART
#endif
++++++
#if defined (drsdre) && !defined (AT90USB)
// this is so I can support Attiny series and any other chip without a uart
#endif
++++++
#if defined (upstream)
// For AT90USB targets use the UART for BT interfacing
#endif
++++++
#if defined (upstream) && (defined(AT90USB) && defined (BTENABLED))
HardwareSerial bt;
#endif
++++++


**--**-**--merge: motion_control.cpp

#if defined (upstream)
//20141002:full circle for G03 did not work, e.g. G03 X80 Y80 I20 J0 F2000 is giving an Angle of zero so head is not moving
#endif
++++++


**--**-**--merge: planner.cpp



**--**-**--merge: qr_solve.cpp



**--**-**--merge: Sd2Card.cpp

#if defined (upstream) && (defined (SDSUPPORT) && defined (SD_CHECK_AND_RETRY) )
uint8_t retryCnt = 3;
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && defined (SD_CHECK_AND_RETRY) )

    uint16_t calcCrc = CRC_CCITT(dst, count);
    uint16_t recvCrc = spiRec() << 8;
    recvCrc |= spiRec();
    if (calcCrc != recvCrc)
    {
        error(SD_CARD_ERROR_CRC);
        goto fail;
    }
  

#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && defined (SD_CHECK_AND_RETRY) )
static const uint16_t crctab[] PROGMEM = {
  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};
#endif
++++++


**--**-**--merge: SdBaseFile.cpp



**--**-**--merge: SdFatUtil.cpp

#if defined (upstream) && (defined (SDSUPPORT) && !defined (__arm__) )
char top;
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
extern int  __bss_end;
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && !defined (__arm__) )
return __brkval ? &top - __brkval : &top - &__bss_end;
#endif
++++++
#if defined (drsdre) && defined (SDSUPPORT)
extern int* __brkval;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
/** Amount of free RAM
 * \return The number of free bytes.
 */
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && defined (__arm__) )
extern "C" char* sbrk(int incr);
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && !defined (__arm__) )
// __arm__
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// __arm
#endif
++++++


**--**-**--merge: SdFile.cpp



**--**-**--merge: SdVolume.cpp



**--**-**--merge: Servo.cpp



**--**-**--merge: stepper.cpp

#if defined (upstream)
MYSERIAL.print(MSG_STEPPER_TOO_HIGH);
#endif
++++++
#if defined (drsdre)
MYSERIAL.print(MSG_STEPPER_TO_HIGH);
#endif
++++++
#if defined (upstream)
// make a note of the number of step loops required at nominal speed
#endif
++++++
#if defined (upstream)
static unsigned short step_loops_nominal;
#endif
++++++
#if defined (upstream) && defined (MOTOR_CURRENT_PWM_XY_PIN)
int motor_current_setting[3] = DEFAULT_PWM_MOTOR_CURRENT;
#endif
++++++
#if defined (drsdre) && defined (ADVANCE)
unsigned char old_OCR0A;
#endif
++++++
#if defined (drsdre)
// ADVANCE
#endif
++++++


**--**-**--merge: temperature.cpp



**--**-**--merge: ultralcd.cpp

#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_status_screen, 0, false);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
encoderPosition = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
cancel_heatup = true;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW0, &extruder_multiply[0], 10, 999);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW1, &extruder_multiply[1], 10, 999);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW2, &extruder_multiply[2], 10, 999);
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (BABYSTEP_XY) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//BABYSTEP_XY
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (MENU_ADDAUTOSTART) && defined (SDSUPPORT) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (SDSUPPORT) && defined (ULTIPANEL) )
//MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 &)
MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 &)
MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (EMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 && )TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(gcode, MSG_COOLDOWN, PSTR("M104 S0\nM140 S0"));
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (EMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 && )TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && PS_ON_PIN > -1 && defined (ULTIPANEL) )
if (powersupply)
    {
        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
    }else{
        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("X"), X_AXIS, X_MIN_POS, X_MAX_POS);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (encoderPosition != 0)
    {
        current_position[X_AXIS] += float((int)encoderPosition) * move_menu_scale;
        if (current_position[X_AXIS] < X_MIN_POS)
            current_position[X_AXIS] = X_MIN_POS;
        if (current_position[X_AXIS] > X_MAX_POS)
            current_position[X_AXIS] = X_MAX_POS;
        encoderPosition = 0;
        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 600, active_extruder);
        lcdDrawUpdate = 1;
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("Y"), Y_AXIS, Y_MIN_POS, Y_MAX_POS);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (encoderPosition != 0)
    {
        current_position[Y_AXIS] += float((int)encoderPosition) * move_menu_scale;
        if (current_position[Y_AXIS] < Y_MIN_POS)
            current_position[Y_AXIS] = Y_MIN_POS;
        if (current_position[Y_AXIS] > Y_MAX_POS)
            current_position[Y_AXIS] = Y_MAX_POS;
        encoderPosition = 0;
        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 600, active_extruder);
        lcdDrawUpdate = 1;
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("Z"), Z_AXIS, Z_MIN_POS, Z_MAX_POS);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (encoderPosition != 0)
    {
        current_position[Z_AXIS] += float((int)encoderPosition) * move_menu_scale;
        if (current_position[Z_AXIS] < Z_MIN_POS)
            current_position[Z_AXIS] = Z_MIN_POS;
        if (current_position[Z_AXIS] > Z_MAX_POS)
            current_position[Z_AXIS] = Z_MAX_POS;
        encoderPosition = 0;
        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 60, active_extruder);
        lcdDrawUpdate = 1;
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA) && defined (ULTIPANEL) )
calculate_delta(current_position);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], 20, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (DELTA) && defined (ULTIPANEL) )
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_move_menu_axis);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
{
        lcd_quick_feedback();
        currentMenu = lcd_move_menu_axis;
        encoderPosition = 0;
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move Z", lcd_move_z);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Extruder", lcd_move_e);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move X", lcd_move_x);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move Y", lcd_move_y);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move 10mm", lcd_move_menu_10mm);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move 1mm", lcd_move_menu_1mm);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move 0.1mm", lcd_move_menu_01mm);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//    MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
// set up temp variables - undo the default scaling
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
// i is typically a small value so allows values below 1
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
//TODO, I and D should have a PID_dT multiplier (Ki = PID_I * PID_dT, Kd = PID_D / PID_dT)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I, &raw_Ki, 0.01, 9990, copy_and_scalePID_i);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float52, MSG_PID_I, &Ki, 1, 9990);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D, &raw_Kd, 1, 9990, copy_and_scalePID_d);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (PIDTEMP) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float52, MSG_PID_D, &Kd, 1, 9990);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ENABLE_AUTO_BED_LEVELING) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, reset_acceleration_rates)
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, reset_acceleration_rates)
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000, reset_acceleration_rates)
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, reset_acceleration_rates)
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(bool, "Endstop abort", &abort_on_endstop_hit);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (SCARA) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS],0.5,2);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (FWRETRACT) )
MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (FWRETRACT) )
MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (lcdDrawUpdate == 0 && LCD_CLICKED == 0)
        return;
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
for(uint16_t i=0;i<fileCnt;i++)
    {
        if (_menuItemNr == _lineNr)
        {
            card.getfilename(i);
            if (card.filenameIsDir)
            {
                MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
            }else{
                MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
            }
        }else{
            MENU_ITEM_DUMMY();
        }
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(data);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
currentMenu = data;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(data);
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
currentMenu = data;
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
SET_INPUT(BTN_EN1);
#endif
++++++
#if defined (drsdre) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
pinMode(BTN_EN1,INPUT);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
SET_INPUT(BTN_EN2);
#endif
++++++
#if defined (drsdre) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
pinMode(BTN_EN2,INPUT);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && BTN_ENC > 0 )
SET_INPUT(BTN_ENC);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) )
pinMode(SHIFT_CLK,OUTPUT);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) )
// Not NEWPANEL
#endif
++++++
#if defined (upstream) && (defined (SR_LCD_2W_NL) && defined (ULTRA_LCD) && !defined (NEWPANEL) )
// Non latching 2 wire shift register
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) && !defined(SHIFT_CLK) && defined (ULTIPANEL) )
#error ULTIPANEL requires an encoder
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) )
// SR_LCD_2W_NL
#endif
++++++
#if defined (upstream) && ((defined (SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0) && )defined (ULTRA_LCD) )
pinMode(SDCARDDETECT,INPUT);
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
//(SDCARDDETECT > 0)
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
//(SDCARDDETECT > -1)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (LCD_HAS_SLOW_BUTTONS) )
slow_buttons = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_Z_UP) {
        		reprapworld_keypad_move_z_up();
        	}
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (encoderDiff)
        {
            lcdDrawUpdate = 1;
            encoderPosition += encoderDiff;
            encoderDiff = 0;
            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
        }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN) {
        		reprapworld_keypad_move_z_down();
        	}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT) {
        		reprapworld_keypad_move_x_left();
        	}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT) {
        		reprapworld_keypad_move_x_right();
        	}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN) {
        		reprapworld_keypad_move_y_down();
        	}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_Y_UP) {
        		reprapworld_keypad_move_y_up();
        	}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
if (REPRAPWORLD_KEYPAD_MOVE_HOME) {
        		reprapworld_keypad_move_home();
        	}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP)
        {
            lcdDrawUpdate = 1;
            encoderPosition += encoderDiff / ENCODER_PULSES_PER_STEP;
            encoderDiff = 0;
            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
        }
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
// Changes due to different driver architecture of the DOGM display
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
blink++;
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
// Variable for fan animation and alive dot
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
u8g.firstPage();
#endif
++++++
#if defined (upstream) && (defined (LCD_HAS_STATUS_INDICATORS) && defined (ULTRA_LCD) )
lcd_implementation_update_indicators();
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_next_update_millis = millis() + LCD_UPDATE_INTERVAL;
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
lcd_next_update_millis = millis() + 100;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP)
        {
            lcdDrawUpdate = 1;
            encoderPosition += encoderDiff / ENCODER_PULSES_PER_STEP;
            encoderDiff = 0;
            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
        }
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
// Changes due to different driver architecture of the DOGM display
#endif
++++++
#if defined (upstream) && (defined (LCD_HAS_STATUS_INDICATORS) && defined (ULTRA_LCD) )
lcd_implementation_update_indicators();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (LCD_HAS_SLOW_BUTTONS) )
slow_buttons = lcd_implementation_read_slow_buttons();
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && (SDCARDDETECT > -1) )
if((IS_SD_INSERTED != lcd_oldcardstatus))
    {
        lcdDrawUpdate = 2;
        lcd_oldcardstatus = IS_SD_INSERTED;
        lcd_implementation_init(); // to maybe revive the lcd if static electricty killed it.
        
        if(lcd_oldcardstatus)
        {
            card.initsd();
            LCD_MESSAGEPGM(MSG_SD_INSERTED);
        }
        else
        {
            card.release();
            LCD_MESSAGEPGM(MSG_SD_REMOVED);
        }
    }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_finishstatus();
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
lcdDrawUpdate = 2;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_finishstatus();
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
lcdDrawUpdate = 2;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc |= B01;
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc|=(1<<0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc |= B10;
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc|=(1<<1);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (LCD_HAS_SLOW_BUTTONS) )
buttons |= slow_buttons;
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
// for the reprapworld_keypad
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0] = xx >= 1000 ? (xx / 1000) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 1000)
    conv[0]=(xx/1000)%10+'0';
  else
    conv[0]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[1] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 100)
    conv[1]=(xx/100)%10+'0';
  else
    conv[1]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[2] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 10)
    conv[2]=(xx/10)%10+'0';
  else
    conv[2]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[3] = xx % 10 + '0';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
conv[3]=(xx)%10+'0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0] = xx >= 10000 ? (xx / 10000) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 10000)
    conv[0]=(xx/10000)%10+'0';
  else
    conv[0]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[1] = xx >= 1000 ? (xx / 1000) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 1000)
    conv[1]=(xx/1000)%10+'0';
  else
    conv[1]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[2] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 100)
    conv[2]=(xx/100)%10+'0';
  else
    conv[2]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[3] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
if (xx >= 10)
    conv[3]=(xx/10)%10+'0';
  else
    conv[3]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[4] = xx % 10 + '0';
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
conv[4]=(xx)%10+'0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
int8_t encoderDiff;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (FILAMENT_LCD_DISPLAY) )
unsigned long message_millis = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static float manual_feedrate[] = MANUAL_FEEDRATE;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// ULTIPANEL
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
#include "dogm_lcd_implementation.h"
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/** forward declarations **/
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
/** forward declerations **/
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void copy_and_scalePID_i();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
extern bool powersupply;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_control_volumetric_menu();
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_set_contrast();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
static void lcd_delta_calibrate_menu();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//Cause an LCD refresh, and give the user visual or audible feedback that something has happened
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//Cause an LCD refresh, and give the user visual or audiable feedback that something has happend
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void menu_action_setting_edit_float43(const char* pstr, float* ptr, float minValue, float maxValue);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callbackFunc);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined(LCD_I2C_VIKI) && !defined (ENCODER_PULSES_PER_STEP) && defined (ULTIPANEL) )
#define ENCODER_PULSES_PER_STEP 1
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (ENCODER_STEPS_PER_MENU_ITEM) && defined(LCD_I2C_VIKI) && defined (ULTIPANEL) )
#define ENCODER_STEPS_PER_MENU_ITEM 2
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined(LCD_I2C_VIKI) && !defined (ENCODER_PULSES_PER_STEP) && defined (ULTIPANEL) )
#define ENCODER_PULSES_PER_STEP 1
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define START_MENU() do { \
    if (encoderPosition > 0x8000) encoderPosition = 0; \
    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM < currentMenuViewOffset) currentMenuViewOffset = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM;\
    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
    bool wasClicked = LCD_CLICKED;\
    for(uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
        _menuItemNr = 0;
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define START_MENU() do { \
    if (encoderPosition > 0x8000) encoderPosition = 0; \
    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM < currentMenuViewOffset) currentMenuViewOffset = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM;\
    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \
    for(uint8_t _drawLineNr = 0; _drawLineNr < LCD_HEIGHT; _drawLineNr++, _lineNr++) { \
        _menuItemNr = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define MENU_ITEM(type, label, args...) do { \
    if (_menuItemNr == _lineNr) { \
        if (lcdDrawUpdate) { \
            const char* _label_pstr = PSTR(label); \
            if ((encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \
                lcd_implementation_drawmenu_ ## type ## _selected (_drawLineNr, _label_pstr , ## args ); \
            }else{\
                lcd_implementation_drawmenu_ ## type (_drawLineNr, _label_pstr , ## args ); \
            }\
        }\
        if (wasClicked && (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) {\
            lcd_quick_feedback(); \
            menu_action_ ## type ( args ); \
            return;\
        }\
    }\
    _menuItemNr++;\
} while(0)
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define MENU_ITEM(type, label, args...) do { \
    if (_menuItemNr == _lineNr) { \
        if (lcdDrawUpdate) { \
            const char* _label_pstr = PSTR(label); \
            if ((encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \
                lcd_implementation_drawmenu_ ## type ## _selected (_drawLineNr, _label_pstr , ## args ); \
            }else{\
                lcd_implementation_drawmenu_ ## type (_drawLineNr, _label_pstr , ## args ); \
            }\
        }\
        if (LCD_CLICKED && (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) {\
            lcd_quick_feedback(); \
            menu_action_ ## type ( args ); \
            return;\
        }\
    }\
    _menuItemNr++;\
} while(0)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label) , ## args )
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
//Contains the bits of the currently pressed buttons.
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
volatile uint8_t buttons_reprapworld_keypad;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (LCD_HAS_SLOW_BUTTONS) )
volatile uint8_t slow_buttons;
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
int8_t encoderDiff;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
bool ignore_click = false;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
menuFunc_t callbackFunc;
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependend */
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// place-holders for Ki and Kd edits
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
static void lcd_status_screen()
{
    if (lcd_status_update_delay)
        lcd_status_update_delay--;
    else
        lcdDrawUpdate = 1;
    if (lcdDrawUpdate)
    {
        lcd_implementation_status_screen();
        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
    }
#ifdef ULTIPANEL
    if (LCD_CLICKED)
    {
        currentMenu = lcd_main_menu;
        lcd_quick_feedback();
    }
    feedmultiply += int(encoderPosition);
    encoderPosition = 0;
    if (feedmultiply < 10)
        feedmultiply = 10;
    if (feedmultiply > 999)
        feedmultiply = 999;
#endif//ULTIPANEL
}
#endif
#if defined (drsdre) && defined (ULTRA_LCD)
static void lcd_status_screen()
{
    if (lcd_status_update_delay)
        lcd_status_update_delay--;
    else
        lcdDrawUpdate = 1;
    if (lcdDrawUpdate)
    {
        lcd_implementation_status_screen();
        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
    }
#ifdef ULTIPANEL
    if (LCD_CLICKED)
    {
        currentMenu = lcd_main_menu;
        lcd_quick_feedback();
    }
    feedmultiply += int(encoderPosition);
    encoderPosition = 0;
    if (feedmultiply < 10)
        feedmultiply = 10;
    if (feedmultiply > 999)
        feedmultiply = 999;
#endif//ULTIPANEL
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
float raw_Ki, raw_Kd;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_set_home_offsets()
{
    for(int8_t i=0; i < NUM_AXIS; i++) {
      if (i != E_AXIS) {
        add_homing[i] -= current_position[i];
        current_position[i] = 0.0;
      }
    }
    plan_set_position(0.0, 0.0, 0.0, current_position[E_AXIS]);

    // Audio feedback
    enquecommand_P(PSTR("M300 S659 P200"));
    enquecommand_P(PSTR("M300 S698 P200"));
    lcd_return_to_status();
}
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_preheat_pla()
{
    setTargetHotend0(plaPreheatHotendTemp);
    setTargetHotend1(plaPreheatHotendTemp);
    setTargetHotend2(plaPreheatHotendTemp);
    setTargetBed(plaPreheatHPBTemp);
    fanSpeed = plaPreheatFanSpeed;
    lcd_return_to_status();
}
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void _lcd_babystep(int axis, const char *msg) {
    if (encoderPosition != 0) {
      babystepsTodo[axis] += (int)encoderPosition;
      encoderPosition = 0;
      lcdDrawUpdate = 1;
    }
    if (lcdDrawUpdate) lcd_implementation_drawedit(msg, "");
    if (LCD_CLICKED) lcd_goto_menu(lcd_tune_menu);
  }
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_preheat_abs()
{
    setTargetHotend0(absPreheatHotendTemp);
    setTargetHotend1(absPreheatHotendTemp);
    setTargetHotend2(absPreheatHotendTemp);
    setTargetBed(absPreheatHPBTemp);
    fanSpeed = absPreheatFanSpeed;
    lcd_return_to_status();
}
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//BABYSTEPPING
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_preheat_pla0()
{
    setTargetHotend0(plaPreheatHotendTemp);
    setTargetBed(plaPreheatHPBTemp);
    fanSpeed = plaPreheatFanSpeed;
    lcd_return_to_status();
    setWatch(); // heater sanity check timer
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
//2nd extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2nd extruder preheat
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
//more than one extruder present
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//more than one extruder present
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
static void lcd_delta_calibrate_menu()
{
    START_MENU();
    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_X, PSTR("G0 F8000 X-77.94 Y-45 Z0"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Y, PSTR("G0 F8000 X77.94 Y-45 Z0"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Z, PSTR("G0 F8000 X0 Y90 Z0"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_CENTER, PSTR("G0 F8000 X0 Y0 Z0"));
    END_MENU();
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void _lcd_move(const char *name, int axis, int min, int max) {
  if (encoderPosition != 0) {
    refresh_cmd_timeout();
    current_position[axis] += float((int)encoderPosition) * move_menu_scale;
    if (min_software_endstops && current_position[axis] < min) current_position[axis] = min;
    if (max_software_endstops && current_position[axis] > max) current_position[axis] = max;
    encoderPosition = 0;
    #ifdef DELTA
      calculate_delta(current_position);
      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
    #else
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
    #endif
    lcdDrawUpdate = 1;
  }
  if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));
  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_control_volumetric_menu()
{
	START_MENU();
	MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);

	MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);

	if (volumetric_enabled) {
		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_0, &filament_size[0], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#if EXTRUDERS > 1
		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_1, &filament_size[1], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#if EXTRUDERS > 2
		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_2, &filament_size[2], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#endif
#endif
	}

	END_MENU();
}
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_set_contrast()
{
    if (encoderPosition != 0)
    {
        lcd_contrast -= encoderPosition;
        if (lcd_contrast < 0) lcd_contrast = 0;
        else if (lcd_contrast > 63) lcd_contrast = 63;
        encoderPosition = 0;
        lcdDrawUpdate = 1;
        u8g.setContrast(lcd_contrast);
    }
    if (lcdDrawUpdate)
    {
        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
    }
    if (LCD_CLICKED) lcd_goto_menu(lcd_control_menu);
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//FWRETRACT
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define menu_edit_type(_type, _name, _strFunc, scale) \
    void menu_edit_ ## _name () \
    { \
        if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
        if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
        if (lcdDrawUpdate) \
            lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
        if (LCD_CLICKED) \
        { \
            *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
            lcd_goto_menu(prevMenu, prevEncoderPosition); \
        } \
    } \
    void menu_edit_callback_ ## _name () { \
        menu_edit_ ## _name (); \
        if (LCD_CLICKED) (*callbackFunc)(); \
    } \
    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale - minEditValue; \
        encoderPosition = (*ptr) * scale - minEditValue; \
    }\
    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_callback_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale - minEditValue; \
        encoderPosition = (*ptr) * scale - minEditValue; \
        callbackFunc = callback;\
    }
#endif
++++++
#if defined (drsdre) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define menu_edit_type(_type, _name, _strFunc, scale) \
    void menu_edit_ ## _name () \
    { \
        if ((int32_t)encoderPosition < minEditValue) \
            encoderPosition = minEditValue; \
        if ((int32_t)encoderPosition > maxEditValue) \
            encoderPosition = maxEditValue; \
        if (lcdDrawUpdate) \
            lcd_implementation_drawedit(editLabel, _strFunc(((_type)encoderPosition) / scale)); \
        if (LCD_CLICKED) \
        { \
            *((_type*)editValue) = ((_type)encoderPosition) / scale; \
            lcd_quick_feedback(); \
            currentMenu = prevMenu; \
            encoderPosition = prevEncoderPosition; \
        } \
    } \
    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale; \
        encoderPosition = (*ptr) * scale; \
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
menu_edit_type(float, float43, ftostr43, 1000)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (REPRAPWORLD_KEYPAD) && defined (ULTIPANEL) )
static void reprapworld_keypad_move_z_up() {
    encoderPosition = 1;
    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;
		lcd_move_z();
  }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback)
{
	menu_action_setting_edit_bool(pstr, ptr);
	(*callback)();
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void lcd_ignore_click(bool b)
{
    ignore_click = b;
    wait_for_unclick = false;
}
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) )
void lcd_setcontrast(uint8_t value)
{
    lcd_contrast = value & 63;
    u8g.setContrast(lcd_contrast);
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
bool lcd_detected(void)
{
#if (defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
  return lcd.LcdDetected() == 1;
#else
  return true;
#endif
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 123.4 format, dropping sign
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
//  convert float to string with +123.4 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 123.4 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 1.234 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert int to rj string with 123 or -12 format
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
char *itostr3(const int &xx)
{
  if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
  if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
  conv[2]=(xx)%10+'0';
  conv[3]=0;
  return conv;
}
#endif
#if defined (drsdre) && defined (ULTRA_LCD)
char *itostr3(const int &xx)
{
  if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
  if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
  conv[2]=(xx)%10+'0';
  conv[3]=0;
  return conv;
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
char *itostr3(const int &x)
{
  int xx = x;
  if (xx < 0) {
     conv[0]='-';
     xx = -xx;
  } else if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
  if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
  conv[2]=(xx)%10+'0';
  conv[3]=0;
  return conv;
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert int to rj string with 1234 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to rj string with 12345 format
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
//  convert float to string with 12345 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with +1234.5 format
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
//  convert float to string with +1234.5 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with +123.45 format
#endif
++++++
#if defined (drsdre) && defined (ULTRA_LCD)
//  convert float to string with +123.45 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Callback for after editing PID i value
#endif
++++++


**--**-**--merge: vector_3.cpp



**--**-**--merge: watchdog.cpp

