!!!fork: indi-RichCattell

**--**-**--merge: BlinkM.cpp



**--**-**--merge: cardreader.cpp

#if defined (upstream) && defined (SDSUPPORT)
file_subcall_ctr=0;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//the SD start is delayed, because otherwise the serial cannot answer fast enough to make contact with the host software.
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
//the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(const char *prepend, SdFile parent, const char * const match/*=NULL*/)
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
(const char *prepend,SdFile parent)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char pn0 = p.name[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(pn0 == DIR_NAME_FREE)
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
(p.name[0] == DIR_NAME_FREE)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(pn0 == DIR_NAME_DELETED || pn0 == '.' || pn0 == '_')
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
(p.name[0] == DIR_NAME_DELETED || p.name[0] == '.'|| p.name[0] == '_')
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lf0 = longFilename[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(lf0 == '.' || lf0 == '_')
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
(longFilename[0] != '\0' &&
          (longFilename[0] == '.' || longFilename[0] == '_'))
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
if ( p.name[0] == '.')
      {
        if ( p.name[1] != '.')
        continue;
      }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if (match != NULL) {
          if (strcasecmp(match, filename) == 0) return;
        }
        else if (cnt == nrFiles) return;
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
if(cnt==nrFiles)
          return;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char pn0 = p.name[0];
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
char lf0 = longFilename[0];
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
if ( p.name[0] == '.')
      {
        if ( p.name[1] != '.')
        continue;
      }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(char* name,bool read, bool replace_current/*=true*/)
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
(char* name,bool read)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
getfilename(0, fname);
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
lcd_setstatus(fname);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lcd_setstatus(longFilename[0] ? longFilename : fname);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(file.isOpen())  //replacing current file by new file, or subfile call
  {
    if(!replace_current)
    {
     if((int)file_subcall_ctr>(int)SD_PROCEDURE_DEPTH-1)
     {
       SERIAL_ERROR_START;
       SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
       SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
       kill();
       return;
     }
     
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("SUBROUTINE CALL target:\"");
     SERIAL_ECHO(name);
     SERIAL_ECHOPGM("\" parent:\"");
     
     //store current filename and position
     getAbsFilename(filenames[file_subcall_ctr]);
     
     SERIAL_ECHO(filenames[file_subcall_ctr]);
     SERIAL_ECHOPGM("\" pos");
     SERIAL_ECHOLN(sdpos);
     filespos[file_subcall_ctr]=sdpos;
     file_subcall_ctr++;
    }
    else
    {
     SERIAL_ECHO_START;
     SERIAL_ECHOPGM("Now doing file: ");
     SERIAL_ECHOLN(name);
    }
    file.close();
  }
  else //opening fresh file
  {
    file_subcall_ctr=0; //resetting procedure depth in case user cancels print while in procedure
    SERIAL_ECHO_START;
    SERIAL_ECHOPGM("Now fresh file: ");
    SERIAL_ECHOLN(name);
  }
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
file.close();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
SERIAL_PROTOCOLLN(fname);
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
SERIAL_PROTOCOL(fname);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(bool store_location)
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
()
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(store_location)
  {
    //future: store printer state, filename and position for continuing a stopped print
    // so one can unplug the printer and continue printing the next day.
    
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
(uint16_t nr, const char * const match/*=NULL*/)
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
(const uint8_t nr)
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
lsDive("",*curDir,match);
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
lsDive("",*curDir);
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
if(file_subcall_ctr>0) //heading up to a parent file that called current as a procedure.
    {
      file.close();
      file_subcall_ctr--;
      openFile(filenames[file_subcall_ctr],true,true);
      setIndex(filespos[file_subcall_ctr]);
      startFileprint();
    }
    else
    {
      quickStop();
      file.close();
      sdprinting = false;
      if(SD_FINISHED_STEPPERRELEASE)
      {
          //finishAndDisableSteppers();
          enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));
      }
      autotempShutdown();
    }
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
quickStop();
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
void CardReader::getAbsFilename(char *t)
{
  uint8_t cnt=0;
  *t='/';t++;cnt++;
  for(uint8_t i=0;i<workDirDepth;i++)
  {
    workDirParents[i].getFilename(t); //SDBaseFile.getfilename!
    while(*t!=0 && cnt< MAXPATHNAMELENGTH) 
    {t++;cnt++;}  //crawl counter forward.
  }
  if(cnt<MAXPATHNAMELENGTH-13)
    file.getFilename(t);
  else
    t[0]=0;
}
#endif
++++++


**--**-**--merge: ConfigurationStore.cpp

#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,add_homing);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,add_homeing);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,endstop_adj);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,delta_segments_per_second);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,max_pos);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_WRITE_VAR(i,zprobe_zoffset);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i,axis_scaling);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,autoretract_enabled);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_feedrate);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_recover_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_WRITE_VAR(i,retract_recover_feedrate);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
// Save filament sizes
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i, filament_size[1]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_WRITE_VAR(i, filament_size[2]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOLNPGM("Scaling factors:");
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR("  M365 X",axis_scaling[X_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" Y",axis_scaling[Y_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" Z",axis_scaling[Z_AXIS]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR("  M203 X", max_feedrate[X_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Y", max_feedrate[Y_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y",max_feedrate[1] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Z", max_feedrate[Z_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z", max_feedrate[2] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" E", max_feedrate[E_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" E", max_feedrate[3]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[X_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[Y_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[Z_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[E_AXIS]);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR("  M206 X",add_homing[X_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Y" ,add_homing[Y_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );
#endif
++++++
#if defined (upstream) && !defined (DISABLE_M503)
SERIAL_ECHOPAIR(" Z" ,add_homing[Z_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_CHITCHAT)
SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOLNPGM("Endstop adjustement (mm):");
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOLNPGM("Endstop adjustment (mm):");
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR("  M666 X",endstop_adj[X_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOPAIR("  M666 X",endstop_adj[0]);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" Y" ,endstop_adj[Y_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOPAIR(" Y" ,endstop_adj[1]);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" Z" ,endstop_adj[Z_AXIS] );
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOPAIR(" Z" ,endstop_adj[2]);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOLNPGM("Delta settings: L=delta_diagonal_rod, R=delta_radius, S=delta_segments_per_second");
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOLNPGM("Delta Geometry adjustment:");
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR("  M665 L",delta_diagonal_rod );
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOPAIR("  M666 A",tower_adj[0]);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && !defined (DISABLE_M503) )
SERIAL_ECHOPAIR(" S" ,delta_segments_per_second );
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
SERIAL_ECHOPAIR(" D" ,delta_diagonal_rod);
#endif
++++++
#if defined (indi-RichCattell) && (defined (EEPROM_CHITCHAT) && defined (DELTA) )
/*
      SERIAL_ECHOLN("Tower Positions");
      SERIAL_ECHOPAIR("Tower1 X:",delta_tower1_x);
      SERIAL_ECHOPAIR(" Y:",delta_tower1_y);
      SERIAL_ECHOLN("");
      SERIAL_ECHOPAIR("Tower2 X:",delta_tower2_x);
      SERIAL_ECHOPAIR(" Y:",delta_tower2_y);
      SERIAL_ECHOLN("");
      SERIAL_ECHOPAIR("Tower3 X:",delta_tower3_x);
      SERIAL_ECHOPAIR(" Y:",delta_tower3_y);
      SERIAL_ECHOLN("");
*/
#endif
++++++
#if defined (upstream) && (defined (PIDTEMP) && !defined (DISABLE_M503) )
SERIAL_ECHOLN("");
#endif
++++++
#if defined (upstream) && (!defined (DISABLE_M503) && defined (FWRETRACT) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && !defined (DISABLE_M503) && defined (FWRETRACT) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && (!defined (DISABLE_M503) && defined (FWRETRACT) )
SERIAL_ECHO_START;
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,add_homing);
#endif
++++++
#if defined (indi-RichCattell) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,add_homeing);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,endstop_adj);
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,delta_segments_per_second);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,max_pos);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,endstop_adj);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,tower_adj);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,z_probe_offset);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
// Update delta constants for updated delta_radius & tower_adj values
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
set_delta_constants();
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,zprobe_zoffset);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,axis_scaling);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,autoretract_enabled);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_length);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_feedrate);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_zlift);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_length);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_feedrate);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i, volumetric_enabled);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i, filament_size[0]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[1]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[2]);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
calculate_volumetric_multipliers();
#endif
++++++
#if defined (upstream) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,endstop_adj);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DELTA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,endstop_adj);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i,zprobe_zoffset);
#endif
++++++
#if defined (upstream) && (defined (SCARA) && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i,axis_scaling);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,autoretract_enabled);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_feedrate);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_length_swap);
#endif
++++++
#if defined (upstream) && (defined (EEPROM_SETTINGS) && defined (FWRETRACT) )
EEPROM_READ_VAR(i,retract_recover_feedrate);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
EEPROM_READ_VAR(i, volumetric_enabled);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[1]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 && defined (EEPROM_SETTINGS) )
EEPROM_READ_VAR(i, filament_size[2]);
#endif
++++++
#if defined (upstream) && defined (EEPROM_SETTINGS)
calculate_volumetric_multipliers();
#endif
++++++
#if defined (indi-RichCattell)
for (short i=0;i<4;i++) 
    {
        axis_steps_per_unit[i]=tmp1[i];  
        max_feedrate[i]=tmp2[i];  
        max_acceleration_units_per_sq_second[i]=tmp3[i];
    }
#endif
++++++
#if defined (upstream)
add_homing[X_AXIS] = add_homing[Y_AXIS] = add_homing[Z_AXIS] = 0;
#endif
++++++
#if defined (indi-RichCattell)
add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;
#endif
++++++
#if defined (upstream) && defined (DELTA)
endstop_adj[X_AXIS] = endstop_adj[Y_AXIS] = endstop_adj[Z_AXIS] = 0;
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
delta_radius = DEFAULT_DELTA_RADIUS;
#endif
++++++
#if defined (upstream) && defined (DELTA)
delta_radius= DELTA_RADIUS;
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
delta_diagonal_rod = DEFAULT_DELTA_DIAGONAL_ROD;
#endif
++++++
#if defined (upstream) && defined (DELTA)
delta_diagonal_rod= DELTA_DIAGONAL_ROD;
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
endstop_adj[0] = endstop_adj[1] = endstop_adj[2] = 0;
#endif
++++++
#if defined (upstream) && defined (DELTA)
delta_segments_per_second= DELTA_SEGMENTS_PER_SECOND;
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
tower_adj[0] = tower_adj[1] = tower_adj[2] = tower_adj[3] = tower_adj[4] = tower_adj[5] = 0;
#endif
++++++
#if defined (upstream) && defined (DELTA)
recalc_delta_settings(delta_radius, delta_diagonal_rod);
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
max_pos[2] = MANUAL_Z_HOME_POS;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
zprobe_zoffset = -Z_PROBE_OFFSET_FROM_EXTRUDER;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
autoretract_enabled = false;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (FWRETRACT) )
retract_length_swap = RETRACT_LENGTH_SWAP;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
retract_feedrate = RETRACT_FEEDRATE;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (FWRETRACT) )
retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;
#endif
++++++
#if defined (upstream)
volumetric_enabled = false;
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
filament_size[1] = DEFAULT_NOMINAL_FILAMENT_DIA;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 2 && EXTRUDERS > 1 )
filament_size[2] = DEFAULT_NOMINAL_FILAMENT_DIA;
#endif
++++++
#if defined (upstream)
calculate_volumetric_multipliers();
#endif
++++++
#if defined (upstream)
#define EEPROM_VERSION "V13"
#endif
++++++
#if defined (indi-RichCattell)
#define EEPROM_VERSION "V14"
#endif
++++++


**--**-**--merge: digipot_mcp4451.cpp



**--**-**--merge: LiquidCrystalRus.cpp

#if defined (upstream)
#include "LiquidCrystalRus.h"

#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <avr/pgmspace.h>

#if defined(ARDUINO) && ARDUINO >= 100
  #include "Arduino.h"
#else
  #include "WProgram.h"
#endif

// it is a Russian alphabet translation
// except 0401 --> 0xa2 = â, 0451 --> 0xb5
const PROGMEM uint8_t utf_recode[] = 
       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
        };     

// When the display powers up, it is configured as follows:
//
// 1. Display clear
// 2. Function set: 
//    DL = 1; 8-bit interface data 
//    N = 0; 1-line display 
//    F = 0; 5x8 dot character font 
// 3. Display on/off control: 
//    D = 0; Display off 
//    C = 0; Cursor off 
//    B = 0; Blinking off 
// 4. Entry mode set: 
//    I/D = 1; Increment by 1 
//    S = 0; No shift 
//
// Note, however, that resetting the Arduino doesn't reset the LCD, so we
// can't assume that it's in that state when a sketch starts (and the
// LiquidCrystal constructor is called).
// 
// modified 27 Jul 2011
// by Ilya V. Danilov http://mk90.ru/


LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  _rs_pin = rs;
  _rw_pin = rw;
  _enable_pin = enable;
  
  _data_pins[0] = d0;
  _data_pins[1] = d1;
  _data_pins[2] = d2;
  _data_pins[3] = d3; 
  _data_pins[4] = d4;
  _data_pins[5] = d5;
  _data_pins[6] = d6;
  _data_pins[7] = d7; 

  pinMode(_rs_pin, OUTPUT);
  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
  if (_rw_pin != 255) { 
    pinMode(_rw_pin, OUTPUT);
  }
  pinMode(_enable_pin, OUTPUT);
  
  if (fourbitmode)
    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
  else 
    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
  
  begin(16, 1);  
}

void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
  if (lines > 1) {
    _displayfunction |= LCD_2LINE;
  }
  _numlines = lines;
  _currline = 0;

  // for some 1 line displays you can select a 10 pixel high font
  if ((dotsize != 0) && (lines == 1)) {
    _displayfunction |= LCD_5x10DOTS;
  }

  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
  // according to datasheet, we need at least 40ms after power rises above 2.7V
  // before sending commands. Arduino can turn on way before 4.5V so we'll wait 50
  delayMicroseconds(50000); 
  // Now we pull both RS and R/W low to begin commands
  digitalWrite(_rs_pin, LOW);
  digitalWrite(_enable_pin, LOW);
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  //put the LCD into 4 bit or 8 bit mode
  if (! (_displayfunction & LCD_8BITMODE)) {
    // this is according to the Hitachi HD44780 datasheet
    // figure 24, pg 46

    // we start in 8bit mode, try to set 4 bit mode
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms

    // second try
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms
    
    // third go!
    writeNbits(0x03,4); 
    delayMicroseconds(150);

    // finally, set to 8-bit interface
    writeNbits(0x02,4); 
  } else {
    // this is according to the Hitachi HD44780 datasheet
    // page 45 figure 23

    // Send function set command sequence
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(4500);  // wait more than 4.1ms

    // second try
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(150);

    // third go
    command(LCD_FUNCTIONSET | _displayfunction);
  }

  // finally, set # lines, font size, etc.
  command(LCD_FUNCTIONSET | _displayfunction);  

  // turn the display on with no cursor or blinking default
  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
  display();

  // clear it off
  clear();

  // Initialize to default text direction (for romance languages)
  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
  // set the entry mode
  command(LCD_ENTRYMODESET | _displaymode);

}

void LiquidCrystalRus::setDRAMModel(uint8_t model) {
  _dram_model = model;
}

/********** high level commands, for the user! */
void LiquidCrystalRus::clear()
{
  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::home()
{
  command(LCD_RETURNHOME);  // set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)
{
  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  if ( row >= _numlines ) {
    row = _numlines-1;    // we count rows starting w/0
  }
  
  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}

// Turn the display on/off (quickly)
void LiquidCrystalRus::noDisplay() {
  _displaycontrol &= ~LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::display() {
  _displaycontrol |= LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turns the underline cursor on/off
void LiquidCrystalRus::noCursor() {
  _displaycontrol &= ~LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::cursor() {
  _displaycontrol |= LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turn on and off the blinking cursor
void LiquidCrystalRus::noBlink() {
  _displaycontrol &= ~LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::blink() {
  _displaycontrol |= LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// These commands scroll the display without changing the RAM
void LiquidCrystalRus::scrollDisplayLeft(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
void LiquidCrystalRus::scrollDisplayRight(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}

// This is for text that flows Left to Right
void LiquidCrystalRus::leftToRight(void) {
  _displaymode |= LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This is for text that flows Right to Left
void LiquidCrystalRus::rightToLeft(void) {
  _displaymode &= ~LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'right justify' text from the cursor
void LiquidCrystalRus::autoscroll(void) {
  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'left justify' text from the cursor
void LiquidCrystalRus::noAutoscroll(void) {
  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// Allows us to fill the first 8 CGRAM locations
// with custom characters
void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {
  location &= 0x7; // we only have 8 locations 0-7
  command(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++) {
    write(charmap[i]);
  }
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystalRus::command(uint8_t value) {
  send(value, LOW);
}

#if defined(ARDUINO) && ARDUINO >= 100
  size_t LiquidCrystalRus::write(uint8_t value)
#else
  void   LiquidCrystalRus::write(uint8_t value)
#endif
{
  uint8_t out_char=value;

  if (_dram_model == LCD_DRAM_WH1601) {  
    uint8_t ac=recv(LOW) & 0x7f;
    if (ac>7 && ac<0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));
  }

  if (value>=0x80) { // UTF-8 handling
    if (value >= 0xc0) {
      utf_hi_char = value - 0xd0;
    } else {
      value &= 0x3f;
      if (!utf_hi_char && (value == 1)) 
        send(0xa2,HIGH); // â
      else if ((utf_hi_char == 1) && (value == 0x11)) 
        send(0xb5,HIGH); // â¦
      else 
        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char<<6) - 0x10), HIGH);
    }    
  } else send(out_char, HIGH);
#if defined(ARDUINO) && ARDUINO >= 100
  return 1; // assume success 
#endif
}

/************ low level data pushing commands **********/

// write either command or data, with automatic 4/8-bit selection
void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    writeNbits(value,8); 
  } else {
    writeNbits(value>>4,4);
    writeNbits(value,4);
  }
}

// read  data, with automatic 4/8-bit selection
uint8_t LiquidCrystalRus::recv(uint8_t mode) {
  uint8_t retval;
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, HIGH);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    retval = readNbits(8); 
  } else {
    retval = readNbits(4) << 4;
    retval |= readNbits(4);
  }
  return retval;
}
void LiquidCrystalRus::pulseEnable() {
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(100);   // commands need > 37us to settle
}

void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], OUTPUT);
    digitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  pulseEnable();
}

uint8_t LiquidCrystalRus::readNbits(uint8_t n) {
  uint8_t retval=0;
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], INPUT);
  }

  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  
  for (int i = 0; i < n; i++) {
    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 << i):0;
  }

  digitalWrite(_enable_pin, LOW);

  return retval;
}







































































































































































































































#endif
++++++
#if defined (indi-RichCattell)
#include "LiquidCrystalRus.h"

#include <stdio.h>
#include <string.h>
#include <inttypes.h>
#include <avr/pgmspace.h>

#if defined(ARDUINO) && ARDUINO >= 100
  #include "Arduino.h"
#else
  #include "WProgram.h"
#endif

// it is a russian alphabet translation
// except 0401 --> 0xa2 = â, 0451 --> 0xb5
const PROGMEM uint8_t utf_recode[] = 
       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,
         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,
         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,
         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7
        };     

// When the display powers up, it is configured as follows:
//
// 1. Display clear
// 2. Function set: 
//    DL = 1; 8-bit interface data 
//    N = 0; 1-line display 
//    F = 0; 5x8 dot character font 
// 3. Display on/off control: 
//    D = 0; Display off 
//    C = 0; Cursor off 
//    B = 0; Blinking off 
// 4. Entry mode set: 
//    I/D = 1; Increment by 1 
//    S = 0; No shift 
//
// Note, however, that resetting the Arduino doesn't reset the LCD, so we
// can't assume that it's in that state when a sketch starts (and the
// LiquidCrystal constructor is called).
// 
// modified 27 Jul 2011
// by Ilya V. Danilov http://mk90.ru/


LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,
			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)
{
  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);
}

void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,
			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)
{
  _rs_pin = rs;
  _rw_pin = rw;
  _enable_pin = enable;
  
  _data_pins[0] = d0;
  _data_pins[1] = d1;
  _data_pins[2] = d2;
  _data_pins[3] = d3; 
  _data_pins[4] = d4;
  _data_pins[5] = d5;
  _data_pins[6] = d6;
  _data_pins[7] = d7; 

  pinMode(_rs_pin, OUTPUT);
  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#
  if (_rw_pin != 255) { 
    pinMode(_rw_pin, OUTPUT);
  }
  pinMode(_enable_pin, OUTPUT);
  
  if (fourbitmode)
    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;
  else 
    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;
  
  begin(16, 1);  
}

void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {
  if (lines > 1) {
    _displayfunction |= LCD_2LINE;
  }
  _numlines = lines;
  _currline = 0;

  // for some 1 line displays you can select a 10 pixel high font
  if ((dotsize != 0) && (lines == 1)) {
    _displayfunction |= LCD_5x10DOTS;
  }

  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!
  // according to datasheet, we need at least 40ms after power rises above 2.7V
  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50
  delayMicroseconds(50000); 
  // Now we pull both RS and R/W low to begin commands
  digitalWrite(_rs_pin, LOW);
  digitalWrite(_enable_pin, LOW);
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  //put the LCD into 4 bit or 8 bit mode
  if (! (_displayfunction & LCD_8BITMODE)) {
    // this is according to the hitachi HD44780 datasheet
    // figure 24, pg 46

    // we start in 8bit mode, try to set 4 bit mode
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms

    // second try
    writeNbits(0x03,4);
    delayMicroseconds(4500); // wait min 4.1ms
    
    // third go!
    writeNbits(0x03,4); 
    delayMicroseconds(150);

    // finally, set to 8-bit interface
    writeNbits(0x02,4); 
  } else {
    // this is according to the hitachi HD44780 datasheet
    // page 45 figure 23

    // Send function set command sequence
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(4500);  // wait more than 4.1ms

    // second try
    command(LCD_FUNCTIONSET | _displayfunction);
    delayMicroseconds(150);

    // third go
    command(LCD_FUNCTIONSET | _displayfunction);
  }

  // finally, set # lines, font size, etc.
  command(LCD_FUNCTIONSET | _displayfunction);  

  // turn the display on with no cursor or blinking default
  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  
  display();

  // clear it off
  clear();

  // Initialize to default text direction (for romance languages)
  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
  // set the entry mode
  command(LCD_ENTRYMODESET | _displaymode);

}

void LiquidCrystalRus::setDRAMModel(uint8_t model) {
  _dram_model = model;
}

/********** high level commands, for the user! */
void LiquidCrystalRus::clear()
{
  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::home()
{
  command(LCD_RETURNHOME);  // set cursor position to zero
  delayMicroseconds(2000);  // this command takes a long time!
}

void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)
{
  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
  if ( row >= _numlines ) {
    row = _numlines-1;    // we count rows starting w/0
  }
  
  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}

// Turn the display on/off (quickly)
void LiquidCrystalRus::noDisplay() {
  _displaycontrol &= ~LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::display() {
  _displaycontrol |= LCD_DISPLAYON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turns the underline cursor on/off
void LiquidCrystalRus::noCursor() {
  _displaycontrol &= ~LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::cursor() {
  _displaycontrol |= LCD_CURSORON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// Turn on and off the blinking cursor
void LiquidCrystalRus::noBlink() {
  _displaycontrol &= ~LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}
void LiquidCrystalRus::blink() {
  _displaycontrol |= LCD_BLINKON;
  command(LCD_DISPLAYCONTROL | _displaycontrol);
}

// These commands scroll the display without changing the RAM
void LiquidCrystalRus::scrollDisplayLeft(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
void LiquidCrystalRus::scrollDisplayRight(void) {
  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}

// This is for text that flows Left to Right
void LiquidCrystalRus::leftToRight(void) {
  _displaymode |= LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This is for text that flows Right to Left
void LiquidCrystalRus::rightToLeft(void) {
  _displaymode &= ~LCD_ENTRYLEFT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'right justify' text from the cursor
void LiquidCrystalRus::autoscroll(void) {
  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// This will 'left justify' text from the cursor
void LiquidCrystalRus::noAutoscroll(void) {
  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  command(LCD_ENTRYMODESET | _displaymode);
}

// Allows us to fill the first 8 CGRAM locations
// with custom characters
void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {
  location &= 0x7; // we only have 8 locations 0-7
  command(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++) {
    write(charmap[i]);
  }
}

/*********** mid level commands, for sending data/cmds */

inline void LiquidCrystalRus::command(uint8_t value) {
  send(value, LOW);
}

#if defined(ARDUINO) && ARDUINO >= 100
  size_t LiquidCrystalRus::write(uint8_t value)
#else
  void   LiquidCrystalRus::write(uint8_t value)
#endif
{
  uint8_t out_char=value;

  if (_dram_model == LCD_DRAM_WH1601) {  
    uint8_t ac=recv(LOW) & 0x7f;
    if (ac>7 && ac<0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));
  }

  if (value>=0x80) { // UTF-8 handling
    if (value >= 0xc0) {
      utf_hi_char = value - 0xd0;
    } else {
      value &= 0x3f;
      if (!utf_hi_char && (value == 1)) 
        send(0xa2,HIGH); // â
      else if ((utf_hi_char == 1) && (value == 0x11)) 
        send(0xb5,HIGH); // â¦
      else 
        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char<<6) - 0x10), HIGH);
    }    
  } else send(out_char, HIGH);
#if defined(ARDUINO) && ARDUINO >= 100
  return 1; // assume sucess 
#endif
}

/************ low level data pushing commands **********/

// write either command or data, with automatic 4/8-bit selection
void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, LOW);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    writeNbits(value,8); 
  } else {
    writeNbits(value>>4,4);
    writeNbits(value,4);
  }
}

// read  data, with automatic 4/8-bit selection
uint8_t LiquidCrystalRus::recv(uint8_t mode) {
  uint8_t retval;
  digitalWrite(_rs_pin, mode);

  // if there is a RW pin indicated, set it low to Write
  if (_rw_pin != 255) { 
    digitalWrite(_rw_pin, HIGH);
  }
  
  if (_displayfunction & LCD_8BITMODE) {
    retval = readNbits(8); 
  } else {
    retval = readNbits(4) << 4;
    retval |= readNbits(4);
  }
  return retval;
}
void LiquidCrystalRus::pulseEnable() {
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(100);   // commands need > 37us to settle
}

void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], OUTPUT);
    digitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  pulseEnable();
}

uint8_t LiquidCrystalRus::readNbits(uint8_t n) {
  uint8_t retval=0;
  for (int i = 0; i < n; i++) {
    pinMode(_data_pins[i], INPUT);
  }

  digitalWrite(_enable_pin, LOW);
  delayMicroseconds(1);    
  digitalWrite(_enable_pin, HIGH);
  delayMicroseconds(1);    // enable pulse must be >450ns
  
  for (int i = 0; i < n; i++) {
    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 << i):0;
  }

  digitalWrite(_enable_pin, LOW);

  return retval;
}



















































#endif
++++++


**--**-**--merge: Marlin_main.cpp

#if defined (upstream)
//this is dangerous if a mixing of serial and this happens
#endif
++++++
#if defined (indi-RichCattell)
//this is dangerous if a mixing of serial and this happsens
#endif
++++++
#if defined (upstream)
SERIAL_ECHOPGM(MSG_Enqueing);
#endif
++++++
#if defined (indi-RichCattell)
SERIAL_ECHOPGM("enqueing \"");
#endif
++++++
#if defined (upstream)
//this is dangerous if a mixing of serial and this happens
#endif
++++++
#if defined (indi-RichCattell)
//this is dangerous if a mixing of serial and this happsens
#endif
++++++
#if defined (upstream)
SERIAL_ECHOPGM(MSG_Enqueing);
#endif
++++++
#if defined (indi-RichCattell)
SERIAL_ECHOPGM("enqueing \"");
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
SET_INPUT(KILL_PIN);
#endif
++++++
#if defined (indi-RichCattell) && (defined(KILL_PIN) && KILL_PIN > -1)
pinMode(KILL_PIN,INPUT);
#endif
++++++
#if defined (upstream) && (defined(PS_DEFAULT_OFF) && (defined(PS_ON_PIN) && PS_ON_PIN > -1 &)
WRITE(PS_ON_PIN, PS_ON_ASLEEP);
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0))
delay(PROBE_SERVO_DEACTIVATION_DELAY);
#endif
++++++
#if defined (upstream) && defined (DIGIPOT_I2C)
digipot_i2c_init();
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
pinMode(SERVO0_PIN, OUTPUT);
#endif
++++++
#if defined (upstream)
// Z_PROBE_SLED
#endif
++++++
#if defined (upstream)
if (Stopped == true) {
              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
              LCD_MESSAGEPGM(MSG_STOPPED);
            }
#endif
++++++
#if defined (upstream)
//If command was e-stop process now
#endif
++++++
#if defined (upstream)
if(strcmp(cmdbuffer[bufindw], "M112") == 0)
          kill();
#endif
++++++
#if defined (upstream)
//If command was e-stop process now
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
//'#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
while( !card.eof()  && buflen < BUFSIZE) {
    int16_t n=card.get();
    serial_char = (char)n;
    if(serial_char == '\n' ||
       serial_char == '\r' ||
       (serial_char == ':' && comment_mode == false) ||
       serial_count >= (MAX_CMD_SIZE - 1)||n==-1)
    {
      if(card.eof()){
        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
        stoptime=millis();
        char time[30];
        unsigned long t=(stoptime-starttime)/1000;
        int hours, minutes;
        minutes=(t/60)%60;
        hours=t/60/60;
        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);
        SERIAL_ECHO_START;
        SERIAL_ECHOLN(time);
        lcd_setstatus(time);
        card.printingHasFinished();
        card.checkautostart(true);

      }
      if(!serial_count)
      {
        comment_mode = false; //for new command
        return; //if empty line
      }
      cmdbuffer[bufindw][serial_count] = 0; //terminate string
//      if(!comment_mode){
        fromsd[bufindw] = true;
        buflen += 1;
        bufindw = (bufindw + 1)%BUFSIZE;
//      }
      comment_mode = false; //for new command
      serial_count = 0; //clear buffer
    }
    else
    {
      if(serial_char == ';') comment_mode = true;
      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;
    }
  }
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// if it occurs, stop_buffering is triggered and the buffer is ran dry.
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
return base_home_pos(X_AXIS) + add_homing[X_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DUAL_X_CARRIAGE)
return base_home_pos(X_AXIS) + add_homeing[X_AXIS];
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homing[X_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DUAL_X_CARRIAGE)
current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homeing[X_AXIS];
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homing[X_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DUAL_X_CARRIAGE)
min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS];
#endif
++++++
#if defined (upstream) && defined (DUAL_X_CARRIAGE)
max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homing[X_AXIS],
                                  max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
#endif
++++++
#if defined (indi-RichCattell) && defined (DUAL_X_CARRIAGE)
max_pos[X_AXIS] =          min(base_max_pos[X_AXIS] + add_homeing[X_AXIS], 
                                  max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
#endif
++++++
#if defined (upstream) && defined (SCARA)
float homeposition[3];
#endif
++++++
#if defined (indi-RichCattell)
current_position[axis] = base_home_pos[axis] + add_homeing[axis];
#endif
++++++
#if defined (upstream) && defined (SCARA)
char i;
#endif
++++++
#if defined (indi-RichCattell)
min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];
#endif
++++++
#if defined (upstream) && defined (SCARA)
if (axis < 2)
   {
   
     for (i=0; i<3; i++)
     {
        homeposition[i] = base_home_pos(i); 
     }  
	// SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);
   //  SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);
   // Works out real Homeposition angles using inverse kinematics, 
   // and calculates homing offset using forward kinematics
     calculate_delta(homeposition);
     
    // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
     for (i=0; i<2; i++)
     {
        delta[i] -= add_homing[i];
     } 
     
    // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homing[X_AXIS]);
	// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homing[Y_AXIS]);
    // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
      
     calculate_SCARA_forward_Transform(delta);
     
    // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);
    // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);
     
    current_position[axis] = delta[axis];
    
    // SCARA home positions are based on configuration since the actual limits are determined by the 
    // inverse kinematic transform.
    min_pos[axis] =          base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));
    max_pos[axis] =          base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));
   } 
   else
   {
      current_position[axis] = base_home_pos(axis) + add_homing[axis];
      min_pos[axis] =          base_min_pos(axis) + add_homing[axis];
      max_pos[axis] =          base_max_pos(axis) + add_homing[axis];
   }
#endif
++++++
#if defined (indi-RichCattell)
max_pos[axis] =          base_max_pos[axis] + add_homeing[axis];
#endif
++++++
#if defined (upstream) && !defined (SCARA)
current_position[axis] = base_home_pos(axis) + add_homing[axis];
#endif
++++++
#if defined (indi-RichCattell)
return;
#endif
++++++
#if defined (indi-RichCattell)
return;
#endif
++++++
#if defined (upstream)
break;
#endif
++++++
#if defined (upstream)
break;
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
retracted_swap[active_extruder]=(code_seen('S') && code_value_long() == 1);
#endif
++++++
#if defined (indi-RichCattell)
if(!retracted)
      {
        destination[X_AXIS]=current_position[X_AXIS];
        destination[Y_AXIS]=current_position[Y_AXIS];
        destination[Z_AXIS]=current_position[Z_AXIS];
        current_position[Z_AXIS]+=-retract_zlift;
        destination[E_AXIS]=current_position[E_AXIS]-retract_length;
        feedrate=retract_feedrate;
        retracted=true;
        prepare_move();
      }
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
// checks for swap retract argument
#endif
++++++
#if defined (upstream) && EXTRUDERS > 1
retract(true,retracted_swap[active_extruder]);
#endif
++++++
#if defined (upstream) && !EXTRUDERS > 1
retract(true);
#endif
++++++
#if defined (upstream) && !EXTRUDERS > 1
retract(true);
#endif
++++++
#if defined (upstream)
31
#endif
++++++
#if defined (indi-RichCattell)
29
#endif
++++++
#if defined (upstream)
// dock the sled
#endif
++++++
#if defined (indi-RichCattell)
// G29 Calibrate print surface with automatic Z probe.
#endif
++++++
#if defined (upstream)
dock_sled(true);
#endif
++++++
#if defined (indi-RichCattell)
if (code_seen('D'))
        {
        SERIAL_ECHOLN("Current bed level array values:");
        SERIAL_ECHOLN("");
        for (int y = 0; y < 7; y++)
          {
          for (int x = 0; x < 7; x++)
            {
            SERIAL_PROTOCOL_F(bed_level[x][y], 3);
            SERIAL_PROTOCOLPGM(" ");
            }
          SERIAL_ECHOLN("");
          }
        break;
        }
#endif
++++++
#if defined (indi-RichCattell)
saved_feedrate = feedrate;
#endif
++++++
#if defined (indi-RichCattell)
saved_feedmultiply = feedmultiply;
#endif
++++++
#if defined (indi-RichCattell)
feedmultiply = 100;
#endif
++++++
#if defined (indi-RichCattell)
deploy_z_probe();
#endif
++++++
#if defined (indi-RichCattell)
calibrate_print_surface(z_probe_offset[Z_AXIS] +
	(code_seen(axis_codes[Z_AXIS]) ? code_value() : 0.0));
#endif
++++++
#if defined (indi-RichCattell)
retract_z_probe();
#endif
++++++
#if defined (indi-RichCattell)
feedrate = saved_feedrate;
#endif
++++++
#if defined (indi-RichCattell)
feedmultiply = saved_feedmultiply;
#endif
++++++
#if defined (indi-RichCattell)
previous_millis_cmd = millis();
#endif
++++++
#if defined (indi-RichCattell)
endstops_hit_on_purpose();
#endif
++++++
#if defined (indi-RichCattell)
saved_feedrate = feedrate;
#endif
++++++
#if defined (upstream) && defined (SCARA)
if (i == X_AXIS || i == Y_AXIS) {
                	current_position[i] = code_value();  
		}
		else {
                current_position[i] = code_value()+add_homing[i];  
            	}
#endif
++++++
#if defined (indi-RichCattell)
current_position[i] = code_value()+add_homeing[i];
#endif
++++++
#if defined (upstream) && !defined (SCARA)
current_position[i] = code_value()+add_homing[i];
#endif
++++++
#if defined (upstream) && !defined (SCARA)
current_position[i] = code_value()+add_homing[i];
#endif
++++++
#if defined (indi-RichCattell)
case 11: // G10 retract_recover
      if(!retracted)
      {
        destination[X_AXIS]=current_position[X_AXIS];
        destination[Y_AXIS]=current_position[Y_AXIS];
        destination[Z_AXIS]=current_position[Z_AXIS];

        current_position[Z_AXIS]+=retract_zlift;
        current_position[E_AXIS]+=-retract_recover_length;
        feedrate=retract_recover_feedrate;
        retracted=false;
        prepare_move();
      }
      break;
      #endif //FWRETRACT
    
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
calculate_delta(current_position);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
// change cartesian kinematic  to  delta kinematic;
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
//sent position to plan_set_position();
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],current_position[E_AXIS]);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (DELTA) )
calculate_delta(current_position);
#endif
++++++
#if defined (indi-RichCattell) && defined (FWRETRACT)
if(autoretract_enabled)
  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])
  {
    float echange=destination[E_AXIS]-current_position[E_AXIS];
    if(echange<-MIN_RETRACT) //retract
    {
      if(!retracted)
      {

      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.
      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally
      float correctede=-echange-retract_length;
      //to generate the additional steps, not the destination is changed, but inversely the current position
      current_position[E_AXIS]+=-correctede;
      feedrate=retract_feedrate;
      retracted=true;
      }

    }
    else
      if(echange>MIN_RETRACT) //retract_recover
    {
      if(retracted)
      {
      //current_position[Z_AXIS]+=-retract_zlift;
      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally
      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]
      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position
      feedrate=retract_recover_feedrate;
      retracted=false;
      }
    }

  }
#endif
++++++
#if defined (indi-RichCattell)
//FWRETRACT
#endif
++++++
#if defined (upstream)
float negative_z_offset = 0;
#endif
++++++
#if defined (indi-RichCattell)
if (target[Z_AXIS] < min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
if (Z_PROBE_OFFSET_FROM_EXTRUDER < 0) negative_z_offset = negative_z_offset + Z_PROBE_OFFSET_FROM_EXTRUDER;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
if (add_homing[Z_AXIS] < 0) negative_z_offset = negative_z_offset + add_homing[Z_AXIS];
#endif
++++++
#if defined (upstream)
if (target[Z_AXIS] < min_pos[Z_AXIS]+negative_z_offset) target[Z_AXIS] = min_pos[Z_AXIS]+negative_z_offset;
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
if (Z_PROBE_OFFSET_FROM_EXTRUDER < 0) negative_z_offset = negative_z_offset + Z_PROBE_OFFSET_FROM_EXTRUDER;
#endif
++++++
#if defined (upstream)
if (target[Z_AXIS] < min_pos[Z_AXIS]+negative_z_offset) target[Z_AXIS] = min_pos[Z_AXIS]+negative_z_offset;
#endif
++++++
#if defined (upstream) && defined (DELTA)
delta[X_AXIS] = sqrt(delta_diagonal_rod_2
                       - sq(delta_tower1_x-cartesian[X_AXIS])
                       - sq(delta_tower1_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
delta[X_AXIS] = sqrt(DELTA_DIAGONAL_ROD_2
                       - sq(delta_tower1_x-cartesian[X_AXIS])
                       - sq(delta_tower1_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (DELTA)
delta[Y_AXIS] = sqrt(delta_diagonal_rod_2
                       - sq(delta_tower2_x-cartesian[X_AXIS])
                       - sq(delta_tower2_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
delta[Y_AXIS] = sqrt(DELTA_DIAGONAL_ROD_2
                       - sq(delta_tower2_x-cartesian[X_AXIS])
                       - sq(delta_tower2_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
#endif
++++++
#if defined (upstream) && defined (DELTA)
delta[Z_AXIS] = sqrt(delta_diagonal_rod_2
                       - sq(delta_tower3_x-cartesian[X_AXIS])
                       - sq(delta_tower3_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
delta[Z_AXIS] = sqrt(DELTA_DIAGONAL_ROD_2
                       - sq(delta_tower3_x-cartesian[X_AXIS])
                       - sq(delta_tower3_y-cartesian[Y_AXIS])
                       ) + cartesian[Z_AXIS];
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
/*
  if ((delta_tmp[X_AXIS] > 0) and (delta_tmp[Y_AXIS] > 0) and (delta_tmp[Z_AXIS] > 0))
    {
      delta[X_AXIS] = delta_tmp[X_AXIS];
      delta[Y_AXIS] = delta_tmp[Y_AXIS];
      delta[Z_AXIS] = delta_tmp[Z_AXIS];
    } else SERIAL_ECHOLN("ERROR: Invalid delta coordinates!");
*/
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
adjust_delta(destination);
#endif
++++++
#if defined (upstream) && defined (SCARA)
//for now same as delta-code
#endif
++++++
#if defined (upstream)
// SCARA
#endif
++++++
#if defined (upstream) && defined (DELTA)
int steps = max(1, int(delta_segments_per_second * seconds));
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
int steps = max(1, int(DELTA_SEGMENTS_PER_SECOND * seconds));
#endif
++++++
#if defined (upstream)
// DELTA
#endif
++++++
#if defined (upstream)
// !(DELTA || SCARA)
#endif
++++++
#if defined (indi-RichCattell)
//else DELTA
#endif
++++++
#if defined (upstream)
(bool ignore_stepper_queue/*=false*/)
#endif
++++++
#if defined (indi-RichCattell)
()
#endif
++++++
#if defined (upstream)
//default argument set in Marlin.h
#endif
++++++
#if defined (upstream)
(blocks_queued() == false && ignore_stepper_queue == false)
#endif
++++++
#if defined (indi-RichCattell)
(blocks_queued() == false)
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)

       killCount++;
    

#endif
++++++
#if defined (indi-RichCattell) && (defined(KILL_PIN) && KILL_PIN > -1)kill();
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
else if (killCount > 0)
    {
       killCount--;
    }
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
else if (killCount > 0)
    {
       killCount--;
    }
#endif
++++++
#if defined (upstream) && defined (EXTRUDER_RUNOUT_PREVENT)
plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
                      destination[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
#endif
++++++
#if defined (indi-RichCattell) && defined (EXTRUDER_RUNOUT_PREVENT)
plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],
                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
static int killCount = 0;
#endif
++++++
#if defined (upstream) && (defined(HOME_PIN) && HOME_PIN > -1)
static int homeDebounceCount = 0;
#endif
++++++
#if defined (upstream)
if(buflen < (BUFSIZE-1))
    get_command();
#endif
++++++
#if defined (upstream) && defined (CHDK)
//Check if pin should be set to LOW after M240 set it to HIGH
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
// Check if the kill button was pressed and wait just in case it was an accidental
#endif
++++++
#if defined (upstream) && (defined(KILL_PIN) && KILL_PIN > -1)
// Exceeded threshold and we can confirm that it was not accidental
#endif
++++++
#if defined (upstream) && (defined(HOME_PIN) && HOME_PIN > -1)
// Check to see if we have to home, use poor man's debouncer
#endif
++++++
#if defined (upstream) && defined (TEMP_STAT_LEDS)
handle_status_leds();
#endif
++++++
#if defined (upstream)
// FMC small patch to update the LCD before ending
#endif
++++++
#if defined (upstream)
case 221:
          SERIAL_ECHO(MSG_M221_INVALID_EXTRUDER);
          break;
      
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
float x_tmp, y_tmp, z_tmp, real_z;
#endif
++++++
#if defined (upstream) && defined (DELTA)
void recalc_delta_settings(float radius, float diagonal_rod)
{
	 delta_tower1_x= -SIN_60*radius; // front left tower
	 delta_tower1_y= -COS_60*radius;	   
	 delta_tower2_x=  SIN_60*radius; // front right tower
	 delta_tower2_y= -COS_60*radius;	   
	 delta_tower3_x= 0.0;                  // back middle tower
	 delta_tower3_y= radius;
	 delta_diagonal_rod_2= sq(diagonal_rod);
}
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
// Adjust print surface height by linear interpolation over the bed_level array.
#endif
++++++
#if defined (indi-RichCattell)
void prepare_move_raw()
{
  previous_millis_cmd = millis();
  calculate_delta(destination);
  plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
		   destination[E_AXIS], feedrate*feedmultiply/60/100.0,
		   active_extruder);
  for(int8_t i=0; i < NUM_AXIS; i++) {
    current_position[i] = destination[i];
  }
}
#endif
++++++
#if defined (upstream) && defined (SCARA)
void calculate_SCARA_forward_Transform(float f_scara[3])
{
  // Perform forward kinematics, and place results in delta[3]
  // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
  
  float x_sin, x_cos, y_sin, y_cos;
  
    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);
    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);
  
    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;
    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;
   
  //  SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);
  //  SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);
  //  SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);
  //  SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);
  
    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta
    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi
	
    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);
    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
}
#endif
++++++
#if defined (upstream) && defined (TEMP_STAT_LEDS)
static bool blue_led = false;
#endif
++++++
#if defined (upstream)
float calculate_volumetric_multiplier(float diameter) {
	float area = .0;
	float radius = .0;

	radius = diameter * .5;
	if (! volumetric_enabled || radius == 0) {
		area = 1;
	}
	else {
		area = M_PI * pow(radius, 2);
	}

	return 1.0 / area;
}
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
#include "vector_3.h"
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && defined (AUTO_BED_LEVELING_GRID) )
#include "qr_solve.h"
#endif
++++++
#if defined (upstream)
// ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (upstream)
#include "math.h"
#endif
++++++
#if defined (upstream) && defined (BLINKM)
#include "BlinkM.h"
#endif
++++++
#if defined (upstream)
#define VERSION_STRING  "1.0.2"
#endif
++++++
#if defined (indi-RichCattell)
#define VERSION_STRING  "1.0.0"
#endif
++++++
#if defined (upstream)
// look here for descriptions of G-codes: http://linuxcnc.org/handbook/gcode/g-code.html
#endif
++++++
#if defined (indi-RichCattell)
// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html
#endif
++++++
#if defined (upstream)
// G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
#endif
++++++
#if defined (indi-RichCattell)
// G29 - Calibrate print surface with automatic Z probe
#endif
++++++
#if defined (upstream)
// G30 - Single Z Probe, probes bed at current XY location.
#endif
++++++
#if defined (indi-RichCattell)
// G30 - Bed Probe and Delta geometry Autocalibration
#endif
++++++
#if defined (upstream)
// G31 - Dock sled (Z_PROBE_SLED only)
#endif
++++++
#if defined (upstream)
// G92 - Set current position to coordinates given
#endif
++++++
#if defined (indi-RichCattell)
// G92 - Set current position to cordinates given
#endif
++++++
#if defined (upstream)
// M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
#endif
++++++
#if defined (indi-RichCattell)
// M32  - Select file and start SD print (Can be used when printing from SD card)
#endif
++++++
#if defined (upstream)
//        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
#endif
++++++
#if defined (upstream)
//        IF AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
#endif
++++++
#if defined (upstream)
// M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
#endif
++++++
#if defined (upstream)
// M200 D<millimeters>- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
#endif
++++++
#if defined (indi-RichCattell)
// M200 - Set filament diameter
#endif
++++++
#if defined (upstream)
// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
#endif
++++++
#if defined (indi-RichCattell)
// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate
#endif
++++++
#if defined (upstream)
// M206 - set additional homing offset
#endif
++++++
#if defined (indi-RichCattell)
// M206 - set additional homeing offset
#endif
++++++
#if defined (upstream)
// M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
#endif
++++++
#if defined (indi-RichCattell)
// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]
#endif
++++++
#if defined (upstream)
// M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
#endif
++++++
#if defined (upstream)
// M401 - Lower z-probe if present
#endif
++++++
#if defined (indi-RichCattell)
// M500 - stores paramters in EEPROM
#endif
++++++
#if defined (upstream)
// M402 - Raise z-probe if present
#endif
++++++
#if defined (upstream)
// M503 - print the current settings (from memory not from EEPROM)
#endif
++++++
#if defined (indi-RichCattell)
// M503 - print the current settings (from memory not from eeprom)
#endif
++++++
#if defined (upstream)
// M665 - set delta configurations
#endif
++++++
#if defined (indi-RichCattell)
// M666 - Endstop and delta geometry adjustment
#endif
++++++
#if defined (upstream)
// ************ SCARA Specific - This can change to suit future G-code regulations
#endif
++++++
#if defined (indi-RichCattell)
float default_z_probe_offset[] = Z_PROBE_OFFSET;
#endif
++++++
#if defined (upstream)
int extruder_multiply[EXTRUDERS] = {100
  #if EXTRUDERS > 1
    , 100
    #if EXTRUDERS > 2
      , 100
    #endif
  #endif
};
#endif
++++++
#if defined (upstream)
float add_homing[3]={0,0,0};
#endif
++++++
#if defined (indi-RichCattell)
float add_homeing[3]={0,0,0};
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
float tower_adj[6]={0,0,0,0,0,0};
#endif
++++++
#if defined (upstream)
bool axis_known_position[3] = {false, false, false};
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
bool autoretract_enabled=false;
#endif
++++++
#if defined (indi-RichCattell) && defined (FWRETRACT)
bool autoretract_enabled=true;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
bool retracted[EXTRUDERS]={false
    #if EXTRUDERS > 1
    , false
     #if EXTRUDERS > 2
      , false
     #endif
  #endif
  };
#endif
++++++
#if defined (indi-RichCattell) && defined (FWRETRACT)
bool retracted=false;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
bool retracted_swap[EXTRUDERS]={false
    #if EXTRUDERS > 1
    , false
     #if EXTRUDERS > 2
      , false
     #endif
  #endif
  };
#endif
++++++
#if defined (indi-RichCattell) && defined (FWRETRACT)
float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
float retract_length = RETRACT_LENGTH;
#endif
++++++
#if defined (indi-RichCattell) && defined (FWRETRACT)
float retract_recover_length=0, retract_recover_feedrate=8*60;
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
float retract_length_swap = RETRACT_LENGTH_SWAP;
#endif
++++++
#if defined (upstream) && (defined (ULTIPANEL) && defined (PS_DEFAULT_OFF) )
bool powersupply = false;
#endif
++++++
#if defined (upstream) && defined (DELTA)
#define SIN_60 0.8660254037844386
#endif
++++++
#if defined (indi-RichCattell) && defined (DELTA)
float delta_tmp[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (upstream) && defined (DELTA)
#define COS_60 0.5
#endif
++++++
#if defined (upstream) && defined (SCARA)
// Build size scaling
#endif
++++++
#if defined (upstream)
bool cancel_heatup = false ;
#endif
++++++
#if defined (upstream) && defined (FILAMENT_SENSOR)
//Variables for Filament Sensor input 
#endif
++++++
#if defined (upstream)
const char errormagic[] PROGMEM = "Error:";
#endif
++++++
#if defined (upstream)
//=============================Private Variables=============================
#endif
++++++
#if defined (indi-RichCattell)
//=============================private variables=============================
#endif
++++++
#if defined (indi-RichCattell)
const float SIN_60 = 0.8660254037844386;
#endif
++++++
#if defined (upstream) && !defined (DELTA)
static float delta[3] = {0.0, 0.0, 0.0};
#endif
++++++
#if defined (indi-RichCattell)
static float bed_level[7][7] = {
  {0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0, 0},
};
#endif
++++++
#if defined (upstream)
static float feedrate = 1500.0, next_feedrate, saved_feedrate;
#endif
++++++
#if defined (indi-RichCattell)
static float feedrate = 1500.0, next_feedrate, saved_feedrate, z_offset;
#endif
++++++
#if defined (indi-RichCattell)
static int loopcount;
#endif
++++++
#if defined (upstream)
// just a pointer to find chars in the command string like X, Y, Z, E, etc
#endif
++++++
#if defined (indi-RichCattell)
// just a pointer to find chars in the cmd string like X, Y, Z, E, etc
#endif
++++++
#if defined (upstream)
//Insert variables if CHDK is defined
#endif
++++++
#if defined (upstream) && defined (CHDK)
unsigned long chdkHigh = 0;
#endif
++++++
#if defined (upstream)
//=============================Routines======================================
#endif
++++++
#if defined (indi-RichCattell)
//=============================ROUTINES=============================
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
#include "SdFatUtil.h"
#endif
++++++
#if defined (upstream)
//!SDSUPPORT
#endif
++++++
#if defined (upstream)
// Set home pin
#endif
++++++
#if defined (upstream)
XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
#endif
++++++
#if defined (indi-RichCattell)
//XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);
#endif
++++++
#if defined (upstream)
XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
#endif
++++++
#if defined (indi-RichCattell)
//XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);
#endif
++++++
#if defined (upstream)
XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
#endif
++++++
#if defined (indi-RichCattell)
//XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);
#endif
++++++
#if defined (upstream) && (defined (DUAL_X_CARRIAGE) && (EXTRUDERS == 1 || defined(COREXY) \
      || !defined(X2_ENABLE_PIN) || !defined(X2_STEP_PIN) || !defined(X2_DIR_PIN) \
      || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \
      || !defined(X_MAX_PIN) || X_MAX_PIN < 0 &) || defined (indi-RichCattell) && (defined (DUAL_X_CARRIAGE) && (EXTRUDERS == 1 || defined(COREXY) \
      || !defined(X2_ENABLE_PIN) || !defined(X2_STEP_PIN) || !defined(X2_DIR_PIN) \
      || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \
      || !defined(X_MAX_PIN) || X_MAX_PIN < 0 &)
#error "Missing or invalid definitions for DUAL_X_CARRIAGE mode."
#endif
++++++
#if defined (upstream) && (defined (ENABLE_AUTO_BED_LEVELING) && defined (AUTO_BED_LEVELING_GRID) )
static void set_bed_level_equation_lsq(double *plane_equation_coefficients)
{
    vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);
    planeNormal.debug("planeNormal");
    plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
    //bedLevel.debug("bedLevel");

    //plan_bed_level_matrix.debug("bed level before");
    //vector_3 uncorrected_position = plan_get_position_mm();
    //uncorrected_position.debug("position before");

    vector_3 corrected_position = plan_get_position();
//    corrected_position.debug("position after");
    current_position[X_AXIS] = corrected_position.x;
    current_position[Y_AXIS] = corrected_position.y;
    current_position[Z_AXIS] = corrected_position.z;

    // put the bed at 0 so we don't go below it.
    current_position[Z_AXIS] = zprobe_zoffset; // in the lsq we reach here after raising the extruder due to the loop structure

    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
}
#endif
++++++
#if defined (upstream) && (!defined (AUTO_BED_LEVELING_GRID) && defined (ENABLE_AUTO_BED_LEVELING) )
// not AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (upstream) && defined (ENABLE_AUTO_BED_LEVELING)
// AUTO_BED_LEVELING_GRID
#endif
++++++
#if defined (upstream)
// #ifdef ENABLE_AUTO_BED_LEVELING
#endif
++++++
#if defined (upstream)
void refresh_cmd_timeout(void)
{
  previous_millis_cmd = millis();
}
#endif
++++++
#if defined (indi-RichCattell)
void set_default_z_probe_offset()
  {
  z_probe_offset[X_AXIS] = default_z_probe_offset[X_AXIS];
  z_probe_offset[Y_AXIS] = default_z_probe_offset[Y_AXIS];
  z_probe_offset[Z_AXIS] = default_z_probe_offset[Z_AXIS];
  }
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
void retract(bool retracting, bool swapretract = false) {
    if(retracting && !retracted[active_extruder]) {
      destination[X_AXIS]=current_position[X_AXIS];
      destination[Y_AXIS]=current_position[Y_AXIS];
      destination[Z_AXIS]=current_position[Z_AXIS];
      destination[E_AXIS]=current_position[E_AXIS];
      if (swapretract) {
        current_position[E_AXIS]+=retract_length_swap/volumetric_multiplier[active_extruder];
      } else {
        current_position[E_AXIS]+=retract_length/volumetric_multiplier[active_extruder];
      }
      plan_set_e_position(current_position[E_AXIS]);
      float oldFeedrate = feedrate;
      feedrate=retract_feedrate*60;
      retracted[active_extruder]=true;
      prepare_move();
      current_position[Z_AXIS]-=retract_zlift;
#ifdef DELTA
      calculate_delta(current_position); // change cartesian kinematic to  delta kinematic;
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#else
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
      prepare_move();
      feedrate = oldFeedrate;
    } else if(!retracting && retracted[active_extruder]) {
      destination[X_AXIS]=current_position[X_AXIS];
      destination[Y_AXIS]=current_position[Y_AXIS];
      destination[Z_AXIS]=current_position[Z_AXIS];
      destination[E_AXIS]=current_position[E_AXIS];
      current_position[Z_AXIS]+=retract_zlift;
#ifdef DELTA
      calculate_delta(current_position); // change cartesian kinematic  to  delta kinematic;
      plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
#else
      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
#endif
      //prepare_move();
      if (swapretract) {
        current_position[E_AXIS]-=(retract_length_swap+retract_recover_length_swap)/volumetric_multiplier[active_extruder]; 
      } else {
        current_position[E_AXIS]-=(retract_length+retract_recover_length)/volumetric_multiplier[active_extruder]; 
      }
      plan_set_e_position(current_position[E_AXIS]);
      float oldFeedrate = feedrate;
      feedrate=retract_recover_feedrate*60;
      retracted[active_extruder]=false;
      prepare_move();
      feedrate = oldFeedrate;
    }
  }
#endif
++++++
#if defined (indi-RichCattell)
void set_delta_constants()
{
  max_length[Z_AXIS] = max_pos[Z_AXIS] - Z_MIN_POS;
  base_max_pos[Z_AXIS]  = max_pos[Z_AXIS];
  base_home_pos[Z_AXIS] = max_pos[Z_AXIS];
  
  DELTA_DIAGONAL_ROD_2 = pow(delta_diagonal_rod,2);
  
  // Effective X/Y positions of the three vertical towers.
  /*
  delta_tower1_x = (-SIN_60 * delta_radius) + tower_adj[0]; // front left tower + xa
  delta_tower1_y = (-COS_60 * delta_radius) - tower_adj[0] ;
  delta_tower2_x = -(-SIN_60 * delta_radius) + tower_adj[1]; // front right tower + xb
  delta_tower2_y = (-COS_60 * delta_radius) + tower_adj[1]; // 
  delta_tower3_x = tower_adj[2] ; // back middle tower + xc
  delta_tower3_y = -2 * (-COS_60 * delta_radius);  
  */
  
  delta_tower1_x = (delta_radius + tower_adj[3]) * cos((210 + tower_adj[0]) * PI/180); // front left tower
  delta_tower1_y = (delta_radius + tower_adj[3]) * sin((210 + tower_adj[0]) * PI/180); 
  delta_tower2_x = (delta_radius + tower_adj[4]) * cos((330 + tower_adj[1]) * PI/180); // front right tower
  delta_tower2_y = (delta_radius + tower_adj[4]) * sin((330 + tower_adj[1]) * PI/180); 
  delta_tower3_x = (delta_radius + tower_adj[5]) * cos((90 + tower_adj[2]) * PI/180);  // back middle tower
  delta_tower3_y = (delta_radius + tower_adj[5]) * sin((90 + tower_adj[2]) * PI/180); 
}
#endif
++++++
#if defined (upstream) && defined (FWRETRACT)
//retract
#endif
++++++
#if defined (indi-RichCattell)
void deploy_z_probe() {
  feedrate = homing_feedrate[X_AXIS];
  destination[X_AXIS] = z_probe_deploy_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_deploy_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_deploy_start_location[Z_AXIS];
  prepare_move_raw();

  feedrate = homing_feedrate[X_AXIS]/10;
  destination[X_AXIS] = z_probe_deploy_end_location[X_AXIS];
  destination[Y_AXIS] = z_probe_deploy_end_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_deploy_end_location[Z_AXIS];
  prepare_move_raw();

  feedrate = homing_feedrate[X_AXIS];
  destination[X_AXIS] = z_probe_deploy_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_deploy_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_deploy_start_location[Z_AXIS];
  prepare_move_raw();
  st_synchronize();
}
#endif
#if defined (indi-RichCattell)
void deploy_z_probe() {
  feedrate = homing_feedrate[X_AXIS];
  destination[X_AXIS] = z_probe_deploy_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_deploy_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_deploy_start_location[Z_AXIS];
  prepare_move_raw();

  feedrate = homing_feedrate[X_AXIS]/10;
  destination[X_AXIS] = z_probe_deploy_end_location[X_AXIS];
  destination[Y_AXIS] = z_probe_deploy_end_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_deploy_end_location[Z_AXIS];
  prepare_move_raw();

  feedrate = homing_feedrate[X_AXIS];
  destination[X_AXIS] = z_probe_deploy_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_deploy_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_deploy_start_location[Z_AXIS];
  prepare_move_raw();
  st_synchronize();
}
#endif
++++++
#if defined (upstream)
//FWRETRACT
#endif
++++++
#if defined (indi-RichCattell)
void retract_z_probe() {
  feedrate = homing_feedrate[X_AXIS];
  destination[Z_AXIS] = 50;
  prepare_move_raw();

  destination[X_AXIS] = z_probe_retract_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_retract_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_retract_start_location[Z_AXIS];
  prepare_move();
  prepare_move_raw();

  // Move the nozzle below the print surface to push the probe up.
  feedrate = homing_feedrate[Z_AXIS]/10;
  destination[X_AXIS] = z_probe_retract_end_location[X_AXIS];
  destination[Y_AXIS] = z_probe_retract_end_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_retract_end_location[Z_AXIS];
  prepare_move_raw();

  feedrate = homing_feedrate[Z_AXIS];
  destination[X_AXIS] = z_probe_retract_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_retract_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_retract_start_location[Z_AXIS];
  prepare_move_raw();
  st_synchronize();
}
#endif
#if defined (indi-RichCattell)
void retract_z_probe() {
  feedrate = homing_feedrate[X_AXIS];
  destination[Z_AXIS] = 50;
  prepare_move_raw();

  destination[X_AXIS] = z_probe_retract_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_retract_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_retract_start_location[Z_AXIS];
  prepare_move();
  prepare_move_raw();

  // Move the nozzle below the print surface to push the probe up.
  feedrate = homing_feedrate[Z_AXIS]/10;
  destination[X_AXIS] = z_probe_retract_end_location[X_AXIS];
  destination[Y_AXIS] = z_probe_retract_end_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_retract_end_location[Z_AXIS];
  prepare_move_raw();

  feedrate = homing_feedrate[Z_AXIS];
  destination[X_AXIS] = z_probe_retract_start_location[X_AXIS];
  destination[Y_AXIS] = z_probe_retract_start_location[Y_AXIS];
  destination[Z_AXIS] = z_probe_retract_start_location[Z_AXIS];
  prepare_move_raw();
  st_synchronize();
}
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++
#if defined (indi-RichCattell)
float z_probe() {
  feedrate = homing_feedrate[X_AXIS];
  prepare_move_raw();
  st_synchronize();

  enable_endstops(true);
  float start_z = current_position[Z_AXIS];
  long start_steps = st_get_position(Z_AXIS);

  feedrate = homing_feedrate[Z_AXIS]/10;
  destination[Z_AXIS] = -20;
  prepare_move_raw();
  st_synchronize();
  endstops_hit_on_purpose();

  enable_endstops(false);
  long stop_steps = st_get_position(Z_AXIS);
  
  saved_position[X_AXIS] = float((st_get_position(X_AXIS)) / axis_steps_per_unit[X_AXIS]);
  saved_position[Y_AXIS] = float((st_get_position(Y_AXIS)) / axis_steps_per_unit[Y_AXIS]);
  saved_position[Z_AXIS] = float((st_get_position(Z_AXIS)) / axis_steps_per_unit[Z_AXIS]);

  float mm = start_z -
    float(start_steps - stop_steps) / axis_steps_per_unit[Z_AXIS];
  current_position[Z_AXIS] = mm;
  calculate_delta(current_position);
  plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
		    current_position[E_AXIS]);

  saved_position[X_AXIS] = float((st_get_position(X_AXIS)) / axis_steps_per_unit[X_AXIS]);
  saved_position[Y_AXIS] = float((st_get_position(Y_AXIS)) / axis_steps_per_unit[Y_AXIS]);
  saved_position[Z_AXIS] = float((st_get_position(Z_AXIS)) / axis_steps_per_unit[Z_AXIS]);

  feedrate = homing_feedrate[Z_AXIS];
  destination[Z_AXIS] = mm+2;
  prepare_move_raw();
  return mm;
}
#endif
#if defined (indi-RichCattell)
float z_probe() {
  feedrate = homing_feedrate[X_AXIS];
  prepare_move_raw();
  st_synchronize();

  enable_endstops(true);
  float start_z = current_position[Z_AXIS];
  long start_steps = st_get_position(Z_AXIS);

  feedrate = homing_feedrate[Z_AXIS]/10;
  destination[Z_AXIS] = -20;
  prepare_move_raw();
  st_synchronize();
  endstops_hit_on_purpose();

  enable_endstops(false);
  long stop_steps = st_get_position(Z_AXIS);
  
  saved_position[X_AXIS] = float((st_get_position(X_AXIS)) / axis_steps_per_unit[X_AXIS]);
  saved_position[Y_AXIS] = float((st_get_position(Y_AXIS)) / axis_steps_per_unit[Y_AXIS]);
  saved_position[Z_AXIS] = float((st_get_position(Z_AXIS)) / axis_steps_per_unit[Z_AXIS]);

  float mm = start_z -
    float(start_steps - stop_steps) / axis_steps_per_unit[Z_AXIS];
  current_position[Z_AXIS] = mm;
  calculate_delta(current_position);
  plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],
		    current_position[E_AXIS]);

  saved_position[X_AXIS] = float((st_get_position(X_AXIS)) / axis_steps_per_unit[X_AXIS]);
  saved_position[Y_AXIS] = float((st_get_position(Y_AXIS)) / axis_steps_per_unit[Y_AXIS]);
  saved_position[Z_AXIS] = float((st_get_position(Z_AXIS)) / axis_steps_per_unit[Z_AXIS]);

  feedrate = homing_feedrate[Z_AXIS];
  destination[Z_AXIS] = mm+2;
  prepare_move_raw();
  return mm;
}
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
// Method to dock/undock a sled designed by Charles Bell.
#endif
++++++
#if defined (indi-RichCattell)
void calibrate_print_surface(float z_offset)
{
    float probe_bed_z, probe_z, probe_h, probe_l;
    int probe_count;
      
    for (int y = 3; y >= -3; y--) {
    int dir = y % 2 ? -1 : 1;
    for (int x = -3*dir; x != 4*dir; x += dir) {
      if (x*x + y*y < 11) {
	destination[X_AXIS] = AUTOLEVEL_GRID * x - z_probe_offset[X_AXIS];
	destination[Y_AXIS] = AUTOLEVEL_GRID * y - z_probe_offset[Y_AXIS];

        probe_count = 0;
        probe_z = -100;
        probe_h = -100;
        probe_l = 100;
        do {
           probe_bed_z = probe_z;
           probe_z = z_probe() + z_offset;
           if (probe_z > probe_h) probe_h = probe_z;
           if (probe_z < probe_l) probe_l = probe_z;
           probe_count ++;
           } while ((probe_z != probe_bed_z) and (probe_count < 21));

	bed_level[x+3][3-y] = probe_bed_z;
      } else {
	bed_level[x+3][3-y] = 0.0;
      }
    }
    // For unprobed positions just copy nearest neighbor.
    if (abs(y) >= 3) {
      bed_level[1][3-y] = bed_level[2][3-y];
      bed_level[5][3-y] = bed_level[4][3-y];
    }
    if (abs(y) >=2) {
      bed_level[0][3-y] = bed_level[1][3-y];
      bed_level[6][3-y] = bed_level[5][3-y];
    }
    // Print calibration results for manual frame adjustment.
    for (int x = -3; x <= 3; x++) {
      SERIAL_PROTOCOL_F(bed_level[x+3][3-y], 3);
      SERIAL_PROTOCOLPGM(" ");
    }
    SERIAL_ECHOLN("");
  }
}
#endif
#if defined (indi-RichCattell)
void calibrate_print_surface(float z_offset)
{
    float probe_bed_z, probe_z, probe_h, probe_l;
    int probe_count;
      
    for (int y = 3; y >= -3; y--) {
    int dir = y % 2 ? -1 : 1;
    for (int x = -3*dir; x != 4*dir; x += dir) {
      if (x*x + y*y < 11) {
	destination[X_AXIS] = AUTOLEVEL_GRID * x - z_probe_offset[X_AXIS];
	destination[Y_AXIS] = AUTOLEVEL_GRID * y - z_probe_offset[Y_AXIS];

        probe_count = 0;
        probe_z = -100;
        probe_h = -100;
        probe_l = 100;
        do {
           probe_bed_z = probe_z;
           probe_z = z_probe() + z_offset;
           if (probe_z > probe_h) probe_h = probe_z;
           if (probe_z < probe_l) probe_l = probe_z;
           probe_count ++;
           } while ((probe_z != probe_bed_z) and (probe_count < 21));

	bed_level[x+3][3-y] = probe_bed_z;
      } else {
	bed_level[x+3][3-y] = 0.0;
      }
    }
    // For unprobed positions just copy nearest neighbor.
    if (abs(y) >= 3) {
      bed_level[1][3-y] = bed_level[2][3-y];
      bed_level[5][3-y] = bed_level[4][3-y];
    }
    if (abs(y) >=2) {
      bed_level[0][3-y] = bed_level[1][3-y];
      bed_level[6][3-y] = bed_level[5][3-y];
    }
    // Print calibration results for manual frame adjustment.
    for (int x = -3; x <= 3; x++) {
      SERIAL_PROTOCOL_F(bed_level[x+3][3-y], 3);
      SERIAL_PROTOCOLPGM(" ");
    }
    SERIAL_ECHOLN("");
  }
}
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++
#if defined (indi-RichCattell)
float probe_bed(float x, float y)
  {
  //Probe bed at specified location and return z height of bed
  float probe_bed_z, probe_z, probe_h, probe_l;
  int probe_count;
//  feedrate = homing_feedrate[Z_AXIS];
  destination[X_AXIS] = x - z_probe_offset[X_AXIS];
  destination[Y_AXIS] = y - z_probe_offset[Y_AXIS];
  destination[Z_AXIS] = bed_level_c - z_probe_offset[Z_AXIS] + 3;
  prepare_move();
  st_synchronize();

  probe_count = 0;
  probe_z = -100;
  probe_h = -100;
  probe_l = 100;
  do {
    probe_bed_z = probe_z;
    probe_z = z_probe() + z_probe_offset[Z_AXIS];
    if (probe_z > probe_h) probe_h = probe_z;
    if (probe_z < probe_l) probe_l = probe_z;
    probe_count ++;
    //SERIAL_PROTOCOL_F(probe_z,3);
    //SERIAL_ECHO(" ");
    } while ((probe_z != probe_bed_z) and (probe_count < 21));
    //SERIAL_ECHOLN("");
  /*
  if (probe_count > 2)
    {
    SERIAL_ECHO("Z-Probe error: ");
    SERIAL_PROTOCOL_F(probe_h - probe_l, 3);
    SERIAL_ECHO("mm in ");
    SERIAL_ECHO(probe_count);
    SERIAL_ECHO(" probes");
    if (probe_count == 20)
      {
      SERIAL_ECHO(" (unable to get 2x consistant probes!)");
      }
    SERIAL_ECHOLN("");
    }
    */
  /*
  SERIAL_ECHO("Bed Z-Height at X:");
  SERIAL_ECHO(x);
  SERIAL_ECHO(" Y:");
  SERIAL_ECHO(y);
  SERIAL_ECHO(" = ");
  SERIAL_PROTOCOL_F(probe_bed_z, 4);
  SERIAL_ECHOLN("");      
  */

  return probe_bed_z;
  }
#endif
#if defined (indi-RichCattell)
float probe_bed(float x, float y)
  {
  //Probe bed at specified location and return z height of bed
  float probe_bed_z, probe_z, probe_h, probe_l;
  int probe_count;
//  feedrate = homing_feedrate[Z_AXIS];
  destination[X_AXIS] = x - z_probe_offset[X_AXIS];
  destination[Y_AXIS] = y - z_probe_offset[Y_AXIS];
  destination[Z_AXIS] = bed_level_c - z_probe_offset[Z_AXIS] + 3;
  prepare_move();
  st_synchronize();

  probe_count = 0;
  probe_z = -100;
  probe_h = -100;
  probe_l = 100;
  do {
    probe_bed_z = probe_z;
    probe_z = z_probe() + z_probe_offset[Z_AXIS];
    if (probe_z > probe_h) probe_h = probe_z;
    if (probe_z < probe_l) probe_l = probe_z;
    probe_count ++;
    //SERIAL_PROTOCOL_F(probe_z,3);
    //SERIAL_ECHO(" ");
    } while ((probe_z != probe_bed_z) and (probe_count < 21));
    //SERIAL_ECHOLN("");
  /*
  if (probe_count > 2)
    {
    SERIAL_ECHO("Z-Probe error: ");
    SERIAL_PROTOCOL_F(probe_h - probe_l, 3);
    SERIAL_ECHO("mm in ");
    SERIAL_ECHO(probe_count);
    SERIAL_ECHO(" probes");
    if (probe_count == 20)
      {
      SERIAL_ECHO(" (unable to get 2x consistant probes!)");
      }
    SERIAL_ECHOLN("");
    }
    */
  /*
  SERIAL_ECHO("Bed Z-Height at X:");
  SERIAL_ECHO(x);
  SERIAL_ECHO(" Y:");
  SERIAL_ECHO(y);
  SERIAL_ECHO(" = ");
  SERIAL_PROTOCOL_F(probe_bed_z, 4);
  SERIAL_ECHOLN("");      
  */

  return probe_bed_z;
  }
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
// dock[in]     If true, move to MAX_X and engage the electromagnet
#endif
++++++
#if defined (indi-RichCattell)
float z_probe_accuracy()
  {  
  //Perform z-probe accuracy test
  float probe_h[7];
  float probe_l[7];
  float range_h = 0, range_l = 0;
  
  for(int x=0; x < 7; x++)
    {
    probe_h[x] = -100;
    probe_l[x] = 100;
    }
    
  // probe test loop  
  for(int x=0; x<3; x++)
   {
   bed_probe_all();
   
   if (bed_level_c > probe_h[0]) probe_h[0] = bed_level_c;
   if (bed_level_c < probe_l[0]) probe_l[0] = bed_level_c;
   if (bed_level_z > probe_h[1]) probe_h[1] = bed_level_z;
   if (bed_level_z < probe_l[1]) probe_l[1] = bed_level_z;
   if (bed_level_oy > probe_h[2]) probe_h[2] = bed_level_oy;
   if (bed_level_oy < probe_l[2]) probe_l[2] = bed_level_oy;
   if (bed_level_x > probe_h[3]) probe_h[3] = bed_level_x;
   if (bed_level_x < probe_l[3]) probe_l[3] = bed_level_x;
   if (bed_level_oz > probe_h[4]) probe_h[4] = bed_level_oz;
   if (bed_level_oz < probe_l[4]) probe_l[4] = bed_level_oz;
   if (bed_level_y > probe_h[5]) probe_h[5] = bed_level_y;
   if (bed_level_y < probe_l[5]) probe_l[5] = bed_level_y;
   if (bed_level_ox > probe_h[6]) probe_h[6] = bed_level_ox;
   if (bed_level_ox < probe_l[6]) probe_l[6] = bed_level_ox;
   }
   for(int x=0; x < 7; x++)
     {
     if (probe_h[x] - probe_l[x] > range_h) range_h = probe_h[x] - probe_l[x];
     if (probe_h[x] - probe_l[x] < range_l) range_l = probe_h[x] - probe_l[x];
     }
  return range_h - range_l;
  }
#endif
#if defined (indi-RichCattell)
float z_probe_accuracy()
  {  
  //Perform z-probe accuracy test
  float probe_h[7];
  float probe_l[7];
  float range_h = 0, range_l = 0;
  
  for(int x=0; x < 7; x++)
    {
    probe_h[x] = -100;
    probe_l[x] = 100;
    }
    
  // probe test loop  
  for(int x=0; x<3; x++)
   {
   bed_probe_all();
   
   if (bed_level_c > probe_h[0]) probe_h[0] = bed_level_c;
   if (bed_level_c < probe_l[0]) probe_l[0] = bed_level_c;
   if (bed_level_z > probe_h[1]) probe_h[1] = bed_level_z;
   if (bed_level_z < probe_l[1]) probe_l[1] = bed_level_z;
   if (bed_level_oy > probe_h[2]) probe_h[2] = bed_level_oy;
   if (bed_level_oy < probe_l[2]) probe_l[2] = bed_level_oy;
   if (bed_level_x > probe_h[3]) probe_h[3] = bed_level_x;
   if (bed_level_x < probe_l[3]) probe_l[3] = bed_level_x;
   if (bed_level_oz > probe_h[4]) probe_h[4] = bed_level_oz;
   if (bed_level_oz < probe_l[4]) probe_l[4] = bed_level_oz;
   if (bed_level_y > probe_h[5]) probe_h[5] = bed_level_y;
   if (bed_level_y < probe_l[5]) probe_l[5] = bed_level_y;
   if (bed_level_ox > probe_h[6]) probe_h[6] = bed_level_ox;
   if (bed_level_ox < probe_l[6]) probe_l[6] = bed_level_ox;
   }
   for(int x=0; x < 7; x++)
     {
     if (probe_h[x] - probe_l[x] > range_h) range_h = probe_h[x] - probe_l[x];
     if (probe_h[x] - probe_l[x] < range_l) range_l = probe_h[x] - probe_l[x];
     }
  return range_h - range_l;
  }
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
// offset[in]   The additional distance to move to adjust docking location
#endif
++++++
#if defined (indi-RichCattell)
void bed_probe_all()
  {
  //Probe all bed positions & store carriage positions
  bed_level_c = probe_bed(0.0, 0.0);      
  save_carriage_positions(0);
  bed_level_z = probe_bed(0.0, bed_radius);
  save_carriage_positions(1);
  bed_level_oy = probe_bed(-SIN_60 * bed_radius, COS_60 * bed_radius);
  save_carriage_positions(2);
  bed_level_x = probe_bed(-SIN_60 * bed_radius, -COS_60 * bed_radius);
  save_carriage_positions(3);
  bed_level_oz = probe_bed(0.0, -bed_radius);
  save_carriage_positions(4);
  bed_level_y = probe_bed(SIN_60 * bed_radius, -COS_60 * bed_radius);
  save_carriage_positions(5);
  bed_level_ox = probe_bed(SIN_60 * bed_radius, COS_60 * bed_radius);
  save_carriage_positions(6);    
  }
#endif
#if defined (indi-RichCattell)
void bed_probe_all()
  {
  //Probe all bed positions & store carriage positions
  bed_level_c = probe_bed(0.0, 0.0);      
  save_carriage_positions(0);
  bed_level_z = probe_bed(0.0, bed_radius);
  save_carriage_positions(1);
  bed_level_oy = probe_bed(-SIN_60 * bed_radius, COS_60 * bed_radius);
  save_carriage_positions(2);
  bed_level_x = probe_bed(-SIN_60 * bed_radius, -COS_60 * bed_radius);
  save_carriage_positions(3);
  bed_level_oz = probe_bed(0.0, -bed_radius);
  save_carriage_positions(4);
  bed_level_y = probe_bed(SIN_60 * bed_radius, -COS_60 * bed_radius);
  save_carriage_positions(5);
  bed_level_ox = probe_bed(SIN_60 * bed_radius, COS_60 * bed_radius);
  save_carriage_positions(6);    
  }
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
//
#endif
++++++
#if defined (indi-RichCattell)
void calibration_report()
  {
  
  //Display Report
  SERIAL_ECHOLN("\tZ-Tower\t\t\tEndstop Offsets");

  SERIAL_ECHO("\t");
  SERIAL_PROTOCOL_F(bed_level_z, 4);
  SERIAL_ECHOPAIR("\t\t\tX:",endstop_adj[0]);
  SERIAL_ECHOPAIR(" Y:",endstop_adj[1]);
  SERIAL_ECHOPAIR(" Z:",endstop_adj[2]);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOL_F(bed_level_oy, 4);
  SERIAL_PROTOCOLPGM("\t\t");
  SERIAL_PROTOCOL_F(bed_level_ox, 4);
  SERIAL_ECHOLN("\t\tTower Position Adjust");

  SERIAL_PROTOCOLPGM("\t");
  SERIAL_PROTOCOL_F(bed_level_c, 4);
  SERIAL_ECHOPAIR("\t\t\tA:",tower_adj[0]);
  SERIAL_ECHOPAIR(" B:",tower_adj[1]);
  SERIAL_ECHOPAIR(" C:",tower_adj[2]);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOL_F(bed_level_x, 4);
  SERIAL_PROTOCOLPGM("\t\t");
  SERIAL_PROTOCOL_F(bed_level_y, 4);
  SERIAL_ECHOPAIR("\t\tI:",tower_adj[3]);
  SERIAL_ECHOPAIR(" J:",tower_adj[4]);
  SERIAL_ECHOPAIR(" K:",tower_adj[5]);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOLPGM("\t");
  SERIAL_PROTOCOL_F(bed_level_oz, 4);
  SERIAL_PROTOCOLPGM("\t\t\tDelta Radius: ");
  SERIAL_PROTOCOL_F(delta_radius, 4);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOLPGM("X-Tower\t\tY-Tower\t\tDiag Rod: ");
  SERIAL_PROTOCOL_F(delta_diagonal_rod, 4);
  SERIAL_ECHOLN("");
}
#endif
#if defined (indi-RichCattell)
void calibration_report()
  {
  
  //Display Report
  SERIAL_ECHOLN("\tZ-Tower\t\t\tEndstop Offsets");

  SERIAL_ECHO("\t");
  SERIAL_PROTOCOL_F(bed_level_z, 4);
  SERIAL_ECHOPAIR("\t\t\tX:",endstop_adj[0]);
  SERIAL_ECHOPAIR(" Y:",endstop_adj[1]);
  SERIAL_ECHOPAIR(" Z:",endstop_adj[2]);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOL_F(bed_level_oy, 4);
  SERIAL_PROTOCOLPGM("\t\t");
  SERIAL_PROTOCOL_F(bed_level_ox, 4);
  SERIAL_ECHOLN("\t\tTower Position Adjust");

  SERIAL_PROTOCOLPGM("\t");
  SERIAL_PROTOCOL_F(bed_level_c, 4);
  SERIAL_ECHOPAIR("\t\t\tA:",tower_adj[0]);
  SERIAL_ECHOPAIR(" B:",tower_adj[1]);
  SERIAL_ECHOPAIR(" C:",tower_adj[2]);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOL_F(bed_level_x, 4);
  SERIAL_PROTOCOLPGM("\t\t");
  SERIAL_PROTOCOL_F(bed_level_y, 4);
  SERIAL_ECHOPAIR("\t\tI:",tower_adj[3]);
  SERIAL_ECHOPAIR(" J:",tower_adj[4]);
  SERIAL_ECHOPAIR(" K:",tower_adj[5]);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOLPGM("\t");
  SERIAL_PROTOCOL_F(bed_level_oz, 4);
  SERIAL_PROTOCOLPGM("\t\t\tDelta Radius: ");
  SERIAL_PROTOCOL_F(delta_radius, 4);
  SERIAL_ECHOLN("");

  SERIAL_PROTOCOLPGM("X-Tower\t\tY-Tower\t\tDiag Rod: ");
  SERIAL_PROTOCOL_F(delta_diagonal_rod, 4);
  SERIAL_ECHOLN("");
}
#endif
++++++
#if defined (upstream) && defined (Z_PROBE_SLED)
static void dock_sled(bool dock, int offset=0) {
 int z_loc;
 
 if (!((axis_known_position[X_AXIS]) && (axis_known_position[Y_AXIS]))) {
   LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
   SERIAL_ECHO_START;
   SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
   return;
 }

 if (dock) {
   do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
                       current_position[Y_AXIS],
                       current_position[Z_AXIS]);
   // turn off magnet
   digitalWrite(SERVO0_PIN, LOW);
 } else {
   if (current_position[Z_AXIS] < (Z_RAISE_BEFORE_PROBING + 5))
     z_loc = Z_RAISE_BEFORE_PROBING;
   else
     z_loc = current_position[Z_AXIS];
   do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset,
                       Y_PROBE_OFFSET_FROM_EXTRUDER, z_loc);
   // turn on magnet
   digitalWrite(SERVO0_PIN, HIGH);
 }
}
#endif
++++++
#if defined (indi-RichCattell)
void save_carriage_positions(int position_num) {
  for(int8_t i=0; i < NUM_AXIS; i++) {
    saved_positions[position_num][i] = saved_position[i];    
  }
}
#endif
++++++


**--**-**--merge: MarlinSerial.cpp

#if defined (upstream) && ((F_CPU == 16000000UL && SERIAL_PORT == 0 && )(defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H) && )!defined (AT90USB) )
// hard-coded exception for compatibility with the bootloader shipped
#endif
++++++
#if defined (indi-RichCattell) && ((F_CPU == 16000000UL && SERIAL_PORT == 0 && )(defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H) && )!defined (AT90USB) )
// hardcoded exception for compatibility with the bootloader shipped
#endif
++++++
#if defined (upstream) && !defined (AT90USB)
// this is so I can support Attiny series and any other chip without a UART
#endif
++++++
#if defined (indi-RichCattell) && !defined (AT90USB)
// this is so I can support Attiny series and any other chip without a uart
#endif
++++++
#if defined (upstream)
// For AT90USB targets use the UART for BT interfacing
#endif
++++++
#if defined (upstream) && (defined(AT90USB) && defined (BTENABLED))
HardwareSerial bt;
#endif
++++++


**--**-**--merge: motion_control.cpp

#if defined (upstream)
//20141002:full circle for G03 did not work, e.g. G03 X80 Y80 I20 J0 F2000 is giving an Angle of zero so head is not moving
#endif
++++++


**--**-**--merge: planner.cpp



**--**-**--merge: qr_solve.cpp



**--**-**--merge: Sd2Card.cpp

#if defined (upstream) && (defined (SDSUPPORT) && defined (SD_CHECK_AND_RETRY) )
uint8_t retryCnt = 3;
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && defined (SD_CHECK_AND_RETRY) )

    uint16_t calcCrc = CRC_CCITT(dst, count);
    uint16_t recvCrc = spiRec() << 8;
    recvCrc |= spiRec();
    if (calcCrc != recvCrc)
    {
        error(SD_CARD_ERROR_CRC);
        goto fail;
    }
  

#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && defined (SD_CHECK_AND_RETRY) )
static const uint16_t crctab[] PROGMEM = {
  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};
#endif
++++++


**--**-**--merge: SdBaseFile.cpp



**--**-**--merge: SdFatUtil.cpp

#if defined (upstream) && (defined (SDSUPPORT) && !defined (__arm__) )
char top;
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
extern int  __bss_end;
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && !defined (__arm__) )
return __brkval ? &top - __brkval : &top - &__bss_end;
#endif
++++++
#if defined (indi-RichCattell) && defined (SDSUPPORT)
extern int* __brkval;
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
/** Amount of free RAM
 * \return The number of free bytes.
 */
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && defined (__arm__) )
extern "C" char* sbrk(int incr);
#endif
++++++
#if defined (upstream) && (defined (SDSUPPORT) && !defined (__arm__) )
// __arm__
#endif
++++++
#if defined (upstream) && defined (SDSUPPORT)
// __arm
#endif
++++++


**--**-**--merge: SdFile.cpp



**--**-**--merge: SdVolume.cpp



**--**-**--merge: Servo.cpp

#if defined (upstream) && (defined (NUM_SERVOS) && (defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0) &)
if (pin > 0) this->pin = pin; else pin = this->pin;
#endif
++++++
#if defined (upstream) && (defined (NUM_SERVOS) && (defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY > 0) &)
if (pin > 0) this->pin = pin; else pin = this->pin;
#endif
++++++


**--**-**--merge: stepper.cpp

#if defined (upstream) && defined (MOTOR_CURRENT_PWM_XY_PIN)
int motor_current_setting[3] = DEFAULT_PWM_MOTOR_CURRENT;
#endif
++++++


**--**-**--merge: temperature.cpp

#if defined (upstream)
/*
  temperature.c - temperature control
  Part of Marlin
  
 Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 This firmware is a mashup between Sprinter and grbl.
  (https://github.com/kliment/Sprinter)
  (https://github.com/simen/grbl/tree)
 
 It has preliminary support for Matthew Roberts advance algorithm 
    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html

 */


#include "Marlin.h"
#include "ultralcd.h"
#include "temperature.h"
#include "watchdog.h"

#include "Sd2PinMap.h"


//===========================================================================
//=============================public variables============================
//===========================================================================
int target_temperature[EXTRUDERS] = { 0 };
int target_temperature_bed = 0;
int current_temperature_raw[EXTRUDERS] = { 0 };
float current_temperature[EXTRUDERS] = { 0.0 };
int current_temperature_bed_raw = 0;
float current_temperature_bed = 0.0;
#ifdef TEMP_SENSOR_1_AS_REDUNDANT
  int redundant_temperature_raw = 0;
  float redundant_temperature = 0.0;
#endif
#ifdef PIDTEMP
  float Kp=DEFAULT_Kp;
  float Ki=(DEFAULT_Ki*PID_dT);
  float Kd=(DEFAULT_Kd/PID_dT);
  #ifdef PID_ADD_EXTRUSION_RATE
    float Kc=DEFAULT_Kc;
  #endif
#endif //PIDTEMP

#ifdef PIDTEMPBED
  float bedKp=DEFAULT_bedKp;
  float bedKi=(DEFAULT_bedKi*PID_dT);
  float bedKd=(DEFAULT_bedKd/PID_dT);
#endif //PIDTEMPBED
  
#ifdef FAN_SOFT_PWM
  unsigned char fanSpeedSoftPwm;
#endif

unsigned char soft_pwm_bed;
  
#ifdef BABYSTEPPING
  volatile int babystepsTodo[3]={0,0,0};
#endif

#ifdef FILAMENT_SENSOR
  int current_raw_filwidth = 0;  //Holds measured filament diameter - one extruder only
#endif  
//===========================================================================
//=============================private variables============================
//===========================================================================
static volatile bool temp_meas_ready = false;

#ifdef PIDTEMP
  //static cannot be external:
  static float temp_iState[EXTRUDERS] = { 0 };
  static float temp_dState[EXTRUDERS] = { 0 };
  static float pTerm[EXTRUDERS];
  static float iTerm[EXTRUDERS];
  static float dTerm[EXTRUDERS];
  //int output;
  static float pid_error[EXTRUDERS];
  static float temp_iState_min[EXTRUDERS];
  static float temp_iState_max[EXTRUDERS];
  // static float pid_input[EXTRUDERS];
  // static float pid_output[EXTRUDERS];
  static bool pid_reset[EXTRUDERS];
#endif //PIDTEMP
#ifdef PIDTEMPBED
  //static cannot be external:
  static float temp_iState_bed = { 0 };
  static float temp_dState_bed = { 0 };
  static float pTerm_bed;
  static float iTerm_bed;
  static float dTerm_bed;
  //int output;
  static float pid_error_bed;
  static float temp_iState_min_bed;
  static float temp_iState_max_bed;
#else //PIDTEMPBED
	static unsigned long  previous_millis_bed_heater;
#endif //PIDTEMPBED
  static unsigned char soft_pwm[EXTRUDERS];

#ifdef FAN_SOFT_PWM
  static unsigned char soft_pwm_fan;
#endif
#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
  static unsigned long extruder_autofan_last_check;
#endif  

#if EXTRUDERS > 3
  # error Unsupported number of extruders
#elif EXTRUDERS > 2
  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
#elif EXTRUDERS > 1
  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
#else
  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
#endif

// Init min and max temp with extreme values to prevent false errors during startup
static int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP );
static int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP );
static int minttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 0, 0, 0 );
static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );
//static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP; /* No bed mintemp error implemented?!? */
#ifdef BED_MAXTEMP
static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
#endif

#ifdef TEMP_SENSOR_1_AS_REDUNDANT
  static void *heater_ttbl_map[2] = {(void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE };
  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
#else
  static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
  static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
#endif

static float analog2temp(int raw, uint8_t e);
static float analog2tempBed(int raw);
static void updateTemperaturesFromRawValues();

#ifdef WATCH_TEMP_PERIOD
int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
unsigned long watchmillis[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
#endif //WATCH_TEMP_PERIOD

#ifndef SOFT_PWM_SCALE
#define SOFT_PWM_SCALE 0
#endif

#ifdef FILAMENT_SENSOR
  static int meas_shift_index;  //used to point to a delayed sample in buffer for filament width sensor
#endif
//===========================================================================
//=============================   functions      ============================
//===========================================================================

void PID_autotune(float temp, int extruder, int ncycles)
{
  float input = 0.0;
  int cycles=0;
  bool heating = true;

  unsigned long temp_millis = millis();
  unsigned long t1=temp_millis;
  unsigned long t2=temp_millis;
  long t_high = 0;
  long t_low = 0;

  long bias, d;
  float Ku, Tu;
  float Kp, Ki, Kd;
  float max = 0, min = 10000;

#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
  unsigned long extruder_autofan_last_check = millis();
#endif

  if ((extruder >= EXTRUDERS)
  #if (TEMP_BED_PIN <= -1)
       ||(extruder < 0)
  #endif
       ){
          SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
          return;
        }
	
  SERIAL_ECHOLN("PID Autotune start");
  
  disable_heater(); // switch off all heaters.

  if (extruder<0)
  {
     soft_pwm_bed = (MAX_BED_POWER)/2;
     bias = d = (MAX_BED_POWER)/2;
   }
   else
   {
     soft_pwm[extruder] = (PID_MAX)/2;
     bias = d = (PID_MAX)/2;
  }




 for(;;) {

    if(temp_meas_ready == true) { // temp sample ready
      updateTemperaturesFromRawValues();

      input = (extruder<0)?current_temperature_bed:current_temperature[extruder];

      max=max(max,input);
      min=min(min,input);

      #if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
          (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
          (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
      if(millis() - extruder_autofan_last_check > 2500) {
        checkExtruderAutoFans();
        extruder_autofan_last_check = millis();
      }
      #endif

      if(heating == true && input > temp) {
        if(millis() - t2 > 5000) { 
          heating=false;
          if (extruder<0)
            soft_pwm_bed = (bias - d) >> 1;
          else
            soft_pwm[extruder] = (bias - d) >> 1;
          t1=millis();
          t_high=t1 - t2;
          max=temp;
        }
      }
      if(heating == false && input < temp) {
        if(millis() - t1 > 5000) {
          heating=true;
          t2=millis();
          t_low=t2 - t1;
          if(cycles > 0) {
            bias += (d*(t_high - t_low))/(t_low + t_high);
            bias = constrain(bias, 20 ,(extruder<0?(MAX_BED_POWER):(PID_MAX))-20);
            if(bias > (extruder<0?(MAX_BED_POWER):(PID_MAX))/2) d = (extruder<0?(MAX_BED_POWER):(PID_MAX)) - 1 - bias;
            else d = bias;

            SERIAL_PROTOCOLPGM(" bias: "); SERIAL_PROTOCOL(bias);
            SERIAL_PROTOCOLPGM(" d: "); SERIAL_PROTOCOL(d);
            SERIAL_PROTOCOLPGM(" min: "); SERIAL_PROTOCOL(min);
            SERIAL_PROTOCOLPGM(" max: "); SERIAL_PROTOCOLLN(max);
            if(cycles > 2) {
              Ku = (4.0*d)/(3.14159*(max-min)/2.0);
              Tu = ((float)(t_low + t_high)/1000.0);
              SERIAL_PROTOCOLPGM(" Ku: "); SERIAL_PROTOCOL(Ku);
              SERIAL_PROTOCOLPGM(" Tu: "); SERIAL_PROTOCOLLN(Tu);
              Kp = 0.6*Ku;
              Ki = 2*Kp/Tu;
              Kd = Kp*Tu/8;
              SERIAL_PROTOCOLLNPGM(" Classic PID ");
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              /*
              Kp = 0.33*Ku;
              Ki = Kp/Tu;
              Kd = Kp*Tu/3;
              SERIAL_PROTOCOLLNPGM(" Some overshoot ");
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              Kp = 0.2*Ku;
              Ki = 2*Kp/Tu;
              Kd = Kp*Tu/3;
              SERIAL_PROTOCOLLNPGM(" No overshoot ");
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              */
            }
          }
          if (extruder<0)
            soft_pwm_bed = (bias + d) >> 1;
          else
            soft_pwm[extruder] = (bias + d) >> 1;
          cycles++;
          min=temp;
        }
      } 
    }
    if(input > (temp + 20)) {
      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature too high");
      return;
    }
    if(millis() - temp_millis > 2000) {
      int p;
      if (extruder<0){
        p=soft_pwm_bed;       
        SERIAL_PROTOCOLPGM("ok B:");
      }else{
        p=soft_pwm[extruder];       
        SERIAL_PROTOCOLPGM("ok T:");
      }
			
      SERIAL_PROTOCOL(input);   
      SERIAL_PROTOCOLPGM(" @:");
      SERIAL_PROTOCOLLN(p);       

      temp_millis = millis();
    }
    if(((millis() - t1) + (millis() - t2)) > (10L*60L*1000L*2L)) {
      SERIAL_PROTOCOLLNPGM("PID Autotune failed! timeout");
      return;
    }
    if(cycles > ncycles) {
      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the last Kp, Ki and Kd constants from above into Configuration.h");
      return;
    }
    lcd_update();
  }
}

void updatePID()
{
#ifdef PIDTEMP
  for(int e = 0; e < EXTRUDERS; e++) { 
     temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;  
  }
#endif
#ifdef PIDTEMPBED
  temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;  
#endif
}
  
int getHeaterPower(int heater) {
	if (heater<0)
		return soft_pwm_bed;
  return soft_pwm[heater];
}

#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)

  #if defined(FAN_PIN) && FAN_PIN > -1
    #if EXTRUDER_0_AUTO_FAN_PIN == FAN_PIN 
       #error "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN"
    #endif
    #if EXTRUDER_1_AUTO_FAN_PIN == FAN_PIN 
       #error "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN"
    #endif
    #if EXTRUDER_2_AUTO_FAN_PIN == FAN_PIN 
       #error "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN"
    #endif
  #endif 

void setExtruderAutoFanState(int pin, bool state)
{
  unsigned char newFanSpeed = (state != 0) ? EXTRUDER_AUTO_FAN_SPEED : 0;
  // this idiom allows both digital and PWM fan outputs (see M42 handling).
  pinMode(pin, OUTPUT);
  digitalWrite(pin, newFanSpeed);
  analogWrite(pin, newFanSpeed);
}

void checkExtruderAutoFans()
{
  uint8_t fanState = 0;

  // which fan pins need to be turned on?      
  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1
    if (current_temperature[0] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
      fanState |= 1;
  #endif
  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
    if (current_temperature[1] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
    {
      if (EXTRUDER_1_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) 
        fanState |= 1;
      else
        fanState |= 2;
    }
  #endif
  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
    if (current_temperature[2] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
    {
      if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) 
        fanState |= 1;
      else if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN) 
        fanState |= 2;
      else
        fanState |= 4;
    }
  #endif
  
  // update extruder auto fan states
  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1
    setExtruderAutoFanState(EXTRUDER_0_AUTO_FAN_PIN, (fanState & 1) != 0);
  #endif 
  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) 
      setExtruderAutoFanState(EXTRUDER_1_AUTO_FAN_PIN, (fanState & 2) != 0);
  #endif 
  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN 
        && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)
      setExtruderAutoFanState(EXTRUDER_2_AUTO_FAN_PIN, (fanState & 4) != 0);
  #endif 
}

#endif // any extruder auto fan pins set

void manage_heater()
{
  float pid_input;
  float pid_output;

  if(temp_meas_ready != true)   //better readability
    return; 

  updateTemperaturesFromRawValues();

  for(int e = 0; e < EXTRUDERS; e++) 
  {

#if defined (THERMAL_RUNAWAY_PROTECTION_PERIOD) && THERMAL_RUNAWAY_PROTECTION_PERIOD > 0
    thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_RUNAWAY_PROTECTION_PERIOD, THERMAL_RUNAWAY_PROTECTION_HYSTERESIS);
  #endif

  #ifdef PIDTEMP
    pid_input = current_temperature[e];

    #ifndef PID_OPENLOOP
        pid_error[e] = target_temperature[e] - pid_input;
        if(pid_error[e] > PID_FUNCTIONAL_RANGE) {
          pid_output = BANG_MAX;
          pid_reset[e] = true;
        }
        else if(pid_error[e] < -PID_FUNCTIONAL_RANGE || target_temperature[e] == 0) {
          pid_output = 0;
          pid_reset[e] = true;
        }
        else {
          if(pid_reset[e] == true) {
            temp_iState[e] = 0.0;
            pid_reset[e] = false;
          }
          pTerm[e] = Kp * pid_error[e];
          temp_iState[e] += pid_error[e];
          temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);
          iTerm[e] = Ki * temp_iState[e];

          //K1 defined in Configuration.h in the PID settings
          #define K2 (1.0-K1)
          dTerm[e] = (Kd * (pid_input - temp_dState[e]))*K2 + (K1 * dTerm[e]);
          pid_output = pTerm[e] + iTerm[e] - dTerm[e];
          if (pid_output > PID_MAX) {
            if (pid_error[e] > 0 )  temp_iState[e] -= pid_error[e]; // conditional un-integration
            pid_output=PID_MAX;
          } else if (pid_output < 0){
            if (pid_error[e] < 0 )  temp_iState[e] -= pid_error[e]; // conditional un-integration
            pid_output=0;
          }
        }
        temp_dState[e] = pid_input;
    #else 
          pid_output = constrain(target_temperature[e], 0, PID_MAX);
    #endif //PID_OPENLOOP
    #ifdef PID_DEBUG
    SERIAL_ECHO_START;
    SERIAL_ECHO(" PID_DEBUG ");
    SERIAL_ECHO(e);
    SERIAL_ECHO(": Input ");
    SERIAL_ECHO(pid_input);
    SERIAL_ECHO(" Output ");
    SERIAL_ECHO(pid_output);
    SERIAL_ECHO(" pTerm ");
    SERIAL_ECHO(pTerm[e]);
    SERIAL_ECHO(" iTerm ");
    SERIAL_ECHO(iTerm[e]);
    SERIAL_ECHO(" dTerm ");
    SERIAL_ECHOLN(dTerm[e]);
    #endif //PID_DEBUG
  #else /* PID off */
    pid_output = 0;
    if(current_temperature[e] < target_temperature[e]) {
      pid_output = PID_MAX;
    }
  #endif

    // Check if temperature is within the correct range
    if((current_temperature[e] > minttemp[e]) && (current_temperature[e] < maxttemp[e])) 
    {
      soft_pwm[e] = (int)pid_output >> 1;
    }
    else {
      soft_pwm[e] = 0;
    }

    #ifdef WATCH_TEMP_PERIOD
    if(watchmillis[e] && millis() - watchmillis[e] > WATCH_TEMP_PERIOD)
    {
        if(degHotend(e) < watch_start_temp[e] + WATCH_TEMP_INCREASE)
        {
            setTargetHotend(0, e);
            LCD_MESSAGEPGM("Heating failed");
            SERIAL_ECHO_START;
            SERIAL_ECHOLN("Heating failed");
        }else{
            watchmillis[e] = 0;
        }
    }
    #endif
    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
      if(fabs(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF) {
        disable_heater();
        if(IsStopped() == false) {
          SERIAL_ERROR_START;
          SERIAL_ERRORLNPGM("Extruder switched off. Temperature difference between temp sensors is too high !");
          LCD_ALERTMESSAGEPGM("Err: REDUNDANT TEMP ERROR");
        }
        #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
          Stop();
        #endif
      }
    #endif
  } // End extruder for loop

  #if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
      (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
      (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
  if(millis() - extruder_autofan_last_check > 2500)  // only need to check fan state very infrequently
  {
    checkExtruderAutoFans();
    extruder_autofan_last_check = millis();
  }  
  #endif       
  
  #ifndef PIDTEMPBED
  if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
    return;
  previous_millis_bed_heater = millis();
  #endif

  #if TEMP_SENSOR_BED != 0
  
    #ifdef THERMAL_RUNAWAY_PROTECTION_PERIOD && THERMAL_RUNAWAY_PROTECTION_PERIOD > 0
      thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, 9, THERMAL_RUNAWAY_PROTECTION_BED_PERIOD, THERMAL_RUNAWAY_PROTECTION_BED_HYSTERESIS);
    #endif

  #ifdef PIDTEMPBED
    pid_input = current_temperature_bed;

    #ifndef PID_OPENLOOP
		  pid_error_bed = target_temperature_bed - pid_input;
		  pTerm_bed = bedKp * pid_error_bed;
		  temp_iState_bed += pid_error_bed;
		  temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);
		  iTerm_bed = bedKi * temp_iState_bed;

		  //K1 defined in Configuration.h in the PID settings
		  #define K2 (1.0-K1)
		  dTerm_bed= (bedKd * (pid_input - temp_dState_bed))*K2 + (K1 * dTerm_bed);
		  temp_dState_bed = pid_input;

		  pid_output = pTerm_bed + iTerm_bed - dTerm_bed;
          	  if (pid_output > MAX_BED_POWER) {
            	    if (pid_error_bed > 0 )  temp_iState_bed -= pid_error_bed; // conditional un-integration
                    pid_output=MAX_BED_POWER;
          	  } else if (pid_output < 0){
            	    if (pid_error_bed < 0 )  temp_iState_bed -= pid_error_bed; // conditional un-integration
                    pid_output=0;
                  }

    #else 
      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    #endif //PID_OPENLOOP

	  if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP)) 
	  {
	    soft_pwm_bed = (int)pid_output >> 1;
	  }
	  else {
	    soft_pwm_bed = 0;
	  }

    #elif !defined(BED_LIMIT_SWITCHING)
      // Check if temperature is within the correct range
      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
      {
        if(current_temperature_bed >= target_temperature_bed)
        {
          soft_pwm_bed = 0;
        }
        else 
        {
          soft_pwm_bed = MAX_BED_POWER>>1;
        }
      }
      else
      {
        soft_pwm_bed = 0;
        WRITE(HEATER_BED_PIN,LOW);
      }
    #else //#ifdef BED_LIMIT_SWITCHING
      // Check if temperature is within the correct band
      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
      {
        if(current_temperature_bed > target_temperature_bed + BED_HYSTERESIS)
        {
          soft_pwm_bed = 0;
        }
        else if(current_temperature_bed <= target_temperature_bed - BED_HYSTERESIS)
        {
          soft_pwm_bed = MAX_BED_POWER>>1;
        }
      }
      else
      {
        soft_pwm_bed = 0;
        WRITE(HEATER_BED_PIN,LOW);
      }
    #endif
  #endif
  
//code for controlling the extruder rate based on the width sensor 
#ifdef FILAMENT_SENSOR
  if(filament_sensor) 
	{
	meas_shift_index=delay_index1-meas_delay_cm;
		  if(meas_shift_index<0)
			  meas_shift_index = meas_shift_index + (MAX_MEASUREMENT_DELAY+1);  //loop around buffer if needed
		  
		  //get the delayed info and add 100 to reconstitute to a percent of the nominal filament diameter
		  //then square it to get an area
		  
		  if(meas_shift_index<0)
			  meas_shift_index=0;
		  else if (meas_shift_index>MAX_MEASUREMENT_DELAY)
			  meas_shift_index=MAX_MEASUREMENT_DELAY;
		  
		     volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = pow((float)(100+measurement_delay[meas_shift_index])/100.0,2);
		     if (volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] <0.01)
		    	 volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]=0.01;
	}
#endif
}

#define PGM_RD_W(x)   (short)pgm_read_word(&x)
// Derived from RepRap FiveD extruder::getTemperature()
// For hot end temperature measurement.
static float analog2temp(int raw, uint8_t e) {
#ifdef TEMP_SENSOR_1_AS_REDUNDANT
  if(e > EXTRUDERS)
#else
  if(e >= EXTRUDERS)
#endif
  {
      SERIAL_ERROR_START;
      SERIAL_ERROR((int)e);
      SERIAL_ERRORLNPGM(" - Invalid extruder number !");
      kill();
      return 0.0;
  } 
  #ifdef HEATER_0_USES_MAX6675
    if (e == 0)
    {
      return 0.25 * raw;
    }
  #endif

  if(heater_ttbl_map[e] != NULL)
  {
    float celsius = 0;
    uint8_t i;
    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);

    for (i=1; i<heater_ttbllen_map[e]; i++)
    {
      if (PGM_RD_W((*tt)[i][0]) > raw)
      {
        celsius = PGM_RD_W((*tt)[i-1][1]) + 
          (raw - PGM_RD_W((*tt)[i-1][0])) * 
          (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1])) /
          (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0]));
        break;
      }
    }

    // Overflow: Set to last value in the table
    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i-1][1]);

    return celsius;
  }
  return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;
}

// Derived from RepRap FiveD extruder::getTemperature()
// For bed temperature measurement.
static float analog2tempBed(int raw) {
  #ifdef BED_USES_THERMISTOR
    float celsius = 0;
    byte i;

    for (i=1; i<BEDTEMPTABLE_LEN; i++)
    {
      if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw)
      {
        celsius  = PGM_RD_W(BEDTEMPTABLE[i-1][1]) + 
          (raw - PGM_RD_W(BEDTEMPTABLE[i-1][0])) * 
          (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i-1][1])) /
          (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i-1][0]));
        break;
      }
    }

    // Overflow: Set to last value in the table
    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i-1][1]);

    return celsius;
  #elif defined BED_USES_AD595
    return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;
  #else
    return 0;
  #endif
}

/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,
    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */
static void updateTemperaturesFromRawValues()
{
    for(uint8_t e=0;e<EXTRUDERS;e++)
    {
        current_temperature[e] = analog2temp(current_temperature_raw[e], e);
    }
    current_temperature_bed = analog2tempBed(current_temperature_bed_raw);
    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
      redundant_temperature = analog2temp(redundant_temperature_raw, 1);
    #endif
    #if defined (FILAMENT_SENSOR) && (FILWIDTH_PIN > -1)    //check if a sensor is supported 
      filament_width_meas = analog2widthFil();
    #endif  
    //Reset the watchdog after we know we have a temperature measurement.
    watchdog_reset();

    CRITICAL_SECTION_START;
    temp_meas_ready = false;
    CRITICAL_SECTION_END;
}


// For converting raw Filament Width to milimeters 
#ifdef FILAMENT_SENSOR
float analog2widthFil() { 
return current_raw_filwidth/16383.0*5.0; 
//return current_raw_filwidth; 
} 
 
// For converting raw Filament Width to a ratio 
int widthFil_to_size_ratio() { 
 
float temp; 
      
temp=filament_width_meas;
if(filament_width_meas<MEASURED_LOWER_LIMIT)
	temp=filament_width_nominal;  //assume sensor cut out
else if (filament_width_meas>MEASURED_UPPER_LIMIT)
	temp= MEASURED_UPPER_LIMIT;


return(filament_width_nominal/temp*100); 


} 
#endif





void tp_init()
{
#if MB(RUMBA) && ((TEMP_SENSOR_0==-1)||(TEMP_SENSOR_1==-1)||(TEMP_SENSOR_2==-1)||(TEMP_SENSOR_BED==-1))
  //disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
  MCUCR=(1<<JTD); 
  MCUCR=(1<<JTD);
#endif
  
  // Finish init of mult extruder arrays 
  for(int e = 0; e < EXTRUDERS; e++) {
    // populate with the first value 
    maxttemp[e] = maxttemp[0];
#ifdef PIDTEMP
    temp_iState_min[e] = 0.0;
    temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;
#endif //PIDTEMP
#ifdef PIDTEMPBED
    temp_iState_min_bed = 0.0;
    temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;
#endif //PIDTEMPBED
  }

  #if defined(HEATER_0_PIN) && (HEATER_0_PIN > -1) 
    SET_OUTPUT(HEATER_0_PIN);
  #endif  
  #if defined(HEATER_1_PIN) && (HEATER_1_PIN > -1) 
    SET_OUTPUT(HEATER_1_PIN);
  #endif  
  #if defined(HEATER_2_PIN) && (HEATER_2_PIN > -1) 
    SET_OUTPUT(HEATER_2_PIN);
  #endif  
  #if defined(HEATER_BED_PIN) && (HEATER_BED_PIN > -1) 
    SET_OUTPUT(HEATER_BED_PIN);
  #endif  
  #if defined(FAN_PIN) && (FAN_PIN > -1) 
    SET_OUTPUT(FAN_PIN);
    #ifdef FAST_PWM_FAN
    setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
    #endif
    #ifdef FAN_SOFT_PWM
    soft_pwm_fan = fanSpeedSoftPwm / 2;
    #endif
  #endif  

  #ifdef HEATER_0_USES_MAX6675
    #ifndef SDSUPPORT
      SET_OUTPUT(SCK_PIN);
      WRITE(SCK_PIN,0);
    
      SET_OUTPUT(MOSI_PIN);
      WRITE(MOSI_PIN,1);
    
      SET_INPUT(MISO_PIN);
      WRITE(MISO_PIN,1);
    #endif
    /* Using pinMode and digitalWrite, as that was the only way I could get it to compile */
    
    //Have to toggle SD card CS pin to low first, to enable firmware to talk with SD card
	pinMode(SS_PIN, OUTPUT);
	digitalWrite(SS_PIN,0);  
	pinMode(MAX6675_SS, OUTPUT);
	digitalWrite(MAX6675_SS,1);
  #endif

  // Set analog inputs
  ADCSRA = 1<<ADEN | 1<<ADSC | 1<<ADIF | 0x07;
  DIDR0 = 0;
  #ifdef DIDR2
    DIDR2 = 0;
  #endif
  #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
    #if TEMP_0_PIN < 8
       DIDR0 |= 1 << TEMP_0_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_0_PIN - 8); 
    #endif
  #endif
  #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
    #if TEMP_1_PIN < 8
       DIDR0 |= 1<<TEMP_1_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_1_PIN - 8); 
    #endif
  #endif
  #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
    #if TEMP_2_PIN < 8
       DIDR0 |= 1 << TEMP_2_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_2_PIN - 8); 
    #endif
  #endif
  #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
    #if TEMP_BED_PIN < 8
       DIDR0 |= 1<<TEMP_BED_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_BED_PIN - 8); 
    #endif
  #endif
  
  //Added for Filament Sensor 
  #ifdef FILAMENT_SENSOR
   #if defined(FILWIDTH_PIN) && (FILWIDTH_PIN > -1) 
	#if FILWIDTH_PIN < 8 
       	   DIDR0 |= 1<<FILWIDTH_PIN;  
	#else 
       	   DIDR2 |= 1<<(FILWIDTH_PIN - 8);  
	#endif 
   #endif
  #endif
  
  // Use timer0 for temperature measurement
  // Interleave temperature interrupt with millies interrupt
  OCR0B = 128;
  TIMSK0 |= (1<<OCIE0B);  
  
  // Wait for temperature measurement to settle
  delay(250);

#ifdef HEATER_0_MINTEMP
  minttemp[0] = HEATER_0_MINTEMP;
  while(analog2temp(minttemp_raw[0], 0) < HEATER_0_MINTEMP) {
#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
    minttemp_raw[0] += OVERSAMPLENR;
#else
    minttemp_raw[0] -= OVERSAMPLENR;
#endif
  }
#endif //MINTEMP
#ifdef HEATER_0_MAXTEMP
  maxttemp[0] = HEATER_0_MAXTEMP;
  while(analog2temp(maxttemp_raw[0], 0) > HEATER_0_MAXTEMP) {
#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
    maxttemp_raw[0] -= OVERSAMPLENR;
#else
    maxttemp_raw[0] += OVERSAMPLENR;
#endif
  }
#endif //MAXTEMP

#if (EXTRUDERS > 1) && defined(HEATER_1_MINTEMP)
  minttemp[1] = HEATER_1_MINTEMP;
  while(analog2temp(minttemp_raw[1], 1) < HEATER_1_MINTEMP) {
#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
    minttemp_raw[1] += OVERSAMPLENR;
#else
    minttemp_raw[1] -= OVERSAMPLENR;
#endif
  }
#endif // MINTEMP 1
#if (EXTRUDERS > 1) && defined(HEATER_1_MAXTEMP)
  maxttemp[1] = HEATER_1_MAXTEMP;
  while(analog2temp(maxttemp_raw[1], 1) > HEATER_1_MAXTEMP) {
#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
    maxttemp_raw[1] -= OVERSAMPLENR;
#else
    maxttemp_raw[1] += OVERSAMPLENR;
#endif
  }
#endif //MAXTEMP 1

#if (EXTRUDERS > 2) && defined(HEATER_2_MINTEMP)
  minttemp[2] = HEATER_2_MINTEMP;
  while(analog2temp(minttemp_raw[2], 2) < HEATER_2_MINTEMP) {
#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
    minttemp_raw[2] += OVERSAMPLENR;
#else
    minttemp_raw[2] -= OVERSAMPLENR;
#endif
  }
#endif //MINTEMP 2
#if (EXTRUDERS > 2) && defined(HEATER_2_MAXTEMP)
  maxttemp[2] = HEATER_2_MAXTEMP;
  while(analog2temp(maxttemp_raw[2], 2) > HEATER_2_MAXTEMP) {
#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
    maxttemp_raw[2] -= OVERSAMPLENR;
#else
    maxttemp_raw[2] += OVERSAMPLENR;
#endif
  }
#endif //MAXTEMP 2

#ifdef BED_MINTEMP
  /* No bed MINTEMP error implemented?!? */ /*
  while(analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
    bed_minttemp_raw += OVERSAMPLENR;
#else
    bed_minttemp_raw -= OVERSAMPLENR;
#endif
  }
  */
#endif //BED_MINTEMP
#ifdef BED_MAXTEMP
  while(analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
    bed_maxttemp_raw -= OVERSAMPLENR;
#else
    bed_maxttemp_raw += OVERSAMPLENR;
#endif
  }
#endif //BED_MAXTEMP
}

void setWatch() 
{  
#ifdef WATCH_TEMP_PERIOD
  for (int e = 0; e < EXTRUDERS; e++)
  {
    if(degHotend(e) < degTargetHotend(e) - (WATCH_TEMP_INCREASE * 2))
    {
      watch_start_temp[e] = degHotend(e);
      watchmillis[e] = millis();
    } 
  }
#endif 
}

#if defined (THERMAL_RUNAWAY_PROTECTION_PERIOD) && THERMAL_RUNAWAY_PROTECTION_PERIOD > 0
void thermal_runaway_protection(int *state, unsigned long *timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc)
{
/*
      SERIAL_ECHO_START;
      SERIAL_ECHO("Thermal Thermal Runaway Running. Heater ID:");
      SERIAL_ECHO(heater_id);
      SERIAL_ECHO(" ;  State:");
      SERIAL_ECHO(*state);
      SERIAL_ECHO(" ;  Timer:");
      SERIAL_ECHO(*timer);
      SERIAL_ECHO(" ;  Temperature:");
      SERIAL_ECHO(temperature);
      SERIAL_ECHO(" ;  Target Temp:");
      SERIAL_ECHO(target_temperature);
      SERIAL_ECHOLN("");    
*/
  if ((target_temperature == 0) || thermal_runaway)
  {
    *state = 0;
    *timer = 0;
    return;
  }
  switch (*state)
  {
    case 0: // "Heater Inactive" state
      if (target_temperature > 0) *state = 1;
      break;
    case 1: // "First Heating" state
      if (temperature >= target_temperature) *state = 2;
      break;
    case 2: // "Temperature Stable" state
      if (temperature >= (target_temperature - hysteresis_degc))
      {
        *timer = millis();
      } 
      else if ( (millis() - *timer) > ((unsigned long) period_seconds) * 1000)
      {
        SERIAL_ERROR_START;
        SERIAL_ERRORLNPGM("Thermal Runaway, system stopped! Heater_ID: ");
        SERIAL_ERRORLN((int)heater_id);
        LCD_ALERTMESSAGEPGM("THERMAL RUNAWAY");
        thermal_runaway = true;
        while(1)
        {
          disable_heater();
          disable_x();
          disable_y();
          disable_z();
          disable_e0();
          disable_e1();
          disable_e2();
          manage_heater();
          lcd_update();
        }
      }
      break;
  }
}
#endif

void disable_heater()
{
  for(int i=0;i<EXTRUDERS;i++)
    setTargetHotend(0,i);
  setTargetBed(0);
  #if defined(TEMP_0_PIN) && TEMP_0_PIN > -1
  target_temperature[0]=0;
  soft_pwm[0]=0;
   #if defined(HEATER_0_PIN) && HEATER_0_PIN > -1  
     WRITE(HEATER_0_PIN,LOW);
   #endif
  #endif
     
  #if defined(TEMP_1_PIN) && TEMP_1_PIN > -1 && EXTRUDERS > 1
    target_temperature[1]=0;
    soft_pwm[1]=0;
    #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1 
      WRITE(HEATER_1_PIN,LOW);
    #endif
  #endif
      
  #if defined(TEMP_2_PIN) && TEMP_2_PIN > -1 && EXTRUDERS > 2
    target_temperature[2]=0;
    soft_pwm[2]=0;
    #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1  
      WRITE(HEATER_2_PIN,LOW);
    #endif
  #endif 

  #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
    target_temperature_bed=0;
    soft_pwm_bed=0;
    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1  
      WRITE(HEATER_BED_PIN,LOW);
    #endif
  #endif 
}

void max_temp_error(uint8_t e) {
  disable_heater();
  if(IsStopped() == false) {
    SERIAL_ERROR_START;
    SERIAL_ERRORLN((int)e);
    SERIAL_ERRORLNPGM(": Extruder switched off. MAXTEMP triggered !");
    LCD_ALERTMESSAGEPGM("Err: MAXTEMP");
  }
  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
  Stop();
  #endif
}

void min_temp_error(uint8_t e) {
  disable_heater();
  if(IsStopped() == false) {
    SERIAL_ERROR_START;
    SERIAL_ERRORLN((int)e);
    SERIAL_ERRORLNPGM(": Extruder switched off. MINTEMP triggered !");
    LCD_ALERTMESSAGEPGM("Err: MINTEMP");
  }
  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
  Stop();
  #endif
}

void bed_max_temp_error(void) {
#if HEATER_BED_PIN > -1
  WRITE(HEATER_BED_PIN, 0);
#endif
  if(IsStopped() == false) {
    SERIAL_ERROR_START;
    SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
    LCD_ALERTMESSAGEPGM("Err: MAXTEMP BED");
  }
  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
  Stop();
  #endif
}

#ifdef HEATER_0_USES_MAX6675
#define MAX6675_HEAT_INTERVAL 250
long max6675_previous_millis = MAX6675_HEAT_INTERVAL;
int max6675_temp = 2000;

int read_max6675()
{
  if (millis() - max6675_previous_millis < MAX6675_HEAT_INTERVAL) 
    return max6675_temp;
  
  max6675_previous_millis = millis();
  max6675_temp = 0;
    
  #ifdef	PRR
    PRR &= ~(1<<PRSPI);
  #elif defined PRR0
    PRR0 &= ~(1<<PRSPI);
  #endif
  
  SPCR = (1<<MSTR) | (1<<SPE) | (1<<SPR0);
  
  // enable TT_MAX6675
  WRITE(MAX6675_SS, 0);
  
  // ensure 100ns delay - a bit extra is fine
  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
  
  // read MSB
  SPDR = 0;
  for (;(SPSR & (1<<SPIF)) == 0;);
  max6675_temp = SPDR;
  max6675_temp <<= 8;
  
  // read LSB
  SPDR = 0;
  for (;(SPSR & (1<<SPIF)) == 0;);
  max6675_temp |= SPDR;
  
  // disable TT_MAX6675
  WRITE(MAX6675_SS, 1);

  if (max6675_temp & 4) 
  {
    // thermocouple open
    max6675_temp = 2000;
  }
  else 
  {
    max6675_temp = max6675_temp >> 3;
  }

  return max6675_temp;
}
#endif


// Timer 0 is shared with millies
ISR(TIMER0_COMPB_vect)
{
  //these variables are only accesible from the ISR, but static, so they don't lose their value
  static unsigned char temp_count = 0;
  static unsigned long raw_temp_0_value = 0;
  static unsigned long raw_temp_1_value = 0;
  static unsigned long raw_temp_2_value = 0;
  static unsigned long raw_temp_bed_value = 0;
  static unsigned char temp_state = 10;
  static unsigned char pwm_count = (1 << SOFT_PWM_SCALE);
  static unsigned char soft_pwm_0;
#ifdef SLOW_PWM_HEATERS
  static unsigned char slow_pwm_count = 0;
  static unsigned char state_heater_0 = 0;
  static unsigned char state_timer_heater_0 = 0;
#endif 
#if (EXTRUDERS > 1) || defined(HEATERS_PARALLEL)
  static unsigned char soft_pwm_1;
#ifdef SLOW_PWM_HEATERS
  static unsigned char state_heater_1 = 0;
  static unsigned char state_timer_heater_1 = 0;
#endif 
#endif
#if EXTRUDERS > 2
  static unsigned char soft_pwm_2;
#ifdef SLOW_PWM_HEATERS
  static unsigned char state_heater_2 = 0;
  static unsigned char state_timer_heater_2 = 0;
#endif 
#endif
#if HEATER_BED_PIN > -1
  static unsigned char soft_pwm_b;
#ifdef SLOW_PWM_HEATERS
  static unsigned char state_heater_b = 0;
  static unsigned char state_timer_heater_b = 0;
#endif 
#endif
  
#if defined(FILWIDTH_PIN) &&(FILWIDTH_PIN > -1)
  static unsigned long raw_filwidth_value = 0;  //added for filament width sensor
#endif
  
#ifndef SLOW_PWM_HEATERS
  /*
   * standard PWM modulation
   */
  if(pwm_count == 0){
    soft_pwm_0 = soft_pwm[0];
    if(soft_pwm_0 > 0) { 
      WRITE(HEATER_0_PIN,1);
#ifdef HEATERS_PARALLEL
      WRITE(HEATER_1_PIN,1);
#endif
    } else WRITE(HEATER_0_PIN,0);
    
#if EXTRUDERS > 1
    soft_pwm_1 = soft_pwm[1];
    if(soft_pwm_1 > 0) WRITE(HEATER_1_PIN,1); else WRITE(HEATER_1_PIN,0);
#endif
#if EXTRUDERS > 2
    soft_pwm_2 = soft_pwm[2];
    if(soft_pwm_2 > 0) WRITE(HEATER_2_PIN,1); else WRITE(HEATER_2_PIN,0);
#endif
#if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
    soft_pwm_b = soft_pwm_bed;
    if(soft_pwm_b > 0) WRITE(HEATER_BED_PIN,1); else WRITE(HEATER_BED_PIN,0);
#endif
#ifdef FAN_SOFT_PWM
    soft_pwm_fan = fanSpeedSoftPwm / 2;
    if(soft_pwm_fan > 0) WRITE(FAN_PIN,1); else WRITE(FAN_PIN,0);
#endif
  }
  if(soft_pwm_0 < pwm_count) { 
    WRITE(HEATER_0_PIN,0);
#ifdef HEATERS_PARALLEL
    WRITE(HEATER_1_PIN,0);
#endif
  }
#if EXTRUDERS > 1
  if(soft_pwm_1 < pwm_count) WRITE(HEATER_1_PIN,0);
#endif
#if EXTRUDERS > 2
  if(soft_pwm_2 < pwm_count) WRITE(HEATER_2_PIN,0);
#endif
#if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
  if(soft_pwm_b < pwm_count) WRITE(HEATER_BED_PIN,0);
#endif
#ifdef FAN_SOFT_PWM
  if(soft_pwm_fan < pwm_count) WRITE(FAN_PIN,0);
#endif
  
  pwm_count += (1 << SOFT_PWM_SCALE);
  pwm_count &= 0x7f;
  
#else //ifndef SLOW_PWM_HEATERS
  /*
   * SLOW PWM HEATERS
   *
   * for heaters drived by relay
   */
#ifndef MIN_STATE_TIME
#define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds
#endif
  if (slow_pwm_count == 0) {
    // EXTRUDER 0 
    soft_pwm_0 = soft_pwm[0];
    if (soft_pwm_0 > 0) {
      // turn ON heather only if the minimum time is up 
      if (state_timer_heater_0 == 0) { 
	// if change state set timer 
	if (state_heater_0 == 0) {
	  state_timer_heater_0 = MIN_STATE_TIME;
	}
	state_heater_0 = 1;
	WRITE(HEATER_0_PIN, 1);
#ifdef HEATERS_PARALLEL
	WRITE(HEATER_1_PIN, 1);
#endif
      }
    } else {
      // turn OFF heather only if the minimum time is up 
      if (state_timer_heater_0 == 0) {
	// if change state set timer 
	if (state_heater_0 == 1) {
	  state_timer_heater_0 = MIN_STATE_TIME;
	}
	state_heater_0 = 0;
	WRITE(HEATER_0_PIN, 0);
#ifdef HEATERS_PARALLEL
	WRITE(HEATER_1_PIN, 0);
#endif
      }
    }
    
#if EXTRUDERS > 1
    // EXTRUDER 1
    soft_pwm_1 = soft_pwm[1];
    if (soft_pwm_1 > 0) {
      // turn ON heather only if the minimum time is up 
      if (state_timer_heater_1 == 0) { 
	// if change state set timer 
	if (state_heater_1 == 0) {
	  state_timer_heater_1 = MIN_STATE_TIME;
	}
	state_heater_1 = 1;
	WRITE(HEATER_1_PIN, 1);
      }
    } else {
      // turn OFF heather only if the minimum time is up 
      if (state_timer_heater_1 == 0) {
	// if change state set timer 
	if (state_heater_1 == 1) {
	  state_timer_heater_1 = MIN_STATE_TIME;
	}
	state_heater_1 = 0;
	WRITE(HEATER_1_PIN, 0);
      }
    }
#endif
    
#if EXTRUDERS > 2
    // EXTRUDER 2
    soft_pwm_2 = soft_pwm[2];
    if (soft_pwm_2 > 0) {
      // turn ON heather only if the minimum time is up 
      if (state_timer_heater_2 == 0) { 
	// if change state set timer 
	if (state_heater_2 == 0) {
	  state_timer_heater_2 = MIN_STATE_TIME;
	}
	state_heater_2 = 1;
	WRITE(HEATER_2_PIN, 1);
      }
    } else {
      // turn OFF heather only if the minimum time is up 
      if (state_timer_heater_2 == 0) {
	// if change state set timer 
	if (state_heater_2 == 1) {
	  state_timer_heater_2 = MIN_STATE_TIME;
	}
	state_heater_2 = 0;
	WRITE(HEATER_2_PIN, 0);
      }
    }
#endif
    
#if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
    // BED
    soft_pwm_b = soft_pwm_bed;
    if (soft_pwm_b > 0) {
      // turn ON heather only if the minimum time is up 
      if (state_timer_heater_b == 0) { 
	// if change state set timer 
	if (state_heater_b == 0) {
	  state_timer_heater_b = MIN_STATE_TIME;
	}
	state_heater_b = 1;
	WRITE(HEATER_BED_PIN, 1);
      }
    } else {
      // turn OFF heather only if the minimum time is up 
      if (state_timer_heater_b == 0) {
	// if change state set timer 
	if (state_heater_b == 1) {
	  state_timer_heater_b = MIN_STATE_TIME;
	}
	state_heater_b = 0;
	WRITE(HEATER_BED_PIN, 0);
      }
    }
#endif
  } // if (slow_pwm_count == 0)
  
  // EXTRUDER 0 
  if (soft_pwm_0 < slow_pwm_count) {
    // turn OFF heather only if the minimum time is up 
    if (state_timer_heater_0 == 0) { 
      // if change state set timer 
      if (state_heater_0 == 1) {
	state_timer_heater_0 = MIN_STATE_TIME;
      }
      state_heater_0 = 0;
      WRITE(HEATER_0_PIN, 0);
#ifdef HEATERS_PARALLEL
      WRITE(HEATER_1_PIN, 0);
#endif
    }
  }
    
#if EXTRUDERS > 1
  // EXTRUDER 1 
  if (soft_pwm_1 < slow_pwm_count) {
    // turn OFF heather only if the minimum time is up 
    if (state_timer_heater_1 == 0) { 
      // if change state set timer 
      if (state_heater_1 == 1) {
	state_timer_heater_1 = MIN_STATE_TIME;
      }
      state_heater_1 = 0;
      WRITE(HEATER_1_PIN, 0);
    }
  }
#endif
  
#if EXTRUDERS > 2
  // EXTRUDER 2
  if (soft_pwm_2 < slow_pwm_count) {
    // turn OFF heather only if the minimum time is up 
    if (state_timer_heater_2 == 0) { 
      // if change state set timer 
      if (state_heater_2 == 1) {
	state_timer_heater_2 = MIN_STATE_TIME;
      }
      state_heater_2 = 0;
      WRITE(HEATER_2_PIN, 0);
    }
  }
#endif
  
#if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
  // BED
  if (soft_pwm_b < slow_pwm_count) {
    // turn OFF heather only if the minimum time is up 
    if (state_timer_heater_b == 0) { 
      // if change state set timer 
      if (state_heater_b == 1) {
	state_timer_heater_b = MIN_STATE_TIME;
      }
      state_heater_b = 0;
      WRITE(HEATER_BED_PIN, 0);
    }
  }
#endif
  
#ifdef FAN_SOFT_PWM
  if (pwm_count == 0){
    soft_pwm_fan = fanSpeedSoftPwm / 2;
    if (soft_pwm_fan > 0) WRITE(FAN_PIN,1); else WRITE(FAN_PIN,0);
  }
  if (soft_pwm_fan < pwm_count) WRITE(FAN_PIN,0);
#endif
  
  pwm_count += (1 << SOFT_PWM_SCALE);
  pwm_count &= 0x7f;
  
  // increment slow_pwm_count only every 64 pwm_count circa 65.5ms
  if ((pwm_count % 64) == 0) {
    slow_pwm_count++;
    slow_pwm_count &= 0x7f;
    
    // Extruder 0
    if (state_timer_heater_0 > 0) {
      state_timer_heater_0--;
    } 
  
#if EXTRUDERS > 1
    // Extruder 1
    if (state_timer_heater_1 > 0) 
      state_timer_heater_1--;
#endif
    
#if EXTRUDERS > 2
    // Extruder 2
    if (state_timer_heater_2 > 0) 
      state_timer_heater_2--;
#endif
    
#if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
    // Bed   
    if (state_timer_heater_b > 0) 
      state_timer_heater_b--;
#endif
  } //if ((pwm_count % 64) == 0) {
  
#endif //ifndef SLOW_PWM_HEATERS
  
  switch(temp_state) {
    case 0: // Prepare TEMP_0
      #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
        #if TEMP_0_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_0_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 1;
      break;
    case 1: // Measure TEMP_0
      #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
        raw_temp_0_value += ADC;
      #endif
      #ifdef HEATER_0_USES_MAX6675 // TODO remove the blocking
        raw_temp_0_value = read_max6675();
      #endif
      temp_state = 2;
      break;
    case 2: // Prepare TEMP_BED
      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
        #if TEMP_BED_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_BED_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 3;
      break;
    case 3: // Measure TEMP_BED
      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
        raw_temp_bed_value += ADC;
      #endif
      temp_state = 4;
      break;
    case 4: // Prepare TEMP_1
      #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
        #if TEMP_1_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_1_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 5;
      break;
    case 5: // Measure TEMP_1
      #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
        raw_temp_1_value += ADC;
      #endif
      temp_state = 6;
      break;
    case 6: // Prepare TEMP_2
      #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
        #if TEMP_2_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_2_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 7;
      break;
    case 7: // Measure TEMP_2
      #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
        raw_temp_2_value += ADC;
      #endif
      temp_state = 8;//change so that Filament Width is also measured
      
      break;
    case 8: //Prepare FILWIDTH 
     #if defined(FILWIDTH_PIN) && (FILWIDTH_PIN> -1) 
      #if FILWIDTH_PIN>7 
         ADCSRB = 1<<MUX5;
      #else
         ADCSRB = 0; 
      #endif 
      ADMUX = ((1 << REFS0) | (FILWIDTH_PIN & 0x07)); 
      ADCSRA |= 1<<ADSC; // Start conversion 
     #endif 
     lcd_buttons_update();       
     temp_state = 9; 
     break; 
    case 9:   //Measure FILWIDTH 
     #if defined(FILWIDTH_PIN) &&(FILWIDTH_PIN > -1) 
     //raw_filwidth_value += ADC;  //remove to use an IIR filter approach 
      if(ADC>102)  //check that ADC is reading a voltage > 0.5 volts, otherwise don't take in the data.
        {
    	raw_filwidth_value= raw_filwidth_value-(raw_filwidth_value>>7);  //multipliy raw_filwidth_value by 127/128
        
        raw_filwidth_value= raw_filwidth_value + ((unsigned long)ADC<<7);  //add new ADC reading 
        }
     #endif 
     temp_state = 0;   
      
     temp_count++;
     break;      
      
      
    case 10: //Startup, delay initial temp reading a tiny bit so the hardware can settle.
      temp_state = 0;
      break;
//    default:
//      SERIAL_ERROR_START;
//      SERIAL_ERRORLNPGM("Temp measurement error!");
//      break;
  }
    
  if(temp_count >= OVERSAMPLENR) // 10 * 16 * 1/(16000000/64/256)  = 164ms.
  {
    if (!temp_meas_ready) //Only update the raw values if they have been read. Else we could be updating them during reading.
    {
      current_temperature_raw[0] = raw_temp_0_value;
#if EXTRUDERS > 1
      current_temperature_raw[1] = raw_temp_1_value;
#endif
#ifdef TEMP_SENSOR_1_AS_REDUNDANT
      redundant_temperature_raw = raw_temp_1_value;
#endif
#if EXTRUDERS > 2
      current_temperature_raw[2] = raw_temp_2_value;
#endif
      current_temperature_bed_raw = raw_temp_bed_value;
    }

//Add similar code for Filament Sensor - can be read any time since IIR filtering is used 
#if defined(FILWIDTH_PIN) &&(FILWIDTH_PIN > -1)
  current_raw_filwidth = raw_filwidth_value>>10;  //need to divide to get to 0-16384 range since we used 1/128 IIR filter approach 
#endif
    
    
    temp_meas_ready = true;
    temp_count = 0;
    raw_temp_0_value = 0;
    raw_temp_1_value = 0;
    raw_temp_2_value = 0;
    raw_temp_bed_value = 0;

#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
    if(current_temperature_raw[0] <= maxttemp_raw[0]) {
#else
    if(current_temperature_raw[0] >= maxttemp_raw[0]) {
#endif
        max_temp_error(0);
    }
#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
    if(current_temperature_raw[0] >= minttemp_raw[0]) {
#else
    if(current_temperature_raw[0] <= minttemp_raw[0]) {
#endif
        min_temp_error(0);
    }
#if EXTRUDERS > 1
#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
    if(current_temperature_raw[1] <= maxttemp_raw[1]) {
#else
    if(current_temperature_raw[1] >= maxttemp_raw[1]) {
#endif
        max_temp_error(1);
    }
#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
    if(current_temperature_raw[1] >= minttemp_raw[1]) {
#else
    if(current_temperature_raw[1] <= minttemp_raw[1]) {
#endif
        min_temp_error(1);
    }
#endif
#if EXTRUDERS > 2
#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
    if(current_temperature_raw[2] <= maxttemp_raw[2]) {
#else
    if(current_temperature_raw[2] >= maxttemp_raw[2]) {
#endif
        max_temp_error(2);
    }
#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
    if(current_temperature_raw[2] >= minttemp_raw[2]) {
#else
    if(current_temperature_raw[2] <= minttemp_raw[2]) {
#endif
        min_temp_error(2);
    }
#endif
  
  /* No bed MINTEMP error? */
#if defined(BED_MAXTEMP) && (TEMP_SENSOR_BED != 0)
# if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
    if(current_temperature_bed_raw <= bed_maxttemp_raw) {
#else
    if(current_temperature_bed_raw >= bed_maxttemp_raw) {
#endif
       target_temperature_bed = 0;
       bed_max_temp_error();
    }
#endif
  }
  
#ifdef BABYSTEPPING
  for(uint8_t axis=0;axis<3;axis++)
  {
    int curTodo=babystepsTodo[axis]; //get rid of volatile for performance
   
    if(curTodo>0)
    {
      babystep(axis,/*fwd*/true);
      babystepsTodo[axis]--; //less to do next time
    }
    else
    if(curTodo<0)
    {
      babystep(axis,/*fwd*/false);
      babystepsTodo[axis]++; //less to do next time
    }
  }
#endif //BABYSTEPPING
}

#ifdef PIDTEMP
// Apply the scale factors to the PID values


float scalePID_i(float i)
{
	return i*PID_dT;
}

float unscalePID_i(float i)
{
	return i/PID_dT;
}

float scalePID_d(float d)
{
    return d/PID_dT;
}

float unscalePID_d(float d)
{
	return d*PID_dT;
}

#endif //PIDTEMP









































#endif
++++++
#if defined (indi-RichCattell)
/*
  temperature.c - temperature control
  Part of Marlin
  
 Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*
 This firmware is a mashup between Sprinter and grbl.
  (https://github.com/kliment/Sprinter)
  (https://github.com/simen/grbl/tree)
 
 It has preliminary support for Matthew Roberts advance algorithm 
    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html

 */


#include "Marlin.h"
#include "ultralcd.h"
#include "temperature.h"
#include "watchdog.h"

//===========================================================================
//=============================public variables============================
//===========================================================================
int target_temperature[EXTRUDERS] = { 0 };
int target_temperature_bed = 0;
int current_temperature_raw[EXTRUDERS] = { 0 };
float current_temperature[EXTRUDERS] = { 0.0 };
int current_temperature_bed_raw = 0;
float current_temperature_bed = 0.0;
#ifdef TEMP_SENSOR_1_AS_REDUNDANT
  int redundant_temperature_raw = 0;
  float redundant_temperature = 0.0;
#endif
#ifdef PIDTEMP
  float Kp=DEFAULT_Kp;
  float Ki=(DEFAULT_Ki*PID_dT);
  float Kd=(DEFAULT_Kd/PID_dT);
  #ifdef PID_ADD_EXTRUSION_RATE
    float Kc=DEFAULT_Kc;
  #endif
#endif //PIDTEMP

#ifdef PIDTEMPBED
  float bedKp=DEFAULT_bedKp;
  float bedKi=(DEFAULT_bedKi*PID_dT);
  float bedKd=(DEFAULT_bedKd/PID_dT);
#endif //PIDTEMPBED
  
#ifdef FAN_SOFT_PWM
  unsigned char fanSpeedSoftPwm;
#endif
  
//===========================================================================
//=============================private variables============================
//===========================================================================
static volatile bool temp_meas_ready = false;

#ifdef PIDTEMP
  //static cannot be external:
  static float temp_iState[EXTRUDERS] = { 0 };
  static float temp_dState[EXTRUDERS] = { 0 };
  static float pTerm[EXTRUDERS];
  static float iTerm[EXTRUDERS];
  static float dTerm[EXTRUDERS];
  //int output;
  static float pid_error[EXTRUDERS];
  static float temp_iState_min[EXTRUDERS];
  static float temp_iState_max[EXTRUDERS];
  // static float pid_input[EXTRUDERS];
  // static float pid_output[EXTRUDERS];
  static bool pid_reset[EXTRUDERS];
#endif //PIDTEMP
#ifdef PIDTEMPBED
  //static cannot be external:
  static float temp_iState_bed = { 0 };
  static float temp_dState_bed = { 0 };
  static float pTerm_bed;
  static float iTerm_bed;
  static float dTerm_bed;
  //int output;
  static float pid_error_bed;
  static float temp_iState_min_bed;
  static float temp_iState_max_bed;
#else //PIDTEMPBED
	static unsigned long  previous_millis_bed_heater;
#endif //PIDTEMPBED
  static unsigned char soft_pwm[EXTRUDERS];
  static unsigned char soft_pwm_bed;
#ifdef FAN_SOFT_PWM
  static unsigned char soft_pwm_fan;
#endif
#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
  static unsigned long extruder_autofan_last_check;
#endif  

#if EXTRUDERS > 3
  # error Unsupported number of extruders
#elif EXTRUDERS > 2
  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }
#elif EXTRUDERS > 1
  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }
#else
  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }
#endif

// Init min and max temp with extreme values to prevent false errors during startup
static int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP );
static int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP );
static int minttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 0, 0, 0 );
static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );
//static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP; /* No bed mintemp error implemented?!? */
#ifdef BED_MAXTEMP
static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;
#endif

#ifdef TEMP_SENSOR_1_AS_REDUNDANT
  static void *heater_ttbl_map[2] = {(void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE };
  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };
#else
  static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );
  static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );
#endif

static float analog2temp(int raw, uint8_t e);
static float analog2tempBed(int raw);
static void updateTemperaturesFromRawValues();

#ifdef WATCH_TEMP_PERIOD
int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
unsigned long watchmillis[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);
#endif //WATCH_TEMP_PERIOD

#ifndef SOFT_PWM_SCALE
#define SOFT_PWM_SCALE 0
#endif

//===========================================================================
//=============================   functions      ============================
//===========================================================================

void PID_autotune(float temp, int extruder, int ncycles)
{
  float input = 0.0;
  int cycles=0;
  bool heating = true;

  unsigned long temp_millis = millis();
  unsigned long t1=temp_millis;
  unsigned long t2=temp_millis;
  long t_high = 0;
  long t_low = 0;

  long bias, d;
  float Ku, Tu;
  float Kp, Ki, Kd;
  float max = 0, min = 10000;

  if ((extruder > EXTRUDERS)
  #if (TEMP_BED_PIN <= -1)
       ||(extruder < 0)
  #endif
       ){
          SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");
          return;
        }
	
  SERIAL_ECHOLN("PID Autotune start");
  
  disable_heater(); // switch off all heaters.

  if (extruder<0)
  {
     soft_pwm_bed = (MAX_BED_POWER)/2;
     bias = d = (MAX_BED_POWER)/2;
   }
   else
   {
     soft_pwm[extruder] = (PID_MAX)/2;
     bias = d = (PID_MAX)/2;
  }




 for(;;) {

    if(temp_meas_ready == true) { // temp sample ready
      updateTemperaturesFromRawValues();

      input = (extruder<0)?current_temperature_bed:current_temperature[extruder];

      max=max(max,input);
      min=min(min,input);
      if(heating == true && input > temp) {
        if(millis() - t2 > 5000) { 
          heating=false;
          if (extruder<0)
            soft_pwm_bed = (bias - d) >> 1;
          else
            soft_pwm[extruder] = (bias - d) >> 1;
          t1=millis();
          t_high=t1 - t2;
          max=temp;
        }
      }
      if(heating == false && input < temp) {
        if(millis() - t1 > 5000) {
          heating=true;
          t2=millis();
          t_low=t2 - t1;
          if(cycles > 0) {
            bias += (d*(t_high - t_low))/(t_low + t_high);
            bias = constrain(bias, 20 ,(extruder<0?(MAX_BED_POWER):(PID_MAX))-20);
            if(bias > (extruder<0?(MAX_BED_POWER):(PID_MAX))/2) d = (extruder<0?(MAX_BED_POWER):(PID_MAX)) - 1 - bias;
            else d = bias;

            SERIAL_PROTOCOLPGM(" bias: "); SERIAL_PROTOCOL(bias);
            SERIAL_PROTOCOLPGM(" d: "); SERIAL_PROTOCOL(d);
            SERIAL_PROTOCOLPGM(" min: "); SERIAL_PROTOCOL(min);
            SERIAL_PROTOCOLPGM(" max: "); SERIAL_PROTOCOLLN(max);
            if(cycles > 2) {
              Ku = (4.0*d)/(3.14159*(max-min)/2.0);
              Tu = ((float)(t_low + t_high)/1000.0);
              SERIAL_PROTOCOLPGM(" Ku: "); SERIAL_PROTOCOL(Ku);
              SERIAL_PROTOCOLPGM(" Tu: "); SERIAL_PROTOCOLLN(Tu);
              Kp = 0.6*Ku;
              Ki = 2*Kp/Tu;
              Kd = Kp*Tu/8;
              SERIAL_PROTOCOLLNPGM(" Clasic PID ");
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              /*
              Kp = 0.33*Ku;
              Ki = Kp/Tu;
              Kd = Kp*Tu/3;
              SERIAL_PROTOCOLLNPGM(" Some overshoot ")
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              Kp = 0.2*Ku;
              Ki = 2*Kp/Tu;
              Kd = Kp*Tu/3;
              SERIAL_PROTOCOLLNPGM(" No overshoot ")
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              */
            }
          }
          if (extruder<0)
            soft_pwm_bed = (bias + d) >> 1;
          else
            soft_pwm[extruder] = (bias + d) >> 1;
          cycles++;
          min=temp;
        }
      } 
    }
    if(input > (temp + 20)) {
      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature too high");
      return;
    }
    if(millis() - temp_millis > 2000) {
      int p;
      if (extruder<0){
        p=soft_pwm_bed;       
        SERIAL_PROTOCOLPGM("ok B:");
      }else{
        p=soft_pwm[extruder];       
        SERIAL_PROTOCOLPGM("ok T:");
      }
			
      SERIAL_PROTOCOL(input);   
      SERIAL_PROTOCOLPGM(" @:");
      SERIAL_PROTOCOLLN(p);       

      temp_millis = millis();
    }
    if(((millis() - t1) + (millis() - t2)) > (10L*60L*1000L*2L)) {
      SERIAL_PROTOCOLLNPGM("PID Autotune failed! timeout");
      return;
    }
    if(cycles > ncycles) {
      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the Kp, Ki and Kd constants into Configuration.h");
      return;
    }
    lcd_update();
  }
}

void updatePID()
{
#ifdef PIDTEMP
  for(int e = 0; e < EXTRUDERS; e++) { 
     temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;  
  }
#endif
#ifdef PIDTEMPBED
  temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;  
#endif
}
  
int getHeaterPower(int heater) {
	if (heater<0)
		return soft_pwm_bed;
  return soft_pwm[heater];
}

#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)

  #if defined(FAN_PIN) && FAN_PIN > -1
    #if EXTRUDER_0_AUTO_FAN_PIN == FAN_PIN 
       #error "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN"
    #endif
    #if EXTRUDER_1_AUTO_FAN_PIN == FAN_PIN 
       #error "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN"
    #endif
    #if EXTRUDER_2_AUTO_FAN_PIN == FAN_PIN 
       #error "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN"
    #endif
  #endif 

void setExtruderAutoFanState(int pin, bool state)
{
  unsigned char newFanSpeed = (state != 0) ? EXTRUDER_AUTO_FAN_SPEED : 0;
  // this idiom allows both digital and PWM fan outputs (see M42 handling).
  pinMode(pin, OUTPUT);
  digitalWrite(pin, newFanSpeed);
  analogWrite(pin, newFanSpeed);
}

void checkExtruderAutoFans()
{
  uint8_t fanState = 0;

  // which fan pins need to be turned on?      
  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1
    if (current_temperature[0] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
      fanState |= 1;
  #endif
  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
    if (current_temperature[1] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
    {
      if (EXTRUDER_1_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) 
        fanState |= 1;
      else
        fanState |= 2;
    }
  #endif
  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
    if (current_temperature[2] > EXTRUDER_AUTO_FAN_TEMPERATURE) 
    {
      if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) 
        fanState |= 1;
      else if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN) 
        fanState |= 2;
      else
        fanState |= 4;
    }
  #endif
  
  // update extruder auto fan states
  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1
    setExtruderAutoFanState(EXTRUDER_0_AUTO_FAN_PIN, (fanState & 1) != 0);
  #endif 
  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1
    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) 
      setExtruderAutoFanState(EXTRUDER_1_AUTO_FAN_PIN, (fanState & 2) != 0);
  #endif 
  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1
    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN 
        && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)
      setExtruderAutoFanState(EXTRUDER_2_AUTO_FAN_PIN, (fanState & 4) != 0);
  #endif 
}

#endif // any extruder auto fan pins set

void manage_heater()
{
  float pid_input;
  float pid_output;

  if(temp_meas_ready != true)   //better readability
    return; 

  updateTemperaturesFromRawValues();

  for(int e = 0; e < EXTRUDERS; e++) 
  {

  #ifdef PIDTEMP
    pid_input = current_temperature[e];

    #ifndef PID_OPENLOOP
        pid_error[e] = target_temperature[e] - pid_input;
        if(pid_error[e] > PID_FUNCTIONAL_RANGE) {
          pid_output = BANG_MAX;
          pid_reset[e] = true;
        }
        else if(pid_error[e] < -PID_FUNCTIONAL_RANGE || target_temperature[e] == 0) {
          pid_output = 0;
          pid_reset[e] = true;
        }
        else {
          if(pid_reset[e] == true) {
            temp_iState[e] = 0.0;
            pid_reset[e] = false;
          }
          pTerm[e] = Kp * pid_error[e];
          temp_iState[e] += pid_error[e];
          temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);
          iTerm[e] = Ki * temp_iState[e];

          //K1 defined in Configuration.h in the PID settings
          #define K2 (1.0-K1)
          dTerm[e] = (Kd * (pid_input - temp_dState[e]))*K2 + (K1 * dTerm[e]);
          pid_output = constrain(pTerm[e] + iTerm[e] - dTerm[e], 0, PID_MAX);
        }
        temp_dState[e] = pid_input;
    #else 
          pid_output = constrain(target_temperature[e], 0, PID_MAX);
    #endif //PID_OPENLOOP
    #ifdef PID_DEBUG
    SERIAL_ECHO_START(" PIDDEBUG ");
    SERIAL_ECHO(e);
    SERIAL_ECHO(": Input ");
    SERIAL_ECHO(pid_input);
    SERIAL_ECHO(" Output ");
    SERIAL_ECHO(pid_output);
    SERIAL_ECHO(" pTerm ");
    SERIAL_ECHO(pTerm[e]);
    SERIAL_ECHO(" iTerm ");
    SERIAL_ECHO(iTerm[e]);
    SERIAL_ECHO(" dTerm ");
    SERIAL_ECHOLN(dTerm[e]);  
    #endif //PID_DEBUG
  #else /* PID off */
    pid_output = 0;
    if(current_temperature[e] < target_temperature[e]) {
      pid_output = PID_MAX;
    }
  #endif

    // Check if temperature is within the correct range
    if((current_temperature[e] > minttemp[e]) && (current_temperature[e] < maxttemp[e])) 
    {
      soft_pwm[e] = (int)pid_output >> 1;
    }
    else {
      soft_pwm[e] = 0;
    }

    #ifdef WATCH_TEMP_PERIOD
    if(watchmillis[e] && millis() - watchmillis[e] > WATCH_TEMP_PERIOD)
    {
        if(degHotend(e) < watch_start_temp[e] + WATCH_TEMP_INCREASE)
        {
            setTargetHotend(0, e);
            LCD_MESSAGEPGM("Heating failed");
            SERIAL_ECHO_START;
            SERIAL_ECHOLN("Heating failed");
        }else{
            watchmillis[e] = 0;
        }
    }
    #endif
    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
      if(fabs(current_temperature[0] - redundant_temperature) > MAX_REDUNDANT_TEMP_SENSOR_DIFF) {
        disable_heater();
        if(IsStopped() == false) {
          SERIAL_ERROR_START;
          SERIAL_ERRORLNPGM("Extruder switched off. Temperature difference between temp sensors is too high !");
          LCD_ALERTMESSAGEPGM("Err: REDUNDANT TEMP ERROR");
        }
        #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
          Stop();
        #endif
      }
    #endif
  } // End extruder for loop

  #if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN > -1) || \
      (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN > -1) || \
      (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN > -1)
  if(millis() - extruder_autofan_last_check > 2500)  // only need to check fan state very infrequently
  {
    checkExtruderAutoFans();
    extruder_autofan_last_check = millis();
  }  
  #endif       
  
  #ifndef PIDTEMPBED
  if(millis() - previous_millis_bed_heater < BED_CHECK_INTERVAL)
    return;
  previous_millis_bed_heater = millis();
  #endif

  #if TEMP_SENSOR_BED != 0
  
  #ifdef PIDTEMPBED
    pid_input = current_temperature_bed;

    #ifndef PID_OPENLOOP
		  pid_error_bed = target_temperature_bed - pid_input;
		  pTerm_bed = bedKp * pid_error_bed;
		  temp_iState_bed += pid_error_bed;
		  temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);
		  iTerm_bed = bedKi * temp_iState_bed;

		  //K1 defined in Configuration.h in the PID settings
		  #define K2 (1.0-K1)
		  dTerm_bed= (bedKd * (pid_input - temp_dState_bed))*K2 + (K1 * dTerm_bed);
		  temp_dState_bed = pid_input;

		  pid_output = constrain(pTerm_bed + iTerm_bed - dTerm_bed, 0, MAX_BED_POWER);

    #else 
      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);
    #endif //PID_OPENLOOP

	  if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP)) 
	  {
	    soft_pwm_bed = (int)pid_output >> 1;
	  }
	  else {
	    soft_pwm_bed = 0;
	  }

    #elif !defined(BED_LIMIT_SWITCHING)
      // Check if temperature is within the correct range
      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
      {
        if(current_temperature_bed >= target_temperature_bed)
        {
          soft_pwm_bed = 0;
        }
        else 
        {
          soft_pwm_bed = MAX_BED_POWER>>1;
        }
      }
      else
      {
        soft_pwm_bed = 0;
        WRITE(HEATER_BED_PIN,LOW);
      }
    #else //#ifdef BED_LIMIT_SWITCHING
      // Check if temperature is within the correct band
      if((current_temperature_bed > BED_MINTEMP) && (current_temperature_bed < BED_MAXTEMP))
      {
        if(current_temperature_bed > target_temperature_bed + BED_HYSTERESIS)
        {
          soft_pwm_bed = 0;
        }
        else if(current_temperature_bed <= target_temperature_bed - BED_HYSTERESIS)
        {
          soft_pwm_bed = MAX_BED_POWER>>1;
        }
      }
      else
      {
        soft_pwm_bed = 0;
        WRITE(HEATER_BED_PIN,LOW);
      }
    #endif
  #endif
}

#define PGM_RD_W(x)   (short)pgm_read_word(&x)
// Derived from RepRap FiveD extruder::getTemperature()
// For hot end temperature measurement.
static float analog2temp(int raw, uint8_t e) {
#ifdef TEMP_SENSOR_1_AS_REDUNDANT
  if(e > EXTRUDERS)
#else
  if(e >= EXTRUDERS)
#endif
  {
      SERIAL_ERROR_START;
      SERIAL_ERROR((int)e);
      SERIAL_ERRORLNPGM(" - Invalid extruder number !");
      kill();
  } 
  #ifdef HEATER_0_USES_MAX6675
    if (e == 0)
    {
      return 0.25 * raw;
    }
  #endif

  if(heater_ttbl_map[e] != NULL)
  {
    float celsius = 0;
    uint8_t i;
    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);

    for (i=1; i<heater_ttbllen_map[e]; i++)
    {
      if (PGM_RD_W((*tt)[i][0]) > raw)
      {
        celsius = PGM_RD_W((*tt)[i-1][1]) + 
          (raw - PGM_RD_W((*tt)[i-1][0])) * 
          (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1])) /
          (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0]));
        break;
      }
    }

    // Overflow: Set to last value in the table
    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i-1][1]);

    return celsius;
  }
  return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;
}

// Derived from RepRap FiveD extruder::getTemperature()
// For bed temperature measurement.
static float analog2tempBed(int raw) {
  #ifdef BED_USES_THERMISTOR
    float celsius = 0;
    byte i;

    for (i=1; i<BEDTEMPTABLE_LEN; i++)
    {
      if (PGM_RD_W(BEDTEMPTABLE[i][0]) > raw)
      {
        celsius  = PGM_RD_W(BEDTEMPTABLE[i-1][1]) + 
          (raw - PGM_RD_W(BEDTEMPTABLE[i-1][0])) * 
          (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i-1][1])) /
          (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i-1][0]));
        break;
      }
    }

    // Overflow: Set to last value in the table
    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i-1][1]);

    return celsius;
  #elif defined BED_USES_AD595
    return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;
  #else
    return 0;
  #endif
}

/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,
    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */
static void updateTemperaturesFromRawValues()
{
    for(uint8_t e=0;e<EXTRUDERS;e++)
    {
        current_temperature[e] = analog2temp(current_temperature_raw[e], e);
    }
    current_temperature_bed = analog2tempBed(current_temperature_bed_raw);
    #ifdef TEMP_SENSOR_1_AS_REDUNDANT
      redundant_temperature = analog2temp(redundant_temperature_raw, 1);
    #endif
    //Reset the watchdog after we know we have a temperature measurement.
    watchdog_reset();

    CRITICAL_SECTION_START;
    temp_meas_ready = false;
    CRITICAL_SECTION_END;
}

void tp_init()
{
#if (MOTHERBOARD == 80) && ((TEMP_SENSOR_0==-1)||(TEMP_SENSOR_1==-1)||(TEMP_SENSOR_2==-1)||(TEMP_SENSOR_BED==-1))
  //disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector
  MCUCR=(1<<JTD); 
  MCUCR=(1<<JTD);
#endif
  
  // Finish init of mult extruder arrays 
  for(int e = 0; e < EXTRUDERS; e++) {
    // populate with the first value 
    maxttemp[e] = maxttemp[0];
#ifdef PIDTEMP
    temp_iState_min[e] = 0.0;
    temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;
#endif //PIDTEMP
#ifdef PIDTEMPBED
    temp_iState_min_bed = 0.0;
    temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;
#endif //PIDTEMPBED
  }

  #if defined(HEATER_0_PIN) && (HEATER_0_PIN > -1) 
    SET_OUTPUT(HEATER_0_PIN);
  #endif  
  #if defined(HEATER_1_PIN) && (HEATER_1_PIN > -1) 
    SET_OUTPUT(HEATER_1_PIN);
  #endif  
  #if defined(HEATER_2_PIN) && (HEATER_2_PIN > -1) 
    SET_OUTPUT(HEATER_2_PIN);
  #endif  
  #if defined(HEATER_BED_PIN) && (HEATER_BED_PIN > -1) 
    SET_OUTPUT(HEATER_BED_PIN);
  #endif  
  #if defined(FAN_PIN) && (FAN_PIN > -1) 
    SET_OUTPUT(FAN_PIN);
    #ifdef FAST_PWM_FAN
    setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8
    #endif
    #ifdef FAN_SOFT_PWM
    soft_pwm_fan = fanSpeedSoftPwm / 2;
    #endif
  #endif  

  #ifdef HEATER_0_USES_MAX6675
    #ifndef SDSUPPORT
      SET_OUTPUT(MAX_SCK_PIN);
      WRITE(MAX_SCK_PIN,0);
    
      SET_OUTPUT(MAX_MOSI_PIN);
      WRITE(MAX_MOSI_PIN,1);
    
      SET_INPUT(MAX_MISO_PIN);
      WRITE(MAX_MISO_PIN,1);
    #endif
    
    SET_OUTPUT(MAX6675_SS);
    WRITE(MAX6675_SS,1);
  #endif

  // Set analog inputs
  ADCSRA = 1<<ADEN | 1<<ADSC | 1<<ADIF | 0x07;
  DIDR0 = 0;
  #ifdef DIDR2
    DIDR2 = 0;
  #endif
  #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
    #if TEMP_0_PIN < 8
       DIDR0 |= 1 << TEMP_0_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_0_PIN - 8); 
    #endif
  #endif
  #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
    #if TEMP_1_PIN < 8
       DIDR0 |= 1<<TEMP_1_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_1_PIN - 8); 
    #endif
  #endif
  #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
    #if TEMP_2_PIN < 8
       DIDR0 |= 1 << TEMP_2_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_2_PIN - 8); 
    #endif
  #endif
  #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
    #if TEMP_BED_PIN < 8
       DIDR0 |= 1<<TEMP_BED_PIN; 
    #else
       DIDR2 |= 1<<(TEMP_BED_PIN - 8); 
    #endif
  #endif
  
  // Use timer0 for temperature measurement
  // Interleave temperature interrupt with millies interrupt
  OCR0B = 128;
  TIMSK0 |= (1<<OCIE0B);  
  
  // Wait for temperature measurement to settle
  delay(250);

#ifdef HEATER_0_MINTEMP
  minttemp[0] = HEATER_0_MINTEMP;
  while(analog2temp(minttemp_raw[0], 0) < HEATER_0_MINTEMP) {
#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
    minttemp_raw[0] += OVERSAMPLENR;
#else
    minttemp_raw[0] -= OVERSAMPLENR;
#endif
  }
#endif //MINTEMP
#ifdef HEATER_0_MAXTEMP
  maxttemp[0] = HEATER_0_MAXTEMP;
  while(analog2temp(maxttemp_raw[0], 0) > HEATER_0_MAXTEMP) {
#if HEATER_0_RAW_LO_TEMP < HEATER_0_RAW_HI_TEMP
    maxttemp_raw[0] -= OVERSAMPLENR;
#else
    maxttemp_raw[0] += OVERSAMPLENR;
#endif
  }
#endif //MAXTEMP

#if (EXTRUDERS > 1) && defined(HEATER_1_MINTEMP)
  minttemp[1] = HEATER_1_MINTEMP;
  while(analog2temp(minttemp_raw[1], 1) < HEATER_1_MINTEMP) {
#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
    minttemp_raw[1] += OVERSAMPLENR;
#else
    minttemp_raw[1] -= OVERSAMPLENR;
#endif
  }
#endif // MINTEMP 1
#if (EXTRUDERS > 1) && defined(HEATER_1_MAXTEMP)
  maxttemp[1] = HEATER_1_MAXTEMP;
  while(analog2temp(maxttemp_raw[1], 1) > HEATER_1_MAXTEMP) {
#if HEATER_1_RAW_LO_TEMP < HEATER_1_RAW_HI_TEMP
    maxttemp_raw[1] -= OVERSAMPLENR;
#else
    maxttemp_raw[1] += OVERSAMPLENR;
#endif
  }
#endif //MAXTEMP 1

#if (EXTRUDERS > 2) && defined(HEATER_2_MINTEMP)
  minttemp[2] = HEATER_2_MINTEMP;
  while(analog2temp(minttemp_raw[2], 2) < HEATER_2_MINTEMP) {
#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
    minttemp_raw[2] += OVERSAMPLENR;
#else
    minttemp_raw[2] -= OVERSAMPLENR;
#endif
  }
#endif //MINTEMP 2
#if (EXTRUDERS > 2) && defined(HEATER_2_MAXTEMP)
  maxttemp[2] = HEATER_2_MAXTEMP;
  while(analog2temp(maxttemp_raw[2], 2) > HEATER_2_MAXTEMP) {
#if HEATER_2_RAW_LO_TEMP < HEATER_2_RAW_HI_TEMP
    maxttemp_raw[2] -= OVERSAMPLENR;
#else
    maxttemp_raw[2] += OVERSAMPLENR;
#endif
  }
#endif //MAXTEMP 2

#ifdef BED_MINTEMP
  /* No bed MINTEMP error implemented?!? */ /*
  while(analog2tempBed(bed_minttemp_raw) < BED_MINTEMP) {
#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
    bed_minttemp_raw += OVERSAMPLENR;
#else
    bed_minttemp_raw -= OVERSAMPLENR;
#endif
  }
  */
#endif //BED_MINTEMP
#ifdef BED_MAXTEMP
  while(analog2tempBed(bed_maxttemp_raw) > BED_MAXTEMP) {
#if HEATER_BED_RAW_LO_TEMP < HEATER_BED_RAW_HI_TEMP
    bed_maxttemp_raw -= OVERSAMPLENR;
#else
    bed_maxttemp_raw += OVERSAMPLENR;
#endif
  }
#endif //BED_MAXTEMP
}

void setWatch() 
{  
#ifdef WATCH_TEMP_PERIOD
  for (int e = 0; e < EXTRUDERS; e++)
  {
    if(degHotend(e) < degTargetHotend(e) - (WATCH_TEMP_INCREASE * 2))
    {
      watch_start_temp[e] = degHotend(e);
      watchmillis[e] = millis();
    } 
  }
#endif 
}


void disable_heater()
{
  for(int i=0;i<EXTRUDERS;i++)
    setTargetHotend(0,i);
  setTargetBed(0);
  #if defined(TEMP_0_PIN) && TEMP_0_PIN > -1
  target_temperature[0]=0;
  soft_pwm[0]=0;
   #if defined(HEATER_0_PIN) && HEATER_0_PIN > -1  
     WRITE(HEATER_0_PIN,LOW);
   #endif
  #endif
     
  #if defined(TEMP_1_PIN) && TEMP_1_PIN > -1
    target_temperature[1]=0;
    soft_pwm[1]=0;
    #if defined(HEATER_1_PIN) && HEATER_1_PIN > -1 
      WRITE(HEATER_1_PIN,LOW);
    #endif
  #endif
      
  #if defined(TEMP_2_PIN) && TEMP_2_PIN > -1
    target_temperature[2]=0;
    soft_pwm[2]=0;
    #if defined(HEATER_2_PIN) && HEATER_2_PIN > -1  
      WRITE(HEATER_2_PIN,LOW);
    #endif
  #endif 

  #if defined(TEMP_BED_PIN) && TEMP_BED_PIN > -1
    target_temperature_bed=0;
    soft_pwm_bed=0;
    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1  
      WRITE(HEATER_BED_PIN,LOW);
    #endif
  #endif 
}

void max_temp_error(uint8_t e) {
  disable_heater();
  if(IsStopped() == false) {
    SERIAL_ERROR_START;
    SERIAL_ERRORLN((int)e);
    SERIAL_ERRORLNPGM(": Extruder switched off. MAXTEMP triggered !");
    LCD_ALERTMESSAGEPGM("Err: MAXTEMP");
  }
  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
  Stop();
  #endif
}

void min_temp_error(uint8_t e) {
  disable_heater();
  if(IsStopped() == false) {
    SERIAL_ERROR_START;
    SERIAL_ERRORLN((int)e);
    SERIAL_ERRORLNPGM(": Extruder switched off. MINTEMP triggered !");
    LCD_ALERTMESSAGEPGM("Err: MINTEMP");
  }
  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
  Stop();
  #endif
}

void bed_max_temp_error(void) {
#if HEATER_BED_PIN > -1
  WRITE(HEATER_BED_PIN, 0);
#endif
  if(IsStopped() == false) {
    SERIAL_ERROR_START;
    SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");
    LCD_ALERTMESSAGEPGM("Err: MAXTEMP BED");
  }
  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE
  Stop();
  #endif
}

#ifdef HEATER_0_USES_MAX6675
#define MAX6675_HEAT_INTERVAL 250
long max6675_previous_millis = -HEAT_INTERVAL;
int max6675_temp = 2000;

int read_max6675()
{
  if (millis() - max6675_previous_millis < MAX6675_HEAT_INTERVAL) 
    return max6675_temp;
  
  max6675_previous_millis = millis();
  max6675_temp = 0;
    
  #ifdef	PRR
    PRR &= ~(1<<PRSPI);
  #elif defined PRR0
    PRR0 &= ~(1<<PRSPI);
  #endif
  
  SPCR = (1<<MSTR) | (1<<SPE) | (1<<SPR0);
  
  // enable TT_MAX6675
  WRITE(MAX6675_SS, 0);
  
  // ensure 100ns delay - a bit extra is fine
  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz
  
  // read MSB
  SPDR = 0;
  for (;(SPSR & (1<<SPIF)) == 0;);
  max6675_temp = SPDR;
  max6675_temp <<= 8;
  
  // read LSB
  SPDR = 0;
  for (;(SPSR & (1<<SPIF)) == 0;);
  max6675_temp |= SPDR;
  
  // disable TT_MAX6675
  WRITE(MAX6675_SS, 1);

  if (max6675_temp & 4) 
  {
    // thermocouple open
    max6675_temp = 2000;
  }
  else 
  {
    max6675_temp = max6675_temp >> 3;
  }

  return max6675_temp;
}
#endif


// Timer 0 is shared with millies
ISR(TIMER0_COMPB_vect)
{
  //these variables are only accesible from the ISR, but static, so they don't lose their value
  static unsigned char temp_count = 0;
  static unsigned long raw_temp_0_value = 0;
  static unsigned long raw_temp_1_value = 0;
  static unsigned long raw_temp_2_value = 0;
  static unsigned long raw_temp_bed_value = 0;
  static unsigned char temp_state = 0;
  static unsigned char pwm_count = (1 << SOFT_PWM_SCALE);
  static unsigned char soft_pwm_0;
  #if EXTRUDERS > 1
  static unsigned char soft_pwm_1;
  #endif
  #if EXTRUDERS > 2
  static unsigned char soft_pwm_2;
  #endif
  #if HEATER_BED_PIN > -1
  static unsigned char soft_pwm_b;
  #endif
  
  if(pwm_count == 0){
    soft_pwm_0 = soft_pwm[0];
    if(soft_pwm_0 > 0) WRITE(HEATER_0_PIN,1);
    #if EXTRUDERS > 1
    soft_pwm_1 = soft_pwm[1];
    if(soft_pwm_1 > 0) WRITE(HEATER_1_PIN,1);
    #endif
    #if EXTRUDERS > 2
    soft_pwm_2 = soft_pwm[2];
    if(soft_pwm_2 > 0) WRITE(HEATER_2_PIN,1);
    #endif
    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
    soft_pwm_b = soft_pwm_bed;
    if(soft_pwm_b > 0) WRITE(HEATER_BED_PIN,1);
    #endif
    #ifdef FAN_SOFT_PWM
    soft_pwm_fan = fanSpeedSoftPwm / 2;
    if(soft_pwm_fan > 0) WRITE(FAN_PIN,1);
    #endif
  }
  if(soft_pwm_0 <= pwm_count) WRITE(HEATER_0_PIN,0);
  #if EXTRUDERS > 1
  if(soft_pwm_1 <= pwm_count) WRITE(HEATER_1_PIN,0);
  #endif
  #if EXTRUDERS > 2
  if(soft_pwm_2 <= pwm_count) WRITE(HEATER_2_PIN,0);
  #endif
  #if defined(HEATER_BED_PIN) && HEATER_BED_PIN > -1
  if(soft_pwm_b <= pwm_count) WRITE(HEATER_BED_PIN,0);
  #endif
  #ifdef FAN_SOFT_PWM
  if(soft_pwm_fan <= pwm_count) WRITE(FAN_PIN,0);
  #endif
  
  pwm_count += (1 << SOFT_PWM_SCALE);
  pwm_count &= 0x7f;
  
  switch(temp_state) {
    case 0: // Prepare TEMP_0
      #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
        #if TEMP_0_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_0_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 1;
      break;
    case 1: // Measure TEMP_0
      #if defined(TEMP_0_PIN) && (TEMP_0_PIN > -1)
        raw_temp_0_value += ADC;
      #endif
      #ifdef HEATER_0_USES_MAX6675 // TODO remove the blocking
        raw_temp_0_value = read_max6675();
      #endif
      temp_state = 2;
      break;
    case 2: // Prepare TEMP_BED
      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
        #if TEMP_BED_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_BED_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 3;
      break;
    case 3: // Measure TEMP_BED
      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN > -1)
        raw_temp_bed_value += ADC;
      #endif
      temp_state = 4;
      break;
    case 4: // Prepare TEMP_1
      #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
        #if TEMP_1_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_1_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 5;
      break;
    case 5: // Measure TEMP_1
      #if defined(TEMP_1_PIN) && (TEMP_1_PIN > -1)
        raw_temp_1_value += ADC;
      #endif
      temp_state = 6;
      break;
    case 6: // Prepare TEMP_2
      #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
        #if TEMP_2_PIN > 7
          ADCSRB = 1<<MUX5;
        #else
          ADCSRB = 0;
        #endif
        ADMUX = ((1 << REFS0) | (TEMP_2_PIN & 0x07));
        ADCSRA |= 1<<ADSC; // Start conversion
      #endif
      lcd_buttons_update();
      temp_state = 7;
      break;
    case 7: // Measure TEMP_2
      #if defined(TEMP_2_PIN) && (TEMP_2_PIN > -1)
        raw_temp_2_value += ADC;
      #endif
      temp_state = 0;
      temp_count++;
      break;
//    default:
//      SERIAL_ERROR_START;
//      SERIAL_ERRORLNPGM("Temp measurement error!");
//      break;
  }
    
  if(temp_count >= 16) // 8 ms * 16 = 128ms.
  {
    if (!temp_meas_ready) //Only update the raw values if they have been read. Else we could be updating them during reading.
    {
      current_temperature_raw[0] = raw_temp_0_value;
#if EXTRUDERS > 1
      current_temperature_raw[1] = raw_temp_1_value;
#endif
#ifdef TEMP_SENSOR_1_AS_REDUNDANT
      redundant_temperature_raw = raw_temp_1_value;
#endif
#if EXTRUDERS > 2
      current_temperature_raw[2] = raw_temp_2_value;
#endif
      current_temperature_bed_raw = raw_temp_bed_value;
    }
    
    temp_meas_ready = true;
    temp_count = 0;
    raw_temp_0_value = 0;
    raw_temp_1_value = 0;
    raw_temp_2_value = 0;
    raw_temp_bed_value = 0;

#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
    if(current_temperature_raw[0] <= maxttemp_raw[0]) {
#else
    if(current_temperature_raw[0] >= maxttemp_raw[0]) {
#endif
        max_temp_error(0);
    }
#if HEATER_0_RAW_LO_TEMP > HEATER_0_RAW_HI_TEMP
    if(current_temperature_raw[0] >= minttemp_raw[0]) {
#else
    if(current_temperature_raw[0] <= minttemp_raw[0]) {
#endif
        min_temp_error(0);
    }
#if EXTRUDERS > 1
#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
    if(current_temperature_raw[1] <= maxttemp_raw[1]) {
#else
    if(current_temperature_raw[1] >= maxttemp_raw[1]) {
#endif
        max_temp_error(1);
    }
#if HEATER_1_RAW_LO_TEMP > HEATER_1_RAW_HI_TEMP
    if(current_temperature_raw[1] >= minttemp_raw[1]) {
#else
    if(current_temperature_raw[1] <= minttemp_raw[1]) {
#endif
        min_temp_error(1);
    }
#endif
#if EXTRUDERS > 2
#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
    if(current_temperature_raw[2] <= maxttemp_raw[2]) {
#else
    if(current_temperature_raw[2] >= maxttemp_raw[2]) {
#endif
        max_temp_error(2);
    }
#if HEATER_2_RAW_LO_TEMP > HEATER_2_RAW_HI_TEMP
    if(current_temperature_raw[2] >= minttemp_raw[2]) {
#else
    if(current_temperature_raw[2] <= minttemp_raw[2]) {
#endif
        min_temp_error(2);
    }
#endif
  
  /* No bed MINTEMP error? */
#if defined(BED_MAXTEMP) && (TEMP_SENSOR_BED != 0)
# if HEATER_BED_RAW_LO_TEMP > HEATER_BED_RAW_HI_TEMP
    if(current_temperature_bed_raw <= bed_maxttemp_raw) {
#else
    if(current_temperature_bed_raw >= bed_maxttemp_raw) {
#endif
       target_temperature_bed = 0;
       bed_max_temp_error();
    }
#endif
  }  
}

#ifdef PIDTEMP
// Apply the scale factors to the PID values


float scalePID_i(float i)
{
	return i*PID_dT;
}

float unscalePID_i(float i)
{
	return i/PID_dT;
}

float scalePID_d(float d)
{
    return d/PID_dT;
}

float unscalePID_d(float d)
{
	return d*PID_dT;
}

#endif //PIDTEMP






#endif
++++++


**--**-**--merge: ultralcd.cpp

#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_status_screen, 0, false);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
encoderPosition = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
cancel_heatup = true;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW0, &extruder_multiply[0], 10, 999);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW1, &extruder_multiply[1], 10, 999);
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(int3, MSG_FLOW2, &extruder_multiply[2], 10, 999);
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (BABYSTEP_XY) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//BABYSTEP_XY
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (MENU_ADDAUTOSTART) && defined (SDSUPPORT) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (SDSUPPORT) && defined (ULTIPANEL) )
//MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 &)
MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 &)
MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (EMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_BED != 0 && )TEMP_SENSOR_0 != 0 && defined (ULTIPANEL) )
MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("X"), X_AXIS, X_MIN_POS, X_MAX_POS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("Y"), Y_AXIS, Y_MIN_POS, Y_MAX_POS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
_lcd_move(PSTR("Z"), Z_AXIS, Z_MIN_POS, Z_MAX_POS);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_move_menu_axis);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
{
        lcd_quick_feedback();
        currentMenu = lcd_move_menu_axis;
        encoderPosition = 0;
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move Z", lcd_move_z);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Extruder", lcd_move_e);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move X", lcd_move_x);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move Y", lcd_move_y);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move 10mm", lcd_move_menu_10mm);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move 1mm", lcd_move_menu_1mm);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, "Move 0.1mm", lcd_move_menu_01mm);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ENABLE_AUTO_BED_LEVELING) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, 0.5, 50);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(bool, "Endstop abort", &abort_on_endstop_hit);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (SCARA) && defined (ULTIPANEL) )
MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS],0.5,2);
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));
#endif
++++++
#if defined (indi-RichCattell) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_implementation_drawedit(PSTR("Contrast"), itostr2(lcd_contrast));
#endif
++++++
#if defined (upstream) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(lcd_control_menu);
#endif
++++++
#if defined (indi-RichCattell) && (defined (DOGLCD) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
{
        lcd_quick_feedback();
        currentMenu = lcd_control_menu;
        encoderPosition = 0;
    }
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (FWRETRACT) )
MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);
#endif
++++++
#if defined (upstream) && (EXTRUDERS > 1 && defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (FWRETRACT) )
MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
for(uint16_t i=0;i<fileCnt;i++)
    {
        if (_menuItemNr == _lineNr)
        {
            card.getfilename(i);
            if (card.filenameIsDir)
            {
                MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);
            }else{
                MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);
            }
        }else{
            MENU_ITEM_DUMMY();
        }
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(data);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
currentMenu = data;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
lcd_goto_menu(data);
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
currentMenu = data;
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
SET_INPUT(BTN_EN1);
#endif
++++++
#if defined (indi-RichCattell) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
pinMode(BTN_EN1,INPUT);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
SET_INPUT(BTN_EN2);
#endif
++++++
#if defined (indi-RichCattell) && (defined (NEWPANEL) && defined (ULTRA_LCD) )
pinMode(BTN_EN2,INPUT);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && BTN_ENC > 0 )
SET_INPUT(BTN_ENC);
#endif
++++++
#if defined (indi-RichCattell) && (defined (NEWPANEL) && defined (ULTRA_LCD) && BTN_ENC > 0 )
pinMode(BTN_ENC,INPUT);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) )
// Not NEWPANEL
#endif
++++++
#if defined (upstream) && (defined (SR_LCD_2W_NL) && defined (ULTRA_LCD) && !defined (NEWPANEL) )
// Non latching 2 wire shift register
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) && !defined(SHIFT_CLK) && defined (ULTIPANEL) )
#error ULTIPANEL requires an encoder
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined (NEWPANEL) )
// SR_LCD_2W_NL
#endif
++++++
#if defined (upstream) && ((defined (SDSUPPORT) && defined(SDCARDDETECT) && (SDCARDDETECT > 0) && )defined (ULTRA_LCD) )
pinMode(SDCARDDETECT,INPUT);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (LCD_HAS_SLOW_BUTTONS) )
slow_buttons = 0;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (abs(encoderDiff) >= ENCODER_PULSES_PER_STEP)
        {
            lcdDrawUpdate = 1;
            encoderPosition += encoderDiff / ENCODER_PULSES_PER_STEP;
            encoderDiff = 0;
            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
        }
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
if (encoderDiff)
        {
            lcdDrawUpdate = 1;
            encoderPosition += encoderDiff;
            encoderDiff = 0;
            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;
        }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_next_update_millis = millis() + LCD_UPDATE_INTERVAL;
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
lcd_next_update_millis = millis() + 100;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (LCD_HAS_SLOW_BUTTONS) )
slow_buttons = lcd_implementation_read_slow_buttons();
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
lcd_buttons_update();
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (LCD_HAS_SLOW_BUTTONS) )
buttons |= lcd_implementation_read_slow_buttons();
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_buttons_update();
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && (SDCARDDETECT > 0) )
if((IS_SD_INSERTED != lcd_oldcardstatus))
    {
        lcdDrawUpdate = 2;
        lcd_oldcardstatus = IS_SD_INSERTED;
        lcd_implementation_init(); // to maybe revive the lcd if static electricty killed it.
        
        if(lcd_oldcardstatus)
        {
            card.initsd();
            LCD_MESSAGEPGM(MSG_SD_INSERTED);
        }
        else
        {
            card.release();
            LCD_MESSAGEPGM(MSG_SD_REMOVED);
        }
    }
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_finishstatus();
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
lcdDrawUpdate = 2;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
lcd_finishstatus();
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
lcdDrawUpdate = 2;
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc |= B01;
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc|=(1<<0);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc |= B10;
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
enc|=(1<<1);
#endif
++++++
#if defined (upstream) && (defined (NEWPANEL) && defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (LCD_HAS_SLOW_BUTTONS) )
buttons |= slow_buttons;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0] = xx >= 1000 ? (xx / 1000) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 1000)
    conv[0]=(xx/1000)%10+'0';
  else
    conv[0]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[1] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 100)
    conv[1]=(xx/100)%10+'0';
  else
    conv[1]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[2] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 10)
    conv[2]=(xx/10)%10+'0';
  else
    conv[2]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[3] = xx % 10 + '0';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
conv[3]=(xx)%10+'0';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[0] = xx >= 10000 ? (xx / 10000) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 10000)
    conv[0]=(xx/10000)%10+'0';
  else
    conv[0]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[1] = xx >= 1000 ? (xx / 1000) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 1000)
    conv[1]=(xx/1000)%10+'0';
  else
    conv[1]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[2] = xx >= 100 ? (xx / 100) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 100)
    conv[2]=(xx/100)%10+'0';
  else
    conv[2]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[3] = xx >= 10 ? (xx / 10) % 10 + '0' : ' ';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
if (xx >= 10)
    conv[3]=(xx/10)%10+'0';
  else
    conv[3]=' ';
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
conv[4] = xx % 10 + '0';
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
conv[4]=(xx)%10+'0';
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (FILAMENT_LCD_DISPLAY) )
unsigned long message_millis = 0;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// ULTIPANEL
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/** forward declarations **/
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
/** forward declerations **/
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_control_volumetric_menu();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
static void lcd_delta_calibrate_menu();
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//Cause an LCD refresh, and give the user visual or audible feedback that something has happened
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//Cause an LCD refresh, and give the user visual or audiable feedback that something has happend
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void menu_action_setting_edit_float43(const char* pstr, float* ptr, float minValue, float maxValue);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void menu_action_setting_edit_callback_float43(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && !defined(LCD_I2C_VIKI) && !defined (ENCODER_PULSES_PER_STEP) && defined (ULTIPANEL) )
#define ENCODER_PULSES_PER_STEP 1
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined(LCD_I2C_VIKI) && !defined (ENCODER_PULSES_PER_STEP) && defined (ULTIPANEL) )
#define ENCODER_PULSES_PER_STEP 1
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) && defined (LCD_HAS_SLOW_BUTTONS) )
volatile uint8_t slow_buttons;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
bool ignore_click = false;
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// place-holders for Ki and Kd edits
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
// placeholders for Ki and Kd edits
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
static void lcd_goto_menu(menuFunc_t menu, const uint32_t encoder=0, const bool feedback=true) {
  if (currentMenu != menu) {
    currentMenu = menu;
    encoderPosition = encoder;
    if (feedback) lcd_quick_feedback();

    // For LCD_PROGRESS_BAR re-initialize the custom characters
    #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT)
      lcd_set_custom_characters(menu == lcd_status_screen);
    #endif
  }
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependend */
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependent */
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
static void lcd_status_screen()
{
    if (lcd_status_update_delay)
        lcd_status_update_delay--;
    else
        lcdDrawUpdate = 1;
    if (lcdDrawUpdate)
    {
        lcd_implementation_status_screen();
        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
    }
#ifdef ULTIPANEL
    if (LCD_CLICKED)
    {
        currentMenu = lcd_main_menu;
        encoderPosition = 0;
        lcd_quick_feedback();
    }

    // Dead zone at 100% feedrate
    if ((feedmultiply < 100 && (feedmultiply + int(encoderPosition)) > 100) ||
            (feedmultiply > 100 && (feedmultiply + int(encoderPosition)) < 100))
    {
        encoderPosition = 0;
        feedmultiply = 100;
    }

    if (feedmultiply == 100 && int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;
    }
    else if (feedmultiply == 100 && int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;	
    }
    else if (feedmultiply != 100)
    {
        feedmultiply += int(encoderPosition);
        encoderPosition = 0;
    }

    if (feedmultiply < 10)
        feedmultiply = 10;
    if (feedmultiply > 999)
        feedmultiply = 999;
#endif//ULTIPANEL
}
#endif
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
static void lcd_status_screen()
{
    if (lcd_status_update_delay)
        lcd_status_update_delay--;
    else
        lcdDrawUpdate = 1;
    if (lcdDrawUpdate)
    {
        lcd_implementation_status_screen();
        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
    }
#ifdef ULTIPANEL
    if (LCD_CLICKED)
    {
        currentMenu = lcd_main_menu;
        encoderPosition = 0;
        lcd_quick_feedback();
    }

    // Dead zone at 100% feedrate
    if ((feedmultiply < 100 && (feedmultiply + int(encoderPosition)) > 100) ||
            (feedmultiply > 100 && (feedmultiply + int(encoderPosition)) < 100))
    {
        encoderPosition = 0;
        feedmultiply = 100;
    }

    if (feedmultiply == 100 && int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;
    }
    else if (feedmultiply == 100 && int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;	
    }
    else if (feedmultiply != 100)
    {
        feedmultiply += int(encoderPosition);
        encoderPosition = 0;
    }

    if (feedmultiply < 10)
        feedmultiply = 10;
    if (feedmultiply > 999)
        feedmultiply = 999;
#endif//ULTIPANEL
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void lcd_status_screen()
{
  #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT)
    uint16_t mil = millis();
    #ifndef PROGRESS_MSG_ONCE
      if (mil > progressBarTick + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME) {
        progressBarTick = mil;
      }
    #endif
    #if PROGRESS_MSG_EXPIRE > 0
      // keep the message alive if paused, count down otherwise
      if (messageTick > 0) {
        if (card.isFileOpen()) {
          if (IS_SD_PRINTING) {
            if ((mil-messageTick) >= PROGRESS_MSG_EXPIRE) {
              lcd_status_message[0] = '\0';
              messageTick = 0;
            }
          }
          else {
            messageTick += LCD_UPDATE_INTERVAL;
          }
        }
        else {
          messageTick = 0;
        }
      }
    #endif
  #endif //LCD_PROGRESS_BAR

    if (lcd_status_update_delay)
        lcd_status_update_delay--;
    else
        lcdDrawUpdate = 1;
    if (lcdDrawUpdate)
    {
        lcd_implementation_status_screen();
        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */
    }
#ifdef ULTIPANEL

    bool current_click = LCD_CLICKED;

    if (ignore_click) {
        if (wait_for_unclick) {
          if (!current_click) {
              ignore_click = wait_for_unclick = false;
          }
          else {
              current_click = false;
          }
        }
        else if (current_click) {
            lcd_quick_feedback();
            wait_for_unclick = true;
            current_click = false;
        }
    }

    if (current_click)
    {
        lcd_goto_menu(lcd_main_menu);
        lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.
          #if defined(LCD_PROGRESS_BAR) && defined(SDSUPPORT)
            currentMenu == lcd_status_screen
          #endif
        );
        #ifdef FILAMENT_LCD_DISPLAY
          message_millis = millis();  // get status message to show up for a while
        #endif
    }

#ifdef ULTIPANEL_FEEDMULTIPLY
    // Dead zone at 100% feedrate
    if ((feedmultiply < 100 && (feedmultiply + int(encoderPosition)) > 100) ||
            (feedmultiply > 100 && (feedmultiply + int(encoderPosition)) < 100))
    {
        encoderPosition = 0;
        feedmultiply = 100;
    }

    if (feedmultiply == 100 && int(encoderPosition) > ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;
    }
    else if (feedmultiply == 100 && int(encoderPosition) < -ENCODER_FEEDRATE_DEADZONE)
    {
        feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;
        encoderPosition = 0;
    }
    else if (feedmultiply != 100)
    {
        feedmultiply += int(encoderPosition);
        encoderPosition = 0;
    }
#endif //ULTIPANEL_FEEDMULTIPLY

    if (feedmultiply < 10)
        feedmultiply = 10;
    else if (feedmultiply > 999)
        feedmultiply = 999;
#endif //ULTIPANEL
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_set_home_offsets()
{
    for(int8_t i=0; i < NUM_AXIS; i++) {
      if (i != E_AXIS) {
        add_homing[i] -= current_position[i];
        current_position[i] = 0.0;
      }
    }
    plan_set_position(0.0, 0.0, 0.0, current_position[E_AXIS]);

    // Audio feedback
    enquecommand_P(PSTR("M300 S659 P200"));
    enquecommand_P(PSTR("M300 S698 P200"));
    lcd_return_to_status();
}
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_preheat_pla()
{
    setTargetHotend0(plaPreheatHotendTemp);
    setTargetHotend1(plaPreheatHotendTemp);
    setTargetHotend2(plaPreheatHotendTemp);
    setTargetBed(plaPreheatHPBTemp);
    fanSpeed = plaPreheatFanSpeed;
    lcd_return_to_status();
    setWatch(); // heater sanity check timer
}
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void _lcd_babystep(int axis, const char *msg) {
    if (encoderPosition != 0) {
      babystepsTodo[axis] += (int)encoderPosition;
      encoderPosition = 0;
      lcdDrawUpdate = 1;
    }
    if (lcdDrawUpdate) lcd_implementation_drawedit(msg, "");
    if (LCD_CLICKED) lcd_goto_menu(lcd_tune_menu);
  }
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_preheat_abs()
{
    setTargetHotend0(absPreheatHotendTemp);
    setTargetHotend1(absPreheatHotendTemp);
    setTargetHotend2(absPreheatHotendTemp);
    setTargetBed(absPreheatHPBTemp);
    fanSpeed = absPreheatFanSpeed;
    lcd_return_to_status();
    setWatch(); // heater sanity check timer
}
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_cooldown()
{
    setTargetHotend0(0);
    setTargetHotend1(0);
    setTargetHotend2(0);
    setTargetBed(0);
    lcd_return_to_status();
}
#endif
++++++
#if defined (upstream) && (defined (BABYSTEPPING) && defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//BABYSTEPPING
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
void lcd_preheat_pla0()
{
    setTargetHotend0(plaPreheatHotendTemp);
    setTargetBed(plaPreheatHPBTemp);
    fanSpeed = plaPreheatFanSpeed;
    lcd_return_to_status();
    setWatch(); // heater sanity check timer
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && TEMP_SENSOR_1 != 0 && defined (ULTIPANEL) )
//2nd extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//2nd extruder preheat
#endif
++++++
#if defined (upstream) && (TEMP_SENSOR_2 != 0 && defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//3 extruder preheat
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 && )defined (ULTIPANEL) )
//more than one extruder present
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//more than one extruder present
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (DELTA_CALIBRATION_MENU) && defined (ULTIPANEL) )
static void lcd_delta_calibrate_menu()
{
    START_MENU();
    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);
    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_X, PSTR("G0 F8000 X-77.94 Y-45 Z0"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Y, PSTR("G0 F8000 X77.94 Y-45 Z0"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Z, PSTR("G0 F8000 X0 Y90 Z0"));
    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_CENTER, PSTR("G0 F8000 X0 Y0 Z0"));
    END_MENU();
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
// DELTA_CALIBRATION_MENU
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void _lcd_move(const char *name, int axis, int min, int max) {
  if (encoderPosition != 0) {
    refresh_cmd_timeout();
    current_position[axis] += float((int)encoderPosition) * move_menu_scale;
    if (min_software_endstops && current_position[axis] < min) current_position[axis] = min;
    if (max_software_endstops && current_position[axis] > max) current_position[axis] = max;
    encoderPosition = 0;
    #ifdef DELTA
      calculate_delta(current_position);
      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
    #else
      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);
    #endif
    lcdDrawUpdate = 1;
  }
  if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));
  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void lcd_control_volumetric_menu()
{
	START_MENU();
	MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);

	MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);

	if (volumetric_enabled) {
		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_0, &filament_size[0], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#if EXTRUDERS > 1
		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_1, &filament_size[1], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#if EXTRUDERS > 2
		MENU_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_SIZE_EXTRUDER_2, &filament_size[2], DEFAULT_NOMINAL_FILAMENT_DIA - .5, DEFAULT_NOMINAL_FILAMENT_DIA + .5, calculate_volumetric_multipliers);
#endif
#endif
	}

	END_MENU();
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
//FWRETRACT
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define menu_edit_type(_type, _name, _strFunc, scale) \
    void menu_edit_ ## _name () \
    { \
        if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
        if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
        if (lcdDrawUpdate) \
            lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \
        if (LCD_CLICKED) \
        { \
            *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \
            lcd_goto_menu(prevMenu, prevEncoderPosition); \
        } \
    } \
    void menu_edit_callback_ ## _name () { \
        menu_edit_ ## _name (); \
        if (LCD_CLICKED) (*callbackFunc)(); \
    } \
    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale - minEditValue; \
        encoderPosition = (*ptr) * scale - minEditValue; \
    }\
    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_callback_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale - minEditValue; \
        encoderPosition = (*ptr) * scale - minEditValue; \
        callbackFunc = callback;\
    }
#endif
++++++
#if defined (indi-RichCattell) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
#define menu_edit_type(_type, _name, _strFunc, scale) \
    void menu_edit_ ## _name () \
    { \
        if ((int32_t)encoderPosition < minEditValue) \
            encoderPosition = minEditValue; \
        if ((int32_t)encoderPosition > maxEditValue) \
            encoderPosition = maxEditValue; \
        if (lcdDrawUpdate) \
            lcd_implementation_drawedit(editLabel, _strFunc(((_type)encoderPosition) / scale)); \
        if (LCD_CLICKED) \
        { \
            *((_type*)editValue) = ((_type)encoderPosition) / scale; \
            lcd_quick_feedback(); \
            currentMenu = prevMenu; \
            encoderPosition = prevEncoderPosition; \
        } \
    } \
    void menu_edit_callback_ ## _name () \
    { \
        if ((int32_t)encoderPosition < minEditValue) \
            encoderPosition = minEditValue; \
        if ((int32_t)encoderPosition > maxEditValue) \
            encoderPosition = maxEditValue; \
        if (lcdDrawUpdate) \
            lcd_implementation_drawedit(editLabel, _strFunc(((_type)encoderPosition) / scale)); \
        if (LCD_CLICKED) \
        { \
            *((_type*)editValue) = ((_type)encoderPosition) / scale; \
            lcd_quick_feedback(); \
            currentMenu = prevMenu; \
            encoderPosition = prevEncoderPosition; \
            (*callbackFunc)();\
        } \
    } \
    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale; \
        encoderPosition = (*ptr) * scale; \
    }\
    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) \
    { \
        prevMenu = currentMenu; \
        prevEncoderPosition = encoderPosition; \
         \
        lcdDrawUpdate = 2; \
        currentMenu = menu_edit_callback_ ## _name; \
         \
        editLabel = pstr; \
        editValue = ptr; \
        minEditValue = minValue * scale; \
        maxEditValue = maxValue * scale; \
        encoderPosition = (*ptr) * scale; \
        callbackFunc = callback;\
    }
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
menu_edit_type(float, float43, ftostr43, 1000)
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback)
{
	menu_action_setting_edit_bool(pstr, ptr);
	(*callback)();
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
void lcd_ignore_click(bool b)
{
    ignore_click = b;
    wait_for_unclick = false;
}
#endif
++++++
#if defined (upstream) && (defined (ULTRA_LCD) && defined (ULTIPANEL) )
bool lcd_detected(void)
{
#if (defined(LCD_I2C_TYPE_MCP23017) || defined(LCD_I2C_TYPE_MCP23008)) && defined(DETECT_DEVICE)
  return lcd.LcdDetected() == 1;
#else
  return true;
#endif
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 123.4 format, dropping sign
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
//  convert float to string with +123.4 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 123.4 format
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
//  convert float to string with 123.4 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with 1.234 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert int to rj string with 123 or -12 format
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
char *itostr3(const int &xx)
{
  if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
  if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
  conv[2]=(xx)%10+'0';
  conv[3]=0;
  return conv;
}
#endif
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
char *itostr3(const int &xx)
{
  if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
  if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
  conv[2]=(xx)%10+'0';
  conv[3]=0;
  return conv;
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
char *itostr3(const int &x)
{
  int xx = x;
  if (xx < 0) {
     conv[0]='-';
     xx = -xx;
  } else if (xx >= 100)
    conv[0]=(xx/100)%10+'0';
  else
    conv[0]=' ';
  if (xx >= 10)
    conv[1]=(xx/10)%10+'0';
  else
    conv[1]=' ';
  conv[2]=(xx)%10+'0';
  conv[3]=0;
  return conv;
}
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert int to rj string with 1234 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to rj string with 12345 format
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
// convert float to string with +123 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with +1234.5 format
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
//  convert float to string with +1234.5 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// Convert float to string with +123.45 format
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
//  convert float to string with +123.45 format
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// grab the PID i value out of the temp variable; scale it; then update the PID driver
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
// grab the pid i value out of the temp variable; scale it; then update the PID driver
#endif
++++++
#if defined (upstream) && defined (ULTRA_LCD)
// grab the PID d value out of the temp variable; scale it; then update the PID driver
#endif
++++++
#if defined (indi-RichCattell) && defined (ULTRA_LCD)
// grab the pid d value out of the temp variable; scale it; then update the PID driver
#endif
++++++


**--**-**--merge: vector_3.cpp



**--**-**--merge: watchdog.cpp

