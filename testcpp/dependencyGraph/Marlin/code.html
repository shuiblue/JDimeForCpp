<html>
<head>
	<title></title>
<link rel="stylesheet" type="text/css" href="style.css">
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
</head>
<body ginger_software_stylesheet="true" ginger_software_doc="true">
	  <IMG id= "expectIMG"SRC="expect.png" style="float: right;width:300px;height:250px;" />
        <IMG id= "resultIMG"SRC="result.png" style="float: right;width:300px;height:250px;" />
       
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
	 <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
<h1>cardreader.cpp</h1>
<pre  class="prettyprint linenums"><front id="cardreaderCPP-1">#include "Marlin.h"</front>
<front id="cardreaderCPP-2">#include "cardreader.h"</front>
<front id="cardreaderCPP-3">#include "ultralcd.h"</front>
<front id="cardreaderCPP-4">#include "stepper.h"</front>
<front id="cardreaderCPP-5">#include "temperature.h"</front>
<front id="cardreaderCPP-6">#include "language.h"</front>
<front id="cardreaderCPP-7"></front>
<front id="cardreaderCPP-8">#ifdef SDSUPPORT</front>
<front id="cardreaderCPP-9"></front>
<front id="cardreaderCPP-10"></front>
<front id="cardreaderCPP-11"></front>
<front id="cardreaderCPP-12">CardReader::CardReader()</front>
<front id="cardreaderCPP-13">{</front>
<front id="cardreaderCPP-14">   filesize = 0;</front>
<front id="cardreaderCPP-15">   sdpos = 0;</front>
<front id="cardreaderCPP-16">   sdprinting = false;</front>
<front id="cardreaderCPP-17">   cardOK = false;</front>
<front id="cardreaderCPP-18">   saving = false;</front>
<front id="cardreaderCPP-19">   logging = false;</front>
<front id="cardreaderCPP-20">   autostart_atmillis=0;</front>
<front id="cardreaderCPP-21">   workDirDepth = 0;</front>
<front id="cardreaderCPP-22">   memset(workDirParents, 0, sizeof(workDirParents));</front>
<front id="cardreaderCPP-23"></front>
<front id="cardreaderCPP-24">   autostart_stilltocheck=true; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.</front>
<front id="cardreaderCPP-25">   lastnr=0;</front>
<front id="cardreaderCPP-26">  //power to SD reader</front>
<front id="cardreaderCPP-27">  #if SDPOWER &gt; -1</front>
<front id="cardreaderCPP-28">    SET_OUTPUT(SDPOWER); </front>
<front id="cardreaderCPP-29">    WRITE(SDPOWER,HIGH);</front>
<front id="cardreaderCPP-30">  #endif //SDPOWER</front>
<front id="cardreaderCPP-31">  </front>
<front id="cardreaderCPP-32">  autostart_atmillis=millis()+5000;</front>
<front id="cardreaderCPP-33">}</front>
<front id="cardreaderCPP-34"></front>
<front id="cardreaderCPP-35">char *createFilename(char *buffer,const dir_t &p) //buffer&gt;12characters</front>
<front id="cardreaderCPP-36">{</front>
<front id="cardreaderCPP-37">  char *pos=buffer;</front>
<front id="cardreaderCPP-38">  for (uint8_t i = 0; i &lt; 11; i++) </front>
<front id="cardreaderCPP-39">  {</front>
<front id="cardreaderCPP-40">    if (p.name[i] == ' ')continue;</front>
<front id="cardreaderCPP-41">    if (i == 8) </front>
<front id="cardreaderCPP-42">    {</front>
<front id="cardreaderCPP-43">      *pos++='.';</front>
<front id="cardreaderCPP-44">    }</front>
<front id="cardreaderCPP-45">    *pos++=p.name[i];</front>
<front id="cardreaderCPP-46">  }</front>
<front id="cardreaderCPP-47">  *pos++=0;</front>
<front id="cardreaderCPP-48">  return buffer;</front>
<front id="cardreaderCPP-49">}</front>
<front id="cardreaderCPP-50"></front>
<front id="cardreaderCPP-51"></front>
<front id="cardreaderCPP-52">void  CardReader::lsDive(const char *prepend,SdFile parent)</front>
<front id="cardreaderCPP-53">{</front>
<front id="cardreaderCPP-54">  dir_t p;</front>
<front id="cardreaderCPP-55"> uint8_t cnt=0;</front>
<front id="cardreaderCPP-56"> </front>
<front id="cardreaderCPP-57">  while (parent.readDir(p, longFilename) &gt; 0)</front>
<front id="cardreaderCPP-58">  {</front>
<front id="cardreaderCPP-59">    if( DIR_IS_SUBDIR(&p) && lsAction!=LS_Count && lsAction!=LS_GetFilename) // hence LS_SerialPrint</front>
<front id="cardreaderCPP-60">    {</front>
<front id="cardreaderCPP-61"></front>
<front id="cardreaderCPP-62">      char path[13*2];</front>
<front id="cardreaderCPP-63">      char lfilename[13];</front>
<front id="cardreaderCPP-64">      createFilename(lfilename,p);</front>
<front id="cardreaderCPP-65">      </front>
<front id="cardreaderCPP-66">      path[0]=0;</front>
<front id="cardreaderCPP-67">      if(strlen(prepend)==0) //avoid leading / if already in prepend</front>
<front id="cardreaderCPP-68">      {</front>
<front id="cardreaderCPP-69">       strcat(path,"/");</front>
<front id="cardreaderCPP-70">      }</front>
<front id="cardreaderCPP-71">      strcat(path,prepend);</front>
<front id="cardreaderCPP-72">      strcat(path,lfilename);</front>
<front id="cardreaderCPP-73">      strcat(path,"/");</front>
<front id="cardreaderCPP-74">      </front>
<front id="cardreaderCPP-75">      //Serial.print(path);</front>
<front id="cardreaderCPP-76">      </front>
<front id="cardreaderCPP-77">      SdFile dir;</front>
<front id="cardreaderCPP-78">      if(!dir.open(parent,lfilename, O_READ))</front>
<front id="cardreaderCPP-79">      {</front>
<front id="cardreaderCPP-80">        if(lsAction==LS_SerialPrint)</front>
<front id="cardreaderCPP-81">        {</front>
<front id="cardreaderCPP-82">          SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-83">          SERIAL_ECHOLN(MSG_SD_CANT_OPEN_SUBDIR);</front>
<front id="cardreaderCPP-84">          SERIAL_ECHOLN(lfilename);</front>
<front id="cardreaderCPP-85">        }</front>
<front id="cardreaderCPP-86">      }</front>
<front id="cardreaderCPP-87">      lsDive(path,dir);</front>
<front id="cardreaderCPP-88">      //close done automatically by destructor of SdFile</front>
<front id="cardreaderCPP-89"></front>
<front id="cardreaderCPP-90">      </front>
<front id="cardreaderCPP-91">    }</front>
<front id="cardreaderCPP-92">    else</front>
<front id="cardreaderCPP-93">    {</front>
<front id="cardreaderCPP-94">      if (p.name[0] == DIR_NAME_FREE) break;</front>
<front id="cardreaderCPP-95">      if (p.name[0] == DIR_NAME_DELETED || p.name[0] == '.'|| p.name[0] == '_') continue;</front>
<front id="cardreaderCPP-96">      if (longFilename[0] != '\0' &&</front>
<front id="cardreaderCPP-97">          (longFilename[0] == '.' || longFilename[0] == '_')) continue;</front>
<front id="cardreaderCPP-98">      if ( p.name[0] == '.')</front>
<front id="cardreaderCPP-99">      {</front>
<front id="cardreaderCPP-100">        if ( p.name[1] != '.')</front>
<front id="cardreaderCPP-101">        continue;</front>
<front id="cardreaderCPP-102">      }</front>
<front id="cardreaderCPP-103">      </front>
<front id="cardreaderCPP-104">      if (!DIR_IS_FILE_OR_SUBDIR(&p)) continue;</front>
<front id="cardreaderCPP-105">      filenameIsDir=DIR_IS_SUBDIR(&p);</front>
<front id="cardreaderCPP-106">      </front>
<front id="cardreaderCPP-107">      </front>
<front id="cardreaderCPP-108">      if(!filenameIsDir)</front>
<front id="cardreaderCPP-109">      {</front>
<front id="cardreaderCPP-110">        if(p.name[8]!='G') continue;</front>
<front id="cardreaderCPP-111">        if(p.name[9]=='~') continue;</front>
<front id="cardreaderCPP-112">      }</front>
<front id="cardreaderCPP-113">      //if(cnt++!=nr) continue;</front>
<front id="cardreaderCPP-114">      createFilename(filename,p);</front>
<front id="cardreaderCPP-115">      if(lsAction==LS_SerialPrint)</front>
<front id="cardreaderCPP-116">      {</front>
<front id="cardreaderCPP-117">        SERIAL_PROTOCOL(prepend);</front>
<front id="cardreaderCPP-118">        SERIAL_PROTOCOLLN(filename);</front>
<front id="cardreaderCPP-119">      }</front>
<front id="cardreaderCPP-120">      else if(lsAction==LS_Count)</front>
<front id="cardreaderCPP-121">      {</front>
<front id="cardreaderCPP-122">        nrFiles++;</front>
<front id="cardreaderCPP-123">      } </front>
<front id="cardreaderCPP-124">      else if(lsAction==LS_GetFilename)</front>
<front id="cardreaderCPP-125">      {</front>
<front id="cardreaderCPP-126">        if(cnt==nrFiles)</front>
<front id="cardreaderCPP-127">          return;</front>
<front id="cardreaderCPP-128">        cnt++;</front>
<front id="cardreaderCPP-129">        </front>
<front id="cardreaderCPP-130">      }</front>
<front id="cardreaderCPP-131">    }</front>
<front id="cardreaderCPP-132">  }</front>
<front id="cardreaderCPP-133">}</front>
<front id="cardreaderCPP-134"></front>
<front id="cardreaderCPP-135">void CardReader::ls() </front>
<front id="cardreaderCPP-136">{</front>
<front id="cardreaderCPP-137">  lsAction=LS_SerialPrint;</front>
<front id="cardreaderCPP-138">  if(lsAction==LS_Count)</front>
<front id="cardreaderCPP-139">  nrFiles=0;</front>
<front id="cardreaderCPP-140"></front>
<front id="cardreaderCPP-141">  root.rewind();</front>
<front id="cardreaderCPP-142">  lsDive("",root);</front>
<front id="cardreaderCPP-143">}</front>
<front id="cardreaderCPP-144"></front>
<front id="cardreaderCPP-145"></front>
<front id="cardreaderCPP-146">void CardReader::initsd()</front>
<front id="cardreaderCPP-147">{</front>
<front id="cardreaderCPP-148">  cardOK = false;</front>
<front id="cardreaderCPP-149">  if(root.isOpen())</front>
<front id="cardreaderCPP-150">    root.close();</front>
<front id="cardreaderCPP-151">#ifdef SDSLOW</front>
<front id="cardreaderCPP-152">  if (!card.init(SPI_HALF_SPEED,SDSS))</front>
<front id="cardreaderCPP-153">#else</front>
<front id="cardreaderCPP-154">  if (!card.init(SPI_FULL_SPEED,SDSS))</front>
<front id="cardreaderCPP-155">#endif</front>
<front id="cardreaderCPP-156">  {</front>
<front id="cardreaderCPP-157">    //if (!card.init(SPI_HALF_SPEED,SDSS))</front>
<front id="cardreaderCPP-158">    SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-159">    SERIAL_ECHOLNPGM(MSG_SD_INIT_FAIL);</front>
<front id="cardreaderCPP-160">  }</front>
<front id="cardreaderCPP-161">  else if (!volume.init(&card))</front>
<front id="cardreaderCPP-162">  {</front>
<front id="cardreaderCPP-163">    SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-164">    SERIAL_ERRORLNPGM(MSG_SD_VOL_INIT_FAIL);</front>
<front id="cardreaderCPP-165">  }</front>
<front id="cardreaderCPP-166">  else if (!root.openRoot(&volume)) </front>
<front id="cardreaderCPP-167">  {</front>
<front id="cardreaderCPP-168">    SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-169">    SERIAL_ERRORLNPGM(MSG_SD_OPENROOT_FAIL);</front>
<front id="cardreaderCPP-170">  }</front>
<front id="cardreaderCPP-171">  else </front>
<front id="cardreaderCPP-172">  {</front>
<front id="cardreaderCPP-173">    cardOK = true;</front>
<front id="cardreaderCPP-174">    SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-175">    SERIAL_ECHOLNPGM(MSG_SD_CARD_OK);</front>
<front id="cardreaderCPP-176">  }</front>
<front id="cardreaderCPP-177">  workDir=root;</front>
<front id="cardreaderCPP-178">  curDir=&root;</front>
<front id="cardreaderCPP-179">  /*</front>
<front id="cardreaderCPP-180">  if(!workDir.openRoot(&volume))</front>
<front id="cardreaderCPP-181">  {</front>
<front id="cardreaderCPP-182">    SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);</front>
<front id="cardreaderCPP-183">  }</front>
<front id="cardreaderCPP-184">  */</front>
<front id="cardreaderCPP-185">  </front>
<front id="cardreaderCPP-186">}</front>
<front id="cardreaderCPP-187"></front>
<front id="cardreaderCPP-188">void CardReader::setroot()</front>
<front id="cardreaderCPP-189">{</front>
<front id="cardreaderCPP-190">  /*if(!workDir.openRoot(&volume))</front>
<front id="cardreaderCPP-191">  {</front>
<front id="cardreaderCPP-192">    SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);</front>
<front id="cardreaderCPP-193">  }*/</front>
<front id="cardreaderCPP-194">  workDir=root;</front>
<front id="cardreaderCPP-195">  </front>
<front id="cardreaderCPP-196">  curDir=&workDir;</front>
<front id="cardreaderCPP-197">}</front>
<front id="cardreaderCPP-198">void CardReader::release()</front>
<front id="cardreaderCPP-199">{</front>
<front id="cardreaderCPP-200">  sdprinting = false;</front>
<front id="cardreaderCPP-201">  cardOK = false;</front>
<front id="cardreaderCPP-202">}</front>
<front id="cardreaderCPP-203"></front>
<front id="cardreaderCPP-204">void CardReader::startFileprint()</front>
<front id="cardreaderCPP-205">{</front>
<front id="cardreaderCPP-206">  if(cardOK)</front>
<front id="cardreaderCPP-207">  {</front>
<front id="cardreaderCPP-208">    sdprinting = true;</front>
<front id="cardreaderCPP-209">  }</front>
<front id="cardreaderCPP-210">}</front>
<front id="cardreaderCPP-211"></front>
<front id="cardreaderCPP-212">void CardReader::pauseSDPrint()</front>
<front id="cardreaderCPP-213">{</front>
<front id="cardreaderCPP-214">  if(sdprinting)</front>
<front id="cardreaderCPP-215">  {</front>
<front id="cardreaderCPP-216">    sdprinting = false;</front>
<front id="cardreaderCPP-217">  }</front>
<front id="cardreaderCPP-218">}</front>
<front id="cardreaderCPP-219"></front>
<front id="cardreaderCPP-220"></front>
<front id="cardreaderCPP-221">void CardReader::openLogFile(char* name)</front>
<front id="cardreaderCPP-222">{</front>
<front id="cardreaderCPP-223">  logging = true;</front>
<front id="cardreaderCPP-224">  openFile(name, false);</front>
<front id="cardreaderCPP-225">}</front>
<front id="cardreaderCPP-226"></front>
<front id="cardreaderCPP-227">void CardReader::openFile(char* name,bool read)</front>
<front id="cardreaderCPP-228">{</front>
<front id="cardreaderCPP-229">  if(!cardOK)</front>
<front id="cardreaderCPP-230">    return;</front>
<front id="cardreaderCPP-231">  file.close();</front>
<front id="cardreaderCPP-232">  sdprinting = false;</front>
<front id="cardreaderCPP-233">  </front>
<front id="cardreaderCPP-234">  </front>
<front id="cardreaderCPP-235">  SdFile myDir;</front>
<front id="cardreaderCPP-236">  curDir=&root;</front>
<front id="cardreaderCPP-237">  char *fname=name;</front>
<front id="cardreaderCPP-238">  </front>
<front id="cardreaderCPP-239">  char *dirname_start,*dirname_end;</front>
<front id="cardreaderCPP-240">  if(name[0]=='/')</front>
<front id="cardreaderCPP-241">  {</front>
<front id="cardreaderCPP-242">    dirname_start=strchr(name,'/')+1;</front>
<front id="cardreaderCPP-243">    while(dirname_start&gt;0)</front>
<front id="cardreaderCPP-244">    {</front>
<front id="cardreaderCPP-245">      dirname_end=strchr(dirname_start,'/');</front>
<front id="cardreaderCPP-246">      //SERIAL_ECHO("start:");SERIAL_ECHOLN((int)(dirname_start-name));</front>
<front id="cardreaderCPP-247">      //SERIAL_ECHO("end  :");SERIAL_ECHOLN((int)(dirname_end-name));</front>
<front id="cardreaderCPP-248">      if(dirname_end&gt;0 && dirname_end&gt;dirname_start)</front>
<front id="cardreaderCPP-249">      {</front>
<front id="cardreaderCPP-250">        char subdirname[13];</front>
<front id="cardreaderCPP-251">        strncpy(subdirname, dirname_start, dirname_end-dirname_start);</front>
<front id="cardreaderCPP-252">        subdirname[dirname_end-dirname_start]=0;</front>
<front id="cardreaderCPP-253">        SERIAL_ECHOLN(subdirname);</front>
<front id="cardreaderCPP-254">        if(!myDir.open(curDir,subdirname,O_READ))</front>
<front id="cardreaderCPP-255">        {</front>
<front id="cardreaderCPP-256">          SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);</front>
<front id="cardreaderCPP-257">          SERIAL_PROTOCOL(subdirname);</front>
<front id="cardreaderCPP-258">          SERIAL_PROTOCOLLNPGM(".");</front>
<front id="cardreaderCPP-259">          return;</front>
<front id="cardreaderCPP-260">        }</front>
<front id="cardreaderCPP-261">        else</front>
<front id="cardreaderCPP-262">        {</front>
<front id="cardreaderCPP-263">          //SERIAL_ECHOLN("dive ok");</front>
<front id="cardreaderCPP-264">        }</front>
<front id="cardreaderCPP-265">          </front>
<front id="cardreaderCPP-266">        curDir=&myDir; </front>
<front id="cardreaderCPP-267">        dirname_start=dirname_end+1;</front>
<front id="cardreaderCPP-268">      }</front>
<front id="cardreaderCPP-269">      else // the reminder after all /fsa/fdsa/ is the filename</front>
<front id="cardreaderCPP-270">      {</front>
<front id="cardreaderCPP-271">        fname=dirname_start;</front>
<front id="cardreaderCPP-272">        //SERIAL_ECHOLN("remaider");</front>
<front id="cardreaderCPP-273">        //SERIAL_ECHOLN(fname);</front>
<front id="cardreaderCPP-274">        break;</front>
<front id="cardreaderCPP-275">      }</front>
<front id="cardreaderCPP-276">      </front>
<front id="cardreaderCPP-277">    }</front>
<front id="cardreaderCPP-278">  }</front>
<front id="cardreaderCPP-279">  else //relative path</front>
<front id="cardreaderCPP-280">  {</front>
<front id="cardreaderCPP-281">    curDir=&workDir;</front>
<front id="cardreaderCPP-282">  }</front>
<front id="cardreaderCPP-283">  if(read)</front>
<front id="cardreaderCPP-284">  {</front>
<front id="cardreaderCPP-285">    if (file.open(curDir, fname, O_READ)) </front>
<front id="cardreaderCPP-286">    {</front>
<front id="cardreaderCPP-287">      filesize = file.fileSize();</front>
<front id="cardreaderCPP-288">      SERIAL_PROTOCOLPGM(MSG_SD_FILE_OPENED);</front>
<front id="cardreaderCPP-289">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-290">      SERIAL_PROTOCOLPGM(MSG_SD_SIZE);</front>
<front id="cardreaderCPP-291">      SERIAL_PROTOCOLLN(filesize);</front>
<front id="cardreaderCPP-292">      sdpos = 0;</front>
<front id="cardreaderCPP-293">      </front>
<front id="cardreaderCPP-294">      SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);</front>
<front id="cardreaderCPP-295">      lcd_setstatus(fname);</front>
<front id="cardreaderCPP-296">    }</front>
<front id="cardreaderCPP-297">    else</front>
<front id="cardreaderCPP-298">    {</front>
<front id="cardreaderCPP-299">      SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);</front>
<front id="cardreaderCPP-300">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-301">      SERIAL_PROTOCOLLNPGM(".");</front>
<front id="cardreaderCPP-302">    }</front>
<front id="cardreaderCPP-303">  }</front>
<front id="cardreaderCPP-304">  else </front>
<front id="cardreaderCPP-305">  { //write</front>
<front id="cardreaderCPP-306">    if (!file.open(curDir, fname, O_CREAT | O_APPEND | O_WRITE | O_TRUNC))</front>
<front id="cardreaderCPP-307">    {</front>
<front id="cardreaderCPP-308">      SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);</front>
<front id="cardreaderCPP-309">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-310">      SERIAL_PROTOCOLLNPGM(".");</front>
<front id="cardreaderCPP-311">    }</front>
<front id="cardreaderCPP-312">    else</front>
<front id="cardreaderCPP-313">    {</front>
<front id="cardreaderCPP-314">      saving = true;</front>
<front id="cardreaderCPP-315">      SERIAL_PROTOCOLPGM(MSG_SD_WRITE_TO_FILE);</front>
<front id="cardreaderCPP-316">      SERIAL_PROTOCOLLN(name);</front>
<front id="cardreaderCPP-317">      lcd_setstatus(fname);</front>
<front id="cardreaderCPP-318">    }</front>
<front id="cardreaderCPP-319">  }</front>
<front id="cardreaderCPP-320">  </front>
<front id="cardreaderCPP-321">}</front>
<front id="cardreaderCPP-322"></front>
<front id="cardreaderCPP-323">void CardReader::removeFile(char* name)</front>
<front id="cardreaderCPP-324">{</front>
<front id="cardreaderCPP-325">  if(!cardOK)</front>
<front id="cardreaderCPP-326">    return;</front>
<front id="cardreaderCPP-327">  file.close();</front>
<front id="cardreaderCPP-328">  sdprinting = false;</front>
<front id="cardreaderCPP-329">  </front>
<front id="cardreaderCPP-330">  </front>
<front id="cardreaderCPP-331">  SdFile myDir;</front>
<front id="cardreaderCPP-332">  curDir=&root;</front>
<front id="cardreaderCPP-333">  char *fname=name;</front>
<front id="cardreaderCPP-334">  </front>
<front id="cardreaderCPP-335">  char *dirname_start,*dirname_end;</front>
<front id="cardreaderCPP-336">  if(name[0]=='/')</front>
<front id="cardreaderCPP-337">  {</front>
<front id="cardreaderCPP-338">    dirname_start=strchr(name,'/')+1;</front>
<front id="cardreaderCPP-339">    while(dirname_start&gt;0)</front>
<front id="cardreaderCPP-340">    {</front>
<front id="cardreaderCPP-341">      dirname_end=strchr(dirname_start,'/');</front>
<front id="cardreaderCPP-342">      //SERIAL_ECHO("start:");SERIAL_ECHOLN((int)(dirname_start-name));</front>
<front id="cardreaderCPP-343">      //SERIAL_ECHO("end  :");SERIAL_ECHOLN((int)(dirname_end-name));</front>
<front id="cardreaderCPP-344">      if(dirname_end&gt;0 && dirname_end&gt;dirname_start)</front>
<front id="cardreaderCPP-345">      {</front>
<front id="cardreaderCPP-346">        char subdirname[13];</front>
<front id="cardreaderCPP-347">        strncpy(subdirname, dirname_start, dirname_end-dirname_start);</front>
<front id="cardreaderCPP-348">        subdirname[dirname_end-dirname_start]=0;</front>
<front id="cardreaderCPP-349">        SERIAL_ECHOLN(subdirname);</front>
<front id="cardreaderCPP-350">        if(!myDir.open(curDir,subdirname,O_READ))</front>
<front id="cardreaderCPP-351">        {</front>
<front id="cardreaderCPP-352">          SERIAL_PROTOCOLPGM("open failed, File: ");</front>
<front id="cardreaderCPP-353">          SERIAL_PROTOCOL(subdirname);</front>
<front id="cardreaderCPP-354">          SERIAL_PROTOCOLLNPGM(".");</front>
<front id="cardreaderCPP-355">          return;</front>
<front id="cardreaderCPP-356">        }</front>
<front id="cardreaderCPP-357">        else</front>
<front id="cardreaderCPP-358">        {</front>
<front id="cardreaderCPP-359">          //SERIAL_ECHOLN("dive ok");</front>
<front id="cardreaderCPP-360">        }</front>
<front id="cardreaderCPP-361">          </front>
<front id="cardreaderCPP-362">        curDir=&myDir; </front>
<front id="cardreaderCPP-363">        dirname_start=dirname_end+1;</front>
<front id="cardreaderCPP-364">      }</front>
<front id="cardreaderCPP-365">      else // the reminder after all /fsa/fdsa/ is the filename</front>
<front id="cardreaderCPP-366">      {</front>
<front id="cardreaderCPP-367">        fname=dirname_start;</front>
<front id="cardreaderCPP-368">        //SERIAL_ECHOLN("remaider");</front>
<front id="cardreaderCPP-369">        //SERIAL_ECHOLN(fname);</front>
<front id="cardreaderCPP-370">        break;</front>
<front id="cardreaderCPP-371">      }</front>
<front id="cardreaderCPP-372">      </front>
<front id="cardreaderCPP-373">    }</front>
<front id="cardreaderCPP-374">  }</front>
<front id="cardreaderCPP-375">  else //relative path</front>
<front id="cardreaderCPP-376">  {</front>
<front id="cardreaderCPP-377">    curDir=&workDir;</front>
<front id="cardreaderCPP-378">  }</front>
<front id="cardreaderCPP-379">    if (file.remove(curDir, fname)) </front>
<front id="cardreaderCPP-380">    {</front>
<front id="cardreaderCPP-381">      SERIAL_PROTOCOLPGM("File deleted:");</front>
<front id="cardreaderCPP-382">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-383">      sdpos = 0;</front>
<front id="cardreaderCPP-384">    }</front>
<front id="cardreaderCPP-385">    else</front>
<front id="cardreaderCPP-386">    {</front>
<front id="cardreaderCPP-387">      SERIAL_PROTOCOLPGM("Deletion failed, File: ");</front>
<front id="cardreaderCPP-388">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-389">      SERIAL_PROTOCOLLNPGM(".");</front>
<front id="cardreaderCPP-390">    }</front>
<front id="cardreaderCPP-391">  </front>
<front id="cardreaderCPP-392">}</front>
<front id="cardreaderCPP-393"></front>
<front id="cardreaderCPP-394">void CardReader::getStatus()</front>
<front id="cardreaderCPP-395">{</front>
<front id="cardreaderCPP-396">  if(cardOK){</front>
<front id="cardreaderCPP-397">    SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);</front>
<front id="cardreaderCPP-398">    SERIAL_PROTOCOL(sdpos);</front>
<front id="cardreaderCPP-399">    SERIAL_PROTOCOLPGM("/");</front>
<front id="cardreaderCPP-400">    SERIAL_PROTOCOLLN(filesize);</front>
<front id="cardreaderCPP-401">  }</front>
<front id="cardreaderCPP-402">  else{</front>
<front id="cardreaderCPP-403">    SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);</front>
<front id="cardreaderCPP-404">  }</front>
<front id="cardreaderCPP-405">}</front>
<front id="cardreaderCPP-406">void CardReader::write_command(char *buf)</front>
<front id="cardreaderCPP-407">{</front>
<front id="cardreaderCPP-408">  char* begin = buf;</front>
<front id="cardreaderCPP-409">  char* npos = 0;</front>
<front id="cardreaderCPP-410">  char* end = buf + strlen(buf) - 1;</front>
<front id="cardreaderCPP-411"></front>
<front id="cardreaderCPP-412">  file.writeError = false;</front>
<front id="cardreaderCPP-413">  if((npos = strchr(buf, 'N')) != NULL)</front>
<front id="cardreaderCPP-414">  {</front>
<front id="cardreaderCPP-415">    begin = strchr(npos, ' ') + 1;</front>
<front id="cardreaderCPP-416">    end = strchr(npos, '*') - 1;</front>
<front id="cardreaderCPP-417">  }</front>
<front id="cardreaderCPP-418">  end[1] = '\r';</front>
<front id="cardreaderCPP-419">  end[2] = '\n';</front>
<front id="cardreaderCPP-420">  end[3] = '\0';</front>
<front id="cardreaderCPP-421">  file.write(begin);</front>
<front id="cardreaderCPP-422">  if (file.writeError)</front>
<front id="cardreaderCPP-423">  {</front>
<front id="cardreaderCPP-424">    SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-425">    SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);</front>
<front id="cardreaderCPP-426">  }</front>
<front id="cardreaderCPP-427">}</front>
<front id="cardreaderCPP-428"></front>
<front id="cardreaderCPP-429"></front>
<front id="cardreaderCPP-430">void CardReader::checkautostart(bool force)</front>
<front id="cardreaderCPP-431">{</front>
<front id="cardreaderCPP-432">  if(!force)</front>
<front id="cardreaderCPP-433">  {</front>
<front id="cardreaderCPP-434">    if(!autostart_stilltocheck)</front>
<front id="cardreaderCPP-435">      return;</front>
<front id="cardreaderCPP-436">    if(autostart_atmillis&lt;millis())</front>
<front id="cardreaderCPP-437">      return;</front>
<front id="cardreaderCPP-438">  }</front>
<front id="cardreaderCPP-439">  autostart_stilltocheck=false;</front>
<front id="cardreaderCPP-440">  if(!cardOK)</front>
<front id="cardreaderCPP-441">  {</front>
<front id="cardreaderCPP-442">    initsd();</front>
<front id="cardreaderCPP-443">    if(!cardOK) //fail</front>
<front id="cardreaderCPP-444">      return;</front>
<front id="cardreaderCPP-445">  }</front>
<front id="cardreaderCPP-446">  </front>
<front id="cardreaderCPP-447">  char autoname[30];</front>
<front id="cardreaderCPP-448">  sprintf_P(autoname, PSTR("auto%i.g"), lastnr);</front>
<front id="cardreaderCPP-449">  for(int8_t i=0;i&lt;(int8_t)strlen(autoname);i++)</front>
<front id="cardreaderCPP-450">    autoname[i]=tolower(autoname[i]);</front>
<front id="cardreaderCPP-451">  dir_t p;</front>
<front id="cardreaderCPP-452"></front>
<front id="cardreaderCPP-453">  root.rewind();</front>
<front id="cardreaderCPP-454">  </front>
<front id="cardreaderCPP-455">  bool found=false;</front>
<front id="cardreaderCPP-456">  while (root.readDir(p, NULL) &gt; 0) </front>
<front id="cardreaderCPP-457">  {</front>
<front id="cardreaderCPP-458">    for(int8_t i=0;i&lt;(int8_t)strlen((char*)p.name);i++)</front>
<front id="cardreaderCPP-459">    p.name[i]=tolower(p.name[i]);</front>
<front id="cardreaderCPP-460">    //Serial.print((char*)p.name);</front>
<front id="cardreaderCPP-461">    //Serial.print(" ");</front>
<front id="cardreaderCPP-462">    //Serial.println(autoname);</front>
<front id="cardreaderCPP-463">    if(p.name[9]!='~') //skip safety copies</front>
<front id="cardreaderCPP-464">    if(strncmp((char*)p.name,autoname,5)==0)</front>
<front id="cardreaderCPP-465">    {</front>
<front id="cardreaderCPP-466">      char cmd[30];</front>
<front id="cardreaderCPP-467"></front>
<front id="cardreaderCPP-468">      sprintf_P(cmd, PSTR("M23 %s"), autoname);</front>
<front id="cardreaderCPP-469">      enquecommand(cmd);</front>
<front id="cardreaderCPP-470">      enquecommand_P(PSTR("M24"));</front>
<front id="cardreaderCPP-471">      found=true;</front>
<front id="cardreaderCPP-472">    }</front>
<front id="cardreaderCPP-473">  }</front>
<front id="cardreaderCPP-474">  if(!found)</front>
<front id="cardreaderCPP-475">    lastnr=-1;</front>
<front id="cardreaderCPP-476">  else</front>
<front id="cardreaderCPP-477">    lastnr++;</front>
<front id="cardreaderCPP-478">}</front>
<front id="cardreaderCPP-479"></front>
<front id="cardreaderCPP-480">void CardReader::closefile()</front>
<front id="cardreaderCPP-481">{</front>
<front id="cardreaderCPP-482">  file.sync();</front>
<front id="cardreaderCPP-483">  file.close();</front>
<front id="cardreaderCPP-484">  saving = false; </front>
<front id="cardreaderCPP-485">  logging = false;</front>
<front id="cardreaderCPP-486">}</front>
<front id="cardreaderCPP-487"></front>
<front id="cardreaderCPP-488">void CardReader::getfilename(const uint8_t nr)</front>
<front id="cardreaderCPP-489">{</front>
<front id="cardreaderCPP-490">  curDir=&workDir;</front>
<front id="cardreaderCPP-491">  lsAction=LS_GetFilename;</front>
<front id="cardreaderCPP-492">  nrFiles=nr;</front>
<front id="cardreaderCPP-493">  curDir-&gt;rewind();</front>
<front id="cardreaderCPP-494">  lsDive("",*curDir);</front>
<front id="cardreaderCPP-495">  </front>
<front id="cardreaderCPP-496">}</front>
<front id="cardreaderCPP-497"></front>
<front id="cardreaderCPP-498">uint16_t CardReader::getnrfilenames()</front>
<front id="cardreaderCPP-499">{</front>
<front id="cardreaderCPP-500">  curDir=&workDir;</front>
<front id="cardreaderCPP-501">  lsAction=LS_Count;</front>
<front id="cardreaderCPP-502">  nrFiles=0;</front>
<front id="cardreaderCPP-503">  curDir-&gt;rewind();</front>
<front id="cardreaderCPP-504">  lsDive("",*curDir);</front>
<front id="cardreaderCPP-505">  //SERIAL_ECHOLN(nrFiles);</front>
<front id="cardreaderCPP-506">  return nrFiles;</front>
<front id="cardreaderCPP-507">}</front>
<front id="cardreaderCPP-508"></front>
<front id="cardreaderCPP-509">void CardReader::chdir(const char * relpath)</front>
<front id="cardreaderCPP-510">{</front>
<front id="cardreaderCPP-511">  SdFile newfile;</front>
<front id="cardreaderCPP-512">  SdFile *parent=&root;</front>
<front id="cardreaderCPP-513">  </front>
<front id="cardreaderCPP-514">  if(workDir.isOpen())</front>
<front id="cardreaderCPP-515">    parent=&workDir;</front>
<front id="cardreaderCPP-516">  </front>
<front id="cardreaderCPP-517">  if(!newfile.open(*parent,relpath, O_READ))</front>
<front id="cardreaderCPP-518">  {</front>
<front id="cardreaderCPP-519">   SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-520">   SERIAL_ECHOPGM(MSG_SD_CANT_ENTER_SUBDIR);</front>
<front id="cardreaderCPP-521">   SERIAL_ECHOLN(relpath);</front>
<front id="cardreaderCPP-522">  }</front>
<front id="cardreaderCPP-523">  else</front>
<front id="cardreaderCPP-524">  {</front>
<front id="cardreaderCPP-525">    if (workDirDepth &lt; MAX_DIR_DEPTH) {</front>
<front id="cardreaderCPP-526">      for (int d = ++workDirDepth; d--;)</front>
<front id="cardreaderCPP-527">        workDirParents[d+1] = workDirParents[d];</front>
<front id="cardreaderCPP-528">      workDirParents[0]=*parent;</front>
<front id="cardreaderCPP-529">    }</front>
<front id="cardreaderCPP-530">    workDir=newfile;</front>
<front id="cardreaderCPP-531">  }</front>
<front id="cardreaderCPP-532">}</front>
<front id="cardreaderCPP-533"></front>
<front id="cardreaderCPP-534">void CardReader::updir()</front>
<front id="cardreaderCPP-535">{</front>
<front id="cardreaderCPP-536">  if(workDirDepth &gt; 0)</front>
<front id="cardreaderCPP-537">  {</front>
<front id="cardreaderCPP-538">    --workDirDepth;</front>
<front id="cardreaderCPP-539">    workDir = workDirParents[0];</front>
<front id="cardreaderCPP-540">    int d;</front>
<front id="cardreaderCPP-541">    for (int d = 0; d &lt; workDirDepth; d++)</front>
<front id="cardreaderCPP-542">      workDirParents[d] = workDirParents[d+1];</front>
<front id="cardreaderCPP-543">  }</front>
<front id="cardreaderCPP-544">}</front>
<front id="cardreaderCPP-545"></front>
<front id="cardreaderCPP-546"></front>
<front id="cardreaderCPP-547">void CardReader::printingHasFinished()</front>
<front id="cardreaderCPP-548">{</front>
<front id="cardreaderCPP-549">    st_synchronize();</front>
<front id="cardreaderCPP-550">    quickStop();</front>
<front id="cardreaderCPP-551">    file.close();</front>
<front id="cardreaderCPP-552">    sdprinting = false;</front>
<front id="cardreaderCPP-553">    if(SD_FINISHED_STEPPERRELEASE)</front>
<front id="cardreaderCPP-554">    {</front>
<front id="cardreaderCPP-555">        //finishAndDisableSteppers();</front>
<front id="cardreaderCPP-556">        enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));</front>
<front id="cardreaderCPP-557">    }</front>
<front id="cardreaderCPP-558">    autotempShutdown();</front>
<front id="cardreaderCPP-559">}</front>
<front id="cardreaderCPP-560">#endif //SDSUPPORT</front>
 </pre>
<h1>cardreader.h</h1>
<pre  class="prettyprint linenums"><front id="cardreaderH-1">#ifndef CARDREADER_H</front>
<front id="cardreaderH-2">#define CARDREADER_H</front>
<front id="cardreaderH-3"></front>
<front id="cardreaderH-4">#ifdef SDSUPPORT</front>
<front id="cardreaderH-5"></front>
<front id="cardreaderH-6">#define MAX_DIR_DEPTH 10</front>
<front id="cardreaderH-7"></front>
<front id="cardreaderH-8">#include "SdFile.h"</front>
<front id="cardreaderH-9">enum LsAction {LS_SerialPrint,LS_Count,LS_GetFilename};</front>
<front id="cardreaderH-10">class CardReader</front>
<front id="cardreaderH-11">{</front>
<front id="cardreaderH-12">public:</front>
<front id="cardreaderH-13">  CardReader();</front>
<front id="cardreaderH-14">  </front>
<front id="cardreaderH-15">  void initsd();</front>
<front id="cardreaderH-16">  void write_command(char *buf);</front>
<front id="cardreaderH-17">  //files auto[0-9].g on the sd card are performed in a row</front>
<front id="cardreaderH-18">  //this is to delay autostart and hence the initialisaiton of the sd card to some seconds after the normal init, so the device is available quick after a reset</front>
<front id="cardreaderH-19"></front>
<front id="cardreaderH-20">  void checkautostart(bool x); </front>
<front id="cardreaderH-21">  void openFile(char* name,bool read);</front>
<front id="cardreaderH-22">  void openLogFile(char* name);</front>
<front id="cardreaderH-23">  void removeFile(char* name);</front>
<front id="cardreaderH-24">  void closefile();</front>
<front id="cardreaderH-25">  void release();</front>
<front id="cardreaderH-26">  void startFileprint();</front>
<front id="cardreaderH-27">  void pauseSDPrint();</front>
<front id="cardreaderH-28">  void getStatus();</front>
<front id="cardreaderH-29">  void printingHasFinished();</front>
<front id="cardreaderH-30"></front>
<front id="cardreaderH-31">  void getfilename(const uint8_t nr);</front>
<front id="cardreaderH-32">  uint16_t getnrfilenames();</front>
<front id="cardreaderH-33">  </front>
<front id="cardreaderH-34"></front>
<front id="cardreaderH-35">  void ls();</front>
<front id="cardreaderH-36">  void chdir(const char * relpath);</front>
<front id="cardreaderH-37">  void updir();</front>
<front id="cardreaderH-38">  void setroot();</front>
<front id="cardreaderH-39"></front>
<front id="cardreaderH-40"></front>
<front id="cardreaderH-41">  FORCE_INLINE bool isFileOpen() { return file.isOpen(); }</front>
<front id="cardreaderH-42">  FORCE_INLINE bool eof() { return sdpos&gt;=filesize ;};</front>
<front id="cardreaderH-43">  FORCE_INLINE int16_t get() {  sdpos = file.curPosition();return (int16_t)file.read();};</front>
<front id="cardreaderH-44">  FORCE_INLINE void setIndex(long index) {sdpos = index;file.seekSet(index);};</front>
<front id="cardreaderH-45">  FORCE_INLINE uint8_t percentDone(){if(!isFileOpen()) return 0; if(filesize) return sdpos/((filesize+99)/100); else return 0;};</front>
<front id="cardreaderH-46">  FORCE_INLINE char* getWorkDirName(){workDir.getFilename(filename);return filename;};</front>
<front id="cardreaderH-47"></front>
<front id="cardreaderH-48">public:</front>
<front id="cardreaderH-49">  bool saving;</front>
<front id="cardreaderH-50">  bool logging;</front>
<front id="cardreaderH-51">  bool sdprinting ;  </front>
<front id="cardreaderH-52">  bool cardOK ;</front>
<front id="cardreaderH-53">  char filename[13];</front>
<front id="cardreaderH-54">  char longFilename[LONG_FILENAME_LENGTH];</front>
<front id="cardreaderH-55">  bool filenameIsDir;</front>
<front id="cardreaderH-56">  int lastnr; //last number of the autostart;</front>
<front id="cardreaderH-57">private:</front>
<front id="cardreaderH-58">  SdFile root,*curDir,workDir,workDirParents[MAX_DIR_DEPTH];</front>
<front id="cardreaderH-59">  uint16_t workDirDepth;</front>
<front id="cardreaderH-60">  Sd2Card card;</front>
<front id="cardreaderH-61">  SdVolume volume;</front>
<front id="cardreaderH-62">  SdFile file;</front>
<front id="cardreaderH-63">  uint32_t filesize;</front>
<front id="cardreaderH-64">  //int16_t n;</front>
<front id="cardreaderH-65">  unsigned long autostart_atmillis;</front>
<front id="cardreaderH-66">  uint32_t sdpos ;</front>
<front id="cardreaderH-67"></front>
<front id="cardreaderH-68">  bool autostart_stilltocheck; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.</front>
<front id="cardreaderH-69">  </front>
<front id="cardreaderH-70">  LsAction lsAction; //stored for recursion.</front>
<front id="cardreaderH-71">  int16_t nrFiles; //counter for the files in the current directory and recycled as position counter for getting the nrFiles'th name in the directory.</front>
<front id="cardreaderH-72">  char* diveDirName;</front>
<front id="cardreaderH-73">  void lsDive(const char *prepend,SdFile parent);</front>
<front id="cardreaderH-74">};</front>
<front id="cardreaderH-75">extern CardReader card;</front>
<front id="cardreaderH-76">#define IS_SD_PRINTING (card.sdprinting)</front>
<front id="cardreaderH-77"></front>
<front id="cardreaderH-78">#if (SDCARDDETECT &gt; -1)</front>
<front id="cardreaderH-79"># ifdef SDCARDDETECTINVERTED </front>
<front id="cardreaderH-80">#  define IS_SD_INSERTED (READ(SDCARDDETECT)!=0)</front>
<front id="cardreaderH-81"># else</front>
<front id="cardreaderH-82">#  define IS_SD_INSERTED (READ(SDCARDDETECT)==0)</front>
<front id="cardreaderH-83"># endif //SDCARDTETECTINVERTED</front>
<front id="cardreaderH-84">#else</front>
<front id="cardreaderH-85">//If we don't have a card detect line, aways asume the card is inserted</front>
<front id="cardreaderH-86"># define IS_SD_INSERTED true</front>
<front id="cardreaderH-87">#endif</front>
<front id="cardreaderH-88"></front>
<front id="cardreaderH-89">#else</front>
<front id="cardreaderH-90"></front>
<front id="cardreaderH-91">#define IS_SD_PRINTING (false)</front>
<front id="cardreaderH-92"></front>
<front id="cardreaderH-93">#endif //SDSUPPORT</front>
<front id="cardreaderH-94">#endif</front>
 </pre>
<h1>Configuration.h</h1>
<pre  class="prettyprint linenums"><front id="ConfigurationH-1">#ifndef CONFIGURATION_H</front>
<front id="ConfigurationH-2">#define CONFIGURATION_H</front>
<front id="ConfigurationH-3"></front>
<front id="ConfigurationH-4">// This configuration file contains the basic settings.</front>
<front id="ConfigurationH-5">// Advanced settings can be found in Configuration_adv.h</front>
<front id="ConfigurationH-6">// BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration</front>
<front id="ConfigurationH-7"></front>
<front id="ConfigurationH-8">//===========================================================================</front>
<front id="ConfigurationH-9">//============================= DELTA Printer ===============================</front>
<front id="ConfigurationH-10">//===========================================================================</front>
<front id="ConfigurationH-11">// For a Delta printer rplace the configuration files wilth the files in the </front>
<front id="ConfigurationH-12">// example_configurations/delta directory.</front>
<front id="ConfigurationH-13">// </front>
<front id="ConfigurationH-14"></front>
<front id="ConfigurationH-15">// User-specified version info of this build to display in [Pronterface, etc] terminal window during</front>
<front id="ConfigurationH-16">// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this</front>
<front id="ConfigurationH-17">// build by the user have been successfully uploaded into firmware.</front>
<front id="ConfigurationH-18">#define STRING_VERSION_CONFIG_H __DATE__ " " __TIME__ // build date and time</front>
<front id="ConfigurationH-19">#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.</front>
<front id="ConfigurationH-20"></front>
<front id="ConfigurationH-21">// SERIAL_PORT selects which serial port should be used for communication with the host.</front>
<front id="ConfigurationH-22">// This allows the connection of wireless adapters (for instance) to non-default port pins.</front>
<front id="ConfigurationH-23">// Serial port 0 is still used by the Arduino bootloader regardless of this setting.</front>
<front id="ConfigurationH-24">#define SERIAL_PORT 0</front>
<front id="ConfigurationH-25"></front>
<front id="ConfigurationH-26">// This determines the communication speed of the printer</front>
<front id="ConfigurationH-27">#define BAUDRATE 250000</front>
<front id="ConfigurationH-28">//#define BAUDRATE 115200</front>
<front id="ConfigurationH-29"></front>
<front id="ConfigurationH-30">//// The following define selects which electronics board you have. Please choose the one that matches your setup</front>
<front id="ConfigurationH-31">// 10 = Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"</front>
<front id="ConfigurationH-32">// 11 = Gen7 v1.1, v1.2 = 11</front>
<front id="ConfigurationH-33">// 12 = Gen7 v1.3</front>
<front id="ConfigurationH-34">// 13 = Gen7 v1.4</front>
<front id="ConfigurationH-35">// 20 = Sethi 3D_1 </front>
<front id="ConfigurationH-36">// 3  = MEGA/RAMPS up to 1.2 = 3</front>
<front id="ConfigurationH-37">// 33 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)</front>
<front id="ConfigurationH-38">// 34 = RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)</front>
<front id="ConfigurationH-39">// 35 = RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)</front>
<front id="ConfigurationH-40">// 4  = Duemilanove w/ ATMega328P pin assignment</front>
<front id="ConfigurationH-41">// 5  = Gen6</front>
<front id="ConfigurationH-42">// 51 = Gen6 deluxe</front>
<front id="ConfigurationH-43">// 6  = Sanguinololu &lt; 1.2</front>
<front id="ConfigurationH-44">// 62 = Sanguinololu 1.2 and above</front>
<front id="ConfigurationH-45">// 63 = Melzi</front>
<front id="ConfigurationH-46">// 64 = STB V1.1</front>
<front id="ConfigurationH-47">// 65 = Azteeg X1</front>
<front id="ConfigurationH-48">// 66 = Melzi with ATmega1284 (MaKr3d version)</front>
<front id="ConfigurationH-49">// 67 = Azteeg X3</front>
<front id="ConfigurationH-50">// 7  = Ultimaker</front>
<front id="ConfigurationH-51">// 71 = Ultimaker (Older electronics. Pre 1.5.4. This is rare)</front>
<front id="ConfigurationH-52">// 77 = 3Drag Controller</front>
<front id="ConfigurationH-53">// 8  = Teensylu</front>
<front id="ConfigurationH-54">// 80 = Rumba</front>
<front id="ConfigurationH-55">// 81 = Printrboard (AT90USB1286)</front>
<front id="ConfigurationH-56">// 82 = Brainwave (AT90USB646)</front>
<front id="ConfigurationH-57">// 9  = Gen3+</front>
<front id="ConfigurationH-58">// 70 = Megatronics</front>
<front id="ConfigurationH-59">// 701= Megatronics v2.0</front>
<front id="ConfigurationH-60">// 702= Minitronics v1.0</front>
<front id="ConfigurationH-61">// 90 = Alpha OMCA board</front>
<front id="ConfigurationH-62">// 91 = Final OMCA board</front>
<front id="ConfigurationH-63">// 301 = Rambo</front>
<front id="ConfigurationH-64">// 21 = Elefu Ra Board (v3)</front>
<front id="ConfigurationH-65"></front>
<front id="ConfigurationH-66">#ifndef MOTHERBOARD</front>
<front id="ConfigurationH-67">#define MOTHERBOARD 7</front>
<front id="ConfigurationH-68">#endif</front>
<front id="ConfigurationH-69"></front>
<front id="ConfigurationH-70">// Define this to set a custom name for your generic Mendel,</front>
<front id="ConfigurationH-71">// #define CUSTOM_MENDEL_NAME "This Mendel"</front>
<front id="ConfigurationH-72"></front>
<front id="ConfigurationH-73">// This defines the number of extruders</front>
<front id="ConfigurationH-74">#define EXTRUDERS 1</front>
<front id="ConfigurationH-75"></front>
<front id="ConfigurationH-76">//// The following define selects which power supply you have. Please choose the one that matches your setup</front>
<front id="ConfigurationH-77">// 1 = ATX</front>
<front id="ConfigurationH-78">// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)</front>
<front id="ConfigurationH-79"></front>
<front id="ConfigurationH-80">#define POWER_SUPPLY 1</front>
<front id="ConfigurationH-81"></front>
<front id="ConfigurationH-82">//===========================================================================</front>
<front id="ConfigurationH-83">//=============================Thermal Settings  ============================</front>
<front id="ConfigurationH-84">//===========================================================================</front>
<front id="ConfigurationH-85">//</front>
<front id="ConfigurationH-86">//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table</front>
<front id="ConfigurationH-87">//</front>
<front id="ConfigurationH-88">//// Temperature sensor settings:</front>
<front id="ConfigurationH-89">// -2 is thermocouple with MAX6675 (only for sensor 0)</front>
<front id="ConfigurationH-90">// -1 is thermocouple with AD595</front>
<front id="ConfigurationH-91">// 0 is not used</front>
<front id="ConfigurationH-92">// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)</front>
<front id="ConfigurationH-93">// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)</front>
<front id="ConfigurationH-94">// 3 is mendel-parts thermistor (4.7k pullup)</front>
<front id="ConfigurationH-95">// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!</front>
<front id="ConfigurationH-96">// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan) (4.7k pullup)</front>
<front id="ConfigurationH-97">// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)</front>
<front id="ConfigurationH-98">// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)</front>
<front id="ConfigurationH-99">// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)</front>
<front id="ConfigurationH-100">// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)</front>
<front id="ConfigurationH-101">// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)</front>
<front id="ConfigurationH-102">// 10 is 100k RS thermistor 198-961 (4.7k pullup)</front>
<front id="ConfigurationH-103">// 60 is 100k Maker's Tool Works Kapton Bed Thermister</front>
<front id="ConfigurationH-104">//</front>
<front id="ConfigurationH-105">//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k</front>
<front id="ConfigurationH-106">//                          (but gives greater accuracy and more stable PID)</front>
<front id="ConfigurationH-107">// 51 is 100k thermistor - EPCOS (1k pullup)</front>
<front id="ConfigurationH-108">// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)</front>
<front id="ConfigurationH-109">// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan) (1k pullup)</front>
<front id="ConfigurationH-110"></front>
<front id="ConfigurationH-111">#define TEMP_SENSOR_0 -1</front>
<front id="ConfigurationH-112">#define TEMP_SENSOR_1 -1</front>
<front id="ConfigurationH-113">#define TEMP_SENSOR_2 0</front>
<front id="ConfigurationH-114">#define TEMP_SENSOR_BED 0</front>
<front id="ConfigurationH-115"></front>
<front id="ConfigurationH-116">// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.</front>
<front id="ConfigurationH-117">//#define TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="ConfigurationH-118">#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10</front>
<front id="ConfigurationH-119"></front>
<front id="ConfigurationH-120">// Actual temperature must be close to target for this long before M109 returns success</front>
<front id="ConfigurationH-121">#define TEMP_RESIDENCY_TIME 10  // (seconds)</front>
<front id="ConfigurationH-122">#define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one</front>
<front id="ConfigurationH-123">#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.</front>
<front id="ConfigurationH-124"></front>
<front id="ConfigurationH-125">// The minimal temperature defines the temperature below which the heater will not be enabled It is used</front>
<front id="ConfigurationH-126">// to check that the wiring to the thermistor is not broken.</front>
<front id="ConfigurationH-127">// Otherwise this would lead to the heater being powered on all the time.</front>
<front id="ConfigurationH-128">#define HEATER_0_MINTEMP 5</front>
<front id="ConfigurationH-129">#define HEATER_1_MINTEMP 5</front>
<front id="ConfigurationH-130">#define HEATER_2_MINTEMP 5</front>
<front id="ConfigurationH-131">#define BED_MINTEMP 5</front>
<front id="ConfigurationH-132"></front>
<front id="ConfigurationH-133">// When temperature exceeds max temp, your heater will be switched off.</front>
<front id="ConfigurationH-134">// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!</front>
<front id="ConfigurationH-135">// You should use MINTEMP for thermistor short/failure protection.</front>
<front id="ConfigurationH-136">#define HEATER_0_MAXTEMP 275</front>
<front id="ConfigurationH-137">#define HEATER_1_MAXTEMP 275</front>
<front id="ConfigurationH-138">#define HEATER_2_MAXTEMP 275</front>
<front id="ConfigurationH-139">#define BED_MAXTEMP 150</front>
<front id="ConfigurationH-140"></front>
<front id="ConfigurationH-141">// If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the</front>
<front id="ConfigurationH-142">// average current. The value should be an integer and the heat bed will be turned on for 1 interval of</front>
<front id="ConfigurationH-143">// HEATER_BED_DUTY_CYCLE_DIVIDER intervals.</front>
<front id="ConfigurationH-144">//#define HEATER_BED_DUTY_CYCLE_DIVIDER 4</front>
<front id="ConfigurationH-145"></front>
<front id="ConfigurationH-146">// PID settings:</front>
<front id="ConfigurationH-147">// Comment the following line to disable PID and enable bang-bang.</front>
<front id="ConfigurationH-148">#define PIDTEMP</front>
<front id="ConfigurationH-149">#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current</front>
<front id="ConfigurationH-150">#define PID_MAX 255 // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current</front>
<front id="ConfigurationH-151">#ifdef PIDTEMP</front>
<front id="ConfigurationH-152">  //#define PID_DEBUG // Sends debug data to the serial port.</front>
<front id="ConfigurationH-153">  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX</front>
<front id="ConfigurationH-154">  #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature</front>
<front id="ConfigurationH-155">                                  // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.</front>
<front id="ConfigurationH-156">  #define PID_INTEGRAL_DRIVE_MAX 255  //limit for the integral term</front>
<front id="ConfigurationH-157">  #define K1 0.95 //smoothing factor within the PID</front>
<front id="ConfigurationH-158">  #define PID_dT ((16.0 * 8.0)/(F_CPU / 64.0 / 256.0)) //sampling period of the temperature routine</front>
<front id="ConfigurationH-159"></front>
<front id="ConfigurationH-160">// If you are using a preconfigured hotend then you can use one of the value sets by uncommenting it</front>
<front id="ConfigurationH-161">// Ultimaker</front>
<front id="ConfigurationH-162">    #define  DEFAULT_Kp 22.2</front>
<front id="ConfigurationH-163">    #define  DEFAULT_Ki 1.08</front>
<front id="ConfigurationH-164">    #define  DEFAULT_Kd 114</front>
<front id="ConfigurationH-165"></front>
<front id="ConfigurationH-166">// Makergear</front>
<front id="ConfigurationH-167">//    #define  DEFAULT_Kp 7.0</front>
<front id="ConfigurationH-168">//    #define  DEFAULT_Ki 0.1</front>
<front id="ConfigurationH-169">//    #define  DEFAULT_Kd 12</front>
<front id="ConfigurationH-170"></front>
<front id="ConfigurationH-171">// Mendel Parts V9 on 12V</front>
<front id="ConfigurationH-172">//    #define  DEFAULT_Kp 63.0</front>
<front id="ConfigurationH-173">//    #define  DEFAULT_Ki 2.25</front>
<front id="ConfigurationH-174">//    #define  DEFAULT_Kd 440</front>
<front id="ConfigurationH-175">#endif // PIDTEMP</front>
<front id="ConfigurationH-176"></front>
<front id="ConfigurationH-177">// Bed Temperature Control</front>
<front id="ConfigurationH-178">// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis</front>
<front id="ConfigurationH-179">//</front>
<front id="ConfigurationH-180">// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.</front>
<front id="ConfigurationH-181">// If your PID_dT above is the default, and correct for your hardware/configuration, that means 7.689Hz,</front>
<front id="ConfigurationH-182">// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.</front>
<front id="ConfigurationH-183">// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.</front>
<front id="ConfigurationH-184">// If your configuration is significantly different than this and you don't understand the issues involved, you probably</front>
<front id="ConfigurationH-185">// shouldn't use bed PID until someone else verifies your hardware works.</front>
<front id="ConfigurationH-186">// If this is enabled, find your own PID constants below.</front>
<front id="ConfigurationH-187">//#define PIDTEMPBED</front>
<front id="ConfigurationH-188">//</front>
<front id="ConfigurationH-189">//#define BED_LIMIT_SWITCHING</front>
<front id="ConfigurationH-190"></front>
<front id="ConfigurationH-191">// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.</front>
<front id="ConfigurationH-192">// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)</front>
<front id="ConfigurationH-193">// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,</front>
<front id="ConfigurationH-194">// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)</front>
<front id="ConfigurationH-195">#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current</front>
<front id="ConfigurationH-196"></front>
<front id="ConfigurationH-197">#ifdef PIDTEMPBED</front>
<front id="ConfigurationH-198">//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)</front>
<front id="ConfigurationH-199">//from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)</front>
<front id="ConfigurationH-200">    #define  DEFAULT_bedKp 10.00</front>
<front id="ConfigurationH-201">    #define  DEFAULT_bedKi .023</front>
<front id="ConfigurationH-202">    #define  DEFAULT_bedKd 305.4</front>
<front id="ConfigurationH-203"></front>
<front id="ConfigurationH-204">//120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)</front>
<front id="ConfigurationH-205">//from pidautotune</front>
<front id="ConfigurationH-206">//    #define  DEFAULT_bedKp 97.1</front>
<front id="ConfigurationH-207">//    #define  DEFAULT_bedKi 1.41</front>
<front id="ConfigurationH-208">//    #define  DEFAULT_bedKd 1675.16</front>
<front id="ConfigurationH-209"></front>
<front id="ConfigurationH-210">// FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.</front>
<front id="ConfigurationH-211">#endif // PIDTEMPBED</front>
<front id="ConfigurationH-212"></front>
<front id="ConfigurationH-213"></front>
<front id="ConfigurationH-214"></front>
<front id="ConfigurationH-215">//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit</front>
<front id="ConfigurationH-216">//can be software-disabled for whatever purposes by</front>
<front id="ConfigurationH-217">#define PREVENT_DANGEROUS_EXTRUDE</front>
<front id="ConfigurationH-218">//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.</front>
<front id="ConfigurationH-219">#define PREVENT_LENGTHY_EXTRUDE</front>
<front id="ConfigurationH-220"></front>
<front id="ConfigurationH-221">#define EXTRUDE_MINTEMP 170</front>
<front id="ConfigurationH-222">#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.</front>
<front id="ConfigurationH-223"></front>
<front id="ConfigurationH-224">//===========================================================================</front>
<front id="ConfigurationH-225">//=============================Mechanical Settings===========================</front>
<front id="ConfigurationH-226">//===========================================================================</front>
<front id="ConfigurationH-227"></front>
<front id="ConfigurationH-228">// Uncomment the following line to enable CoreXY kinematics</front>
<front id="ConfigurationH-229">// #define COREXY</front>
<front id="ConfigurationH-230"></front>
<front id="ConfigurationH-231">// coarse Endstop Settings</front>
<front id="ConfigurationH-232">#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors</front>
<front id="ConfigurationH-233"></front>
<front id="ConfigurationH-234">#ifndef ENDSTOPPULLUPS</front>
<front id="ConfigurationH-235">  // fine Enstop settings: Individual Pullups. will be ignored if ENDSTOPPULLUPS is defined</front>
<front id="ConfigurationH-236">  // #define ENDSTOPPULLUP_XMAX</front>
<front id="ConfigurationH-237">  // #define ENDSTOPPULLUP_YMAX</front>
<front id="ConfigurationH-238">  // #define ENDSTOPPULLUP_ZMAX</front>
<front id="ConfigurationH-239">  // #define ENDSTOPPULLUP_XMIN</front>
<front id="ConfigurationH-240">  // #define ENDSTOPPULLUP_YMIN</front>
<front id="ConfigurationH-241">  // #define ENDSTOPPULLUP_ZMIN</front>
<front id="ConfigurationH-242">#endif</front>
<front id="ConfigurationH-243"></front>
<front id="ConfigurationH-244">#ifdef ENDSTOPPULLUPS</front>
<front id="ConfigurationH-245">  #define ENDSTOPPULLUP_XMAX</front>
<front id="ConfigurationH-246">  #define ENDSTOPPULLUP_YMAX</front>
<front id="ConfigurationH-247">  #define ENDSTOPPULLUP_ZMAX</front>
<front id="ConfigurationH-248">  #define ENDSTOPPULLUP_XMIN</front>
<front id="ConfigurationH-249">  #define ENDSTOPPULLUP_YMIN</front>
<front id="ConfigurationH-250">  #define ENDSTOPPULLUP_ZMIN</front>
<front id="ConfigurationH-251">#endif</front>
<front id="ConfigurationH-252"></front>
<front id="ConfigurationH-253">// The pullups are needed if you directly connect a mechanical endswitch between the signal and ground pins.</front>
<front id="ConfigurationH-254">const bool X_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-255">const bool Y_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-256">const bool Z_MIN_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-257">const bool X_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-258">const bool Y_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-259">const bool Z_MAX_ENDSTOP_INVERTING = true; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-260">//#define DISABLE_MAX_ENDSTOPS</front>
<front id="ConfigurationH-261">//#define DISABLE_MIN_ENDSTOPS</front>
<front id="ConfigurationH-262"></front>
<front id="ConfigurationH-263">// Disable max endstops for compatibility with endstop checking routine</front>
<front id="ConfigurationH-264">#if defined(COREXY) && !defined(DISABLE_MAX_ENDSTOPS)</front>
<front id="ConfigurationH-265">  #define DISABLE_MAX_ENDSTOPS</front>
<front id="ConfigurationH-266">#endif</front>
<front id="ConfigurationH-267"></front>
<front id="ConfigurationH-268">// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1</front>
<front id="ConfigurationH-269">#define X_ENABLE_ON 0</front>
<front id="ConfigurationH-270">#define Y_ENABLE_ON 0</front>
<front id="ConfigurationH-271">#define Z_ENABLE_ON 0</front>
<front id="ConfigurationH-272">#define E_ENABLE_ON 0 // For all extruders</front>
<front id="ConfigurationH-273"></front>
<front id="ConfigurationH-274">// Disables axis when it's not being used.</front>
<front id="ConfigurationH-275">#define DISABLE_X false</front>
<front id="ConfigurationH-276">#define DISABLE_Y false</front>
<front id="ConfigurationH-277">#define DISABLE_Z false</front>
<front id="ConfigurationH-278">#define DISABLE_E false // For all extruders</front>
<front id="ConfigurationH-279"></front>
<front id="ConfigurationH-280">#define INVERT_X_DIR true    // for Mendel set to false, for Orca set to true</front>
<front id="ConfigurationH-281">#define INVERT_Y_DIR false    // for Mendel set to true, for Orca set to false</front>
<front id="ConfigurationH-282">#define INVERT_Z_DIR true     // for Mendel set to false, for Orca set to true</front>
<front id="ConfigurationH-283">#define INVERT_E0_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false</front>
<front id="ConfigurationH-284">#define INVERT_E1_DIR false    // for direct drive extruder v9 set to true, for geared extruder set to false</front>
<front id="ConfigurationH-285">#define INVERT_E2_DIR false   // for direct drive extruder v9 set to true, for geared extruder set to false</front>
<front id="ConfigurationH-286"></front>
<front id="ConfigurationH-287">// ENDSTOP SETTINGS:</front>
<front id="ConfigurationH-288">// Sets direction of endstops when homing; 1=MAX, -1=MIN</front>
<front id="ConfigurationH-289">#define X_HOME_DIR -1</front>
<front id="ConfigurationH-290">#define Y_HOME_DIR -1</front>
<front id="ConfigurationH-291">#define Z_HOME_DIR -1</front>
<front id="ConfigurationH-292"></front>
<front id="ConfigurationH-293">#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.</front>
<front id="ConfigurationH-294">#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.</front>
<front id="ConfigurationH-295"></front>
<front id="ConfigurationH-296">//============================= Bed Auto Leveling ===========================</front>
<front id="ConfigurationH-297"></front>
<front id="ConfigurationH-298">//#define ENABLE_AUTO_BED_LEVELING // Delete the comment to enable (remove // at the start of the line)</front>
<front id="ConfigurationH-299"></front>
<front id="ConfigurationH-300">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="ConfigurationH-301"></front>
<front id="ConfigurationH-302">  // these are the positions on the bed to do the probing</front>
<front id="ConfigurationH-303">  #define LEFT_PROBE_BED_POSITION 15</front>
<front id="ConfigurationH-304">  #define RIGHT_PROBE_BED_POSITION 170</front>
<front id="ConfigurationH-305">  #define BACK_PROBE_BED_POSITION 180</front>
<front id="ConfigurationH-306">  #define FRONT_PROBE_BED_POSITION 20</front>
<front id="ConfigurationH-307"></front>
<front id="ConfigurationH-308">  // these are the offsets to the prob relative to the extruder tip (Hotend - Probe)</front>
<front id="ConfigurationH-309">  #define X_PROBE_OFFSET_FROM_EXTRUDER -25</front>
<front id="ConfigurationH-310">  #define Y_PROBE_OFFSET_FROM_EXTRUDER -29</front>
<front id="ConfigurationH-311">  #define Z_PROBE_OFFSET_FROM_EXTRUDER -12.35</front>
<front id="ConfigurationH-312">  </front>
<front id="ConfigurationH-313">  #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min</front>
<front id="ConfigurationH-314">  </front>
<front id="ConfigurationH-315">  #define Z_RAISE_BEFORE_PROBING 15    //How much the extruder will be raised before traveling to the first probing point.</front>
<front id="ConfigurationH-316">  #define Z_RAISE_BETWEEN_PROBINGS 5  //How much the extruder will be raised when traveling from between next probing points</front>
<front id="ConfigurationH-317"></front>
<front id="ConfigurationH-318"></front>
<front id="ConfigurationH-319">  //If defined, the Probe servo will be turned on only during movement and then turned off to avoid jerk</front>
<front id="ConfigurationH-320">  //The value is the delay to turn the servo off after powered on - depends on the servo speed; 300ms is good value, but you can try lower it.</front>
<front id="ConfigurationH-321">  // You MUST HAVE the SERVO_ENDSTOPS defined to use here a value higher than zero otherwise your code will not compile.</front>
<front id="ConfigurationH-322"></front>
<front id="ConfigurationH-323">//  #define PROBE_SERVO_DEACTIVATION_DELAY 300  </front>
<front id="ConfigurationH-324">  </front>
<front id="ConfigurationH-325">#endif</front>
<front id="ConfigurationH-326"></front>
<front id="ConfigurationH-327">// Travel limits after homing</front>
<front id="ConfigurationH-328">#define X_MAX_POS 205</front>
<front id="ConfigurationH-329">#define X_MIN_POS 0</front>
<front id="ConfigurationH-330">#define Y_MAX_POS 205</front>
<front id="ConfigurationH-331">#define Y_MIN_POS 0</front>
<front id="ConfigurationH-332">#define Z_MAX_POS 200</front>
<front id="ConfigurationH-333"></front>
<front id="ConfigurationH-334">#ifndef ENABLE_AUTO_BED_LEVELING</front>
<front id="ConfigurationH-335">#define Z_MIN_POS 0</front>
<front id="ConfigurationH-336">#else</front>
<front id="ConfigurationH-337">#define Z_MIN_POS (-1*Z_PROBE_OFFSET_FROM_EXTRUDER)  //With Auto Bed Leveling, the Z_MIN MUST have the same distance as Z_PROBE</front>
<front id="ConfigurationH-338">#endif</front>
<front id="ConfigurationH-339"></front>
<front id="ConfigurationH-340">#define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)</front>
<front id="ConfigurationH-341">#define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)</front>
<front id="ConfigurationH-342">#define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)</front>
<front id="ConfigurationH-343"></front>
<front id="ConfigurationH-344">// The position of the homing switches</front>
<front id="ConfigurationH-345">//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used</front>
<front id="ConfigurationH-346">//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)</front>
<front id="ConfigurationH-347"></front>
<front id="ConfigurationH-348">//Manual homing switch locations:</front>
<front id="ConfigurationH-349">// For deltabots this means top and center of the cartesian print volume.</front>
<front id="ConfigurationH-350">#define MANUAL_X_HOME_POS 0</front>
<front id="ConfigurationH-351">#define MANUAL_Y_HOME_POS 0</front>
<front id="ConfigurationH-352">#define MANUAL_Z_HOME_POS 0</front>
<front id="ConfigurationH-353">//#define MANUAL_Z_HOME_POS 402 // For delta: Distance between nozzle and print surface after homing.</front>
<front id="ConfigurationH-354"></front>
<front id="ConfigurationH-355">//// MOVEMENT SETTINGS</front>
<front id="ConfigurationH-356">#define NUM_AXIS 4 // The axis order in all axis related arrays is X, Y, Z, E</front>
<front id="ConfigurationH-357">#define HOMING_FEEDRATE {50*60, 50*60, 4*60, 0}  // set the homing speeds (mm/min)</front>
<front id="ConfigurationH-358"></front>
<front id="ConfigurationH-359">// default settings</front>
<front id="ConfigurationH-360"></front>
<front id="ConfigurationH-361">#define DEFAULT_AXIS_STEPS_PER_UNIT   {78.7402,78.7402,200.0*8/3,760*1.1}  // default steps per unit for Ultimaker</front>
<front id="ConfigurationH-362">#define DEFAULT_MAX_FEEDRATE          {500, 500, 5, 25}    // (mm/sec)</front>
<front id="ConfigurationH-363">#define DEFAULT_MAX_ACCELERATION      {9000,9000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for skeinforge 40+, for older versions raise them a lot.</front>
<front id="ConfigurationH-364"></front>
<front id="ConfigurationH-365">#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E max acceleration in mm/s^2 for printing moves</front>
<front id="ConfigurationH-366">#define DEFAULT_RETRACT_ACCELERATION  3000   // X, Y, Z and E max acceleration in mm/s^2 for retracts</front>
<front id="ConfigurationH-367"></front>
<front id="ConfigurationH-368">// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).</front>
<front id="ConfigurationH-369">// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).</front>
<front id="ConfigurationH-370">// For the other hotends it is their distance from the extruder 0 hotend.</front>
<front id="ConfigurationH-371">// #define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis</front>
<front id="ConfigurationH-372">// #define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis</front>
<front id="ConfigurationH-373"></front>
<front id="ConfigurationH-374">// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)</front>
<front id="ConfigurationH-375">#define DEFAULT_XYJERK                20.0    // (mm/sec)</front>
<front id="ConfigurationH-376">#define DEFAULT_ZJERK                 0.4     // (mm/sec)</front>
<front id="ConfigurationH-377">#define DEFAULT_EJERK                 5.0    // (mm/sec)</front>
<front id="ConfigurationH-378"></front>
<front id="ConfigurationH-379">//===========================================================================</front>
<front id="ConfigurationH-380">//=============================Additional Features===========================</front>
<front id="ConfigurationH-381">//===========================================================================</front>
<front id="ConfigurationH-382"></front>
<front id="ConfigurationH-383">// EEPROM</front>
<front id="ConfigurationH-384">// the microcontroller can store settings in the EEPROM, e.g. max velocity...</front>
<front id="ConfigurationH-385">// M500 - stores paramters in EEPROM</front>
<front id="ConfigurationH-386">// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).</front>
<front id="ConfigurationH-387">// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.</front>
<front id="ConfigurationH-388">//define this to enable eeprom support</front>
<front id="ConfigurationH-389">//#define EEPROM_SETTINGS</front>
<front id="ConfigurationH-390">//to disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:</front>
<front id="ConfigurationH-391">// please keep turned on if you can.</front>
<front id="ConfigurationH-392">//#define EEPROM_CHITCHAT</front>
<front id="ConfigurationH-393"></front>
<front id="ConfigurationH-394">// Preheat Constants</front>
<front id="ConfigurationH-395">#define PLA_PREHEAT_HOTEND_TEMP 180</front>
<front id="ConfigurationH-396">#define PLA_PREHEAT_HPB_TEMP 70</front>
<front id="ConfigurationH-397">#define PLA_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255</front>
<front id="ConfigurationH-398"></front>
<front id="ConfigurationH-399">#define ABS_PREHEAT_HOTEND_TEMP 240</front>
<front id="ConfigurationH-400">#define ABS_PREHEAT_HPB_TEMP 100</front>
<front id="ConfigurationH-401">#define ABS_PREHEAT_FAN_SPEED 255   // Insert Value between 0 and 255</front>
<front id="ConfigurationH-402"></front>
<front id="ConfigurationH-403">//LCD and SD support</front>
<front id="ConfigurationH-404">//#define ULTRA_LCD  //general lcd support, also 16x2</front>
<front id="ConfigurationH-405">//#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)</front>
<front id="ConfigurationH-406">//#define SDSUPPORT // Enable SD Card Support in Hardware Console</front>
<front id="ConfigurationH-407">//#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)</front>
<front id="ConfigurationH-408">//#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder</front>
<front id="ConfigurationH-409">//#define ULTIMAKERCONTROLLER //as available from the ultimaker online store.</front>
<front id="ConfigurationH-410">//#define ULTIPANEL  //the ultipanel as on thingiverse</front>
<front id="ConfigurationH-411"></front>
<front id="ConfigurationH-412">// The MaKr3d Makr-Panel with graphic controller and SD support</front>
<front id="ConfigurationH-413">// http://reprap.org/wiki/MaKr3d_MaKrPanel</front>
<front id="ConfigurationH-414">//#define MAKRPANEL</front>
<front id="ConfigurationH-415"></front>
<front id="ConfigurationH-416">// The RepRapDiscount Smart Controller (white PCB)</front>
<front id="ConfigurationH-417">// http://reprap.org/wiki/RepRapDiscount_Smart_Controller</front>
<front id="ConfigurationH-418">//#define REPRAP_DISCOUNT_SMART_CONTROLLER</front>
<front id="ConfigurationH-419"></front>
<front id="ConfigurationH-420">// The GADGETS3D G3D LCD/SD Controller (blue PCB)</front>
<front id="ConfigurationH-421">// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel</front>
<front id="ConfigurationH-422">//#define G3D_PANEL</front>
<front id="ConfigurationH-423"></front>
<front id="ConfigurationH-424">// The RepRapDiscount FULL GRAPHIC Smart Controller (quadratic white PCB)</front>
<front id="ConfigurationH-425">// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller</front>
<front id="ConfigurationH-426">//</front>
<front id="ConfigurationH-427">// ==&gt; REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib</front>
<front id="ConfigurationH-428">//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER</front>
<front id="ConfigurationH-429"></front>
<front id="ConfigurationH-430">// The RepRapWorld REPRAPWORLD_KEYPAD v1.1</front>
<front id="ConfigurationH-431">// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626</front>
<front id="ConfigurationH-432">//#define REPRAPWORLD_KEYPAD</front>
<front id="ConfigurationH-433">//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0 // how much should be moved when a key is pressed, eg 10.0 means 10mm per click</front>
<front id="ConfigurationH-434"></front>
<front id="ConfigurationH-435">// The Elefu RA Board Control Panel</front>
<front id="ConfigurationH-436">// http://www.elefu.com/index.php?route=product/product&product_id=53</front>
<front id="ConfigurationH-437">// REMEMBER TO INSTALL LiquidCrystal_I2C.h in your ARUDINO library folder: https://github.com/kiyoshigawa/LiquidCrystal_I2C</front>
<front id="ConfigurationH-438">//#define RA_CONTROL_PANEL</front>
<front id="ConfigurationH-439"></front>
<front id="ConfigurationH-440">//automatic expansion</front>
<front id="ConfigurationH-441">#if defined (MAKRPANEL)</front>
<front id="ConfigurationH-442"> #define DOGLCD</front>
<front id="ConfigurationH-443"> #define SDSUPPORT</front>
<front id="ConfigurationH-444"> #define ULTIPANEL</front>
<front id="ConfigurationH-445"> #define NEWPANEL</front>
<front id="ConfigurationH-446"> #define DEFAULT_LCD_CONTRAST 17</front>
<front id="ConfigurationH-447">#endif</front>
<front id="ConfigurationH-448"></front>
<front id="ConfigurationH-449">#if defined (REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER)</front>
<front id="ConfigurationH-450"> #define DOGLCD</front>
<front id="ConfigurationH-451"> #define U8GLIB_ST7920</front>
<front id="ConfigurationH-452"> #define REPRAP_DISCOUNT_SMART_CONTROLLER</front>
<front id="ConfigurationH-453">#endif</front>
<front id="ConfigurationH-454"></front>
<front id="ConfigurationH-455">#if defined(ULTIMAKERCONTROLLER) || defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)</front>
<front id="ConfigurationH-456"> #define ULTIPANEL</front>
<front id="ConfigurationH-457"> #define NEWPANEL</front>
<front id="ConfigurationH-458">#endif</front>
<front id="ConfigurationH-459"></front>
<front id="ConfigurationH-460">#if defined(REPRAPWORLD_KEYPAD)</front>
<front id="ConfigurationH-461">  #define NEWPANEL</front>
<front id="ConfigurationH-462">  #define ULTIPANEL</front>
<front id="ConfigurationH-463">#endif</front>
<front id="ConfigurationH-464">#if defined(RA_CONTROL_PANEL)</front>
<front id="ConfigurationH-465"> #define ULTIPANEL</front>
<front id="ConfigurationH-466"> #define NEWPANEL</front>
<front id="ConfigurationH-467"> #define LCD_I2C_TYPE_PCA8574</front>
<front id="ConfigurationH-468"> #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander</front>
<front id="ConfigurationH-469">#endif</front>
<front id="ConfigurationH-470"></front>
<front id="ConfigurationH-471">//I2C PANELS</front>
<front id="ConfigurationH-472"></front>
<front id="ConfigurationH-473">//#define LCD_I2C_SAINSMART_YWROBOT</front>
<front id="ConfigurationH-474">#ifdef LCD_I2C_SAINSMART_YWROBOT</front>
<front id="ConfigurationH-475">  // This uses the LiquidCrystal_I2C library ( https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/Home )</front>
<front id="ConfigurationH-476">  // Make sure it is placed in the Arduino libraries directory.</front>
<front id="ConfigurationH-477">  #define LCD_I2C_TYPE_PCF8575</front>
<front id="ConfigurationH-478">  #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander</front>
<front id="ConfigurationH-479">  #define NEWPANEL</front>
<front id="ConfigurationH-480">  #define ULTIPANEL</front>
<front id="ConfigurationH-481">#endif</front>
<front id="ConfigurationH-482"></front>
<front id="ConfigurationH-483">// PANELOLU2 LCD with status LEDs, separate encoder and click inputs</front>
<front id="ConfigurationH-484">//#define LCD_I2C_PANELOLU2</front>
<front id="ConfigurationH-485">#ifdef LCD_I2C_PANELOLU2</front>
<front id="ConfigurationH-486">  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )</front>
<front id="ConfigurationH-487">  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.</front>
<front id="ConfigurationH-488">  // (v1.2.3 no longer requires you to define PANELOLU in the LiquidTWI2.h library header file)</front>
<front id="ConfigurationH-489">  // Note: The PANELOLU2 encoder click input can either be directly connected to a pin</front>
<front id="ConfigurationH-490">  //       (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1).</front>
<front id="ConfigurationH-491">  #define LCD_I2C_TYPE_MCP23017</front>
<front id="ConfigurationH-492">  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander</front>
<front id="ConfigurationH-493">  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD</front>
<front id="ConfigurationH-494">  #define NEWPANEL</front>
<front id="ConfigurationH-495">  #define ULTIPANEL</front>
<front id="ConfigurationH-496">#endif</front>
<front id="ConfigurationH-497"></front>
<front id="ConfigurationH-498">// Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs</front>
<front id="ConfigurationH-499">//#define LCD_I2C_VIKI</front>
<front id="ConfigurationH-500">#ifdef LCD_I2C_VIKI</front>
<front id="ConfigurationH-501">  // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )</front>
<front id="ConfigurationH-502">  // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.</front>
<front id="ConfigurationH-503">  // Note: The pause/stop/resume LCD button pin should be connected to the Arduino</front>
<front id="ConfigurationH-504">  //       BTN_ENC pin (or set BTN_ENC to -1 if not used)</front>
<front id="ConfigurationH-505">  #define LCD_I2C_TYPE_MCP23017</front>
<front id="ConfigurationH-506">  #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander</front>
<front id="ConfigurationH-507">  #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD (requires LiquidTWI2 v1.2.3 or later)</front>
<front id="ConfigurationH-508">  #define NEWPANEL</front>
<front id="ConfigurationH-509">  #define ULTIPANEL</front>
<front id="ConfigurationH-510">#endif</front>
<front id="ConfigurationH-511"></front>
<front id="ConfigurationH-512">#ifdef ULTIPANEL</front>
<front id="ConfigurationH-513">//  #define NEWPANEL  //enable this if you have a click-encoder panel</front>
<front id="ConfigurationH-514">  #define SDSUPPORT</front>
<front id="ConfigurationH-515">  #define ULTRA_LCD</front>
<front id="ConfigurationH-516">  #ifdef DOGLCD // Change number of lines to match the DOG graphic display</front>
<front id="ConfigurationH-517">    #define LCD_WIDTH 20</front>
<front id="ConfigurationH-518">    #define LCD_HEIGHT 5</front>
<front id="ConfigurationH-519">  #else</front>
<front id="ConfigurationH-520">    #define LCD_WIDTH 20</front>
<front id="ConfigurationH-521">    #define LCD_HEIGHT 4</front>
<front id="ConfigurationH-522">  #endif</front>
<front id="ConfigurationH-523">#else //no panel but just lcd</front>
<front id="ConfigurationH-524">  #ifdef ULTRA_LCD</front>
<front id="ConfigurationH-525">  #ifdef DOGLCD // Change number of lines to match the 128x64 graphics display</front>
<front id="ConfigurationH-526">    #define LCD_WIDTH 20</front>
<front id="ConfigurationH-527">    #define LCD_HEIGHT 5</front>
<front id="ConfigurationH-528">  #else</front>
<front id="ConfigurationH-529">    #define LCD_WIDTH 16</front>
<front id="ConfigurationH-530">    #define LCD_HEIGHT 2</front>
<front id="ConfigurationH-531">  #endif</front>
<front id="ConfigurationH-532">  #endif</front>
<front id="ConfigurationH-533">#endif</front>
<front id="ConfigurationH-534"></front>
<front id="ConfigurationH-535">// default LCD contrast for dogm-like LCD displays</front>
<front id="ConfigurationH-536">#ifdef DOGLCD</front>
<front id="ConfigurationH-537"># ifndef DEFAULT_LCD_CONTRAST</front>
<front id="ConfigurationH-538">#  define DEFAULT_LCD_CONTRAST 32</front>
<front id="ConfigurationH-539"># endif</front>
<front id="ConfigurationH-540">#endif</front>
<front id="ConfigurationH-541"></front>
<front id="ConfigurationH-542">// Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino</front>
<front id="ConfigurationH-543">//#define FAST_PWM_FAN</front>
<front id="ConfigurationH-544"></front>
<front id="ConfigurationH-545">// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency</front>
<front id="ConfigurationH-546">// which is not ass annoying as with the hardware PWM. On the other hand, if this frequency</front>
<front id="ConfigurationH-547">// is too low, you should also increment SOFT_PWM_SCALE.</front>
<front id="ConfigurationH-548">//#define FAN_SOFT_PWM</front>
<front id="ConfigurationH-549"></front>
<front id="ConfigurationH-550">// Incrementing this by 1 will double the software PWM frequency,</front>
<front id="ConfigurationH-551">// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.</front>
<front id="ConfigurationH-552">// However, control resolution will be halved for each increment;</front>
<front id="ConfigurationH-553">// at zero value, there are 128 effective control positions.</front>
<front id="ConfigurationH-554">#define SOFT_PWM_SCALE 0</front>
<front id="ConfigurationH-555"></front>
<front id="ConfigurationH-556">// M240  Triggers a camera by emulating a Canon RC-1 Remote</front>
<front id="ConfigurationH-557">// Data from: http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="ConfigurationH-558">// #define PHOTOGRAPH_PIN     23</front>
<front id="ConfigurationH-559"></front>
<front id="ConfigurationH-560">// SF send wrong arc g-codes when using Arc Point as fillet procedure</front>
<front id="ConfigurationH-561">//#define SF_ARC_FIX</front>
<front id="ConfigurationH-562"></front>
<front id="ConfigurationH-563">// Support for the BariCUDA Paste Extruder.</front>
<front id="ConfigurationH-564">//#define BARICUDA</front>
<front id="ConfigurationH-565"></front>
<front id="ConfigurationH-566">/*********************************************************************\</front>
<front id="ConfigurationH-567">* R/C SERVO support</front>
<front id="ConfigurationH-568">* Sponsored by TrinityLabs, Reworked by codexmas</front>
<front id="ConfigurationH-569">**********************************************************************/</front>
<front id="ConfigurationH-570"></front>
<front id="ConfigurationH-571">// Number of servos</front>
<front id="ConfigurationH-572">//</front>
<front id="ConfigurationH-573">// If you select a configuration below, this will receive a default value and does not need to be set manually</front>
<front id="ConfigurationH-574">// set it manually if you have more servos than extruders and wish to manually control some</front>
<front id="ConfigurationH-575">// leaving it undefined or defining as 0 will disable the servo subsystem</front>
<front id="ConfigurationH-576">// If unsure, leave commented / disabled</front>
<front id="ConfigurationH-577">//</front>
<front id="ConfigurationH-578">//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command</front>
<front id="ConfigurationH-579"></front>
<front id="ConfigurationH-580">// Servo Endstops</front>
<front id="ConfigurationH-581">//</front>
<front id="ConfigurationH-582">// This allows for servo actuated endstops, primary usage is for the Z Axis to eliminate calibration or bed height changes.</front>
<front id="ConfigurationH-583">// Use M206 command to correct for switch height offset to actual nozzle height. Store that setting with M500.</front>
<front id="ConfigurationH-584">//</front>
<front id="ConfigurationH-585">//#define SERVO_ENDSTOPS {-1, -1, 0} // Servo index for X, Y, Z. Disable with -1</front>
<front id="ConfigurationH-586">//#define SERVO_ENDSTOP_ANGLES {0,0, 0,0, 70,0} // X,Y,Z Axis Extend and Retract angles</front>
<front id="ConfigurationH-587"></front>
<front id="ConfigurationH-588">#include "Configuration_adv.h"</front>
<front id="ConfigurationH-589">#include "thermistortables.h"</front>
<front id="ConfigurationH-590"></front>
<front id="ConfigurationH-591">#endif //__CONFIGURATION_H</front>
 </pre>
<h1>Configuration_adv.h</h1>
<pre  class="prettyprint linenums"><front id="Configuration_advH-1">#ifndef CONFIGURATION_ADV_H</front>
<front id="Configuration_advH-2">#define CONFIGURATION_ADV_H</front>
<front id="Configuration_advH-3"></front>
<front id="Configuration_advH-4">//===========================================================================</front>
<front id="Configuration_advH-5">//=============================Thermal Settings  ============================</front>
<front id="Configuration_advH-6">//===========================================================================</front>
<front id="Configuration_advH-7"></front>
<front id="Configuration_advH-8">#ifdef BED_LIMIT_SWITCHING</front>
<front id="Configuration_advH-9">  #define BED_HYSTERESIS 2 //only disable heating if T&gt;target+BED_HYSTERESIS and enable heating if T&gt;target-BED_HYSTERESIS</front>
<front id="Configuration_advH-10">#endif</front>
<front id="Configuration_advH-11">#define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control</front>
<front id="Configuration_advH-12"></front>
<front id="Configuration_advH-13">//// Heating sanity check:</front>
<front id="Configuration_advH-14">// This waits for the watchperiod in milliseconds whenever an M104 or M109 increases the target temperature</front>
<front id="Configuration_advH-15">// If the temperature has not increased at the end of that period, the target temperature is set to zero. </front>
<front id="Configuration_advH-16">// It can be reset with another M104/M109. This check is also only triggered if the target temperature and the current temperature</front>
<front id="Configuration_advH-17">//  differ by at least 2x WATCH_TEMP_INCREASE</front>
<front id="Configuration_advH-18">//#define WATCH_TEMP_PERIOD 40000 //40 seconds</front>
<front id="Configuration_advH-19">//#define WATCH_TEMP_INCREASE 10  //Heat up at least 10 degree in 20 seconds</front>
<front id="Configuration_advH-20"></front>
<front id="Configuration_advH-21">#ifdef PIDTEMP</front>
<front id="Configuration_advH-22">  // this adds an experimental additional term to the heatingpower, proportional to the extrusion speed.</front>
<front id="Configuration_advH-23">  // if Kc is choosen well, the additional required power due to increased melting should be compensated.</front>
<front id="Configuration_advH-24">  #define PID_ADD_EXTRUSION_RATE  </front>
<front id="Configuration_advH-25">  #ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="Configuration_advH-26">    #define  DEFAULT_Kc (1) //heatingpower=Kc*(e_speed)</front>
<front id="Configuration_advH-27">  #endif</front>
<front id="Configuration_advH-28">#endif</front>
<front id="Configuration_advH-29"></front>
<front id="Configuration_advH-30"></front>
<front id="Configuration_advH-31">//automatic temperature: The hot end target temperature is calculated by all the buffered lines of gcode.</front>
<front id="Configuration_advH-32">//The maximum buffered steps/sec of the extruder motor are called "se".</front>
<front id="Configuration_advH-33">//You enter the autotemp mode by a M109 S&lt;mintemp&gt; T&lt;maxtemp&gt; F&lt;factor&gt;</front>
<front id="Configuration_advH-34">// the target temperature is set to mintemp+factor*se[steps/sec] and limited by mintemp and maxtemp</front>
<front id="Configuration_advH-35">// you exit the value by any M109 without F*</front>
<front id="Configuration_advH-36">// Also, if the temperature is set to a value &lt;mintemp, it is not changed by autotemp.</front>
<front id="Configuration_advH-37">// on an ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode</front>
<front id="Configuration_advH-38">#define AUTOTEMP</front>
<front id="Configuration_advH-39">#ifdef AUTOTEMP</front>
<front id="Configuration_advH-40">  #define AUTOTEMP_OLDWEIGHT 0.98</front>
<front id="Configuration_advH-41">#endif</front>
<front id="Configuration_advH-42"></front>
<front id="Configuration_advH-43">//  extruder run-out prevention. </front>
<front id="Configuration_advH-44">//if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded</front>
<front id="Configuration_advH-45">//#define EXTRUDER_RUNOUT_PREVENT  </front>
<front id="Configuration_advH-46">#define EXTRUDER_RUNOUT_MINTEMP 190  </front>
<front id="Configuration_advH-47">#define EXTRUDER_RUNOUT_SECONDS 30.</front>
<front id="Configuration_advH-48">#define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament</front>
<front id="Configuration_advH-49">#define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed</front>
<front id="Configuration_advH-50">#define EXTRUDER_RUNOUT_EXTRUDE 100</front>
<front id="Configuration_advH-51"></front>
<front id="Configuration_advH-52">//These defines help to calibrate the AD595 sensor in case you get wrong temperature measurements.</front>
<front id="Configuration_advH-53">//The measured temperature is defined as "actualTemp = (measuredTemp * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET"</front>
<front id="Configuration_advH-54">#define TEMP_SENSOR_AD595_OFFSET 0.0</front>
<front id="Configuration_advH-55">#define TEMP_SENSOR_AD595_GAIN   1.0</front>
<front id="Configuration_advH-56"></front>
<front id="Configuration_advH-57">//This is for controlling a fan to cool down the stepper drivers</front>
<front id="Configuration_advH-58">//it will turn on when any driver is enabled</front>
<front id="Configuration_advH-59">//and turn off after the set amount of seconds from last driver being disabled again</front>
<front id="Configuration_advH-60">#define CONTROLLERFAN_PIN -1 //Pin used for the fan to cool controller (-1 to disable)</front>
<front id="Configuration_advH-61">#define CONTROLLERFAN_SECS 60 //How many seconds, after all motors were disabled, the fan should run</front>
<front id="Configuration_advH-62">#define CONTROLLERFAN_SPEED 255  // == full speed</front>
<front id="Configuration_advH-63"></front>
<front id="Configuration_advH-64">// When first starting the main fan, run it at full speed for the</front>
<front id="Configuration_advH-65">// given number of milliseconds.  This gets the fan spinning reliably</front>
<front id="Configuration_advH-66">// before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)</front>
<front id="Configuration_advH-67">//#define FAN_KICKSTART_TIME 100</front>
<front id="Configuration_advH-68"></front>
<front id="Configuration_advH-69">// Extruder cooling fans</front>
<front id="Configuration_advH-70">// Configure fan pin outputs to automatically turn on/off when the associated</front>
<front id="Configuration_advH-71">// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.</front>
<front id="Configuration_advH-72">// Multiple extruders can be assigned to the same pin in which case </front>
<front id="Configuration_advH-73">// the fan will turn on when any selected extruder is above the threshold.</front>
<front id="Configuration_advH-74">#define EXTRUDER_0_AUTO_FAN_PIN   -1</front>
<front id="Configuration_advH-75">#define EXTRUDER_1_AUTO_FAN_PIN   -1</front>
<front id="Configuration_advH-76">#define EXTRUDER_2_AUTO_FAN_PIN   -1</front>
<front id="Configuration_advH-77">#define EXTRUDER_AUTO_FAN_TEMPERATURE 50</front>
<front id="Configuration_advH-78">#define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed</front>
<front id="Configuration_advH-79"></front>
<front id="Configuration_advH-80"></front>
<front id="Configuration_advH-81">//===========================================================================</front>
<front id="Configuration_advH-82">//=============================Mechanical Settings===========================</front>
<front id="Configuration_advH-83">//===========================================================================</front>
<front id="Configuration_advH-84"></front>
<front id="Configuration_advH-85">#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing</front>
<front id="Configuration_advH-86"></front>
<front id="Configuration_advH-87"></front>
<front id="Configuration_advH-88">//// AUTOSET LOCATIONS OF LIMIT SWITCHES</front>
<front id="Configuration_advH-89">//// Added by ZetaPhoenix 09-15-2012</front>
<front id="Configuration_advH-90">#ifdef MANUAL_HOME_POSITIONS  // Use manual limit switch locations</front>
<front id="Configuration_advH-91">  #define X_HOME_POS MANUAL_X_HOME_POS</front>
<front id="Configuration_advH-92">  #define Y_HOME_POS MANUAL_Y_HOME_POS</front>
<front id="Configuration_advH-93">  #define Z_HOME_POS MANUAL_Z_HOME_POS</front>
<front id="Configuration_advH-94">#else //Set min/max homing switch positions based upon homing direction and min/max travel limits</front>
<front id="Configuration_advH-95">  //X axis</front>
<front id="Configuration_advH-96">  #if X_HOME_DIR == -1</front>
<front id="Configuration_advH-97">    #ifdef BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-98">      #define X_HOME_POS X_MAX_LENGTH * -0.5</front>
<front id="Configuration_advH-99">    #else</front>
<front id="Configuration_advH-100">      #define X_HOME_POS X_MIN_POS</front>
<front id="Configuration_advH-101">    #endif //BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-102">  #else    </front>
<front id="Configuration_advH-103">    #ifdef BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-104">      #define X_HOME_POS X_MAX_LENGTH * 0.5</front>
<front id="Configuration_advH-105">    #else</front>
<front id="Configuration_advH-106">      #define X_HOME_POS X_MAX_POS</front>
<front id="Configuration_advH-107">    #endif //BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-108">  #endif //X_HOME_DIR == -1</front>
<front id="Configuration_advH-109">  </front>
<front id="Configuration_advH-110">  //Y axis</front>
<front id="Configuration_advH-111">  #if Y_HOME_DIR == -1</front>
<front id="Configuration_advH-112">    #ifdef BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-113">      #define Y_HOME_POS Y_MAX_LENGTH * -0.5</front>
<front id="Configuration_advH-114">    #else</front>
<front id="Configuration_advH-115">      #define Y_HOME_POS Y_MIN_POS</front>
<front id="Configuration_advH-116">    #endif //BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-117">  #else    </front>
<front id="Configuration_advH-118">    #ifdef BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-119">      #define Y_HOME_POS Y_MAX_LENGTH * 0.5</front>
<front id="Configuration_advH-120">    #else</front>
<front id="Configuration_advH-121">      #define Y_HOME_POS Y_MAX_POS</front>
<front id="Configuration_advH-122">    #endif //BED_CENTER_AT_0_0</front>
<front id="Configuration_advH-123">  #endif //Y_HOME_DIR == -1</front>
<front id="Configuration_advH-124">  </front>
<front id="Configuration_advH-125">  // Z axis</front>
<front id="Configuration_advH-126">  #if Z_HOME_DIR == -1 //BED_CENTER_AT_0_0 not used</front>
<front id="Configuration_advH-127">    #define Z_HOME_POS Z_MIN_POS</front>
<front id="Configuration_advH-128">  #else    </front>
<front id="Configuration_advH-129">    #define Z_HOME_POS Z_MAX_POS</front>
<front id="Configuration_advH-130">  #endif //Z_HOME_DIR == -1</front>
<front id="Configuration_advH-131">#endif //End auto min/max positions</front>
<front id="Configuration_advH-132">//END AUTOSET LOCATIONS OF LIMIT SWITCHES -ZP</front>
<front id="Configuration_advH-133"></front>
<front id="Configuration_advH-134"></front>
<front id="Configuration_advH-135">//#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.</front>
<front id="Configuration_advH-136"></front>
<front id="Configuration_advH-137">// A single Z stepper driver is usually used to drive 2 stepper motors.</front>
<front id="Configuration_advH-138">// Uncomment this define to utilize a separate stepper driver for each Z axis motor.</front>
<front id="Configuration_advH-139">// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used</front>
<front id="Configuration_advH-140">// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.</front>
<front id="Configuration_advH-141">// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.</front>
<front id="Configuration_advH-142">//#define Z_DUAL_STEPPER_DRIVERS</front>
<front id="Configuration_advH-143"></front>
<front id="Configuration_advH-144">#ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="Configuration_advH-145">  #undef EXTRUDERS</front>
<front id="Configuration_advH-146">  #define EXTRUDERS 1</front>
<front id="Configuration_advH-147">#endif</front>
<front id="Configuration_advH-148"></front>
<front id="Configuration_advH-149">// Enable this for dual x-carriage printers. </front>
<front id="Configuration_advH-150">// A dual x-carriage design has the advantage that the inactive extruder can be parked which</front>
<front id="Configuration_advH-151">// prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage</front>
<front id="Configuration_advH-152">// allowing faster printing speeds.</front>
<front id="Configuration_advH-153">//#define DUAL_X_CARRIAGE</front>
<front id="Configuration_advH-154">#ifdef DUAL_X_CARRIAGE</front>
<front id="Configuration_advH-155">// Configuration for second X-carriage</front>
<front id="Configuration_advH-156">// Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;</front>
<front id="Configuration_advH-157">// the second x-carriage always homes to the maximum endstop.</front>
<front id="Configuration_advH-158">#define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage</front>
<front id="Configuration_advH-159">#define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed </front>
<front id="Configuration_advH-160">#define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position</front>
<front id="Configuration_advH-161">#define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position </front>
<front id="Configuration_advH-162">    // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software </front>
<front id="Configuration_advH-163">    // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops</front>
<front id="Configuration_advH-164">    // without modifying the firmware (through the "M218 T1 X???" command).</front>
<front id="Configuration_advH-165">    // Remember: you should set the second extruder x-offset to 0 in your slicer.</front>
<front id="Configuration_advH-166"></front>
<front id="Configuration_advH-167">// Pins for second x-carriage stepper driver (defined here to avoid further complicating pins.h)</front>
<front id="Configuration_advH-168">#define X2_ENABLE_PIN 29</front>
<front id="Configuration_advH-169">#define X2_STEP_PIN 25</front>
<front id="Configuration_advH-170">#define X2_DIR_PIN 23</front>
<front id="Configuration_advH-171"></front>
<front id="Configuration_advH-172">// There are a few selectable movement modes for dual x-carriages using M605 S&lt;mode&gt;</front>
<front id="Configuration_advH-173">//    Mode 0: Full control. The slicer has full control over both x-carriages and can achieve optimal travel results</front>
<front id="Configuration_advH-174">//                           as long as it supports dual x-carriages. (M605 S0)</front>
<front id="Configuration_advH-175">//    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so</front>
<front id="Configuration_advH-176">//                           that additional slicer support is not required. (M605 S1)</front>
<front id="Configuration_advH-177">//    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all  </front>
<front id="Configuration_advH-178">//                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at</front>
<front id="Configuration_advH-179">//                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])</front>
<front id="Configuration_advH-180"></front>
<front id="Configuration_advH-181">// This is the default power-up mode which can be later using M605. </front>
<front id="Configuration_advH-182">#define DEFAULT_DUAL_X_CARRIAGE_MODE 0 </front>
<front id="Configuration_advH-183"></front>
<front id="Configuration_advH-184">// As the x-carriages are independent we can now account for any relative Z offset</front>
<front id="Configuration_advH-185">#define EXTRUDER1_Z_OFFSET 0.0           // z offset relative to extruder 0</front>
<front id="Configuration_advH-186"></front>
<front id="Configuration_advH-187">// Default settings in "Auto-park Mode" </front>
<front id="Configuration_advH-188">#define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder</front>
<front id="Configuration_advH-189">#define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder</front>
<front id="Configuration_advH-190"></front>
<front id="Configuration_advH-191">// Default x offset in duplication mode (typically set to half print bed width)</front>
<front id="Configuration_advH-192">#define DEFAULT_DUPLICATION_X_OFFSET 100</front>
<front id="Configuration_advH-193"></front>
<front id="Configuration_advH-194">#endif //DUAL_X_CARRIAGE</front>
<front id="Configuration_advH-195">    </front>
<front id="Configuration_advH-196">//homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:</front>
<front id="Configuration_advH-197">#define X_HOME_RETRACT_MM 5 </front>
<front id="Configuration_advH-198">#define Y_HOME_RETRACT_MM 5 </front>
<front id="Configuration_advH-199">#define Z_HOME_RETRACT_MM 1 </front>
<front id="Configuration_advH-200">//#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.</front>
<front id="Configuration_advH-201"></front>
<front id="Configuration_advH-202">#define AXIS_RELATIVE_MODES {false, false, false, false}</front>
<front id="Configuration_advH-203"></front>
<front id="Configuration_advH-204">#define MAX_STEP_FREQUENCY 40000 // Max step frequency for Ultimaker (5000 pps / half step)</front>
<front id="Configuration_advH-205"></front>
<front id="Configuration_advH-206">//By default pololu step drivers require an active high signal. However, some high power drivers require an active low signal as step.</front>
<front id="Configuration_advH-207">#define INVERT_X_STEP_PIN false</front>
<front id="Configuration_advH-208">#define INVERT_Y_STEP_PIN false</front>
<front id="Configuration_advH-209">#define INVERT_Z_STEP_PIN false</front>
<front id="Configuration_advH-210">#define INVERT_E_STEP_PIN false</front>
<front id="Configuration_advH-211"></front>
<front id="Configuration_advH-212">//default stepper release if idle</front>
<front id="Configuration_advH-213">#define DEFAULT_STEPPER_DEACTIVE_TIME 60</front>
<front id="Configuration_advH-214"></front>
<front id="Configuration_advH-215">#define DEFAULT_MINIMUMFEEDRATE       0.0     // minimum feedrate</front>
<front id="Configuration_advH-216">#define DEFAULT_MINTRAVELFEEDRATE     0.0</front>
<front id="Configuration_advH-217"></front>
<front id="Configuration_advH-218">// Feedrates for manual moves along X, Y, Z, E from panel</front>
<front id="Configuration_advH-219">#ifdef ULTIPANEL</front>
<front id="Configuration_advH-220">#define MANUAL_FEEDRATE {50*60, 50*60, 4*60, 60}  // set the speeds for manual moves (mm/min)</front>
<front id="Configuration_advH-221">#endif</front>
<front id="Configuration_advH-222"></front>
<front id="Configuration_advH-223">// minimum time in microseconds that a movement needs to take if the buffer is emptied.</front>
<front id="Configuration_advH-224">#define DEFAULT_MINSEGMENTTIME        20000</front>
<front id="Configuration_advH-225"></front>
<front id="Configuration_advH-226">// If defined the movements slow down when the look ahead buffer is only half full</front>
<front id="Configuration_advH-227">#define SLOWDOWN</front>
<front id="Configuration_advH-228"></front>
<front id="Configuration_advH-229">// Frequency limit</front>
<front id="Configuration_advH-230">// See nophead's blog for more info</front>
<front id="Configuration_advH-231">// Not working O</front>
<front id="Configuration_advH-232">//#define XY_FREQUENCY_LIMIT  15</front>
<front id="Configuration_advH-233"></front>
<front id="Configuration_advH-234">// Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end</front>
<front id="Configuration_advH-235">// of the buffer and all stops. This should not be much greater than zero and should only be changed</front>
<front id="Configuration_advH-236">// if unwanted behavior is observed on a user's machine when running at very slow speeds.</front>
<front id="Configuration_advH-237">#define MINIMUM_PLANNER_SPEED 0.05// (mm/sec)</front>
<front id="Configuration_advH-238"></front>
<front id="Configuration_advH-239">// MS1 MS2 Stepper Driver Microstepping mode table</front>
<front id="Configuration_advH-240">#define MICROSTEP1 LOW,LOW</front>
<front id="Configuration_advH-241">#define MICROSTEP2 HIGH,LOW</front>
<front id="Configuration_advH-242">#define MICROSTEP4 LOW,HIGH</front>
<front id="Configuration_advH-243">#define MICROSTEP8 HIGH,HIGH</front>
<front id="Configuration_advH-244">#define MICROSTEP16 HIGH,HIGH</front>
<front id="Configuration_advH-245"></front>
<front id="Configuration_advH-246">// Microstep setting (Only functional when stepper driver microstep pins are connected to MCU.</front>
<front id="Configuration_advH-247">#define MICROSTEP_MODES {16,16,16,16,16} // [1,2,4,8,16]</front>
<front id="Configuration_advH-248"></front>
<front id="Configuration_advH-249">// Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)</front>
<front id="Configuration_advH-250">#define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)</front>
<front id="Configuration_advH-251"></front>
<front id="Configuration_advH-252"></front>
<front id="Configuration_advH-253">//===========================================================================</front>
<front id="Configuration_advH-254">//=============================Additional Features===========================</front>
<front id="Configuration_advH-255">//===========================================================================</front>
<front id="Configuration_advH-256"></front>
<front id="Configuration_advH-257">#define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?</front>
<front id="Configuration_advH-258">#define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.</front>
<front id="Configuration_advH-259"></front>
<front id="Configuration_advH-260">// The hardware watchdog should reset the Microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.</front>
<front id="Configuration_advH-261">//#define USE_WATCHDOG</front>
<front id="Configuration_advH-262"></front>
<front id="Configuration_advH-263">#ifdef USE_WATCHDOG</front>
<front id="Configuration_advH-264">// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.</front>
<front id="Configuration_advH-265">// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.</front>
<front id="Configuration_advH-266">//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.</front>
<front id="Configuration_advH-267">//#define WATCHDOG_RESET_MANUAL</front>
<front id="Configuration_advH-268">#endif</front>
<front id="Configuration_advH-269"></front>
<front id="Configuration_advH-270">// Enable the option to stop SD printing when hitting and endstops, needs to be enabled from the LCD menu when this option is enabled.</front>
<front id="Configuration_advH-271">//#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="Configuration_advH-272"></front>
<front id="Configuration_advH-273">// Babystepping enables the user to control the axis in tiny amounts, independently from the normal printing process</front>
<front id="Configuration_advH-274">// it can e.g. be used to change z-positions in the print startup phase in realtime</front>
<front id="Configuration_advH-275">// does not respect endstops!</front>
<front id="Configuration_advH-276"></front>
<front id="Configuration_advH-277">//#define BABYSTEPPING</front>
<front id="Configuration_advH-278">//#define BABYSTEP_XY  //not only z, but also XY</front>
<front id="Configuration_advH-279"></front>
<front id="Configuration_advH-280">#ifdef COREXY</front>
<front id="Configuration_advH-281">    #error BABYSTEPPING not implemented for COREXY yet.</front>
<front id="Configuration_advH-282">#endif</front>
<front id="Configuration_advH-283"></front>
<front id="Configuration_advH-284">// extruder advance constant (s2/mm3)</front>
<front id="Configuration_advH-285">//</front>
<front id="Configuration_advH-286">// advance (steps) = STEPS_PER_CUBIC_MM_E * EXTUDER_ADVANCE_K * cubic mm per second ^ 2</front>
<front id="Configuration_advH-287">//</front>
<front id="Configuration_advH-288">// hooke's law says:		force = k * distance</front>
<front id="Configuration_advH-289">// bernoulli's priniciple says:	v ^ 2 / 2 + g . h + pressure / density = constant</front>
<front id="Configuration_advH-290">// so: v ^ 2 is proportional to number of steps we advance the extruder</front>
<front id="Configuration_advH-291">//#define ADVANCE</front>
<front id="Configuration_advH-292"></front>
<front id="Configuration_advH-293">#ifdef ADVANCE</front>
<front id="Configuration_advH-294">  #define EXTRUDER_ADVANCE_K .0</front>
<front id="Configuration_advH-295"></front>
<front id="Configuration_advH-296">  #define D_FILAMENT 2.85</front>
<front id="Configuration_advH-297">  #define STEPS_MM_E 836</front>
<front id="Configuration_advH-298">  #define EXTRUTION_AREA (0.25 * D_FILAMENT * D_FILAMENT * 3.14159)</front>
<front id="Configuration_advH-299">  #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS]/ EXTRUTION_AREA)</front>
<front id="Configuration_advH-300"></front>
<front id="Configuration_advH-301">#endif // ADVANCE</front>
<front id="Configuration_advH-302"></front>
<front id="Configuration_advH-303">// Arc interpretation settings:</front>
<front id="Configuration_advH-304">#define MM_PER_ARC_SEGMENT 1</front>
<front id="Configuration_advH-305">#define N_ARC_CORRECTION 25</front>
<front id="Configuration_advH-306"></front>
<front id="Configuration_advH-307">const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement</front>
<front id="Configuration_advH-308"></front>
<front id="Configuration_advH-309">// If you are using a RAMPS board or cheap E-bay purchased boards that do not detect when an SD card is inserted</front>
<front id="Configuration_advH-310">// You can get round this by connecting a push button or single throw switch to the pin defined as SDCARDCARDDETECT </front>
<front id="Configuration_advH-311">// in the pins.h file.  When using a push button pulling the pin to ground this will need inverted.  This setting should</front>
<front id="Configuration_advH-312">// be commented out otherwise</front>
<front id="Configuration_advH-313">#define SDCARDDETECTINVERTED </front>
<front id="Configuration_advH-314"></front>
<front id="Configuration_advH-315">#ifdef ULTIPANEL</front>
<front id="Configuration_advH-316"> #undef SDCARDDETECTINVERTED</front>
<front id="Configuration_advH-317">#endif</front>
<front id="Configuration_advH-318"></front>
<front id="Configuration_advH-319">// Power Signal Control Definitions</front>
<front id="Configuration_advH-320">// By default use ATX definition</front>
<front id="Configuration_advH-321">#ifndef POWER_SUPPLY</front>
<front id="Configuration_advH-322">  #define POWER_SUPPLY 1</front>
<front id="Configuration_advH-323">#endif</front>
<front id="Configuration_advH-324">// 1 = ATX</front>
<front id="Configuration_advH-325">#if (POWER_SUPPLY == 1) </front>
<front id="Configuration_advH-326">  #define PS_ON_AWAKE  LOW</front>
<front id="Configuration_advH-327">  #define PS_ON_ASLEEP HIGH</front>
<front id="Configuration_advH-328">#endif</front>
<front id="Configuration_advH-329">// 2 = X-Box 360 203W</front>
<front id="Configuration_advH-330">#if (POWER_SUPPLY == 2) </front>
<front id="Configuration_advH-331">  #define PS_ON_AWAKE  HIGH</front>
<front id="Configuration_advH-332">  #define PS_ON_ASLEEP LOW</front>
<front id="Configuration_advH-333">#endif</front>
<front id="Configuration_advH-334"></front>
<front id="Configuration_advH-335">//===========================================================================</front>
<front id="Configuration_advH-336">//=============================Buffers           ============================</front>
<front id="Configuration_advH-337">//===========================================================================</front>
<front id="Configuration_advH-338"></front>
<front id="Configuration_advH-339">// The number of linear motions that can be in the plan at any give time.  </front>
<front id="Configuration_advH-340">// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ringbuffering.</front>
<front id="Configuration_advH-341">#if defined SDSUPPORT</front>
<front id="Configuration_advH-342">  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller</front>
<front id="Configuration_advH-343">#else</front>
<front id="Configuration_advH-344">  #define BLOCK_BUFFER_SIZE 16 // maximize block buffer</front>
<front id="Configuration_advH-345">#endif</front>
<front id="Configuration_advH-346"></front>
<front id="Configuration_advH-347"></front>
<front id="Configuration_advH-348">//The ASCII buffer for recieving from the serial:</front>
<front id="Configuration_advH-349">#define MAX_CMD_SIZE 96</front>
<front id="Configuration_advH-350">#define BUFSIZE 4</front>
<front id="Configuration_advH-351"></front>
<front id="Configuration_advH-352"></front>
<front id="Configuration_advH-353">// Firmware based and LCD controled retract</front>
<front id="Configuration_advH-354">// M207 and M208 can be used to define parameters for the retraction. </front>
<front id="Configuration_advH-355">// The retraction can be called by the slicer using G10 and G11</front>
<front id="Configuration_advH-356">// until then, intended retractions can be detected by moves that only extrude and the direction. </front>
<front id="Configuration_advH-357">// the moves are than replaced by the firmware controlled ones.</front>
<front id="Configuration_advH-358"></front>
<front id="Configuration_advH-359">// #define FWRETRACT  //ONLY PARTIALLY TESTED</front>
<front id="Configuration_advH-360">#define MIN_RETRACT 0.1 //minimum extruded mm to accept a automatic gcode retraction attempt</front>
<front id="Configuration_advH-361"></front>
<front id="Configuration_advH-362"></front>
<front id="Configuration_advH-363">//adds support for experimental filament exchange support M600; requires display</front>
<front id="Configuration_advH-364">#ifdef ULTIPANEL</front>
<front id="Configuration_advH-365">  //#define FILAMENTCHANGEENABLE</front>
<front id="Configuration_advH-366">  #ifdef FILAMENTCHANGEENABLE</front>
<front id="Configuration_advH-367">    #define FILAMENTCHANGE_XPOS 3</front>
<front id="Configuration_advH-368">    #define FILAMENTCHANGE_YPOS 3</front>
<front id="Configuration_advH-369">    #define FILAMENTCHANGE_ZADD 10</front>
<front id="Configuration_advH-370">    #define FILAMENTCHANGE_FIRSTRETRACT -2</front>
<front id="Configuration_advH-371">    #define FILAMENTCHANGE_FINALRETRACT -100</front>
<front id="Configuration_advH-372">  #endif</front>
<front id="Configuration_advH-373">#endif</front>
<front id="Configuration_advH-374"> </front>
<front id="Configuration_advH-375">//===========================================================================</front>
<front id="Configuration_advH-376">//=============================  Define Defines  ============================</front>
<front id="Configuration_advH-377">//===========================================================================</front>
<front id="Configuration_advH-378">#if EXTRUDERS &gt; 1 && defined TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="Configuration_advH-379">  #error "You cannot use TEMP_SENSOR_1_AS_REDUNDANT if EXTRUDERS &gt; 1"</front>
<front id="Configuration_advH-380">#endif</front>
<front id="Configuration_advH-381"></front>
<front id="Configuration_advH-382">#if TEMP_SENSOR_0 &gt; 0</front>
<front id="Configuration_advH-383">  #define THERMISTORHEATER_0 TEMP_SENSOR_0</front>
<front id="Configuration_advH-384">  #define HEATER_0_USES_THERMISTOR</front>
<front id="Configuration_advH-385">#endif</front>
<front id="Configuration_advH-386">#if TEMP_SENSOR_1 &gt; 0</front>
<front id="Configuration_advH-387">  #define THERMISTORHEATER_1 TEMP_SENSOR_1</front>
<front id="Configuration_advH-388">  #define HEATER_1_USES_THERMISTOR</front>
<front id="Configuration_advH-389">#endif</front>
<front id="Configuration_advH-390">#if TEMP_SENSOR_2 &gt; 0</front>
<front id="Configuration_advH-391">  #define THERMISTORHEATER_2 TEMP_SENSOR_2</front>
<front id="Configuration_advH-392">  #define HEATER_2_USES_THERMISTOR</front>
<front id="Configuration_advH-393">#endif</front>
<front id="Configuration_advH-394">#if TEMP_SENSOR_BED &gt; 0</front>
<front id="Configuration_advH-395">  #define THERMISTORBED TEMP_SENSOR_BED</front>
<front id="Configuration_advH-396">  #define BED_USES_THERMISTOR</front>
<front id="Configuration_advH-397">#endif</front>
<front id="Configuration_advH-398">#if TEMP_SENSOR_0 == -1</front>
<front id="Configuration_advH-399">  #define HEATER_0_USES_AD595</front>
<front id="Configuration_advH-400">#endif</front>
<front id="Configuration_advH-401">#if TEMP_SENSOR_1 == -1</front>
<front id="Configuration_advH-402">  #define HEATER_1_USES_AD595</front>
<front id="Configuration_advH-403">#endif</front>
<front id="Configuration_advH-404">#if TEMP_SENSOR_2 == -1</front>
<front id="Configuration_advH-405">  #define HEATER_2_USES_AD595</front>
<front id="Configuration_advH-406">#endif</front>
<front id="Configuration_advH-407">#if TEMP_SENSOR_BED == -1</front>
<front id="Configuration_advH-408">  #define BED_USES_AD595</front>
<front id="Configuration_advH-409">#endif</front>
<front id="Configuration_advH-410">#if TEMP_SENSOR_0 == -2</front>
<front id="Configuration_advH-411">  #define HEATER_0_USES_MAX6675</front>
<front id="Configuration_advH-412">#endif</front>
<front id="Configuration_advH-413">#if TEMP_SENSOR_0 == 0</front>
<front id="Configuration_advH-414">  #undef HEATER_0_MINTEMP</front>
<front id="Configuration_advH-415">  #undef HEATER_0_MAXTEMP</front>
<front id="Configuration_advH-416">#endif</front>
<front id="Configuration_advH-417">#if TEMP_SENSOR_1 == 0</front>
<front id="Configuration_advH-418">  #undef HEATER_1_MINTEMP</front>
<front id="Configuration_advH-419">  #undef HEATER_1_MAXTEMP</front>
<front id="Configuration_advH-420">#endif</front>
<front id="Configuration_advH-421">#if TEMP_SENSOR_2 == 0</front>
<front id="Configuration_advH-422">  #undef HEATER_2_MINTEMP</front>
<front id="Configuration_advH-423">  #undef HEATER_2_MAXTEMP</front>
<front id="Configuration_advH-424">#endif</front>
<front id="Configuration_advH-425">#if TEMP_SENSOR_BED == 0</front>
<front id="Configuration_advH-426">  #undef BED_MINTEMP</front>
<front id="Configuration_advH-427">  #undef BED_MAXTEMP</front>
<front id="Configuration_advH-428">#endif</front>
<front id="Configuration_advH-429"></front>
<front id="Configuration_advH-430"></front>
<front id="Configuration_advH-431">#endif //__CONFIGURATION_ADV_H</front>
 </pre>
<h1>ConfigurationStore.cpp</h1>
<pre  class="prettyprint linenums"><front id="ConfigurationStoreCPP-1">#include "Marlin.h"</front>
<front id="ConfigurationStoreCPP-2">#include "planner.h"</front>
<front id="ConfigurationStoreCPP-3">#include "temperature.h"</front>
<front id="ConfigurationStoreCPP-4">#include "ultralcd.h"</front>
<front id="ConfigurationStoreCPP-5">#include "ConfigurationStore.h"</front>
<front id="ConfigurationStoreCPP-6"></front>
<front id="ConfigurationStoreCPP-7">void _EEPROM_writeData(int &pos, uint8_t* value, uint8_t size)</front>
<front id="ConfigurationStoreCPP-8">{</front>
<front id="ConfigurationStoreCPP-9">    do</front>
<front id="ConfigurationStoreCPP-10">    {</front>
<front id="ConfigurationStoreCPP-11">        eeprom_write_byte((unsigned char*)pos, *value);</front>
<front id="ConfigurationStoreCPP-12">        pos++;</front>
<front id="ConfigurationStoreCPP-13">        value++;</front>
<front id="ConfigurationStoreCPP-14">    }while(--size);</front>
<front id="ConfigurationStoreCPP-15">}</front>
<front id="ConfigurationStoreCPP-16">#define EEPROM_WRITE_VAR(pos, value) _EEPROM_writeData(pos, (uint8_t*)&value, sizeof(value))</front>
<front id="ConfigurationStoreCPP-17">void _EEPROM_readData(int &pos, uint8_t* value, uint8_t size)</front>
<front id="ConfigurationStoreCPP-18">{</front>
<front id="ConfigurationStoreCPP-19">    do</front>
<front id="ConfigurationStoreCPP-20">    {</front>
<front id="ConfigurationStoreCPP-21">        *value = eeprom_read_byte((unsigned char*)pos);</front>
<front id="ConfigurationStoreCPP-22">        pos++;</front>
<front id="ConfigurationStoreCPP-23">        value++;</front>
<front id="ConfigurationStoreCPP-24">    }while(--size);</front>
<front id="ConfigurationStoreCPP-25">}</front>
<front id="ConfigurationStoreCPP-26">#define EEPROM_READ_VAR(pos, value) _EEPROM_readData(pos, (uint8_t*)&value, sizeof(value))</front>
<front id="ConfigurationStoreCPP-27">//======================================================================================</front>
<front id="ConfigurationStoreCPP-28"></front>
<front id="ConfigurationStoreCPP-29"></front>
<front id="ConfigurationStoreCPP-30"></front>
<front id="ConfigurationStoreCPP-31"></front>
<front id="ConfigurationStoreCPP-32">#define EEPROM_OFFSET 100</front>
<front id="ConfigurationStoreCPP-33"></front>
<front id="ConfigurationStoreCPP-34"></front>
<front id="ConfigurationStoreCPP-35">// IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM</front>
<front id="ConfigurationStoreCPP-36">// in the functions below, also increment the version number. This makes sure that</front>
<front id="ConfigurationStoreCPP-37">// the default values are used whenever there is a change to the data, to prevent</front>
<front id="ConfigurationStoreCPP-38">// wrong data being written to the variables.</front>
<front id="ConfigurationStoreCPP-39">// ALSO:  always make sure the variables in the Store and retrieve sections are in the same order.</front>
<front id="ConfigurationStoreCPP-40">#define EEPROM_VERSION "V09"</front>
<front id="ConfigurationStoreCPP-41"></front>
<front id="ConfigurationStoreCPP-42">#ifdef EEPROM_SETTINGS</front>
<front id="ConfigurationStoreCPP-43">void Config_StoreSettings() </front>
<front id="ConfigurationStoreCPP-44">{</front>
<front id="ConfigurationStoreCPP-45">  char ver[4]= "000";</front>
<front id="ConfigurationStoreCPP-46">  int i=EEPROM_OFFSET;</front>
<front id="ConfigurationStoreCPP-47">  EEPROM_WRITE_VAR(i,ver); // invalidate data first </front>
<front id="ConfigurationStoreCPP-48">  EEPROM_WRITE_VAR(i,axis_steps_per_unit);  </front>
<front id="ConfigurationStoreCPP-49">  EEPROM_WRITE_VAR(i,max_feedrate);  </front>
<front id="ConfigurationStoreCPP-50">  EEPROM_WRITE_VAR(i,max_acceleration_units_per_sq_second);</front>
<front id="ConfigurationStoreCPP-51">  EEPROM_WRITE_VAR(i,acceleration);</front>
<front id="ConfigurationStoreCPP-52">  EEPROM_WRITE_VAR(i,retract_acceleration);</front>
<front id="ConfigurationStoreCPP-53">  EEPROM_WRITE_VAR(i,minimumfeedrate);</front>
<front id="ConfigurationStoreCPP-54">  EEPROM_WRITE_VAR(i,mintravelfeedrate);</front>
<front id="ConfigurationStoreCPP-55">  EEPROM_WRITE_VAR(i,minsegmenttime);</front>
<front id="ConfigurationStoreCPP-56">  EEPROM_WRITE_VAR(i,max_xy_jerk);</front>
<front id="ConfigurationStoreCPP-57">  EEPROM_WRITE_VAR(i,max_z_jerk);</front>
<front id="ConfigurationStoreCPP-58">  EEPROM_WRITE_VAR(i,max_e_jerk);</front>
<front id="ConfigurationStoreCPP-59">  EEPROM_WRITE_VAR(i,add_homeing);</front>
<front id="ConfigurationStoreCPP-60">  #ifdef DELTA</front>
<front id="ConfigurationStoreCPP-61">  EEPROM_WRITE_VAR(i,endstop_adj);</front>
<front id="ConfigurationStoreCPP-62">  #endif</front>
<front id="ConfigurationStoreCPP-63">  #ifndef ULTIPANEL</front>
<front id="ConfigurationStoreCPP-64">  int plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP, plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP, plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;</front>
<front id="ConfigurationStoreCPP-65">  int absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP, absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP, absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;</front>
<front id="ConfigurationStoreCPP-66">  #endif</front>
<front id="ConfigurationStoreCPP-67">  EEPROM_WRITE_VAR(i,plaPreheatHotendTemp);</front>
<front id="ConfigurationStoreCPP-68">  EEPROM_WRITE_VAR(i,plaPreheatHPBTemp);</front>
<front id="ConfigurationStoreCPP-69">  EEPROM_WRITE_VAR(i,plaPreheatFanSpeed);</front>
<front id="ConfigurationStoreCPP-70">  EEPROM_WRITE_VAR(i,absPreheatHotendTemp);</front>
<front id="ConfigurationStoreCPP-71">  EEPROM_WRITE_VAR(i,absPreheatHPBTemp);</front>
<front id="ConfigurationStoreCPP-72">  EEPROM_WRITE_VAR(i,absPreheatFanSpeed);</front>
<front id="ConfigurationStoreCPP-73">  #ifdef PIDTEMP</front>
<front id="ConfigurationStoreCPP-74">    EEPROM_WRITE_VAR(i,Kp);</front>
<front id="ConfigurationStoreCPP-75">    EEPROM_WRITE_VAR(i,Ki);</front>
<front id="ConfigurationStoreCPP-76">    EEPROM_WRITE_VAR(i,Kd);</front>
<front id="ConfigurationStoreCPP-77">  #else</front>
<front id="ConfigurationStoreCPP-78">		float dummy = 3000.0f;</front>
<front id="ConfigurationStoreCPP-79">    EEPROM_WRITE_VAR(i,dummy);</front>
<front id="ConfigurationStoreCPP-80">		dummy = 0.0f;</front>
<front id="ConfigurationStoreCPP-81">    EEPROM_WRITE_VAR(i,dummy);</front>
<front id="ConfigurationStoreCPP-82">    EEPROM_WRITE_VAR(i,dummy);</front>
<front id="ConfigurationStoreCPP-83">  #endif</front>
<front id="ConfigurationStoreCPP-84">  #ifndef DOGLCD</front>
<front id="ConfigurationStoreCPP-85">    int lcd_contrast = 32;</front>
<front id="ConfigurationStoreCPP-86">  #endif</front>
<front id="ConfigurationStoreCPP-87">  EEPROM_WRITE_VAR(i,lcd_contrast);</front>
<front id="ConfigurationStoreCPP-88">  char ver2[4]=EEPROM_VERSION;</front>
<front id="ConfigurationStoreCPP-89">  i=EEPROM_OFFSET;</front>
<front id="ConfigurationStoreCPP-90">  EEPROM_WRITE_VAR(i,ver2); // validate data</front>
<front id="ConfigurationStoreCPP-91">  SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-92">  SERIAL_ECHOLNPGM("Settings Stored");</front>
<front id="ConfigurationStoreCPP-93">}</front>
<front id="ConfigurationStoreCPP-94">#endif //EEPROM_SETTINGS</front>
<front id="ConfigurationStoreCPP-95"></front>
<front id="ConfigurationStoreCPP-96"></front>
<front id="ConfigurationStoreCPP-97">#ifndef DISABLE_M503</front>
<front id="ConfigurationStoreCPP-98">void Config_PrintSettings()</front>
<front id="ConfigurationStoreCPP-99">{  // Always have this function, even with EEPROM_SETTINGS disabled, the current values will be shown</front>
<front id="ConfigurationStoreCPP-100">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-101">    SERIAL_ECHOLNPGM("Steps per unit:");</front>
<front id="ConfigurationStoreCPP-102">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-103">    SERIAL_ECHOPAIR("  M92 X",axis_steps_per_unit[0]);</front>
<front id="ConfigurationStoreCPP-104">    SERIAL_ECHOPAIR(" Y",axis_steps_per_unit[1]);</front>
<front id="ConfigurationStoreCPP-105">    SERIAL_ECHOPAIR(" Z",axis_steps_per_unit[2]);</front>
<front id="ConfigurationStoreCPP-106">    SERIAL_ECHOPAIR(" E",axis_steps_per_unit[3]);</front>
<front id="ConfigurationStoreCPP-107">    SERIAL_ECHOLN("");</front>
<front id="ConfigurationStoreCPP-108">      </front>
<front id="ConfigurationStoreCPP-109">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-110">    SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");</front>
<front id="ConfigurationStoreCPP-111">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-112">    SERIAL_ECHOPAIR("  M203 X",max_feedrate[0]);</front>
<front id="ConfigurationStoreCPP-113">    SERIAL_ECHOPAIR(" Y",max_feedrate[1] ); </front>
<front id="ConfigurationStoreCPP-114">    SERIAL_ECHOPAIR(" Z", max_feedrate[2] ); </front>
<front id="ConfigurationStoreCPP-115">    SERIAL_ECHOPAIR(" E", max_feedrate[3]);</front>
<front id="ConfigurationStoreCPP-116">    SERIAL_ECHOLN("");</front>
<front id="ConfigurationStoreCPP-117"></front>
<front id="ConfigurationStoreCPP-118">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-119">    SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");</front>
<front id="ConfigurationStoreCPP-120">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-121">    SERIAL_ECHOPAIR("  M201 X" ,max_acceleration_units_per_sq_second[0] ); </front>
<front id="ConfigurationStoreCPP-122">    SERIAL_ECHOPAIR(" Y" , max_acceleration_units_per_sq_second[1] ); </front>
<front id="ConfigurationStoreCPP-123">    SERIAL_ECHOPAIR(" Z" ,max_acceleration_units_per_sq_second[2] );</front>
<front id="ConfigurationStoreCPP-124">    SERIAL_ECHOPAIR(" E" ,max_acceleration_units_per_sq_second[3]);</front>
<front id="ConfigurationStoreCPP-125">    SERIAL_ECHOLN("");</front>
<front id="ConfigurationStoreCPP-126">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-127">    SERIAL_ECHOLNPGM("Acceleration: S=acceleration, T=retract acceleration");</front>
<front id="ConfigurationStoreCPP-128">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-129">    SERIAL_ECHOPAIR("  M204 S",acceleration ); </front>
<front id="ConfigurationStoreCPP-130">    SERIAL_ECHOPAIR(" T" ,retract_acceleration);</front>
<front id="ConfigurationStoreCPP-131">    SERIAL_ECHOLN("");</front>
<front id="ConfigurationStoreCPP-132"></front>
<front id="ConfigurationStoreCPP-133">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-134">    SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum XY jerk (mm/s),  Z=maximum Z jerk (mm/s),  E=maximum E jerk (mm/s)");</front>
<front id="ConfigurationStoreCPP-135">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-136">    SERIAL_ECHOPAIR("  M205 S",minimumfeedrate ); </front>
<front id="ConfigurationStoreCPP-137">    SERIAL_ECHOPAIR(" T" ,mintravelfeedrate ); </front>
<front id="ConfigurationStoreCPP-138">    SERIAL_ECHOPAIR(" B" ,minsegmenttime ); </front>
<front id="ConfigurationStoreCPP-139">    SERIAL_ECHOPAIR(" X" ,max_xy_jerk ); </front>
<front id="ConfigurationStoreCPP-140">    SERIAL_ECHOPAIR(" Z" ,max_z_jerk);</front>
<front id="ConfigurationStoreCPP-141">    SERIAL_ECHOPAIR(" E" ,max_e_jerk);</front>
<front id="ConfigurationStoreCPP-142">    SERIAL_ECHOLN(""); </front>
<front id="ConfigurationStoreCPP-143"></front>
<front id="ConfigurationStoreCPP-144">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-145">    SERIAL_ECHOLNPGM("Home offset (mm):");</front>
<front id="ConfigurationStoreCPP-146">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-147">    SERIAL_ECHOPAIR("  M206 X",add_homeing[0] );</front>
<front id="ConfigurationStoreCPP-148">    SERIAL_ECHOPAIR(" Y" ,add_homeing[1] );</front>
<front id="ConfigurationStoreCPP-149">    SERIAL_ECHOPAIR(" Z" ,add_homeing[2] );</front>
<front id="ConfigurationStoreCPP-150">    SERIAL_ECHOLN("");</front>
<front id="ConfigurationStoreCPP-151">#ifdef DELTA</front>
<front id="ConfigurationStoreCPP-152">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-153">    SERIAL_ECHOLNPGM("Endstop adjustement (mm):");</front>
<front id="ConfigurationStoreCPP-154">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-155">    SERIAL_ECHOPAIR("  M666 X",endstop_adj[0] );</front>
<front id="ConfigurationStoreCPP-156">    SERIAL_ECHOPAIR(" Y" ,endstop_adj[1] );</front>
<front id="ConfigurationStoreCPP-157">    SERIAL_ECHOPAIR(" Z" ,endstop_adj[2] );</front>
<front id="ConfigurationStoreCPP-158">    SERIAL_ECHOLN("");</front>
<front id="ConfigurationStoreCPP-159">#endif</front>
<front id="ConfigurationStoreCPP-160">#ifdef PIDTEMP</front>
<front id="ConfigurationStoreCPP-161">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-162">    SERIAL_ECHOLNPGM("PID settings:");</front>
<front id="ConfigurationStoreCPP-163">    SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-164">    SERIAL_ECHOPAIR("   M301 P",Kp); </front>
<front id="ConfigurationStoreCPP-165">    SERIAL_ECHOPAIR(" I" ,unscalePID_i(Ki)); </front>
<front id="ConfigurationStoreCPP-166">    SERIAL_ECHOPAIR(" D" ,unscalePID_d(Kd));</front>
<front id="ConfigurationStoreCPP-167">    SERIAL_ECHOLN(""); </front>
<front id="ConfigurationStoreCPP-168">#endif</front>
<front id="ConfigurationStoreCPP-169">} </front>
<front id="ConfigurationStoreCPP-170">#endif</front>
<front id="ConfigurationStoreCPP-171"></front>
<front id="ConfigurationStoreCPP-172"></front>
<front id="ConfigurationStoreCPP-173">#ifdef EEPROM_SETTINGS</front>
<front id="ConfigurationStoreCPP-174">void Config_RetrieveSettings()</front>
<front id="ConfigurationStoreCPP-175">{</front>
<front id="ConfigurationStoreCPP-176">    int i=EEPROM_OFFSET;</front>
<front id="ConfigurationStoreCPP-177">    char stored_ver[4];</front>
<front id="ConfigurationStoreCPP-178">    char ver[4]=EEPROM_VERSION;</front>
<front id="ConfigurationStoreCPP-179">    EEPROM_READ_VAR(i,stored_ver); //read stored version</front>
<front id="ConfigurationStoreCPP-180">    //  SERIAL_ECHOLN("Version: [" &lt;&lt; ver &lt;&lt; "] Stored version: [" &lt;&lt; stored_ver &lt;&lt; "]");</front>
<front id="ConfigurationStoreCPP-181">    if (strncmp(ver,stored_ver,3) == 0)</front>
<front id="ConfigurationStoreCPP-182">    {</front>
<front id="ConfigurationStoreCPP-183">        // version number match</front>
<front id="ConfigurationStoreCPP-184">        EEPROM_READ_VAR(i,axis_steps_per_unit);  </front>
<front id="ConfigurationStoreCPP-185">        EEPROM_READ_VAR(i,max_feedrate);  </front>
<front id="ConfigurationStoreCPP-186">        EEPROM_READ_VAR(i,max_acceleration_units_per_sq_second);</front>
<front id="ConfigurationStoreCPP-187">        </front>
<front id="ConfigurationStoreCPP-188">        // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</front>
<front id="ConfigurationStoreCPP-189">		reset_acceleration_rates();</front>
<front id="ConfigurationStoreCPP-190">        </front>
<front id="ConfigurationStoreCPP-191">        EEPROM_READ_VAR(i,acceleration);</front>
<front id="ConfigurationStoreCPP-192">        EEPROM_READ_VAR(i,retract_acceleration);</front>
<front id="ConfigurationStoreCPP-193">        EEPROM_READ_VAR(i,minimumfeedrate);</front>
<front id="ConfigurationStoreCPP-194">        EEPROM_READ_VAR(i,mintravelfeedrate);</front>
<front id="ConfigurationStoreCPP-195">        EEPROM_READ_VAR(i,minsegmenttime);</front>
<front id="ConfigurationStoreCPP-196">        EEPROM_READ_VAR(i,max_xy_jerk);</front>
<front id="ConfigurationStoreCPP-197">        EEPROM_READ_VAR(i,max_z_jerk);</front>
<front id="ConfigurationStoreCPP-198">        EEPROM_READ_VAR(i,max_e_jerk);</front>
<front id="ConfigurationStoreCPP-199">        EEPROM_READ_VAR(i,add_homeing);</front>
<front id="ConfigurationStoreCPP-200">        #ifdef DELTA</front>
<front id="ConfigurationStoreCPP-201">        EEPROM_READ_VAR(i,endstop_adj);</front>
<front id="ConfigurationStoreCPP-202">        #endif</front>
<front id="ConfigurationStoreCPP-203">        #ifndef ULTIPANEL</front>
<front id="ConfigurationStoreCPP-204">        int plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed;</front>
<front id="ConfigurationStoreCPP-205">        int absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed;</front>
<front id="ConfigurationStoreCPP-206">        #endif</front>
<front id="ConfigurationStoreCPP-207">        EEPROM_READ_VAR(i,plaPreheatHotendTemp);</front>
<front id="ConfigurationStoreCPP-208">        EEPROM_READ_VAR(i,plaPreheatHPBTemp);</front>
<front id="ConfigurationStoreCPP-209">        EEPROM_READ_VAR(i,plaPreheatFanSpeed);</front>
<front id="ConfigurationStoreCPP-210">        EEPROM_READ_VAR(i,absPreheatHotendTemp);</front>
<front id="ConfigurationStoreCPP-211">        EEPROM_READ_VAR(i,absPreheatHPBTemp);</front>
<front id="ConfigurationStoreCPP-212">        EEPROM_READ_VAR(i,absPreheatFanSpeed);</front>
<front id="ConfigurationStoreCPP-213">        #ifndef PIDTEMP</front>
<front id="ConfigurationStoreCPP-214">        float Kp,Ki,Kd;</front>
<front id="ConfigurationStoreCPP-215">        #endif</front>
<front id="ConfigurationStoreCPP-216">        // do not need to scale PID values as the values in EEPROM are already scaled		</front>
<front id="ConfigurationStoreCPP-217">        EEPROM_READ_VAR(i,Kp);</front>
<front id="ConfigurationStoreCPP-218">        EEPROM_READ_VAR(i,Ki);</front>
<front id="ConfigurationStoreCPP-219">        EEPROM_READ_VAR(i,Kd);</front>
<front id="ConfigurationStoreCPP-220">        #ifndef DOGLCD</front>
<front id="ConfigurationStoreCPP-221">        int lcd_contrast;</front>
<front id="ConfigurationStoreCPP-222">        #endif</front>
<front id="ConfigurationStoreCPP-223">        EEPROM_READ_VAR(i,lcd_contrast);</front>
<front id="ConfigurationStoreCPP-224"></front>
<front id="ConfigurationStoreCPP-225">		// Call updatePID (similar to when we have processed M301)</front>
<front id="ConfigurationStoreCPP-226">		updatePID();</front>
<front id="ConfigurationStoreCPP-227">        SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-228">        SERIAL_ECHOLNPGM("Stored settings retrieved");</front>
<front id="ConfigurationStoreCPP-229">    }</front>
<front id="ConfigurationStoreCPP-230">    else</front>
<front id="ConfigurationStoreCPP-231">    {</front>
<front id="ConfigurationStoreCPP-232">        Config_ResetDefault();</front>
<front id="ConfigurationStoreCPP-233">    }</front>
<front id="ConfigurationStoreCPP-234">    #ifdef EEPROM_CHITCHAT</front>
<front id="ConfigurationStoreCPP-235">      Config_PrintSettings();</front>
<front id="ConfigurationStoreCPP-236">    #endif</front>
<front id="ConfigurationStoreCPP-237">}</front>
<front id="ConfigurationStoreCPP-238">#endif</front>
<front id="ConfigurationStoreCPP-239"></front>
<front id="ConfigurationStoreCPP-240">void Config_ResetDefault()</front>
<front id="ConfigurationStoreCPP-241">{</front>
<front id="ConfigurationStoreCPP-242">    float tmp1[]=DEFAULT_AXIS_STEPS_PER_UNIT;</front>
<front id="ConfigurationStoreCPP-243">    float tmp2[]=DEFAULT_MAX_FEEDRATE;</front>
<front id="ConfigurationStoreCPP-244">    long tmp3[]=DEFAULT_MAX_ACCELERATION;</front>
<front id="ConfigurationStoreCPP-245">    for (short i=0;i&lt;4;i++) </front>
<front id="ConfigurationStoreCPP-246">    {</front>
<front id="ConfigurationStoreCPP-247">        axis_steps_per_unit[i]=tmp1[i];  </front>
<front id="ConfigurationStoreCPP-248">        max_feedrate[i]=tmp2[i];  </front>
<front id="ConfigurationStoreCPP-249">        max_acceleration_units_per_sq_second[i]=tmp3[i];</front>
<front id="ConfigurationStoreCPP-250">    }</front>
<front id="ConfigurationStoreCPP-251">    </front>
<front id="ConfigurationStoreCPP-252">    // steps per sq second need to be updated to agree with the units per sq second</front>
<front id="ConfigurationStoreCPP-253">    reset_acceleration_rates();</front>
<front id="ConfigurationStoreCPP-254">    </front>
<front id="ConfigurationStoreCPP-255">    acceleration=DEFAULT_ACCELERATION;</front>
<front id="ConfigurationStoreCPP-256">    retract_acceleration=DEFAULT_RETRACT_ACCELERATION;</front>
<front id="ConfigurationStoreCPP-257">    minimumfeedrate=DEFAULT_MINIMUMFEEDRATE;</front>
<front id="ConfigurationStoreCPP-258">    minsegmenttime=DEFAULT_MINSEGMENTTIME;       </front>
<front id="ConfigurationStoreCPP-259">    mintravelfeedrate=DEFAULT_MINTRAVELFEEDRATE;</front>
<front id="ConfigurationStoreCPP-260">    max_xy_jerk=DEFAULT_XYJERK;</front>
<front id="ConfigurationStoreCPP-261">    max_z_jerk=DEFAULT_ZJERK;</front>
<front id="ConfigurationStoreCPP-262">    max_e_jerk=DEFAULT_EJERK;</front>
<front id="ConfigurationStoreCPP-263">    add_homeing[0] = add_homeing[1] = add_homeing[2] = 0;</front>
<front id="ConfigurationStoreCPP-264">#ifdef DELTA</front>
<front id="ConfigurationStoreCPP-265">    endstop_adj[0] = endstop_adj[1] = endstop_adj[2] = 0;</front>
<front id="ConfigurationStoreCPP-266">#endif</front>
<front id="ConfigurationStoreCPP-267">#ifdef ULTIPANEL</front>
<front id="ConfigurationStoreCPP-268">    plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;</front>
<front id="ConfigurationStoreCPP-269">    plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;</front>
<front id="ConfigurationStoreCPP-270">    plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;</front>
<front id="ConfigurationStoreCPP-271">    absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;</front>
<front id="ConfigurationStoreCPP-272">    absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;</front>
<front id="ConfigurationStoreCPP-273">    absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;</front>
<front id="ConfigurationStoreCPP-274">#endif</front>
<front id="ConfigurationStoreCPP-275">#ifdef DOGLCD</front>
<front id="ConfigurationStoreCPP-276">    lcd_contrast = DEFAULT_LCD_CONTRAST;</front>
<front id="ConfigurationStoreCPP-277">#endif</front>
<front id="ConfigurationStoreCPP-278">#ifdef PIDTEMP</front>
<front id="ConfigurationStoreCPP-279">    Kp = DEFAULT_Kp;</front>
<front id="ConfigurationStoreCPP-280">    Ki = scalePID_i(DEFAULT_Ki);</front>
<front id="ConfigurationStoreCPP-281">    Kd = scalePID_d(DEFAULT_Kd);</front>
<front id="ConfigurationStoreCPP-282">    </front>
<front id="ConfigurationStoreCPP-283">    // call updatePID (similar to when we have processed M301)</front>
<front id="ConfigurationStoreCPP-284">    updatePID();</front>
<front id="ConfigurationStoreCPP-285">    </front>
<front id="ConfigurationStoreCPP-286">#ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="ConfigurationStoreCPP-287">    Kc = DEFAULT_Kc;</front>
<front id="ConfigurationStoreCPP-288">#endif//PID_ADD_EXTRUSION_RATE</front>
<front id="ConfigurationStoreCPP-289">#endif//PIDTEMP</front>
<front id="ConfigurationStoreCPP-290"></front>
<front id="ConfigurationStoreCPP-291">SERIAL_ECHO_START;</front>
<front id="ConfigurationStoreCPP-292">SERIAL_ECHOLNPGM("Hardcoded Default Settings Loaded");</front>
<front id="ConfigurationStoreCPP-293"></front>
<front id="ConfigurationStoreCPP-294">}</front>
 </pre>
<h1>ConfigurationStore.h</h1>
<pre  class="prettyprint linenums"><front id="ConfigurationStoreH-1">#ifndef CONFIG_STORE_H</front>
<front id="ConfigurationStoreH-2">#define CONFIG_STORE_H</front>
<front id="ConfigurationStoreH-3"></front>
<front id="ConfigurationStoreH-4">#include "Configuration.h"</front>
<front id="ConfigurationStoreH-5"></front>
<front id="ConfigurationStoreH-6">void Config_ResetDefault();</front>
<front id="ConfigurationStoreH-7"></front>
<front id="ConfigurationStoreH-8">#ifndef DISABLE_M503</front>
<front id="ConfigurationStoreH-9">void Config_PrintSettings();</front>
<front id="ConfigurationStoreH-10">#else</front>
<front id="ConfigurationStoreH-11">FORCE_INLINE void Config_PrintSettings() {}</front>
<front id="ConfigurationStoreH-12">#endif</front>
<front id="ConfigurationStoreH-13"></front>
<front id="ConfigurationStoreH-14">#ifdef EEPROM_SETTINGS</front>
<front id="ConfigurationStoreH-15">void Config_StoreSettings();</front>
<front id="ConfigurationStoreH-16">void Config_RetrieveSettings();</front>
<front id="ConfigurationStoreH-17">#else</front>
<front id="ConfigurationStoreH-18">FORCE_INLINE void Config_StoreSettings() {}</front>
<front id="ConfigurationStoreH-19">FORCE_INLINE void Config_RetrieveSettings() { Config_ResetDefault(); Config_PrintSettings(); }</front>
<front id="ConfigurationStoreH-20">#endif</front>
<front id="ConfigurationStoreH-21"></front>
<front id="ConfigurationStoreH-22">#endif//CONFIG_STORE_H</front>
 </pre>
<h1>dogm_font_data_marlin.h</h1>
<pre  class="prettyprint linenums"><front id="dogm_font_data_marlinH-1">/*</front>
<front id="dogm_font_data_marlinH-2">  Fontname: -Misc-Fixed-Medium-R-Normal--9-90-75-75-C-60-ISO10646-1</front>
<front id="dogm_font_data_marlinH-3">  Copyright: Public domain font.  Share and enjoy.</front>
<front id="dogm_font_data_marlinH-4">  Capital A Height: 6, '1' Height: 6</front>
<front id="dogm_font_data_marlinH-5">  Calculated Max Values w= 6 h= 9 x= 2 y= 7 dx= 6 dy= 0 ascent= 7 len= 9</front>
<front id="dogm_font_data_marlinH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_marlinH-7">  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0</front>
<front id="dogm_font_data_marlinH-8">  Pure Font   ascent = 6 descent=-2</front>
<front id="dogm_font_data_marlinH-9">  X Font      ascent = 6 descent=-2</front>
<front id="dogm_font_data_marlinH-10">  Max Font    ascent = 7 descent=-2</front>
<front id="dogm_font_data_marlinH-11">*/</front>
<front id="dogm_font_data_marlinH-12">#include &lt;utility/u8g.h&gt;</front>
<front id="dogm_font_data_marlinH-13">const u8g_fntpgm_uint8_t u8g_font_6x9[2300] U8G_SECTION(".progmem.u8g_font_6x9") = {</front>
<front id="dogm_font_data_marlinH-14">  0,6,9,0,254,6,1,137,2,254,32,255,254,7,254,6,</front>
<front id="dogm_font_data_marlinH-15">  254,0,0,0,6,0,7,1,6,6,6,2,0,128,128,128,</front>
<front id="dogm_font_data_marlinH-16">  128,0,128,3,3,3,6,1,3,160,160,160,5,7,7,6,</front>
<front id="dogm_font_data_marlinH-17">  0,255,80,80,248,80,248,80,80,5,9,9,6,0,254,32,</front>
<front id="dogm_font_data_marlinH-18">  112,168,160,112,40,168,112,32,6,8,8,6,0,255,64,168,</front>
<front id="dogm_font_data_marlinH-19">  72,16,32,72,84,8,5,7,7,6,0,255,96,144,144,96,</front>
<front id="dogm_font_data_marlinH-20">  152,144,104,1,3,3,6,2,3,128,128,128,2,7,7,6,</front>
<front id="dogm_font_data_marlinH-21">  2,255,64,128,128,128,128,128,64,2,7,7,6,2,255,128,</front>
<front id="dogm_font_data_marlinH-22">  64,64,64,64,64,128,5,5,5,6,0,0,136,80,248,80,</front>
<front id="dogm_font_data_marlinH-23">  136,5,5,5,6,0,0,32,32,248,32,32,2,4,4,6,</front>
<front id="dogm_font_data_marlinH-24">  2,254,192,64,64,128,5,1,1,6,0,2,248,2,2,2,</front>
<front id="dogm_font_data_marlinH-25">  6,2,0,192,192,4,6,6,6,1,0,16,16,32,64,128,</front>
<front id="dogm_font_data_marlinH-26">  128,4,6,6,6,1,0,96,144,144,144,144,96,3,6,6,</front>
<front id="dogm_font_data_marlinH-27">  6,1,0,64,192,64,64,64,224,4,6,6,6,1,0,96,</front>
<front id="dogm_font_data_marlinH-28">  144,16,32,64,240,4,6,6,6,1,0,240,32,96,16,16,</front>
<front id="dogm_font_data_marlinH-29">  224,5,6,6,6,0,0,16,48,80,144,248,16,4,6,6,</front>
<front id="dogm_font_data_marlinH-30">  6,1,0,240,128,224,16,16,224,4,6,6,6,1,0,96,</front>
<front id="dogm_font_data_marlinH-31">  128,224,144,144,96,4,6,6,6,1,0,240,16,16,32,64,</front>
<front id="dogm_font_data_marlinH-32">  64,4,6,6,6,1,0,96,144,96,144,144,96,4,6,6,</front>
<front id="dogm_font_data_marlinH-33">  6,1,0,96,144,144,112,16,96,2,5,5,6,2,0,192,</front>
<front id="dogm_font_data_marlinH-34">  192,0,192,192,2,7,7,6,2,254,192,192,0,192,64,64,</front>
<front id="dogm_font_data_marlinH-35">  128,5,5,5,6,0,0,24,96,128,96,24,5,3,3,6,</front>
<front id="dogm_font_data_marlinH-36">  0,1,248,0,248,5,5,5,6,0,0,192,48,8,48,192,</front>
<front id="dogm_font_data_marlinH-37">  4,7,7,6,1,0,96,144,16,96,64,0,64,5,6,6,</front>
<front id="dogm_font_data_marlinH-38">  6,0,0,112,144,168,176,128,112,5,6,6,6,0,0,32,</front>
<front id="dogm_font_data_marlinH-39">  80,136,248,136,136,5,6,6,6,0,0,240,136,240,136,136,</front>
<front id="dogm_font_data_marlinH-40">  240,4,6,6,6,1,0,96,144,128,128,144,96,4,6,6,</front>
<front id="dogm_font_data_marlinH-41">  6,1,0,224,144,144,144,144,224,4,6,6,6,1,0,240,</front>
<front id="dogm_font_data_marlinH-42">  128,224,128,128,240,4,6,6,6,1,0,240,128,224,128,128,</front>
<front id="dogm_font_data_marlinH-43">  128,4,6,6,6,1,0,96,144,128,176,144,96,4,6,6,</front>
<front id="dogm_font_data_marlinH-44">  6,1,0,144,144,240,144,144,144,3,6,6,6,1,0,224,</front>
<front id="dogm_font_data_marlinH-45">  64,64,64,64,224,5,6,6,6,0,0,56,16,16,16,144,</front>
<front id="dogm_font_data_marlinH-46">  96,4,6,6,6,1,0,144,160,192,160,144,144,4,6,6,</front>
<front id="dogm_font_data_marlinH-47">  6,1,0,128,128,128,128,128,240,5,6,6,6,0,0,136,</front>
<front id="dogm_font_data_marlinH-48">  216,168,168,136,136,4,6,6,6,1,0,144,208,176,144,144,</front>
<front id="dogm_font_data_marlinH-49">  144,5,6,6,6,0,0,112,136,136,136,136,112,4,6,6,</front>
<front id="dogm_font_data_marlinH-50">  6,1,0,224,144,144,224,128,128,4,7,7,6,1,255,96,</front>
<front id="dogm_font_data_marlinH-51">  144,144,208,176,96,16,4,6,6,6,1,0,224,144,144,224,</front>
<front id="dogm_font_data_marlinH-52">  144,144,4,6,6,6,1,0,96,144,64,32,144,96,5,6,</front>
<front id="dogm_font_data_marlinH-53">  6,6,0,0,248,32,32,32,32,32,4,6,6,6,1,0,</front>
<front id="dogm_font_data_marlinH-54">  144,144,144,144,144,96,4,6,6,6,1,0,144,144,144,240,</front>
<front id="dogm_font_data_marlinH-55">  96,96,5,6,6,6,0,0,136,136,168,168,216,136,5,6,</front>
<front id="dogm_font_data_marlinH-56">  6,6,0,0,136,80,32,32,80,136,5,6,6,6,0,0,</front>
<front id="dogm_font_data_marlinH-57">  136,136,80,32,32,32,4,6,6,6,1,0,240,16,32,64,</front>
<front id="dogm_font_data_marlinH-58">  128,240,3,6,6,6,1,0,224,128,128,128,128,224,4,6,</front>
<front id="dogm_font_data_marlinH-59">  6,6,1,0,128,128,64,32,16,16,3,6,6,6,1,0,</front>
<front id="dogm_font_data_marlinH-60">  224,32,32,32,32,224,5,3,3,6,0,3,32,80,136,5,</front>
<front id="dogm_font_data_marlinH-61">  1,1,6,0,254,248,2,2,2,6,2,4,128,64,4,4,</front>
<front id="dogm_font_data_marlinH-62">  4,6,1,0,112,144,144,112,4,6,6,6,1,0,128,128,</front>
<front id="dogm_font_data_marlinH-63">  224,144,144,224,4,4,4,6,1,0,112,128,128,112,4,6,</front>
<front id="dogm_font_data_marlinH-64">  6,6,1,0,16,16,112,144,144,112,4,4,4,6,1,0,</front>
<front id="dogm_font_data_marlinH-65">  96,176,192,112,4,6,6,6,1,0,32,80,64,224,64,64,</front>
<front id="dogm_font_data_marlinH-66">  4,6,6,6,1,254,96,144,144,112,16,96,4,6,6,6,</front>
<front id="dogm_font_data_marlinH-67">  1,0,128,128,224,144,144,144,3,6,6,6,1,0,64,0,</front>
<front id="dogm_font_data_marlinH-68">  192,64,64,224,3,8,8,6,1,254,32,0,96,32,32,32,</front>
<front id="dogm_font_data_marlinH-69">  160,64,4,6,6,6,1,0,128,128,160,192,160,144,3,6,</front>
<front id="dogm_font_data_marlinH-70">  6,6,1,0,192,64,64,64,64,224,5,4,4,6,0,0,</front>
<front id="dogm_font_data_marlinH-71">  208,168,168,136,4,4,4,6,1,0,224,144,144,144,4,4,</front>
<front id="dogm_font_data_marlinH-72">  4,6,1,0,96,144,144,96,4,6,6,6,1,254,224,144,</front>
<front id="dogm_font_data_marlinH-73">  144,224,128,128,4,6,6,6,1,254,112,144,144,112,16,16,</front>
<front id="dogm_font_data_marlinH-74">  4,4,4,6,1,0,160,208,128,128,4,4,4,6,1,0,</front>
<front id="dogm_font_data_marlinH-75">  112,192,48,224,4,6,6,6,1,0,64,64,224,64,80,32,</front>
<front id="dogm_font_data_marlinH-76">  4,4,4,6,1,0,144,144,144,112,4,4,4,6,1,0,</front>
<front id="dogm_font_data_marlinH-77">  144,144,96,96,5,4,4,6,0,0,136,168,168,80,4,4,</front>
<front id="dogm_font_data_marlinH-78">  4,6,1,0,144,96,96,144,4,6,6,6,1,254,144,144,</front>
<front id="dogm_font_data_marlinH-79">  144,112,144,96,4,4,4,6,1,0,240,32,64,240,3,7,</front>
<front id="dogm_font_data_marlinH-80">  7,6,1,0,32,64,64,128,64,64,32,1,7,7,6,2,</front>
<front id="dogm_font_data_marlinH-81">  255,128,128,128,128,128,128,128,3,7,7,6,1,0,128,64,</front>
<front id="dogm_font_data_marlinH-82">  64,32,64,64,128,4,2,2,6,1,3,80,160,255,255,255,</front>
<front id="dogm_font_data_marlinH-83">  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,</front>
<front id="dogm_font_data_marlinH-84">  255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,</front>
<front id="dogm_font_data_marlinH-85">  0,6,0,7,1,6,6,6,2,0,128,0,128,128,128,128,</front>
<front id="dogm_font_data_marlinH-86">  4,6,6,6,1,255,32,112,160,160,112,32,5,7,7,6,</front>
<front id="dogm_font_data_marlinH-87">  0,255,48,72,64,240,64,64,248,5,5,5,6,0,0,168,</front>
<front id="dogm_font_data_marlinH-88">  80,136,80,168,5,6,6,6,0,0,136,80,248,32,248,32,</front>
<front id="dogm_font_data_marlinH-89">  1,7,7,6,2,255,128,128,128,0,128,128,128,4,7,7,</front>
<front id="dogm_font_data_marlinH-90">  6,1,255,112,128,96,144,96,16,224,3,1,1,6,1,5,</front>
<front id="dogm_font_data_marlinH-91">  160,6,7,7,6,0,0,120,132,148,164,148,132,120,3,5,</front>
<front id="dogm_font_data_marlinH-92">  5,6,1,1,96,160,96,0,224,5,5,5,6,0,0,40,</front>
<front id="dogm_font_data_marlinH-93">  80,160,80,40,4,3,3,6,1,0,240,16,16,4,1,1,</front>
<front id="dogm_font_data_marlinH-94">  6,1,2,240,6,7,7,6,0,0,120,132,180,164,164,132,</front>
<front id="dogm_font_data_marlinH-95">  120,4,1,1,6,1,5,240,4,3,3,6,1,2,96,144,</front>
<front id="dogm_font_data_marlinH-96">  96,5,7,7,6,0,255,32,32,248,32,32,0,248,3,5,</front>
<front id="dogm_font_data_marlinH-97">  5,6,1,1,64,160,32,64,224,3,5,5,6,1,1,192,</front>
<front id="dogm_font_data_marlinH-98">  32,64,32,192,2,2,2,6,2,4,64,128,4,5,5,6,</front>
<front id="dogm_font_data_marlinH-99">  1,255,144,144,176,208,128,5,6,6,6,0,0,120,232,232,</front>
<front id="dogm_font_data_marlinH-100">  104,40,40,1,1,1,6,2,2,128,2,2,2,6,2,254,</front>
<front id="dogm_font_data_marlinH-101">  64,128,3,5,5,6,1,1,64,192,64,64,224,3,5,5,</front>
<front id="dogm_font_data_marlinH-102">  6,1,1,64,160,64,0,224,5,5,5,6,0,0,160,80,</front>
<front id="dogm_font_data_marlinH-103">  40,80,160,5,8,8,6,0,255,64,192,64,80,112,48,120,</front>
<front id="dogm_font_data_marlinH-104">  16,5,8,8,6,0,255,64,192,64,80,104,8,16,56,5,</front>
<front id="dogm_font_data_marlinH-105">  8,8,6,0,255,192,32,64,48,240,48,120,16,4,7,7,</front>
<front id="dogm_font_data_marlinH-106">  6,1,0,32,0,32,96,128,144,96,5,7,7,6,0,0,</front>
<front id="dogm_font_data_marlinH-107">  64,32,32,80,112,136,136,5,7,7,6,0,0,16,32,32,</front>
<front id="dogm_font_data_marlinH-108">  80,112,136,136,5,7,7,6,0,0,32,80,32,80,112,136,</front>
<front id="dogm_font_data_marlinH-109">  136,5,7,7,6,0,0,40,80,32,80,112,136,136,5,7,</front>
<front id="dogm_font_data_marlinH-110">  7,6,0,0,80,0,32,80,112,136,136,5,7,7,6,0,</front>
<front id="dogm_font_data_marlinH-111">  0,32,80,32,80,112,136,136,5,6,6,6,0,0,120,160,</front>
<front id="dogm_font_data_marlinH-112">  240,160,160,184,4,8,8,6,1,254,96,144,128,128,144,96,</front>
<front id="dogm_font_data_marlinH-113">  32,64,4,7,7,6,1,0,64,32,240,128,224,128,240,4,</front>
<front id="dogm_font_data_marlinH-114">  7,7,6,1,0,32,64,240,128,224,128,240,4,7,7,6,</front>
<front id="dogm_font_data_marlinH-115">  1,0,32,80,240,128,224,128,240,4,7,7,6,1,0,80,</front>
<front id="dogm_font_data_marlinH-116">  0,240,128,224,128,240,3,7,7,6,1,0,128,64,224,64,</front>
<front id="dogm_font_data_marlinH-117">  64,64,224,3,7,7,6,1,0,32,64,224,64,64,64,224,</front>
<front id="dogm_font_data_marlinH-118">  3,7,7,6,1,0,64,160,224,64,64,64,224,3,7,7,</front>
<front id="dogm_font_data_marlinH-119">  6,1,0,160,0,224,64,64,64,224,5,6,6,6,0,0,</front>
<front id="dogm_font_data_marlinH-120">  112,72,232,72,72,112,4,7,7,6,1,0,80,160,144,208,</front>
<front id="dogm_font_data_marlinH-121">  176,144,144,4,7,7,6,1,0,64,32,96,144,144,144,96,</front>
<front id="dogm_font_data_marlinH-122">  4,7,7,6,1,0,32,64,96,144,144,144,96,4,7,7,</front>
<front id="dogm_font_data_marlinH-123">  6,1,0,32,80,96,144,144,144,96,4,7,7,6,1,0,</front>
<front id="dogm_font_data_marlinH-124">  80,160,96,144,144,144,96,4,7,7,6,1,0,80,0,96,</front>
<front id="dogm_font_data_marlinH-125">  144,144,144,96,5,5,5,6,0,0,136,80,32,80,136,4,</front>
<front id="dogm_font_data_marlinH-126">  8,8,6,1,255,16,112,176,176,208,208,224,128,4,7,7,</front>
<front id="dogm_font_data_marlinH-127">  6,1,0,64,32,144,144,144,144,96,4,7,7,6,1,0,</front>
<front id="dogm_font_data_marlinH-128">  32,64,144,144,144,144,96,4,7,7,6,1,0,32,80,144,</front>
<front id="dogm_font_data_marlinH-129">  144,144,144,96,4,7,7,6,1,0,80,0,144,144,144,144,</front>
<front id="dogm_font_data_marlinH-130">  96,5,7,7,6,0,0,16,32,136,80,32,32,32,4,6,</front>
<front id="dogm_font_data_marlinH-131">  6,6,1,0,128,224,144,144,224,128,4,6,6,6,1,0,</front>
<front id="dogm_font_data_marlinH-132">  96,144,160,160,144,160,4,7,7,6,1,0,64,32,0,112,</front>
<front id="dogm_font_data_marlinH-133">  144,144,112,4,7,7,6,1,0,32,64,0,112,144,144,112,</front>
<front id="dogm_font_data_marlinH-134">  4,7,7,6,1,0,32,80,0,112,144,144,112,4,7,7,</front>
<front id="dogm_font_data_marlinH-135">  6,1,0,80,160,0,112,144,144,112,4,6,6,6,1,0,</front>
<front id="dogm_font_data_marlinH-136">  80,0,112,144,144,112,4,7,7,6,1,0,32,80,32,112,</front>
<front id="dogm_font_data_marlinH-137">  144,144,112,5,4,4,6,0,0,112,168,176,120,4,6,6,</front>
<front id="dogm_font_data_marlinH-138">  6,1,254,112,128,128,112,32,64,4,7,7,6,1,0,64,</front>
<front id="dogm_font_data_marlinH-139">  32,0,96,176,192,112,4,7,7,6,1,0,32,64,0,96,</front>
<front id="dogm_font_data_marlinH-140">  176,192,112,4,7,7,6,1,0,32,80,0,96,176,192,112,</front>
<front id="dogm_font_data_marlinH-141">  4,6,6,6,1,0,80,0,96,176,192,112,3,7,7,6,</front>
<front id="dogm_font_data_marlinH-142">  1,0,128,64,0,192,64,64,224,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_marlinH-143">  64,0,192,64,64,224,3,7,7,6,1,0,64,160,0,192,</front>
<front id="dogm_font_data_marlinH-144">  64,64,224,3,6,6,6,1,0,160,0,192,64,64,224,4,</front>
<front id="dogm_font_data_marlinH-145">  7,7,6,1,0,48,96,16,112,144,144,96,4,7,7,6,</front>
<front id="dogm_font_data_marlinH-146">  1,0,80,160,0,224,144,144,144,4,7,7,6,1,0,64,</front>
<front id="dogm_font_data_marlinH-147">  32,0,96,144,144,96,4,7,7,6,1,0,32,64,0,96,</front>
<front id="dogm_font_data_marlinH-148">  144,144,96,4,7,7,6,1,0,32,80,0,96,144,144,96,</front>
<front id="dogm_font_data_marlinH-149">  4,7,7,6,1,0,80,160,0,96,144,144,96,4,6,6,</front>
<front id="dogm_font_data_marlinH-150">  6,1,0,80,0,96,144,144,96,5,5,5,6,0,0,32,</front>
<front id="dogm_font_data_marlinH-151">  0,248,0,32,4,4,4,6,1,0,112,176,208,224,4,7,</front>
<front id="dogm_font_data_marlinH-152">  7,6,1,0,64,32,0,144,144,144,112,4,7,7,6,1,</front>
<front id="dogm_font_data_marlinH-153">  0,32,64,0,144,144,144,112,4,7,7,6,1,0,32,80,</front>
<front id="dogm_font_data_marlinH-154">  0,144,144,144,112,4,6,6,6,1,0,80,0,144,144,144,</front>
<front id="dogm_font_data_marlinH-155">  112,4,9,9,6,1,254,32,64,0,144,144,144,112,144,96,</front>
<front id="dogm_font_data_marlinH-156">  4,8,8,6,1,254,128,128,224,144,144,224,128,128,4,8,</front>
<front id="dogm_font_data_marlinH-157">  8,6,1,254,80,0,144,144,144,112,144,96};</front>
<front id="dogm_font_data_marlinH-158"></front>
<front id="dogm_font_data_marlinH-159">// STB Marlin</front>
<front id="dogm_font_data_marlinH-160">/*</front>
<front id="dogm_font_data_marlinH-161">  Fontname: u8g_font_6x10_marlin</front>
<front id="dogm_font_data_marlinH-162">  Copyright: Public domain terminal emulator font.  Share and enjoy.</front>
<front id="dogm_font_data_marlinH-163">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_marlinH-164">  Calculated Max Values w= 6 h=10 x= 2 y= 7 dx= 6 dy= 0 ascent= 8 len=10</front>
<front id="dogm_font_data_marlinH-165">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_marlinH-166">  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0</front>
<front id="dogm_font_data_marlinH-167">  Pure Font   ascent = 7 descent=-2</front>
<front id="dogm_font_data_marlinH-168">  X Font      ascent = 7 descent=-2</front>
<front id="dogm_font_data_marlinH-169">  Max Font    ascent = 8 descent=-2</front>
<front id="dogm_font_data_marlinH-170">*/</front>
<front id="dogm_font_data_marlinH-171">#include &lt;utility/u8g.h&gt;</front>
<front id="dogm_font_data_marlinH-172">const u8g_fntpgm_uint8_t u8g_font_6x10_marlin[2617] U8G_SECTION(".progmem.u8g_font_6x10_marlin") = {</front>
<front id="dogm_font_data_marlinH-173">  0,6,9,0,254,7,1,153,3,43,32,255,254,8,254,7,</front>
<front id="dogm_font_data_marlinH-174">  254,0,0,0,6,0,0,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_marlinH-175">  128,128,0,128,3,3,3,6,1,4,160,160,160,5,7,7,</front>
<front id="dogm_font_data_marlinH-176">  6,0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,</front>
<front id="dogm_font_data_marlinH-177">  32,112,160,112,40,112,32,5,7,7,6,0,0,72,168,80,</front>
<front id="dogm_font_data_marlinH-178">  32,80,168,144,5,7,7,6,0,0,64,160,160,64,168,144,</front>
<front id="dogm_font_data_marlinH-179">  104,1,3,3,6,2,4,128,128,128,3,7,7,6,1,0,</front>
<front id="dogm_font_data_marlinH-180">  32,64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,</front>
<front id="dogm_font_data_marlinH-181">  32,32,64,128,5,5,5,6,0,1,136,80,248,80,136,5,</front>
<front id="dogm_font_data_marlinH-182">  5,5,6,0,1,32,32,248,32,32,3,3,3,6,1,255,</front>
<front id="dogm_font_data_marlinH-183">  96,64,128,5,1,1,6,0,3,248,3,3,3,6,1,255,</front>
<front id="dogm_font_data_marlinH-184">  64,224,64,5,7,7,6,0,0,8,8,16,32,64,128,128,</front>
<front id="dogm_font_data_marlinH-185">  5,7,7,6,0,0,32,80,136,136,136,80,32,5,7,7,</front>
<front id="dogm_font_data_marlinH-186">  6,0,0,32,96,160,32,32,32,248,5,7,7,6,0,0,</front>
<front id="dogm_font_data_marlinH-187">  112,136,8,48,64,128,248,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_marlinH-188">  48,8,136,112,5,7,7,6,0,0,16,48,80,144,248,16,</front>
<front id="dogm_font_data_marlinH-189">  16,5,7,7,6,0,0,248,128,176,200,8,136,112,5,7,</front>
<front id="dogm_font_data_marlinH-190">  7,6,0,0,48,64,128,176,200,136,112,5,7,7,6,0,</front>
<front id="dogm_font_data_marlinH-191">  0,248,8,16,16,32,64,64,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_marlinH-192">  136,112,136,136,112,5,7,7,6,0,0,112,136,152,104,8,</front>
<front id="dogm_font_data_marlinH-193">  16,96,3,7,7,6,1,255,64,224,64,0,64,224,64,3,</front>
<front id="dogm_font_data_marlinH-194">  7,7,6,1,255,64,224,64,0,96,64,128,4,7,7,6,</front>
<front id="dogm_font_data_marlinH-195">  1,0,16,32,64,128,64,32,16,5,3,3,6,0,2,248,</front>
<front id="dogm_font_data_marlinH-196">  0,248,4,7,7,6,1,0,128,64,32,16,32,64,128,5,</front>
<front id="dogm_font_data_marlinH-197">  7,7,6,0,0,112,136,16,32,32,0,32,5,7,7,6,</front>
<front id="dogm_font_data_marlinH-198">  0,0,112,136,152,168,176,128,112,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_marlinH-199">  80,136,136,248,136,136,5,7,7,6,0,0,240,72,72,112,</front>
<front id="dogm_font_data_marlinH-200">  72,72,240,5,7,7,6,0,0,112,136,128,128,128,136,112,</front>
<front id="dogm_font_data_marlinH-201">  5,7,7,6,0,0,240,72,72,72,72,72,240,5,7,7,</front>
<front id="dogm_font_data_marlinH-202">  6,0,0,248,128,128,240,128,128,248,5,7,7,6,0,0,</front>
<front id="dogm_font_data_marlinH-203">  248,128,128,240,128,128,128,5,7,7,6,0,0,112,136,128,</front>
<front id="dogm_font_data_marlinH-204">  128,152,136,112,5,7,7,6,0,0,136,136,136,248,136,136,</front>
<front id="dogm_font_data_marlinH-205">  136,3,7,7,6,1,0,224,64,64,64,64,64,224,5,7,</front>
<front id="dogm_font_data_marlinH-206">  7,6,0,0,56,16,16,16,16,144,96,5,7,7,6,0,</front>
<front id="dogm_font_data_marlinH-207">  0,136,144,160,192,160,144,136,5,7,7,6,0,0,128,128,</front>
<front id="dogm_font_data_marlinH-208">  128,128,128,128,248,5,7,7,6,0,0,136,136,216,168,136,</front>
<front id="dogm_font_data_marlinH-209">  136,136,5,7,7,6,0,0,136,136,200,168,152,136,136,5,</front>
<front id="dogm_font_data_marlinH-210">  7,7,6,0,0,112,136,136,136,136,136,112,5,7,7,6,</front>
<front id="dogm_font_data_marlinH-211">  0,0,240,136,136,240,128,128,128,5,8,8,6,0,255,112,</front>
<front id="dogm_font_data_marlinH-212">  136,136,136,136,168,112,8,5,7,7,6,0,0,240,136,136,</front>
<front id="dogm_font_data_marlinH-213">  240,160,144,136,5,7,7,6,0,0,112,136,128,112,8,136,</front>
<front id="dogm_font_data_marlinH-214">  112,5,7,7,6,0,0,248,32,32,32,32,32,32,5,7,</front>
<front id="dogm_font_data_marlinH-215">  7,6,0,0,136,136,136,136,136,136,112,5,7,7,6,0,</front>
<front id="dogm_font_data_marlinH-216">  0,136,136,136,80,80,80,32,5,7,7,6,0,0,136,136,</front>
<front id="dogm_font_data_marlinH-217">  136,168,168,216,136,5,7,7,6,0,0,136,136,80,32,80,</front>
<front id="dogm_font_data_marlinH-218">  136,136,5,7,7,6,0,0,136,136,80,32,32,32,32,5,</front>
<front id="dogm_font_data_marlinH-219">  7,7,6,0,0,248,8,16,32,64,128,248,3,7,7,6,</front>
<front id="dogm_font_data_marlinH-220">  1,0,224,128,128,128,128,128,224,5,7,7,6,0,0,128,</front>
<front id="dogm_font_data_marlinH-221">  128,64,32,16,8,8,3,7,7,6,1,0,224,32,32,32,</front>
<front id="dogm_font_data_marlinH-222">  32,32,224,5,3,3,6,0,4,32,80,136,5,1,1,6,</front>
<front id="dogm_font_data_marlinH-223">  0,255,248,2,2,2,6,2,6,128,64,5,5,5,6,0,</front>
<front id="dogm_font_data_marlinH-224">  0,112,8,120,136,120,5,7,7,6,0,0,128,128,176,200,</front>
<front id="dogm_font_data_marlinH-225">  136,200,176,5,5,5,6,0,0,112,136,128,136,112,5,7,</front>
<front id="dogm_font_data_marlinH-226">  7,6,0,0,8,8,104,152,136,152,104,5,5,5,6,0,</front>
<front id="dogm_font_data_marlinH-227">  0,112,136,248,128,112,5,7,7,6,0,0,48,72,64,240,</front>
<front id="dogm_font_data_marlinH-228">  64,64,64,5,7,7,6,0,254,120,136,136,120,8,136,112,</front>
<front id="dogm_font_data_marlinH-229">  5,7,7,6,0,0,128,128,176,200,136,136,136,3,7,7,</front>
<front id="dogm_font_data_marlinH-230">  6,1,0,64,0,192,64,64,64,224,4,9,9,6,1,254,</front>
<front id="dogm_font_data_marlinH-231">  16,0,48,16,16,16,144,144,96,5,7,7,6,0,0,128,</front>
<front id="dogm_font_data_marlinH-232">  128,136,144,224,144,136,3,7,7,6,1,0,192,64,64,64,</front>
<front id="dogm_font_data_marlinH-233">  64,64,224,5,5,5,6,0,0,208,168,168,168,136,5,5,</front>
<front id="dogm_font_data_marlinH-234">  5,6,0,0,176,200,136,136,136,5,5,5,6,0,0,112,</front>
<front id="dogm_font_data_marlinH-235">  136,136,136,112,5,7,7,6,0,254,176,200,136,200,176,128,</front>
<front id="dogm_font_data_marlinH-236">  128,5,7,7,6,0,254,104,152,136,152,104,8,8,5,5,</front>
<front id="dogm_font_data_marlinH-237">  5,6,0,0,176,200,128,128,128,5,5,5,6,0,0,112,</front>
<front id="dogm_font_data_marlinH-238">  128,112,8,240,5,7,7,6,0,0,64,64,240,64,64,72,</front>
<front id="dogm_font_data_marlinH-239">  48,5,5,5,6,0,0,136,136,136,152,104,5,5,5,6,</front>
<front id="dogm_font_data_marlinH-240">  0,0,136,136,80,80,32,5,5,5,6,0,0,136,136,168,</front>
<front id="dogm_font_data_marlinH-241">  168,80,5,5,5,6,0,0,136,80,32,80,136,5,7,7,</front>
<front id="dogm_font_data_marlinH-242">  6,0,254,136,136,152,104,8,136,112,5,5,5,6,0,0,</front>
<front id="dogm_font_data_marlinH-243">  248,16,32,64,248,4,7,7,6,1,0,48,64,32,192,32,</front>
<front id="dogm_font_data_marlinH-244">  64,48,1,7,7,6,2,0,128,128,128,128,128,128,128,4,</front>
<front id="dogm_font_data_marlinH-245">  7,7,6,1,0,192,32,64,48,64,32,192,5,3,3,6,</front>
<front id="dogm_font_data_marlinH-246">  0,4,72,168,144,0,0,0,1,0,0,0,0,0,1,0,</front>
<front id="dogm_font_data_marlinH-247">  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,</front>
<front id="dogm_font_data_marlinH-248">  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,</front>
<front id="dogm_font_data_marlinH-249">  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,</front>
<front id="dogm_font_data_marlinH-250">  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,</front>
<front id="dogm_font_data_marlinH-251">  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,</front>
<front id="dogm_font_data_marlinH-252">  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,</front>
<front id="dogm_font_data_marlinH-253">  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,</front>
<front id="dogm_font_data_marlinH-254">  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,</front>
<front id="dogm_font_data_marlinH-255">  0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,</front>
<front id="dogm_font_data_marlinH-256">  0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,</front>
<front id="dogm_font_data_marlinH-257">  1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,</front>
<front id="dogm_font_data_marlinH-258">  0,0,1,0,0,0,0,0,1,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_marlinH-259">  0,1,7,7,6,2,0,128,0,128,128,128,128,128,5,7,</front>
<front id="dogm_font_data_marlinH-260">  7,6,0,255,32,120,160,160,160,120,32,5,7,7,6,0,</front>
<front id="dogm_font_data_marlinH-261">  0,48,72,64,224,64,72,176,5,5,5,6,0,0,136,112,</front>
<front id="dogm_font_data_marlinH-262">  80,112,136,5,8,8,6,0,255,136,136,80,32,248,32,32,</front>
<front id="dogm_font_data_marlinH-263">  32,1,7,7,6,2,0,128,128,128,0,128,128,128,5,8,</front>
<front id="dogm_font_data_marlinH-264">  8,6,0,255,112,128,224,144,72,56,8,112,3,1,1,6,</front>
<front id="dogm_font_data_marlinH-265">  1,7,160,5,7,7,6,0,0,112,136,168,200,168,136,112,</front>
<front id="dogm_font_data_marlinH-266">  4,6,6,6,1,1,112,144,176,80,0,240,6,5,5,6,</front>
<front id="dogm_font_data_marlinH-267">  0,0,36,72,144,72,36,4,2,2,6,1,2,240,16,4,</front>
<front id="dogm_font_data_marlinH-268">  1,1,6,1,3,240,5,7,7,6,0,0,112,136,232,200,</front>
<front id="dogm_font_data_marlinH-269">  200,136,112,5,1,1,6,0,7,248,3,3,3,6,1,4,</front>
<front id="dogm_font_data_marlinH-270">  64,160,64,5,6,6,6,0,0,32,32,248,32,32,248,4,</front>
<front id="dogm_font_data_marlinH-271">  5,5,6,1,3,96,144,32,64,240,4,5,5,6,1,3,</front>
<front id="dogm_font_data_marlinH-272">  224,16,96,16,224,2,2,2,6,2,6,64,128,5,6,6,</front>
<front id="dogm_font_data_marlinH-273">  6,0,255,136,136,136,200,176,128,5,7,7,6,0,0,120,</front>
<front id="dogm_font_data_marlinH-274">  232,232,104,40,40,40,1,1,1,6,2,3,128,2,2,2,</front>
<front id="dogm_font_data_marlinH-275">  6,2,254,64,128,3,5,5,6,1,3,64,192,64,64,224,</front>
<front id="dogm_font_data_marlinH-276">  4,6,6,6,1,1,96,144,144,96,0,240,6,5,5,6,</front>
<front id="dogm_font_data_marlinH-277">  0,0,144,72,36,72,144,6,9,9,6,0,255,64,192,64,</front>
<front id="dogm_font_data_marlinH-278">  64,228,12,20,60,4,6,9,9,6,0,255,64,192,64,64,</front>
<front id="dogm_font_data_marlinH-279">  232,20,4,8,28,5,9,9,6,0,255,192,32,64,32,200,</front>
<front id="dogm_font_data_marlinH-280">  24,40,120,8,5,7,7,6,0,0,32,0,32,32,64,136,</front>
<front id="dogm_font_data_marlinH-281">  112,5,8,8,6,0,0,64,32,112,136,136,248,136,136,5,</front>
<front id="dogm_font_data_marlinH-282">  8,8,6,0,0,16,32,112,136,136,248,136,136,5,8,8,</front>
<front id="dogm_font_data_marlinH-283">  6,0,0,32,80,112,136,136,248,136,136,5,8,8,6,0,</front>
<front id="dogm_font_data_marlinH-284">  0,72,176,112,136,136,248,136,136,5,8,8,6,0,0,80,</front>
<front id="dogm_font_data_marlinH-285">  0,112,136,136,248,136,136,5,8,8,6,0,0,32,80,112,</front>
<front id="dogm_font_data_marlinH-286">  136,136,248,136,136,6,7,7,6,0,0,60,80,144,156,240,</front>
<front id="dogm_font_data_marlinH-287">  144,156,5,9,9,6,0,254,112,136,128,128,128,136,112,32,</front>
<front id="dogm_font_data_marlinH-288">  64,5,8,8,6,0,0,64,248,128,128,240,128,128,248,5,</front>
<front id="dogm_font_data_marlinH-289">  8,8,6,0,0,16,248,128,128,240,128,128,248,5,8,8,</front>
<front id="dogm_font_data_marlinH-290">  6,0,0,32,248,128,128,240,128,128,248,5,8,8,6,0,</front>
<front id="dogm_font_data_marlinH-291">  0,80,248,128,128,240,128,128,248,3,8,8,6,1,0,128,</front>
<front id="dogm_font_data_marlinH-292">  64,224,64,64,64,64,224,3,8,8,6,1,0,32,64,224,</front>
<front id="dogm_font_data_marlinH-293">  64,64,64,64,224,3,8,8,6,1,0,64,160,224,64,64,</front>
<front id="dogm_font_data_marlinH-294">  64,64,224,3,8,8,6,1,0,160,0,224,64,64,64,64,</front>
<front id="dogm_font_data_marlinH-295">  224,5,7,7,6,0,0,240,72,72,232,72,72,240,5,8,</front>
<front id="dogm_font_data_marlinH-296">  8,6,0,0,40,80,136,200,168,152,136,136,5,8,8,6,</front>
<front id="dogm_font_data_marlinH-297">  0,0,64,32,112,136,136,136,136,112,5,8,8,6,0,0,</front>
<front id="dogm_font_data_marlinH-298">  16,32,112,136,136,136,136,112,5,8,8,6,0,0,32,80,</front>
<front id="dogm_font_data_marlinH-299">  112,136,136,136,136,112,5,8,8,6,0,0,40,80,112,136,</front>
<front id="dogm_font_data_marlinH-300">  136,136,136,112,5,8,8,6,0,0,80,0,112,136,136,136,</front>
<front id="dogm_font_data_marlinH-301">  136,112,5,5,5,6,0,0,136,80,32,80,136,5,7,7,</front>
<front id="dogm_font_data_marlinH-302">  6,0,0,112,152,152,168,200,200,112,5,8,8,6,0,0,</front>
<front id="dogm_font_data_marlinH-303">  64,32,136,136,136,136,136,112,5,8,8,6,0,0,16,32,</front>
<front id="dogm_font_data_marlinH-304">  136,136,136,136,136,112,5,8,8,6,0,0,32,80,0,136,</front>
<front id="dogm_font_data_marlinH-305">  136,136,136,112,5,8,8,6,0,0,80,0,136,136,136,136,</front>
<front id="dogm_font_data_marlinH-306">  136,112,5,8,8,6,0,0,16,32,136,136,80,32,32,32,</front>
<front id="dogm_font_data_marlinH-307">  5,7,7,6,0,0,128,240,136,240,128,128,128,5,7,7,</front>
<front id="dogm_font_data_marlinH-308">  6,0,0,112,136,144,160,144,136,176,5,8,8,6,0,0,</front>
<front id="dogm_font_data_marlinH-309">  64,32,0,112,8,120,136,120,5,8,8,6,0,0,16,32,</front>
<front id="dogm_font_data_marlinH-310">  0,112,8,120,136,120,5,8,8,6,0,0,32,80,0,112,</front>
<front id="dogm_font_data_marlinH-311">  8,120,136,120,5,8,8,6,0,0,40,80,0,112,8,120,</front>
<front id="dogm_font_data_marlinH-312">  136,120,5,7,7,6,0,0,80,0,112,8,120,136,120,5,</front>
<front id="dogm_font_data_marlinH-313">  8,8,6,0,0,32,80,32,112,8,120,136,120,6,5,5,</front>
<front id="dogm_font_data_marlinH-314">  6,0,0,120,20,124,144,124,5,7,7,6,0,254,112,136,</front>
<front id="dogm_font_data_marlinH-315">  128,136,112,32,64,5,8,8,6,0,0,64,32,0,112,136,</front>
<front id="dogm_font_data_marlinH-316">  248,128,112,5,8,8,6,0,0,16,32,0,112,136,248,128,</front>
<front id="dogm_font_data_marlinH-317">  112,5,8,8,6,0,0,32,80,0,112,136,248,128,112,5,</front>
<front id="dogm_font_data_marlinH-318">  7,7,6,0,0,80,0,112,136,248,128,112,3,8,8,6,</front>
<front id="dogm_font_data_marlinH-319">  1,0,128,64,0,192,64,64,64,224,3,8,8,6,1,0,</front>
<front id="dogm_font_data_marlinH-320">  64,128,0,192,64,64,64,224,3,8,8,6,1,0,64,160,</front>
<front id="dogm_font_data_marlinH-321">  0,192,64,64,64,224,6,10,10,6,0,254,164,168,0,252,</front>
<front id="dogm_font_data_marlinH-322">  132,128,128,128,132,252,6,10,10,6,0,254,84,148,0,252,</front>
<front id="dogm_font_data_marlinH-323">  132,4,4,4,132,252,5,8,8,6,0,0,40,80,0,176,</front>
<front id="dogm_font_data_marlinH-324">  200,136,136,136,5,8,8,6,0,0,64,32,0,112,136,136,</front>
<front id="dogm_font_data_marlinH-325">  136,112,4,10,10,6,2,254,48,64,128,144,144,144,144,144,</front>
<front id="dogm_font_data_marlinH-326">  144,144,4,10,10,6,0,254,192,32,16,144,144,144,144,144,</front>
<front id="dogm_font_data_marlinH-327">  144,144,6,7,7,6,0,1,68,140,140,132,128,64,60,6,</front>
<front id="dogm_font_data_marlinH-328">  7,7,6,0,1,136,196,196,132,4,8,240,5,5,5,6,</front>
<front id="dogm_font_data_marlinH-329">  0,1,32,0,248,0,32,5,8,8,6,0,0,64,240,200,</front>
<front id="dogm_font_data_marlinH-330">  136,136,152,120,16,5,8,8,6,0,0,224,248,136,136,136,</front>
<front id="dogm_font_data_marlinH-331">  136,136,248,5,5,5,6,0,1,32,48,248,48,32,5,8,</front>
<front id="dogm_font_data_marlinH-332">  8,6,0,0,32,112,248,32,32,32,32,224,5,9,9,6,</front>
<front id="dogm_font_data_marlinH-333">  0,255,32,112,168,168,184,136,136,80,32,5,9,9,6,0,</front>
<front id="dogm_font_data_marlinH-334">  255,224,128,192,176,168,168,48,40,40,5,9,9,6,0,255,</front>
<front id="dogm_font_data_marlinH-335">  248,168,136,136,136,136,136,168,248,5,10,10,6,0,254,32,</front>
<front id="dogm_font_data_marlinH-336">  80,80,80,80,136,168,168,136,112};</front>
<front id="dogm_font_data_marlinH-337">  </front>
 </pre>
<h1>dogm_lcd_implementation.h</h1>
<pre  class="prettyprint linenums"><front id="dogm_lcd_implementationH-1">/**</front>
<front id="dogm_lcd_implementationH-2"> *dogm_lcd_implementation.h</front>
<front id="dogm_lcd_implementationH-3"> *</front>
<front id="dogm_lcd_implementationH-4"> *Graphics LCD implementation for 128x64 pixel LCDs by STB for ErikZalm/Marlin</front>
<front id="dogm_lcd_implementationH-5"> *Demonstrator: http://www.reprap.org/wiki/STB_Electronics</front>
<front id="dogm_lcd_implementationH-6"> *License: http://opensource.org/licenses/BSD-3-Clause</front>
<front id="dogm_lcd_implementationH-7"> *</front>
<front id="dogm_lcd_implementationH-8"> *With the use of:</front>
<front id="dogm_lcd_implementationH-9"> *u8glib by Oliver Kraus</front>
<front id="dogm_lcd_implementationH-10"> *http://code.google.com/p/u8glib/</front>
<front id="dogm_lcd_implementationH-11"> *License: http://opensource.org/licenses/BSD-3-Clause</front>
<front id="dogm_lcd_implementationH-12"> */</front>
<front id="dogm_lcd_implementationH-13"></front>
<front id="dogm_lcd_implementationH-14"></front>
<front id="dogm_lcd_implementationH-15">#ifndef ULTRA_LCD_IMPLEMENTATION_DOGM_H</front>
<front id="dogm_lcd_implementationH-16">#define ULTRA_LCD_IMPLEMENTATION_DOGM_H</front>
<front id="dogm_lcd_implementationH-17"></front>
<front id="dogm_lcd_implementationH-18">/**</front>
<front id="dogm_lcd_implementationH-19">* Implementation of the LCD display routines for a DOGM128 graphic display. These are common LCD 128x64 pixel graphic displays.</front>
<front id="dogm_lcd_implementationH-20">**/</front>
<front id="dogm_lcd_implementationH-21"></front>
<front id="dogm_lcd_implementationH-22">#ifdef ULTIPANEL</front>
<front id="dogm_lcd_implementationH-23">#define BLEN_A 0</front>
<front id="dogm_lcd_implementationH-24">#define BLEN_B 1</front>
<front id="dogm_lcd_implementationH-25">#define BLEN_C 2</front>
<front id="dogm_lcd_implementationH-26">#define EN_A (1&lt;&lt;BLEN_A)</front>
<front id="dogm_lcd_implementationH-27">#define EN_B (1&lt;&lt;BLEN_B)</front>
<front id="dogm_lcd_implementationH-28">#define EN_C (1&lt;&lt;BLEN_C)</front>
<front id="dogm_lcd_implementationH-29">#define encrot0 0</front>
<front id="dogm_lcd_implementationH-30">#define encrot1 2</front>
<front id="dogm_lcd_implementationH-31">#define encrot2 3</front>
<front id="dogm_lcd_implementationH-32">#define encrot3 1</front>
<front id="dogm_lcd_implementationH-33">#define LCD_CLICKED (buttons&EN_C)</front>
<front id="dogm_lcd_implementationH-34">#endif</front>
<front id="dogm_lcd_implementationH-35"></front>
<front id="dogm_lcd_implementationH-36">#include &lt;U8glib.h&gt;</front>
<front id="dogm_lcd_implementationH-37">#include "DOGMbitmaps.h"</front>
<front id="dogm_lcd_implementationH-38">#include "dogm_font_data_marlin.h"</front>
<front id="dogm_lcd_implementationH-39">#include "ultralcd.h"</front>
<front id="dogm_lcd_implementationH-40">#include "ultralcd_st7920_u8glib_rrd.h"</front>
<front id="dogm_lcd_implementationH-41"></front>
<front id="dogm_lcd_implementationH-42"></front>
<front id="dogm_lcd_implementationH-43">/* Russian language not supported yet, needs custom font</front>
<front id="dogm_lcd_implementationH-44"></front>
<front id="dogm_lcd_implementationH-45">#if LANGUAGE_CHOICE == 6</front>
<front id="dogm_lcd_implementationH-46">#include "LiquidCrystalRus.h"</front>
<front id="dogm_lcd_implementationH-47">#define LCD_CLASS LiquidCrystalRus</front>
<front id="dogm_lcd_implementationH-48">#else</front>
<front id="dogm_lcd_implementationH-49">#include &lt;LiquidCrystal.h&gt;</front>
<front id="dogm_lcd_implementationH-50">#define LCD_CLASS LiquidCrystal</front>
<front id="dogm_lcd_implementationH-51">#endif</front>
<front id="dogm_lcd_implementationH-52">*/</front>
<front id="dogm_lcd_implementationH-53"></front>
<front id="dogm_lcd_implementationH-54">// DOGM parameters (size in pixels)</front>
<front id="dogm_lcd_implementationH-55">#define DOG_CHAR_WIDTH			6</front>
<front id="dogm_lcd_implementationH-56">#define DOG_CHAR_HEIGHT			12</front>
<front id="dogm_lcd_implementationH-57">#define DOG_CHAR_WIDTH_LARGE	9</front>
<front id="dogm_lcd_implementationH-58">#define DOG_CHAR_HEIGHT_LARGE	18</front>
<front id="dogm_lcd_implementationH-59"></front>
<front id="dogm_lcd_implementationH-60"></front>
<front id="dogm_lcd_implementationH-61">#define START_ROW				0</front>
<front id="dogm_lcd_implementationH-62"></front>
<front id="dogm_lcd_implementationH-63"></front>
<front id="dogm_lcd_implementationH-64">/* Custom characters defined in font font_6x10_marlin.c */</front>
<front id="dogm_lcd_implementationH-65">#define LCD_STR_BEDTEMP     "\xFE"</front>
<front id="dogm_lcd_implementationH-66">#define LCD_STR_DEGREE      "\xB0"</front>
<front id="dogm_lcd_implementationH-67">#define LCD_STR_THERMOMETER "\xFF"</front>
<front id="dogm_lcd_implementationH-68">#define LCD_STR_UPLEVEL     "\xFB"</front>
<front id="dogm_lcd_implementationH-69">#define LCD_STR_REFRESH     "\xF8"</front>
<front id="dogm_lcd_implementationH-70">#define LCD_STR_FOLDER      "\xF9"</front>
<front id="dogm_lcd_implementationH-71">#define LCD_STR_FEEDRATE    "\xFD"</front>
<front id="dogm_lcd_implementationH-72">#define LCD_STR_CLOCK       "\xFC"</front>
<front id="dogm_lcd_implementationH-73">#define LCD_STR_ARROW_RIGHT "\xFA"</front>
<front id="dogm_lcd_implementationH-74"></front>
<front id="dogm_lcd_implementationH-75">#define FONT_STATUSMENU	u8g_font_6x9</front>
<front id="dogm_lcd_implementationH-76"></front>
<front id="dogm_lcd_implementationH-77">int lcd_contrast;</front>
<front id="dogm_lcd_implementationH-78"></front>
<front id="dogm_lcd_implementationH-79">// LCD selection</front>
<front id="dogm_lcd_implementationH-80">#ifdef U8GLIB_ST7920</front>
<front id="dogm_lcd_implementationH-81">//U8GLIB_ST7920_128X64_RRD u8g(0,0,0);</front>
<front id="dogm_lcd_implementationH-82">U8GLIB_ST7920_128X64_RRD u8g(0);</front>
<front id="dogm_lcd_implementationH-83">#elif defined(MAKRPANEL)</front>
<front id="dogm_lcd_implementationH-84">// The MaKrPanel display, ST7565 controller as well</front>
<front id="dogm_lcd_implementationH-85">U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);</front>
<front id="dogm_lcd_implementationH-86">#else</front>
<front id="dogm_lcd_implementationH-87">// for regular DOGM128 display with HW-SPI</front>
<front id="dogm_lcd_implementationH-88">U8GLIB_DOGM128 u8g(DOGLCD_CS, DOGLCD_A0);	// HW-SPI Com: CS, A0</front>
<front id="dogm_lcd_implementationH-89">#endif</front>
<front id="dogm_lcd_implementationH-90"></front>
<front id="dogm_lcd_implementationH-91">static void lcd_implementation_init()</front>
<front id="dogm_lcd_implementationH-92">{</front>
<front id="dogm_lcd_implementationH-93">#ifdef LCD_PIN_BL</front>
<front id="dogm_lcd_implementationH-94">	pinMode(LCD_PIN_BL, OUTPUT);	// Enable LCD backlight</front>
<front id="dogm_lcd_implementationH-95">	digitalWrite(LCD_PIN_BL, HIGH);</front>
<front id="dogm_lcd_implementationH-96">#endif</front>
<front id="dogm_lcd_implementationH-97"></front>
<front id="dogm_lcd_implementationH-98">        u8g.setContrast(lcd_contrast);	</front>
<front id="dogm_lcd_implementationH-99">	//  Uncomment this if you have the first generation (V1.10) of STBs board</front>
<front id="dogm_lcd_implementationH-100">	//  pinMode(17, OUTPUT);	// Enable LCD backlight</front>
<front id="dogm_lcd_implementationH-101">	//  digitalWrite(17, HIGH);</front>
<front id="dogm_lcd_implementationH-102">	</front>
<front id="dogm_lcd_implementationH-103">	u8g.firstPage();</front>
<front id="dogm_lcd_implementationH-104">	do {</front>
<front id="dogm_lcd_implementationH-105">		u8g.setFont(u8g_font_6x10_marlin);</front>
<front id="dogm_lcd_implementationH-106">		u8g.setColorIndex(1);</front>
<front id="dogm_lcd_implementationH-107">		u8g.drawBox (0, 0, u8g.getWidth(), u8g.getHeight());</front>
<front id="dogm_lcd_implementationH-108">		u8g.setColorIndex(1);</front>
<front id="dogm_lcd_implementationH-109">	   } while( u8g.nextPage() );</front>
<front id="dogm_lcd_implementationH-110"></front>
<front id="dogm_lcd_implementationH-111">#ifdef LCD_SCREEN_ROT_90</front>
<front id="dogm_lcd_implementationH-112">	u8g.setRot90();	// Rotate screen by 90</front>
<front id="dogm_lcd_implementationH-113">#endif</front>
<front id="dogm_lcd_implementationH-114"></front>
<front id="dogm_lcd_implementationH-115">#ifdef LCD_SCREEN_ROT_180</front>
<front id="dogm_lcd_implementationH-116">	u8g.setRot180();	// Rotate screen by 180</front>
<front id="dogm_lcd_implementationH-117">#endif</front>
<front id="dogm_lcd_implementationH-118"></front>
<front id="dogm_lcd_implementationH-119">#ifdef LCD_SCREEN_ROT_270</front>
<front id="dogm_lcd_implementationH-120">	u8g.setRot270();	// Rotate screen by 270</front>
<front id="dogm_lcd_implementationH-121">#endif</front>
<front id="dogm_lcd_implementationH-122"></front>
<front id="dogm_lcd_implementationH-123">   </front>
<front id="dogm_lcd_implementationH-124">	u8g.firstPage();</front>
<front id="dogm_lcd_implementationH-125">	do {</front>
<front id="dogm_lcd_implementationH-126">			// RepRap init bmp</front>
<front id="dogm_lcd_implementationH-127">			u8g.drawBitmapP(0,0,START_BMPBYTEWIDTH,START_BMPHEIGHT,start_bmp);</front>
<front id="dogm_lcd_implementationH-128">			// Welcome message</front>
<front id="dogm_lcd_implementationH-129">			u8g.setFont(u8g_font_6x10_marlin);</front>
<front id="dogm_lcd_implementationH-130">			u8g.drawStr(62,10,"MARLIN"); </front>
<front id="dogm_lcd_implementationH-131">			u8g.setFont(u8g_font_5x8);</front>
<front id="dogm_lcd_implementationH-132">			u8g.drawStr(62,19,"V1.0.0 RC2-mm");</front>
<front id="dogm_lcd_implementationH-133">			u8g.setFont(u8g_font_6x10_marlin);</front>
<front id="dogm_lcd_implementationH-134">			u8g.drawStr(62,28,"by ErikZalm");</front>
<front id="dogm_lcd_implementationH-135">			u8g.drawStr(62,41,"DOGM128 LCD");</front>
<front id="dogm_lcd_implementationH-136">			u8g.setFont(u8g_font_5x8);</front>
<front id="dogm_lcd_implementationH-137">			u8g.drawStr(62,48,"enhancements");</front>
<front id="dogm_lcd_implementationH-138">			u8g.setFont(u8g_font_5x8);</front>
<front id="dogm_lcd_implementationH-139">			u8g.drawStr(62,55,"by STB, MM");</front>
<front id="dogm_lcd_implementationH-140">			u8g.drawStr(62,61,"uses u");</front>
<front id="dogm_lcd_implementationH-141">			u8g.drawStr90(92,57,"8");</front>
<front id="dogm_lcd_implementationH-142">			u8g.drawStr(100,61,"glib");</front>
<front id="dogm_lcd_implementationH-143">	   } while( u8g.nextPage() );</front>
<front id="dogm_lcd_implementationH-144">}</front>
<front id="dogm_lcd_implementationH-145"></front>
<front id="dogm_lcd_implementationH-146">static void lcd_implementation_clear()</front>
<front id="dogm_lcd_implementationH-147">{</front>
<front id="dogm_lcd_implementationH-148">// NO NEED TO IMPLEMENT LIKE SO. Picture loop automatically clears the display.</front>
<front id="dogm_lcd_implementationH-149">//</front>
<front id="dogm_lcd_implementationH-150">// Check this article: http://arduino.cc/forum/index.php?topic=91395.25;wap2</front>
<front id="dogm_lcd_implementationH-151">//</front>
<front id="dogm_lcd_implementationH-152">//	u8g.firstPage();</front>
<front id="dogm_lcd_implementationH-153">//	do {	</front>
<front id="dogm_lcd_implementationH-154">//			u8g.setColorIndex(0);</front>
<front id="dogm_lcd_implementationH-155">//			u8g.drawBox (0, 0, u8g.getWidth(), u8g.getHeight());</front>
<front id="dogm_lcd_implementationH-156">//			u8g.setColorIndex(1);</front>
<front id="dogm_lcd_implementationH-157">//		} while( u8g.nextPage() );</front>
<front id="dogm_lcd_implementationH-158">}</front>
<front id="dogm_lcd_implementationH-159"></front>
<front id="dogm_lcd_implementationH-160">/* Arduino &lt; 1.0.0 is missing a function to print PROGMEM strings, so we need to implement our own */</front>
<front id="dogm_lcd_implementationH-161">static void lcd_printPGM(const char* str)</front>
<front id="dogm_lcd_implementationH-162">{</front>
<front id="dogm_lcd_implementationH-163">    char c;</front>
<front id="dogm_lcd_implementationH-164">    while((c = pgm_read_byte(str++)) != '\0')</front>
<front id="dogm_lcd_implementationH-165">    {</front>
<front id="dogm_lcd_implementationH-166">			u8g.print(c);</front>
<front id="dogm_lcd_implementationH-167">    }</front>
<front id="dogm_lcd_implementationH-168">}</front>
<front id="dogm_lcd_implementationH-169"></front>
<front id="dogm_lcd_implementationH-170"></front>
<front id="dogm_lcd_implementationH-171">static void lcd_implementation_status_screen()</front>
<front id="dogm_lcd_implementationH-172">{</front>
<front id="dogm_lcd_implementationH-173"></front>
<front id="dogm_lcd_implementationH-174"> static unsigned char fan_rot = 0;</front>
<front id="dogm_lcd_implementationH-175"> </front>
<front id="dogm_lcd_implementationH-176"> u8g.setColorIndex(1);	// black on white</front>
<front id="dogm_lcd_implementationH-177"> </front>
<front id="dogm_lcd_implementationH-178"> // Symbols menu graphics, animated fan</front>
<front id="dogm_lcd_implementationH-179"> if ((blink % 2) &&  fanSpeed )	u8g.drawBitmapP(9,1,STATUS_SCREENBYTEWIDTH,STATUS_SCREENHEIGHT,status_screen0_bmp);</front>
<front id="dogm_lcd_implementationH-180">	else u8g.drawBitmapP(9,1,STATUS_SCREENBYTEWIDTH,STATUS_SCREENHEIGHT,status_screen1_bmp);</front>
<front id="dogm_lcd_implementationH-181"> </front>
<front id="dogm_lcd_implementationH-182"> #ifdef SDSUPPORT</front>
<front id="dogm_lcd_implementationH-183"> //SD Card Symbol</front>
<front id="dogm_lcd_implementationH-184"> u8g.drawBox(42,42,8,7);</front>
<front id="dogm_lcd_implementationH-185"> u8g.drawBox(50,44,2,5);</front>
<front id="dogm_lcd_implementationH-186"> u8g.drawFrame(42,49,10,4);</front>
<front id="dogm_lcd_implementationH-187"> u8g.drawPixel(50,43);</front>
<front id="dogm_lcd_implementationH-188"> // Progress bar</front>
<front id="dogm_lcd_implementationH-189"> u8g.drawFrame(54,49,73,4);</front>
<front id="dogm_lcd_implementationH-190"> </front>
<front id="dogm_lcd_implementationH-191"> // SD Card Progress bar and clock</front>
<front id="dogm_lcd_implementationH-192"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-193"> </front>
<front id="dogm_lcd_implementationH-194"> if (IS_SD_PRINTING)</front>
<front id="dogm_lcd_implementationH-195">   {</front>
<front id="dogm_lcd_implementationH-196">	// Progress bar</front>
<front id="dogm_lcd_implementationH-197">	u8g.drawBox(55,50, (unsigned int)( (71 * card.percentDone())/100) ,2);</front>
<front id="dogm_lcd_implementationH-198">   }</front>
<front id="dogm_lcd_implementationH-199">    else {</front>
<front id="dogm_lcd_implementationH-200">			// do nothing</front>
<front id="dogm_lcd_implementationH-201">		 }</front>
<front id="dogm_lcd_implementationH-202"> </front>
<front id="dogm_lcd_implementationH-203"> u8g.setPrintPos(80,47);</front>
<front id="dogm_lcd_implementationH-204"> if(starttime != 0)</front>
<front id="dogm_lcd_implementationH-205">    {</front>
<front id="dogm_lcd_implementationH-206">        uint16_t time = millis()/60000 - starttime/60000;</front>
<front id="dogm_lcd_implementationH-207"></front>
<front id="dogm_lcd_implementationH-208">		u8g.print(itostr2(time/60));</front>
<front id="dogm_lcd_implementationH-209">		u8g.print(':');</front>
<front id="dogm_lcd_implementationH-210">		u8g.print(itostr2(time%60));</front>
<front id="dogm_lcd_implementationH-211">    }else{</front>
<front id="dogm_lcd_implementationH-212">			lcd_printPGM(PSTR("--:--"));</front>
<front id="dogm_lcd_implementationH-213">		 }</front>
<front id="dogm_lcd_implementationH-214"> #endif</front>
<front id="dogm_lcd_implementationH-215"> </front>
<front id="dogm_lcd_implementationH-216"> // Extruder 1</front>
<front id="dogm_lcd_implementationH-217"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-218"> u8g.setPrintPos(6,6);</front>
<front id="dogm_lcd_implementationH-219"> u8g.print(itostr3(int(degTargetHotend(0) + 0.5)));</front>
<front id="dogm_lcd_implementationH-220"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-221"> u8g.setPrintPos(6,27);</front>
<front id="dogm_lcd_implementationH-222"> u8g.print(itostr3(int(degHotend(0) + 0.5)));</front>
<front id="dogm_lcd_implementationH-223"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-224"> if (!isHeatingHotend(0)) u8g.drawBox(13,17,2,2);</front>
<front id="dogm_lcd_implementationH-225">	else</front>
<front id="dogm_lcd_implementationH-226">		{</front>
<front id="dogm_lcd_implementationH-227">		 u8g.setColorIndex(0);	// white on black</front>
<front id="dogm_lcd_implementationH-228">		 u8g.drawBox(13,17,2,2);</front>
<front id="dogm_lcd_implementationH-229">		 u8g.setColorIndex(1);	// black on white</front>
<front id="dogm_lcd_implementationH-230">		}</front>
<front id="dogm_lcd_implementationH-231"> </front>
<front id="dogm_lcd_implementationH-232"> // Extruder 2</front>
<front id="dogm_lcd_implementationH-233"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-234"> #if EXTRUDERS &gt; 1</front>
<front id="dogm_lcd_implementationH-235"> u8g.setPrintPos(31,6);</front>
<front id="dogm_lcd_implementationH-236"> u8g.print(itostr3(int(degTargetHotend(1) + 0.5)));</front>
<front id="dogm_lcd_implementationH-237"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-238"> u8g.setPrintPos(31,27);</front>
<front id="dogm_lcd_implementationH-239"> u8g.print(itostr3(int(degHotend(1) + 0.5)));</front>
<front id="dogm_lcd_implementationH-240"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-241"> if (!isHeatingHotend(1)) u8g.drawBox(38,17,2,2);</front>
<front id="dogm_lcd_implementationH-242">	else</front>
<front id="dogm_lcd_implementationH-243">		{</front>
<front id="dogm_lcd_implementationH-244">		 u8g.setColorIndex(0);	// white on black</front>
<front id="dogm_lcd_implementationH-245">		 u8g.drawBox(38,17,2,2);</front>
<front id="dogm_lcd_implementationH-246">		 u8g.setColorIndex(1);	// black on white</front>
<front id="dogm_lcd_implementationH-247">		}</front>
<front id="dogm_lcd_implementationH-248"> #else</front>
<front id="dogm_lcd_implementationH-249"> u8g.setPrintPos(31,27);</front>
<front id="dogm_lcd_implementationH-250"> u8g.print("---");</front>
<front id="dogm_lcd_implementationH-251"> #endif</front>
<front id="dogm_lcd_implementationH-252"> </front>
<front id="dogm_lcd_implementationH-253"> // Extruder 3</front>
<front id="dogm_lcd_implementationH-254"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-255"> # if EXTRUDERS &gt; 2</front>
<front id="dogm_lcd_implementationH-256"> u8g.setPrintPos(55,6);</front>
<front id="dogm_lcd_implementationH-257"> u8g.print(itostr3(int(degTargetHotend(2) + 0.5)));</front>
<front id="dogm_lcd_implementationH-258"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-259"> u8g.setPrintPos(55,27);</front>
<front id="dogm_lcd_implementationH-260"> u8g.print(itostr3(int(degHotend(2) + 0.5)));</front>
<front id="dogm_lcd_implementationH-261"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-262"> if (!isHeatingHotend(2)) u8g.drawBox(62,17,2,2);</front>
<front id="dogm_lcd_implementationH-263">	else</front>
<front id="dogm_lcd_implementationH-264">		{</front>
<front id="dogm_lcd_implementationH-265">		 u8g.setColorIndex(0);	// white on black</front>
<front id="dogm_lcd_implementationH-266">		 u8g.drawBox(62,17,2,2);</front>
<front id="dogm_lcd_implementationH-267">		 u8g.setColorIndex(1);	// black on white</front>
<front id="dogm_lcd_implementationH-268">		}</front>
<front id="dogm_lcd_implementationH-269"> #else</front>
<front id="dogm_lcd_implementationH-270"> u8g.setPrintPos(55,27);</front>
<front id="dogm_lcd_implementationH-271"> u8g.print("---");</front>
<front id="dogm_lcd_implementationH-272"> #endif</front>
<front id="dogm_lcd_implementationH-273"> </front>
<front id="dogm_lcd_implementationH-274"> // Heatbed</front>
<front id="dogm_lcd_implementationH-275"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-276"> u8g.setPrintPos(81,6);</front>
<front id="dogm_lcd_implementationH-277"> u8g.print(itostr3(int(degTargetBed() + 0.5)));</front>
<front id="dogm_lcd_implementationH-278"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-279"> u8g.setPrintPos(81,27);</front>
<front id="dogm_lcd_implementationH-280"> u8g.print(itostr3(int(degBed() + 0.5)));</front>
<front id="dogm_lcd_implementationH-281"> lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-282"> if (!isHeatingBed()) u8g.drawBox(88,18,2,2);</front>
<front id="dogm_lcd_implementationH-283">	else</front>
<front id="dogm_lcd_implementationH-284">		{</front>
<front id="dogm_lcd_implementationH-285">		 u8g.setColorIndex(0);	// white on black</front>
<front id="dogm_lcd_implementationH-286">		 u8g.drawBox(88,18,2,2);</front>
<front id="dogm_lcd_implementationH-287">		 u8g.setColorIndex(1);	// black on white</front>
<front id="dogm_lcd_implementationH-288">		}</front>
<front id="dogm_lcd_implementationH-289"> </front>
<front id="dogm_lcd_implementationH-290"> // Fan</front>
<front id="dogm_lcd_implementationH-291"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-292"> u8g.setPrintPos(104,27);</front>
<front id="dogm_lcd_implementationH-293"> #if defined(FAN_PIN) && FAN_PIN &gt; -1</front>
<front id="dogm_lcd_implementationH-294"> u8g.print(itostr3(int((fanSpeed*100)/256 + 1)));</front>
<front id="dogm_lcd_implementationH-295"> u8g.print("%");</front>
<front id="dogm_lcd_implementationH-296"> #else</front>
<front id="dogm_lcd_implementationH-297"> u8g.print("---");</front>
<front id="dogm_lcd_implementationH-298"> #endif</front>
<front id="dogm_lcd_implementationH-299"> </front>
<front id="dogm_lcd_implementationH-300"> </front>
<front id="dogm_lcd_implementationH-301"> // X, Y, Z-Coordinates</front>
<front id="dogm_lcd_implementationH-302"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-303"> u8g.drawBox(0,29,128,10);</front>
<front id="dogm_lcd_implementationH-304"> u8g.setColorIndex(0);	// white on black</front>
<front id="dogm_lcd_implementationH-305"> u8g.setPrintPos(2,37);</front>
<front id="dogm_lcd_implementationH-306"> u8g.print("X");</front>
<front id="dogm_lcd_implementationH-307"> u8g.drawPixel(8,33);</front>
<front id="dogm_lcd_implementationH-308"> u8g.drawPixel(8,35);</front>
<front id="dogm_lcd_implementationH-309"> u8g.setPrintPos(10,37);</front>
<front id="dogm_lcd_implementationH-310"> u8g.print(ftostr31ns(current_position[X_AXIS]));</front>
<front id="dogm_lcd_implementationH-311"> u8g.setPrintPos(43,37);</front>
<front id="dogm_lcd_implementationH-312"> lcd_printPGM(PSTR("Y"));</front>
<front id="dogm_lcd_implementationH-313"> u8g.drawPixel(49,33);</front>
<front id="dogm_lcd_implementationH-314"> u8g.drawPixel(49,35);</front>
<front id="dogm_lcd_implementationH-315"> u8g.setPrintPos(51,37);</front>
<front id="dogm_lcd_implementationH-316"> u8g.print(ftostr31ns(current_position[Y_AXIS]));</front>
<front id="dogm_lcd_implementationH-317"> u8g.setPrintPos(83,37);</front>
<front id="dogm_lcd_implementationH-318"> u8g.print("Z");</front>
<front id="dogm_lcd_implementationH-319"> u8g.drawPixel(89,33);</front>
<front id="dogm_lcd_implementationH-320"> u8g.drawPixel(89,35);</front>
<front id="dogm_lcd_implementationH-321"> u8g.setPrintPos(91,37);</front>
<front id="dogm_lcd_implementationH-322"> u8g.print(ftostr31(current_position[Z_AXIS]));</front>
<front id="dogm_lcd_implementationH-323"> u8g.setColorIndex(1);	// black on white</front>
<front id="dogm_lcd_implementationH-324"> </front>
<front id="dogm_lcd_implementationH-325"> // Feedrate</front>
<front id="dogm_lcd_implementationH-326"> u8g.setFont(u8g_font_6x10_marlin);</front>
<front id="dogm_lcd_implementationH-327"> u8g.setPrintPos(3,49);</front>
<front id="dogm_lcd_implementationH-328"> u8g.print(LCD_STR_FEEDRATE[0]);</front>
<front id="dogm_lcd_implementationH-329"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-330"> u8g.setPrintPos(12,48);</front>
<front id="dogm_lcd_implementationH-331"> u8g.print(itostr3(feedmultiply));</front>
<front id="dogm_lcd_implementationH-332"> u8g.print('%');</front>
<front id="dogm_lcd_implementationH-333"></front>
<front id="dogm_lcd_implementationH-334"> // Status line</front>
<front id="dogm_lcd_implementationH-335"> u8g.setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-336"> u8g.setPrintPos(0,61);</front>
<front id="dogm_lcd_implementationH-337"> u8g.print(lcd_status_message);</front>
<front id="dogm_lcd_implementationH-338"></front>
<front id="dogm_lcd_implementationH-339">}</front>
<front id="dogm_lcd_implementationH-340"></front>
<front id="dogm_lcd_implementationH-341">static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, char pre_char, char post_char)</front>
<front id="dogm_lcd_implementationH-342">{</front>
<front id="dogm_lcd_implementationH-343">    char c;</front>
<front id="dogm_lcd_implementationH-344">    </front>
<front id="dogm_lcd_implementationH-345">    uint8_t n = LCD_WIDTH - 1 - 2;</front>
<front id="dogm_lcd_implementationH-346">		</front>
<front id="dogm_lcd_implementationH-347">		if ((pre_char == '&gt;') || (pre_char == LCD_STR_UPLEVEL[0] ))</front>
<front id="dogm_lcd_implementationH-348">		   {</front>
<front id="dogm_lcd_implementationH-349">			u8g.setColorIndex(1);		// black on white</front>
<front id="dogm_lcd_implementationH-350">			u8g.drawBox (0, row*DOG_CHAR_HEIGHT + 3, 128, DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-351">			u8g.setColorIndex(0);		// following text must be white on black</front>
<front id="dogm_lcd_implementationH-352">		   } else u8g.setColorIndex(1); // unmarked text is black on white</front>
<front id="dogm_lcd_implementationH-353">		</front>
<front id="dogm_lcd_implementationH-354">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-355">		if (pre_char != '&gt;') u8g.print(pre_char); else u8g.print(' ');	// Row selector is obsolete</front>
<front id="dogm_lcd_implementationH-356"></front>
<front id="dogm_lcd_implementationH-357"></front>
<front id="dogm_lcd_implementationH-358">    while( (c = pgm_read_byte(pstr)) != '\0' )</front>
<front id="dogm_lcd_implementationH-359">    {</front>
<front id="dogm_lcd_implementationH-360">		u8g.print(c);</front>
<front id="dogm_lcd_implementationH-361">        pstr++;</front>
<front id="dogm_lcd_implementationH-362">        n--;</front>
<front id="dogm_lcd_implementationH-363">    }</front>
<front id="dogm_lcd_implementationH-364">    while(n--){</front>
<front id="dogm_lcd_implementationH-365">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-366">		}</front>
<front id="dogm_lcd_implementationH-367">	   </front>
<front id="dogm_lcd_implementationH-368">		u8g.print(post_char);</front>
<front id="dogm_lcd_implementationH-369">		u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-370">		u8g.setColorIndex(1);		// restore settings to black on white</front>
<front id="dogm_lcd_implementationH-371">}</front>
<front id="dogm_lcd_implementationH-372"></front>
<front id="dogm_lcd_implementationH-373">static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const char* pstr, char pre_char, char* data)</front>
<front id="dogm_lcd_implementationH-374">{</front>
<front id="dogm_lcd_implementationH-375">    static unsigned int fkt_cnt = 0;</front>
<front id="dogm_lcd_implementationH-376">	char c;</front>
<front id="dogm_lcd_implementationH-377">    uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);</front>
<front id="dogm_lcd_implementationH-378">		</front>
<front id="dogm_lcd_implementationH-379">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-380">		u8g.print(pre_char);</front>
<front id="dogm_lcd_implementationH-381">	</front>
<front id="dogm_lcd_implementationH-382">    while( (c = pgm_read_byte(pstr)) != '\0' )</front>
<front id="dogm_lcd_implementationH-383">    {</front>
<front id="dogm_lcd_implementationH-384">			u8g.print(c);</front>
<front id="dogm_lcd_implementationH-385">		</front>
<front id="dogm_lcd_implementationH-386">        pstr++;</front>
<front id="dogm_lcd_implementationH-387">        n--;</front>
<front id="dogm_lcd_implementationH-388">    }</front>
<front id="dogm_lcd_implementationH-389">	</front>
<front id="dogm_lcd_implementationH-390">		u8g.print(':');</front>
<front id="dogm_lcd_implementationH-391"></front>
<front id="dogm_lcd_implementationH-392">    while(n--){</front>
<front id="dogm_lcd_implementationH-393">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-394">			  }</front>
<front id="dogm_lcd_implementationH-395"></front>
<front id="dogm_lcd_implementationH-396">		u8g.print(data);</front>
<front id="dogm_lcd_implementationH-397">}</front>
<front id="dogm_lcd_implementationH-398"></front>
<front id="dogm_lcd_implementationH-399">static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, const char* pstr, char pre_char, const char* data)</front>
<front id="dogm_lcd_implementationH-400">{</front>
<front id="dogm_lcd_implementationH-401">    char c;</front>
<front id="dogm_lcd_implementationH-402">    uint8_t n= LCD_WIDTH - 1 - 2 - strlen_P(data);</front>
<front id="dogm_lcd_implementationH-403"></front>
<front id="dogm_lcd_implementationH-404">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-405">		u8g.print(pre_char);</front>
<front id="dogm_lcd_implementationH-406">	</front>
<front id="dogm_lcd_implementationH-407">    while( (c = pgm_read_byte(pstr)) != '\0' )</front>
<front id="dogm_lcd_implementationH-408">    {</front>
<front id="dogm_lcd_implementationH-409">			u8g.print(c);</front>
<front id="dogm_lcd_implementationH-410">		</front>
<front id="dogm_lcd_implementationH-411">        pstr++;</front>
<front id="dogm_lcd_implementationH-412">        n--;</front>
<front id="dogm_lcd_implementationH-413">    }</front>
<front id="dogm_lcd_implementationH-414"></front>
<front id="dogm_lcd_implementationH-415">		u8g.print(':');</front>
<front id="dogm_lcd_implementationH-416">	</front>
<front id="dogm_lcd_implementationH-417">    while(n--){</front>
<front id="dogm_lcd_implementationH-418">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-419">			  }</front>
<front id="dogm_lcd_implementationH-420"></front>
<front id="dogm_lcd_implementationH-421">		lcd_printPGM(data);</front>
<front id="dogm_lcd_implementationH-422">}</front>
<front id="dogm_lcd_implementationH-423"></front>
<front id="dogm_lcd_implementationH-424">#define lcd_implementation_drawmenu_setting_edit_int3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', itostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-425">#define lcd_implementation_drawmenu_setting_edit_int3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', itostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-426">#define lcd_implementation_drawmenu_setting_edit_float3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-427">#define lcd_implementation_drawmenu_setting_edit_float3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-428">#define lcd_implementation_drawmenu_setting_edit_float32_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr32(*(data)))</front>
<front id="dogm_lcd_implementationH-429">#define lcd_implementation_drawmenu_setting_edit_float32(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr32(*(data)))</front>
<front id="dogm_lcd_implementationH-430">#define lcd_implementation_drawmenu_setting_edit_float5_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-431">#define lcd_implementation_drawmenu_setting_edit_float5(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-432">#define lcd_implementation_drawmenu_setting_edit_float52_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr52(*(data)))</front>
<front id="dogm_lcd_implementationH-433">#define lcd_implementation_drawmenu_setting_edit_float52(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr52(*(data)))</front>
<front id="dogm_lcd_implementationH-434">#define lcd_implementation_drawmenu_setting_edit_float51_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr51(*(data)))</front>
<front id="dogm_lcd_implementationH-435">#define lcd_implementation_drawmenu_setting_edit_float51(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr51(*(data)))</front>
<front id="dogm_lcd_implementationH-436">#define lcd_implementation_drawmenu_setting_edit_long5_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-437">#define lcd_implementation_drawmenu_setting_edit_long5(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-438">#define lcd_implementation_drawmenu_setting_edit_bool_selected(row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, '&gt;', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="dogm_lcd_implementationH-439">#define lcd_implementation_drawmenu_setting_edit_bool(row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, ' ', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="dogm_lcd_implementationH-440"></front>
<front id="dogm_lcd_implementationH-441">//Add version for callback functions</front>
<front id="dogm_lcd_implementationH-442">#define lcd_implementation_drawmenu_setting_edit_callback_int3_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', itostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-443">#define lcd_implementation_drawmenu_setting_edit_callback_int3(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', itostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-444">#define lcd_implementation_drawmenu_setting_edit_callback_float3_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-445">#define lcd_implementation_drawmenu_setting_edit_callback_float3(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-446">#define lcd_implementation_drawmenu_setting_edit_callback_float32_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr32(*(data)))</front>
<front id="dogm_lcd_implementationH-447">#define lcd_implementation_drawmenu_setting_edit_callback_float32(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr32(*(data)))</front>
<front id="dogm_lcd_implementationH-448">#define lcd_implementation_drawmenu_setting_edit_callback_float5_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-449">#define lcd_implementation_drawmenu_setting_edit_callback_float5(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-450">#define lcd_implementation_drawmenu_setting_edit_callback_float52_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr52(*(data)))</front>
<front id="dogm_lcd_implementationH-451">#define lcd_implementation_drawmenu_setting_edit_callback_float52(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr52(*(data)))</front>
<front id="dogm_lcd_implementationH-452">#define lcd_implementation_drawmenu_setting_edit_callback_float51_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr51(*(data)))</front>
<front id="dogm_lcd_implementationH-453">#define lcd_implementation_drawmenu_setting_edit_callback_float51(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr51(*(data)))</front>
<front id="dogm_lcd_implementationH-454">#define lcd_implementation_drawmenu_setting_edit_callback_long5_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-455">#define lcd_implementation_drawmenu_setting_edit_callback_long5(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-456">#define lcd_implementation_drawmenu_setting_edit_callback_bool_selected(row, pstr, pstr2, data, callback) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, '&gt;', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="dogm_lcd_implementationH-457">#define lcd_implementation_drawmenu_setting_edit_callback_bool(row, pstr, pstr2, data, callback) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, ' ', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="dogm_lcd_implementationH-458"></front>
<front id="dogm_lcd_implementationH-459">void lcd_implementation_drawedit(const char* pstr, char* value)</front>
<front id="dogm_lcd_implementationH-460">{</front>
<front id="dogm_lcd_implementationH-461">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH_LARGE, (u8g.getHeight() - 1 - DOG_CHAR_HEIGHT_LARGE) - (1 * DOG_CHAR_HEIGHT_LARGE) - START_ROW );</front>
<front id="dogm_lcd_implementationH-462">		u8g.setFont(u8g_font_9x18);</front>
<front id="dogm_lcd_implementationH-463">		lcd_printPGM(pstr);</front>
<front id="dogm_lcd_implementationH-464">		u8g.print(':');</front>
<front id="dogm_lcd_implementationH-465">		u8g.setPrintPos((14 - strlen(value)) * DOG_CHAR_WIDTH_LARGE, (u8g.getHeight() - 1 - DOG_CHAR_HEIGHT_LARGE) - (1 * DOG_CHAR_HEIGHT_LARGE) - START_ROW );</front>
<front id="dogm_lcd_implementationH-466">		u8g.print(value);</front>
<front id="dogm_lcd_implementationH-467">}</front>
<front id="dogm_lcd_implementationH-468"></front>
<front id="dogm_lcd_implementationH-469">static void lcd_implementation_drawmenu_sdfile_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="dogm_lcd_implementationH-470">{</front>
<front id="dogm_lcd_implementationH-471">    char c;</front>
<front id="dogm_lcd_implementationH-472">    uint8_t n = LCD_WIDTH - 1;</front>
<front id="dogm_lcd_implementationH-473"></front>
<front id="dogm_lcd_implementationH-474">    if (longFilename[0] != '\0')</front>
<front id="dogm_lcd_implementationH-475">    {</front>
<front id="dogm_lcd_implementationH-476">        filename = longFilename;</front>
<front id="dogm_lcd_implementationH-477">        longFilename[LCD_WIDTH-1] = '\0';</front>
<front id="dogm_lcd_implementationH-478">    }</front>
<front id="dogm_lcd_implementationH-479"></front>
<front id="dogm_lcd_implementationH-480">		u8g.setColorIndex(1);		// black on white</front>
<front id="dogm_lcd_implementationH-481">		u8g.drawBox (0, row*DOG_CHAR_HEIGHT + 3, 128, DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-482">		u8g.setColorIndex(0);		// following text must be white on black</front>
<front id="dogm_lcd_implementationH-483">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-484">		u8g.print(' ');	// Indent by 1 char</front>
<front id="dogm_lcd_implementationH-485">	   </front>
<front id="dogm_lcd_implementationH-486">    while((c = *filename) != '\0')</front>
<front id="dogm_lcd_implementationH-487">    {</front>
<front id="dogm_lcd_implementationH-488">		u8g.print(c);</front>
<front id="dogm_lcd_implementationH-489">        filename++;</front>
<front id="dogm_lcd_implementationH-490">        n--;</front>
<front id="dogm_lcd_implementationH-491">    }</front>
<front id="dogm_lcd_implementationH-492">    while(n--){</front>
<front id="dogm_lcd_implementationH-493">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-494">			   }</front>
<front id="dogm_lcd_implementationH-495">	u8g.setColorIndex(1);		// black on white</front>
<front id="dogm_lcd_implementationH-496">}</front>
<front id="dogm_lcd_implementationH-497"></front>
<front id="dogm_lcd_implementationH-498">static void lcd_implementation_drawmenu_sdfile(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="dogm_lcd_implementationH-499">{</front>
<front id="dogm_lcd_implementationH-500">    char c;</front>
<front id="dogm_lcd_implementationH-501">    uint8_t n = LCD_WIDTH - 1;</front>
<front id="dogm_lcd_implementationH-502"></front>
<front id="dogm_lcd_implementationH-503">    if (longFilename[0] != '\0')</front>
<front id="dogm_lcd_implementationH-504">    {</front>
<front id="dogm_lcd_implementationH-505">        filename = longFilename;</front>
<front id="dogm_lcd_implementationH-506">        longFilename[LCD_WIDTH-1] = '\0';</front>
<front id="dogm_lcd_implementationH-507">    }</front>
<front id="dogm_lcd_implementationH-508"></front>
<front id="dogm_lcd_implementationH-509">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-510">		u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-511">		</front>
<front id="dogm_lcd_implementationH-512">while((c = *filename) != '\0')</front>
<front id="dogm_lcd_implementationH-513">    {</front>
<front id="dogm_lcd_implementationH-514">			u8g.print(c);</front>
<front id="dogm_lcd_implementationH-515">		</front>
<front id="dogm_lcd_implementationH-516">        filename++;</front>
<front id="dogm_lcd_implementationH-517">        n--;</front>
<front id="dogm_lcd_implementationH-518">    }</front>
<front id="dogm_lcd_implementationH-519">    while(n--){</front>
<front id="dogm_lcd_implementationH-520">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-521">			   }</front>
<front id="dogm_lcd_implementationH-522"></front>
<front id="dogm_lcd_implementationH-523">}</front>
<front id="dogm_lcd_implementationH-524"></front>
<front id="dogm_lcd_implementationH-525">static void lcd_implementation_drawmenu_sddirectory_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="dogm_lcd_implementationH-526">{</front>
<front id="dogm_lcd_implementationH-527">    char c;</front>
<front id="dogm_lcd_implementationH-528">    uint8_t n = LCD_WIDTH - 2;</front>
<front id="dogm_lcd_implementationH-529">		</front>
<front id="dogm_lcd_implementationH-530">    if (longFilename[0] != '\0')</front>
<front id="dogm_lcd_implementationH-531">    {</front>
<front id="dogm_lcd_implementationH-532">        filename = longFilename;</front>
<front id="dogm_lcd_implementationH-533">        longFilename[LCD_WIDTH-2] = '\0';</front>
<front id="dogm_lcd_implementationH-534">    }</front>
<front id="dogm_lcd_implementationH-535">		u8g.setColorIndex(1);		// black on white</front>
<front id="dogm_lcd_implementationH-536">		u8g.drawBox (0, row*DOG_CHAR_HEIGHT + 3, 128, DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-537">		u8g.setColorIndex(0);		// following text must be white on black</front>
<front id="dogm_lcd_implementationH-538">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-539">		u8g.print(' ');	// Indent by 1 char</front>
<front id="dogm_lcd_implementationH-540">		u8g.print(LCD_STR_FOLDER[0]);		</front>
<front id="dogm_lcd_implementationH-541">	   </front>
<front id="dogm_lcd_implementationH-542">    while((c = *filename) != '\0')</front>
<front id="dogm_lcd_implementationH-543">    {</front>
<front id="dogm_lcd_implementationH-544">			u8g.print(c);</front>
<front id="dogm_lcd_implementationH-545">		</front>
<front id="dogm_lcd_implementationH-546">        filename++;</front>
<front id="dogm_lcd_implementationH-547">        n--;</front>
<front id="dogm_lcd_implementationH-548">    }</front>
<front id="dogm_lcd_implementationH-549">    while(n--){</front>
<front id="dogm_lcd_implementationH-550">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-551">			   }</front>
<front id="dogm_lcd_implementationH-552">	u8g.setColorIndex(1);		// black on white</front>
<front id="dogm_lcd_implementationH-553">}</front>
<front id="dogm_lcd_implementationH-554"></front>
<front id="dogm_lcd_implementationH-555">static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="dogm_lcd_implementationH-556">{</front>
<front id="dogm_lcd_implementationH-557">    char c;</front>
<front id="dogm_lcd_implementationH-558">    uint8_t n = LCD_WIDTH - 2;</front>
<front id="dogm_lcd_implementationH-559"></front>
<front id="dogm_lcd_implementationH-560">    if (longFilename[0] != '\0')</front>
<front id="dogm_lcd_implementationH-561">    {</front>
<front id="dogm_lcd_implementationH-562">        filename = longFilename;</front>
<front id="dogm_lcd_implementationH-563">        longFilename[LCD_WIDTH-2] = '\0';</front>
<front id="dogm_lcd_implementationH-564">    }</front>
<front id="dogm_lcd_implementationH-565"></front>
<front id="dogm_lcd_implementationH-566">		u8g.setPrintPos(0 * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-567">		u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-568">		u8g.print(LCD_STR_FOLDER[0]);</front>
<front id="dogm_lcd_implementationH-569"></front>
<front id="dogm_lcd_implementationH-570">    while((c = *filename) != '\0')</front>
<front id="dogm_lcd_implementationH-571">    {</front>
<front id="dogm_lcd_implementationH-572">			u8g.print(c);</front>
<front id="dogm_lcd_implementationH-573">		</front>
<front id="dogm_lcd_implementationH-574">        filename++;</front>
<front id="dogm_lcd_implementationH-575">        n--;</front>
<front id="dogm_lcd_implementationH-576">    }</front>
<front id="dogm_lcd_implementationH-577">    while(n--){</front>
<front id="dogm_lcd_implementationH-578">					u8g.print(' ');</front>
<front id="dogm_lcd_implementationH-579">			   }</front>
<front id="dogm_lcd_implementationH-580">}</front>
<front id="dogm_lcd_implementationH-581"></front>
<front id="dogm_lcd_implementationH-582">#define lcd_implementation_drawmenu_back_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])</front>
<front id="dogm_lcd_implementationH-583">#define lcd_implementation_drawmenu_back(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_UPLEVEL[0])</front>
<front id="dogm_lcd_implementationH-584">#define lcd_implementation_drawmenu_submenu_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, '&gt;', LCD_STR_ARROW_RIGHT[0])</front>
<front id="dogm_lcd_implementationH-585">#define lcd_implementation_drawmenu_submenu(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_ARROW_RIGHT[0])</front>
<front id="dogm_lcd_implementationH-586">#define lcd_implementation_drawmenu_gcode_selected(row, pstr, gcode) lcd_implementation_drawmenu_generic(row, pstr, '&gt;', ' ')</front>
<front id="dogm_lcd_implementationH-587">#define lcd_implementation_drawmenu_gcode(row, pstr, gcode) lcd_implementation_drawmenu_generic(row, pstr, ' ', ' ')</front>
<front id="dogm_lcd_implementationH-588">#define lcd_implementation_drawmenu_function_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, '&gt;', ' ')</front>
<front id="dogm_lcd_implementationH-589">#define lcd_implementation_drawmenu_function(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', ' ')</front>
<front id="dogm_lcd_implementationH-590"></front>
<front id="dogm_lcd_implementationH-591">static void lcd_implementation_quick_feedback()</front>
<front id="dogm_lcd_implementationH-592">{</front>
<front id="dogm_lcd_implementationH-593"></front>
<front id="dogm_lcd_implementationH-594">#if BEEPER &gt; -1</front>
<front id="dogm_lcd_implementationH-595">    SET_OUTPUT(BEEPER);</front>
<front id="dogm_lcd_implementationH-596">    for(int8_t i=0;i&lt;10;i++)</front>
<front id="dogm_lcd_implementationH-597">    {</front>
<front id="dogm_lcd_implementationH-598">		WRITE(BEEPER,HIGH);</front>
<front id="dogm_lcd_implementationH-599">		delay(3);</front>
<front id="dogm_lcd_implementationH-600">		WRITE(BEEPER,LOW);</front>
<front id="dogm_lcd_implementationH-601">		delay(3);</front>
<front id="dogm_lcd_implementationH-602">    }</front>
<front id="dogm_lcd_implementationH-603">#endif</front>
<front id="dogm_lcd_implementationH-604">}</front>
<front id="dogm_lcd_implementationH-605">#endif//ULTRA_LCD_IMPLEMENTATION_DOGM_H</front>
<front id="dogm_lcd_implementationH-606"></front>
<front id="dogm_lcd_implementationH-607"></front>
 </pre>
<h1>DOGMbitmaps.h</h1>
<pre  class="prettyprint linenums"><front id="DOGMbitmapsH-1">#define START_BMPWIDTH 	60	//Width in pixels</front>
<front id="DOGMbitmapsH-2">#define START_BMPHEIGHT 	64	//Height in pixels</front>
<front id="DOGMbitmapsH-3">#define START_BMPBYTEWIDTH 	8	//Width in bytes</front>
<front id="DOGMbitmapsH-4">const unsigned char start_bmp[574] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="DOGMbitmapsH-5">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-6">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-7">0xFF,0xFF,0xFF,0xF9,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-8">0xFF,0xFF,0xFF,0xF0,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-9">0xFF,0xFF,0xFF,0xE0,0x7F,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-10">0xFF,0xFF,0xFF,0xC0,0x3F,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-11">0xFF,0xFF,0xFF,0x80,0x1F,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-12">0xFF,0xFF,0xFF,0x00,0x0F,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-13">0xFF,0xFF,0xFE,0x00,0x07,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-14">0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-15">0xFF,0xFF,0xF8,0x00,0x01,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-16">0xFF,0xFF,0xF0,0x00,0x00,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-17">0xFF,0xFF,0xE0,0x00,0x00,0x7F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-18">0xFF,0xFF,0xC0,0x00,0x00,0x3F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-19">0xFF,0xFF,0x80,0x00,0x00,0x3F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-20">0xFF,0xFF,0x00,0x00,0x00,0x1F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-21">0xFF,0xFE,0x00,0x00,0x00,0x0F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-22">0xFF,0xFE,0x00,0x00,0x00,0x07,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-23">0xFF,0xFC,0x00,0x00,0x00,0x07,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-24">0xFF,0xFC,0x00,0x00,0x00,0x03,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-25">0xFF,0xF8,0x00,0x00,0x00,0x03,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-26">0xFF,0xF8,0x00,0x00,0x00,0x03,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-27">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-28">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-29">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-30">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-31">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-32">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-33">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-34">0xFF,0xF8,0x00,0x00,0x00,0x01,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-35">0xFF,0xF8,0x00,0x00,0x00,0x03,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-36">0xFF,0xF8,0x00,0x00,0x00,0x03,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-37">0xFF,0xFC,0x00,0x00,0x00,0x03,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-38">0xFF,0xFC,0x00,0x00,0x00,0x07,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-39">0xFF,0xFE,0x00,0x00,0x00,0x07,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-40">0xFF,0xFE,0x00,0x00,0x00,0x0F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-41">0xFF,0xFF,0x00,0x00,0x00,0x1F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-42">0xFF,0xFF,0x80,0x00,0x00,0x1F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-43">0xFF,0xFF,0xC0,0x00,0x00,0x3F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-44">0xFF,0xFF,0xE0,0x00,0x00,0x7F,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-45">0xFF,0xFF,0xF0,0x00,0x01,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-46">0xFF,0xFF,0xFC,0x00,0x03,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-47">0xFF,0xFF,0xFF,0x00,0x1F,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-48">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-49">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-50">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-51">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-52">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-53">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-54">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-55">0x83,0xFF,0xFF,0xFE,0x0F,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-56">0x80,0xFF,0xFF,0xFE,0x03,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-57">0x88,0x7F,0xFF,0xFE,0x23,0xFF,0xFF,0xF0,</front>
<front id="DOGMbitmapsH-58">0x8C,0x70,0x38,0x0E,0x71,0x81,0xC0,0x70,</front>
<front id="DOGMbitmapsH-59">0x8C,0x60,0x38,0x0E,0x63,0x80,0xC0,0x30,</front>
<front id="DOGMbitmapsH-60">0x80,0xE3,0x19,0xC6,0x07,0xF8,0xC7,0x30,</front>
<front id="DOGMbitmapsH-61">0x80,0xE0,0x19,0xC6,0x03,0x80,0xC7,0x10,</front>
<front id="DOGMbitmapsH-62">0x8C,0x62,0x79,0xC6,0x63,0x9C,0xC7,0x30,</front>
<front id="DOGMbitmapsH-63">0x8C,0x63,0xF8,0xC6,0x71,0x18,0xC6,0x30,</front>
<front id="DOGMbitmapsH-64">0x8E,0x30,0x18,0x0E,0x71,0x80,0xC0,0x30,</front>
<front id="DOGMbitmapsH-65">0x9E,0x38,0x39,0x1E,0x79,0xC4,0xC4,0xF0,</front>
<front id="DOGMbitmapsH-66">0xFF,0xFF,0xF9,0xFF,0xFF,0xFF,0xC7,0xF0,</front>
<front id="DOGMbitmapsH-67">0xFF,0xFF,0xF9,0xFF,0xFF,0xFF,0xC7,0xF0,</front>
<front id="DOGMbitmapsH-68">0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0</front>
<front id="DOGMbitmapsH-69">};</front>
<front id="DOGMbitmapsH-70"></front>
<front id="DOGMbitmapsH-71">#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="DOGMbitmapsH-72">#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="DOGMbitmapsH-73">#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="DOGMbitmapsH-74">const unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="DOGMbitmapsH-75">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="DOGMbitmapsH-76">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="DOGMbitmapsH-77">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x0C,0x60,</front>
<front id="DOGMbitmapsH-78">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x0E,0x20,</front>
<front id="DOGMbitmapsH-79">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x0F,0x20,</front>
<front id="DOGMbitmapsH-80">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x0F,0xA0,</front>
<front id="DOGMbitmapsH-81">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,0x07,0xA0,</front>
<front id="DOGMbitmapsH-82">0x7F,0x80,0x00,0x3F,0xC0,0x00,0x3F,0xC0,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="DOGMbitmapsH-83">0xFB,0xC0,0x00,0x79,0xE0,0x00,0x79,0xE0,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="DOGMbitmapsH-84">0xF3,0xC0,0x00,0x76,0xE0,0x00,0x76,0xE0,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="DOGMbitmapsH-85">0xEB,0xC0,0x00,0x7E,0xE0,0x00,0x7E,0xE0,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="DOGMbitmapsH-86">0x7B,0x80,0x00,0x3D,0xC0,0x00,0x39,0xC0,0x00,0x82,0x08,0x00,0x5E,0x07,0xA0,</front>
<front id="DOGMbitmapsH-87">0x7B,0x80,0x00,0x3B,0xC0,0x00,0x3E,0xC0,0x01,0x04,0x10,0x00,0x5F,0x0F,0xA0,</front>
<front id="DOGMbitmapsH-88">0xFB,0xC0,0x00,0x77,0xE0,0x00,0x76,0xE0,0x01,0x04,0x10,0x00,0x4F,0x0F,0x20,</front>
<front id="DOGMbitmapsH-89">0xFB,0xC0,0x00,0x70,0xE0,0x00,0x79,0xE0,0x00,0x82,0x08,0x00,0x47,0x0E,0x20,</front>
<front id="DOGMbitmapsH-90">0xFF,0xC0,0x00,0x7F,0xE0,0x00,0x7F,0xE0,0x00,0x41,0x04,0x00,0x63,0x0C,0x60,</front>
<front id="DOGMbitmapsH-91">0x3F,0x00,0x00,0x1F,0x80,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="DOGMbitmapsH-92">0x1E,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="DOGMbitmapsH-93">0x0C,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="DOGMbitmapsH-94">};</front>
<front id="DOGMbitmapsH-95"></front>
<front id="DOGMbitmapsH-96">#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="DOGMbitmapsH-97">#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="DOGMbitmapsH-98">#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="DOGMbitmapsH-99">const unsigned char status_screen1_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="DOGMbitmapsH-100">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="DOGMbitmapsH-101">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="DOGMbitmapsH-102">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x61,0xF8,0x60,</front>
<front id="DOGMbitmapsH-103">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0xF8,0x20,</front>
<front id="DOGMbitmapsH-104">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xF0,0x20,</front>
<front id="DOGMbitmapsH-105">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x20,</front>
<front id="DOGMbitmapsH-106">0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x01,0xA0,</front>
<front id="DOGMbitmapsH-107">0x7F,0x80,0x00,0x3F,0xC0,0x00,0x3F,0xC0,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="DOGMbitmapsH-108">0xFB,0xC0,0x00,0x79,0xE0,0x00,0x79,0xE0,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="DOGMbitmapsH-109">0xF3,0xC0,0x00,0x76,0xE0,0x00,0x76,0xE0,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="DOGMbitmapsH-110">0xEB,0xC0,0x00,0x7E,0xE0,0x00,0x7E,0xE0,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="DOGMbitmapsH-111">0x7B,0x80,0x00,0x3D,0xC0,0x00,0x39,0xC0,0x00,0x82,0x08,0x00,0x58,0x01,0xA0,</front>
<front id="DOGMbitmapsH-112">0x7B,0x80,0x00,0x3B,0xC0,0x00,0x3E,0xC0,0x01,0x04,0x10,0x00,0x40,0x60,0x20,</front>
<front id="DOGMbitmapsH-113">0xFB,0xC0,0x00,0x77,0xE0,0x00,0x76,0xE0,0x01,0x04,0x10,0x00,0x40,0xF0,0x20,</front>
<front id="DOGMbitmapsH-114">0xFB,0xC0,0x00,0x70,0xE0,0x00,0x79,0xE0,0x00,0x82,0x08,0x00,0x41,0xF8,0x20,</front>
<front id="DOGMbitmapsH-115">0xFF,0xC0,0x00,0x7F,0xE0,0x00,0x7F,0xE0,0x00,0x41,0x04,0x00,0x61,0xF8,0x60,</front>
<front id="DOGMbitmapsH-116">0x3F,0x00,0x00,0x1F,0x80,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="DOGMbitmapsH-117">0x1E,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="DOGMbitmapsH-118">0x0C,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="DOGMbitmapsH-119">};</front>
<front id="DOGMbitmapsH-120"></front>
<front id="DOGMbitmapsH-121"></front>
 </pre>
<h1>fastio.h</h1>
<pre  class="prettyprint linenums"><front id="fastioH-1">/*</front>
<front id="fastioH-2">  This code contibuted by Triffid_Hunter and modified by Kliment</front>
<front id="fastioH-3">  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html</front>
<front id="fastioH-4">*/</front>
<front id="fastioH-5"></front>
<front id="fastioH-6">#ifndef	_FASTIO_ARDUINO_H</front>
<front id="fastioH-7">#define	_FASTIO_ARDUINO_H</front>
<front id="fastioH-8"></front>
<front id="fastioH-9">#include &lt;avr/io.h&gt;</front>
<front id="fastioH-10"></front>
<front id="fastioH-11">/*</front>
<front id="fastioH-12">  utility functions</front>
<front id="fastioH-13">*/</front>
<front id="fastioH-14"></front>
<front id="fastioH-15">#ifndef MASK</front>
<front id="fastioH-16">/// MASKING- returns \f$2^PIN\f$</front>
<front id="fastioH-17">#define MASK(PIN)  (1 &lt;&lt; PIN)</front>
<front id="fastioH-18">#endif</front>
<front id="fastioH-19"></front>
<front id="fastioH-20">/*</front>
<front id="fastioH-21">  magic I/O routines</front>
<front id="fastioH-22">  now you can simply SET_OUTPUT(STEP); WRITE(STEP, 1); WRITE(STEP, 0);</front>
<front id="fastioH-23">*/</front>
<front id="fastioH-24"></front>
<front id="fastioH-25">/// Read a pin</front>
<front id="fastioH-26">#define _READ(IO) ((bool)(DIO ## IO ## _RPORT & MASK(DIO ## IO ## _PIN)))</front>
<front id="fastioH-27">/// write to a pin</front>
<front id="fastioH-28">// On some boards pins &gt; 0x100 are used. These are not converted to atomic actions. An critical section is needed.</front>
<front id="fastioH-29"></front>
<front id="fastioH-30">#define _WRITE_NC(IO, v)  do { if (v) {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); } else {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }; } while (0)</front>
<front id="fastioH-31"></front>
<front id="fastioH-32">#define _WRITE_C(IO, v)   do { if (v) { \</front>
<front id="fastioH-33">                                         CRITICAL_SECTION_START; \</front>
<front id="fastioH-34">                                         {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); }\</front>
<front id="fastioH-35">                                         CRITICAL_SECTION_END; \</front>
<front id="fastioH-36">                                       }\</front>
<front id="fastioH-37">                                       else {\</front>
<front id="fastioH-38">                                         CRITICAL_SECTION_START; \</front>
<front id="fastioH-39">                                         {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }\</front>
<front id="fastioH-40">                                         CRITICAL_SECTION_END; \</front>
<front id="fastioH-41">                                       }\</front>
<front id="fastioH-42">                                     }\</front>
<front id="fastioH-43">                                     while (0)</front>
<front id="fastioH-44"></front>
<front id="fastioH-45">#define _WRITE(IO, v)  do {  if (&(DIO ##  IO ## _RPORT) &gt;= (uint8_t *)0x100) {_WRITE_C(IO, v); } else {_WRITE_NC(IO, v); }; } while (0)</front>
<front id="fastioH-46"></front>
<front id="fastioH-47">/// toggle a pin</front>
<front id="fastioH-48">#define _TOGGLE(IO)  do {DIO ##  IO ## _RPORT = MASK(DIO ## IO ## _PIN); } while (0)</front>
<front id="fastioH-49"></front>
<front id="fastioH-50">/// set pin as input</front>
<front id="fastioH-51">#define	_SET_INPUT(IO) do {DIO ##  IO ## _DDR &= ~MASK(DIO ## IO ## _PIN); } while (0)</front>
<front id="fastioH-52">/// set pin as output</front>
<front id="fastioH-53">#define	_SET_OUTPUT(IO) do {DIO ##  IO ## _DDR |=  MASK(DIO ## IO ## _PIN); } while (0)</front>
<front id="fastioH-54"></front>
<front id="fastioH-55">/// check if pin is an input</front>
<front id="fastioH-56">#define	_GET_INPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) == 0)</front>
<front id="fastioH-57">/// check if pin is an output</front>
<front id="fastioH-58">#define	_GET_OUTPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) != 0)</front>
<front id="fastioH-59"></front>
<front id="fastioH-60">/// check if pin is an timer</front>
<front id="fastioH-61">#define	_GET_TIMER(IO)  ((DIO ## IO ## _PWM)</front>
<front id="fastioH-62"></front>
<front id="fastioH-63">//  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html</front>
<front id="fastioH-64"></front>
<front id="fastioH-65">/// Read a pin wrapper</front>
<front id="fastioH-66">#define READ(IO)  _READ(IO)</front>
<front id="fastioH-67">/// Write to a pin wrapper</front>
<front id="fastioH-68">#define WRITE(IO, v)  _WRITE(IO, v)</front>
<front id="fastioH-69"></front>
<front id="fastioH-70">/// toggle a pin wrapper</front>
<front id="fastioH-71">#define TOGGLE(IO)  _TOGGLE(IO)</front>
<front id="fastioH-72"></front>
<front id="fastioH-73">/// set pin as input wrapper</front>
<front id="fastioH-74">#define SET_INPUT(IO)  _SET_INPUT(IO)</front>
<front id="fastioH-75">/// set pin as output wrapper</front>
<front id="fastioH-76">#define SET_OUTPUT(IO)  _SET_OUTPUT(IO)</front>
<front id="fastioH-77"></front>
<front id="fastioH-78">/// check if pin is an input wrapper</front>
<front id="fastioH-79">#define GET_INPUT(IO)  _GET_INPUT(IO)</front>
<front id="fastioH-80">/// check if pin is an output wrapper</front>
<front id="fastioH-81">#define GET_OUTPUT(IO)  _GET_OUTPUT(IO)</front>
<front id="fastioH-82"></front>
<front id="fastioH-83">/// check if pin is an timer wrapper</front>
<front id="fastioH-84">#define GET_TIMER(IO)  _GET_TIMER(IO)</front>
<front id="fastioH-85"></front>
<front id="fastioH-86">/*</front>
<front id="fastioH-87">	ports and functions</front>
<front id="fastioH-88"></front>
<front id="fastioH-89">	added as necessary or if I feel like it- not a comprehensive list!</front>
<front id="fastioH-90">*/</front>
<front id="fastioH-91"></front>
<front id="fastioH-92">#if defined (__AVR_ATmega168__) || defined (__AVR_ATmega328__) || defined (__AVR_ATmega328P__)</front>
<front id="fastioH-93">// UART</front>
<front id="fastioH-94">#define	RXD					DIO0</front>
<front id="fastioH-95">#define	TXD					DIO1</front>
<front id="fastioH-96"></front>
<front id="fastioH-97">// SPI</front>
<front id="fastioH-98">#define	SCK					DIO13</front>
<front id="fastioH-99">#define	MISO				DIO12</front>
<front id="fastioH-100">#define	MOSI				DIO11</front>
<front id="fastioH-101">#define	SS					DIO10</front>
<front id="fastioH-102"></front>
<front id="fastioH-103">// TWI (I2C)</front>
<front id="fastioH-104">#define	SCL					AIO5</front>
<front id="fastioH-105">#define	SDA					AIO4</front>
<front id="fastioH-106"></front>
<front id="fastioH-107">// timers and PWM</front>
<front id="fastioH-108">#define	OC0A				DIO6</front>
<front id="fastioH-109">#define	OC0B				DIO5</front>
<front id="fastioH-110">#define	OC1A				DIO9</front>
<front id="fastioH-111">#define	OC1B				DIO10</front>
<front id="fastioH-112">#define	OC2A				DIO11</front>
<front id="fastioH-113">#define	OC2B				DIO3</front>
<front id="fastioH-114"></front>
<front id="fastioH-115">#define	DEBUG_LED		AIO5</front>
<front id="fastioH-116"></front>
<front id="fastioH-117">/*</front>
<front id="fastioH-118">pins</front>
<front id="fastioH-119">*/</front>
<front id="fastioH-120"></front>
<front id="fastioH-121">#define DIO0_PIN		PIND0</front>
<front id="fastioH-122">#define DIO0_RPORT	PIND</front>
<front id="fastioH-123">#define DIO0_WPORT	PORTD</front>
<front id="fastioH-124">#define DIO0_DDR		DDRD</front>
<front id="fastioH-125">#define DIO0_PWM		NULL</front>
<front id="fastioH-126"></front>
<front id="fastioH-127">#define DIO1_PIN		PIND1</front>
<front id="fastioH-128">#define DIO1_RPORT	PIND</front>
<front id="fastioH-129">#define DIO1_WPORT	PORTD</front>
<front id="fastioH-130">#define DIO1_DDR		DDRD</front>
<front id="fastioH-131">#define DIO1_PWM		NULL</front>
<front id="fastioH-132"></front>
<front id="fastioH-133">#define DIO2_PIN		PIND2</front>
<front id="fastioH-134">#define DIO2_RPORT	PIND</front>
<front id="fastioH-135">#define DIO2_WPORT	PORTD</front>
<front id="fastioH-136">#define DIO2_DDR		DDRD</front>
<front id="fastioH-137">#define DIO2_PWM		NULL</front>
<front id="fastioH-138"></front>
<front id="fastioH-139">#define DIO3_PIN		PIND3</front>
<front id="fastioH-140">#define DIO3_RPORT	PIND</front>
<front id="fastioH-141">#define DIO3_WPORT	PORTD</front>
<front id="fastioH-142">#define DIO3_DDR		DDRD</front>
<front id="fastioH-143">#define DIO3_PWM		&OCR2B</front>
<front id="fastioH-144"></front>
<front id="fastioH-145">#define DIO4_PIN		PIND4</front>
<front id="fastioH-146">#define DIO4_RPORT	PIND</front>
<front id="fastioH-147">#define DIO4_WPORT	PORTD</front>
<front id="fastioH-148">#define DIO4_DDR		DDRD</front>
<front id="fastioH-149">#define DIO4_PWM		NULL</front>
<front id="fastioH-150"></front>
<front id="fastioH-151">#define DIO5_PIN		PIND5</front>
<front id="fastioH-152">#define DIO5_RPORT	PIND</front>
<front id="fastioH-153">#define DIO5_WPORT	PORTD</front>
<front id="fastioH-154">#define DIO5_DDR		DDRD</front>
<front id="fastioH-155">#define DIO5_PWM		&OCR0B</front>
<front id="fastioH-156"></front>
<front id="fastioH-157">#define DIO6_PIN		PIND6</front>
<front id="fastioH-158">#define DIO6_RPORT	PIND</front>
<front id="fastioH-159">#define DIO6_WPORT	PORTD</front>
<front id="fastioH-160">#define DIO6_DDR		DDRD</front>
<front id="fastioH-161">#define DIO6_PWM		&OCR0A</front>
<front id="fastioH-162"></front>
<front id="fastioH-163">#define DIO7_PIN		PIND7</front>
<front id="fastioH-164">#define DIO7_RPORT	PIND</front>
<front id="fastioH-165">#define DIO7_WPORT	PORTD</front>
<front id="fastioH-166">#define DIO7_DDR		DDRD</front>
<front id="fastioH-167">#define DIO7_PWM		NULL</front>
<front id="fastioH-168"></front>
<front id="fastioH-169">#define DIO8_PIN		PINB0</front>
<front id="fastioH-170">#define DIO8_RPORT	PINB</front>
<front id="fastioH-171">#define DIO8_WPORT	PORTB</front>
<front id="fastioH-172">#define DIO8_DDR		DDRB</front>
<front id="fastioH-173">#define DIO8_PWM		NULL</front>
<front id="fastioH-174"></front>
<front id="fastioH-175">#define DIO9_PIN		PINB1</front>
<front id="fastioH-176">#define DIO9_RPORT	PINB</front>
<front id="fastioH-177">#define DIO9_WPORT	PORTB</front>
<front id="fastioH-178">#define DIO9_DDR		DDRB</front>
<front id="fastioH-179">#define DIO9_PWM		NULL</front>
<front id="fastioH-180"></front>
<front id="fastioH-181">#define DIO10_PIN		PINB2</front>
<front id="fastioH-182">#define DIO10_RPORT	PINB</front>
<front id="fastioH-183">#define DIO10_WPORT	PORTB</front>
<front id="fastioH-184">#define DIO10_DDR		DDRB</front>
<front id="fastioH-185">#define DIO10_PWM		NULL</front>
<front id="fastioH-186"></front>
<front id="fastioH-187">#define DIO11_PIN		PINB3</front>
<front id="fastioH-188">#define DIO11_RPORT	PINB</front>
<front id="fastioH-189">#define DIO11_WPORT	PORTB</front>
<front id="fastioH-190">#define DIO11_DDR		DDRB</front>
<front id="fastioH-191">#define DIO11_PWM		&OCR2A</front>
<front id="fastioH-192"></front>
<front id="fastioH-193">#define DIO12_PIN		PINB4</front>
<front id="fastioH-194">#define DIO12_RPORT	PINB</front>
<front id="fastioH-195">#define DIO12_WPORT	PORTB</front>
<front id="fastioH-196">#define DIO12_DDR		DDRB</front>
<front id="fastioH-197">#define DIO12_PWM		NULL</front>
<front id="fastioH-198"></front>
<front id="fastioH-199">#define DIO13_PIN		PINB5</front>
<front id="fastioH-200">#define DIO13_RPORT	PINB</front>
<front id="fastioH-201">#define DIO13_WPORT	PORTB</front>
<front id="fastioH-202">#define DIO13_DDR		DDRB</front>
<front id="fastioH-203">#define DIO13_PWM		NULL</front>
<front id="fastioH-204"></front>
<front id="fastioH-205"></front>
<front id="fastioH-206">#define DIO14_PIN		PINC0</front>
<front id="fastioH-207">#define DIO14_RPORT	PINC</front>
<front id="fastioH-208">#define DIO14_WPORT	PORTC</front>
<front id="fastioH-209">#define DIO14_DDR		DDRC</front>
<front id="fastioH-210">#define DIO14_PWM		NULL</front>
<front id="fastioH-211"></front>
<front id="fastioH-212">#define DIO15_PIN		PINC1</front>
<front id="fastioH-213">#define DIO15_RPORT	PINC</front>
<front id="fastioH-214">#define DIO15_WPORT	PORTC</front>
<front id="fastioH-215">#define DIO15_DDR		DDRC</front>
<front id="fastioH-216">#define DIO15_PWM		NULL</front>
<front id="fastioH-217"></front>
<front id="fastioH-218">#define DIO16_PIN		PINC2</front>
<front id="fastioH-219">#define DIO16_RPORT	PINC</front>
<front id="fastioH-220">#define DIO16_WPORT	PORTC</front>
<front id="fastioH-221">#define DIO16_DDR		DDRC</front>
<front id="fastioH-222">#define DIO16_PWM		NULL</front>
<front id="fastioH-223"></front>
<front id="fastioH-224">#define DIO17_PIN		PINC3</front>
<front id="fastioH-225">#define DIO17_RPORT	PINC</front>
<front id="fastioH-226">#define DIO17_WPORT	PORTC</front>
<front id="fastioH-227">#define DIO17_DDR		DDRC</front>
<front id="fastioH-228">#define DIO17_PWM		NULL</front>
<front id="fastioH-229"></front>
<front id="fastioH-230">#define DIO18_PIN		PINC4</front>
<front id="fastioH-231">#define DIO18_RPORT	PINC</front>
<front id="fastioH-232">#define DIO18_WPORT	PORTC</front>
<front id="fastioH-233">#define DIO18_DDR		DDRC</front>
<front id="fastioH-234">#define DIO18_PWM		NULL</front>
<front id="fastioH-235"></front>
<front id="fastioH-236">#define DIO19_PIN		PINC5</front>
<front id="fastioH-237">#define DIO19_RPORT	PINC</front>
<front id="fastioH-238">#define DIO19_WPORT	PORTC</front>
<front id="fastioH-239">#define DIO19_DDR		DDRC</front>
<front id="fastioH-240">#define DIO19_PWM		NULL</front>
<front id="fastioH-241"></front>
<front id="fastioH-242">#define DIO20_PIN		PINC6</front>
<front id="fastioH-243">#define DIO20_RPORT	PINC</front>
<front id="fastioH-244">#define DIO20_WPORT	PORTC</front>
<front id="fastioH-245">#define DIO20_DDR		DDRC</front>
<front id="fastioH-246">#define DIO20_PWM		NULL</front>
<front id="fastioH-247"></front>
<front id="fastioH-248">#define DIO21_PIN		PINC7</front>
<front id="fastioH-249">#define DIO21_RPORT	PINC</front>
<front id="fastioH-250">#define DIO21_WPORT	PORTC</front>
<front id="fastioH-251">#define DIO21_DDR		DDRC</front>
<front id="fastioH-252">#define DIO21_PWM		NULL</front>
<front id="fastioH-253"></front>
<front id="fastioH-254"></front>
<front id="fastioH-255"></front>
<front id="fastioH-256">#undef PB0</front>
<front id="fastioH-257">#define PB0_PIN			PINB0</front>
<front id="fastioH-258">#define PB0_RPORT		PINB</front>
<front id="fastioH-259">#define PB0_WPORT		PORTB</front>
<front id="fastioH-260">#define PB0_DDR			DDRB</front>
<front id="fastioH-261">#define PB0_PWM			NULL</front>
<front id="fastioH-262"></front>
<front id="fastioH-263">#undef PB1</front>
<front id="fastioH-264">#define PB1_PIN			PINB1</front>
<front id="fastioH-265">#define PB1_RPORT		PINB</front>
<front id="fastioH-266">#define PB1_WPORT		PORTB</front>
<front id="fastioH-267">#define PB1_DDR			DDRB</front>
<front id="fastioH-268">#define PB1_PWM			NULL</front>
<front id="fastioH-269"></front>
<front id="fastioH-270">#undef PB2</front>
<front id="fastioH-271">#define PB2_PIN			PINB2</front>
<front id="fastioH-272">#define PB2_RPORT		PINB</front>
<front id="fastioH-273">#define PB2_WPORT		PORTB</front>
<front id="fastioH-274">#define PB2_DDR			DDRB</front>
<front id="fastioH-275">#define PB2_PWM			NULL</front>
<front id="fastioH-276"></front>
<front id="fastioH-277">#undef PB3</front>
<front id="fastioH-278">#define PB3_PIN			PINB3</front>
<front id="fastioH-279">#define PB3_RPORT		PINB</front>
<front id="fastioH-280">#define PB3_WPORT		PORTB</front>
<front id="fastioH-281">#define PB3_DDR			DDRB</front>
<front id="fastioH-282">#define PB3_PWM			&OCR2A</front>
<front id="fastioH-283"></front>
<front id="fastioH-284">#undef PB4</front>
<front id="fastioH-285">#define PB4_PIN			PINB4</front>
<front id="fastioH-286">#define PB4_RPORT		PINB</front>
<front id="fastioH-287">#define PB4_WPORT		PORTB</front>
<front id="fastioH-288">#define PB4_DDR			DDRB</front>
<front id="fastioH-289">#define PB4_PWM			NULL</front>
<front id="fastioH-290"></front>
<front id="fastioH-291">#undef PB5</front>
<front id="fastioH-292">#define PB5_PIN			PINB5</front>
<front id="fastioH-293">#define PB5_RPORT		PINB</front>
<front id="fastioH-294">#define PB5_WPORT		PORTB</front>
<front id="fastioH-295">#define PB5_DDR			DDRB</front>
<front id="fastioH-296">#define PB5_PWM			NULL</front>
<front id="fastioH-297"></front>
<front id="fastioH-298">#undef PB6</front>
<front id="fastioH-299">#define PB6_PIN			PINB6</front>
<front id="fastioH-300">#define PB6_RPORT		PINB</front>
<front id="fastioH-301">#define PB6_WPORT		PORTB</front>
<front id="fastioH-302">#define PB6_DDR			DDRB</front>
<front id="fastioH-303">#define PB6_PWM			NULL</front>
<front id="fastioH-304"></front>
<front id="fastioH-305">#undef PB7</front>
<front id="fastioH-306">#define PB7_PIN			PINB7</front>
<front id="fastioH-307">#define PB7_RPORT		PINB</front>
<front id="fastioH-308">#define PB7_WPORT		PORTB</front>
<front id="fastioH-309">#define PB7_DDR			DDRB</front>
<front id="fastioH-310">#define PB7_PWM			NULL</front>
<front id="fastioH-311"></front>
<front id="fastioH-312"></front>
<front id="fastioH-313">#undef PC0</front>
<front id="fastioH-314">#define PC0_PIN			PINC0</front>
<front id="fastioH-315">#define PC0_RPORT		PINC</front>
<front id="fastioH-316">#define PC0_WPORT		PORTC</front>
<front id="fastioH-317">#define PC0_DDR			DDRC</front>
<front id="fastioH-318">#define PC0_PWM			NULL</front>
<front id="fastioH-319"></front>
<front id="fastioH-320">#undef PC1</front>
<front id="fastioH-321">#define PC1_PIN			PINC1</front>
<front id="fastioH-322">#define PC1_RPORT		PINC</front>
<front id="fastioH-323">#define PC1_WPORT		PORTC</front>
<front id="fastioH-324">#define PC1_DDR			DDRC</front>
<front id="fastioH-325">#define PC1_PWM			NULL</front>
<front id="fastioH-326"></front>
<front id="fastioH-327">#undef PC2</front>
<front id="fastioH-328">#define PC2_PIN			PINC2</front>
<front id="fastioH-329">#define PC2_RPORT		PINC</front>
<front id="fastioH-330">#define PC2_WPORT		PORTC</front>
<front id="fastioH-331">#define PC2_DDR			DDRC</front>
<front id="fastioH-332">#define PC2_PWM			NULL</front>
<front id="fastioH-333"></front>
<front id="fastioH-334">#undef PC3</front>
<front id="fastioH-335">#define PC3_PIN			PINC3</front>
<front id="fastioH-336">#define PC3_RPORT		PINC</front>
<front id="fastioH-337">#define PC3_WPORT		PORTC</front>
<front id="fastioH-338">#define PC3_DDR			DDRC</front>
<front id="fastioH-339">#define PC3_PWM			NULL</front>
<front id="fastioH-340"></front>
<front id="fastioH-341">#undef PC4</front>
<front id="fastioH-342">#define PC4_PIN			PINC4</front>
<front id="fastioH-343">#define PC4_RPORT		PINC</front>
<front id="fastioH-344">#define PC4_WPORT		PORTC</front>
<front id="fastioH-345">#define PC4_DDR			DDRC</front>
<front id="fastioH-346">#define PC4_PWM			NULL</front>
<front id="fastioH-347"></front>
<front id="fastioH-348">#undef PC5</front>
<front id="fastioH-349">#define PC5_PIN			PINC5</front>
<front id="fastioH-350">#define PC5_RPORT		PINC</front>
<front id="fastioH-351">#define PC5_WPORT		PORTC</front>
<front id="fastioH-352">#define PC5_DDR			DDRC</front>
<front id="fastioH-353">#define PC5_PWM			NULL</front>
<front id="fastioH-354"></front>
<front id="fastioH-355">#undef PC6</front>
<front id="fastioH-356">#define PC6_PIN			PINC6</front>
<front id="fastioH-357">#define PC6_RPORT		PINC</front>
<front id="fastioH-358">#define PC6_WPORT		PORTC</front>
<front id="fastioH-359">#define PC6_DDR			DDRC</front>
<front id="fastioH-360">#define PC6_PWM			NULL</front>
<front id="fastioH-361"></front>
<front id="fastioH-362">#undef PC7</front>
<front id="fastioH-363">#define PC7_PIN			PINC7</front>
<front id="fastioH-364">#define PC7_RPORT		PINC</front>
<front id="fastioH-365">#define PC7_WPORT		PORTC</front>
<front id="fastioH-366">#define PC7_DDR			DDRC</front>
<front id="fastioH-367">#define PC7_PWM			NULL</front>
<front id="fastioH-368"></front>
<front id="fastioH-369"></front>
<front id="fastioH-370">#undef PD0</front>
<front id="fastioH-371">#define PD0_PIN			PIND0</front>
<front id="fastioH-372">#define PD0_RPORT		PIND</front>
<front id="fastioH-373">#define PD0_WPORT		PORTD</front>
<front id="fastioH-374">#define PD0_DDR			DDRD</front>
<front id="fastioH-375">#define PD0_PWM			NULL</front>
<front id="fastioH-376"></front>
<front id="fastioH-377">#undef PD1</front>
<front id="fastioH-378">#define PD1_PIN			PIND1</front>
<front id="fastioH-379">#define PD1_RPORT		PIND</front>
<front id="fastioH-380">#define PD1_WPORT		PORTD</front>
<front id="fastioH-381">#define PD1_DDR			DDRD</front>
<front id="fastioH-382">#define PD1_PWM			NULL</front>
<front id="fastioH-383"></front>
<front id="fastioH-384">#undef PD2</front>
<front id="fastioH-385">#define PD2_PIN			PIND2</front>
<front id="fastioH-386">#define PD2_RPORT		PIND</front>
<front id="fastioH-387">#define PD2_WPORT		PORTD</front>
<front id="fastioH-388">#define PD2_DDR			DDRD</front>
<front id="fastioH-389">#define PD2_PWM			NULL</front>
<front id="fastioH-390"></front>
<front id="fastioH-391">#undef PD3</front>
<front id="fastioH-392">#define PD3_PIN			PIND3</front>
<front id="fastioH-393">#define PD3_RPORT		PIND</front>
<front id="fastioH-394">#define PD3_WPORT		PORTD</front>
<front id="fastioH-395">#define PD3_DDR			DDRD</front>
<front id="fastioH-396">#define PD3_PWM			&OCR2B</front>
<front id="fastioH-397"></front>
<front id="fastioH-398">#undef PD4</front>
<front id="fastioH-399">#define PD4_PIN			PIND4</front>
<front id="fastioH-400">#define PD4_RPORT		PIND</front>
<front id="fastioH-401">#define PD4_WPORT		PORTD</front>
<front id="fastioH-402">#define PD4_DDR			DDRD</front>
<front id="fastioH-403">#define PD4_PWM			NULL</front>
<front id="fastioH-404"></front>
<front id="fastioH-405">#undef PD5</front>
<front id="fastioH-406">#define PD5_PIN			PIND5</front>
<front id="fastioH-407">#define PD5_RPORT		PIND</front>
<front id="fastioH-408">#define PD5_WPORT		PORTD</front>
<front id="fastioH-409">#define PD5_DDR			DDRD</front>
<front id="fastioH-410">#define PD5_PWM			&OCR0B</front>
<front id="fastioH-411"></front>
<front id="fastioH-412">#undef PD6</front>
<front id="fastioH-413">#define PD6_PIN			PIND6</front>
<front id="fastioH-414">#define PD6_RPORT		PIND</front>
<front id="fastioH-415">#define PD6_WPORT		PORTD</front>
<front id="fastioH-416">#define PD6_DDR			DDRD</front>
<front id="fastioH-417">#define PD6_PWM			&OCR0A</front>
<front id="fastioH-418"></front>
<front id="fastioH-419">#undef PD7</front>
<front id="fastioH-420">#define PD7_PIN			PIND7</front>
<front id="fastioH-421">#define PD7_RPORT		PIND</front>
<front id="fastioH-422">#define PD7_WPORT		PORTD</front>
<front id="fastioH-423">#define PD7_DDR			DDRD</front>
<front id="fastioH-424">#define PD7_PWM			NULL</front>
<front id="fastioH-425">#endif	/*	_AVR_ATmega{168,328,328P}__ */</front>
<front id="fastioH-426"></front>
<front id="fastioH-427">#if defined (__AVR_ATmega644__) || defined (__AVR_ATmega644P__) || defined (__AVR_ATmega644PA__) || defined (__AVR_ATmega1284P__)</front>
<front id="fastioH-428">// UART</front>
<front id="fastioH-429">#define	RXD					DIO8</front>
<front id="fastioH-430">#define	TXD					DIO9</front>
<front id="fastioH-431">#define	RXD0				DIO8</front>
<front id="fastioH-432">#define	TXD0				DIO9</front>
<front id="fastioH-433"></front>
<front id="fastioH-434">#define	RXD1				DIO10</front>
<front id="fastioH-435">#define	TXD1				DIO11</front>
<front id="fastioH-436"></front>
<front id="fastioH-437">// SPI</front>
<front id="fastioH-438">#define	SCK					DIO7</front>
<front id="fastioH-439">#define	MISO				DIO6</front>
<front id="fastioH-440">#define	MOSI				DIO5</front>
<front id="fastioH-441">#define	SS					DIO4</front>
<front id="fastioH-442"></front>
<front id="fastioH-443">// TWI (I2C)</front>
<front id="fastioH-444">#define	SCL					DIO16</front>
<front id="fastioH-445">#define	SDA					DIO17</front>
<front id="fastioH-446"></front>
<front id="fastioH-447">// timers and PWM</front>
<front id="fastioH-448">#define	OC0A				DIO3</front>
<front id="fastioH-449">#define	OC0B				DIO4</front>
<front id="fastioH-450">#define	OC1A				DIO13</front>
<front id="fastioH-451">#define	OC1B				DIO12</front>
<front id="fastioH-452">#define	OC2A				DIO15</front>
<front id="fastioH-453">#define	OC2B				DIO14</front>
<front id="fastioH-454"></front>
<front id="fastioH-455">#define	DEBUG_LED		DIO0</front>
<front id="fastioH-456">/*</front>
<front id="fastioH-457">pins</front>
<front id="fastioH-458">*/</front>
<front id="fastioH-459"></front>
<front id="fastioH-460">#define DIO0_PIN		PINB0</front>
<front id="fastioH-461">#define DIO0_RPORT	PINB</front>
<front id="fastioH-462">#define DIO0_WPORT	PORTB</front>
<front id="fastioH-463">#define DIO0_DDR		DDRB</front>
<front id="fastioH-464">#define DIO0_PWM		NULL</front>
<front id="fastioH-465"></front>
<front id="fastioH-466">#define DIO1_PIN		PINB1</front>
<front id="fastioH-467">#define DIO1_RPORT	PINB</front>
<front id="fastioH-468">#define DIO1_WPORT	PORTB</front>
<front id="fastioH-469">#define DIO1_DDR		DDRB</front>
<front id="fastioH-470">#define DIO1_PWM		NULL</front>
<front id="fastioH-471"></front>
<front id="fastioH-472">#define DIO2_PIN		PINB2</front>
<front id="fastioH-473">#define DIO2_RPORT	PINB</front>
<front id="fastioH-474">#define DIO2_WPORT	PORTB</front>
<front id="fastioH-475">#define DIO2_DDR		DDRB</front>
<front id="fastioH-476">#define DIO2_PWM		NULL</front>
<front id="fastioH-477"></front>
<front id="fastioH-478">#define DIO3_PIN		PINB3</front>
<front id="fastioH-479">#define DIO3_RPORT	PINB</front>
<front id="fastioH-480">#define DIO3_WPORT	PORTB</front>
<front id="fastioH-481">#define DIO3_DDR		DDRB</front>
<front id="fastioH-482">#define DIO3_PWM		OCR0A</front>
<front id="fastioH-483"></front>
<front id="fastioH-484">#define DIO4_PIN		PINB4</front>
<front id="fastioH-485">#define DIO4_RPORT	PINB</front>
<front id="fastioH-486">#define DIO4_WPORT	PORTB</front>
<front id="fastioH-487">#define DIO4_DDR		DDRB</front>
<front id="fastioH-488">#define DIO4_PWM		OCR0B</front>
<front id="fastioH-489"></front>
<front id="fastioH-490">#define DIO5_PIN		PINB5</front>
<front id="fastioH-491">#define DIO5_RPORT	PINB</front>
<front id="fastioH-492">#define DIO5_WPORT	PORTB</front>
<front id="fastioH-493">#define DIO5_DDR		DDRB</front>
<front id="fastioH-494">#define DIO5_PWM		NULL</front>
<front id="fastioH-495"></front>
<front id="fastioH-496">#define DIO6_PIN		PINB6</front>
<front id="fastioH-497">#define DIO6_RPORT	PINB</front>
<front id="fastioH-498">#define DIO6_WPORT	PORTB</front>
<front id="fastioH-499">#define DIO6_DDR		DDRB</front>
<front id="fastioH-500">#define DIO6_PWM		NULL</front>
<front id="fastioH-501"></front>
<front id="fastioH-502">#define DIO7_PIN		PINB7</front>
<front id="fastioH-503">#define DIO7_RPORT	PINB</front>
<front id="fastioH-504">#define DIO7_WPORT	PORTB</front>
<front id="fastioH-505">#define DIO7_DDR		DDRB</front>
<front id="fastioH-506">#define DIO7_PWM		NULL</front>
<front id="fastioH-507"></front>
<front id="fastioH-508">#define DIO8_PIN		PIND0</front>
<front id="fastioH-509">#define DIO8_RPORT	PIND</front>
<front id="fastioH-510">#define DIO8_WPORT	PORTD</front>
<front id="fastioH-511">#define DIO8_DDR		DDRD</front>
<front id="fastioH-512">#define DIO8_PWM		NULL</front>
<front id="fastioH-513"></front>
<front id="fastioH-514">#define DIO9_PIN		PIND1</front>
<front id="fastioH-515">#define DIO9_RPORT	PIND</front>
<front id="fastioH-516">#define DIO9_WPORT	PORTD</front>
<front id="fastioH-517">#define DIO9_DDR		DDRD</front>
<front id="fastioH-518">#define DIO9_PWM		NULL</front>
<front id="fastioH-519"></front>
<front id="fastioH-520">#define DIO10_PIN		PIND2</front>
<front id="fastioH-521">#define DIO10_RPORT	PIND</front>
<front id="fastioH-522">#define DIO10_WPORT	PORTD</front>
<front id="fastioH-523">#define DIO10_DDR		DDRD</front>
<front id="fastioH-524">#define DIO10_PWM		NULL</front>
<front id="fastioH-525"></front>
<front id="fastioH-526">#define DIO11_PIN		PIND3</front>
<front id="fastioH-527">#define DIO11_RPORT	PIND</front>
<front id="fastioH-528">#define DIO11_WPORT	PORTD</front>
<front id="fastioH-529">#define DIO11_DDR		DDRD</front>
<front id="fastioH-530">#define DIO11_PWM		NULL</front>
<front id="fastioH-531"></front>
<front id="fastioH-532">#define DIO12_PIN		PIND4</front>
<front id="fastioH-533">#define DIO12_RPORT	PIND</front>
<front id="fastioH-534">#define DIO12_WPORT	PORTD</front>
<front id="fastioH-535">#define DIO12_DDR		DDRD</front>
<front id="fastioH-536">#define DIO12_PWM		OCR1B</front>
<front id="fastioH-537"></front>
<front id="fastioH-538">#define DIO13_PIN		PIND5</front>
<front id="fastioH-539">#define DIO13_RPORT	PIND</front>
<front id="fastioH-540">#define DIO13_WPORT	PORTD</front>
<front id="fastioH-541">#define DIO13_DDR		DDRD</front>
<front id="fastioH-542">#define DIO13_PWM		OCR1A</front>
<front id="fastioH-543"></front>
<front id="fastioH-544">#define DIO14_PIN		PIND6</front>
<front id="fastioH-545">#define DIO14_RPORT	PIND</front>
<front id="fastioH-546">#define DIO14_WPORT	PORTD</front>
<front id="fastioH-547">#define DIO14_DDR		DDRD</front>
<front id="fastioH-548">#define DIO14_PWM		OCR2B</front>
<front id="fastioH-549"></front>
<front id="fastioH-550">#define DIO15_PIN		PIND7</front>
<front id="fastioH-551">#define DIO15_RPORT	PIND</front>
<front id="fastioH-552">#define DIO15_WPORT	PORTD</front>
<front id="fastioH-553">#define DIO15_DDR		DDRD</front>
<front id="fastioH-554">#define DIO15_PWM		OCR2A</front>
<front id="fastioH-555"></front>
<front id="fastioH-556">#define DIO16_PIN		PINC0</front>
<front id="fastioH-557">#define DIO16_RPORT	PINC</front>
<front id="fastioH-558">#define DIO16_WPORT	PORTC</front>
<front id="fastioH-559">#define DIO16_DDR		DDRC</front>
<front id="fastioH-560">#define DIO16_PWM		NULL</front>
<front id="fastioH-561"></front>
<front id="fastioH-562">#define DIO17_PIN		PINC1</front>
<front id="fastioH-563">#define DIO17_RPORT	PINC</front>
<front id="fastioH-564">#define DIO17_WPORT	PORTC</front>
<front id="fastioH-565">#define DIO17_DDR		DDRC</front>
<front id="fastioH-566">#define DIO17_PWM		NULL</front>
<front id="fastioH-567"></front>
<front id="fastioH-568">#define DIO18_PIN		PINC2</front>
<front id="fastioH-569">#define DIO18_RPORT	PINC</front>
<front id="fastioH-570">#define DIO18_WPORT	PORTC</front>
<front id="fastioH-571">#define DIO18_DDR		DDRC</front>
<front id="fastioH-572">#define DIO18_PWM		NULL</front>
<front id="fastioH-573"></front>
<front id="fastioH-574">#define DIO19_PIN		PINC3</front>
<front id="fastioH-575">#define DIO19_RPORT	PINC</front>
<front id="fastioH-576">#define DIO19_WPORT	PORTC</front>
<front id="fastioH-577">#define DIO19_DDR		DDRC</front>
<front id="fastioH-578">#define DIO19_PWM		NULL</front>
<front id="fastioH-579"></front>
<front id="fastioH-580">#define DIO20_PIN		PINC4</front>
<front id="fastioH-581">#define DIO20_RPORT	PINC</front>
<front id="fastioH-582">#define DIO20_WPORT	PORTC</front>
<front id="fastioH-583">#define DIO20_DDR		DDRC</front>
<front id="fastioH-584">#define DIO20_PWM		NULL</front>
<front id="fastioH-585"></front>
<front id="fastioH-586">#define DIO21_PIN		PINC5</front>
<front id="fastioH-587">#define DIO21_RPORT	PINC</front>
<front id="fastioH-588">#define DIO21_WPORT	PORTC</front>
<front id="fastioH-589">#define DIO21_DDR		DDRC</front>
<front id="fastioH-590">#define DIO21_PWM		NULL</front>
<front id="fastioH-591"></front>
<front id="fastioH-592">#define DIO22_PIN		PINC6</front>
<front id="fastioH-593">#define DIO22_RPORT	PINC</front>
<front id="fastioH-594">#define DIO22_WPORT	PORTC</front>
<front id="fastioH-595">#define DIO22_DDR		DDRC</front>
<front id="fastioH-596">#define DIO22_PWM		NULL</front>
<front id="fastioH-597"></front>
<front id="fastioH-598">#define DIO23_PIN		PINC7</front>
<front id="fastioH-599">#define DIO23_RPORT	PINC</front>
<front id="fastioH-600">#define DIO23_WPORT	PORTC</front>
<front id="fastioH-601">#define DIO23_DDR		DDRC</front>
<front id="fastioH-602">#define DIO23_PWM		NULL</front>
<front id="fastioH-603"></front>
<front id="fastioH-604">#define DIO24_PIN		PINA7</front>
<front id="fastioH-605">#define DIO24_RPORT	PINA</front>
<front id="fastioH-606">#define DIO24_WPORT	PORTA</front>
<front id="fastioH-607">#define DIO24_DDR		DDRA</front>
<front id="fastioH-608">#define DIO24_PWM		NULL</front>
<front id="fastioH-609"></front>
<front id="fastioH-610">#define DIO25_PIN		PINA6</front>
<front id="fastioH-611">#define DIO25_RPORT	PINA</front>
<front id="fastioH-612">#define DIO25_WPORT	PORTA</front>
<front id="fastioH-613">#define DIO25_DDR		DDRA</front>
<front id="fastioH-614">#define DIO25_PWM		NULL</front>
<front id="fastioH-615"></front>
<front id="fastioH-616">#define DIO26_PIN		PINA5</front>
<front id="fastioH-617">#define DIO26_RPORT	PINA</front>
<front id="fastioH-618">#define DIO26_WPORT	PORTA</front>
<front id="fastioH-619">#define DIO26_DDR		DDRA</front>
<front id="fastioH-620">#define DIO26_PWM		NULL</front>
<front id="fastioH-621"></front>
<front id="fastioH-622">#define DIO27_PIN		PINA4</front>
<front id="fastioH-623">#define DIO27_RPORT	PINA</front>
<front id="fastioH-624">#define DIO27_WPORT	PORTA</front>
<front id="fastioH-625">#define DIO27_DDR		DDRA</front>
<front id="fastioH-626">#define DIO27_PWM		NULL</front>
<front id="fastioH-627"></front>
<front id="fastioH-628">#define DIO28_PIN		PINA3</front>
<front id="fastioH-629">#define DIO28_RPORT	PINA</front>
<front id="fastioH-630">#define DIO28_WPORT	PORTA</front>
<front id="fastioH-631">#define DIO28_DDR		DDRA</front>
<front id="fastioH-632">#define DIO28_PWM		NULL</front>
<front id="fastioH-633"></front>
<front id="fastioH-634">#define DIO29_PIN		PINA2</front>
<front id="fastioH-635">#define DIO29_RPORT	PINA</front>
<front id="fastioH-636">#define DIO29_WPORT	PORTA</front>
<front id="fastioH-637">#define DIO29_DDR		DDRA</front>
<front id="fastioH-638">#define DIO29_PWM		NULL</front>
<front id="fastioH-639"></front>
<front id="fastioH-640">#define DIO30_PIN		PINA1</front>
<front id="fastioH-641">#define DIO30_RPORT	PINA</front>
<front id="fastioH-642">#define DIO30_WPORT	PORTA</front>
<front id="fastioH-643">#define DIO30_DDR		DDRA</front>
<front id="fastioH-644">#define DIO30_PWM		NULL</front>
<front id="fastioH-645"></front>
<front id="fastioH-646">#define DIO31_PIN		PINA0</front>
<front id="fastioH-647">#define DIO31_RPORT	PINA</front>
<front id="fastioH-648">#define DIO31_WPORT	PORTA</front>
<front id="fastioH-649">#define DIO31_DDR		DDRA</front>
<front id="fastioH-650">#define DIO31_PWM		NULL</front>
<front id="fastioH-651"></front>
<front id="fastioH-652">#define AIO0_PIN		PINA0</front>
<front id="fastioH-653">#define AIO0_RPORT	PINA</front>
<front id="fastioH-654">#define AIO0_WPORT	PORTA</front>
<front id="fastioH-655">#define AIO0_DDR		DDRA</front>
<front id="fastioH-656">#define AIO0_PWM		NULL</front>
<front id="fastioH-657"></front>
<front id="fastioH-658">#define AIO1_PIN		PINA1</front>
<front id="fastioH-659">#define AIO1_RPORT	PINA</front>
<front id="fastioH-660">#define AIO1_WPORT	PORTA</front>
<front id="fastioH-661">#define AIO1_DDR		DDRA</front>
<front id="fastioH-662">#define AIO1_PWM		NULL</front>
<front id="fastioH-663"></front>
<front id="fastioH-664">#define AIO2_PIN		PINA2</front>
<front id="fastioH-665">#define AIO2_RPORT	PINA</front>
<front id="fastioH-666">#define AIO2_WPORT	PORTA</front>
<front id="fastioH-667">#define AIO2_DDR		DDRA</front>
<front id="fastioH-668">#define AIO2_PWM		NULL</front>
<front id="fastioH-669"></front>
<front id="fastioH-670">#define AIO3_PIN		PINA3</front>
<front id="fastioH-671">#define AIO3_RPORT	PINA</front>
<front id="fastioH-672">#define AIO3_WPORT	PORTA</front>
<front id="fastioH-673">#define AIO3_DDR		DDRA</front>
<front id="fastioH-674">#define AIO3_PWM		NULL</front>
<front id="fastioH-675"></front>
<front id="fastioH-676">#define AIO4_PIN		PINA4</front>
<front id="fastioH-677">#define AIO4_RPORT	PINA</front>
<front id="fastioH-678">#define AIO4_WPORT	PORTA</front>
<front id="fastioH-679">#define AIO4_DDR		DDRA</front>
<front id="fastioH-680">#define AIO4_PWM		NULL</front>
<front id="fastioH-681"></front>
<front id="fastioH-682">#define AIO5_PIN		PINA5</front>
<front id="fastioH-683">#define AIO5_RPORT	PINA</front>
<front id="fastioH-684">#define AIO5_WPORT	PORTA</front>
<front id="fastioH-685">#define AIO5_DDR		DDRA</front>
<front id="fastioH-686">#define AIO5_PWM		NULL</front>
<front id="fastioH-687"></front>
<front id="fastioH-688">#define AIO6_PIN		PINA6</front>
<front id="fastioH-689">#define AIO6_RPORT	PINA</front>
<front id="fastioH-690">#define AIO6_WPORT	PORTA</front>
<front id="fastioH-691">#define AIO6_DDR		DDRA</front>
<front id="fastioH-692">#define AIO6_PWM		NULL</front>
<front id="fastioH-693"></front>
<front id="fastioH-694">#define AIO7_PIN		PINA7</front>
<front id="fastioH-695">#define AIO7_RPORT	PINA</front>
<front id="fastioH-696">#define AIO7_WPORT	PORTA</front>
<front id="fastioH-697">#define AIO7_DDR		DDRA</front>
<front id="fastioH-698">#define AIO7_PWM		NULL</front>
<front id="fastioH-699"></front>
<front id="fastioH-700"></front>
<front id="fastioH-701"></front>
<front id="fastioH-702">#undef PA0</front>
<front id="fastioH-703">#define PA0_PIN			PINA0</front>
<front id="fastioH-704">#define PA0_RPORT		PINA</front>
<front id="fastioH-705">#define PA0_WPORT		PORTA</front>
<front id="fastioH-706">#define PA0_DDR			DDRA</front>
<front id="fastioH-707">#define PA0_PWM			NULL</front>
<front id="fastioH-708"></front>
<front id="fastioH-709">#undef PA1</front>
<front id="fastioH-710">#define PA1_PIN			PINA1</front>
<front id="fastioH-711">#define PA1_RPORT		PINA</front>
<front id="fastioH-712">#define PA1_WPORT		PORTA</front>
<front id="fastioH-713">#define PA1_DDR			DDRA</front>
<front id="fastioH-714">#define PA1_PWM			NULL</front>
<front id="fastioH-715"></front>
<front id="fastioH-716">#undef PA2</front>
<front id="fastioH-717">#define PA2_PIN			PINA2</front>
<front id="fastioH-718">#define PA2_RPORT		PINA</front>
<front id="fastioH-719">#define PA2_WPORT		PORTA</front>
<front id="fastioH-720">#define PA2_DDR			DDRA</front>
<front id="fastioH-721">#define PA2_PWM			NULL</front>
<front id="fastioH-722"></front>
<front id="fastioH-723">#undef PA3</front>
<front id="fastioH-724">#define PA3_PIN			PINA3</front>
<front id="fastioH-725">#define PA3_RPORT		PINA</front>
<front id="fastioH-726">#define PA3_WPORT		PORTA</front>
<front id="fastioH-727">#define PA3_DDR			DDRA</front>
<front id="fastioH-728">#define PA3_PWM			NULL</front>
<front id="fastioH-729"></front>
<front id="fastioH-730">#undef PA4</front>
<front id="fastioH-731">#define PA4_PIN			PINA4</front>
<front id="fastioH-732">#define PA4_RPORT		PINA</front>
<front id="fastioH-733">#define PA4_WPORT		PORTA</front>
<front id="fastioH-734">#define PA4_DDR			DDRA</front>
<front id="fastioH-735">#define PA4_PWM			NULL</front>
<front id="fastioH-736"></front>
<front id="fastioH-737">#undef PA5</front>
<front id="fastioH-738">#define PA5_PIN			PINA5</front>
<front id="fastioH-739">#define PA5_RPORT		PINA</front>
<front id="fastioH-740">#define PA5_WPORT		PORTA</front>
<front id="fastioH-741">#define PA5_DDR			DDRA</front>
<front id="fastioH-742">#define PA5_PWM			NULL</front>
<front id="fastioH-743"></front>
<front id="fastioH-744">#undef PA6</front>
<front id="fastioH-745">#define PA6_PIN			PINA6</front>
<front id="fastioH-746">#define PA6_RPORT		PINA</front>
<front id="fastioH-747">#define PA6_WPORT		PORTA</front>
<front id="fastioH-748">#define PA6_DDR			DDRA</front>
<front id="fastioH-749">#define PA6_PWM			NULL</front>
<front id="fastioH-750"></front>
<front id="fastioH-751">#undef PA7</front>
<front id="fastioH-752">#define PA7_PIN			PINA7</front>
<front id="fastioH-753">#define PA7_RPORT		PINA</front>
<front id="fastioH-754">#define PA7_WPORT		PORTA</front>
<front id="fastioH-755">#define PA7_DDR			DDRA</front>
<front id="fastioH-756">#define PA7_PWM			NULL</front>
<front id="fastioH-757"></front>
<front id="fastioH-758"></front>
<front id="fastioH-759">#undef PB0</front>
<front id="fastioH-760">#define PB0_PIN			PINB0</front>
<front id="fastioH-761">#define PB0_RPORT		PINB</front>
<front id="fastioH-762">#define PB0_WPORT		PORTB</front>
<front id="fastioH-763">#define PB0_DDR			DDRB</front>
<front id="fastioH-764">#define PB0_PWM			NULL</front>
<front id="fastioH-765"></front>
<front id="fastioH-766">#undef PB1</front>
<front id="fastioH-767">#define PB1_PIN			PINB1</front>
<front id="fastioH-768">#define PB1_RPORT		PINB</front>
<front id="fastioH-769">#define PB1_WPORT		PORTB</front>
<front id="fastioH-770">#define PB1_DDR			DDRB</front>
<front id="fastioH-771">#define PB1_PWM			NULL</front>
<front id="fastioH-772"></front>
<front id="fastioH-773">#undef PB2</front>
<front id="fastioH-774">#define PB2_PIN			PINB2</front>
<front id="fastioH-775">#define PB2_RPORT		PINB</front>
<front id="fastioH-776">#define PB2_WPORT		PORTB</front>
<front id="fastioH-777">#define PB2_DDR			DDRB</front>
<front id="fastioH-778">#define PB2_PWM			NULL</front>
<front id="fastioH-779"></front>
<front id="fastioH-780">#undef PB3</front>
<front id="fastioH-781">#define PB3_PIN			PINB3</front>
<front id="fastioH-782">#define PB3_RPORT		PINB</front>
<front id="fastioH-783">#define PB3_WPORT		PORTB</front>
<front id="fastioH-784">#define PB3_DDR			DDRB</front>
<front id="fastioH-785">#define PB3_PWM			OCR0A</front>
<front id="fastioH-786"></front>
<front id="fastioH-787">#undef PB4</front>
<front id="fastioH-788">#define PB4_PIN			PINB4</front>
<front id="fastioH-789">#define PB4_RPORT		PINB</front>
<front id="fastioH-790">#define PB4_WPORT		PORTB</front>
<front id="fastioH-791">#define PB4_DDR			DDRB</front>
<front id="fastioH-792">#define PB4_PWM			OCR0B</front>
<front id="fastioH-793"></front>
<front id="fastioH-794">#undef PB5</front>
<front id="fastioH-795">#define PB5_PIN			PINB5</front>
<front id="fastioH-796">#define PB5_RPORT		PINB</front>
<front id="fastioH-797">#define PB5_WPORT		PORTB</front>
<front id="fastioH-798">#define PB5_DDR			DDRB</front>
<front id="fastioH-799">#define PB5_PWM			NULL</front>
<front id="fastioH-800"></front>
<front id="fastioH-801">#undef PB6</front>
<front id="fastioH-802">#define PB6_PIN			PINB6</front>
<front id="fastioH-803">#define PB6_RPORT		PINB</front>
<front id="fastioH-804">#define PB6_WPORT		PORTB</front>
<front id="fastioH-805">#define PB6_DDR			DDRB</front>
<front id="fastioH-806">#define PB6_PWM			NULL</front>
<front id="fastioH-807"></front>
<front id="fastioH-808">#undef PB7</front>
<front id="fastioH-809">#define PB7_PIN			PINB7</front>
<front id="fastioH-810">#define PB7_RPORT		PINB</front>
<front id="fastioH-811">#define PB7_WPORT		PORTB</front>
<front id="fastioH-812">#define PB7_DDR			DDRB</front>
<front id="fastioH-813">#define PB7_PWM			NULL</front>
<front id="fastioH-814"></front>
<front id="fastioH-815"></front>
<front id="fastioH-816">#undef PC0</front>
<front id="fastioH-817">#define PC0_PIN			PINC0</front>
<front id="fastioH-818">#define PC0_RPORT		PINC</front>
<front id="fastioH-819">#define PC0_WPORT		PORTC</front>
<front id="fastioH-820">#define PC0_DDR			DDRC</front>
<front id="fastioH-821">#define PC0_PWM			NULL</front>
<front id="fastioH-822"></front>
<front id="fastioH-823">#undef PC1</front>
<front id="fastioH-824">#define PC1_PIN			PINC1</front>
<front id="fastioH-825">#define PC1_RPORT		PINC</front>
<front id="fastioH-826">#define PC1_WPORT		PORTC</front>
<front id="fastioH-827">#define PC1_DDR			DDRC</front>
<front id="fastioH-828">#define PC1_PWM			NULL</front>
<front id="fastioH-829"></front>
<front id="fastioH-830">#undef PC2</front>
<front id="fastioH-831">#define PC2_PIN			PINC2</front>
<front id="fastioH-832">#define PC2_RPORT		PINC</front>
<front id="fastioH-833">#define PC2_WPORT		PORTC</front>
<front id="fastioH-834">#define PC2_DDR			DDRC</front>
<front id="fastioH-835">#define PC2_PWM			NULL</front>
<front id="fastioH-836"></front>
<front id="fastioH-837">#undef PC3</front>
<front id="fastioH-838">#define PC3_PIN			PINC3</front>
<front id="fastioH-839">#define PC3_RPORT		PINC</front>
<front id="fastioH-840">#define PC3_WPORT		PORTC</front>
<front id="fastioH-841">#define PC3_DDR			DDRC</front>
<front id="fastioH-842">#define PC3_PWM			NULL</front>
<front id="fastioH-843"></front>
<front id="fastioH-844">#undef PC4</front>
<front id="fastioH-845">#define PC4_PIN			PINC4</front>
<front id="fastioH-846">#define PC4_RPORT		PINC</front>
<front id="fastioH-847">#define PC4_WPORT		PORTC</front>
<front id="fastioH-848">#define PC4_DDR			DDRC</front>
<front id="fastioH-849">#define PC4_PWM			NULL</front>
<front id="fastioH-850"></front>
<front id="fastioH-851">#undef PC5</front>
<front id="fastioH-852">#define PC5_PIN			PINC5</front>
<front id="fastioH-853">#define PC5_RPORT		PINC</front>
<front id="fastioH-854">#define PC5_WPORT		PORTC</front>
<front id="fastioH-855">#define PC5_DDR			DDRC</front>
<front id="fastioH-856">#define PC5_PWM			NULL</front>
<front id="fastioH-857"></front>
<front id="fastioH-858">#undef PC6</front>
<front id="fastioH-859">#define PC6_PIN			PINC6</front>
<front id="fastioH-860">#define PC6_RPORT		PINC</front>
<front id="fastioH-861">#define PC6_WPORT		PORTC</front>
<front id="fastioH-862">#define PC6_DDR			DDRC</front>
<front id="fastioH-863">#define PC6_PWM			NULL</front>
<front id="fastioH-864"></front>
<front id="fastioH-865">#undef PC7</front>
<front id="fastioH-866">#define PC7_PIN			PINC7</front>
<front id="fastioH-867">#define PC7_RPORT		PINC</front>
<front id="fastioH-868">#define PC7_WPORT		PORTC</front>
<front id="fastioH-869">#define PC7_DDR			DDRC</front>
<front id="fastioH-870">#define PC7_PWM			NULL</front>
<front id="fastioH-871"></front>
<front id="fastioH-872"></front>
<front id="fastioH-873">#undef PD0</front>
<front id="fastioH-874">#define PD0_PIN			PIND0</front>
<front id="fastioH-875">#define PD0_RPORT		PIND</front>
<front id="fastioH-876">#define PD0_WPORT		PORTD</front>
<front id="fastioH-877">#define PD0_DDR			DDRD</front>
<front id="fastioH-878">#define PD0_PWM			NULL</front>
<front id="fastioH-879"></front>
<front id="fastioH-880">#undef PD1</front>
<front id="fastioH-881">#define PD1_PIN			PIND1</front>
<front id="fastioH-882">#define PD1_RPORT		PIND</front>
<front id="fastioH-883">#define PD1_WPORT		PORTD</front>
<front id="fastioH-884">#define PD1_DDR			DDRD</front>
<front id="fastioH-885">#define PD1_PWM			NULL</front>
<front id="fastioH-886"></front>
<front id="fastioH-887">#undef PD2</front>
<front id="fastioH-888">#define PD2_PIN			PIND2</front>
<front id="fastioH-889">#define PD2_RPORT		PIND</front>
<front id="fastioH-890">#define PD2_WPORT		PORTD</front>
<front id="fastioH-891">#define PD2_DDR			DDRD</front>
<front id="fastioH-892">#define PD2_PWM			NULL</front>
<front id="fastioH-893"></front>
<front id="fastioH-894">#undef PD3</front>
<front id="fastioH-895">#define PD3_PIN			PIND3</front>
<front id="fastioH-896">#define PD3_RPORT		PIND</front>
<front id="fastioH-897">#define PD3_WPORT		PORTD</front>
<front id="fastioH-898">#define PD3_DDR			DDRD</front>
<front id="fastioH-899">#define PD3_PWM			NULL</front>
<front id="fastioH-900"></front>
<front id="fastioH-901">#undef PD4</front>
<front id="fastioH-902">#define PD4_PIN			PIND4</front>
<front id="fastioH-903">#define PD4_RPORT		PIND</front>
<front id="fastioH-904">#define PD4_WPORT		PORTD</front>
<front id="fastioH-905">#define PD4_DDR			DDRD</front>
<front id="fastioH-906">#define PD4_PWM			NULL</front>
<front id="fastioH-907"></front>
<front id="fastioH-908">#undef PD5</front>
<front id="fastioH-909">#define PD5_PIN			PIND5</front>
<front id="fastioH-910">#define PD5_RPORT		PIND</front>
<front id="fastioH-911">#define PD5_WPORT		PORTD</front>
<front id="fastioH-912">#define PD5_DDR			DDRD</front>
<front id="fastioH-913">#define PD5_PWM			NULL</front>
<front id="fastioH-914"></front>
<front id="fastioH-915">#undef PD6</front>
<front id="fastioH-916">#define PD6_PIN			PIND6</front>
<front id="fastioH-917">#define PD6_RPORT		PIND</front>
<front id="fastioH-918">#define PD6_WPORT		PORTD</front>
<front id="fastioH-919">#define PD6_DDR			DDRD</front>
<front id="fastioH-920">#define PD6_PWM			OCR2B</front>
<front id="fastioH-921"></front>
<front id="fastioH-922">#undef PD7</front>
<front id="fastioH-923">#define PD7_PIN			PIND7</front>
<front id="fastioH-924">#define PD7_RPORT		PIND</front>
<front id="fastioH-925">#define PD7_WPORT		PORTD</front>
<front id="fastioH-926">#define PD7_DDR			DDRD</front>
<front id="fastioH-927">#define PD7_PWM			OCR2A</front>
<front id="fastioH-928">#endif	/*	_AVR_ATmega{644,644P,644PA}__ */</front>
<front id="fastioH-929"></front>
<front id="fastioH-930">#if defined (__AVR_ATmega1280__) || defined (__AVR_ATmega2560__)</front>
<front id="fastioH-931">// UART</front>
<front id="fastioH-932">#define	RXD					DIO0</front>
<front id="fastioH-933">#define	TXD					DIO1</front>
<front id="fastioH-934"></front>
<front id="fastioH-935">// SPI</front>
<front id="fastioH-936">#define	SCK					DIO52</front>
<front id="fastioH-937">#define	MISO				DIO50</front>
<front id="fastioH-938">#define	MOSI				DIO51</front>
<front id="fastioH-939">#define	SS					DIO53</front>
<front id="fastioH-940"></front>
<front id="fastioH-941">// TWI (I2C)</front>
<front id="fastioH-942">#define	SCL					DIO21</front>
<front id="fastioH-943">#define	SDA					DIO20</front>
<front id="fastioH-944"></front>
<front id="fastioH-945">// timers and PWM</front>
<front id="fastioH-946">#define	OC0A				DIO13</front>
<front id="fastioH-947">#define	OC0B				DIO4</front>
<front id="fastioH-948">#define	OC1A				DIO11</front>
<front id="fastioH-949">#define	OC1B				DIO12</front>
<front id="fastioH-950">#define	OC2A				DIO10</front>
<front id="fastioH-951">#define	OC2B				DIO9</front>
<front id="fastioH-952">#define	OC3A				DIO5</front>
<front id="fastioH-953">#define	OC3B				DIO2</front>
<front id="fastioH-954">#define	OC3C				DIO3</front>
<front id="fastioH-955">#define	OC4A				DIO6</front>
<front id="fastioH-956">#define	OC4B				DIO7</front>
<front id="fastioH-957">#define	OC4C				DIO8</front>
<front id="fastioH-958">#define	OC5A				DIO46</front>
<front id="fastioH-959">#define	OC5B				DIO45</front>
<front id="fastioH-960">#define	OC5C				DIO44</front>
<front id="fastioH-961"></front>
<front id="fastioH-962">// change for your board</front>
<front id="fastioH-963">#define	DEBUG_LED		DIO21</front>
<front id="fastioH-964"></front>
<front id="fastioH-965">/*</front>
<front id="fastioH-966">pins</front>
<front id="fastioH-967">*/</front>
<front id="fastioH-968">#define	DIO0_PIN		PINE0</front>
<front id="fastioH-969">#define	DIO0_RPORT	PINE</front>
<front id="fastioH-970">#define	DIO0_WPORT	PORTE</front>
<front id="fastioH-971">#define	DIO0_DDR		DDRE</front>
<front id="fastioH-972">#define DIO0_PWM		NULL</front>
<front id="fastioH-973"></front>
<front id="fastioH-974">#define	DIO1_PIN		PINE1</front>
<front id="fastioH-975">#define	DIO1_RPORT	PINE</front>
<front id="fastioH-976">#define	DIO1_WPORT	PORTE</front>
<front id="fastioH-977">#define	DIO1_DDR		DDRE</front>
<front id="fastioH-978">#define DIO1_PWM		NULL</front>
<front id="fastioH-979"></front>
<front id="fastioH-980">#define	DIO2_PIN		PINE4</front>
<front id="fastioH-981">#define	DIO2_RPORT	PINE</front>
<front id="fastioH-982">#define	DIO2_WPORT	PORTE</front>
<front id="fastioH-983">#define	DIO2_DDR		DDRE</front>
<front id="fastioH-984">#define DIO2_PWM		&OCR3BL</front>
<front id="fastioH-985"></front>
<front id="fastioH-986">#define	DIO3_PIN		PINE5</front>
<front id="fastioH-987">#define	DIO3_RPORT	PINE</front>
<front id="fastioH-988">#define	DIO3_WPORT	PORTE</front>
<front id="fastioH-989">#define	DIO3_DDR		DDRE</front>
<front id="fastioH-990">#define DIO3_PWM		&OCR3CL</front>
<front id="fastioH-991"></front>
<front id="fastioH-992">#define	DIO4_PIN		PING5</front>
<front id="fastioH-993">#define	DIO4_RPORT	PING</front>
<front id="fastioH-994">#define	DIO4_WPORT	PORTG</front>
<front id="fastioH-995">#define	DIO4_DDR		DDRG</front>
<front id="fastioH-996">#define DIO4_PWM		&OCR0B</front>
<front id="fastioH-997"></front>
<front id="fastioH-998">#define	DIO5_PIN		PINE3</front>
<front id="fastioH-999">#define	DIO5_RPORT	PINE</front>
<front id="fastioH-1000">#define	DIO5_WPORT	PORTE</front>
<front id="fastioH-1001">#define	DIO5_DDR		DDRE</front>
<front id="fastioH-1002">#define DIO5_PWM		&OCR3AL</front>
<front id="fastioH-1003"></front>
<front id="fastioH-1004">#define	DIO6_PIN		PINH3</front>
<front id="fastioH-1005">#define	DIO6_RPORT	PINH</front>
<front id="fastioH-1006">#define	DIO6_WPORT	PORTH</front>
<front id="fastioH-1007">#define	DIO6_DDR		DDRH</front>
<front id="fastioH-1008">#define DIO6_PWM		&OCR4AL</front>
<front id="fastioH-1009"></front>
<front id="fastioH-1010">#define	DIO7_PIN		PINH4</front>
<front id="fastioH-1011">#define	DIO7_RPORT	PINH</front>
<front id="fastioH-1012">#define	DIO7_WPORT	PORTH</front>
<front id="fastioH-1013">#define	DIO7_DDR		DDRH</front>
<front id="fastioH-1014">#define DIO7_PWM		&OCR4BL</front>
<front id="fastioH-1015"></front>
<front id="fastioH-1016">#define	DIO8_PIN		PINH5</front>
<front id="fastioH-1017">#define	DIO8_RPORT	PINH</front>
<front id="fastioH-1018">#define	DIO8_WPORT	PORTH</front>
<front id="fastioH-1019">#define	DIO8_DDR		DDRH</front>
<front id="fastioH-1020">#define DIO8_PWM		&OCR4CL</front>
<front id="fastioH-1021"></front>
<front id="fastioH-1022">#define	DIO9_PIN		PINH6</front>
<front id="fastioH-1023">#define	DIO9_RPORT	PINH</front>
<front id="fastioH-1024">#define	DIO9_WPORT	PORTH</front>
<front id="fastioH-1025">#define	DIO9_DDR		DDRH</front>
<front id="fastioH-1026">#define DIO9_PWM		&OCR2B</front>
<front id="fastioH-1027"></front>
<front id="fastioH-1028">#define	DIO10_PIN		PINB4</front>
<front id="fastioH-1029">#define	DIO10_RPORT	PINB</front>
<front id="fastioH-1030">#define	DIO10_WPORT	PORTB</front>
<front id="fastioH-1031">#define	DIO10_DDR		DDRB</front>
<front id="fastioH-1032">#define DIO10_PWM		&OCR2A</front>
<front id="fastioH-1033"></front>
<front id="fastioH-1034">#define	DIO11_PIN		PINB5</front>
<front id="fastioH-1035">#define	DIO11_RPORT	PINB</front>
<front id="fastioH-1036">#define	DIO11_WPORT	PORTB</front>
<front id="fastioH-1037">#define	DIO11_DDR		DDRB</front>
<front id="fastioH-1038">#define DIO11_PWM		NULL</front>
<front id="fastioH-1039"></front>
<front id="fastioH-1040">#define	DIO12_PIN		PINB6</front>
<front id="fastioH-1041">#define	DIO12_RPORT	PINB</front>
<front id="fastioH-1042">#define	DIO12_WPORT	PORTB</front>
<front id="fastioH-1043">#define	DIO12_DDR		DDRB</front>
<front id="fastioH-1044">#define DIO12_PWM		NULL</front>
<front id="fastioH-1045"></front>
<front id="fastioH-1046">#define	DIO13_PIN		PINB7</front>
<front id="fastioH-1047">#define	DIO13_RPORT	PINB</front>
<front id="fastioH-1048">#define	DIO13_WPORT	PORTB</front>
<front id="fastioH-1049">#define	DIO13_DDR		DDRB</front>
<front id="fastioH-1050">#define DIO13_PWM		&OCR0A</front>
<front id="fastioH-1051"></front>
<front id="fastioH-1052">#define	DIO14_PIN		PINJ1</front>
<front id="fastioH-1053">#define	DIO14_RPORT	PINJ</front>
<front id="fastioH-1054">#define	DIO14_WPORT	PORTJ</front>
<front id="fastioH-1055">#define	DIO14_DDR		DDRJ</front>
<front id="fastioH-1056">#define DIO14_PWM		NULL</front>
<front id="fastioH-1057"></front>
<front id="fastioH-1058">#define	DIO15_PIN		PINJ0</front>
<front id="fastioH-1059">#define	DIO15_RPORT	PINJ</front>
<front id="fastioH-1060">#define	DIO15_WPORT	PORTJ</front>
<front id="fastioH-1061">#define	DIO15_DDR		DDRJ</front>
<front id="fastioH-1062">#define DIO15_PWM		NULL</front>
<front id="fastioH-1063"></front>
<front id="fastioH-1064">#define	DIO16_PIN		PINH1</front>
<front id="fastioH-1065">#define	DIO16_RPORT	PINH</front>
<front id="fastioH-1066">#define	DIO16_WPORT	PORTH</front>
<front id="fastioH-1067">#define	DIO16_DDR		DDRH</front>
<front id="fastioH-1068">#define DIO16_PWM		NULL</front>
<front id="fastioH-1069"></front>
<front id="fastioH-1070">#define	DIO17_PIN		PINH0</front>
<front id="fastioH-1071">#define	DIO17_RPORT	PINH</front>
<front id="fastioH-1072">#define	DIO17_WPORT	PORTH</front>
<front id="fastioH-1073">#define	DIO17_DDR		DDRH</front>
<front id="fastioH-1074">#define DIO17_PWM		NULL</front>
<front id="fastioH-1075"></front>
<front id="fastioH-1076">#define	DIO18_PIN		PIND3</front>
<front id="fastioH-1077">#define	DIO18_RPORT	PIND</front>
<front id="fastioH-1078">#define	DIO18_WPORT	PORTD</front>
<front id="fastioH-1079">#define	DIO18_DDR		DDRD</front>
<front id="fastioH-1080">#define DIO18_PWM		NULL</front>
<front id="fastioH-1081"></front>
<front id="fastioH-1082">#define	DIO19_PIN		PIND2</front>
<front id="fastioH-1083">#define	DIO19_RPORT	PIND</front>
<front id="fastioH-1084">#define	DIO19_WPORT	PORTD</front>
<front id="fastioH-1085">#define	DIO19_DDR		DDRD</front>
<front id="fastioH-1086">#define DIO19_PWM		NULL</front>
<front id="fastioH-1087"></front>
<front id="fastioH-1088">#define	DIO20_PIN		PIND1</front>
<front id="fastioH-1089">#define	DIO20_RPORT	PIND</front>
<front id="fastioH-1090">#define	DIO20_WPORT	PORTD</front>
<front id="fastioH-1091">#define	DIO20_DDR		DDRD</front>
<front id="fastioH-1092">#define DIO20_PWM		NULL</front>
<front id="fastioH-1093"></front>
<front id="fastioH-1094">#define	DIO21_PIN		PIND0</front>
<front id="fastioH-1095">#define	DIO21_RPORT	PIND</front>
<front id="fastioH-1096">#define	DIO21_WPORT	PORTD</front>
<front id="fastioH-1097">#define	DIO21_DDR		DDRD</front>
<front id="fastioH-1098">#define DIO21_PWM		NULL</front>
<front id="fastioH-1099"></front>
<front id="fastioH-1100">#define	DIO22_PIN		PINA0</front>
<front id="fastioH-1101">#define	DIO22_RPORT	PINA</front>
<front id="fastioH-1102">#define	DIO22_WPORT	PORTA</front>
<front id="fastioH-1103">#define	DIO22_DDR		DDRA</front>
<front id="fastioH-1104">#define DIO22_PWM		NULL</front>
<front id="fastioH-1105"></front>
<front id="fastioH-1106">#define	DIO23_PIN		PINA1</front>
<front id="fastioH-1107">#define	DIO23_RPORT	PINA</front>
<front id="fastioH-1108">#define	DIO23_WPORT	PORTA</front>
<front id="fastioH-1109">#define	DIO23_DDR		DDRA</front>
<front id="fastioH-1110">#define DIO23_PWM		NULL</front>
<front id="fastioH-1111"></front>
<front id="fastioH-1112">#define	DIO24_PIN		PINA2</front>
<front id="fastioH-1113">#define	DIO24_RPORT	PINA</front>
<front id="fastioH-1114">#define	DIO24_WPORT	PORTA</front>
<front id="fastioH-1115">#define	DIO24_DDR		DDRA</front>
<front id="fastioH-1116">#define DIO24_PWM		NULL</front>
<front id="fastioH-1117"></front>
<front id="fastioH-1118">#define	DIO25_PIN		PINA3</front>
<front id="fastioH-1119">#define	DIO25_RPORT	PINA</front>
<front id="fastioH-1120">#define	DIO25_WPORT	PORTA</front>
<front id="fastioH-1121">#define	DIO25_DDR		DDRA</front>
<front id="fastioH-1122">#define DIO25_PWM		NULL</front>
<front id="fastioH-1123"></front>
<front id="fastioH-1124">#define	DIO26_PIN		PINA4</front>
<front id="fastioH-1125">#define	DIO26_RPORT	PINA</front>
<front id="fastioH-1126">#define	DIO26_WPORT	PORTA</front>
<front id="fastioH-1127">#define	DIO26_DDR		DDRA</front>
<front id="fastioH-1128">#define DIO26_PWM		NULL</front>
<front id="fastioH-1129"></front>
<front id="fastioH-1130">#define	DIO27_PIN		PINA5</front>
<front id="fastioH-1131">#define	DIO27_RPORT	PINA</front>
<front id="fastioH-1132">#define	DIO27_WPORT	PORTA</front>
<front id="fastioH-1133">#define	DIO27_DDR		DDRA</front>
<front id="fastioH-1134">#define DIO27_PWM		NULL</front>
<front id="fastioH-1135"></front>
<front id="fastioH-1136">#define	DIO28_PIN		PINA6</front>
<front id="fastioH-1137">#define	DIO28_RPORT	PINA</front>
<front id="fastioH-1138">#define	DIO28_WPORT	PORTA</front>
<front id="fastioH-1139">#define	DIO28_DDR		DDRA</front>
<front id="fastioH-1140">#define DIO28_PWM		NULL</front>
<front id="fastioH-1141"></front>
<front id="fastioH-1142">#define	DIO29_PIN		PINA7</front>
<front id="fastioH-1143">#define	DIO29_RPORT	PINA</front>
<front id="fastioH-1144">#define	DIO29_WPORT	PORTA</front>
<front id="fastioH-1145">#define	DIO29_DDR		DDRA</front>
<front id="fastioH-1146">#define DIO29_PWM		NULL</front>
<front id="fastioH-1147"></front>
<front id="fastioH-1148">#define	DIO30_PIN		PINC7</front>
<front id="fastioH-1149">#define	DIO30_RPORT	PINC</front>
<front id="fastioH-1150">#define	DIO30_WPORT	PORTC</front>
<front id="fastioH-1151">#define	DIO30_DDR		DDRC</front>
<front id="fastioH-1152">#define DIO30_PWM		NULL</front>
<front id="fastioH-1153"></front>
<front id="fastioH-1154">#define	DIO31_PIN		PINC6</front>
<front id="fastioH-1155">#define	DIO31_RPORT	PINC</front>
<front id="fastioH-1156">#define	DIO31_WPORT	PORTC</front>
<front id="fastioH-1157">#define	DIO31_DDR		DDRC</front>
<front id="fastioH-1158">#define DIO31_PWM		NULL</front>
<front id="fastioH-1159"></front>
<front id="fastioH-1160">#define	DIO32_PIN		PINC5</front>
<front id="fastioH-1161">#define	DIO32_RPORT	PINC</front>
<front id="fastioH-1162">#define	DIO32_WPORT	PORTC</front>
<front id="fastioH-1163">#define	DIO32_DDR		DDRC</front>
<front id="fastioH-1164">#define DIO32_PWM		NULL</front>
<front id="fastioH-1165"></front>
<front id="fastioH-1166">#define	DIO33_PIN		PINC4</front>
<front id="fastioH-1167">#define	DIO33_RPORT	PINC</front>
<front id="fastioH-1168">#define	DIO33_WPORT	PORTC</front>
<front id="fastioH-1169">#define	DIO33_DDR		DDRC</front>
<front id="fastioH-1170">#define DIO33_PWM		NULL</front>
<front id="fastioH-1171"></front>
<front id="fastioH-1172">#define	DIO34_PIN		PINC3</front>
<front id="fastioH-1173">#define	DIO34_RPORT	PINC</front>
<front id="fastioH-1174">#define	DIO34_WPORT	PORTC</front>
<front id="fastioH-1175">#define	DIO34_DDR		DDRC</front>
<front id="fastioH-1176">#define DIO34_PWM		NULL</front>
<front id="fastioH-1177"></front>
<front id="fastioH-1178">#define	DIO35_PIN		PINC2</front>
<front id="fastioH-1179">#define	DIO35_RPORT	PINC</front>
<front id="fastioH-1180">#define	DIO35_WPORT	PORTC</front>
<front id="fastioH-1181">#define	DIO35_DDR		DDRC</front>
<front id="fastioH-1182">#define DIO35_PWM		NULL</front>
<front id="fastioH-1183"></front>
<front id="fastioH-1184">#define	DIO36_PIN		PINC1</front>
<front id="fastioH-1185">#define	DIO36_RPORT	PINC</front>
<front id="fastioH-1186">#define	DIO36_WPORT	PORTC</front>
<front id="fastioH-1187">#define	DIO36_DDR		DDRC</front>
<front id="fastioH-1188">#define DIO36_PWM		NULL</front>
<front id="fastioH-1189"></front>
<front id="fastioH-1190">#define	DIO37_PIN		PINC0</front>
<front id="fastioH-1191">#define	DIO37_RPORT	PINC</front>
<front id="fastioH-1192">#define	DIO37_WPORT	PORTC</front>
<front id="fastioH-1193">#define	DIO37_DDR		DDRC</front>
<front id="fastioH-1194">#define DIO37_PWM		NULL</front>
<front id="fastioH-1195"></front>
<front id="fastioH-1196">#define	DIO38_PIN		PIND7</front>
<front id="fastioH-1197">#define	DIO38_RPORT	PIND</front>
<front id="fastioH-1198">#define	DIO38_WPORT	PORTD</front>
<front id="fastioH-1199">#define	DIO38_DDR		DDRD</front>
<front id="fastioH-1200">#define DIO38_PWM		NULL</front>
<front id="fastioH-1201"></front>
<front id="fastioH-1202">#define	DIO39_PIN		PING2</front>
<front id="fastioH-1203">#define	DIO39_RPORT	PING</front>
<front id="fastioH-1204">#define	DIO39_WPORT	PORTG</front>
<front id="fastioH-1205">#define	DIO39_DDR		DDRG</front>
<front id="fastioH-1206">#define DIO39_PWM		NULL</front>
<front id="fastioH-1207"></front>
<front id="fastioH-1208">#define	DIO40_PIN		PING1</front>
<front id="fastioH-1209">#define	DIO40_RPORT	PING</front>
<front id="fastioH-1210">#define	DIO40_WPORT	PORTG</front>
<front id="fastioH-1211">#define	DIO40_DDR		DDRG</front>
<front id="fastioH-1212">#define DIO40_PWM		NULL</front>
<front id="fastioH-1213"></front>
<front id="fastioH-1214">#define	DIO41_PIN		PING0</front>
<front id="fastioH-1215">#define	DIO41_RPORT	PING</front>
<front id="fastioH-1216">#define	DIO41_WPORT	PORTG</front>
<front id="fastioH-1217">#define	DIO41_DDR		DDRG</front>
<front id="fastioH-1218">#define DIO41_PWM		NULL</front>
<front id="fastioH-1219"></front>
<front id="fastioH-1220">#define	DIO42_PIN		PINL7</front>
<front id="fastioH-1221">#define	DIO42_RPORT	PINL</front>
<front id="fastioH-1222">#define	DIO42_WPORT	PORTL</front>
<front id="fastioH-1223">#define	DIO42_DDR		DDRL</front>
<front id="fastioH-1224">#define DIO42_PWM		NULL</front>
<front id="fastioH-1225"></front>
<front id="fastioH-1226">#define	DIO43_PIN		PINL6</front>
<front id="fastioH-1227">#define	DIO43_RPORT	PINL</front>
<front id="fastioH-1228">#define	DIO43_WPORT	PORTL</front>
<front id="fastioH-1229">#define	DIO43_DDR		DDRL</front>
<front id="fastioH-1230">#define DIO43_PWM		NULL</front>
<front id="fastioH-1231"></front>
<front id="fastioH-1232">#define	DIO44_PIN		PINL5</front>
<front id="fastioH-1233">#define	DIO44_RPORT	PINL</front>
<front id="fastioH-1234">#define	DIO44_WPORT	PORTL</front>
<front id="fastioH-1235">#define	DIO44_DDR		DDRL</front>
<front id="fastioH-1236">#define DIO44_PWM		&OCR5CL</front>
<front id="fastioH-1237"></front>
<front id="fastioH-1238">#define	DIO45_PIN		PINL4</front>
<front id="fastioH-1239">#define	DIO45_RPORT	PINL</front>
<front id="fastioH-1240">#define	DIO45_WPORT	PORTL</front>
<front id="fastioH-1241">#define	DIO45_DDR		DDRL</front>
<front id="fastioH-1242">#define DIO45_PWM		&OCR5BL</front>
<front id="fastioH-1243"></front>
<front id="fastioH-1244">#define	DIO46_PIN		PINL3</front>
<front id="fastioH-1245">#define	DIO46_RPORT	PINL</front>
<front id="fastioH-1246">#define	DIO46_WPORT	PORTL</front>
<front id="fastioH-1247">#define	DIO46_DDR		DDRL</front>
<front id="fastioH-1248">#define DIO46_PWM		&OCR5AL</front>
<front id="fastioH-1249"></front>
<front id="fastioH-1250">#define	DIO47_PIN		PINL2</front>
<front id="fastioH-1251">#define	DIO47_RPORT	PINL</front>
<front id="fastioH-1252">#define	DIO47_WPORT	PORTL</front>
<front id="fastioH-1253">#define	DIO47_DDR		DDRL</front>
<front id="fastioH-1254">#define DIO47_PWM		NULL</front>
<front id="fastioH-1255"></front>
<front id="fastioH-1256">#define	DIO48_PIN		PINL1</front>
<front id="fastioH-1257">#define	DIO48_RPORT	PINL</front>
<front id="fastioH-1258">#define	DIO48_WPORT	PORTL</front>
<front id="fastioH-1259">#define	DIO48_DDR		DDRL</front>
<front id="fastioH-1260">#define DIO48_PWM		NULL</front>
<front id="fastioH-1261"></front>
<front id="fastioH-1262">#define	DIO49_PIN		PINL0</front>
<front id="fastioH-1263">#define	DIO49_RPORT	PINL</front>
<front id="fastioH-1264">#define	DIO49_WPORT	PORTL</front>
<front id="fastioH-1265">#define	DIO49_DDR		DDRL</front>
<front id="fastioH-1266">#define DIO49_PWM		NULL</front>
<front id="fastioH-1267"></front>
<front id="fastioH-1268">#define	DIO50_PIN		PINB3</front>
<front id="fastioH-1269">#define	DIO50_RPORT	PINB</front>
<front id="fastioH-1270">#define	DIO50_WPORT	PORTB</front>
<front id="fastioH-1271">#define	DIO50_DDR		DDRB</front>
<front id="fastioH-1272">#define DIO50_PWM		NULL</front>
<front id="fastioH-1273"></front>
<front id="fastioH-1274">#define	DIO51_PIN		PINB2</front>
<front id="fastioH-1275">#define	DIO51_RPORT	PINB</front>
<front id="fastioH-1276">#define	DIO51_WPORT	PORTB</front>
<front id="fastioH-1277">#define	DIO51_DDR		DDRB</front>
<front id="fastioH-1278">#define DIO51_PWM		NULL</front>
<front id="fastioH-1279"></front>
<front id="fastioH-1280">#define	DIO52_PIN		PINB1</front>
<front id="fastioH-1281">#define	DIO52_RPORT	PINB</front>
<front id="fastioH-1282">#define	DIO52_WPORT	PORTB</front>
<front id="fastioH-1283">#define	DIO52_DDR		DDRB</front>
<front id="fastioH-1284">#define DIO52_PWM		NULL</front>
<front id="fastioH-1285"></front>
<front id="fastioH-1286">#define	DIO53_PIN		PINB0</front>
<front id="fastioH-1287">#define	DIO53_RPORT	PINB</front>
<front id="fastioH-1288">#define	DIO53_WPORT	PORTB</front>
<front id="fastioH-1289">#define	DIO53_DDR		DDRB</front>
<front id="fastioH-1290">#define DIO53_PWM		NULL</front>
<front id="fastioH-1291"></front>
<front id="fastioH-1292">#define DIO54_PIN		PINF0</front>
<front id="fastioH-1293">#define DIO54_RPORT	PINF</front>
<front id="fastioH-1294">#define DIO54_WPORT	PORTF</front>
<front id="fastioH-1295">#define DIO54_DDR		DDRF</front>
<front id="fastioH-1296">#define DIO54_PWM		NULL</front>
<front id="fastioH-1297"></front>
<front id="fastioH-1298">#define DIO55_PIN		PINF1</front>
<front id="fastioH-1299">#define DIO55_RPORT	PINF</front>
<front id="fastioH-1300">#define DIO55_WPORT	PORTF</front>
<front id="fastioH-1301">#define DIO55_DDR		DDRF</front>
<front id="fastioH-1302">#define DIO55_PWM		NULL</front>
<front id="fastioH-1303"></front>
<front id="fastioH-1304">#define DIO56_PIN		PINF2</front>
<front id="fastioH-1305">#define DIO56_RPORT	PINF</front>
<front id="fastioH-1306">#define DIO56_WPORT	PORTF</front>
<front id="fastioH-1307">#define DIO56_DDR		DDRF</front>
<front id="fastioH-1308">#define DIO56_PWM		NULL</front>
<front id="fastioH-1309"></front>
<front id="fastioH-1310">#define DIO57_PIN		PINF3</front>
<front id="fastioH-1311">#define DIO57_RPORT	PINF</front>
<front id="fastioH-1312">#define DIO57_WPORT	PORTF</front>
<front id="fastioH-1313">#define DIO57_DDR		DDRF</front>
<front id="fastioH-1314">#define DIO57_PWM		NULL</front>
<front id="fastioH-1315"></front>
<front id="fastioH-1316">#define DIO58_PIN		PINF4</front>
<front id="fastioH-1317">#define DIO58_RPORT	PINF</front>
<front id="fastioH-1318">#define DIO58_WPORT	PORTF</front>
<front id="fastioH-1319">#define DIO58_DDR		DDRF</front>
<front id="fastioH-1320">#define DIO58_PWM		NULL</front>
<front id="fastioH-1321"></front>
<front id="fastioH-1322">#define DIO59_PIN		PINF5</front>
<front id="fastioH-1323">#define DIO59_RPORT	PINF</front>
<front id="fastioH-1324">#define DIO59_WPORT	PORTF</front>
<front id="fastioH-1325">#define DIO59_DDR		DDRF</front>
<front id="fastioH-1326">#define DIO59_PWM		NULL</front>
<front id="fastioH-1327"></front>
<front id="fastioH-1328">#define DIO60_PIN		PINF6</front>
<front id="fastioH-1329">#define DIO60_RPORT	PINF</front>
<front id="fastioH-1330">#define DIO60_WPORT	PORTF</front>
<front id="fastioH-1331">#define DIO60_DDR		DDRF</front>
<front id="fastioH-1332">#define DIO60_PWM		NULL</front>
<front id="fastioH-1333"></front>
<front id="fastioH-1334">#define DIO61_PIN		PINF7</front>
<front id="fastioH-1335">#define DIO61_RPORT	PINF</front>
<front id="fastioH-1336">#define DIO61_WPORT	PORTF</front>
<front id="fastioH-1337">#define DIO61_DDR		DDRF</front>
<front id="fastioH-1338">#define DIO61_PWM		NULL</front>
<front id="fastioH-1339"></front>
<front id="fastioH-1340">#define DIO62_PIN		PINK0</front>
<front id="fastioH-1341">#define DIO62_RPORT	PINK</front>
<front id="fastioH-1342">#define DIO62_WPORT	PORTK</front>
<front id="fastioH-1343">#define DIO62_DDR		DDRK</front>
<front id="fastioH-1344">#define DIO62_PWM		NULL</front>
<front id="fastioH-1345"></front>
<front id="fastioH-1346">#define DIO63_PIN		PINK1</front>
<front id="fastioH-1347">#define DIO63_RPORT	PINK</front>
<front id="fastioH-1348">#define DIO63_WPORT	PORTK</front>
<front id="fastioH-1349">#define DIO63_DDR		DDRK</front>
<front id="fastioH-1350">#define DIO63_PWM		NULL</front>
<front id="fastioH-1351"></front>
<front id="fastioH-1352">#define DIO64_PIN		PINK2</front>
<front id="fastioH-1353">#define DIO64_RPORT	PINK</front>
<front id="fastioH-1354">#define DIO64_WPORT	PORTK</front>
<front id="fastioH-1355">#define DIO64_DDR		DDRK</front>
<front id="fastioH-1356">#define DIO64_PWM		NULL</front>
<front id="fastioH-1357"></front>
<front id="fastioH-1358">#define DIO65_PIN		PINK3</front>
<front id="fastioH-1359">#define DIO65_RPORT	PINK</front>
<front id="fastioH-1360">#define DIO65_WPORT	PORTK</front>
<front id="fastioH-1361">#define DIO65_DDR		DDRK</front>
<front id="fastioH-1362">#define DIO65_PWM		NULL</front>
<front id="fastioH-1363"></front>
<front id="fastioH-1364">#define DIO66_PIN		PINK4</front>
<front id="fastioH-1365">#define DIO66_RPORT	PINK</front>
<front id="fastioH-1366">#define DIO66_WPORT	PORTK</front>
<front id="fastioH-1367">#define DIO66_DDR		DDRK</front>
<front id="fastioH-1368">#define DIO66_PWM		NULL</front>
<front id="fastioH-1369"></front>
<front id="fastioH-1370">#define DIO67_PIN		PINK5</front>
<front id="fastioH-1371">#define DIO67_RPORT	PINK</front>
<front id="fastioH-1372">#define DIO67_WPORT	PORTK</front>
<front id="fastioH-1373">#define DIO67_DDR		DDRK</front>
<front id="fastioH-1374">#define DIO67_PWM		NULL</front>
<front id="fastioH-1375"></front>
<front id="fastioH-1376">#define DIO68_PIN		PINK6</front>
<front id="fastioH-1377">#define DIO68_RPORT	PINK</front>
<front id="fastioH-1378">#define DIO68_WPORT	PORTK</front>
<front id="fastioH-1379">#define DIO68_DDR		DDRK</front>
<front id="fastioH-1380">#define DIO68_PWM		NULL</front>
<front id="fastioH-1381"></front>
<front id="fastioH-1382">#define DIO69_PIN		PINK7</front>
<front id="fastioH-1383">#define DIO69_RPORT	PINK</front>
<front id="fastioH-1384">#define DIO69_WPORT	PORTK</front>
<front id="fastioH-1385">#define DIO69_DDR		DDRK</front>
<front id="fastioH-1386">#define DIO69_PWM		NULL</front>
<front id="fastioH-1387"></front>
<front id="fastioH-1388">#define DIO70_PIN		PING4</front>
<front id="fastioH-1389">#define DIO70_RPORT	PING</front>
<front id="fastioH-1390">#define DIO70_WPORT	PORTG</front>
<front id="fastioH-1391">#define DIO70_DDR		DDRG</front>
<front id="fastioH-1392">#define DIO70_PWM		NULL</front>
<front id="fastioH-1393"></front>
<front id="fastioH-1394">#define DIO71_PIN		PING3</front>
<front id="fastioH-1395">#define DIO71_RPORT	PING</front>
<front id="fastioH-1396">#define DIO71_WPORT	PORTG</front>
<front id="fastioH-1397">#define DIO71_DDR		DDRG</front>
<front id="fastioH-1398">#define DIO71_PWM		NULL</front>
<front id="fastioH-1399"></front>
<front id="fastioH-1400">#define DIO72_PIN		PINJ2</front>
<front id="fastioH-1401">#define DIO72_RPORT	PINJ</front>
<front id="fastioH-1402">#define DIO72_WPORT	PORTJ</front>
<front id="fastioH-1403">#define DIO72_DDR		DDRJ</front>
<front id="fastioH-1404">#define DIO72_PWM		NULL</front>
<front id="fastioH-1405"></front>
<front id="fastioH-1406">#define DIO73_PIN		PINJ3</front>
<front id="fastioH-1407">#define DIO73_RPORT	PINJ</front>
<front id="fastioH-1408">#define DIO73_WPORT	PORTJ</front>
<front id="fastioH-1409">#define DIO73_DDR		DDRJ</front>
<front id="fastioH-1410">#define DIO73_PWM		NULL</front>
<front id="fastioH-1411"></front>
<front id="fastioH-1412">#define DIO74_PIN		PINJ7</front>
<front id="fastioH-1413">#define DIO74_RPORT	PINJ</front>
<front id="fastioH-1414">#define DIO74_WPORT	PORTJ</front>
<front id="fastioH-1415">#define DIO74_DDR		DDRJ</front>
<front id="fastioH-1416">#define DIO74_PWM		NULL</front>
<front id="fastioH-1417"></front>
<front id="fastioH-1418">#define DIO75_PIN		PINJ4</front>
<front id="fastioH-1419">#define DIO75_RPORT	PINJ</front>
<front id="fastioH-1420">#define DIO75_WPORT	PORTJ</front>
<front id="fastioH-1421">#define DIO75_DDR		DDRJ</front>
<front id="fastioH-1422">#define DIO75_PWM		NULL</front>
<front id="fastioH-1423"></front>
<front id="fastioH-1424">#define DIO76_PIN		PINJ5</front>
<front id="fastioH-1425">#define DIO76_RPORT	PINJ</front>
<front id="fastioH-1426">#define DIO76_WPORT	PORTJ</front>
<front id="fastioH-1427">#define DIO76_DDR		DDRJ</front>
<front id="fastioH-1428">#define DIO76_PWM		NULL</front>
<front id="fastioH-1429"></front>
<front id="fastioH-1430">#define DIO77_PIN		PINJ6</front>
<front id="fastioH-1431">#define DIO77_RPORT	PINJ</front>
<front id="fastioH-1432">#define DIO77_WPORT	PORTJ</front>
<front id="fastioH-1433">#define DIO77_DDR		DDRJ</front>
<front id="fastioH-1434">#define DIO77_PWM		NULL</front>
<front id="fastioH-1435"></front>
<front id="fastioH-1436">#define DIO78_PIN		PINE2</front>
<front id="fastioH-1437">#define DIO78_RPORT	PINE</front>
<front id="fastioH-1438">#define DIO78_WPORT	PORTE</front>
<front id="fastioH-1439">#define DIO78_DDR		DDRE</front>
<front id="fastioH-1440">#define DIO78_PWM		NULL</front>
<front id="fastioH-1441"></front>
<front id="fastioH-1442">#define DIO79_PIN		PINE6</front>
<front id="fastioH-1443">#define DIO79_RPORT	PINE</front>
<front id="fastioH-1444">#define DIO79_WPORT	PORTE</front>
<front id="fastioH-1445">#define DIO79_DDR		DDRE</front>
<front id="fastioH-1446">#define DIO79_PWM		NULL</front>
<front id="fastioH-1447"></front>
<front id="fastioH-1448">#define DIO80_PIN		PINE7</front>
<front id="fastioH-1449">#define DIO80_RPORT	PINE</front>
<front id="fastioH-1450">#define DIO80_WPORT	PORTE</front>
<front id="fastioH-1451">#define DIO80_DDR		DDRE</front>
<front id="fastioH-1452">#define DIO80_PWM		NULL</front>
<front id="fastioH-1453"></front>
<front id="fastioH-1454">#define DIO81_PIN		PIND4</front>
<front id="fastioH-1455">#define DIO81_RPORT	PIND</front>
<front id="fastioH-1456">#define DIO81_WPORT	PORTD</front>
<front id="fastioH-1457">#define DIO81_DDR		DDRD</front>
<front id="fastioH-1458">#define DIO81_PWM		NULL</front>
<front id="fastioH-1459"></front>
<front id="fastioH-1460">#define DIO82_PIN		PIND5</front>
<front id="fastioH-1461">#define DIO82_RPORT	PIND</front>
<front id="fastioH-1462">#define DIO82_WPORT	PORTD</front>
<front id="fastioH-1463">#define DIO82_DDR		DDRD</front>
<front id="fastioH-1464">#define DIO82_PWM		NULL</front>
<front id="fastioH-1465"></front>
<front id="fastioH-1466">#define DIO83_PIN		PIND6</front>
<front id="fastioH-1467">#define DIO83_RPORT	PIND</front>
<front id="fastioH-1468">#define DIO83_WPORT	PORTD</front>
<front id="fastioH-1469">#define DIO83_DDR		DDRD</front>
<front id="fastioH-1470">#define DIO83_PWM		NULL</front>
<front id="fastioH-1471"></front>
<front id="fastioH-1472">#define DIO84_PIN		PINH2</front>
<front id="fastioH-1473">#define DIO84_RPORT	PINH</front>
<front id="fastioH-1474">#define DIO84_WPORT	PORTH</front>
<front id="fastioH-1475">#define DIO84_DDR		DDRH</front>
<front id="fastioH-1476">#define DIO84_PWM		NULL</front>
<front id="fastioH-1477"></front>
<front id="fastioH-1478">#define DIO85_PIN		PINH7</front>
<front id="fastioH-1479">#define DIO85_RPORT	PINH</front>
<front id="fastioH-1480">#define DIO85_WPORT	PORTH</front>
<front id="fastioH-1481">#define DIO85_DDR		DDRH</front>
<front id="fastioH-1482">#define DIO85_PWM		NULL</front>
<front id="fastioH-1483"></front>
<front id="fastioH-1484">#undef PA0</front>
<front id="fastioH-1485">#define PA0_PIN			PINA0</front>
<front id="fastioH-1486">#define PA0_RPORT		PINA</front>
<front id="fastioH-1487">#define PA0_WPORT		PORTA</front>
<front id="fastioH-1488">#define PA0_DDR			DDRA</front>
<front id="fastioH-1489">#define PA0_PWM			NULL</front>
<front id="fastioH-1490">#undef PA1</front>
<front id="fastioH-1491">#define PA1_PIN			PINA1</front>
<front id="fastioH-1492">#define PA1_RPORT		PINA</front>
<front id="fastioH-1493">#define PA1_WPORT		PORTA</front>
<front id="fastioH-1494">#define PA1_DDR			DDRA</front>
<front id="fastioH-1495">#define PA1_PWM			NULL</front>
<front id="fastioH-1496">#undef PA2</front>
<front id="fastioH-1497">#define PA2_PIN			PINA2</front>
<front id="fastioH-1498">#define PA2_RPORT		PINA</front>
<front id="fastioH-1499">#define PA2_WPORT		PORTA</front>
<front id="fastioH-1500">#define PA2_DDR			DDRA</front>
<front id="fastioH-1501">#define PA2_PWM			NULL</front>
<front id="fastioH-1502">#undef PA3</front>
<front id="fastioH-1503">#define PA3_PIN			PINA3</front>
<front id="fastioH-1504">#define PA3_RPORT		PINA</front>
<front id="fastioH-1505">#define PA3_WPORT		PORTA</front>
<front id="fastioH-1506">#define PA3_DDR			DDRA</front>
<front id="fastioH-1507">#define PA3_PWM			NULL</front>
<front id="fastioH-1508">#undef PA4</front>
<front id="fastioH-1509">#define PA4_PIN			PINA4</front>
<front id="fastioH-1510">#define PA4_RPORT		PINA</front>
<front id="fastioH-1511">#define PA4_WPORT		PORTA</front>
<front id="fastioH-1512">#define PA4_DDR			DDRA</front>
<front id="fastioH-1513">#define PA4_PWM			NULL</front>
<front id="fastioH-1514">#undef PA5</front>
<front id="fastioH-1515">#define PA5_PIN			PINA5</front>
<front id="fastioH-1516">#define PA5_RPORT		PINA</front>
<front id="fastioH-1517">#define PA5_WPORT		PORTA</front>
<front id="fastioH-1518">#define PA5_DDR			DDRA</front>
<front id="fastioH-1519">#define PA5_PWM			NULL</front>
<front id="fastioH-1520">#undef PA6</front>
<front id="fastioH-1521">#define PA6_PIN			PINA6</front>
<front id="fastioH-1522">#define PA6_RPORT		PINA</front>
<front id="fastioH-1523">#define PA6_WPORT		PORTA</front>
<front id="fastioH-1524">#define PA6_DDR			DDRA</front>
<front id="fastioH-1525">#define PA6_PWM			NULL</front>
<front id="fastioH-1526">#undef PA7</front>
<front id="fastioH-1527">#define PA7_PIN			PINA7</front>
<front id="fastioH-1528">#define PA7_RPORT		PINA</front>
<front id="fastioH-1529">#define PA7_WPORT		PORTA</front>
<front id="fastioH-1530">#define PA7_DDR			DDRA</front>
<front id="fastioH-1531">#define PA7_PWM			NULL</front>
<front id="fastioH-1532"></front>
<front id="fastioH-1533">#undef PB0</front>
<front id="fastioH-1534">#define PB0_PIN			PINB0</front>
<front id="fastioH-1535">#define PB0_RPORT		PINB</front>
<front id="fastioH-1536">#define PB0_WPORT		PORTB</front>
<front id="fastioH-1537">#define PB0_DDR			DDRB</front>
<front id="fastioH-1538">#define PB0_PWM			NULL</front>
<front id="fastioH-1539">#undef PB1</front>
<front id="fastioH-1540">#define PB1_PIN			PINB1</front>
<front id="fastioH-1541">#define PB1_RPORT		PINB</front>
<front id="fastioH-1542">#define PB1_WPORT		PORTB</front>
<front id="fastioH-1543">#define PB1_DDR			DDRB</front>
<front id="fastioH-1544">#define PB1_PWM			NULL</front>
<front id="fastioH-1545">#undef PB2</front>
<front id="fastioH-1546">#define PB2_PIN			PINB2</front>
<front id="fastioH-1547">#define PB2_RPORT		PINB</front>
<front id="fastioH-1548">#define PB2_WPORT		PORTB</front>
<front id="fastioH-1549">#define PB2_DDR			DDRB</front>
<front id="fastioH-1550">#define PB2_PWM			NULL</front>
<front id="fastioH-1551">#undef PB3</front>
<front id="fastioH-1552">#define PB3_PIN			PINB3</front>
<front id="fastioH-1553">#define PB3_RPORT		PINB</front>
<front id="fastioH-1554">#define PB3_WPORT		PORTB</front>
<front id="fastioH-1555">#define PB3_DDR			DDRB</front>
<front id="fastioH-1556">#define PB3_PWM			NULL</front>
<front id="fastioH-1557">#undef PB4</front>
<front id="fastioH-1558">#define PB4_PIN			PINB4</front>
<front id="fastioH-1559">#define PB4_RPORT		PINB</front>
<front id="fastioH-1560">#define PB4_WPORT		PORTB</front>
<front id="fastioH-1561">#define PB4_DDR			DDRB</front>
<front id="fastioH-1562">#define PB4_PWM			&OCR2A</front>
<front id="fastioH-1563">#undef PB5</front>
<front id="fastioH-1564">#define PB5_PIN			PINB5</front>
<front id="fastioH-1565">#define PB5_RPORT		PINB</front>
<front id="fastioH-1566">#define PB5_WPORT		PORTB</front>
<front id="fastioH-1567">#define PB5_DDR			DDRB</front>
<front id="fastioH-1568">#define PB5_PWM			NULL</front>
<front id="fastioH-1569">#undef PB6</front>
<front id="fastioH-1570">#define PB6_PIN			PINB6</front>
<front id="fastioH-1571">#define PB6_RPORT		PINB</front>
<front id="fastioH-1572">#define PB6_WPORT		PORTB</front>
<front id="fastioH-1573">#define PB6_DDR			DDRB</front>
<front id="fastioH-1574">#define PB6_PWM			NULL</front>
<front id="fastioH-1575">#undef PB7</front>
<front id="fastioH-1576">#define PB7_PIN			PINB7</front>
<front id="fastioH-1577">#define PB7_RPORT		PINB</front>
<front id="fastioH-1578">#define PB7_WPORT		PORTB</front>
<front id="fastioH-1579">#define PB7_DDR			DDRB</front>
<front id="fastioH-1580">#define PB7_PWM			&OCR0A</front>
<front id="fastioH-1581"></front>
<front id="fastioH-1582">#undef PC0</front>
<front id="fastioH-1583">#define PC0_PIN			PINC0</front>
<front id="fastioH-1584">#define PC0_RPORT		PINC</front>
<front id="fastioH-1585">#define PC0_WPORT		PORTC</front>
<front id="fastioH-1586">#define PC0_DDR			DDRC</front>
<front id="fastioH-1587">#define PC0_PWM			NULL</front>
<front id="fastioH-1588">#undef PC1</front>
<front id="fastioH-1589">#define PC1_PIN			PINC1</front>
<front id="fastioH-1590">#define PC1_RPORT		PINC</front>
<front id="fastioH-1591">#define PC1_WPORT		PORTC</front>
<front id="fastioH-1592">#define PC1_DDR			DDRC</front>
<front id="fastioH-1593">#define PC1_PWM			NULL</front>
<front id="fastioH-1594">#undef PC2</front>
<front id="fastioH-1595">#define PC2_PIN			PINC2</front>
<front id="fastioH-1596">#define PC2_RPORT		PINC</front>
<front id="fastioH-1597">#define PC2_WPORT		PORTC</front>
<front id="fastioH-1598">#define PC2_DDR			DDRC</front>
<front id="fastioH-1599">#define PC2_PWM			NULL</front>
<front id="fastioH-1600">#undef PC3</front>
<front id="fastioH-1601">#define PC3_PIN			PINC3</front>
<front id="fastioH-1602">#define PC3_RPORT		PINC</front>
<front id="fastioH-1603">#define PC3_WPORT		PORTC</front>
<front id="fastioH-1604">#define PC3_DDR			DDRC</front>
<front id="fastioH-1605">#define PC3_PWM			NULL</front>
<front id="fastioH-1606">#undef PC4</front>
<front id="fastioH-1607">#define PC4_PIN			PINC4</front>
<front id="fastioH-1608">#define PC4_RPORT		PINC</front>
<front id="fastioH-1609">#define PC4_WPORT		PORTC</front>
<front id="fastioH-1610">#define PC4_DDR			DDRC</front>
<front id="fastioH-1611">#define PC4_PWM			NULL</front>
<front id="fastioH-1612">#undef PC5</front>
<front id="fastioH-1613">#define PC5_PIN			PINC5</front>
<front id="fastioH-1614">#define PC5_RPORT		PINC</front>
<front id="fastioH-1615">#define PC5_WPORT		PORTC</front>
<front id="fastioH-1616">#define PC5_DDR			DDRC</front>
<front id="fastioH-1617">#define PC5_PWM			NULL</front>
<front id="fastioH-1618">#undef PC6</front>
<front id="fastioH-1619">#define PC6_PIN			PINC6</front>
<front id="fastioH-1620">#define PC6_RPORT		PINC</front>
<front id="fastioH-1621">#define PC6_WPORT		PORTC</front>
<front id="fastioH-1622">#define PC6_DDR			DDRC</front>
<front id="fastioH-1623">#define PC6_PWM			NULL</front>
<front id="fastioH-1624">#undef PC7</front>
<front id="fastioH-1625">#define PC7_PIN			PINC7</front>
<front id="fastioH-1626">#define PC7_RPORT		PINC</front>
<front id="fastioH-1627">#define PC7_WPORT		PORTC</front>
<front id="fastioH-1628">#define PC7_DDR			DDRC</front>
<front id="fastioH-1629">#define PC7_PWM			NULL</front>
<front id="fastioH-1630"></front>
<front id="fastioH-1631">#undef PD0</front>
<front id="fastioH-1632">#define PD0_PIN			PIND0</front>
<front id="fastioH-1633">#define PD0_RPORT		PIND</front>
<front id="fastioH-1634">#define PD0_WPORT		PORTD</front>
<front id="fastioH-1635">#define PD0_DDR			DDRD</front>
<front id="fastioH-1636">#define PD0_PWM			NULL</front>
<front id="fastioH-1637">#undef PD1</front>
<front id="fastioH-1638">#define PD1_PIN			PIND1</front>
<front id="fastioH-1639">#define PD1_RPORT		PIND</front>
<front id="fastioH-1640">#define PD1_WPORT		PORTD</front>
<front id="fastioH-1641">#define PD1_DDR			DDRD</front>
<front id="fastioH-1642">#define PD1_PWM			NULL</front>
<front id="fastioH-1643">#undef PD2</front>
<front id="fastioH-1644">#define PD2_PIN			PIND2</front>
<front id="fastioH-1645">#define PD2_RPORT		PIND</front>
<front id="fastioH-1646">#define PD2_WPORT		PORTD</front>
<front id="fastioH-1647">#define PD2_DDR			DDRD</front>
<front id="fastioH-1648">#define PD2_PWM			NULL</front>
<front id="fastioH-1649">#undef PD3</front>
<front id="fastioH-1650">#define PD3_PIN			PIND3</front>
<front id="fastioH-1651">#define PD3_RPORT		PIND</front>
<front id="fastioH-1652">#define PD3_WPORT		PORTD</front>
<front id="fastioH-1653">#define PD3_DDR			DDRD</front>
<front id="fastioH-1654">#define PD3_PWM			NULL</front>
<front id="fastioH-1655">#undef PD4</front>
<front id="fastioH-1656">#define PD4_PIN			PIND4</front>
<front id="fastioH-1657">#define PD4_RPORT		PIND</front>
<front id="fastioH-1658">#define PD4_WPORT		PORTD</front>
<front id="fastioH-1659">#define PD4_DDR			DDRD</front>
<front id="fastioH-1660">#define PD4_PWM			NULL</front>
<front id="fastioH-1661">#undef PD5</front>
<front id="fastioH-1662">#define PD5_PIN			PIND5</front>
<front id="fastioH-1663">#define PD5_RPORT		PIND</front>
<front id="fastioH-1664">#define PD5_WPORT		PORTD</front>
<front id="fastioH-1665">#define PD5_DDR			DDRD</front>
<front id="fastioH-1666">#define PD5_PWM			NULL</front>
<front id="fastioH-1667">#undef PD6</front>
<front id="fastioH-1668">#define PD6_PIN			PIND6</front>
<front id="fastioH-1669">#define PD6_RPORT		PIND</front>
<front id="fastioH-1670">#define PD6_WPORT		PORTD</front>
<front id="fastioH-1671">#define PD6_DDR			DDRD</front>
<front id="fastioH-1672">#define PD6_PWM			NULL</front>
<front id="fastioH-1673">#undef PD7</front>
<front id="fastioH-1674">#define PD7_PIN			PIND7</front>
<front id="fastioH-1675">#define PD7_RPORT		PIND</front>
<front id="fastioH-1676">#define PD7_WPORT		PORTD</front>
<front id="fastioH-1677">#define PD7_DDR			DDRD</front>
<front id="fastioH-1678">#define PD7_PWM			NULL</front>
<front id="fastioH-1679"></front>
<front id="fastioH-1680">#undef PE0</front>
<front id="fastioH-1681">#define PE0_PIN			PINE0</front>
<front id="fastioH-1682">#define PE0_RPORT		PINE</front>
<front id="fastioH-1683">#define PE0_WPORT		PORTE</front>
<front id="fastioH-1684">#define PE0_DDR			DDRE</front>
<front id="fastioH-1685">#define PE0_PWM			NULL</front>
<front id="fastioH-1686">#undef PE1</front>
<front id="fastioH-1687">#define PE1_PIN			PINE1</front>
<front id="fastioH-1688">#define PE1_RPORT		PINE</front>
<front id="fastioH-1689">#define PE1_WPORT		PORTE</front>
<front id="fastioH-1690">#define PE1_DDR			DDRE</front>
<front id="fastioH-1691">#define PE1_PWM			NULL</front>
<front id="fastioH-1692">#undef PE2</front>
<front id="fastioH-1693">#define PE2_PIN			PINE2</front>
<front id="fastioH-1694">#define PE2_RPORT		PINE</front>
<front id="fastioH-1695">#define PE2_WPORT		PORTE</front>
<front id="fastioH-1696">#define PE2_DDR			DDRE</front>
<front id="fastioH-1697">#define PE2_PWM			NULL</front>
<front id="fastioH-1698">#undef PE3</front>
<front id="fastioH-1699">#define PE3_PIN			PINE3</front>
<front id="fastioH-1700">#define PE3_RPORT		PINE</front>
<front id="fastioH-1701">#define PE3_WPORT		PORTE</front>
<front id="fastioH-1702">#define PE3_DDR			DDRE</front>
<front id="fastioH-1703">#define PE3_PWM			&OCR3AL</front>
<front id="fastioH-1704">#undef PE4</front>
<front id="fastioH-1705">#define PE4_PIN			PINE4</front>
<front id="fastioH-1706">#define PE4_RPORT		PINE</front>
<front id="fastioH-1707">#define PE4_WPORT		PORTE</front>
<front id="fastioH-1708">#define PE4_DDR			DDRE</front>
<front id="fastioH-1709">#define PE4_PWM			&OCR3BL</front>
<front id="fastioH-1710">#undef PE5</front>
<front id="fastioH-1711">#define PE5_PIN			PINE5</front>
<front id="fastioH-1712">#define PE5_RPORT		PINE</front>
<front id="fastioH-1713">#define PE5_WPORT		PORTE</front>
<front id="fastioH-1714">#define PE5_DDR			DDRE</front>
<front id="fastioH-1715">#define PE5_PWM			&OCR3CL</front>
<front id="fastioH-1716">#undef PE6</front>
<front id="fastioH-1717">#define PE6_PIN			PINE6</front>
<front id="fastioH-1718">#define PE6_RPORT		PINE</front>
<front id="fastioH-1719">#define PE6_WPORT		PORTE</front>
<front id="fastioH-1720">#define PE6_DDR			DDRE</front>
<front id="fastioH-1721">#define PE6_PWM			NULL</front>
<front id="fastioH-1722">#undef PE7</front>
<front id="fastioH-1723">#define PE7_PIN			PINE7</front>
<front id="fastioH-1724">#define PE7_RPORT		PINE</front>
<front id="fastioH-1725">#define PE7_WPORT		PORTE</front>
<front id="fastioH-1726">#define PE7_DDR			DDRE</front>
<front id="fastioH-1727">#define PE7_PWM			NULL</front>
<front id="fastioH-1728"></front>
<front id="fastioH-1729">#undef PF0</front>
<front id="fastioH-1730">#define PF0_PIN			PINF0</front>
<front id="fastioH-1731">#define PF0_RPORT		PINF</front>
<front id="fastioH-1732">#define PF0_WPORT		PORTF</front>
<front id="fastioH-1733">#define PF0_DDR			DDRF</front>
<front id="fastioH-1734">#define PF0_PWM			NULL</front>
<front id="fastioH-1735">#undef PF1</front>
<front id="fastioH-1736">#define PF1_PIN			PINF1</front>
<front id="fastioH-1737">#define PF1_RPORT		PINF</front>
<front id="fastioH-1738">#define PF1_WPORT		PORTF</front>
<front id="fastioH-1739">#define PF1_DDR			DDRF</front>
<front id="fastioH-1740">#define PF1_PWM			NULL</front>
<front id="fastioH-1741">#undef PF2</front>
<front id="fastioH-1742">#define PF2_PIN			PINF2</front>
<front id="fastioH-1743">#define PF2_RPORT		PINF</front>
<front id="fastioH-1744">#define PF2_WPORT		PORTF</front>
<front id="fastioH-1745">#define PF2_DDR			DDRF</front>
<front id="fastioH-1746">#define PF2_PWM			NULL</front>
<front id="fastioH-1747">#undef PF3</front>
<front id="fastioH-1748">#define PF3_PIN			PINF3</front>
<front id="fastioH-1749">#define PF3_RPORT		PINF</front>
<front id="fastioH-1750">#define PF3_WPORT		PORTF</front>
<front id="fastioH-1751">#define PF3_DDR			DDRF</front>
<front id="fastioH-1752">#define PF3_PWM			NULL</front>
<front id="fastioH-1753">#undef PF4</front>
<front id="fastioH-1754">#define PF4_PIN			PINF4</front>
<front id="fastioH-1755">#define PF4_RPORT		PINF</front>
<front id="fastioH-1756">#define PF4_WPORT		PORTF</front>
<front id="fastioH-1757">#define PF4_DDR			DDRF</front>
<front id="fastioH-1758">#define PF4_PWM			NULL</front>
<front id="fastioH-1759">#undef PF5</front>
<front id="fastioH-1760">#define PF5_PIN			PINF5</front>
<front id="fastioH-1761">#define PF5_RPORT		PINF</front>
<front id="fastioH-1762">#define PF5_WPORT		PORTF</front>
<front id="fastioH-1763">#define PF5_DDR			DDRF</front>
<front id="fastioH-1764">#define PF5_PWM			NULL</front>
<front id="fastioH-1765">#undef PF6</front>
<front id="fastioH-1766">#define PF6_PIN			PINF6</front>
<front id="fastioH-1767">#define PF6_RPORT		PINF</front>
<front id="fastioH-1768">#define PF6_WPORT		PORTF</front>
<front id="fastioH-1769">#define PF6_DDR			DDRF</front>
<front id="fastioH-1770">#define PF6_PWM			NULL</front>
<front id="fastioH-1771">#undef PF7</front>
<front id="fastioH-1772">#define PF7_PIN			PINF7</front>
<front id="fastioH-1773">#define PF7_RPORT		PINF</front>
<front id="fastioH-1774">#define PF7_WPORT		PORTF</front>
<front id="fastioH-1775">#define PF7_DDR			DDRF</front>
<front id="fastioH-1776">#define PF7_PWM			NULL</front>
<front id="fastioH-1777"></front>
<front id="fastioH-1778">#undef PG0</front>
<front id="fastioH-1779">#define PG0_PIN			PING0</front>
<front id="fastioH-1780">#define PG0_RPORT		PING</front>
<front id="fastioH-1781">#define PG0_WPORT		PORTG</front>
<front id="fastioH-1782">#define PG0_DDR			DDRG</front>
<front id="fastioH-1783">#define PG0_PWM			NULL</front>
<front id="fastioH-1784">#undef PG1</front>
<front id="fastioH-1785">#define PG1_PIN			PING1</front>
<front id="fastioH-1786">#define PG1_RPORT		PING</front>
<front id="fastioH-1787">#define PG1_WPORT		PORTG</front>
<front id="fastioH-1788">#define PG1_DDR			DDRG</front>
<front id="fastioH-1789">#define PG1_PWM			NULL</front>
<front id="fastioH-1790">#undef PG2</front>
<front id="fastioH-1791">#define PG2_PIN			PING2</front>
<front id="fastioH-1792">#define PG2_RPORT		PING</front>
<front id="fastioH-1793">#define PG2_WPORT		PORTG</front>
<front id="fastioH-1794">#define PG2_DDR			DDRG</front>
<front id="fastioH-1795">#define PG2_PWM			NULL</front>
<front id="fastioH-1796">#undef PG3</front>
<front id="fastioH-1797">#define PG3_PIN			PING3</front>
<front id="fastioH-1798">#define PG3_RPORT		PING</front>
<front id="fastioH-1799">#define PG3_WPORT		PORTG</front>
<front id="fastioH-1800">#define PG3_DDR			DDRG</front>
<front id="fastioH-1801">#define PG3_PWM			NULL</front>
<front id="fastioH-1802">#undef PG4</front>
<front id="fastioH-1803">#define PG4_PIN			PING4</front>
<front id="fastioH-1804">#define PG4_RPORT		PING</front>
<front id="fastioH-1805">#define PG4_WPORT		PORTG</front>
<front id="fastioH-1806">#define PG4_DDR			DDRG</front>
<front id="fastioH-1807">#define PG4_PWM			NULL</front>
<front id="fastioH-1808">#undef PG5</front>
<front id="fastioH-1809">#define PG5_PIN			PING5</front>
<front id="fastioH-1810">#define PG5_RPORT		PING</front>
<front id="fastioH-1811">#define PG5_WPORT		PORTG</front>
<front id="fastioH-1812">#define PG5_DDR			DDRG</front>
<front id="fastioH-1813">#define PG5_PWM			&OCR0B</front>
<front id="fastioH-1814">#undef PG6</front>
<front id="fastioH-1815">#define PG6_PIN			PING6</front>
<front id="fastioH-1816">#define PG6_RPORT		PING</front>
<front id="fastioH-1817">#define PG6_WPORT		PORTG</front>
<front id="fastioH-1818">#define PG6_DDR			DDRG</front>
<front id="fastioH-1819">#define PG6_PWM			NULL</front>
<front id="fastioH-1820">#undef PG7</front>
<front id="fastioH-1821">#define PG7_PIN			PING7</front>
<front id="fastioH-1822">#define PG7_RPORT		PING</front>
<front id="fastioH-1823">#define PG7_WPORT		PORTG</front>
<front id="fastioH-1824">#define PG7_DDR			DDRG</front>
<front id="fastioH-1825">#define PG7_PWM			NULL</front>
<front id="fastioH-1826"></front>
<front id="fastioH-1827">#undef PH0</front>
<front id="fastioH-1828">#define PH0_PIN			PINH0</front>
<front id="fastioH-1829">#define PH0_RPORT		PINH</front>
<front id="fastioH-1830">#define PH0_WPORT		PORTH</front>
<front id="fastioH-1831">#define PH0_DDR			DDRH</front>
<front id="fastioH-1832">#define PH0_PWM			NULL</front>
<front id="fastioH-1833">#undef PH1</front>
<front id="fastioH-1834">#define PH1_PIN			PINH1</front>
<front id="fastioH-1835">#define PH1_RPORT		PINH</front>
<front id="fastioH-1836">#define PH1_WPORT		PORTH</front>
<front id="fastioH-1837">#define PH1_DDR			DDRH</front>
<front id="fastioH-1838">#define PH1_PWM			NULL</front>
<front id="fastioH-1839">#undef PH2</front>
<front id="fastioH-1840">#define PH2_PIN			PINH2</front>
<front id="fastioH-1841">#define PH2_RPORT		PINH</front>
<front id="fastioH-1842">#define PH2_WPORT		PORTH</front>
<front id="fastioH-1843">#define PH2_DDR			DDRH</front>
<front id="fastioH-1844">#define PH2_PWM			NULL</front>
<front id="fastioH-1845">#undef PH3</front>
<front id="fastioH-1846">#define PH3_PIN			PINH3</front>
<front id="fastioH-1847">#define PH3_RPORT		PINH</front>
<front id="fastioH-1848">#define PH3_WPORT		PORTH</front>
<front id="fastioH-1849">#define PH3_DDR			DDRH</front>
<front id="fastioH-1850">#define PH3_PWM			&OCR4AL</front>
<front id="fastioH-1851">#undef PH4</front>
<front id="fastioH-1852">#define PH4_PIN			PINH4</front>
<front id="fastioH-1853">#define PH4_RPORT		PINH</front>
<front id="fastioH-1854">#define PH4_WPORT		PORTH</front>
<front id="fastioH-1855">#define PH4_DDR			DDRH</front>
<front id="fastioH-1856">#define PH4_PWM			&OCR4BL</front>
<front id="fastioH-1857">#undef PH5</front>
<front id="fastioH-1858">#define PH5_PIN			PINH5</front>
<front id="fastioH-1859">#define PH5_RPORT		PINH</front>
<front id="fastioH-1860">#define PH5_WPORT		PORTH</front>
<front id="fastioH-1861">#define PH5_DDR			DDRH</front>
<front id="fastioH-1862">#define PH5_PWM			&OCR4CL</front>
<front id="fastioH-1863">#undef PH6</front>
<front id="fastioH-1864">#define PH6_PIN			PINH6</front>
<front id="fastioH-1865">#define PH6_RPORT		PINH</front>
<front id="fastioH-1866">#define PH6_WPORT		PORTH</front>
<front id="fastioH-1867">#define PH6_DDR			DDRH</front>
<front id="fastioH-1868">#define PH6_PWM			&OCR2B</front>
<front id="fastioH-1869">#undef PH7</front>
<front id="fastioH-1870">#define PH7_PIN			PINH7</front>
<front id="fastioH-1871">#define PH7_RPORT		PINH</front>
<front id="fastioH-1872">#define PH7_WPORT		PORTH</front>
<front id="fastioH-1873">#define PH7_DDR			DDRH</front>
<front id="fastioH-1874">#define PH7_PWM			NULL</front>
<front id="fastioH-1875"></front>
<front id="fastioH-1876">#undef PJ0</front>
<front id="fastioH-1877">#define PJ0_PIN			PINJ0</front>
<front id="fastioH-1878">#define PJ0_RPORT		PINJ</front>
<front id="fastioH-1879">#define PJ0_WPORT		PORTJ</front>
<front id="fastioH-1880">#define PJ0_DDR			DDRJ</front>
<front id="fastioH-1881">#define PJ0_PWM			NULL</front>
<front id="fastioH-1882">#undef PJ1</front>
<front id="fastioH-1883">#define PJ1_PIN			PINJ1</front>
<front id="fastioH-1884">#define PJ1_RPORT		PINJ</front>
<front id="fastioH-1885">#define PJ1_WPORT		PORTJ</front>
<front id="fastioH-1886">#define PJ1_DDR			DDRJ</front>
<front id="fastioH-1887">#define PJ1_PWM			NULL</front>
<front id="fastioH-1888">#undef PJ2</front>
<front id="fastioH-1889">#define PJ2_PIN			PINJ2</front>
<front id="fastioH-1890">#define PJ2_RPORT		PINJ</front>
<front id="fastioH-1891">#define PJ2_WPORT		PORTJ</front>
<front id="fastioH-1892">#define PJ2_DDR			DDRJ</front>
<front id="fastioH-1893">#define PJ2_PWM			NULL</front>
<front id="fastioH-1894">#undef PJ3</front>
<front id="fastioH-1895">#define PJ3_PIN			PINJ3</front>
<front id="fastioH-1896">#define PJ3_RPORT		PINJ</front>
<front id="fastioH-1897">#define PJ3_WPORT		PORTJ</front>
<front id="fastioH-1898">#define PJ3_DDR			DDRJ</front>
<front id="fastioH-1899">#define PJ3_PWM			NULL</front>
<front id="fastioH-1900">#undef PJ4</front>
<front id="fastioH-1901">#define PJ4_PIN			PINJ4</front>
<front id="fastioH-1902">#define PJ4_RPORT		PINJ</front>
<front id="fastioH-1903">#define PJ4_WPORT		PORTJ</front>
<front id="fastioH-1904">#define PJ4_DDR			DDRJ</front>
<front id="fastioH-1905">#define PJ4_PWM			NULL</front>
<front id="fastioH-1906">#undef PJ5</front>
<front id="fastioH-1907">#define PJ5_PIN			PINJ5</front>
<front id="fastioH-1908">#define PJ5_RPORT		PINJ</front>
<front id="fastioH-1909">#define PJ5_WPORT		PORTJ</front>
<front id="fastioH-1910">#define PJ5_DDR			DDRJ</front>
<front id="fastioH-1911">#define PJ5_PWM			NULL</front>
<front id="fastioH-1912">#undef PJ6</front>
<front id="fastioH-1913">#define PJ6_PIN			PINJ6</front>
<front id="fastioH-1914">#define PJ6_RPORT		PINJ</front>
<front id="fastioH-1915">#define PJ6_WPORT		PORTJ</front>
<front id="fastioH-1916">#define PJ6_DDR			DDRJ</front>
<front id="fastioH-1917">#define PJ6_PWM			NULL</front>
<front id="fastioH-1918">#undef PJ7</front>
<front id="fastioH-1919">#define PJ7_PIN			PINJ7</front>
<front id="fastioH-1920">#define PJ7_RPORT		PINJ</front>
<front id="fastioH-1921">#define PJ7_WPORT		PORTJ</front>
<front id="fastioH-1922">#define PJ7_DDR			DDRJ</front>
<front id="fastioH-1923">#define PJ7_PWM			NULL</front>
<front id="fastioH-1924"></front>
<front id="fastioH-1925">#undef PK0</front>
<front id="fastioH-1926">#define PK0_PIN			PINK0</front>
<front id="fastioH-1927">#define PK0_RPORT		PINK</front>
<front id="fastioH-1928">#define PK0_WPORT		PORTK</front>
<front id="fastioH-1929">#define PK0_DDR			DDRK</front>
<front id="fastioH-1930">#define PK0_PWM			NULL</front>
<front id="fastioH-1931">#undef PK1</front>
<front id="fastioH-1932">#define PK1_PIN			PINK1</front>
<front id="fastioH-1933">#define PK1_RPORT		PINK</front>
<front id="fastioH-1934">#define PK1_WPORT		PORTK</front>
<front id="fastioH-1935">#define PK1_DDR			DDRK</front>
<front id="fastioH-1936">#define PK1_PWM			NULL</front>
<front id="fastioH-1937">#undef PK2</front>
<front id="fastioH-1938">#define PK2_PIN			PINK2</front>
<front id="fastioH-1939">#define PK2_RPORT		PINK</front>
<front id="fastioH-1940">#define PK2_WPORT		PORTK</front>
<front id="fastioH-1941">#define PK2_DDR			DDRK</front>
<front id="fastioH-1942">#define PK2_PWM			NULL</front>
<front id="fastioH-1943">#undef PK3</front>
<front id="fastioH-1944">#define PK3_PIN			PINK3</front>
<front id="fastioH-1945">#define PK3_RPORT		PINK</front>
<front id="fastioH-1946">#define PK3_WPORT		PORTK</front>
<front id="fastioH-1947">#define PK3_DDR			DDRK</front>
<front id="fastioH-1948">#define PK3_PWM			NULL</front>
<front id="fastioH-1949">#undef PK4</front>
<front id="fastioH-1950">#define PK4_PIN			PINK4</front>
<front id="fastioH-1951">#define PK4_RPORT		PINK</front>
<front id="fastioH-1952">#define PK4_WPORT		PORTK</front>
<front id="fastioH-1953">#define PK4_DDR			DDRK</front>
<front id="fastioH-1954">#define PK4_PWM			NULL</front>
<front id="fastioH-1955">#undef PK5</front>
<front id="fastioH-1956">#define PK5_PIN			PINK5</front>
<front id="fastioH-1957">#define PK5_RPORT		PINK</front>
<front id="fastioH-1958">#define PK5_WPORT		PORTK</front>
<front id="fastioH-1959">#define PK5_DDR			DDRK</front>
<front id="fastioH-1960">#define PK5_PWM			NULL</front>
<front id="fastioH-1961">#undef PK6</front>
<front id="fastioH-1962">#define PK6_PIN			PINK6</front>
<front id="fastioH-1963">#define PK6_RPORT		PINK</front>
<front id="fastioH-1964">#define PK6_WPORT		PORTK</front>
<front id="fastioH-1965">#define PK6_DDR			DDRK</front>
<front id="fastioH-1966">#define PK6_PWM			NULL</front>
<front id="fastioH-1967">#undef PK7</front>
<front id="fastioH-1968">#define PK7_PIN			PINK7</front>
<front id="fastioH-1969">#define PK7_RPORT		PINK</front>
<front id="fastioH-1970">#define PK7_WPORT		PORTK</front>
<front id="fastioH-1971">#define PK7_DDR			DDRK</front>
<front id="fastioH-1972">#define PK7_PWM			NULL</front>
<front id="fastioH-1973"></front>
<front id="fastioH-1974">#undef PL0</front>
<front id="fastioH-1975">#define PL0_PIN			PINL0</front>
<front id="fastioH-1976">#define PL0_RPORT		PINL</front>
<front id="fastioH-1977">#define PL0_WPORT		PORTL</front>
<front id="fastioH-1978">#define PL0_DDR			DDRL</front>
<front id="fastioH-1979">#define PL0_PWM			NULL</front>
<front id="fastioH-1980">#undef PL1</front>
<front id="fastioH-1981">#define PL1_PIN			PINL1</front>
<front id="fastioH-1982">#define PL1_RPORT		PINL</front>
<front id="fastioH-1983">#define PL1_WPORT		PORTL</front>
<front id="fastioH-1984">#define PL1_DDR			DDRL</front>
<front id="fastioH-1985">#define PL1_PWM			NULL</front>
<front id="fastioH-1986">#undef PL2</front>
<front id="fastioH-1987">#define PL2_PIN			PINL2</front>
<front id="fastioH-1988">#define PL2_RPORT		PINL</front>
<front id="fastioH-1989">#define PL2_WPORT		PORTL</front>
<front id="fastioH-1990">#define PL2_DDR			DDRL</front>
<front id="fastioH-1991">#define PL2_PWM			NULL</front>
<front id="fastioH-1992">#undef PL3</front>
<front id="fastioH-1993">#define PL3_PIN			PINL3</front>
<front id="fastioH-1994">#define PL3_RPORT		PINL</front>
<front id="fastioH-1995">#define PL3_WPORT		PORTL</front>
<front id="fastioH-1996">#define PL3_DDR			DDRL</front>
<front id="fastioH-1997">#define PL3_PWM			&OCR5AL</front>
<front id="fastioH-1998">#undef PL4</front>
<front id="fastioH-1999">#define PL4_PIN			PINL4</front>
<front id="fastioH-2000">#define PL4_RPORT		PINL</front>
<front id="fastioH-2001">#define PL4_WPORT		PORTL</front>
<front id="fastioH-2002">#define PL4_DDR			DDRL</front>
<front id="fastioH-2003">#define PL4_PWM			&OCR5BL</front>
<front id="fastioH-2004">#undef PL5</front>
<front id="fastioH-2005">#define PL5_PIN			PINL5</front>
<front id="fastioH-2006">#define PL5_RPORT		PINL</front>
<front id="fastioH-2007">#define PL5_WPORT		PORTL</front>
<front id="fastioH-2008">#define PL5_DDR			DDRL</front>
<front id="fastioH-2009">#define PL5_PWM			&OCR5CL</front>
<front id="fastioH-2010">#undef PL6</front>
<front id="fastioH-2011">#define PL6_PIN			PINL6</front>
<front id="fastioH-2012">#define PL6_RPORT		PINL</front>
<front id="fastioH-2013">#define PL6_WPORT		PORTL</front>
<front id="fastioH-2014">#define PL6_DDR			DDRL</front>
<front id="fastioH-2015">#define PL6_PWM			NULL</front>
<front id="fastioH-2016">#undef PL7</front>
<front id="fastioH-2017">#define PL7_PIN			PINL7</front>
<front id="fastioH-2018">#define PL7_RPORT		PINL</front>
<front id="fastioH-2019">#define PL7_WPORT		PORTL</front>
<front id="fastioH-2020">#define PL7_DDR			DDRL</front>
<front id="fastioH-2021">#define PL7_PWM			NULL</front>
<front id="fastioH-2022"></front>
<front id="fastioH-2023">#endif</front>
<front id="fastioH-2024"></front>
<front id="fastioH-2025">#if defined (__AVR_AT90USB1287__) || defined (__AVR_AT90USB1286__) || defined (__AVR_AT90USB646__) || defined(__AVR_AT90USB647__)</front>
<front id="fastioH-2026">// SPI</front>
<front id="fastioH-2027">#define	SCK					DIO9</front>
<front id="fastioH-2028">#define	MISO				DIO11</front>
<front id="fastioH-2029">#define	MOSI				DIO10</front>
<front id="fastioH-2030">#define	SS					DIO8</front>
<front id="fastioH-2031"></front>
<front id="fastioH-2032">// change for your board</front>
<front id="fastioH-2033">#define	DEBUG_LED		DIO31 /* led D5 red */</front>
<front id="fastioH-2034"></front>
<front id="fastioH-2035">/*</front>
<front id="fastioH-2036">pins</front>
<front id="fastioH-2037">*/</front>
<front id="fastioH-2038">#define DIO0_PIN        PINA0</front>
<front id="fastioH-2039">#define DIO0_RPORT      PINA</front>
<front id="fastioH-2040">#define DIO0_WPORT      PORTA</front>
<front id="fastioH-2041">#define DIO0_PWM			NULL</front>
<front id="fastioH-2042">#define DIO0_DDR        DDRA</front>
<front id="fastioH-2043"></front>
<front id="fastioH-2044">#define DIO1_PIN        PINA1</front>
<front id="fastioH-2045">#define DIO1_RPORT      PINA</front>
<front id="fastioH-2046">#define DIO1_WPORT      PORTA</front>
<front id="fastioH-2047">#define DIO1_PWM			NULL</front>
<front id="fastioH-2048">#define DIO1_DDR        DDRA</front>
<front id="fastioH-2049"></front>
<front id="fastioH-2050">#define DIO2_PIN        PINA2</front>
<front id="fastioH-2051">#define DIO2_RPORT      PINA</front>
<front id="fastioH-2052">#define DIO2_WPORT      PORTA</front>
<front id="fastioH-2053">#define DIO2_PWM			NULL</front>
<front id="fastioH-2054">#define DIO2_DDR        DDRA</front>
<front id="fastioH-2055"></front>
<front id="fastioH-2056">#define DIO3_PIN        PINA3</front>
<front id="fastioH-2057">#define DIO3_RPORT      PINA</front>
<front id="fastioH-2058">#define DIO3_WPORT      PORTA</front>
<front id="fastioH-2059">#define DIO3_PWM			NULL</front>
<front id="fastioH-2060">#define DIO3_DDR        DDRA</front>
<front id="fastioH-2061"></front>
<front id="fastioH-2062">#define DIO4_PIN        PINA4</front>
<front id="fastioH-2063">#define DIO4_RPORT      PINA</front>
<front id="fastioH-2064">#define DIO4_WPORT      PORTA</front>
<front id="fastioH-2065">#define DIO4_PWM			NULL</front>
<front id="fastioH-2066">#define DIO4_DDR        DDRA</front>
<front id="fastioH-2067"></front>
<front id="fastioH-2068">#define DIO5_PIN        PINA5</front>
<front id="fastioH-2069">#define DIO5_RPORT      PINA</front>
<front id="fastioH-2070">#define DIO5_WPORT      PORTA</front>
<front id="fastioH-2071">#define DIO5_PWM			NULL</front>
<front id="fastioH-2072">#define DIO5_DDR        DDRA</front>
<front id="fastioH-2073"></front>
<front id="fastioH-2074">#define DIO6_PIN        PINA6</front>
<front id="fastioH-2075">#define DIO6_RPORT      PINA</front>
<front id="fastioH-2076">#define DIO6_WPORT      PORTA</front>
<front id="fastioH-2077">#define DIO6_PWM			NULL</front>
<front id="fastioH-2078">#define DIO6_DDR        DDRA</front>
<front id="fastioH-2079"></front>
<front id="fastioH-2080">#define DIO7_PIN        PINA7</front>
<front id="fastioH-2081">#define DIO7_RPORT      PINA</front>
<front id="fastioH-2082">#define DIO7_WPORT      PORTA</front>
<front id="fastioH-2083">#define DIO7_PWM			NULL</front>
<front id="fastioH-2084">#define DIO7_DDR        DDRA</front>
<front id="fastioH-2085"></front>
<front id="fastioH-2086">#define DIO8_PIN        PINB0</front>
<front id="fastioH-2087">#define DIO8_RPORT      PINB</front>
<front id="fastioH-2088">#define DIO8_WPORT      PORTB</front>
<front id="fastioH-2089">#define DIO8_PWM			NULL</front>
<front id="fastioH-2090">#define DIO8_DDR        DDRB</front>
<front id="fastioH-2091"></front>
<front id="fastioH-2092">#define DIO9_PIN        PINB1</front>
<front id="fastioH-2093">#define DIO9_RPORT      PINB</front>
<front id="fastioH-2094">#define DIO9_WPORT      PORTB</front>
<front id="fastioH-2095">#define DIO9_PWM			NULL</front>
<front id="fastioH-2096">#define DIO9_DDR        DDRB</front>
<front id="fastioH-2097"></front>
<front id="fastioH-2098">#define DIO10_PIN       PINB2</front>
<front id="fastioH-2099">#define DIO10_RPORT     PINB</front>
<front id="fastioH-2100">#define DIO10_WPORT     PORTB</front>
<front id="fastioH-2101">#define DIO10_PWM			NULL</front>
<front id="fastioH-2102">#define DIO10_DDR       DDRB</front>
<front id="fastioH-2103"></front>
<front id="fastioH-2104">#define DIO11_PIN       PINB3</front>
<front id="fastioH-2105">#define DIO11_RPORT     PINB</front>
<front id="fastioH-2106">#define DIO11_WPORT     PORTB</front>
<front id="fastioH-2107">#define DIO11_PWM			NULL</front>
<front id="fastioH-2108">#define DIO11_DDR       DDRB</front>
<front id="fastioH-2109"></front>
<front id="fastioH-2110">#define DIO12_PIN       PINB4</front>
<front id="fastioH-2111">#define DIO12_RPORT     PINB</front>
<front id="fastioH-2112">#define DIO12_WPORT     PORTB</front>
<front id="fastioH-2113">#define DIO12_PWM			NULL</front>
<front id="fastioH-2114">#define DIO12_DDR       DDRB</front>
<front id="fastioH-2115"></front>
<front id="fastioH-2116">#define DIO13_PIN       PINB5</front>
<front id="fastioH-2117">#define DIO13_RPORT     PINB</front>
<front id="fastioH-2118">#define DIO13_WPORT     PORTB</front>
<front id="fastioH-2119">#define DIO13_PWM			NULL</front>
<front id="fastioH-2120">#define DIO13_DDR       DDRB</front>
<front id="fastioH-2121"></front>
<front id="fastioH-2122">#define DIO14_PIN       PINB6</front>
<front id="fastioH-2123">#define DIO14_RPORT     PINB</front>
<front id="fastioH-2124">#define DIO14_WPORT     PORTB</front>
<front id="fastioH-2125">#define DIO14_PWM			NULL</front>
<front id="fastioH-2126">#define DIO14_DDR       DDRB</front>
<front id="fastioH-2127"></front>
<front id="fastioH-2128">#define DIO15_PIN       PINB7</front>
<front id="fastioH-2129">#define DIO15_RPORT     PINB</front>
<front id="fastioH-2130">#define DIO15_WPORT     PORTB</front>
<front id="fastioH-2131">#define DIO15_PWM			NULL</front>
<front id="fastioH-2132">#define DIO15_DDR       DDRB</front>
<front id="fastioH-2133"></front>
<front id="fastioH-2134">#define DIO16_PIN       PINC0</front>
<front id="fastioH-2135">#define DIO16_RPORT     PINC</front>
<front id="fastioH-2136">#define DIO16_WPORT     PORTC</front>
<front id="fastioH-2137">#define DIO16_PWM			NULL</front>
<front id="fastioH-2138">#define DIO16_DDR       DDRC</front>
<front id="fastioH-2139"></front>
<front id="fastioH-2140">#define DIO17_PIN       PINC1</front>
<front id="fastioH-2141">#define DIO17_RPORT     PINC</front>
<front id="fastioH-2142">#define DIO17_WPORT     PORTC</front>
<front id="fastioH-2143">#define DIO17_PWM			NULL</front>
<front id="fastioH-2144">#define DIO17_DDR       DDRC</front>
<front id="fastioH-2145"></front>
<front id="fastioH-2146">#define DIO18_PIN       PINC2</front>
<front id="fastioH-2147">#define DIO18_RPORT     PINC</front>
<front id="fastioH-2148">#define DIO18_WPORT     PORTC</front>
<front id="fastioH-2149">#define DIO18_PWM			NULL</front>
<front id="fastioH-2150">#define DIO18_DDR       DDRC</front>
<front id="fastioH-2151"></front>
<front id="fastioH-2152">#define DIO19_PIN       PINC3</front>
<front id="fastioH-2153">#define DIO19_RPORT     PINC</front>
<front id="fastioH-2154">#define DIO19_WPORT     PORTC</front>
<front id="fastioH-2155">#define DIO19_PWM			NULL</front>
<front id="fastioH-2156">#define DIO19_DDR       DDRC</front>
<front id="fastioH-2157"></front>
<front id="fastioH-2158">#define DIO20_PIN       PINC4</front>
<front id="fastioH-2159">#define DIO20_RPORT     PINC</front>
<front id="fastioH-2160">#define DIO20_WPORT     PORTC</front>
<front id="fastioH-2161">#define DIO20_PWM			NULL</front>
<front id="fastioH-2162">#define DIO20_DDR       DDRC</front>
<front id="fastioH-2163"></front>
<front id="fastioH-2164">#define DIO21_PIN       PINC5</front>
<front id="fastioH-2165">#define DIO21_RPORT     PINC</front>
<front id="fastioH-2166">#define DIO21_WPORT     PORTC</front>
<front id="fastioH-2167">#define DIO21_PWM			NULL</front>
<front id="fastioH-2168">#define DIO21_DDR       DDRC</front>
<front id="fastioH-2169"></front>
<front id="fastioH-2170">#define DIO22_PIN       PINC6</front>
<front id="fastioH-2171">#define DIO22_RPORT     PINC</front>
<front id="fastioH-2172">#define DIO22_WPORT     PORTC</front>
<front id="fastioH-2173">#define DIO22_PWM			NULL</front>
<front id="fastioH-2174">#define DIO22_DDR       DDRC</front>
<front id="fastioH-2175"></front>
<front id="fastioH-2176">#define DIO23_PIN       PINC7</front>
<front id="fastioH-2177">#define DIO23_RPORT     PINC</front>
<front id="fastioH-2178">#define DIO23_WPORT     PORTC</front>
<front id="fastioH-2179">#define DIO23_PWM			NULL</front>
<front id="fastioH-2180">#define DIO23_DDR       DDRC</front>
<front id="fastioH-2181"></front>
<front id="fastioH-2182">#define DIO24_PIN       PIND0</front>
<front id="fastioH-2183">#define DIO24_RPORT     PIND</front>
<front id="fastioH-2184">#define DIO24_WPORT     PORTD</front>
<front id="fastioH-2185">#define DIO24_PWM			NULL</front>
<front id="fastioH-2186">#define DIO24_DDR       DDRD</front>
<front id="fastioH-2187"></front>
<front id="fastioH-2188">#define DIO25_PIN       PIND1</front>
<front id="fastioH-2189">#define DIO25_RPORT     PIND</front>
<front id="fastioH-2190">#define DIO25_WPORT     PORTD</front>
<front id="fastioH-2191">#define DIO25_PWM			NULL</front>
<front id="fastioH-2192">#define DIO25_DDR       DDRD</front>
<front id="fastioH-2193"></front>
<front id="fastioH-2194">#define DIO26_PIN       PIND2</front>
<front id="fastioH-2195">#define DIO26_RPORT     PIND</front>
<front id="fastioH-2196">#define DIO26_WPORT     PORTD</front>
<front id="fastioH-2197">#define DIO26_PWM			NULL</front>
<front id="fastioH-2198">#define DIO26_DDR       DDRD</front>
<front id="fastioH-2199"></front>
<front id="fastioH-2200">#define DIO27_PIN       PIND3</front>
<front id="fastioH-2201">#define DIO27_RPORT     PIND</front>
<front id="fastioH-2202">#define DIO27_WPORT     PORTD</front>
<front id="fastioH-2203">#define DIO27_PWM			NULL</front>
<front id="fastioH-2204">#define DIO27_DDR       DDRD</front>
<front id="fastioH-2205"></front>
<front id="fastioH-2206">#define DIO28_PIN       PIND4</front>
<front id="fastioH-2207">#define DIO28_RPORT     PIND</front>
<front id="fastioH-2208">#define DIO28_WPORT     PORTD</front>
<front id="fastioH-2209">#define DIO28_PWM			NULL</front>
<front id="fastioH-2210">#define DIO28_DDR       DDRD</front>
<front id="fastioH-2211"></front>
<front id="fastioH-2212">#define DIO29_PIN       PIND5</front>
<front id="fastioH-2213">#define DIO29_RPORT     PIND</front>
<front id="fastioH-2214">#define DIO29_WPORT     PORTD</front>
<front id="fastioH-2215">#define DIO29_PWM			NULL</front>
<front id="fastioH-2216">#define DIO29_DDR       DDRD</front>
<front id="fastioH-2217"></front>
<front id="fastioH-2218">#define DIO30_PIN       PIND6</front>
<front id="fastioH-2219">#define DIO30_RPORT     PIND</front>
<front id="fastioH-2220">#define DIO30_WPORT     PORTD</front>
<front id="fastioH-2221">#define DIO30_PWM			NULL</front>
<front id="fastioH-2222">#define DIO30_DDR       DDRD</front>
<front id="fastioH-2223"></front>
<front id="fastioH-2224">#define DIO31_PIN       PIND7</front>
<front id="fastioH-2225">#define DIO31_RPORT     PIND</front>
<front id="fastioH-2226">#define DIO31_WPORT     PORTD</front>
<front id="fastioH-2227">#define DIO31_PWM			NULL</front>
<front id="fastioH-2228">#define DIO31_DDR       DDRD</front>
<front id="fastioH-2229"></front>
<front id="fastioH-2230"></front>
<front id="fastioH-2231">#define DIO32_PIN       PINE0</front>
<front id="fastioH-2232">#define DIO32_RPORT     PINE</front>
<front id="fastioH-2233">#define DIO32_WPORT     PORTE</front>
<front id="fastioH-2234">#define DIO32_PWM			NULL</front>
<front id="fastioH-2235">#define DIO32_DDR       DDRE</front>
<front id="fastioH-2236"></front>
<front id="fastioH-2237">#define DIO33_PIN       PINE1</front>
<front id="fastioH-2238">#define DIO33_RPORT     PINE</front>
<front id="fastioH-2239">#define DIO33_WPORT     PORTE</front>
<front id="fastioH-2240">#define DIO33_PWM			NULL</front>
<front id="fastioH-2241">#define DIO33_DDR       DDRE</front>
<front id="fastioH-2242"></front>
<front id="fastioH-2243">#define DIO34_PIN       PINE2</front>
<front id="fastioH-2244">#define DIO34_RPORT     PINE</front>
<front id="fastioH-2245">#define DIO34_WPORT     PORTE</front>
<front id="fastioH-2246">#define DIO34_PWM			NULL</front>
<front id="fastioH-2247">#define DIO34_DDR       DDRE</front>
<front id="fastioH-2248"></front>
<front id="fastioH-2249">#define DIO35_PIN       PINE3</front>
<front id="fastioH-2250">#define DIO35_RPORT     PINE</front>
<front id="fastioH-2251">#define DIO35_WPORT     PORTE</front>
<front id="fastioH-2252">#define DIO35_PWM			NULL</front>
<front id="fastioH-2253">#define DIO35_DDR       DDRE</front>
<front id="fastioH-2254"></front>
<front id="fastioH-2255">#define DIO36_PIN       PINE4</front>
<front id="fastioH-2256">#define DIO36_RPORT     PINE</front>
<front id="fastioH-2257">#define DIO36_WPORT     PORTE</front>
<front id="fastioH-2258">#define DIO36_PWM			NULL</front>
<front id="fastioH-2259">#define DIO36_DDR       DDRE</front>
<front id="fastioH-2260"></front>
<front id="fastioH-2261">#define DIO37_PIN       PINE5</front>
<front id="fastioH-2262">#define DIO37_RPORT     PINE</front>
<front id="fastioH-2263">#define DIO37_WPORT     PORTE</front>
<front id="fastioH-2264">#define DIO37_PWM			NULL</front>
<front id="fastioH-2265">#define DIO37_DDR       DDRE</front>
<front id="fastioH-2266"></front>
<front id="fastioH-2267">#define DIO38_PIN       PINE6</front>
<front id="fastioH-2268">#define DIO38_RPORT     PINE</front>
<front id="fastioH-2269">#define DIO38_WPORT     PORTE</front>
<front id="fastioH-2270">#define DIO38_PWM			NULL</front>
<front id="fastioH-2271">#define DIO38_DDR       DDRE</front>
<front id="fastioH-2272"></front>
<front id="fastioH-2273">#define DIO39_PIN       PINE7</front>
<front id="fastioH-2274">#define DIO39_RPORT     PINE</front>
<front id="fastioH-2275">#define DIO39_WPORT     PORTE</front>
<front id="fastioH-2276">#define DIO39_PWM			NULL</front>
<front id="fastioH-2277">#define DIO39_DDR       DDRE</front>
<front id="fastioH-2278"></front>
<front id="fastioH-2279">#define AIO0_PIN PINF0</front>
<front id="fastioH-2280">#define AIO0_RPORT PINF</front>
<front id="fastioH-2281">#define AIO0_WPORT PORTF</front>
<front id="fastioH-2282">#define AIO0_PWM			NULL</front>
<front id="fastioH-2283">#define AIO0_DDR DDRF</front>
<front id="fastioH-2284"></front>
<front id="fastioH-2285">#define AIO1_PIN PINF1</front>
<front id="fastioH-2286">#define AIO1_RPORT PINF</front>
<front id="fastioH-2287">#define AIO1_WPORT PORTF</front>
<front id="fastioH-2288">#define AIO1_PWM			NULL</front>
<front id="fastioH-2289">#define AIO1_DDR DDRF</front>
<front id="fastioH-2290"></front>
<front id="fastioH-2291">#define AIO2_PIN PINF2</front>
<front id="fastioH-2292">#define AIO2_RPORT PINF</front>
<front id="fastioH-2293">#define AIO2_WPORT PORTF</front>
<front id="fastioH-2294">#define AIO2_PWM			NULL</front>
<front id="fastioH-2295">#define AIO2_DDR DDRF</front>
<front id="fastioH-2296"></front>
<front id="fastioH-2297">#define AIO3_PIN PINF3</front>
<front id="fastioH-2298">#define AIO3_RPORT PINF</front>
<front id="fastioH-2299">#define AIO3_WPORT PORTF</front>
<front id="fastioH-2300">#define AIO3_PWM			NULL</front>
<front id="fastioH-2301">#define AIO3_DDR DDRF</front>
<front id="fastioH-2302"></front>
<front id="fastioH-2303">#define AIO4_PIN PINF4</front>
<front id="fastioH-2304">#define AIO4_RPORT PINF</front>
<front id="fastioH-2305">#define AIO4_WPORT PORTF</front>
<front id="fastioH-2306">#define AIO4_PWM			NULL</front>
<front id="fastioH-2307">#define AIO4_DDR DDRF</front>
<front id="fastioH-2308"></front>
<front id="fastioH-2309">#define AIO5_PIN PINF5</front>
<front id="fastioH-2310">#define AIO5_RPORT PINF</front>
<front id="fastioH-2311">#define AIO5_WPORT PORTF</front>
<front id="fastioH-2312">#define AIO5_PWM			NULL</front>
<front id="fastioH-2313">#define AIO5_DDR DDRF</front>
<front id="fastioH-2314"></front>
<front id="fastioH-2315">#define AIO6_PIN PINF6</front>
<front id="fastioH-2316">#define AIO6_RPORT PINF</front>
<front id="fastioH-2317">#define AIO6_WPORT PORTF</front>
<front id="fastioH-2318">#define AIO6_PWM			NULL</front>
<front id="fastioH-2319">#define AIO6_DDR DDRF</front>
<front id="fastioH-2320"></front>
<front id="fastioH-2321">#define AIO7_PIN PINF7</front>
<front id="fastioH-2322">#define AIO7_RPORT PINF</front>
<front id="fastioH-2323">#define AIO7_WPORT PORTF</front>
<front id="fastioH-2324">#define AIO7_PWM			NULL</front>
<front id="fastioH-2325">#define AIO7_DDR DDRF</front>
<front id="fastioH-2326"></front>
<front id="fastioH-2327">#define DIO40_PIN       PINF0</front>
<front id="fastioH-2328">#define DIO40_RPORT     PINF</front>
<front id="fastioH-2329">#define DIO40_WPORT     PORTF</front>
<front id="fastioH-2330">#define DIO40_PWM			NULL</front>
<front id="fastioH-2331">#define DIO40_DDR       DDRF</front>
<front id="fastioH-2332"></front>
<front id="fastioH-2333">#define DIO41_PIN       PINF1</front>
<front id="fastioH-2334">#define DIO41_RPORT     PINF</front>
<front id="fastioH-2335">#define DIO41_WPORT     PORTF</front>
<front id="fastioH-2336">#define DIO41_PWM			NULL</front>
<front id="fastioH-2337">#define DIO41_DDR       DDRF</front>
<front id="fastioH-2338"></front>
<front id="fastioH-2339">#define DIO42_PIN       PINF2</front>
<front id="fastioH-2340">#define DIO42_RPORT     PINF</front>
<front id="fastioH-2341">#define DIO42_WPORT     PORTF</front>
<front id="fastioH-2342">#define DIO42_PWM			NULL</front>
<front id="fastioH-2343">#define DIO42_DDR       DDRF</front>
<front id="fastioH-2344"></front>
<front id="fastioH-2345">#define DIO43_PIN       PINF3</front>
<front id="fastioH-2346">#define DIO43_RPORT     PINF</front>
<front id="fastioH-2347">#define DIO43_WPORT     PORTF</front>
<front id="fastioH-2348">#define DIO43_PWM			NULL</front>
<front id="fastioH-2349">#define DIO43_DDR       DDRF</front>
<front id="fastioH-2350"></front>
<front id="fastioH-2351">#define DIO44_PIN       PINF4</front>
<front id="fastioH-2352">#define DIO44_RPORT     PINF</front>
<front id="fastioH-2353">#define DIO44_WPORT     PORTF</front>
<front id="fastioH-2354">#define DIO44_PWM			NULL</front>
<front id="fastioH-2355">#define DIO44_DDR       DDRF</front>
<front id="fastioH-2356"></front>
<front id="fastioH-2357">#define DIO45_PIN       PINF5</front>
<front id="fastioH-2358">#define DIO45_RPORT     PINF</front>
<front id="fastioH-2359">#define DIO45_WPORT     PORTF</front>
<front id="fastioH-2360">#define DIO45_PWM			NULL</front>
<front id="fastioH-2361">#define DIO45_DDR       DDRF</front>
<front id="fastioH-2362"></front>
<front id="fastioH-2363">#define DIO46_PIN       PINF6</front>
<front id="fastioH-2364">#define DIO46_RPORT     PINF</front>
<front id="fastioH-2365">#define DIO46_WPORT     PORTF</front>
<front id="fastioH-2366">#define DIO46_PWM			NULL</front>
<front id="fastioH-2367">#define DIO46_DDR       DDRF</front>
<front id="fastioH-2368"></front>
<front id="fastioH-2369">#define DIO47_PIN       PINF7</front>
<front id="fastioH-2370">#define DIO47_RPORT     PINF</front>
<front id="fastioH-2371">#define DIO47_WPORT     PORTF</front>
<front id="fastioH-2372">#define DIO47_PWM			NULL</front>
<front id="fastioH-2373">#define DIO47_DDR       DDRF</front>
<front id="fastioH-2374"></front>
<front id="fastioH-2375"></front>
<front id="fastioH-2376"></front>
<front id="fastioH-2377">#undef PA0</front>
<front id="fastioH-2378">#define PA0_PIN			PINA0</front>
<front id="fastioH-2379">#define PA0_RPORT		PINA</front>
<front id="fastioH-2380">#define PA0_WPORT		PORTA</front>
<front id="fastioH-2381">#define PA0_PWM			NULL</front>
<front id="fastioH-2382">#define PA0_DDR			DDRA</front>
<front id="fastioH-2383">#undef PA1</front>
<front id="fastioH-2384">#define PA1_PIN			PINA1</front>
<front id="fastioH-2385">#define PA1_RPORT		PINA</front>
<front id="fastioH-2386">#define PA1_WPORT		PORTA</front>
<front id="fastioH-2387">#define PA1_PWM			NULL</front>
<front id="fastioH-2388">#define PA1_DDR			DDRA</front>
<front id="fastioH-2389">#undef PA2</front>
<front id="fastioH-2390">#define PA2_PIN			PINA2</front>
<front id="fastioH-2391">#define PA2_RPORT		PINA</front>
<front id="fastioH-2392">#define PA2_WPORT		PORTA</front>
<front id="fastioH-2393">#define PA2_PWM			NULL</front>
<front id="fastioH-2394">#define PA2_DDR			DDRA</front>
<front id="fastioH-2395">#undef PA3</front>
<front id="fastioH-2396">#define PA3_PIN			PINA3</front>
<front id="fastioH-2397">#define PA3_RPORT		PINA</front>
<front id="fastioH-2398">#define PA3_WPORT		PORTA</front>
<front id="fastioH-2399">#define PA3_PWM			NULL</front>
<front id="fastioH-2400">#define PA3_DDR			DDRA</front>
<front id="fastioH-2401">#undef PA4</front>
<front id="fastioH-2402">#define PA4_PIN			PINA4</front>
<front id="fastioH-2403">#define PA4_RPORT		PINA</front>
<front id="fastioH-2404">#define PA4_WPORT		PORTA</front>
<front id="fastioH-2405">#define PA4_PWM			NULL</front>
<front id="fastioH-2406">#define PA4_DDR			DDRA</front>
<front id="fastioH-2407">#undef PA5</front>
<front id="fastioH-2408">#define PA5_PIN			PINA5</front>
<front id="fastioH-2409">#define PA5_RPORT		PINA</front>
<front id="fastioH-2410">#define PA5_WPORT		PORTA</front>
<front id="fastioH-2411">#define PA5_PWM			NULL</front>
<front id="fastioH-2412">#define PA5_DDR			DDRA</front>
<front id="fastioH-2413">#undef PA6</front>
<front id="fastioH-2414">#define PA6_PIN			PINA6</front>
<front id="fastioH-2415">#define PA6_RPORT		PINA</front>
<front id="fastioH-2416">#define PA6_WPORT		PORTA</front>
<front id="fastioH-2417">#define PA6_PWM			NULL</front>
<front id="fastioH-2418">#define PA6_DDR			DDRA</front>
<front id="fastioH-2419">#undef PA7</front>
<front id="fastioH-2420">#define PA7_PIN			PINA7</front>
<front id="fastioH-2421">#define PA7_RPORT		PINA</front>
<front id="fastioH-2422">#define PA7_WPORT		PORTA</front>
<front id="fastioH-2423">#define PA7_PWM			NULL</front>
<front id="fastioH-2424">#define PA7_DDR			DDRA</front>
<front id="fastioH-2425"></front>
<front id="fastioH-2426">#undef PB0</front>
<front id="fastioH-2427">#define PB0_PIN			PINB0</front>
<front id="fastioH-2428">#define PB0_RPORT		PINB</front>
<front id="fastioH-2429">#define PB0_WPORT		PORTB</front>
<front id="fastioH-2430">#define PB0_PWM			NULL</front>
<front id="fastioH-2431">#define PB0_DDR			DDRB</front>
<front id="fastioH-2432">#undef PB1</front>
<front id="fastioH-2433">#define PB1_PIN			PINB1</front>
<front id="fastioH-2434">#define PB1_RPORT		PINB</front>
<front id="fastioH-2435">#define PB1_WPORT		PORTB</front>
<front id="fastioH-2436">#define PB1_PWM			NULL</front>
<front id="fastioH-2437">#define PB1_DDR			DDRB</front>
<front id="fastioH-2438">#undef PB2</front>
<front id="fastioH-2439">#define PB2_PIN			PINB2</front>
<front id="fastioH-2440">#define PB2_RPORT		PINB</front>
<front id="fastioH-2441">#define PB2_WPORT		PORTB</front>
<front id="fastioH-2442">#define PB2_PWM			NULL</front>
<front id="fastioH-2443">#define PB2_DDR			DDRB</front>
<front id="fastioH-2444">#undef PB3</front>
<front id="fastioH-2445">#define PB3_PIN			PINB3</front>
<front id="fastioH-2446">#define PB3_RPORT		PINB</front>
<front id="fastioH-2447">#define PB3_WPORT		PORTB</front>
<front id="fastioH-2448">#define PB3_PWM			NULL</front>
<front id="fastioH-2449">#define PB3_DDR			DDRB</front>
<front id="fastioH-2450">#undef PB4</front>
<front id="fastioH-2451">#define PB4_PIN			PINB4</front>
<front id="fastioH-2452">#define PB4_RPORT		PINB</front>
<front id="fastioH-2453">#define PB4_WPORT		PORTB</front>
<front id="fastioH-2454">#define PB4_PWM			NULL</front>
<front id="fastioH-2455">#define PB4_DDR			DDRB</front>
<front id="fastioH-2456">#undef PB5</front>
<front id="fastioH-2457">#define PB5_PIN			PINB5</front>
<front id="fastioH-2458">#define PB5_RPORT		PINB</front>
<front id="fastioH-2459">#define PB5_WPORT		PORTB</front>
<front id="fastioH-2460">#define PB5_PWM			NULL</front>
<front id="fastioH-2461">#define PB5_DDR			DDRB</front>
<front id="fastioH-2462">#undef PB6</front>
<front id="fastioH-2463">#define PB6_PIN			PINB6</front>
<front id="fastioH-2464">#define PB6_RPORT		PINB</front>
<front id="fastioH-2465">#define PB6_WPORT		PORTB</front>
<front id="fastioH-2466">#define PB6_PWM			NULL</front>
<front id="fastioH-2467">#define PB6_DDR			DDRB</front>
<front id="fastioH-2468">#undef PB7</front>
<front id="fastioH-2469">#define PB7_PIN			PINB7</front>
<front id="fastioH-2470">#define PB7_RPORT		PINB</front>
<front id="fastioH-2471">#define PB7_WPORT		PORTB</front>
<front id="fastioH-2472">#define PB7_PWM			NULL</front>
<front id="fastioH-2473">#define PB7_DDR			DDRB</front>
<front id="fastioH-2474"></front>
<front id="fastioH-2475">#undef PC0</front>
<front id="fastioH-2476">#define PC0_PIN			PINC0</front>
<front id="fastioH-2477">#define PC0_RPORT		PINC</front>
<front id="fastioH-2478">#define PC0_WPORT		PORTC</front>
<front id="fastioH-2479">#define PC0_PWM			NULL</front>
<front id="fastioH-2480">#define PC0_DDR			DDRC</front>
<front id="fastioH-2481">#undef PC1</front>
<front id="fastioH-2482">#define PC1_PIN			PINC1</front>
<front id="fastioH-2483">#define PC1_RPORT		PINC</front>
<front id="fastioH-2484">#define PC1_WPORT		PORTC</front>
<front id="fastioH-2485">#define PC1_PWM			NULL</front>
<front id="fastioH-2486">#define PC1_DDR			DDRC</front>
<front id="fastioH-2487">#undef PC2</front>
<front id="fastioH-2488">#define PC2_PIN			PINC2</front>
<front id="fastioH-2489">#define PC2_RPORT		PINC</front>
<front id="fastioH-2490">#define PC2_WPORT		PORTC</front>
<front id="fastioH-2491">#define PC2_PWM			NULL</front>
<front id="fastioH-2492">#define PC2_DDR			DDRC</front>
<front id="fastioH-2493">#undef PC3</front>
<front id="fastioH-2494">#define PC3_PIN			PINC3</front>
<front id="fastioH-2495">#define PC3_RPORT		PINC</front>
<front id="fastioH-2496">#define PC3_WPORT		PORTC</front>
<front id="fastioH-2497">#define PC3_PWM			NULL</front>
<front id="fastioH-2498">#define PC3_DDR			DDRC</front>
<front id="fastioH-2499">#undef PC4</front>
<front id="fastioH-2500">#define PC4_PIN			PINC4</front>
<front id="fastioH-2501">#define PC4_RPORT		PINC</front>
<front id="fastioH-2502">#define PC4_WPORT		PORTC</front>
<front id="fastioH-2503">#define PC4_PWM			NULL</front>
<front id="fastioH-2504">#define PC4_DDR			DDRC</front>
<front id="fastioH-2505">#undef PC5</front>
<front id="fastioH-2506">#define PC5_PIN			PINC5</front>
<front id="fastioH-2507">#define PC5_RPORT		PINC</front>
<front id="fastioH-2508">#define PC5_WPORT		PORTC</front>
<front id="fastioH-2509">#define PC5_PWM			NULL</front>
<front id="fastioH-2510">#define PC5_DDR			DDRC</front>
<front id="fastioH-2511">#undef PC6</front>
<front id="fastioH-2512">#define PC6_PIN			PINC6</front>
<front id="fastioH-2513">#define PC6_RPORT		PINC</front>
<front id="fastioH-2514">#define PC6_WPORT		PORTC</front>
<front id="fastioH-2515">#define PC6_PWM			NULL</front>
<front id="fastioH-2516">#define PC6_DDR			DDRC</front>
<front id="fastioH-2517">#undef PC7</front>
<front id="fastioH-2518">#define PC7_PIN			PINC7</front>
<front id="fastioH-2519">#define PC7_RPORT		PINC</front>
<front id="fastioH-2520">#define PC7_WPORT		PORTC</front>
<front id="fastioH-2521">#define PC7_PWM			NULL</front>
<front id="fastioH-2522">#define PC7_DDR			DDRC</front>
<front id="fastioH-2523"></front>
<front id="fastioH-2524">#undef PD0</front>
<front id="fastioH-2525">#define PD0_PIN			PIND0</front>
<front id="fastioH-2526">#define PD0_RPORT		PIND</front>
<front id="fastioH-2527">#define PD0_WPORT		PORTD</front>
<front id="fastioH-2528">#define PD0_PWM			NULL</front>
<front id="fastioH-2529">#define PD0_DDR			DDRD</front>
<front id="fastioH-2530">#undef PD1</front>
<front id="fastioH-2531">#define PD1_PIN			PIND1</front>
<front id="fastioH-2532">#define PD1_RPORT		PIND</front>
<front id="fastioH-2533">#define PD1_WPORT		PORTD</front>
<front id="fastioH-2534">#define PD1_PWM			NULL</front>
<front id="fastioH-2535">#define PD1_DDR			DDRD</front>
<front id="fastioH-2536">#undef PD2</front>
<front id="fastioH-2537">#define PD2_PIN			PIND2</front>
<front id="fastioH-2538">#define PD2_RPORT		PIND</front>
<front id="fastioH-2539">#define PD2_WPORT		PORTD</front>
<front id="fastioH-2540">#define PD2_PWM			NULL</front>
<front id="fastioH-2541">#define PD2_DDR			DDRD</front>
<front id="fastioH-2542">#undef PD3</front>
<front id="fastioH-2543">#define PD3_PIN			PIND3</front>
<front id="fastioH-2544">#define PD3_RPORT		PIND</front>
<front id="fastioH-2545">#define PD3_WPORT		PORTD</front>
<front id="fastioH-2546">#define PD3_PWM			NULL</front>
<front id="fastioH-2547">#define PD3_DDR			DDRD</front>
<front id="fastioH-2548">#undef PD4</front>
<front id="fastioH-2549">#define PD4_PIN			PIND4</front>
<front id="fastioH-2550">#define PD4_RPORT		PIND</front>
<front id="fastioH-2551">#define PD4_WPORT		PORTD</front>
<front id="fastioH-2552">#define PD4_PWM			NULL</front>
<front id="fastioH-2553">#define PD4_DDR			DDRD</front>
<front id="fastioH-2554">#undef PD5</front>
<front id="fastioH-2555">#define PD5_PIN			PIND5</front>
<front id="fastioH-2556">#define PD5_RPORT		PIND</front>
<front id="fastioH-2557">#define PD5_WPORT		PORTD</front>
<front id="fastioH-2558">#define PD5_PWM			NULL</front>
<front id="fastioH-2559">#define PD5_DDR			DDRD</front>
<front id="fastioH-2560">#undef PD6</front>
<front id="fastioH-2561">#define PD6_PIN			PIND6</front>
<front id="fastioH-2562">#define PD6_RPORT		PIND</front>
<front id="fastioH-2563">#define PD6_WPORT		PORTD</front>
<front id="fastioH-2564">#define PD6_PWM			NULL</front>
<front id="fastioH-2565">#define PD6_DDR			DDRD</front>
<front id="fastioH-2566">#undef PD7</front>
<front id="fastioH-2567">#define PD7_PIN			PIND7</front>
<front id="fastioH-2568">#define PD7_RPORT		PIND</front>
<front id="fastioH-2569">#define PD7_WPORT		PORTD</front>
<front id="fastioH-2570">#define PD7_PWM			NULL</front>
<front id="fastioH-2571">#define PD7_DDR			DDRD</front>
<front id="fastioH-2572"></front>
<front id="fastioH-2573">#undef PE0</front>
<front id="fastioH-2574">#define PE0_PIN			PINE0</front>
<front id="fastioH-2575">#define PE0_RPORT		PINE</front>
<front id="fastioH-2576">#define PE0_WPORT		PORTE</front>
<front id="fastioH-2577">#define PE0_PWM			NULL</front>
<front id="fastioH-2578">#define PE0_DDR			DDRE</front>
<front id="fastioH-2579">#undef PE1</front>
<front id="fastioH-2580">#define PE1_PIN			PINE1</front>
<front id="fastioH-2581">#define PE1_RPORT		PINE</front>
<front id="fastioH-2582">#define PE1_WPORT		PORTE</front>
<front id="fastioH-2583">#define PE1_PWM			NULL</front>
<front id="fastioH-2584">#define PE1_DDR			DDRE</front>
<front id="fastioH-2585">#undef PE2</front>
<front id="fastioH-2586">#define PE2_PIN			PINE2</front>
<front id="fastioH-2587">#define PE2_RPORT		PINE</front>
<front id="fastioH-2588">#define PE2_WPORT		PORTE</front>
<front id="fastioH-2589">#define PE2_PWM			NULL</front>
<front id="fastioH-2590">#define PE2_DDR			DDRE</front>
<front id="fastioH-2591">#undef PE3</front>
<front id="fastioH-2592">#define PE3_PIN			PINE3</front>
<front id="fastioH-2593">#define PE3_RPORT		PINE</front>
<front id="fastioH-2594">#define PE3_WPORT		PORTE</front>
<front id="fastioH-2595">#define PE3_PWM			NULL</front>
<front id="fastioH-2596">#define PE3_DDR			DDRE</front>
<front id="fastioH-2597">#undef PE4</front>
<front id="fastioH-2598">#define PE4_PIN			PINE4</front>
<front id="fastioH-2599">#define PE4_RPORT		PINE</front>
<front id="fastioH-2600">#define PE4_WPORT		PORTE</front>
<front id="fastioH-2601">#define PE4_PWM			NULL</front>
<front id="fastioH-2602">#define PE4_DDR			DDRE</front>
<front id="fastioH-2603">#undef PE5</front>
<front id="fastioH-2604">#define PE5_PIN			PINE5</front>
<front id="fastioH-2605">#define PE5_RPORT		PINE</front>
<front id="fastioH-2606">#define PE5_WPORT		PORTE</front>
<front id="fastioH-2607">#define PE5_PWM			NULL</front>
<front id="fastioH-2608">#define PE5_DDR			DDRE</front>
<front id="fastioH-2609">#undef PE6</front>
<front id="fastioH-2610">#define PE6_PIN			PINE6</front>
<front id="fastioH-2611">#define PE6_RPORT		PINE</front>
<front id="fastioH-2612">#define PE6_WPORT		PORTE</front>
<front id="fastioH-2613">#define PE6_PWM			NULL</front>
<front id="fastioH-2614">#define PE6_DDR			DDRE</front>
<front id="fastioH-2615">#undef PE7</front>
<front id="fastioH-2616">#define PE7_PIN			PINE7</front>
<front id="fastioH-2617">#define PE7_RPORT		PINE</front>
<front id="fastioH-2618">#define PE7_WPORT		PORTE</front>
<front id="fastioH-2619">#define PE7_PWM			NULL</front>
<front id="fastioH-2620">#define PE7_DDR			DDRE</front>
<front id="fastioH-2621"></front>
<front id="fastioH-2622">#undef PF0</front>
<front id="fastioH-2623">#define PF0_PIN			PINF0</front>
<front id="fastioH-2624">#define PF0_RPORT		PINF</front>
<front id="fastioH-2625">#define PF0_WPORT		PORTF</front>
<front id="fastioH-2626">#define PF0_PWM			NULL</front>
<front id="fastioH-2627">#define PF0_DDR			DDRF</front>
<front id="fastioH-2628">#undef PF1</front>
<front id="fastioH-2629">#define PF1_PIN			PINF1</front>
<front id="fastioH-2630">#define PF1_RPORT		PINF</front>
<front id="fastioH-2631">#define PF1_WPORT		PORTF</front>
<front id="fastioH-2632">#define PF1_PWM			NULL</front>
<front id="fastioH-2633">#define PF1_DDR			DDRF</front>
<front id="fastioH-2634">#undef PF2</front>
<front id="fastioH-2635">#define PF2_PIN			PINF2</front>
<front id="fastioH-2636">#define PF2_RPORT		PINF</front>
<front id="fastioH-2637">#define PF2_WPORT		PORTF</front>
<front id="fastioH-2638">#define PF2_PWM			NULL</front>
<front id="fastioH-2639">#define PF2_DDR			DDRF</front>
<front id="fastioH-2640">#undef PF3</front>
<front id="fastioH-2641">#define PF3_PIN			PINF3</front>
<front id="fastioH-2642">#define PF3_RPORT		PINF</front>
<front id="fastioH-2643">#define PF3_WPORT		PORTF</front>
<front id="fastioH-2644">#define PF3_PWM			NULL</front>
<front id="fastioH-2645">#define PF3_DDR			DDRF</front>
<front id="fastioH-2646">#undef PF4</front>
<front id="fastioH-2647">#define PF4_PIN			PINF4</front>
<front id="fastioH-2648">#define PF4_RPORT		PINF</front>
<front id="fastioH-2649">#define PF4_WPORT		PORTF</front>
<front id="fastioH-2650">#define PF4_PWM			NULL</front>
<front id="fastioH-2651">#define PF4_DDR			DDRF</front>
<front id="fastioH-2652">#undef PF5</front>
<front id="fastioH-2653">#define PF5_PIN			PINF5</front>
<front id="fastioH-2654">#define PF5_RPORT		PINF</front>
<front id="fastioH-2655">#define PF5_WPORT		PORTF</front>
<front id="fastioH-2656">#define PF5_PWM			NULL</front>
<front id="fastioH-2657">#define PF5_DDR			DDRF</front>
<front id="fastioH-2658">#undef PF6</front>
<front id="fastioH-2659">#define PF6_PIN			PINF6</front>
<front id="fastioH-2660">#define PF6_RPORT		PINF</front>
<front id="fastioH-2661">#define PF6_WPORT		PORTF</front>
<front id="fastioH-2662">#define PF6_PWM			NULL</front>
<front id="fastioH-2663">#define PF6_DDR			DDRF</front>
<front id="fastioH-2664">#undef PF7</front>
<front id="fastioH-2665">#define PF7_PIN			PINF7</front>
<front id="fastioH-2666">#define PF7_RPORT		PINF</front>
<front id="fastioH-2667">#define PF7_WPORT		PORTF</front>
<front id="fastioH-2668">#define PF7_PWM			NULL</front>
<front id="fastioH-2669">#define PF7_DDR			DDRF</front>
<front id="fastioH-2670">#endif</front>
<front id="fastioH-2671"></front>
<front id="fastioH-2672"></front>
<front id="fastioH-2673">#if defined (__AVR_ATmega1281__) || defined (__AVR_ATmega2561__)</front>
<front id="fastioH-2674">// UART</front>
<front id="fastioH-2675">#define	RXD					DIO0</front>
<front id="fastioH-2676">#define	TXD					DIO1</front>
<front id="fastioH-2677"></front>
<front id="fastioH-2678">// SPI</front>
<front id="fastioH-2679">#define	SCK					DIO10</front>
<front id="fastioH-2680">#define	MISO				DIO12</front>
<front id="fastioH-2681">#define	MOSI				DIO11</front>
<front id="fastioH-2682">#define	SS					DIO16</front>
<front id="fastioH-2683"></front>
<front id="fastioH-2684">// TWI (I2C)</front>
<front id="fastioH-2685">#define	SCL					DIO17</front>
<front id="fastioH-2686">#define	SDA					DIO18</front>
<front id="fastioH-2687"></front>
<front id="fastioH-2688">// timers and PWM</front>
<front id="fastioH-2689">#define	OC0A				DIO9</front>
<front id="fastioH-2690">#define	OC0B				DIO4</front>
<front id="fastioH-2691">#define	OC1A				DIO7</front>
<front id="fastioH-2692">#define	OC1B				DIO8</front>
<front id="fastioH-2693">#define	OC2A				DIO6</front>
<front id="fastioH-2694">#define	OC3A				DIO5</front>
<front id="fastioH-2695">#define	OC3B				DIO2</front>
<front id="fastioH-2696">#define	OC3C				DIO3</front>
<front id="fastioH-2697"></front>
<front id="fastioH-2698"></front>
<front id="fastioH-2699">// change for your board</front>
<front id="fastioH-2700">#define	DEBUG_LED		DIO46</front>
<front id="fastioH-2701"></front>
<front id="fastioH-2702">/*</front>
<front id="fastioH-2703">pins</front>
<front id="fastioH-2704">*/</front>
<front id="fastioH-2705">#define	DIO0_PIN		PINE0</front>
<front id="fastioH-2706">#define	DIO0_RPORT	PINE</front>
<front id="fastioH-2707">#define	DIO0_WPORT	PORTE</front>
<front id="fastioH-2708">#define	DIO0_DDR		DDRE</front>
<front id="fastioH-2709">#define DIO0_PWM		NULL</front>
<front id="fastioH-2710"></front>
<front id="fastioH-2711">#define	DIO1_PIN		PINE1</front>
<front id="fastioH-2712">#define	DIO1_RPORT	PINE</front>
<front id="fastioH-2713">#define	DIO1_WPORT	PORTE</front>
<front id="fastioH-2714">#define	DIO1_DDR		DDRE</front>
<front id="fastioH-2715">#define DIO1_PWM		NULL</front>
<front id="fastioH-2716"></front>
<front id="fastioH-2717">#define	DIO2_PIN		PINE4</front>
<front id="fastioH-2718">#define	DIO2_RPORT	PINE</front>
<front id="fastioH-2719">#define	DIO2_WPORT	PORTE</front>
<front id="fastioH-2720">#define	DIO2_DDR		DDRE</front>
<front id="fastioH-2721">#define DIO2_PWM		&OCR3BL</front>
<front id="fastioH-2722"></front>
<front id="fastioH-2723">#define	DIO3_PIN		PINE5</front>
<front id="fastioH-2724">#define	DIO3_RPORT	PINE</front>
<front id="fastioH-2725">#define	DIO3_WPORT	PORTE</front>
<front id="fastioH-2726">#define	DIO3_DDR		DDRE</front>
<front id="fastioH-2727">#define DIO3_PWM		&OCR3CL</front>
<front id="fastioH-2728"></front>
<front id="fastioH-2729">#define	DIO4_PIN		PING5</front>
<front id="fastioH-2730">#define	DIO4_RPORT	PING</front>
<front id="fastioH-2731">#define	DIO4_WPORT	PORTG</front>
<front id="fastioH-2732">#define	DIO4_DDR		DDRG</front>
<front id="fastioH-2733">#define DIO4_PWM		&OCR0B</front>
<front id="fastioH-2734"></front>
<front id="fastioH-2735">#define	DIO5_PIN		PINE3</front>
<front id="fastioH-2736">#define	DIO5_RPORT	PINE</front>
<front id="fastioH-2737">#define	DIO5_WPORT	PORTE</front>
<front id="fastioH-2738">#define	DIO5_DDR		DDRE</front>
<front id="fastioH-2739">#define DIO5_PWM		&OCR3AL</front>
<front id="fastioH-2740"></front>
<front id="fastioH-2741">#define	DIO6_PIN		PINB4</front>
<front id="fastioH-2742">#define	DIO6_RPORT	PINB</front>
<front id="fastioH-2743">#define	DIO6_WPORT	PORTB</front>
<front id="fastioH-2744">#define	DIO6_DDR		DDRB</front>
<front id="fastioH-2745">#define DIO6_PWM		&OCR2AL</front>
<front id="fastioH-2746"></front>
<front id="fastioH-2747">#define	DIO7_PIN		PINB5</front>
<front id="fastioH-2748">#define	DIO7_RPORT	PINB</front>
<front id="fastioH-2749">#define	DIO7_WPORT	PORTB</front>
<front id="fastioH-2750">#define	DIO7_DDR		DDRB</front>
<front id="fastioH-2751">#define DIO7_PWM		&OCR1AL</front>
<front id="fastioH-2752"></front>
<front id="fastioH-2753">#define	DIO8_PIN		PINB6</front>
<front id="fastioH-2754">#define	DIO8_RPORT	PINB</front>
<front id="fastioH-2755">#define	DIO8_WPORT	PORTB</front>
<front id="fastioH-2756">#define	DIO8_DDR		DDRB</front>
<front id="fastioH-2757">#define DIO8_PWM		&OCR1BL</front>
<front id="fastioH-2758"></front>
<front id="fastioH-2759">#define	DIO9_PIN		PINB7</front>
<front id="fastioH-2760">#define	DIO9_RPORT	PINB</front>
<front id="fastioH-2761">#define	DIO9_WPORT	PORTB</front>
<front id="fastioH-2762">#define	DIO9_DDR		DDRB</front>
<front id="fastioH-2763">#define DIO9_PWM		&OCR0AL</front>
<front id="fastioH-2764"></front>
<front id="fastioH-2765">#define	DIO10_PIN		PINB1</front>
<front id="fastioH-2766">#define	DIO10_RPORT	PINB</front>
<front id="fastioH-2767">#define	DIO10_WPORT	PORTB</front>
<front id="fastioH-2768">#define	DIO10_DDR		DDRB</front>
<front id="fastioH-2769">#define DIO10_PWM		NULL</front>
<front id="fastioH-2770"></front>
<front id="fastioH-2771">#define	DIO11_PIN		PINB2</front>
<front id="fastioH-2772">#define	DIO11_RPORT	PINB</front>
<front id="fastioH-2773">#define	DIO11_WPORT	PORTB</front>
<front id="fastioH-2774">#define	DIO11_DDR		DDRB</front>
<front id="fastioH-2775">#define DIO11_PWM		NULL</front>
<front id="fastioH-2776"></front>
<front id="fastioH-2777">#define	DIO12_PIN		PINB3</front>
<front id="fastioH-2778">#define	DIO12_RPORT	PINB</front>
<front id="fastioH-2779">#define	DIO12_WPORT	PORTB</front>
<front id="fastioH-2780">#define	DIO12_DDR		DDRB</front>
<front id="fastioH-2781">#define DIO12_PWM		NULL</front>
<front id="fastioH-2782"></front>
<front id="fastioH-2783">#define	DIO13_PIN		PINE2</front>
<front id="fastioH-2784">#define	DIO13_RPORT	PINE</front>
<front id="fastioH-2785">#define	DIO13_WPORT	PORTE</front>
<front id="fastioH-2786">#define	DIO13_DDR		DDRE</front>
<front id="fastioH-2787">#define DIO13_PWM		NULL</front>
<front id="fastioH-2788"></front>
<front id="fastioH-2789">#define	DIO14_PIN		PINE6</front>
<front id="fastioH-2790">#define	DIO14_RPORT	PINE</front>
<front id="fastioH-2791">#define	DIO14_WPORT	PORTE</front>
<front id="fastioH-2792">#define	DIO14_DDR		DDRE</front>
<front id="fastioH-2793">#define DIO14_PWM		NULL</front>
<front id="fastioH-2794"></front>
<front id="fastioH-2795">#define	DIO15_PIN		PINE7</front>
<front id="fastioH-2796">#define	DIO15_RPORT	PINE</front>
<front id="fastioH-2797">#define	DIO15_WPORT	PORTE</front>
<front id="fastioH-2798">#define	DIO15_DDR		DDRE</front>
<front id="fastioH-2799">#define DIO15_PWM		NULL</front>
<front id="fastioH-2800"></front>
<front id="fastioH-2801">#define	DIO16_PIN		PINB0</front>
<front id="fastioH-2802">#define	DIO16_RPORT	PINB</front>
<front id="fastioH-2803">#define	DIO16_WPORT	PORTB</front>
<front id="fastioH-2804">#define	DIO16_DDR		DDRB</front>
<front id="fastioH-2805">#define DIO16_PWM		NULL</front>
<front id="fastioH-2806"></front>
<front id="fastioH-2807">#define	DIO17_PIN		PIND0</front>
<front id="fastioH-2808">#define	DIO17_RPORT	PIND</front>
<front id="fastioH-2809">#define	DIO17_WPORT	PORTD</front>
<front id="fastioH-2810">#define	DIO17_DDR		DDRD</front>
<front id="fastioH-2811">#define DIO17_PWM		NULL</front>
<front id="fastioH-2812"></front>
<front id="fastioH-2813">#define	DIO18_PIN		PIND1</front>
<front id="fastioH-2814">#define	DIO18_RPORT	PIND</front>
<front id="fastioH-2815">#define	DIO18_WPORT	PORTD</front>
<front id="fastioH-2816">#define	DIO18_DDR		DDRD</front>
<front id="fastioH-2817">#define DIO18_PWM		NULL</front>
<front id="fastioH-2818"></front>
<front id="fastioH-2819">#define	DIO19_PIN		PIND2</front>
<front id="fastioH-2820">#define	DIO19_RPORT	PIND</front>
<front id="fastioH-2821">#define	DIO19_WPORT	PORTD</front>
<front id="fastioH-2822">#define	DIO19_DDR		DDRD</front>
<front id="fastioH-2823">#define DIO19_PWM		NULL</front>
<front id="fastioH-2824"></front>
<front id="fastioH-2825">#define	DIO20_PIN		PIND3</front>
<front id="fastioH-2826">#define	DIO20_RPORT	PIND</front>
<front id="fastioH-2827">#define	DIO20_WPORT	PORTD</front>
<front id="fastioH-2828">#define	DIO20_DDR		DDRD</front>
<front id="fastioH-2829">#define DIO20_PWM		NULL</front>
<front id="fastioH-2830"></front>
<front id="fastioH-2831">#define	DIO21_PIN		PIND4</front>
<front id="fastioH-2832">#define	DIO21_RPORT	PIND</front>
<front id="fastioH-2833">#define	DIO21_WPORT	PORTD</front>
<front id="fastioH-2834">#define	DIO21_DDR		DDRD</front>
<front id="fastioH-2835">#define DIO21_PWM		NULL</front>
<front id="fastioH-2836"></front>
<front id="fastioH-2837">#define	DIO22_PIN		PIND5</front>
<front id="fastioH-2838">#define	DIO22_RPORT	PIND</front>
<front id="fastioH-2839">#define	DIO22_WPORT	PORTD</front>
<front id="fastioH-2840">#define	DIO22_DDR		DDRD</front>
<front id="fastioH-2841">#define DIO22_PWM		NULL</front>
<front id="fastioH-2842"></front>
<front id="fastioH-2843">#define	DIO23_PIN		PIND6</front>
<front id="fastioH-2844">#define	DIO23_RPORT	PIND</front>
<front id="fastioH-2845">#define	DIO23_WPORT	PORTD</front>
<front id="fastioH-2846">#define	DIO23_DDR		DDRD</front>
<front id="fastioH-2847">#define DIO23_PWM		NULL</front>
<front id="fastioH-2848"></front>
<front id="fastioH-2849">#define	DIO24_PIN		PIND7</front>
<front id="fastioH-2850">#define	DIO24_RPORT	PIND</front>
<front id="fastioH-2851">#define	DIO24_WPORT	PORTD</front>
<front id="fastioH-2852">#define	DIO24_DDR		DDRD</front>
<front id="fastioH-2853">#define DIO24_PWM		NULL</front>
<front id="fastioH-2854"></front>
<front id="fastioH-2855">#define	DIO25_PIN		PING0</front>
<front id="fastioH-2856">#define	DIO25_RPORT	PING</front>
<front id="fastioH-2857">#define	DIO25_WPORT	PORTG</front>
<front id="fastioH-2858">#define	DIO25_DDR		DDRG</front>
<front id="fastioH-2859">#define DIO25_PWM		NULL</front>
<front id="fastioH-2860"></front>
<front id="fastioH-2861">#define	DIO26_PIN		PING1</front>
<front id="fastioH-2862">#define	DIO26_RPORT	PING</front>
<front id="fastioH-2863">#define	DIO26_WPORT	PORTG</front>
<front id="fastioH-2864">#define	DIO26_DDR		DDRG</front>
<front id="fastioH-2865">#define DIO26_PWM		NULL</front>
<front id="fastioH-2866"></front>
<front id="fastioH-2867">#define	DIO27_PIN		PING2</front>
<front id="fastioH-2868">#define	DIO27_RPORT	PING</front>
<front id="fastioH-2869">#define	DIO27_WPORT	PORTG</front>
<front id="fastioH-2870">#define	DIO27_DDR		DDRG</front>
<front id="fastioH-2871">#define DIO27_PWM		NULL</front>
<front id="fastioH-2872"></front>
<front id="fastioH-2873">#define	DIO28_PIN		PING3</front>
<front id="fastioH-2874">#define	DIO28_RPORT	PING</front>
<front id="fastioH-2875">#define	DIO28_WPORT	PORTG</front>
<front id="fastioH-2876">#define	DIO28_DDR		DDRG</front>
<front id="fastioH-2877">#define DIO28_PWM		NULL</front>
<front id="fastioH-2878"></front>
<front id="fastioH-2879">#define	DIO29_PIN		PING4</front>
<front id="fastioH-2880">#define	DIO29_RPORT	PING</front>
<front id="fastioH-2881">#define	DIO29_WPORT	PORTG</front>
<front id="fastioH-2882">#define	DIO29_DDR		DDRG</front>
<front id="fastioH-2883">#define DIO29_PWM		NULL</front>
<front id="fastioH-2884"></front>
<front id="fastioH-2885">#define	DIO30_PIN		PINC0</front>
<front id="fastioH-2886">#define	DIO30_RPORT	PINC</front>
<front id="fastioH-2887">#define	DIO30_WPORT	PORTC</front>
<front id="fastioH-2888">#define	DIO30_DDR		DDRC</front>
<front id="fastioH-2889">#define DIO30_PWM		NULL</front>
<front id="fastioH-2890"></front>
<front id="fastioH-2891">#define	DIO31_PIN		PINC1</front>
<front id="fastioH-2892">#define	DIO31_RPORT	PINC</front>
<front id="fastioH-2893">#define	DIO31_WPORT	PORTC</front>
<front id="fastioH-2894">#define	DIO31_DDR		DDRC</front>
<front id="fastioH-2895">#define DIO31_PWM		NULL</front>
<front id="fastioH-2896"></front>
<front id="fastioH-2897">#define	DIO32_PIN		PINC2</front>
<front id="fastioH-2898">#define	DIO32_RPORT	PINC</front>
<front id="fastioH-2899">#define	DIO32_WPORT	PORTC</front>
<front id="fastioH-2900">#define	DIO32_DDR		DDRC</front>
<front id="fastioH-2901">#define DIO32_PWM		NULL</front>
<front id="fastioH-2902"></front>
<front id="fastioH-2903">#define	DIO33_PIN		PINC3</front>
<front id="fastioH-2904">#define	DIO33_RPORT	PINC</front>
<front id="fastioH-2905">#define	DIO33_WPORT	PORTC</front>
<front id="fastioH-2906">#define	DIO33_DDR		DDRC</front>
<front id="fastioH-2907">#define DIO33_PWM		NULL</front>
<front id="fastioH-2908"></front>
<front id="fastioH-2909">#define	DIO34_PIN		PINC4</front>
<front id="fastioH-2910">#define	DIO34_RPORT	PINC</front>
<front id="fastioH-2911">#define	DIO34_WPORT	PORTC</front>
<front id="fastioH-2912">#define	DIO34_DDR		DDRC</front>
<front id="fastioH-2913">#define DIO34_PWM		NULL</front>
<front id="fastioH-2914"></front>
<front id="fastioH-2915">#define	DIO35_PIN		PINC5</front>
<front id="fastioH-2916">#define	DIO35_RPORT	PINC</front>
<front id="fastioH-2917">#define	DIO35_WPORT	PORTC</front>
<front id="fastioH-2918">#define	DIO35_DDR		DDRC</front>
<front id="fastioH-2919">#define DIO35_PWM		NULL</front>
<front id="fastioH-2920"></front>
<front id="fastioH-2921">#define	DIO36_PIN		PINC6</front>
<front id="fastioH-2922">#define	DIO36_RPORT	PINC</front>
<front id="fastioH-2923">#define	DIO36_WPORT	PORTC</front>
<front id="fastioH-2924">#define	DIO36_DDR		DDRC</front>
<front id="fastioH-2925">#define DIO36_PWM		NULL</front>
<front id="fastioH-2926"></front>
<front id="fastioH-2927">#define	DIO37_PIN		PINC7</front>
<front id="fastioH-2928">#define	DIO37_RPORT	PINC</front>
<front id="fastioH-2929">#define	DIO37_WPORT	PORTC</front>
<front id="fastioH-2930">#define	DIO37_DDR		DDRC</front>
<front id="fastioH-2931">#define DIO37_PWM		NULL</front>
<front id="fastioH-2932"></front>
<front id="fastioH-2933">#define	DIO38_PIN		PINA0</front>
<front id="fastioH-2934">#define	DIO38_RPORT	PINA</front>
<front id="fastioH-2935">#define	DIO38_WPORT	PORTA</front>
<front id="fastioH-2936">#define	DIO38_DDR		DDRA</front>
<front id="fastioH-2937">#define DIO38_PWM		NULL</front>
<front id="fastioH-2938"></front>
<front id="fastioH-2939">#define	DIO39_PIN		PINA1</front>
<front id="fastioH-2940">#define	DIO39_RPORT	PINA</front>
<front id="fastioH-2941">#define	DIO39_WPORT	PORTA</front>
<front id="fastioH-2942">#define	DIO39_DDR		DDRA</front>
<front id="fastioH-2943">#define DIO39_PWM		NULL</front>
<front id="fastioH-2944"></front>
<front id="fastioH-2945">#define	DIO40_PIN		PINA2</front>
<front id="fastioH-2946">#define	DIO40_RPORT	PINA</front>
<front id="fastioH-2947">#define	DIO40_WPORT	PORTA</front>
<front id="fastioH-2948">#define	DIO40_DDR		DDRA</front>
<front id="fastioH-2949">#define DIO40_PWM		NULL</front>
<front id="fastioH-2950"></front>
<front id="fastioH-2951">#define	DIO41_PIN		PINA3</front>
<front id="fastioH-2952">#define	DIO41_RPORT	PINA</front>
<front id="fastioH-2953">#define	DIO41_WPORT	PORTA</front>
<front id="fastioH-2954">#define	DIO41_DDR		DDRA</front>
<front id="fastioH-2955">#define DIO41_PWM		NULL</front>
<front id="fastioH-2956"></front>
<front id="fastioH-2957">#define	DIO42_PIN		PINA4</front>
<front id="fastioH-2958">#define	DIO42_RPORT	PINA</front>
<front id="fastioH-2959">#define	DIO42_WPORT	PORTA</front>
<front id="fastioH-2960">#define	DIO42_DDR		DDRA</front>
<front id="fastioH-2961">#define DIO42_PWM		NULL</front>
<front id="fastioH-2962"></front>
<front id="fastioH-2963">#define	DIO43_PIN		PINA5</front>
<front id="fastioH-2964">#define	DIO43_RPORT	PINA</front>
<front id="fastioH-2965">#define	DIO43_WPORT	PORTA</front>
<front id="fastioH-2966">#define	DIO43_DDR		DDRA</front>
<front id="fastioH-2967">#define DIO43_PWM		NULL</front>
<front id="fastioH-2968"></front>
<front id="fastioH-2969">#define	DIO44_PIN		PINA6</front>
<front id="fastioH-2970">#define	DIO44_RPORT	PINA</front>
<front id="fastioH-2971">#define	DIO44_WPORT	PORTA</front>
<front id="fastioH-2972">#define	DIO44_DDR		DDRA</front>
<front id="fastioH-2973">#define DIO44_PWM		NULL</front>
<front id="fastioH-2974"></front>
<front id="fastioH-2975">#define	DIO45_PIN		PINA7</front>
<front id="fastioH-2976">#define	DIO45_RPORT	PINA</front>
<front id="fastioH-2977">#define	DIO45_WPORT	PORTA</front>
<front id="fastioH-2978">#define	DIO45_DDR		DDRA</front>
<front id="fastioH-2979">#define DIO45_PWM		NULL</front>
<front id="fastioH-2980"></front>
<front id="fastioH-2981">#define	DIO46_PIN		PINF0</front>
<front id="fastioH-2982">#define	DIO46_RPORT	PINF</front>
<front id="fastioH-2983">#define	DIO46_WPORT	PORTF</front>
<front id="fastioH-2984">#define	DIO46_DDR		DDRF</front>
<front id="fastioH-2985">#define DIO46_PWM		NULL</front>
<front id="fastioH-2986"></front>
<front id="fastioH-2987">#define	DIO47_PIN		PINF1</front>
<front id="fastioH-2988">#define	DIO47_RPORT	PINF</front>
<front id="fastioH-2989">#define	DIO47_WPORT	PORTF</front>
<front id="fastioH-2990">#define	DIO47_DDR		DDRF</front>
<front id="fastioH-2991">#define DIO47_PWM		NULL</front>
<front id="fastioH-2992"></front>
<front id="fastioH-2993">#define	DIO48_PIN		PINF2</front>
<front id="fastioH-2994">#define	DIO48_RPORT	PINF</front>
<front id="fastioH-2995">#define	DIO48_WPORT	PORTF</front>
<front id="fastioH-2996">#define	DIO48_DDR		DDRF</front>
<front id="fastioH-2997">#define DIO48_PWM		NULL</front>
<front id="fastioH-2998"></front>
<front id="fastioH-2999">#define	DIO49_PIN		PINF3</front>
<front id="fastioH-3000">#define	DIO49_RPORT	PINF</front>
<front id="fastioH-3001">#define	DIO49_WPORT	PORTF</front>
<front id="fastioH-3002">#define	DIO49_DDR		DDRF</front>
<front id="fastioH-3003">#define DIO49_PWM		NULL</front>
<front id="fastioH-3004"></front>
<front id="fastioH-3005">#define	DIO50_PIN		PINF4</front>
<front id="fastioH-3006">#define	DIO50_RPORT	PINF</front>
<front id="fastioH-3007">#define	DIO50_WPORT	PORTF</front>
<front id="fastioH-3008">#define	DIO50_DDR		DDRF</front>
<front id="fastioH-3009">#define DIO50_PWM		NULL</front>
<front id="fastioH-3010"></front>
<front id="fastioH-3011">#define	DIO51_PIN		PINF5</front>
<front id="fastioH-3012">#define	DIO51_RPORT	PINF</front>
<front id="fastioH-3013">#define	DIO51_WPORT	PORTF</front>
<front id="fastioH-3014">#define	DIO51_DDR		DDRF</front>
<front id="fastioH-3015">#define DIO51_PWM		NULL</front>
<front id="fastioH-3016"></front>
<front id="fastioH-3017">#define	DIO52_PIN		PINF6</front>
<front id="fastioH-3018">#define	DIO52_RPORT	PINF</front>
<front id="fastioH-3019">#define	DIO52_WPORT	PORTF</front>
<front id="fastioH-3020">#define	DIO52_DDR		DDRF</front>
<front id="fastioH-3021">#define DIO52_PWM		NULL</front>
<front id="fastioH-3022"></front>
<front id="fastioH-3023">#define	DIO53_PIN		PINF7</front>
<front id="fastioH-3024">#define	DIO53_RPORT	PINF</front>
<front id="fastioH-3025">#define	DIO53_WPORT	PORTF</front>
<front id="fastioH-3026">#define	DIO53_DDR		DDRF</front>
<front id="fastioH-3027">#define DIO53_PWM		NULL</front>
<front id="fastioH-3028"></front>
<front id="fastioH-3029"></front>
<front id="fastioH-3030"></front>
<front id="fastioH-3031"></front>
<front id="fastioH-3032">#undef PA0</front>
<front id="fastioH-3033">#define PA0_PIN			PINA0</front>
<front id="fastioH-3034">#define PA0_RPORT		PINA</front>
<front id="fastioH-3035">#define PA0_WPORT		PORTA</front>
<front id="fastioH-3036">#define PA0_DDR			DDRA</front>
<front id="fastioH-3037">#define PA0_PWM			NULL</front>
<front id="fastioH-3038">#undef PA1</front>
<front id="fastioH-3039">#define PA1_PIN			PINA1</front>
<front id="fastioH-3040">#define PA1_RPORT		PINA</front>
<front id="fastioH-3041">#define PA1_WPORT		PORTA</front>
<front id="fastioH-3042">#define PA1_DDR			DDRA</front>
<front id="fastioH-3043">#define PA1_PWM			NULL</front>
<front id="fastioH-3044">#undef PA2</front>
<front id="fastioH-3045">#define PA2_PIN			PINA2</front>
<front id="fastioH-3046">#define PA2_RPORT		PINA</front>
<front id="fastioH-3047">#define PA2_WPORT		PORTA</front>
<front id="fastioH-3048">#define PA2_DDR			DDRA</front>
<front id="fastioH-3049">#define PA2_PWM			NULL</front>
<front id="fastioH-3050">#undef PA3</front>
<front id="fastioH-3051">#define PA3_PIN			PINA3</front>
<front id="fastioH-3052">#define PA3_RPORT		PINA</front>
<front id="fastioH-3053">#define PA3_WPORT		PORTA</front>
<front id="fastioH-3054">#define PA3_DDR			DDRA</front>
<front id="fastioH-3055">#define PA3_PWM			NULL</front>
<front id="fastioH-3056">#undef PA4</front>
<front id="fastioH-3057">#define PA4_PIN			PINA4</front>
<front id="fastioH-3058">#define PA4_RPORT		PINA</front>
<front id="fastioH-3059">#define PA4_WPORT		PORTA</front>
<front id="fastioH-3060">#define PA4_DDR			DDRA</front>
<front id="fastioH-3061">#define PA4_PWM			NULL</front>
<front id="fastioH-3062">#undef PA5</front>
<front id="fastioH-3063">#define PA5_PIN			PINA5</front>
<front id="fastioH-3064">#define PA5_RPORT		PINA</front>
<front id="fastioH-3065">#define PA5_WPORT		PORTA</front>
<front id="fastioH-3066">#define PA5_DDR			DDRA</front>
<front id="fastioH-3067">#define PA5_PWM			NULL</front>
<front id="fastioH-3068">#undef PA6</front>
<front id="fastioH-3069">#define PA6_PIN			PINA6</front>
<front id="fastioH-3070">#define PA6_RPORT		PINA</front>
<front id="fastioH-3071">#define PA6_WPORT		PORTA</front>
<front id="fastioH-3072">#define PA6_DDR			DDRA</front>
<front id="fastioH-3073">#define PA6_PWM			NULL</front>
<front id="fastioH-3074">#undef PA7</front>
<front id="fastioH-3075">#define PA7_PIN			PINA7</front>
<front id="fastioH-3076">#define PA7_RPORT		PINA</front>
<front id="fastioH-3077">#define PA7_WPORT		PORTA</front>
<front id="fastioH-3078">#define PA7_DDR			DDRA</front>
<front id="fastioH-3079">#define PA7_PWM			NULL</front>
<front id="fastioH-3080"></front>
<front id="fastioH-3081">#undef PB0</front>
<front id="fastioH-3082">#define PB0_PIN			PINB0</front>
<front id="fastioH-3083">#define PB0_RPORT		PINB</front>
<front id="fastioH-3084">#define PB0_WPORT		PORTB</front>
<front id="fastioH-3085">#define PB0_DDR			DDRB</front>
<front id="fastioH-3086">#define PB0_PWM			NULL</front>
<front id="fastioH-3087">#undef PB1</front>
<front id="fastioH-3088">#define PB1_PIN			PINB1</front>
<front id="fastioH-3089">#define PB1_RPORT		PINB</front>
<front id="fastioH-3090">#define PB1_WPORT		PORTB</front>
<front id="fastioH-3091">#define PB1_DDR			DDRB</front>
<front id="fastioH-3092">#define PB1_PWM			NULL</front>
<front id="fastioH-3093">#undef PB2</front>
<front id="fastioH-3094">#define PB2_PIN			PINB2</front>
<front id="fastioH-3095">#define PB2_RPORT		PINB</front>
<front id="fastioH-3096">#define PB2_WPORT		PORTB</front>
<front id="fastioH-3097">#define PB2_DDR			DDRB</front>
<front id="fastioH-3098">#define PB2_PWM			NULL</front>
<front id="fastioH-3099">#undef PB3</front>
<front id="fastioH-3100">#define PB3_PIN			PINB3</front>
<front id="fastioH-3101">#define PB3_RPORT		PINB</front>
<front id="fastioH-3102">#define PB3_WPORT		PORTB</front>
<front id="fastioH-3103">#define PB3_DDR			DDRB</front>
<front id="fastioH-3104">#define PB3_PWM			NULL</front>
<front id="fastioH-3105">#undef PB4</front>
<front id="fastioH-3106">#define PB4_PIN			PINB4</front>
<front id="fastioH-3107">#define PB4_RPORT		PINB</front>
<front id="fastioH-3108">#define PB4_WPORT		PORTB</front>
<front id="fastioH-3109">#define PB4_DDR			DDRB</front>
<front id="fastioH-3110">#define PB4_PWM			&OCR2A</front>
<front id="fastioH-3111">#undef PB5</front>
<front id="fastioH-3112">#define PB5_PIN			PINB5</front>
<front id="fastioH-3113">#define PB5_RPORT		PINB</front>
<front id="fastioH-3114">#define PB5_WPORT		PORTB</front>
<front id="fastioH-3115">#define PB5_DDR			DDRB</front>
<front id="fastioH-3116">#define PB5_PWM			NULL</front>
<front id="fastioH-3117">#undef PB6</front>
<front id="fastioH-3118">#define PB6_PIN			PINB6</front>
<front id="fastioH-3119">#define PB6_RPORT		PINB</front>
<front id="fastioH-3120">#define PB6_WPORT		PORTB</front>
<front id="fastioH-3121">#define PB6_DDR			DDRB</front>
<front id="fastioH-3122">#define PB6_PWM			NULL</front>
<front id="fastioH-3123">#undef PB7</front>
<front id="fastioH-3124">#define PB7_PIN			PINB7</front>
<front id="fastioH-3125">#define PB7_RPORT		PINB</front>
<front id="fastioH-3126">#define PB7_WPORT		PORTB</front>
<front id="fastioH-3127">#define PB7_DDR			DDRB</front>
<front id="fastioH-3128">#define PB7_PWM			&OCR0A</front>
<front id="fastioH-3129"></front>
<front id="fastioH-3130">#undef PC0</front>
<front id="fastioH-3131">#define PC0_PIN			PINC0</front>
<front id="fastioH-3132">#define PC0_RPORT		PINC</front>
<front id="fastioH-3133">#define PC0_WPORT		PORTC</front>
<front id="fastioH-3134">#define PC0_DDR			DDRC</front>
<front id="fastioH-3135">#define PC0_PWM			NULL</front>
<front id="fastioH-3136">#undef PC1</front>
<front id="fastioH-3137">#define PC1_PIN			PINC1</front>
<front id="fastioH-3138">#define PC1_RPORT		PINC</front>
<front id="fastioH-3139">#define PC1_WPORT		PORTC</front>
<front id="fastioH-3140">#define PC1_DDR			DDRC</front>
<front id="fastioH-3141">#define PC1_PWM			NULL</front>
<front id="fastioH-3142">#undef PC2</front>
<front id="fastioH-3143">#define PC2_PIN			PINC2</front>
<front id="fastioH-3144">#define PC2_RPORT		PINC</front>
<front id="fastioH-3145">#define PC2_WPORT		PORTC</front>
<front id="fastioH-3146">#define PC2_DDR			DDRC</front>
<front id="fastioH-3147">#define PC2_PWM			NULL</front>
<front id="fastioH-3148">#undef PC3</front>
<front id="fastioH-3149">#define PC3_PIN			PINC3</front>
<front id="fastioH-3150">#define PC3_RPORT		PINC</front>
<front id="fastioH-3151">#define PC3_WPORT		PORTC</front>
<front id="fastioH-3152">#define PC3_DDR			DDRC</front>
<front id="fastioH-3153">#define PC3_PWM			NULL</front>
<front id="fastioH-3154">#undef PC4</front>
<front id="fastioH-3155">#define PC4_PIN			PINC4</front>
<front id="fastioH-3156">#define PC4_RPORT		PINC</front>
<front id="fastioH-3157">#define PC4_WPORT		PORTC</front>
<front id="fastioH-3158">#define PC4_DDR			DDRC</front>
<front id="fastioH-3159">#define PC4_PWM			NULL</front>
<front id="fastioH-3160">#undef PC5</front>
<front id="fastioH-3161">#define PC5_PIN			PINC5</front>
<front id="fastioH-3162">#define PC5_RPORT		PINC</front>
<front id="fastioH-3163">#define PC5_WPORT		PORTC</front>
<front id="fastioH-3164">#define PC5_DDR			DDRC</front>
<front id="fastioH-3165">#define PC5_PWM			NULL</front>
<front id="fastioH-3166">#undef PC6</front>
<front id="fastioH-3167">#define PC6_PIN			PINC6</front>
<front id="fastioH-3168">#define PC6_RPORT		PINC</front>
<front id="fastioH-3169">#define PC6_WPORT		PORTC</front>
<front id="fastioH-3170">#define PC6_DDR			DDRC</front>
<front id="fastioH-3171">#define PC6_PWM			NULL</front>
<front id="fastioH-3172">#undef PC7</front>
<front id="fastioH-3173">#define PC7_PIN			PINC7</front>
<front id="fastioH-3174">#define PC7_RPORT		PINC</front>
<front id="fastioH-3175">#define PC7_WPORT		PORTC</front>
<front id="fastioH-3176">#define PC7_DDR			DDRC</front>
<front id="fastioH-3177">#define PC7_PWM			NULL</front>
<front id="fastioH-3178"></front>
<front id="fastioH-3179">#undef PD0</front>
<front id="fastioH-3180">#define PD0_PIN			PIND0</front>
<front id="fastioH-3181">#define PD0_RPORT		PIND</front>
<front id="fastioH-3182">#define PD0_WPORT		PORTD</front>
<front id="fastioH-3183">#define PD0_DDR			DDRD</front>
<front id="fastioH-3184">#define PD0_PWM			NULL</front>
<front id="fastioH-3185">#undef PD1</front>
<front id="fastioH-3186">#define PD1_PIN			PIND1</front>
<front id="fastioH-3187">#define PD1_RPORT		PIND</front>
<front id="fastioH-3188">#define PD1_WPORT		PORTD</front>
<front id="fastioH-3189">#define PD1_DDR			DDRD</front>
<front id="fastioH-3190">#define PD1_PWM			NULL</front>
<front id="fastioH-3191">#undef PD2</front>
<front id="fastioH-3192">#define PD2_PIN			PIND2</front>
<front id="fastioH-3193">#define PD2_RPORT		PIND</front>
<front id="fastioH-3194">#define PD2_WPORT		PORTD</front>
<front id="fastioH-3195">#define PD2_DDR			DDRD</front>
<front id="fastioH-3196">#define PD2_PWM			NULL</front>
<front id="fastioH-3197">#undef PD3</front>
<front id="fastioH-3198">#define PD3_PIN			PIND3</front>
<front id="fastioH-3199">#define PD3_RPORT		PIND</front>
<front id="fastioH-3200">#define PD3_WPORT		PORTD</front>
<front id="fastioH-3201">#define PD3_DDR			DDRD</front>
<front id="fastioH-3202">#define PD3_PWM			NULL</front>
<front id="fastioH-3203">#undef PD4</front>
<front id="fastioH-3204">#define PD4_PIN			PIND4</front>
<front id="fastioH-3205">#define PD4_RPORT		PIND</front>
<front id="fastioH-3206">#define PD4_WPORT		PORTD</front>
<front id="fastioH-3207">#define PD4_DDR			DDRD</front>
<front id="fastioH-3208">#define PD4_PWM			NULL</front>
<front id="fastioH-3209">#undef PD5</front>
<front id="fastioH-3210">#define PD5_PIN			PIND5</front>
<front id="fastioH-3211">#define PD5_RPORT		PIND</front>
<front id="fastioH-3212">#define PD5_WPORT		PORTD</front>
<front id="fastioH-3213">#define PD5_DDR			DDRD</front>
<front id="fastioH-3214">#define PD5_PWM			NULL</front>
<front id="fastioH-3215">#undef PD6</front>
<front id="fastioH-3216">#define PD6_PIN			PIND6</front>
<front id="fastioH-3217">#define PD6_RPORT		PIND</front>
<front id="fastioH-3218">#define PD6_WPORT		PORTD</front>
<front id="fastioH-3219">#define PD6_DDR			DDRD</front>
<front id="fastioH-3220">#define PD6_PWM			NULL</front>
<front id="fastioH-3221">#undef PD7</front>
<front id="fastioH-3222">#define PD7_PIN			PIND7</front>
<front id="fastioH-3223">#define PD7_RPORT		PIND</front>
<front id="fastioH-3224">#define PD7_WPORT		PORTD</front>
<front id="fastioH-3225">#define PD7_DDR			DDRD</front>
<front id="fastioH-3226">#define PD7_PWM			NULL</front>
<front id="fastioH-3227"></front>
<front id="fastioH-3228">#undef PE0</front>
<front id="fastioH-3229">#define PE0_PIN			PINE0</front>
<front id="fastioH-3230">#define PE0_RPORT		PINE</front>
<front id="fastioH-3231">#define PE0_WPORT		PORTE</front>
<front id="fastioH-3232">#define PE0_DDR			DDRE</front>
<front id="fastioH-3233">#define PE0_PWM			NULL</front>
<front id="fastioH-3234">#undef PE1</front>
<front id="fastioH-3235">#define PE1_PIN			PINE1</front>
<front id="fastioH-3236">#define PE1_RPORT		PINE</front>
<front id="fastioH-3237">#define PE1_WPORT		PORTE</front>
<front id="fastioH-3238">#define PE1_DDR			DDRE</front>
<front id="fastioH-3239">#define PE1_PWM			NULL</front>
<front id="fastioH-3240">#undef PE2</front>
<front id="fastioH-3241">#define PE2_PIN			PINE2</front>
<front id="fastioH-3242">#define PE2_RPORT		PINE</front>
<front id="fastioH-3243">#define PE2_WPORT		PORTE</front>
<front id="fastioH-3244">#define PE2_DDR			DDRE</front>
<front id="fastioH-3245">#define PE2_PWM			NULL</front>
<front id="fastioH-3246">#undef PE3</front>
<front id="fastioH-3247">#define PE3_PIN			PINE3</front>
<front id="fastioH-3248">#define PE3_RPORT		PINE</front>
<front id="fastioH-3249">#define PE3_WPORT		PORTE</front>
<front id="fastioH-3250">#define PE3_DDR			DDRE</front>
<front id="fastioH-3251">#define PE3_PWM			&OCR3AL</front>
<front id="fastioH-3252">#undef PE4</front>
<front id="fastioH-3253">#define PE4_PIN			PINE4</front>
<front id="fastioH-3254">#define PE4_RPORT		PINE</front>
<front id="fastioH-3255">#define PE4_WPORT		PORTE</front>
<front id="fastioH-3256">#define PE4_DDR			DDRE</front>
<front id="fastioH-3257">#define PE4_PWM			&OCR3BL</front>
<front id="fastioH-3258">#undef PE5</front>
<front id="fastioH-3259">#define PE5_PIN			PINE5</front>
<front id="fastioH-3260">#define PE5_RPORT		PINE</front>
<front id="fastioH-3261">#define PE5_WPORT		PORTE</front>
<front id="fastioH-3262">#define PE5_DDR			DDRE</front>
<front id="fastioH-3263">#define PE5_PWM			&OCR3CL</front>
<front id="fastioH-3264">#undef PE6</front>
<front id="fastioH-3265">#define PE6_PIN			PINE6</front>
<front id="fastioH-3266">#define PE6_RPORT		PINE</front>
<front id="fastioH-3267">#define PE6_WPORT		PORTE</front>
<front id="fastioH-3268">#define PE6_DDR			DDRE</front>
<front id="fastioH-3269">#define PE6_PWM			NULL</front>
<front id="fastioH-3270">#undef PE7</front>
<front id="fastioH-3271">#define PE7_PIN			PINE7</front>
<front id="fastioH-3272">#define PE7_RPORT		PINE</front>
<front id="fastioH-3273">#define PE7_WPORT		PORTE</front>
<front id="fastioH-3274">#define PE7_DDR			DDRE</front>
<front id="fastioH-3275">#define PE7_PWM			NULL</front>
<front id="fastioH-3276"></front>
<front id="fastioH-3277">#undef PF0</front>
<front id="fastioH-3278">#define PF0_PIN			PINF0</front>
<front id="fastioH-3279">#define PF0_RPORT		PINF</front>
<front id="fastioH-3280">#define PF0_WPORT		PORTF</front>
<front id="fastioH-3281">#define PF0_DDR			DDRF</front>
<front id="fastioH-3282">#define PF0_PWM			NULL</front>
<front id="fastioH-3283">#undef PF1</front>
<front id="fastioH-3284">#define PF1_PIN			PINF1</front>
<front id="fastioH-3285">#define PF1_RPORT		PINF</front>
<front id="fastioH-3286">#define PF1_WPORT		PORTF</front>
<front id="fastioH-3287">#define PF1_DDR			DDRF</front>
<front id="fastioH-3288">#define PF1_PWM			NULL</front>
<front id="fastioH-3289">#undef PF2</front>
<front id="fastioH-3290">#define PF2_PIN			PINF2</front>
<front id="fastioH-3291">#define PF2_RPORT		PINF</front>
<front id="fastioH-3292">#define PF2_WPORT		PORTF</front>
<front id="fastioH-3293">#define PF2_DDR			DDRF</front>
<front id="fastioH-3294">#define PF2_PWM			NULL</front>
<front id="fastioH-3295">#undef PF3</front>
<front id="fastioH-3296">#define PF3_PIN			PINF3</front>
<front id="fastioH-3297">#define PF3_RPORT		PINF</front>
<front id="fastioH-3298">#define PF3_WPORT		PORTF</front>
<front id="fastioH-3299">#define PF3_DDR			DDRF</front>
<front id="fastioH-3300">#define PF3_PWM			NULL</front>
<front id="fastioH-3301">#undef PF4</front>
<front id="fastioH-3302">#define PF4_PIN			PINF4</front>
<front id="fastioH-3303">#define PF4_RPORT		PINF</front>
<front id="fastioH-3304">#define PF4_WPORT		PORTF</front>
<front id="fastioH-3305">#define PF4_DDR			DDRF</front>
<front id="fastioH-3306">#define PF4_PWM			NULL</front>
<front id="fastioH-3307">#undef PF5</front>
<front id="fastioH-3308">#define PF5_PIN			PINF5</front>
<front id="fastioH-3309">#define PF5_RPORT		PINF</front>
<front id="fastioH-3310">#define PF5_WPORT		PORTF</front>
<front id="fastioH-3311">#define PF5_DDR			DDRF</front>
<front id="fastioH-3312">#define PF5_PWM			NULL</front>
<front id="fastioH-3313">#undef PF6</front>
<front id="fastioH-3314">#define PF6_PIN			PINF6</front>
<front id="fastioH-3315">#define PF6_RPORT		PINF</front>
<front id="fastioH-3316">#define PF6_WPORT		PORTF</front>
<front id="fastioH-3317">#define PF6_DDR			DDRF</front>
<front id="fastioH-3318">#define PF6_PWM			NULL</front>
<front id="fastioH-3319">#undef PF7</front>
<front id="fastioH-3320">#define PF7_PIN			PINF7</front>
<front id="fastioH-3321">#define PF7_RPORT		PINF</front>
<front id="fastioH-3322">#define PF7_WPORT		PORTF</front>
<front id="fastioH-3323">#define PF7_DDR			DDRF</front>
<front id="fastioH-3324">#define PF7_PWM			NULL</front>
<front id="fastioH-3325"></front>
<front id="fastioH-3326">#undef PG0</front>
<front id="fastioH-3327">#define PG0_PIN			PING0</front>
<front id="fastioH-3328">#define PG0_RPORT		PING</front>
<front id="fastioH-3329">#define PG0_WPORT		PORTG</front>
<front id="fastioH-3330">#define PG0_DDR			DDRG</front>
<front id="fastioH-3331">#define PG0_PWM			NULL</front>
<front id="fastioH-3332">#undef PG1</front>
<front id="fastioH-3333">#define PG1_PIN			PING1</front>
<front id="fastioH-3334">#define PG1_RPORT		PING</front>
<front id="fastioH-3335">#define PG1_WPORT		PORTG</front>
<front id="fastioH-3336">#define PG1_DDR			DDRG</front>
<front id="fastioH-3337">#define PG1_PWM			NULL</front>
<front id="fastioH-3338">#undef PG2</front>
<front id="fastioH-3339">#define PG2_PIN			PING2</front>
<front id="fastioH-3340">#define PG2_RPORT		PING</front>
<front id="fastioH-3341">#define PG2_WPORT		PORTG</front>
<front id="fastioH-3342">#define PG2_DDR			DDRG</front>
<front id="fastioH-3343">#define PG2_PWM			NULL</front>
<front id="fastioH-3344">#undef PG3</front>
<front id="fastioH-3345">#define PG3_PIN			PING3</front>
<front id="fastioH-3346">#define PG3_RPORT		PING</front>
<front id="fastioH-3347">#define PG3_WPORT		PORTG</front>
<front id="fastioH-3348">#define PG3_DDR			DDRG</front>
<front id="fastioH-3349">#define PG3_PWM			NULL</front>
<front id="fastioH-3350">#undef PG4</front>
<front id="fastioH-3351">#define PG4_PIN			PING4</front>
<front id="fastioH-3352">#define PG4_RPORT		PING</front>
<front id="fastioH-3353">#define PG4_WPORT		PORTG</front>
<front id="fastioH-3354">#define PG4_DDR			DDRG</front>
<front id="fastioH-3355">#define PG4_PWM			NULL</front>
<front id="fastioH-3356">#undef PG5</front>
<front id="fastioH-3357">#define PG5_PIN			PING5</front>
<front id="fastioH-3358">#define PG5_RPORT		PING</front>
<front id="fastioH-3359">#define PG5_WPORT		PORTG</front>
<front id="fastioH-3360">#define PG5_DDR			DDRG</front>
<front id="fastioH-3361">#define PG5_PWM			&OCR0B</front>
<front id="fastioH-3362"></front>
<front id="fastioH-3363"></front>
<front id="fastioH-3364">#endif</front>
<front id="fastioH-3365"></front>
<front id="fastioH-3366">#ifndef	DIO0_PIN</front>
<front id="fastioH-3367">#error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request</front>
<front id="fastioH-3368">#endif</front>
<front id="fastioH-3369"></front>
<front id="fastioH-3370">#endif /* _FASTIO_ARDUINO_H */</front>
 </pre>
<h1>language.h</h1>
<pre  class="prettyprint linenums"><front id="languageH-1">#ifndef LANGUAGE_H</front>
<front id="languageH-2">#define LANGUAGE_H</front>
<front id="languageH-3"></front>
<front id="languageH-4">// NOTE: IF YOU CHANGE THIS FILE / MERGE THIS FILE WITH CHANGES</front>
<front id="languageH-5">//</front>
<front id="languageH-6">//   ==&gt; ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h" </front>
<front id="languageH-7">//   ==&gt; ALSO TRY ALL AVAILABLE "LANGUAGE_CHOICE" OPTIONS</front>
<front id="languageH-8"></front>
<front id="languageH-9">// Languages</front>
<front id="languageH-10">// 1  English</front>
<front id="languageH-11">// 2  Polish</front>
<front id="languageH-12">// 3  French</front>
<front id="languageH-13">// 4  German</front>
<front id="languageH-14">// 5  Spanish</front>
<front id="languageH-15">// 6  Russian</front>
<front id="languageH-16">// 7  Italian</front>
<front id="languageH-17">// 8  Portuguese</front>
<front id="languageH-18">// 9  Finnish</front>
<front id="languageH-19"></front>
<front id="languageH-20">#ifndef LANGUAGE_CHOICE</front>
<front id="languageH-21">#define LANGUAGE_CHOICE 1  // Pick your language from the list above</front>
<front id="languageH-22">#endif</front>
<front id="languageH-23"></front>
<front id="languageH-24">#define PROTOCOL_VERSION "1.0"</front>
<front id="languageH-25"></front>
<front id="languageH-26">#if MOTHERBOARD == 7 || MOTHERBOARD == 71</front>
<front id="languageH-27">	#define MACHINE_NAME "Ultimaker"</front>
<front id="languageH-28">	#define FIRMWARE_URL "http://firmware.ultimaker.com"</front>
<front id="languageH-29">#elif MOTHERBOARD == 80</front>
<front id="languageH-30">	#define MACHINE_NAME "Rumba"</front>
<front id="languageH-31">	#define FIRMWARE_URL "https://github.com/ErikZalm/Marlin/"</front>
<front id="languageH-32">#elif MOTHERBOARD == 77</front>
<front id="languageH-33">	#define MACHINE_NAME "3Drag"</front>
<front id="languageH-34">	#define FIRMWARE_URL "http://3dprint.elettronicain.it/"</front>
<front id="languageH-35">#else</front>
<front id="languageH-36">	#ifdef CUSTOM_MENDEL_NAME</front>
<front id="languageH-37">		#define MACHINE_NAME CUSTOM_MENDEL_NAME</front>
<front id="languageH-38">	#else</front>
<front id="languageH-39">		#define MACHINE_NAME "Mendel"</front>
<front id="languageH-40">	#endif</front>
<front id="languageH-41">	#define FIRMWARE_URL "http://www.mendel-parts.com"</front>
<front id="languageH-42">#endif</front>
<front id="languageH-43"></front>
<front id="languageH-44">#define STRINGIFY_(n) #n</front>
<front id="languageH-45">#define STRINGIFY(n) STRINGIFY_(n)</front>
<front id="languageH-46"></front>
<front id="languageH-47">#if LANGUAGE_CHOICE == 1</front>
<front id="languageH-48"></front>
<front id="languageH-49">// LCD Menu Messages</front>
<front id="languageH-50">	#define WELCOME_MSG MACHINE_NAME " Ready."</front>
<front id="languageH-51">	#define MSG_SD_INSERTED "Card inserted"</front>
<front id="languageH-52">	#define MSG_SD_REMOVED "Card removed"</front>
<front id="languageH-53">	#define MSG_MAIN "Main"</front>
<front id="languageH-54">	#define MSG_AUTOSTART "Autostart"</front>
<front id="languageH-55">	#define MSG_DISABLE_STEPPERS "Disable Steppers"</front>
<front id="languageH-56">	#define MSG_AUTO_HOME "Auto Home"</front>
<front id="languageH-57">	#define MSG_SET_ORIGIN "Set Origin"</front>
<front id="languageH-58">	#define MSG_PREHEAT_PLA "Preheat PLA"</front>
<front id="languageH-59">	#define MSG_PREHEAT_PLA_SETTINGS "Preheat PLA Conf"</front>
<front id="languageH-60">	#define MSG_PREHEAT_ABS "Preheat ABS"</front>
<front id="languageH-61">	#define MSG_PREHEAT_ABS_SETTINGS "Preheat ABS Conf"</front>
<front id="languageH-62">	#define MSG_COOLDOWN "Cooldown"</front>
<front id="languageH-63">	#define MSG_SWITCH_PS_ON "Switch Power On"</front>
<front id="languageH-64">	#define MSG_SWITCH_PS_OFF "Switch Power Off"</front>
<front id="languageH-65">	#define MSG_EXTRUDE "Extrude"</front>
<front id="languageH-66">	#define MSG_RETRACT "Retract"</front>
<front id="languageH-67">	#define MSG_MOVE_AXIS "Move Axis"</front>
<front id="languageH-68">	#define MSG_SPEED "Speed"</front>
<front id="languageH-69">	#define MSG_NOZZLE "Nozzle"</front>
<front id="languageH-70">	#define MSG_NOZZLE1 "Nozzle2"</front>
<front id="languageH-71">	#define MSG_NOZZLE2 "Nozzle3"</front>
<front id="languageH-72">	#define MSG_BED "Bed"</front>
<front id="languageH-73">	#define MSG_FAN_SPEED "Fan speed"</front>
<front id="languageH-74">	#define MSG_FLOW "Flow"</front>
<front id="languageH-75">	#define MSG_CONTROL "Control"</front>
<front id="languageH-76">	#define MSG_MIN " \002 Min"</front>
<front id="languageH-77">	#define MSG_MAX " \002 Max"</front>
<front id="languageH-78">	#define MSG_FACTOR " \002 Fact"</front>
<front id="languageH-79">	#define MSG_AUTOTEMP "Autotemp"</front>
<front id="languageH-80">	#define MSG_ON "On "</front>
<front id="languageH-81">	#define MSG_OFF "Off"</front>
<front id="languageH-82">	#define MSG_PID_P "PID-P"</front>
<front id="languageH-83">	#define MSG_PID_I "PID-I"</front>
<front id="languageH-84">	#define MSG_PID_D "PID-D"</front>
<front id="languageH-85">	#define MSG_PID_C "PID-C"</front>
<front id="languageH-86">	#define MSG_ACC  "Accel"</front>
<front id="languageH-87">	#define MSG_VXY_JERK "Vxy-jerk"</front>
<front id="languageH-88">	#define MSG_VZ_JERK "Vz-jerk"</front>
<front id="languageH-89">	#define MSG_VE_JERK "Ve-jerk"</front>
<front id="languageH-90">	#define MSG_VMAX "Vmax "</front>
<front id="languageH-91">	#define MSG_X "x"</front>
<front id="languageH-92">	#define MSG_Y "y"</front>
<front id="languageH-93">	#define MSG_Z "z"</front>
<front id="languageH-94">	#define MSG_E "e"</front>
<front id="languageH-95">	#define MSG_VMIN "Vmin"</front>
<front id="languageH-96">	#define MSG_VTRAV_MIN "VTrav min"</front>
<front id="languageH-97">	#define MSG_AMAX "Amax "</front>
<front id="languageH-98">	#define MSG_A_RETRACT "A-retract"</front>
<front id="languageH-99">	#define MSG_XSTEPS "Xsteps/mm"</front>
<front id="languageH-100">	#define MSG_YSTEPS "Ysteps/mm"</front>
<front id="languageH-101">	#define MSG_ZSTEPS "Zsteps/mm"</front>
<front id="languageH-102">	#define MSG_ESTEPS "Esteps/mm"</front>
<front id="languageH-103">	#define MSG_RECTRACT "Rectract"</front>
<front id="languageH-104">	#define MSG_TEMPERATURE "Temperature"</front>
<front id="languageH-105">	#define MSG_MOTION "Motion"</front>
<front id="languageH-106">	#define MSG_CONTRAST "LCD contrast"</front>
<front id="languageH-107">	#define MSG_STORE_EPROM "Store memory"</front>
<front id="languageH-108">	#define MSG_LOAD_EPROM "Load memory"</front>
<front id="languageH-109">	#define MSG_RESTORE_FAILSAFE "Restore Failsafe"</front>
<front id="languageH-110">	#define MSG_REFRESH "Refresh"</front>
<front id="languageH-111">	#define MSG_WATCH "Info screen"</front>
<front id="languageH-112">	#define MSG_PREPARE "Prepare"</front>
<front id="languageH-113">	#define MSG_TUNE "Tune"</front>
<front id="languageH-114">	#define MSG_PAUSE_PRINT "Pause Print"</front>
<front id="languageH-115">	#define MSG_RESUME_PRINT "Resume Print"</front>
<front id="languageH-116">	#define MSG_STOP_PRINT "Stop Print"</front>
<front id="languageH-117">	#define MSG_CARD_MENU "Print from SD"</front>
<front id="languageH-118">	#define MSG_NO_CARD "No Card"</front>
<front id="languageH-119">	#define MSG_DWELL "Sleep..."</front>
<front id="languageH-120">	#define MSG_USERWAIT "Wait for user..."</front>
<front id="languageH-121">	#define MSG_RESUMING "Resuming print"</front>
<front id="languageH-122">	#define MSG_NO_MOVE "No move."</front>
<front id="languageH-123">	#define MSG_KILLED "KILLED. "</front>
<front id="languageH-124">	#define MSG_STOPPED "STOPPED. "</front>
<front id="languageH-125">	#define MSG_CONTROL_RETRACT  "Retract mm"</front>
<front id="languageH-126">	#define MSG_CONTROL_RETRACTF "Retract  F"</front>
<front id="languageH-127">	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"</front>
<front id="languageH-128">	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"</front>
<front id="languageH-129">	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"</front>
<front id="languageH-130">	#define MSG_AUTORETRACT "AutoRetr."</front>
<front id="languageH-131">	#define MSG_FILAMENTCHANGE "Change filament"</front>
<front id="languageH-132">	#define MSG_INIT_SDCARD "Init. SD-Card"	</front>
<front id="languageH-133">	#define MSG_CNG_SDCARD "Change SD-Card"</front>
<front id="languageH-134"></front>
<front id="languageH-135">// Serial Console Messages</front>
<front id="languageH-136"></front>
<front id="languageH-137">	#define MSG_Enqueing "enqueing \""</front>
<front id="languageH-138">	#define MSG_POWERUP "PowerUp"</front>
<front id="languageH-139">	#define MSG_EXTERNAL_RESET " External Reset"</front>
<front id="languageH-140">	#define MSG_BROWNOUT_RESET " Brown out Reset"</front>
<front id="languageH-141">	#define MSG_WATCHDOG_RESET " Watchdog Reset"</front>
<front id="languageH-142">	#define MSG_SOFTWARE_RESET " Software Reset"</front>
<front id="languageH-143">	#define MSG_MARLIN "Marlin "</front>
<front id="languageH-144">	#define MSG_AUTHOR " | Author: "</front>
<front id="languageH-145">	#define MSG_CONFIGURATION_VER " Last Updated: "</front>
<front id="languageH-146">	#define MSG_FREE_MEMORY " Free Memory: "</front>
<front id="languageH-147">	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "</front>
<front id="languageH-148">	#define MSG_OK "ok"</front>
<front id="languageH-149">	#define MSG_FILE_SAVED "Done saving file."</front>
<front id="languageH-150">	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line: "</front>
<front id="languageH-151">	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line: "</front>
<front id="languageH-152">	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line: "</front>
<front id="languageH-153">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "</front>
<front id="languageH-154">	#define MSG_FILE_PRINTED "Done printing file"</front>
<front id="languageH-155">	#define MSG_BEGIN_FILE_LIST "Begin file list"</front>
<front id="languageH-156">	#define MSG_END_FILE_LIST "End file list"</front>
<front id="languageH-157">	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "</front>
<front id="languageH-158">	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "</front>
<front id="languageH-159">	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "</front>
<front id="languageH-160">	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temperature"</front>
<front id="languageH-161">	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "</front>
<front id="languageH-162">	#define MSG_HEATING "Heating..."</front>
<front id="languageH-163">	#define MSG_HEATING_COMPLETE "Heating done."</front>
<front id="languageH-164">	#define MSG_BED_HEATING "Bed Heating."</front>
<front id="languageH-165">	#define MSG_BED_DONE "Bed done."</front>
<front id="languageH-166">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-167">	#define MSG_COUNT_X " Count X: "</front>
<front id="languageH-168">	#define MSG_ERR_KILLED "Printer halted. kill() called!"</front>
<front id="languageH-169">	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"</front>
<front id="languageH-170">	#define MSG_RESEND "Resend: "</front>
<front id="languageH-171">	#define MSG_UNKNOWN_COMMAND "Unknown command: \""</front>
<front id="languageH-172">	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "</front>
<front id="languageH-173">	#define MSG_INVALID_EXTRUDER "Invalid extruder"</front>
<front id="languageH-174">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-175">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-176">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-177">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-178">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-179">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-180">	#define MSG_M119_REPORT "Reporting endstop status"</front>
<front id="languageH-181">	#define MSG_ENDSTOP_HIT "TRIGGERED"</front>
<front id="languageH-182">	#define MSG_ENDSTOP_OPEN "open"</front>
<front id="languageH-183">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-184"></front>
<front id="languageH-185">	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"</front>
<front id="languageH-186">	#define MSG_SD_INIT_FAIL "SD init fail"</front>
<front id="languageH-187">	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"</front>
<front id="languageH-188">	#define MSG_SD_OPENROOT_FAIL "openRoot failed"</front>
<front id="languageH-189">	#define MSG_SD_CARD_OK "SD card ok"</front>
<front id="languageH-190">	#define MSG_SD_WORKDIR_FAIL "workDir open failed"</front>
<front id="languageH-191">	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "</front>
<front id="languageH-192">	#define MSG_SD_FILE_OPENED "File opened: "</front>
<front id="languageH-193">	#define MSG_SD_SIZE " Size: "</front>
<front id="languageH-194">	#define MSG_SD_FILE_SELECTED "File selected"</front>
<front id="languageH-195">	#define MSG_SD_WRITE_TO_FILE "Writing to file: "</front>
<front id="languageH-196">	#define MSG_SD_PRINTING_BYTE "SD printing byte "</front>
<front id="languageH-197">	#define MSG_SD_NOT_PRINTING "Not SD printing"</front>
<front id="languageH-198">	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"</front>
<front id="languageH-199">	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir: "</front>
<front id="languageH-200"></front>
<front id="languageH-201">	#define MSG_STEPPER_TOO_HIGH "Steprate too high: "</front>
<front id="languageH-202">	#define MSG_ENDSTOPS_HIT "endstops hit: "</front>
<front id="languageH-203">	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"</front>
<front id="languageH-204">	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"</front>
<front id="languageH-205"></front>
<front id="languageH-206">#endif</front>
<front id="languageH-207"></front>
<front id="languageH-208"></front>
<front id="languageH-209">#if LANGUAGE_CHOICE == 2</front>
<front id="languageH-210"></front>
<front id="languageH-211">// LCD Menu Messages</front>
<front id="languageH-212">	#define WELCOME_MSG MACHINE_NAME " Gotowe."</front>
<front id="languageH-213">	#define MSG_SD_INSERTED "Karta wlozona"</front>
<front id="languageH-214">	#define MSG_SD_REMOVED "Karta usunieta"</front>
<front id="languageH-215">	#define MSG_MAIN "Main"</front>
<front id="languageH-216">	#define MSG_AUTOSTART "Autostart"</front>
<front id="languageH-217">	#define MSG_DISABLE_STEPPERS "Wylacz silniki"</front>
<front id="languageH-218">	#define MSG_AUTO_HOME "Auto. poz. zerowa"</front>
<front id="languageH-219">	#define MSG_SET_ORIGIN "Ustaw punkt zerowy"</front>
<front id="languageH-220">	#define MSG_PREHEAT_PLA "Rozgrzej PLA"</front>
<front id="languageH-221">	#define MSG_PREHEAT_PLA_SETTINGS "Ustawienia roz. PLA"</front>
<front id="languageH-222">	#define MSG_PREHEAT_ABS "Rozgrzej ABS"</front>
<front id="languageH-223">	#define MSG_PREHEAT_ABS_SETTINGS "Ustawienia roz. ABS"</front>
<front id="languageH-224">	#define MSG_COOLDOWN "Chlodzenie"</front>
<front id="languageH-225">	#define MSG_SWITCH_PS_ON "Switch Power On"</front>
<front id="languageH-226">	#define MSG_SWITCH_PS_OFF "Switch Power Off"</front>
<front id="languageH-227">	#define MSG_EXTRUDE "Ekstruzja"</front>
<front id="languageH-228">	#define MSG_RETRACT "Cofanie"</front>
<front id="languageH-229">	#define MSG_MOVE_AXIS "Ruch osi"</front>
<front id="languageH-230">	#define MSG_SPEED "Predkosc"</front>
<front id="languageH-231">	#define MSG_NOZZLE "Dysza"</front>
<front id="languageH-232">	#define MSG_NOZZLE1 "Dysza2"</front>
<front id="languageH-233">	#define MSG_NOZZLE2 "Dysza3"</front>
<front id="languageH-234">	#define MSG_BED "Loze"</front>
<front id="languageH-235">	#define MSG_FAN_SPEED "Obroty wiatraka"</front>
<front id="languageH-236">	#define MSG_FLOW "Przeplyw"</front>
<front id="languageH-237">	#define MSG_CONTROL "Kontrola"</front>
<front id="languageH-238">	#define MSG_MIN " \002 Min"</front>
<front id="languageH-239">	#define MSG_MAX " \002 Max"</front>
<front id="languageH-240">	#define MSG_FACTOR " \002 Mnoznik"</front>
<front id="languageH-241">	#define MSG_AUTOTEMP "Auto. temp."</front>
<front id="languageH-242">	#define MSG_ON "Wl. "</front>
<front id="languageH-243">	#define MSG_OFF "Wyl."</front>
<front id="languageH-244">	#define MSG_PID_P "PID-P"</front>
<front id="languageH-245">	#define MSG_PID_I "PID-I"</front>
<front id="languageH-246">	#define MSG_PID_D "PID-D"</front>
<front id="languageH-247">	#define MSG_PID_C "PID-C"</front>
<front id="languageH-248">	#define MSG_ACC  "Acc"</front>
<front id="languageH-249">	#define MSG_VXY_JERK "Zryw Vxy"</front>
<front id="languageH-250">	#define MSG_VZ_JERK "Zryw Vz"</front>
<front id="languageH-251">	#define MSG_VE_JERK "Zryw Ve"</front>
<front id="languageH-252">	#define MSG_VMAX "Vmax"</front>
<front id="languageH-253">	#define MSG_X "x"</front>
<front id="languageH-254">	#define MSG_Y "y"</front>
<front id="languageH-255">	#define MSG_Z "z"</front>
<front id="languageH-256">	#define MSG_E "e"</front>
<front id="languageH-257">	#define MSG_VMIN "Vmin"</front>
<front id="languageH-258">	#define MSG_VTRAV_MIN "Vskok min"</front>
<front id="languageH-259">	#define MSG_AMAX "Amax"</front>
<front id="languageH-260">	#define MSG_A_RETRACT "A-wycofanie"</front>
<front id="languageH-261">	#define MSG_XSTEPS "krokiX/mm"</front>
<front id="languageH-262">	#define MSG_YSTEPS "krokiY/mm"</front>
<front id="languageH-263">	#define MSG_ZSTEPS "krokiZ/mm"</front>
<front id="languageH-264">	#define MSG_ESTEPS "krokiE/mm"</front>
<front id="languageH-265">	#define MSG_RECTRACT "Wycofanie"</front>
<front id="languageH-266">	#define MSG_TEMPERATURE "Temperatura"</front>
<front id="languageH-267">	#define MSG_MOTION "Ruch"</front>
<front id="languageH-268">	#define MSG_CONTRAST "LCD contrast"</front>
<front id="languageH-269">	#define MSG_STORE_EPROM "Zapisz w pamieci"</front>
<front id="languageH-270">	#define MSG_LOAD_EPROM "Wczytaj z pamieci"</front>
<front id="languageH-271">	#define MSG_RESTORE_FAILSAFE " Ustawienia fabryczne"</front>
<front id="languageH-272">	#define MSG_REFRESH "\004Odswiez"</front>
<front id="languageH-273">	#define MSG_WATCH "Obserwuj"</front>
<front id="languageH-274">	#define MSG_PREPARE "Przygotuj"</front>
<front id="languageH-275">	#define MSG_CONTROL "Kontroluj"</front>
<front id="languageH-276">	#define MSG_TUNE "Strojenie"</front>
<front id="languageH-277">	#define MSG_PAUSE_PRINT "Pauza"</front>
<front id="languageH-278">	#define MSG_RESUME_PRINT "Wznowienie"</front>
<front id="languageH-279">	#define MSG_STOP_PRINT "Stop"</front>
<front id="languageH-280">	#define MSG_CARD_MENU "Menu SDCard"</front>
<front id="languageH-281">	#define MSG_NO_CARD "Brak karty"</front>
<front id="languageH-282">	#define MSG_DWELL "Uspij..."</front>
<front id="languageH-283">	#define MSG_USERWAIT "Czekaj na uzytkownika..."</front>
<front id="languageH-284">	#define MSG_RESUMING "Wznawiam drukowanie"</front>
<front id="languageH-285">	#define MSG_NO_MOVE "Brak ruchu."</front>
<front id="languageH-286">	#define MSG_PART_RELEASE "Czesciowe zwolnienie"</front>
<front id="languageH-287">	#define MSG_KILLED "Ubity. "</front>
<front id="languageH-288">	#define MSG_STOPPED "Zatrzymany. "</front>
<front id="languageH-289">	#define MSG_STEPPER_RELEASED "Zwolniony."</front>
<front id="languageH-290">	#define MSG_CONTROL_RETRACT  "Wycofaj mm"</front>
<front id="languageH-291">	#define MSG_CONTROL_RETRACTF "Wycofaj  F"</front>
<front id="languageH-292">	#define MSG_CONTROL_RETRACT_ZLIFT "Skok Z mm:"</front>
<front id="languageH-293">	#define MSG_CONTROL_RETRACT_RECOVER "Cof. wycof. +mm"</front>
<front id="languageH-294">	#define MSG_CONTROL_RETRACT_RECOVERF "Cof. wycof.  F"</front>
<front id="languageH-295">	#define MSG_AUTORETRACT "Auto. wycofanie"</front>
<front id="languageH-296">	#define MSG_FILAMENTCHANGE "Change filament"</front>
<front id="languageH-297">	#define MSG_INIT_SDCARD "Init. SD-Card"	</front>
<front id="languageH-298">	#define MSG_CNG_SDCARD "Change SD-Card"</front>
<front id="languageH-299"></front>
<front id="languageH-300">// Serial Console Messages</front>
<front id="languageH-301"></front>
<front id="languageH-302">	#define MSG_Enqueing "Kolejkowanie \""</front>
<front id="languageH-303">	#define MSG_POWERUP "Zasilanie wlaczone"</front>
<front id="languageH-304">	#define MSG_EXTERNAL_RESET " Reset (zewnetrzny)"</front>
<front id="languageH-305">	#define MSG_BROWNOUT_RESET " Reset (spadek napiecia)"</front>
<front id="languageH-306">	#define MSG_WATCHDOG_RESET " Reset (watchdog)"</front>
<front id="languageH-307">	#define MSG_SOFTWARE_RESET " Reset (programowy)"</front>
<front id="languageH-308">	#define MSG_MARLIN "Marlin "</front>
<front id="languageH-309">	#define MSG_AUTHOR " | Autor: "</front>
<front id="languageH-310">	#define MSG_CONFIGURATION_VER " Ostatnia aktualizacja: "</front>
<front id="languageH-311">	#define MSG_FREE_MEMORY " Wolna pamiec: "</front>
<front id="languageH-312">	#define MSG_PLANNER_BUFFER_BYTES "  Bufor planisty krokow (w bajtach): "</front>
<front id="languageH-313">	#define MSG_OK "ok"</front>
<front id="languageH-314">	#define MSG_FILE_SAVED "Plik zapisany."</front>
<front id="languageH-315">	#define MSG_ERR_LINE_NO "Numer linijki nie jest ostatnim numerem linijki+1; ostatnia linijka:"</front>
<front id="languageH-316">	#define MSG_ERR_CHECKSUM_MISMATCH "Niezgodna suma kontrolna; ostatnia linijka: "</front>
<front id="languageH-317">	#define MSG_ERR_NO_CHECKSUM "Brak sumy kontrolnej w linijce; ostatnia linijka:"</front>
<front id="languageH-318">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Brak numery linijki przy sumie kontrolnej; ostatnia linijka:"</front>
<front id="languageH-319">	#define MSG_FILE_PRINTED "Ukonczono wydruk z pliku"</front>
<front id="languageH-320">	#define MSG_BEGIN_FILE_LIST "Start listy plikow"</front>
<front id="languageH-321">	#define MSG_END_FILE_LIST "Koniec listy plikow"</front>
<front id="languageH-322">	#define MSG_M104_INVALID_EXTRUDER "M104 Niepoprawny ekstruder "</front>
<front id="languageH-323">	#define MSG_M105_INVALID_EXTRUDER "M105 Niepoprawny ekstruder "</front>
<front id="languageH-324">	#define MSG_M218_INVALID_EXTRUDER "M218 Niepoprawny ekstruder "</front>
<front id="languageH-325">	#define MSG_ERR_NO_THERMISTORS "Brak termistorow - brak temperatury :("</front>
<front id="languageH-326">	#define MSG_M109_INVALID_EXTRUDER "M109 Niepoprawny ekstruder "</front>
<front id="languageH-327">	#define MSG_HEATING "Nagrzewanie ekstrudera..."</front>
<front id="languageH-328">	#define MSG_HEATING_COMPLETE "Nagrzewanie ekstrudera zakonczone."</front>
<front id="languageH-329">	#define MSG_BED_HEATING "Nagrzewanie loza..."</front>
<front id="languageH-330">	#define MSG_BED_DONE "Nagrzewanie loza zakonczone."</front>
<front id="languageH-331">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-332">	#define MSG_COUNT_X " Liczenie X: "</front>
<front id="languageH-333">	#define MSG_ERR_KILLED "Drukarka zatrzymana. Wywolano kill()"</front>
<front id="languageH-334">	#define MSG_ERR_STOPPED "Drukarka zatrzymana z powodu bledu. Usun problem i zrestartuj drukartke komenda M999. (temperatura zostala zresetowana; ustaw temperature po restarcie)"</front>
<front id="languageH-335">	#define MSG_RESEND "Wyslij ponownie: "</front>
<front id="languageH-336">	#define MSG_UNKNOWN_COMMAND "Nieznane polecenie: \""</front>
<front id="languageH-337">	#define MSG_ACTIVE_EXTRUDER "Aktywny ekstruder: "</front>
<front id="languageH-338">	#define MSG_INVALID_EXTRUDER "Niepoprawny ekstruder"</front>
<front id="languageH-339">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-340">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-341">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-342">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-343">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-344">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-345">	#define MSG_M119_REPORT "Zgloszenie statusu wylacznikow krancowych"</front>
<front id="languageH-346">	#define MSG_ENDSTOP_HIT "WYZWOLONY"</front>
<front id="languageH-347">	#define MSG_ENDSTOP_OPEN "otwarty"</front>
<front id="languageH-348">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-349"></front>
<front id="languageH-350">	#define MSG_SD_CANT_OPEN_SUBDIR "Nie mozna otworzyc podkatalogu"</front>
<front id="languageH-351">	#define MSG_SD_INIT_FAIL "Blad inicjalizacji karty SD"</front>
<front id="languageH-352">	#define MSG_SD_VOL_INIT_FAIL "Blad inizjalizacji wolumenu"</front>
<front id="languageH-353">	#define MSG_SD_OPENROOT_FAIL "Blad odczytywania katalogu glownego"</front>
<front id="languageH-354">	#define MSG_SD_CARD_OK "Karta SD zainicjalizowana"</front>
<front id="languageH-355">	#define MSG_SD_WORKDIR_FAIL "Blad odczytywania katalogu roboczego"</front>
<front id="languageH-356">	#define MSG_SD_OPEN_FILE_FAIL "Nie mozna otworzyc pliku: "</front>
<front id="languageH-357">	#define MSG_SD_FILE_OPENED "Otwarto plik:"</front>
<front id="languageH-358">	#define MSG_SD_SIZE " Rozmiar:"</front>
<front id="languageH-359">	#define MSG_SD_FILE_SELECTED "Wybrano plik"</front>
<front id="languageH-360">	#define MSG_SD_WRITE_TO_FILE "Zapisywanie do pliku: "</front>
<front id="languageH-361">	#define MSG_SD_PRINTING_BYTE "Drukowanie z karty SD, bajt "</front>
<front id="languageH-362">	#define MSG_SD_NOT_PRINTING "Nie trwa drukowanie z karty SD"</front>
<front id="languageH-363">	#define MSG_SD_ERR_WRITE_TO_FILE "blad podczas zapisu do pliku"</front>
<front id="languageH-364">	#define MSG_SD_CANT_ENTER_SUBDIR "Nie mozna odczytac podkatalogu: "</front>
<front id="languageH-365"></front>
<front id="languageH-366">	#define MSG_STEPPER_TOO_HIGH "Za duza czestotliwosc krokow: "</front>
<front id="languageH-367">	#define MSG_ENDSTOPS_HIT "Wylacznik krancowy zostal wyzwolony na pozycji: "</front>
<front id="languageH-368">	#define MSG_ERR_COLD_EXTRUDE_STOP " uniemozliwiono zimna ekstruzje"</front>
<front id="languageH-369">	#define MSG_ERR_LONG_EXTRUDE_STOP " uniemozliwiono zbyt dluga ekstruzje"</front>
<front id="languageH-370"></front>
<front id="languageH-371">#endif</front>
<front id="languageH-372"></front>
<front id="languageH-373"></front>
<front id="languageH-374">#if LANGUAGE_CHOICE == 3</front>
<front id="languageH-375"></front>
<front id="languageH-376">	#define WELCOME_MSG MACHINE_NAME " prete."</front>
<front id="languageH-377">	#define MSG_SD_INSERTED "Carte inseree"</front>
<front id="languageH-378">	#define MSG_SD_REMOVED "Carte retiree"</front>
<front id="languageH-379">	#define MSG_MAIN "Menu principal"</front>
<front id="languageH-380">	#define MSG_AUTOSTART "Demarrage auto"</front>
<front id="languageH-381">	#define MSG_DISABLE_STEPPERS "Arreter moteurs"</front>
<front id="languageH-382">	#define MSG_AUTO_HOME "Home auto."</front>
<front id="languageH-383">	#define MSG_SET_ORIGIN "Regler origine"</front>
<front id="languageH-384">	#define MSG_PREHEAT_PLA " Prechauffage PLA"</front>
<front id="languageH-385">	#define MSG_PREHEAT_PLA_SETTINGS " Regl. prechauffe PLA"</front>
<front id="languageH-386">	#define MSG_PREHEAT_ABS "Prechauffage ABS"</front>
<front id="languageH-387">	#define MSG_PREHEAT_ABS_SETTINGS "Regl. prechauffe ABS"</front>
<front id="languageH-388">	#define MSG_COOLDOWN "Refroidir"</front>
<front id="languageH-389">	#define MSG_SWITCH_PS_ON "Allumer alim."</front>
<front id="languageH-390">	#define MSG_SWITCH_PS_OFF "Eteindre alim."</front>
<front id="languageH-391">	#define MSG_EXTRUDE "Extrusion"</front>
<front id="languageH-392">	#define MSG_RETRACT "Retraction"</front>
<front id="languageH-393">	#define MSG_PREHEAT_PLA "Prechauffage PLA"</front>
<front id="languageH-394">	#define MSG_PREHEAT_ABS "Prechauffage ABS"</front>
<front id="languageH-395">	#define MSG_MOVE_AXIS "Deplacer un axe"</front>
<front id="languageH-396">	#define MSG_SPEED " Vitesse"</front>
<front id="languageH-397">	#define MSG_NOZZLE "Buse"</front>
<front id="languageH-398">	#define MSG_NOZZLE1 "Buse2"</front>
<front id="languageH-399">	#define MSG_NOZZLE2 "Buse3"</front>
<front id="languageH-400">	#define MSG_BED "Plateau"</front>
<front id="languageH-401">	#define MSG_FAN_SPEED "Vitesse ventilateur"</front>
<front id="languageH-402">	#define MSG_FLOW "Flux"</front>
<front id="languageH-403">	#define MSG_CONTROL "Controler"</front>
<front id="languageH-404">	#define MSG_MIN " \002 Min"</front>
<front id="languageH-405">	#define MSG_MAX " \002 Max"</front>
<front id="languageH-406">	#define MSG_FACTOR " \002 Facteur"</front>
<front id="languageH-407">	#define MSG_AUTOTEMP "Temp. Auto."</front>
<front id="languageH-408">	#define MSG_ON "Marche "</front>
<front id="languageH-409">	#define MSG_OFF "Arret"</front>
<front id="languageH-410">	#define MSG_PID_P "PID-P"</front>
<front id="languageH-411">	#define MSG_PID_I "PID-I"</front>
<front id="languageH-412">	#define MSG_PID_D "PID-D"</front>
<front id="languageH-413">	#define MSG_PID_C "PID-C"</front>
<front id="languageH-414">	#define MSG_ACC "Accel"</front>
<front id="languageH-415">	#define MSG_VXY_JERK "Vxy-jerk"</front>
<front id="languageH-416">	#define MSG_VZ_JERK "Vz-jerk"</front>
<front id="languageH-417">	#define MSG_VE_JERK "Ve-jerk"</front>
<front id="languageH-418">	#define MSG_VMAX "Vmax"</front>
<front id="languageH-419">	#define MSG_X "x"</front>
<front id="languageH-420">	#define MSG_Y "y"</front>
<front id="languageH-421">	#define MSG_Z "z"</front>
<front id="languageH-422">	#define MSG_E "e"</front>
<front id="languageH-423">	#define MSG_VMIN "Vmin"</front>
<front id="languageH-424">	#define MSG_VTRAV_MIN "Vdepl min"</front>
<front id="languageH-425">	#define MSG_AMAX "Amax "</front>
<front id="languageH-426">	#define MSG_A_RETRACT "A-retract"</front>
<front id="languageH-427">	#define MSG_XSTEPS "Xpas/mm"</front>
<front id="languageH-428">	#define MSG_YSTEPS "Ypas/mm"</front>
<front id="languageH-429">	#define MSG_ZSTEPS "Zpas/mm"</front>
<front id="languageH-430">	#define MSG_ESTEPS "Epas/mm"</front>
<front id="languageH-431">	#define MSG_TEMPERATURE "Temperature"</front>
<front id="languageH-432">	#define MSG_MOTION "Mouvement"</front>
<front id="languageH-433">	#define MSG_CONTRAST "Contraste LCD"</front>
<front id="languageH-434">	#define MSG_STORE_EPROM "Sauver config"</front>
<front id="languageH-435">	#define MSG_LOAD_EPROM "Lire config"</front>
<front id="languageH-436">	#define MSG_RESTORE_FAILSAFE "Restaurer defauts"</front>
<front id="languageH-437">	#define MSG_REFRESH "Actualiser"</front>
<front id="languageH-438">	#define MSG_WATCH "Surveiller"</front>
<front id="languageH-439">	#define MSG_PREPARE "Preparer"</front>
<front id="languageH-440">	#define MSG_TUNE "Regler"</front>
<front id="languageH-441">	#define MSG_PAUSE_PRINT "Interrompre impr."</front>
<front id="languageH-442">	#define MSG_RESUME_PRINT "Reprendre impr."</front>
<front id="languageH-443">	#define MSG_STOP_PRINT "Arreter impr."</front>
<front id="languageH-444">	#define MSG_CARD_MENU "Impr. depuis SD"</front>
<front id="languageH-445">	#define MSG_NO_CARD "Pas de carte"</front>
<front id="languageH-446">	#define MSG_DWELL "Repos..."</front>
<front id="languageH-447">	#define MSG_USERWAIT "Attente de l'utilisateur..."</front>
<front id="languageH-448">	#define MSG_RESUMING "Reprise de l'impression"</front>
<front id="languageH-449">	#define MSG_NO_MOVE "Aucun mouvement."</front>
<front id="languageH-450">	#define MSG_PART_RELEASE "Relache partielle"</front>
<front id="languageH-451">	#define MSG_KILLED "MORT."</front>
<front id="languageH-452">	#define MSG_STOPPED "STOPPE."</front>
<front id="languageH-453">	#define MSG_STEPPER_RELEASED "RELACHE."</front>
<front id="languageH-454">	#define MSG_CONTROL_RETRACT "Retraction mm"</front>
<front id="languageH-455">	#define MSG_CONTROL_RETRACTF "Retraction F"</front>
<front id="languageH-456">	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"</front>
<front id="languageH-457">	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"</front>
<front id="languageH-458">	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet F"</front>
<front id="languageH-459">	#define MSG_AUTORETRACT "Retract. Auto."</front>
<front id="languageH-460">	#define MSG_FILAMENTCHANGE "Changer filament"</front>
<front id="languageH-461">	#define MSG_INIT_SDCARD "Init. la carte SD"	</front>
<front id="languageH-462">	#define MSG_CNG_SDCARD "Changer de carte SD"</front>
<front id="languageH-463"></front>
<front id="languageH-464">// Serial Console Messages</front>
<front id="languageH-465"></front>
<front id="languageH-466">	#define MSG_Enqueing "Mise en tampon \""</front>
<front id="languageH-467">	#define MSG_POWERUP "Allumage"</front>
<front id="languageH-468">	#define MSG_EXTERNAL_RESET " RAZ Externe"</front>
<front id="languageH-469">	#define MSG_BROWNOUT_RESET " RAZ defaut alim."</front>
<front id="languageH-470">	#define MSG_WATCHDOG_RESET " RAZ Watchdog"</front>
<front id="languageH-471">	#define MSG_SOFTWARE_RESET " RAZ logicielle"</front>
<front id="languageH-472">	#define MSG_MARLIN "Marlin "</front>
<front id="languageH-473">	#define MSG_AUTHOR " | Auteur: "</front>
<front id="languageH-474">	#define MSG_CONFIGURATION_VER " Derniere MaJ: "</front>
<front id="languageH-475">	#define MSG_FREE_MEMORY " Memoire libre: "</front>
<front id="languageH-476">	#define MSG_PLANNER_BUFFER_BYTES " PlannerBufferBytes: "</front>
<front id="languageH-477">	#define MSG_OK "ok"</front>
<front id="languageH-478">	#define MSG_FILE_SAVED "Fichier enregistre."</front>
<front id="languageH-479">	#define MSG_ERR_LINE_NO "Le numero de ligne n'est pas la derniere ligne + 1, derniere ligne: "</front>
<front id="languageH-480">	#define MSG_ERR_CHECKSUM_MISMATCH "Erreur somme de controle, derniere ligne: "</front>
<front id="languageH-481">	#define MSG_ERR_NO_CHECKSUM "Pas de somme de controle avec le numero de ligne, derniere ligne: "</front>
<front id="languageH-482">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Pas de numero de ligne avec somme de controle, derniere ligne: "</front>
<front id="languageH-483">	#define MSG_FILE_PRINTED "Impression terminee"</front>
<front id="languageH-484">	#define MSG_BEGIN_FILE_LIST "Debut de la liste de fichiers"</front>
<front id="languageH-485">	#define MSG_END_FILE_LIST "Fin de la liste de fichiers"</front>
<front id="languageH-486">	#define MSG_M104_INVALID_EXTRUDER "M104 Extruder invalide"</front>
<front id="languageH-487">	#define MSG_M105_INVALID_EXTRUDER "M105 Extruder invalide"</front>
<front id="languageH-488">	#define MSG_M218_INVALID_EXTRUDER "M218 Extruder invalide"</front>
<front id="languageH-489">	#define MSG_ERR_NO_THERMISTORS "Pas de thermistor, pas de temperature"</front>
<front id="languageH-490">	#define MSG_M109_INVALID_EXTRUDER "M109 Extruder invalide "</front>
<front id="languageH-491">	#define MSG_HEATING "En chauffe..."</front>
<front id="languageH-492">	#define MSG_HEATING_COMPLETE "Chauffe terminee."</front>
<front id="languageH-493">	#define MSG_BED_HEATING "Chauffe du lit."</front>
<front id="languageH-494">	#define MSG_BED_DONE "Chauffe du lit terminee."</front>
<front id="languageH-495">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-496">	#define MSG_COUNT_X " Compteur X: "</front>
<front id="languageH-497">	#define MSG_ERR_KILLED "Impression arretee. kill() appelee!"</front>
<front id="languageH-498">	#define MSG_ERR_STOPPED "Impression arretee a cause d'erreurs. Corriger les erreurs et utiliser M999 pour la reprendre. (Temperature remise a zero. Reactivez la apres redemarrage)"</front>
<front id="languageH-499">	#define MSG_RESEND "Renvoie: "</front>
<front id="languageH-500">	#define MSG_UNKNOWN_COMMAND "Commande inconnue: \""</front>
<front id="languageH-501">	#define MSG_ACTIVE_EXTRUDER "Extrudeur actif: "</front>
<front id="languageH-502">	#define MSG_INVALID_EXTRUDER "Extrudeur invalide"</front>
<front id="languageH-503">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-504">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-505">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-506">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-507">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-508">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-509">	#define MSG_M119_REPORT "Affichage du status des fin de course"</front>
<front id="languageH-510">	#define MSG_ENDSTOP_HIT "DECLENCHE"</front>
<front id="languageH-511">	#define MSG_ENDSTOP_OPEN "OUVERT"</front>
<front id="languageH-512">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-513"></front>
<front id="languageH-514">	#define MSG_SD_CANT_OPEN_SUBDIR "Impossible d'ouvrir le sous-repertoire"</front>
<front id="languageH-515">	#define MSG_SD_INIT_FAIL "Echec de l'initialisation de la SD"</front>
<front id="languageH-516">	#define MSG_SD_VOL_INIT_FAIL "Echec de volume.init"</front>
<front id="languageH-517">	#define MSG_SD_OPENROOT_FAIL "Echec openRoot"</front>
<front id="languageH-518">	#define MSG_SD_CARD_OK "Carte SD Ok"</front>
<front id="languageH-519">	#define MSG_SD_WORKDIR_FAIL "Echec d'ouverture workDir"</front>
<front id="languageH-520">	#define MSG_SD_OPEN_FILE_FAIL "Echec d'ouverture, Fichier: "</front>
<front id="languageH-521">	#define MSG_SD_FILE_OPENED "Fichier ouvert: "</front>
<front id="languageH-522">	#define MSG_SD_SIZE " Taille: "</front>
<front id="languageH-523">	#define MSG_SD_FILE_SELECTED "Fichier selectionne"</front>
<front id="languageH-524">	#define MSG_SD_WRITE_TO_FILE "Ecriture dans le fichier: "</front>
<front id="languageH-525">	#define MSG_SD_PRINTING_BYTE "Octet impression SD "</front>
<front id="languageH-526">	#define MSG_SD_NOT_PRINTING "Pas d'impression SD"</front>
<front id="languageH-527">	#define MSG_SD_ERR_WRITE_TO_FILE "Erreur d'ecriture dans le fichier"</front>
<front id="languageH-528">	#define MSG_SD_CANT_ENTER_SUBDIR "Impossible d'entrer dans le sous-repertoire: "</front>
<front id="languageH-529"></front>
<front id="languageH-530">	#define MSG_STEPPER_TOO_HIGH "Steprate trop eleve: "</front>
<front id="languageH-531">	#define MSG_ENDSTOPS_HIT "Fin de course atteint: "</front>
<front id="languageH-532">	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusion a froid evitee"</front>
<front id="languageH-533">	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusion longue evitee"</front>
<front id="languageH-534">	</front>
<front id="languageH-535">#endif</front>
<front id="languageH-536"></front>
<front id="languageH-537"></front>
<front id="languageH-538">#if LANGUAGE_CHOICE == 4</front>
<front id="languageH-539"></front>
<front id="languageH-540">// LCD Menu Messages</front>
<front id="languageH-541"></front>
<front id="languageH-542">	#define WELCOME_MSG MACHINE_NAME " Bereit."</front>
<front id="languageH-543"></front>
<front id="languageH-544">	#define MSG_SD_INSERTED      "SDKarte erkannt"</front>
<front id="languageH-545">	#define MSG_SD_REMOVED       "SDKarte entfernt"</front>
<front id="languageH-546">	#define MSG_MAIN             "Hauptmen"</front>
<front id="languageH-547">	#define MSG_AUTOSTART        "Autostart"</front>
<front id="languageH-548">	#define MSG_DISABLE_STEPPERS "Stepper abschalten"</front>
<front id="languageH-549">	#define MSG_AUTO_HOME        "Auto Nullpunkt"</front>
<front id="languageH-550">	#define MSG_SET_ORIGIN       "Setze Nullpunkt"</front>
<front id="languageH-551">	#define MSG_PREHEAT_PLA      "Vorwrmen PLA"</front>
<front id="languageH-552">	#define MSG_PREHEAT_PLA_SETTINGS "Vorwrmen PLA Einstellungen"</front>
<front id="languageH-553">	#define MSG_PREHEAT_ABS      "Vorwrmen ABS"</front>
<front id="languageH-554">	#define MSG_PREHEAT_ABS_SETTINGS "Vorwrmen ABS Einstellungen"</front>
<front id="languageH-555">	#define MSG_COOLDOWN         "Abkhlen"</front>
<front id="languageH-556">	#define MSG_SWITCH_PS_ON     "Switch Power On"</front>
<front id="languageH-557">	#define MSG_SWITCH_PS_OFF    "Switch Power Off"</front>
<front id="languageH-558">	#define MSG_EXTRUDE          "Extrude"</front>
<front id="languageH-559">	#define MSG_RETRACT          "Retract"</front>
<front id="languageH-560">	#define MSG_MOVE_AXIS        "Achsen bewegen"</front>
<front id="languageH-561">	#define MSG_SPEED            "Geschw"</front>
<front id="languageH-562">	#define MSG_NOZZLE           "Dse"</front>
<front id="languageH-563">	#define MSG_NOZZLE1          "Dse2"</front>
<front id="languageH-564">	#define MSG_NOZZLE2          "Dse3"</front>
<front id="languageH-565">	#define MSG_BED              "Bett"</front>
<front id="languageH-566">	#define MSG_FAN_SPEED        "Lftergeschw."</front>
<front id="languageH-567">	#define MSG_FLOW             "Fluss"</front>
<front id="languageH-568">	#define MSG_CONTROL          "Einstellungen"</front>
<front id="languageH-569">	#define MSG_MIN              "\002 Min"</front>
<front id="languageH-570">	#define MSG_MAX              "\002 Max"</front>
<front id="languageH-571">	#define MSG_FACTOR           "\002 Faktor"</front>
<front id="languageH-572">	#define MSG_AUTOTEMP         "AutoTemp"</front>
<front id="languageH-573">	#define MSG_ON               "Ein"</front>
<front id="languageH-574">	#define MSG_OFF              "Aus"</front>
<front id="languageH-575">	#define MSG_PID_P            "PID-P"</front>
<front id="languageH-576">	#define MSG_PID_I            "PID-I"</front>
<front id="languageH-577">	#define MSG_PID_D            "PID-D"</front>
<front id="languageH-578">	#define MSG_PID_C            "PID-C"</front>
<front id="languageH-579">	#define MSG_ACC              "Acc"</front>
<front id="languageH-580">	#define MSG_VXY_JERK         "Vxy-jerk"</front>
<front id="languageH-581">	#define MSG_VZ_JERK          "Vz-jerk"</front>
<front id="languageH-582">	#define MSG_VE_JERK          "Ve-jerk"</front>
<front id="languageH-583">	#define MSG_VMAX             "Vmax "</front>
<front id="languageH-584">	#define MSG_X                "x"</front>
<front id="languageH-585">	#define MSG_Y                "y"</front>
<front id="languageH-586">	#define MSG_Z                "z"</front>
<front id="languageH-587">	#define MSG_E                "e"</front>
<front id="languageH-588">	#define MSG_VMIN             "Vmin"</front>
<front id="languageH-589">	#define MSG_VTRAV_MIN        "VTrav min"</front>
<front id="languageH-590">	#define MSG_AMAX             "Amax "</front>
<front id="languageH-591">	#define MSG_A_RETRACT        "A-Retract"</front>
<front id="languageH-592">	#define MSG_XSTEPS           "Xsteps/mm"</front>
<front id="languageH-593">	#define MSG_YSTEPS           "Ysteps/mm"</front>
<front id="languageH-594">	#define MSG_ZSTEPS           "Zsteps/mm"</front>
<front id="languageH-595">	#define MSG_ESTEPS           "Esteps/mm"</front>
<front id="languageH-596">	#define MSG_RECTRACT_WIDE    "Rectract"</front>
<front id="languageH-597">	#define MSG_WATCH            "Beobachten"</front>
<front id="languageH-598">	#define MSG_TEMPERATURE      "Temperatur"</front>
<front id="languageH-599">	#define MSG_MOTION           "Bewegung"</front>
<front id="languageH-600">	#define MSG_CONTRAST "LCD contrast"</front>
<front id="languageH-601">	#define MSG_STORE_EPROM      "EPROM speichern"</front>
<front id="languageH-602">	#define MSG_LOAD_EPROM       "EPROM laden"</front>
<front id="languageH-603">	#define MSG_RESTORE_FAILSAFE "Standardkonfig."</front>
<front id="languageH-604">	#define MSG_REFRESH          "Aktualisieren"</front>
<front id="languageH-605">	#define MSG_PREPARE          "Vorbereitung"</front>
<front id="languageH-606">	#define MSG_CONTROL          "Einstellungen"</front>
<front id="languageH-607">	#define MSG_TUNE             "Justierung"</front>
<front id="languageH-608">	#define MSG_PAUSE_PRINT      "Druck anhalten"</front>
<front id="languageH-609">	#define MSG_RESUME_PRINT     "Druck fortsetz"</front>
<front id="languageH-610">	#define MSG_STOP_PRINT       "Druck stoppen"</front>
<front id="languageH-611">	#define MSG_CARD_MENU        "SDKarten Men"</front>
<front id="languageH-612">	#define MSG_NO_CARD          "Keine SDKarte"</front>
<front id="languageH-613">	#define MSG_DWELL            "Warten..."		</front>
<front id="languageH-614">	#define MSG_USERWAIT         "Warte auf Nutzer..."</front>
<front id="languageH-615">	#define MSG_RESUMING         "Druck fortsetzung"</front>
<front id="languageH-616">	#define MSG_NO_MOVE          "Kein Zug."</front>
<front id="languageH-617">	#define MSG_PART_RELEASE     "Stepper tlw frei"</front>
<front id="languageH-618">	#define MSG_KILLED           "KILLED"</front>
<front id="languageH-619">	#define MSG_STOPPED          "GESTOPPT"</front>
<front id="languageH-620">	#define MSG_STEPPER_RELEASED "Stepper frei"</front>
<front id="languageH-621">	#define MSG_CONTROL_RETRACT  "Retract mm"</front>
<front id="languageH-622">	#define MSG_CONTROL_RETRACTF "Retract  F"</front>
<front id="languageH-623">	#define MSG_CONTROL_RETRACT_ZLIFT "Hop mm"</front>
<front id="languageH-624">	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"</front>
<front id="languageH-625">	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"</front>
<front id="languageH-626">	#define MSG_AUTORETRACT      "AutoRetr."</front>
<front id="languageH-627">	#define MSG_FILAMENTCHANGE "Filament wechseln"</front>
<front id="languageH-628">	#define MSG_INIT_SDCARD "Init. SD-Card"	</front>
<front id="languageH-629">	#define MSG_CNG_SDCARD "Change SD-Card"</front>
<front id="languageH-630">	</front>
<front id="languageH-631">// Serial Console Messages</front>
<front id="languageH-632"></front>
<front id="languageH-633">	#define MSG_Enqueing "enqueing \""</front>
<front id="languageH-634">	#define MSG_POWERUP "PowerUp"</front>
<front id="languageH-635">	#define MSG_EXTERNAL_RESET " External Reset"</front>
<front id="languageH-636">	#define MSG_BROWNOUT_RESET " Brown out Reset"</front>
<front id="languageH-637">	#define MSG_WATCHDOG_RESET " Watchdog Reset"</front>
<front id="languageH-638">	#define MSG_SOFTWARE_RESET " Software Reset"</front>
<front id="languageH-639">	#define MSG_MARLIN "Marlin: "</front>
<front id="languageH-640">	#define MSG_AUTHOR " | Author: "</front>
<front id="languageH-641">	#define MSG_CONFIGURATION_VER " Last Updated: "</front>
<front id="languageH-642">	#define MSG_FREE_MEMORY " Free Memory: "</front>
<front id="languageH-643">	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "</front>
<front id="languageH-644">	#define MSG_OK "ok"</front>
<front id="languageH-645">	#define MSG_FILE_SAVED "Done saving file."</front>
<front id="languageH-646">	#define MSG_ERR_LINE_NO "Line Number is not Last Line Number+1, Last Line:"</front>
<front id="languageH-647">	#define MSG_ERR_CHECKSUM_MISMATCH "checksum mismatch, Last Line:"</front>
<front id="languageH-648">	#define MSG_ERR_NO_CHECKSUM "No Checksum with line number, Last Line:"</front>
<front id="languageH-649">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line:"</front>
<front id="languageH-650">	#define MSG_FILE_PRINTED "Done printing file"</front>
<front id="languageH-651">	#define MSG_BEGIN_FILE_LIST "Begin file list"</front>
<front id="languageH-652">	#define MSG_END_FILE_LIST "End file list"</front>
<front id="languageH-653">	#define MSG_M104_INVALID_EXTRUDER "M104 Invalid extruder "</front>
<front id="languageH-654">	#define MSG_M105_INVALID_EXTRUDER "M105 Invalid extruder "</front>
<front id="languageH-655">	#define MSG_M218_INVALID_EXTRUDER "M218 Invalid extruder "</front>
<front id="languageH-656">	#define MSG_ERR_NO_THERMISTORS "No thermistors - no temp"</front>
<front id="languageH-657">	#define MSG_M109_INVALID_EXTRUDER "M109 Invalid extruder "</front>
<front id="languageH-658">	#define MSG_HEATING "Heating..."</front>
<front id="languageH-659">	#define MSG_HEATING_COMPLETE "Heating done."</front>
<front id="languageH-660">	#define MSG_BED_HEATING "Bed Heating."</front>
<front id="languageH-661">	#define MSG_BED_DONE "Bed done."</front>
<front id="languageH-662">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-663">	#define MSG_COUNT_X " Count X:"</front>
<front id="languageH-664">	#define MSG_ERR_KILLED "Printer halted. kill() called !!"</front>
<front id="languageH-665">	#define MSG_ERR_STOPPED "Printer stopped due to errors. Fix the error and use M999 to restart!"</front>
<front id="languageH-666">	#define MSG_RESEND "Resend:"</front>
<front id="languageH-667">	#define MSG_UNKNOWN_COMMAND "Unknown command:\""</front>
<front id="languageH-668">	#define MSG_ACTIVE_EXTRUDER "Active Extruder: "</front>
<front id="languageH-669">	#define MSG_INVALID_EXTRUDER "Invalid extruder"</front>
<front id="languageH-670">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-671">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-672">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-673">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-674">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-675">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-676">	#define MSG_M119_REPORT "Reporting endstop status"</front>
<front id="languageH-677">	#define MSG_ENDSTOP_HIT "TRIGGERED"</front>
<front id="languageH-678">	#define MSG_ENDSTOP_OPEN "open"</front>
<front id="languageH-679">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-680"></front>
<front id="languageH-681">	#define MSG_SD_CANT_OPEN_SUBDIR "Cannot open subdir"</front>
<front id="languageH-682">	#define MSG_SD_INIT_FAIL "SD init fail"</front>
<front id="languageH-683">	#define MSG_SD_VOL_INIT_FAIL "volume.init failed"</front>
<front id="languageH-684">	#define MSG_SD_OPENROOT_FAIL "openRoot failed"</front>
<front id="languageH-685">	#define MSG_SD_CARD_OK "SD card ok"</front>
<front id="languageH-686">	#define MSG_SD_WORKDIR_FAIL "workDir open failed"</front>
<front id="languageH-687">	#define MSG_SD_OPEN_FILE_FAIL "open failed, File: "</front>
<front id="languageH-688">	#define MSG_SD_FILE_OPENED "File opened:"</front>
<front id="languageH-689">	#define MSG_SD_SIZE " Size:"</front>
<front id="languageH-690">	#define MSG_SD_FILE_SELECTED "File selected"</front>
<front id="languageH-691">	#define MSG_SD_WRITE_TO_FILE "Writing to file: "</front>
<front id="languageH-692">	#define MSG_SD_PRINTING_BYTE "SD printing byte "</front>
<front id="languageH-693">	#define MSG_SD_NOT_PRINTING "Not SD printing"</front>
<front id="languageH-694">	#define MSG_SD_ERR_WRITE_TO_FILE "error writing to file"</front>
<front id="languageH-695">	#define MSG_SD_CANT_ENTER_SUBDIR "Cannot enter subdir:"</front>
<front id="languageH-696"></front>
<front id="languageH-697">	#define MSG_STEPPER_TOO_HIGH "Steprate too high : "</front>
<front id="languageH-698">	#define MSG_ENDSTOPS_HIT "endstops hit: "</front>
<front id="languageH-699">	#define MSG_ERR_COLD_EXTRUDE_STOP " cold extrusion prevented"</front>
<front id="languageH-700">	#define MSG_ERR_LONG_EXTRUDE_STOP " too long extrusion prevented"</front>
<front id="languageH-701"></front>
<front id="languageH-702">#endif</front>
<front id="languageH-703"></front>
<front id="languageH-704"></front>
<front id="languageH-705">#if LANGUAGE_CHOICE == 5</front>
<front id="languageH-706"></front>
<front id="languageH-707">// LCD Menu Messages</front>
<front id="languageH-708">	#define WELCOME_MSG MACHINE_NAME "Lista."</front>
<front id="languageH-709">	#define MSG_SD_INSERTED "Tarjeta SD Colocada"</front>
<front id="languageH-710">	#define MSG_SD_REMOVED "Tarjeta SD Retirada"</front>
<front id="languageH-711">	#define MSG_MAIN "Menu Principal"</front>
<front id="languageH-712">	#define MSG_AUTOSTART " Autostart"</front>
<front id="languageH-713">	#define MSG_DISABLE_STEPPERS "Apagar Motores"</front>
<front id="languageH-714">	#define MSG_AUTO_HOME "Llevar al Origen" // "Llevar Ejes al Cero"</front>
<front id="languageH-715">	#define MSG_SET_ORIGIN "Establecer Cero"</front>
<front id="languageH-716">	#define MSG_PREHEAT_PLA "Precalentar PLA"</front>
<front id="languageH-717">	#define MSG_PREHEAT_PLA_SETTINGS "Ajustar temp. PLA"</front>
<front id="languageH-718">	#define MSG_PREHEAT_ABS "Precalentar ABS"</front>
<front id="languageH-719">	#define MSG_PREHEAT_ABS_SETTINGS "Ajustar temp. ABS"</front>
<front id="languageH-720">	#define MSG_COOLDOWN "Enfriar"</front>
<front id="languageH-721">	#define MSG_SWITCH_PS_ON "Switch Power On"</front>
<front id="languageH-722">	#define MSG_SWITCH_PS_OFF "Switch Power Off"</front>
<front id="languageH-723">	#define MSG_EXTRUDE "Extruir"</front>
<front id="languageH-724">	#define MSG_RETRACT "Retraer"</front>
<front id="languageH-725">	#define MSG_MOVE_AXIS "Mover Ejes"</front>
<front id="languageH-726">	#define MSG_SPEED "Velocidad"</front>
<front id="languageH-727">	#define MSG_NOZZLE "Nozzle"</front>
<front id="languageH-728">	#define MSG_NOZZLE1 "Nozzle2"</front>
<front id="languageH-729">	#define MSG_NOZZLE2 "Nozzle3"</front>
<front id="languageH-730">	#define MSG_BED "Base"</front>
<front id="languageH-731">	#define MSG_FAN_SPEED "Ventilador"</front>
<front id="languageH-732">	#define MSG_FLOW "Flujo"</front>
<front id="languageH-733">	#define MSG_CONTROL "Control"</front>
<front id="languageH-734">	#define MSG_MIN "\002 Min"</front>
<front id="languageH-735">	#define MSG_MAX "\002 Max"</front>
<front id="languageH-736">	#define MSG_FACTOR "\002 Fact"</front>
<front id="languageH-737">	#define MSG_AUTOTEMP "Autotemp"</front>
<front id="languageH-738">	#define MSG_ON "On"</front>
<front id="languageH-739">	#define MSG_OFF "Off"</front>
<front id="languageH-740">	#define MSG_PID_P "PID-P"</front>
<front id="languageH-741">	#define MSG_PID_I "PID-I"</front>
<front id="languageH-742">	#define MSG_PID_D "PID-D"</front>
<front id="languageH-743">	#define MSG_PID_C "PID-C"</front>
<front id="languageH-744">	#define MSG_ACC  "Acel"</front>
<front id="languageH-745">	#define MSG_VXY_JERK "Vxy-jerk"</front>
<front id="languageH-746">	#define MSG_VZ_JERK "Vz-jerk"</front>
<front id="languageH-747">	#define MSG_VE_JERK "Ve-jerk"</front>
<front id="languageH-748">	#define MSG_VMAX "Vmax"</front>
<front id="languageH-749">	#define MSG_X "x"</front>
<front id="languageH-750">	#define MSG_Y "y"</front>
<front id="languageH-751">	#define MSG_Z "z"</front>
<front id="languageH-752">	#define MSG_E "e"</front>
<front id="languageH-753">	#define MSG_VMIN "Vmin"</front>
<front id="languageH-754">	#define MSG_VTRAV_MIN "VTrav min"</front>
<front id="languageH-755">	#define MSG_AMAX "Amax"</front>
<front id="languageH-756">	#define MSG_A_RETRACT "A-retrac."</front>
<front id="languageH-757">	#define MSG_XSTEPS "X pasos/mm"</front>
<front id="languageH-758">	#define MSG_YSTEPS "Y pasos/mm"</front>
<front id="languageH-759">	#define MSG_ZSTEPS "Z pasos/mm"</front>
<front id="languageH-760">	#define MSG_ESTEPS "E pasos/mm"</front>
<front id="languageH-761">	#define MSG_RECTRACT "Retraer"</front>
<front id="languageH-762">	#define MSG_TEMPERATURE "Temperatura"</front>
<front id="languageH-763">	#define MSG_MOTION "Movimiento"</front>
<front id="languageH-764">	#define MSG_STORE_EPROM "Guardar Memoria"</front>
<front id="languageH-765">	#define MSG_LOAD_EPROM "Cargar Memoria"</front>
<front id="languageH-766">	#define MSG_RESTORE_FAILSAFE "Rest. de emergencia"</front>
<front id="languageH-767">	#define MSG_REFRESH "Volver a cargar"</front>
<front id="languageH-768">	#define MSG_WATCH "Monitorizar"</front>
<front id="languageH-769">	#define MSG_PREPARE "Preparar"</front>
<front id="languageH-770">	#define MSG_TUNE "Ajustar"</front>
<front id="languageH-771">	#define MSG_PAUSE_PRINT "Pausar Impresion"</front>
<front id="languageH-772">	#define MSG_RESUME_PRINT "Reanudar Impresion"</front>
<front id="languageH-773">	#define MSG_STOP_PRINT "Detener Impresion"</front>
<front id="languageH-774">	#define MSG_CARD_MENU "Menu de SD"</front>
<front id="languageH-775">	#define MSG_NO_CARD "No hay Tarjeta SD"</front>
<front id="languageH-776">	#define MSG_DWELL "Reposo..."</front>
<front id="languageH-777">	#define MSG_USERWAIT "Esperando Ordenes..."</front>
<front id="languageH-778">	#define MSG_RESUMING "Resumiendo Impresion"</front>
<front id="languageH-779">	#define MSG_NO_MOVE "Sin movimiento"</front>
<front id="languageH-780">	#define MSG_KILLED "PARADA DE EMERGENCIA. "</front>
<front id="languageH-781">	#define MSG_STOPPED "PARADA."</front>
<front id="languageH-782">	#define MSG_CONTROL_RETRACT  "Retraer mm"</front>
<front id="languageH-783">	#define MSG_CONTROL_RETRACTF "Retraer  F"</front>
<front id="languageH-784">	#define MSG_CONTROL_RETRACT_ZLIFT "Levantar mm"</front>
<front id="languageH-785">	#define MSG_CONTROL_RETRACT_RECOVER "DesRet +mm"</front>
<front id="languageH-786">	#define MSG_CONTROL_RETRACT_RECOVERF "DesRet F"</front>
<front id="languageH-787">	#define MSG_AUTORETRACT "AutoRetr."</front>
<front id="languageH-788">	#define MSG_FILAMENTCHANGE "Change filament"</front>
<front id="languageH-789">	#define MSG_INIT_SDCARD "Iniciando. Tarjeta-SD"</front>
<front id="languageH-790">	#define MSG_CNG_SDCARD "Cambiar Tarjeta-SD"</front>
<front id="languageH-791">	#define MSG_RECTRACT_WIDE "Retraer"</front>
<front id="languageH-792">	#define MSG_TEMPERATURE_WIDE "Temperatura"</front>
<front id="languageH-793">	#define MSG_TEMPERATURE_RTN  "Temperatura"</front>
<front id="languageH-794">	#define MSG_MAIN_WIDE "Menu Principal"</front>
<front id="languageH-795">	#define MSG_MOTION_WIDE "Movimiento"</front>
<front id="languageH-796">	#define MSG_PREPARE_ALT "Preparar"</front>
<front id="languageH-797">	#define MSG_CONTROL_ARROW "Control"</front>
<front id="languageH-798">	#define MSG_RETRACT_ARROW "Retraer"</front>
<front id="languageH-799">	#define MSG_PART_RELEASE "Desacople Parcial"</front>
<front id="languageH-800">	#define MSG_STEPPER_RELEASED "Desacoplada."</front>
<front id="languageH-801"></front>
<front id="languageH-802">// Serial Console Messages</front>
<front id="languageH-803"></front>
<front id="languageH-804">	#define MSG_Enqueing "En cola \""</front>
<front id="languageH-805">	#define MSG_POWERUP "PowerUp"</front>
<front id="languageH-806">	#define MSG_EXTERNAL_RESET " Reset Externo"</front>
<front id="languageH-807">	#define MSG_BROWNOUT_RESET " Reset por Voltaje Incorrecto"</front>
<front id="languageH-808">	#define MSG_WATCHDOG_RESET " Reset por Bloqueo"</front>
<front id="languageH-809">	#define MSG_SOFTWARE_RESET " Reset por Software"</front>
<front id="languageH-810">	#define MSG_MARLIN "Marlin "</front>
<front id="languageH-811">	#define MSG_AUTHOR " | Autor: "</front>
<front id="languageH-812">	#define MSG_CONFIGURATION_VER " Ultima actualizacion: "</front>
<front id="languageH-813">	#define MSG_FREE_MEMORY " Memoria libre: "</front>
<front id="languageH-814">	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "</front>
<front id="languageH-815">	#define MSG_OK "ok"</front>
<front id="languageH-816">	#define MSG_FILE_SAVED "Guardado."</front>
<front id="languageH-817">	#define MSG_ERR_LINE_NO "El Numero de Linea no es igual al Ultimo Numero de Linea+1, Ultima Linea:"</front>
<front id="languageH-818">	#define MSG_ERR_CHECKSUM_MISMATCH "el checksum no coincide, Ultima Linea:"</front>
<front id="languageH-819">	#define MSG_ERR_NO_CHECKSUM "No se pudo hallar el Checksum con el numero de linea, Ultima Linea:"</front>
<front id="languageH-820">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No se hallo el Numero de Linea con el Checksum, Ultima Linea:"</front>
<front id="languageH-821">	#define MSG_FILE_PRINTED "Impresion terminada"</front>
<front id="languageH-822">	#define MSG_BEGIN_FILE_LIST "Comienzo de la lista de archivos"</front>
<front id="languageH-823">	#define MSG_END_FILE_LIST "Fin de la lista de archivos"</front>
<front id="languageH-824">	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor Invalido "</front>
<front id="languageH-825">	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor Invalido "</front>
<front id="languageH-826">	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor Invalido "</front>
<front id="languageH-827">	#define MSG_ERR_NO_THERMISTORS "No hay termistores - no temp"</front>
<front id="languageH-828">	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor Invalido "</front>
<front id="languageH-829">	#define MSG_HEATING "Calentando..."</front>
<front id="languageH-830">	#define MSG_HEATING_COMPLETE "Calentamiento Hecho."</front>
<front id="languageH-831">	#define MSG_BED_HEATING "Calentando la base."</front>
<front id="languageH-832">	#define MSG_BED_DONE "Base Caliente."</front>
<front id="languageH-833">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-834">	#define MSG_COUNT_X " Cuenta X:"</front>
<front id="languageH-835">	#define MSG_ERR_KILLED "Impresora Parada con kill()!!"</front>
<front id="languageH-836">	#define MSG_ERR_STOPPED "Impresora parada por errores. Arregle el error y use M999 Para reiniciar!. (La temperatura se reestablece. Ajustela antes de continuar)"</front>
<front id="languageH-837">	#define MSG_RESEND "Reenviar:"</front>
<front id="languageH-838">	#define MSG_UNKNOWN_COMMAND "Comando Desconocido:\""</front>
<front id="languageH-839">	#define MSG_ACTIVE_EXTRUDER "Extrusor Activo: "</front>
<front id="languageH-840">	#define MSG_INVALID_EXTRUDER "Extrusor Invalido"</front>
<front id="languageH-841">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-842">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-843">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-844">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-845">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-846">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-847">	#define MSG_M119_REPORT "Comprobando fines de carrera."</front>
<front id="languageH-848">	#define MSG_ENDSTOP_HIT "PULSADO"</front>
<front id="languageH-849">	#define MSG_ENDSTOP_OPEN "abierto"</front>
<front id="languageH-850">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-851">	#define MSG_SD_CANT_OPEN_SUBDIR "No se pudo abrir la subcarpeta."</front>
<front id="languageH-852">	#define MSG_SD_INIT_FAIL "Fallo al iniciar la SD"</front>
<front id="languageH-853">	#define MSG_SD_VOL_INIT_FAIL "Fallo al montar el volumen"</front>
<front id="languageH-854">	#define MSG_SD_OPENROOT_FAIL "Fallo al abrir la carpeta raiz"</front>
<front id="languageH-855">	#define MSG_SD_CARD_OK "Tarjeta SD OK"</front>
<front id="languageH-856">	#define MSG_SD_WORKDIR_FAIL "Fallo al abrir la carpeta de trabajo"</front>
<front id="languageH-857">	#define MSG_SD_OPEN_FILE_FAIL "Error al abrir, Archivo: "</front>
<front id="languageH-858">	#define MSG_SD_FILE_OPENED "Archivo abierto:"</front>
<front id="languageH-859">	#define MSG_SD_SIZE " Tamao:"</front>
<front id="languageH-860">	#define MSG_SD_FILE_SELECTED "Archivo Seleccionado"</front>
<front id="languageH-861">	#define MSG_SD_WRITE_TO_FILE "Escribiendo en el archivo: "</front>
<front id="languageH-862">	#define MSG_SD_PRINTING_BYTE "SD imprimiendo el byte "</front>
<front id="languageH-863">	#define MSG_SD_NOT_PRINTING "No se esta imprimiendo con SD"</front>
<front id="languageH-864">	#define MSG_SD_ERR_WRITE_TO_FILE "Error al escribir en el archivo"</front>
<front id="languageH-865">	#define MSG_SD_CANT_ENTER_SUBDIR "No se puede abrir la carpeta:"</front>
<front id="languageH-866"></front>
<front id="languageH-867">	#define MSG_STEPPER_TOO_HIGH "Steprate demasiado alto : "</front>
<front id="languageH-868">	#define MSG_ENDSTOPS_HIT "Se ha tocado el fin de carril: "</front>
<front id="languageH-869">	#define MSG_ERR_COLD_EXTRUDE_STOP " extrusion fria evitada"</front>
<front id="languageH-870">	#define MSG_ERR_LONG_EXTRUDE_STOP " extrusion demasiado larga evitada"</front>
<front id="languageH-871"></front>
<front id="languageH-872">#endif</front>
<front id="languageH-873"></front>
<front id="languageH-874">#if LANGUAGE_CHOICE == 6</front>
<front id="languageH-875"></front>
<front id="languageH-876">	// LCD Menu Messages</front>
<front id="languageH-877">	#define WELCOME_MSG MACHINE_NAME			" "</front>
<front id="languageH-878">	#define MSG_SD_INSERTED						" "</front>
<front id="languageH-879">	#define MSG_SD_REMOVED						" "</front>
<front id="languageH-880">	#define MSG_MAIN							"               \003"</front>
<front id="languageH-881">	#define MSG_AUTOSTART						"           "</front>
<front id="languageH-882">	#define MSG_DISABLE_STEPPERS				"  "</front>
<front id="languageH-883">	#define MSG_AUTO_HOME						"            "</front>
<front id="languageH-884">	#define MSG_SET_ORIGIN						"       "</front>
<front id="languageH-885">	#define MSG_PREHEAT_PLA						"  PLA     "</front>
<front id="languageH-886">	#define MSG_PREHEAT_PLA_SETTINGS			" . .PLA"</front>
<front id="languageH-887">	#define MSG_PREHEAT_ABS						"  ABS     "</front>
<front id="languageH-888">	#define MSG_PREHEAT_ABS_SETTINGS			" . .ABS"</front>
<front id="languageH-889">	#define MSG_COOLDOWN						"          "</front>
<front id="languageH-890">	#define MSG_SWITCH_PS_ON					"Switch Power On"</front>
<front id="languageH-891">	#define MSG_SWITCH_PS_OFF					"Switch Power Off"</front>
<front id="languageH-892">	#define MSG_EXTRUDE							"           "</front>
<front id="languageH-893">	#define MSG_RETRACT							" "</front>
<front id="languageH-894">	#define MSG_MOVE_AXIS						"     \x7E"</front>
<front id="languageH-895">	#define MSG_SPEED							" :"</front>
<front id="languageH-896">	#define MSG_NOZZLE							" \002 :"</front>
<front id="languageH-897">	#define MSG_NOZZLE1							" \002 2:"</front>
<front id="languageH-898">	#define MSG_NOZZLE2							" \002 3:"</front>
<front id="languageH-899">	#define MSG_BED								" \002 :"</front>
<front id="languageH-900">	#define MSG_FAN_SPEED						" :"</front>
<front id="languageH-901">	#define MSG_FLOW							" :"</front>
<front id="languageH-902">	#define MSG_CONTROL							"  \003"</front>
<front id="languageH-903">	#define MSG_MIN								" \002 :"</front>
<front id="languageH-904">	#define MSG_MAX								" \002 :"</front>
<front id="languageH-905">	#define MSG_FACTOR							" \002 :"</front>
<front id="languageH-906">	#define MSG_AUTOTEMP						" Autotemp:"</front>
<front id="languageH-907">	#define MSG_ON								". "</front>
<front id="languageH-908">	#define MSG_OFF								". "</front>
<front id="languageH-909">	#define MSG_PID_P							" PID-P: "</front>
<front id="languageH-910">	#define MSG_PID_I							" PID-I: "</front>
<front id="languageH-911">	#define MSG_PID_D							" PID-D: "</front>
<front id="languageH-912">	#define MSG_PID_C							" PID-C: "</front>
<front id="languageH-913">	#define MSG_ACC								" Acc:"</front>
<front id="languageH-914">	#define MSG_VXY_JERK						" Vxy-jerk: "</front>
<front id="languageH-915">	#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="languageH-916">	#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="languageH-917">	#define MSG_VMAX							" Vmax "</front>
<front id="languageH-918">	#define MSG_X								"x:"</front>
<front id="languageH-919">	#define MSG_Y								"y:"</front>
<front id="languageH-920">	#define MSG_Z								"z:"</front>
<front id="languageH-921">	#define MSG_E								"e:"</front>
<front id="languageH-922">	#define MSG_VMIN							" Vmin:"</front>
<front id="languageH-923">	#define MSG_VTRAV_MIN						" VTrav min:"</front>
<front id="languageH-924">	#define MSG_AMAX							" Amax "</front>
<front id="languageH-925">	#define MSG_A_RETRACT						" A-retract:"</front>
<front id="languageH-926">	#define MSG_XSTEPS							" X /mm:"</front>
<front id="languageH-927">	#define MSG_YSTEPS							" Y /mm:"</front>
<front id="languageH-928">	#define MSG_ZSTEPS							" Z /mm:"</front>
<front id="languageH-929">	#define MSG_ESTEPS							" E /mm:"</front>
<front id="languageH-930">	#define MSG_RECTRACT    					"        \x7E"</front>
<front id="languageH-931">	#define MSG_TEMPERATURE  				"        \x7E"</front>
<front id="languageH-932">	#define MSG_MOTION						"           \x7E"</front>
<front id="languageH-933">		#define MSG_CONTRAST "LCD contrast"</front>
<front id="languageH-934">	#define MSG_STORE_EPROM						"  "</front>
<front id="languageH-935">	#define MSG_LOAD_EPROM						"  "</front>
<front id="languageH-936">	#define MSG_RESTORE_FAILSAFE				"       "</front>
<front id="languageH-937">	#define MSG_REFRESH							"\004           "</front>
<front id="languageH-938">	#define MSG_WATCH							"              \003"</front>
<front id="languageH-939">	#define MSG_PREPARE							"           \x7E"</front>
<front id="languageH-940">	#define MSG_TUNE					"          \x7E"</front>
<front id="languageH-941">	#define MSG_PAUSE_PRINT						"        \x7E"</front>
<front id="languageH-942">	#define MSG_RESUME_PRINT					"   \x7E"</front>
<front id="languageH-943">	#define MSG_STOP_PRINT						"   \x7E"</front>
<front id="languageH-944">	#define MSG_CARD_MENU						"          \x7E"</front>
<front id="languageH-945">	#define MSG_NO_CARD							"  "</front>
<front id="languageH-946">	#define MSG_DWELL							"..."</front>
<front id="languageH-947">	#define MSG_USERWAIT						"  ."</front>
<front id="languageH-948">	#define MSG_RESUMING "Resuming print"</front>
<front id="languageH-949">	#define MSG_NO_MOVE							" .       "</front>
<front id="languageH-950">	#define MSG_PART_RELEASE					"    "</front>
<front id="languageH-951">	#define MSG_KILLED							". "</front>
<front id="languageH-952">	#define MSG_STOPPED							". "</front>
<front id="languageH-953">	#define MSG_CONTROL_RETRACT					"  mm:"</front>
<front id="languageH-954">	#define MSG_CONTROL_RETRACTF				"   F:"</front>
<front id="languageH-955">	#define MSG_CONTROL_RETRACT_ZLIFT			"  mm:"</front>
<front id="languageH-956">	#define MSG_CONTROL_RETRACT_RECOVER			"  +mm:"</front>
<front id="languageH-957">	#define MSG_CONTROL_RETRACT_RECOVERF		"   F:"</front>
<front id="languageH-958">	#define MSG_AUTORETRACT						" :"</front>
<front id="languageH-959">	#define MSG_FILAMENTCHANGE "Change filament"</front>
<front id="languageH-960">	#define MSG_INIT_SDCARD "Init. SD-Card"	</front>
<front id="languageH-961">	#define MSG_CNG_SDCARD "Change SD-Card"</front>
<front id="languageH-962"></front>
<front id="languageH-963">// Serial Console Messages</front>
<front id="languageH-964"></front>
<front id="languageH-965">	#define MSG_Enqueing						" \""</front>
<front id="languageH-966">	#define MSG_POWERUP							" "</front>
<front id="languageH-967">	#define MSG_EXTERNAL_RESET					"  "</front>
<front id="languageH-968">	#define MSG_BROWNOUT_RESET					" Brown out "</front>
<front id="languageH-969">	#define MSG_WATCHDOG_RESET					" Watchdog "</front>
<front id="languageH-970">	#define MSG_SOFTWARE_RESET					"  "</front>
<front id="languageH-971">	#define MSG_MARLIN							"Marlin "</front>
<front id="languageH-972">	#define MSG_AUTHOR							" | : "</front>
<front id="languageH-973">	#define MSG_CONFIGURATION_VER				"  : "</front>
<front id="languageH-974">	#define MSG_FREE_MEMORY						"  : "</front>
<front id="languageH-975">	#define MSG_PLANNER_BUFFER_BYTES			"     Bytes: "</front>
<front id="languageH-976">	#define MSG_OK								"ok"</front>
<front id="languageH-977">	#define MSG_FILE_SAVED						" ."</front>
<front id="languageH-978">	#define MSG_ERR_LINE_NO						"     +1,  :"</front>
<front id="languageH-979">	#define MSG_ERR_CHECKSUM_MISMATCH			"   ,  :"</front>
<front id="languageH-980">	#define MSG_ERR_NO_CHECKSUM					"    ,  :"</front>
<front id="languageH-981">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM	"    ,  :"</front>
<front id="languageH-982">	#define MSG_FILE_PRINTED					"  "</front>
<front id="languageH-983">	#define MSG_BEGIN_FILE_LIST					" "</front>
<front id="languageH-984">	#define MSG_END_FILE_LIST					"  "</front>
<front id="languageH-985">	#define MSG_M104_INVALID_EXTRUDER			"M104   "</front>
<front id="languageH-986">	#define MSG_M105_INVALID_EXTRUDER			"M105   "</front>
<front id="languageH-987">	#define MSG_M218_INVALID_EXTRUDER			"M218   "</front>
<front id="languageH-988">	#define MSG_ERR_NO_THERMISTORS				"  -  "</front>
<front id="languageH-989">	#define MSG_M109_INVALID_EXTRUDER			"M109   "</front>
<front id="languageH-990">	#define MSG_HEATING							"...  "</front>
<front id="languageH-991">	#define MSG_HEATING_COMPLETE				".    "</front>
<front id="languageH-992">	#define MSG_BED_HEATING						" ...     "</front>
<front id="languageH-993">	#define MSG_BED_DONE						" .        "</front>
<front id="languageH-994">	#define MSG_M115_REPORT						"FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-995">	#define MSG_COUNT_X							" Count X:"</front>
<front id="languageH-996">	#define MSG_ERR_KILLED						" .  kill() !!"</front>
<front id="languageH-997">	#define MSG_ERR_STOPPED						" , .     M999  !. ( .  )"</front>
<front id="languageH-998">	#define MSG_RESEND							":"</front>
<front id="languageH-999">	#define MSG_UNKNOWN_COMMAND					" :\""</front>
<front id="languageH-1000">	#define MSG_ACTIVE_EXTRUDER					" : "</front>
<front id="languageH-1001">	#define MSG_INVALID_EXTRUDER				" "</front>
<front id="languageH-1002">	#define MSG_X_MIN							"x_min:"</front>
<front id="languageH-1003">	#define MSG_X_MAX							"x_max:"</front>
<front id="languageH-1004">	#define MSG_Y_MIN							"y_min:"</front>
<front id="languageH-1005">	#define MSG_Y_MAX							"y_max:"</front>
<front id="languageH-1006">	#define MSG_Z_MIN							"z_min:"</front>
<front id="languageH-1007">	#define MSG_Z_MAX							"z_max:"</front>
<front id="languageH-1008">	#define MSG_M119_REPORT						" "</front>
<front id="languageH-1009">	#define MSG_ENDSTOP_HIT						" "</front>
<front id="languageH-1010">	#define MSG_ENDSTOP_OPEN					" "</front>
<front id="languageH-1011">	#define MSG_HOTEND_OFFSET					"Hotend offsets:"</front>
<front id="languageH-1012">	#define MSG_SD_CANT_OPEN_SUBDIR				"  "</front>
<front id="languageH-1013">	#define MSG_SD_INIT_FAIL					"  SD"</front>
<front id="languageH-1014">	#define MSG_SD_VOL_INIT_FAIL				"  "</front>
<front id="languageH-1015">	#define MSG_SD_OPENROOT_FAIL				"   "</front>
<front id="languageH-1016">	#define MSG_SD_CARD_OK						"SD   "</front>
<front id="languageH-1017">	#define MSG_SD_WORKDIR_FAIL					"   "</front>
<front id="languageH-1018">	#define MSG_SD_OPEN_FILE_FAIL				" , : "</front>
<front id="languageH-1019">	#define MSG_SD_FILE_OPENED					" :"</front>
<front id="languageH-1020">	#define MSG_SD_SIZE							" :"</front>
<front id="languageH-1021">	#define MSG_SD_FILE_SELECTED				" "</front>
<front id="languageH-1022">	#define MSG_SD_WRITE_TO_FILE				"  : "</front>
<front id="languageH-1023">	#define MSG_SD_PRINTING_BYTE				"SD  byte "</front>
<front id="languageH-1024">	#define MSG_SD_NOT_PRINTING					" SD "</front>
<front id="languageH-1025">	#define MSG_SD_ERR_WRITE_TO_FILE			"   "</front>
<front id="languageH-1026">	#define MSG_SD_CANT_ENTER_SUBDIR			"   :"</front>
<front id="languageH-1027">	#define MSG_STEPPER_TOO_HIGH				"    : "</front>
<front id="languageH-1028">	#define MSG_ENDSTOPS_HIT					" : "</front>
<front id="languageH-1029">	#define MSG_ERR_COLD_EXTRUDE_STOP			"   "</front>
<front id="languageH-1030">	#define MSG_ERR_LONG_EXTRUDE_STOP			"    "</front>
<front id="languageH-1031"></front>
<front id="languageH-1032">#endif</front>
<front id="languageH-1033"></front>
<front id="languageH-1034"></front>
<front id="languageH-1035">#if LANGUAGE_CHOICE == 7</front>
<front id="languageH-1036"></front>
<front id="languageH-1037">	// LCD Menu Messages</front>
<front id="languageH-1038">	#define WELCOME_MSG MACHINE_NAME " Pronta"</front>
<front id="languageH-1039">	#define MSG_SD_INSERTED          "SD Card inserita"</front>
<front id="languageH-1040">	#define MSG_SD_REMOVED           "SD Card rimossa"</front>
<front id="languageH-1041">	#define MSG_MAIN                 "Menu principale"</front>
<front id="languageH-1042">	#define MSG_AUTOSTART            "Autostart"</front>
<front id="languageH-1043">	#define MSG_DISABLE_STEPPERS     "Disabilita Motori"</front>
<front id="languageH-1044">	#define MSG_AUTO_HOME            "Auto Home"</front>
<front id="languageH-1045">	#define MSG_SET_ORIGIN           "Imposta Origine"</front>
<front id="languageH-1046">	#define MSG_PREHEAT_PLA          "Preriscalda PLA"</front>
<front id="languageH-1047">	#define MSG_PREHEAT_PLA_SETTINGS "Preris. PLA Conf"</front>
<front id="languageH-1048">	#define MSG_PREHEAT_ABS          "Preriscalda ABS"</front>
<front id="languageH-1049">	#define MSG_PREHEAT_ABS_SETTINGS "Preris. ABS Conf"</front>
<front id="languageH-1050">	#define MSG_COOLDOWN             "Raffredda"</front>
<front id="languageH-1051">	#define MSG_SWITCH_PS_ON         "Switch Power On"</front>
<front id="languageH-1052">	#define MSG_SWITCH_PS_OFF        "Switch Power Off"</front>
<front id="languageH-1053">	#define MSG_EXTRUDE              "Estrudi"</front>
<front id="languageH-1054">	#define MSG_RETRACT              "Ritrai"</front>
<front id="languageH-1055">	#define MSG_MOVE_AXIS            "Muovi Asse"</front>
<front id="languageH-1056">	#define MSG_SPEED                "Velcit"</front>
<front id="languageH-1057">	#define MSG_NOZZLE               "Ugello"</front>
<front id="languageH-1058">	#define MSG_NOZZLE1              "Ugello2"</front>
<front id="languageH-1059">	#define MSG_NOZZLE2              "Ugello3"</front>
<front id="languageH-1060">	#define MSG_BED                  "Piatto"</front>
<front id="languageH-1061">	#define MSG_FAN_SPEED            "Ventola"</front>
<front id="languageH-1062">	#define MSG_FLOW                 "Flusso"</front>
<front id="languageH-1063">	#define MSG_CONTROL              "Controllo"</front>
<front id="languageH-1064">	#define MSG_MIN                  " \002 Min:"</front>
<front id="languageH-1065">	#define MSG_MAX                  " \002 Max:"</front>
<front id="languageH-1066">	#define MSG_FACTOR               " \002 Fact:"</front>
<front id="languageH-1067">	#define MSG_AUTOTEMP             "Autotemp"</front>
<front id="languageH-1068">	#define MSG_ON                   "On "</front>
<front id="languageH-1069">	#define MSG_OFF                  "Off"</front>
<front id="languageH-1070">	#define MSG_PID_P                "PID-P"</front>
<front id="languageH-1071">	#define MSG_PID_I                "PID-I"</front>
<front id="languageH-1072">	#define MSG_PID_D                "PID-D"</front>
<front id="languageH-1073">	#define MSG_PID_C                "PID-C"</front>
<front id="languageH-1074">	#define MSG_ACC                  "Accel"</front>
<front id="languageH-1075">	#define MSG_VXY_JERK             "Vxy-jerk"</front>
<front id="languageH-1076">	#define MSG_VZ_JERK              "Vz-jerk"</front>
<front id="languageH-1077">	#define MSG_VE_JERK              "Ve-jerk"</front>
<front id="languageH-1078">	#define MSG_VMAX                 "Vmax"</front>
<front id="languageH-1079">	#define MSG_X                    "x"</front>
<front id="languageH-1080">	#define MSG_Y                    "y"</front>
<front id="languageH-1081">	#define MSG_Z                    "z"</front>
<front id="languageH-1082">	#define MSG_E                    "e"</front>
<front id="languageH-1083">	#define MSG_VMIN                 "Vmin"</front>
<front id="languageH-1084">	#define MSG_VTRAV_MIN            "VTrav min"</front>
<front id="languageH-1085">	#define MSG_AMAX                 "Amax"</front>
<front id="languageH-1086">	#define MSG_A_RETRACT            "A-retract"</front>
<front id="languageH-1087">	#define MSG_XSTEPS               "Xpassi/mm"</front>
<front id="languageH-1088">	#define MSG_YSTEPS               "Ypassi/mm"</front>
<front id="languageH-1089">	#define MSG_ZSTEPS               "Zpassi/mm"</front>
<front id="languageH-1090">	#define MSG_ESTEPS               "Epassi/mm"</front>
<front id="languageH-1091">	#define MSG_RECTRACT             "Ritrai"</front>
<front id="languageH-1092">	#define MSG_TEMPERATURE          "Temperatura"</front>
<front id="languageH-1093">	#define MSG_MOTION               "Movimento"</front>
<front id="languageH-1094">	#define MSG_CONTRAST "LCD contrast"</front>
<front id="languageH-1095">	#define MSG_STORE_EPROM          "Salva in EEPROM"</front>
<front id="languageH-1096">	#define MSG_LOAD_EPROM           "Carica da EEPROM"</front>
<front id="languageH-1097">	#define MSG_RESTORE_FAILSAFE     "Impostaz. default"</front>
<front id="languageH-1098">	#define MSG_REFRESH              "Aggiorna"</front>
<front id="languageH-1099">	#define MSG_WATCH                "Guarda"</front>
<front id="languageH-1100">	#define MSG_PREPARE              "Prepara"</front>
<front id="languageH-1101">	#define MSG_TUNE                 "Adatta"</front>
<front id="languageH-1102">	#define MSG_PAUSE_PRINT          "Pausa"</front>
<front id="languageH-1103">	#define MSG_RESUME_PRINT         "Riprendi Stampa"</front>
<front id="languageH-1104">	#define MSG_STOP_PRINT           "Arresta Stampa"</front>
<front id="languageH-1105">	#define MSG_CARD_MENU            "SD Card Menu"</front>
<front id="languageH-1106">	#define MSG_NO_CARD              "No SD Card"</front>
<front id="languageH-1107">	#define MSG_DWELL                "Sospensione..."</front>
<front id="languageH-1108">	#define MSG_USERWAIT             "Attendi Utente..."</front>
<front id="languageH-1109">	#define MSG_RESUMING             "Riprendi Stampa"</front>
<front id="languageH-1110">	#define MSG_NO_MOVE              "Nessun Movimento."</front>
<front id="languageH-1111">	#define MSG_KILLED               "UCCISO. "</front>
<front id="languageH-1112">	#define MSG_STOPPED              "ARRESTATO. "</front>
<front id="languageH-1113">	#define MSG_CONTROL_RETRACT      "Ritrai mm"</front>
<front id="languageH-1114">	#define MSG_CONTROL_RETRACTF     "Ritrai  F"</front>
<front id="languageH-1115">	#define MSG_CONTROL_RETRACT_ZLIFT "Salta mm"</front>
<front id="languageH-1116">	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"</front>
<front id="languageH-1117">	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"</front>
<front id="languageH-1118">	#define MSG_AUTORETRACT          "AutoArretramento"</front>
<front id="languageH-1119">	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Qualcosa non va in MenuStructure."</front>
<front id="languageH-1120">	#define MSG_FILAMENTCHANGE       "Cambia filamento"</front>
<front id="languageH-1121">	#define MSG_INIT_SDCARD          "Iniz. SD-Card"</front>
<front id="languageH-1122">	#define MSG_CNG_SDCARD           "Cambia SD-Card"</front>
<front id="languageH-1123"></front>
<front id="languageH-1124">	// Serial Console Messages</front>
<front id="languageH-1125"></front>
<front id="languageH-1126">	#define MSG_Enqueing             "accodamento \""</front>
<front id="languageH-1127">	#define MSG_POWERUP              "Accensione"</front>
<front id="languageH-1128">	#define MSG_EXTERNAL_RESET       " Reset Esterno"</front>
<front id="languageH-1129">	#define MSG_BROWNOUT_RESET       " Brown out Reset"</front>
<front id="languageH-1130">	#define MSG_WATCHDOG_RESET       " Watchdog Reset"</front>
<front id="languageH-1131">	#define MSG_SOFTWARE_RESET       " Software Reset"</front>
<front id="languageH-1132">	#define MSG_MARLIN               "Marlin "</front>
<front id="languageH-1133">	#define MSG_AUTHOR               " | Autore: "</front>
<front id="languageH-1134">	#define MSG_CONFIGURATION_VER    " Ultimo Aggiornamento: "</front>
<front id="languageH-1135">	#define MSG_FREE_MEMORY          " Memoria Libera: "</front>
<front id="languageH-1136">	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "</front>
<front id="languageH-1137">	#define MSG_OK                   "ok"</front>
<front id="languageH-1138">	#define MSG_FILE_SAVED           "File Salvato."</front>
<front id="languageH-1139">	#define MSG_ERR_LINE_NO          "Il Numero della Linea non corrisponde al Numero dell'Ultima Linea+1, Ultima Linea: "</front>
<front id="languageH-1140">	#define MSG_ERR_CHECKSUM_MISMATCH "checksum non corrispondente, Ultima Linea: "</front>
<front id="languageH-1141">	#define MSG_ERR_NO_CHECKSUM      "Nessun Checksum con Numero di Linea, Ultima Linea: "</front>
<front id="languageH-1142">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nessun Numero di Linea con Checksum, Ultima Linea: "</front>
<front id="languageH-1143">	#define MSG_FILE_PRINTED         "File stampato"</front>
<front id="languageH-1144">	#define MSG_BEGIN_FILE_LIST      "Inizio Lista File"</front>
<front id="languageH-1145">	#define MSG_END_FILE_LIST        "Fine Lista File"</front>
<front id="languageH-1146">	#define MSG_M104_INVALID_EXTRUDER "M104 Estrusore non valido "</front>
<front id="languageH-1147">	#define MSG_M105_INVALID_EXTRUDER "M105 Estrusore non valido "</front>
<front id="languageH-1148">	#define MSG_M218_INVALID_EXTRUDER "M218 Estrusore non valido "</front>
<front id="languageH-1149">	#define MSG_ERR_NO_THERMISTORS   "Nessun Termistore - nessuna temperatura"</front>
<front id="languageH-1150">	#define MSG_M109_INVALID_EXTRUDER "M109 Estrusore non valido "</front>
<front id="languageH-1151">	#define MSG_HEATING              "Riscaldamento..."</front>
<front id="languageH-1152">	#define MSG_HEATING_COMPLETE     "Stampante Calda."</front>
<front id="languageH-1153">	#define MSG_BED_HEATING          "Riscaldamento Piatto."</front>
<front id="languageH-1154">	#define MSG_BED_DONE             "Piatto Pronto."</front>
<front id="languageH-1155">	#define MSG_M115_REPORT          "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-1156">	#define MSG_COUNT_X              " Calcola X: "</front>
<front id="languageH-1157">	#define MSG_ERR_KILLED           "Stampante Calda. kill() chiamata !!"</front>
<front id="languageH-1158">	#define MSG_ERR_STOPPED          "Stampante fermata a causa di errori. Risolvi l'errore e usa M999 per ripartire!. (Reset temperatura. Impostala prima di ripartire)"</front>
<front id="languageH-1159">	#define MSG_RESEND               "Reinviato:"</front>
<front id="languageH-1160">	#define MSG_UNKNOWN_COMMAND      "Comando sconosciuto: \""</front>
<front id="languageH-1161">	#define MSG_ACTIVE_EXTRUDER      "Attiva Estrusore: "</front>
<front id="languageH-1162">	#define MSG_INVALID_EXTRUDER     "Estrusore non valido"</front>
<front id="languageH-1163">	#define MSG_X_MIN                "x_min: "</front>
<front id="languageH-1164">	#define MSG_X_MAX                "x_max: "</front>
<front id="languageH-1165">	#define MSG_Y_MIN                "y_min: "</front>
<front id="languageH-1166">	#define MSG_Y_MAX                "y_max: "</front>
<front id="languageH-1167">	#define MSG_Z_MIN                "z_min: "</front>
<front id="languageH-1168">	#define MSG_Z_MAX                "z_max: "</front>
<front id="languageH-1169">	#define MSG_M119_REPORT          "Segnalazione stato degli endstop"</front>
<front id="languageH-1170">	#define MSG_ENDSTOP_HIT          "INNESCATO"</front>
<front id="languageH-1171">	#define MSG_ENDSTOP_OPEN         "aperto"</front>
<front id="languageH-1172">	#define MSG_HOTEND_OFFSET        "Hotend offsets:"</front>
<front id="languageH-1173"></front>
<front id="languageH-1174">	#define MSG_SD_CANT_OPEN_SUBDIR  "Impossibile aprire sottocartella"</front>
<front id="languageH-1175">	#define MSG_SD_INIT_FAIL         "Fallita Inizializzazione SD"</front>
<front id="languageH-1176">	#define MSG_SD_VOL_INIT_FAIL     "Fallito il montaggio del Volume"</front>
<front id="languageH-1177">	#define MSG_SD_OPENROOT_FAIL     "Fallita l'apertura Cartella Principale"</front>
<front id="languageH-1178">	#define MSG_SD_CARD_OK           "SD card ok"</front>
<front id="languageH-1179">	#define MSG_SD_WORKDIR_FAIL      "Fallita l'apertura Cartella di Lavoro"</front>
<front id="languageH-1180">	#define MSG_SD_OPEN_FILE_FAIL    "Fallita l'apertura del File: "</front>
<front id="languageH-1181">	#define MSG_SD_FILE_OPENED       "File aperto: "</front>
<front id="languageH-1182">	#define MSG_SD_SIZE              " Dimensione: "</front>
<front id="languageH-1183">	#define MSG_SD_FILE_SELECTED     "File selezionato"</front>
<front id="languageH-1184">	#define MSG_SD_WRITE_TO_FILE     "Scrittura su file: "</front>
<front id="languageH-1185">	#define MSG_SD_PRINTING_BYTE     "Si sta scrivendo il byte su SD "</front>
<front id="languageH-1186">	#define MSG_SD_NOT_PRINTING      "Non si sta scrivendo su SD"</front>
<front id="languageH-1187">	#define MSG_SD_ERR_WRITE_TO_FILE "Errore nella scrittura su file"</front>
<front id="languageH-1188">	#define MSG_SD_CANT_ENTER_SUBDIR "Impossibile entrare nella sottocartella: "</front>
<front id="languageH-1189"></front>
<front id="languageH-1190">	#define MSG_STEPPER_TOO_HIGH     "Steprate troppo alto: "</front>
<front id="languageH-1191">	#define MSG_ENDSTOPS_HIT         "Raggiunto il fondo carrello: "</front>
<front id="languageH-1192">	#define MSG_ERR_COLD_EXTRUDE_STOP " prevenuta estrusione fredda"</front>
<front id="languageH-1193">	#define MSG_ERR_LONG_EXTRUDE_STOP " prevenuta estrusione troppo lunga"</front>
<front id="languageH-1194"></front>
<front id="languageH-1195">#endif</front>
<front id="languageH-1196"></front>
<front id="languageH-1197"></front>
<front id="languageH-1198">#if LANGUAGE_CHOICE == 8</front>
<front id="languageH-1199"></front>
<front id="languageH-1200">// LCD Menu Messages</front>
<front id="languageH-1201">	#define WELCOME_MSG MACHINE_NAME " Pronta."</front>
<front id="languageH-1202">	#define MSG_SD_INSERTED "Cartao SD inserido"</front>
<front id="languageH-1203">	#define MSG_SD_REMOVED "Cartao SD removido"</front>
<front id="languageH-1204">	#define MSG_MAIN " Menu Principal \003"</front>
<front id="languageH-1205">	#define MSG_AUTOSTART " Autostart"</front>
<front id="languageH-1206">	#define MSG_DISABLE_STEPPERS " Apagar Motores"</front>
<front id="languageH-1207">	#define MSG_AUTO_HOME " Ir para Origen"</front>
<front id="languageH-1208">	#define MSG_SET_ORIGIN " Estabelecer Origen"</front>
<front id="languageH-1209">	#define MSG_PREHEAT_PLA " pre-aquecer PLA"</front>
<front id="languageH-1210">	#define MSG_PREHEAT_PLA_SETTINGS " pre-aquecer PLA Setting"</front>
<front id="languageH-1211">	#define MSG_PREHEAT_ABS " pre-aquecer ABS"</front>
<front id="languageH-1212">	#define MSG_PREHEAT_ABS_SETTINGS " pre-aquecer ABS Setting"</front>
<front id="languageH-1213">	#define MSG_COOLDOWN " Esfriar"</front>
<front id="languageH-1214">	#define MSG_SWITCH_PS_ON "Switch Power On"</front>
<front id="languageH-1215">	#define MSG_SWITCH_PS_OFF "Switch Power Off"</front>
<front id="languageH-1216">	#define MSG_EXTRUDE " Extrudar"</front>
<front id="languageH-1217">	#define MSG_RETRACT " Retrair"</front>
<front id="languageH-1218">	#define MSG_PREHEAT_PLA " pre-aquecer PLA"</front>
<front id="languageH-1219">	#define MSG_PREHEAT_ABS " pre-aquecer ABS"</front>
<front id="languageH-1220">	#define MSG_MOVE_AXIS " Mover eixo      \x7E"</front>
<front id="languageH-1221">	#define MSG_SPEED " Velocidade:"</front>
<front id="languageH-1222">	#define MSG_NOZZLE " \002Nozzle:"</front>
<front id="languageH-1223">	#define MSG_NOZZLE1 " \002Nozzle2:"</front>
<front id="languageH-1224">	#define MSG_NOZZLE2 " \002Nozzle3:"</front>
<front id="languageH-1225">	#define MSG_BED " \002Base:"</front>
<front id="languageH-1226">	#define MSG_FAN_SPEED " Velocidade Ventoinha:"</front>
<front id="languageH-1227">	#define MSG_FLOW " Fluxo:"</front>
<front id="languageH-1228">	#define MSG_CONTROL " Controle \003"</front>
<front id="languageH-1229">	#define MSG_MIN " \002 Min:"</front>
<front id="languageH-1230">	#define MSG_MAX " \002 Max:"</front>
<front id="languageH-1231">	#define MSG_FACTOR " \002 Fact:"</front>
<front id="languageH-1232">	#define MSG_AUTOTEMP " Autotemp:"</front>
<front id="languageH-1233">	#define MSG_ON "On "</front>
<front id="languageH-1234">	#define MSG_OFF "Off"</front>
<front id="languageH-1235">	#define MSG_PID_P " PID-P: "</front>
<front id="languageH-1236">	#define MSG_PID_I " PID-I: "</front>
<front id="languageH-1237">	#define MSG_PID_D " PID-D: "</front>
<front id="languageH-1238">	#define MSG_PID_C " PID-C: "</front>
<front id="languageH-1239">	#define MSG_ACC  " Acc:"</front>
<front id="languageH-1240">	#define MSG_VXY_JERK " Vxy-jerk: "</front>
<front id="languageH-1241">	#define MSG_VZ_JERK "Vz-jerk"</front>
<front id="languageH-1242">	#define MSG_VE_JERK "Ve-jerk"</front>
<front id="languageH-1243">	#define MSG_VMAX " Vmax "</front>
<front id="languageH-1244">	#define MSG_X "x:"</front>
<front id="languageH-1245">	#define MSG_Y "y:"</front>
<front id="languageH-1246">	#define MSG_Z "z:"</front>
<front id="languageH-1247">	#define MSG_E "e:"</front>
<front id="languageH-1248">	#define MSG_VMIN " Vmin:"</front>
<front id="languageH-1249">	#define MSG_VTRAV_MIN " VTrav min:"</front>
<front id="languageH-1250">	#define MSG_AMAX " Amax "</front>
<front id="languageH-1251">	#define MSG_A_RETRACT " A-retract:"</front>
<front id="languageH-1252">	#define MSG_XSTEPS " Xpasso/mm:"</front>
<front id="languageH-1253">	#define MSG_YSTEPS " Ypasso/mm:"</front>
<front id="languageH-1254">	#define MSG_ZSTEPS " Zpasso/mm:"</front>
<front id="languageH-1255">	#define MSG_ESTEPS " Epasso/mm:"</front>
<front id="languageH-1256">	#define MSG_MAIN_WIDE " Menu Principal  \003"</front>
<front id="languageH-1257">	#define MSG_RECTRACT "Retrair"</front>
<front id="languageH-1258">	#define MSG_TEMPERATURE "Temperatura"</front>
<front id="languageH-1259">	#define MSG_MOTION "Movimento"</front>
<front id="languageH-1260">	#define MSG_STORE_EPROM " Guardar memoria"</front>
<front id="languageH-1261">	#define MSG_LOAD_EPROM " Carregar memoria"</front>
<front id="languageH-1262">	#define MSG_RESTORE_FAILSAFE " Rest. de emergencia"</front>
<front id="languageH-1263">	#define MSG_REFRESH "\004Recarregar"</front>
<front id="languageH-1264">	#define MSG_WATCH " Monitorar   \003"</front>
<front id="languageH-1265">	#define MSG_PREPARE " Preparar \x7E"</front>
<front id="languageH-1266">	#define MSG_PREPARE_ALT " Preparar \003"</front>
<front id="languageH-1267">	#define MSG_CONTROL_ARROW " Controle \x7E"</front>
<front id="languageH-1268">	#define MSG_RETRACT_ARROW " Retrair \x7E"</front>
<front id="languageH-1269">	#define MSG_TUNE " Tune    \x7E"</front>
<front id="languageH-1270">	#define MSG_PAUSE_PRINT " Pausar Impressao \x7E"</front>
<front id="languageH-1271">	#define MSG_RESUME_PRINT " Resumir Impressao \x7E"</front>
<front id="languageH-1272">	#define MSG_STOP_PRINT " Parar Impressao   \x7E"</front>
<front id="languageH-1273">	#define MSG_CARD_MENU " Menu cartao SD    \x7E"</front>
<front id="languageH-1274">	#define MSG_NO_CARD " Sem cartao SD"</front>
<front id="languageH-1275">	#define MSG_DWELL "Repouso..."</front>
<front id="languageH-1276">	#define MSG_USERWAIT "Esperando Ordem..."</front>
<front id="languageH-1277">	#define MSG_RESUMING "Resuming print"</front>
<front id="languageH-1278">	#define MSG_NO_MOVE "Sem movimento."</front>
<front id="languageH-1279">	#define MSG_PART_RELEASE "Lancamento Parcial"</front>
<front id="languageH-1280">	#define MSG_KILLED "PARADA DE EMERGENCIA. "</front>
<front id="languageH-1281">	#define MSG_STOPPED "PARADA. "</front>
<front id="languageH-1282">	#define MSG_STEPPER_RELEASED "Lancado."</front>
<front id="languageH-1283">	#define MSG_CONTROL_RETRACT  " Retrair mm:"</front>
<front id="languageH-1284">	#define MSG_CONTROL_RETRACTF " Retrair  F:"</front>
<front id="languageH-1285">	#define MSG_CONTROL_RETRACT_ZLIFT " Levantar mm:"</front>
<front id="languageH-1286">	#define MSG_CONTROL_RETRACT_RECOVER " DesRet +mm:"</front>
<front id="languageH-1287">	#define MSG_CONTROL_RETRACT_RECOVERF " DesRet  F:"</front>
<front id="languageH-1288">	#define MSG_AUTORETRACT " AutoRetr.:"</front>
<front id="languageH-1289">	#define MSG_SERIAL_ERROR_MENU_STRUCTURE "Algo esta errado na estrutura do Menu."</front>
<front id="languageH-1290">	#define MSG_FILAMENTCHANGE "Change filament"</front>
<front id="languageH-1291">	#define MSG_INIT_SDCARD "Init. SD-Card"	</front>
<front id="languageH-1292">	#define MSG_CNG_SDCARD "Change SD-Card"</front>
<front id="languageH-1293"></front>
<front id="languageH-1294">// Serial Console Messages</front>
<front id="languageH-1295"></front>
<front id="languageH-1296">	#define MSG_Enqueing "enqueing \""</front>
<front id="languageH-1297">	#define MSG_POWERUP "PowerUp"</front>
<front id="languageH-1298">	#define MSG_EXTERNAL_RESET " Reset Externo"</front>
<front id="languageH-1299">	#define MSG_BROWNOUT_RESET " Reset por voltagem incorreta"</front>
<front id="languageH-1300">	#define MSG_WATCHDOG_RESET " Reset por Bloqueio"</front>
<front id="languageH-1301">	#define MSG_SOFTWARE_RESET " Reset por Software"</front>
<front id="languageH-1302">	#define MSG_MARLIN "Marlin "</front>
<front id="languageH-1303">	#define MSG_AUTHOR " | Author: "</front>
<front id="languageH-1304">	#define MSG_CONFIGURATION_VER " Ultima atualizacao: "</front>
<front id="languageH-1305">	#define MSG_FREE_MEMORY " memoria Livre: "</front>
<front id="languageH-1306">	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "</front>
<front id="languageH-1307">	#define MSG_OK "ok"</front>
<front id="languageH-1308">	#define MSG_FILE_SAVED "Guardado."</front>
<front id="languageH-1309">	#define MSG_ERR_LINE_NO "O Numero da linha Nao e igual ao ultimo Numero da linha+1, Ultima linha:"</front>
<front id="languageH-1310">	#define MSG_ERR_CHECKSUM_MISMATCH "O checksum Nao coincide, Ultima linha:"</front>
<front id="languageH-1311">	#define MSG_ERR_NO_CHECKSUM "Nao foi possivel encontrar o checksum com o numero da linha, Ultima linha :"</front>
<front id="languageH-1312">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Nao ha o numero da linha com o checksum, Ultima linha:"</front>
<front id="languageH-1313">	#define MSG_FILE_PRINTED "Impressao terminada"</front>
<front id="languageH-1314">	#define MSG_BEGIN_FILE_LIST "Comeo da lista de arquivos"</front>
<front id="languageH-1315">	#define MSG_END_FILE_LIST "Fim da lista de arquivos"</front>
<front id="languageH-1316">	#define MSG_M104_INVALID_EXTRUDER "M104 Extrusor invlido "</front>
<front id="languageH-1317">	#define MSG_M105_INVALID_EXTRUDER "M105 Extrusor invlido "</front>
<front id="languageH-1318">	#define MSG_M218_INVALID_EXTRUDER "M218 Extrusor invlido "</front>
<front id="languageH-1319">	#define MSG_ERR_NO_THERMISTORS "Nao ha termistor - no temp"</front>
<front id="languageH-1320">	#define MSG_M109_INVALID_EXTRUDER "M109 Extrusor invlido "</front>
<front id="languageH-1321">	#define MSG_HEATING "Aquecendo..."</front>
<front id="languageH-1322">	#define MSG_HEATING_COMPLETE "Aquecido."</front>
<front id="languageH-1323">	#define MSG_BED_HEATING "Aquecendo a Base."</front>
<front id="languageH-1324">	#define MSG_BED_DONE "Base quente."</front>
<front id="languageH-1325">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-1326">	#define MSG_COUNT_X " Conta X:"</front>
<front id="languageH-1327">	#define MSG_ERR_KILLED "Impressora parada com kill() !!"</front>
<front id="languageH-1328">	#define MSG_ERR_STOPPED "Impressora parada por erros. Coserte o erro e use M999 para recomear!. (Temperatura reiniciada. Ajuste antes de recomear)"</front>
<front id="languageH-1329">	#define MSG_RESEND "Reenviar:"</front>
<front id="languageH-1330">	#define MSG_UNKNOWN_COMMAND "Comando desconhecido:\""</front>
<front id="languageH-1331">	#define MSG_ACTIVE_EXTRUDER "Extrusor ativo: "</front>
<front id="languageH-1332">	#define MSG_INVALID_EXTRUDER "Extrusor invalido"</front>
<front id="languageH-1333">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-1334">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-1335">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-1336">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-1337">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-1338">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-1339">	#define MSG_M119_REPORT "Relatando estado do ponto final"</front>
<front id="languageH-1340">	#define MSG_ENDSTOP_HIT "PULSADO"</front>
<front id="languageH-1341">	#define MSG_ENDSTOP_OPEN "Aberto"</front>
<front id="languageH-1342">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-1343"></front>
<front id="languageH-1344">	#define MSG_SD_CANT_OPEN_SUBDIR "Nao pode abrir sub diretorio"</front>
<front id="languageH-1345">	#define MSG_SD_INIT_FAIL "Falha ao iniciar SD"</front>
<front id="languageH-1346">	#define MSG_SD_VOL_INIT_FAIL "Falha ao montar volume"</front>
<front id="languageH-1347">	#define MSG_SD_OPENROOT_FAIL "Falha ao abrir diretorio raiz"</front>
<front id="languageH-1348">	#define MSG_SD_CARD_OK "cartao SD ok"</front>
<front id="languageH-1349">	#define MSG_SD_WORKDIR_FAIL "Falha ao abrir diretorio de trabalho"</front>
<front id="languageH-1350">	#define MSG_SD_OPEN_FILE_FAIL "Erro ao abrir, Arquivo: "</front>
<front id="languageH-1351">	#define MSG_SD_FILE_OPENED "Arquivo aberto:"</front>
<front id="languageH-1352">	#define MSG_SD_SIZE " Size:"</front>
<front id="languageH-1353">	#define MSG_SD_FILE_SELECTED "Arquivo selecionado"</front>
<front id="languageH-1354">	#define MSG_SD_WRITE_TO_FILE "Escrevendo no arquivo: "</front>
<front id="languageH-1355">	#define MSG_SD_PRINTING_BYTE "SD imprimindo o byte "</front>
<front id="languageH-1356">	#define MSG_SD_NOT_PRINTING "Nao esta se imprimindo com o SD"</front>
<front id="languageH-1357">	#define MSG_SD_ERR_WRITE_TO_FILE "Erro ao escrever no arquivo"</front>
<front id="languageH-1358">	#define MSG_SD_CANT_ENTER_SUBDIR "Nao pode abrir o sub diretorio:"</front>
<front id="languageH-1359"></front>
<front id="languageH-1360">	#define MSG_STEPPER_TOO_HIGH "Steprate muito alto : "</front>
<front id="languageH-1361">	#define MSG_ENDSTOPS_HIT "O ponto final foi tocado: "</front>
<front id="languageH-1362">	#define MSG_ERR_COLD_EXTRUDE_STOP " Extrusao a frio evitada"</front>
<front id="languageH-1363">	#define MSG_ERR_LONG_EXTRUDE_STOP " Extrusao muito larga evitada"</front>
<front id="languageH-1364"></front>
<front id="languageH-1365"></front>
<front id="languageH-1366">#endif</front>
<front id="languageH-1367"></front>
<front id="languageH-1368"></front>
<front id="languageH-1369"></front>
<front id="languageH-1370">#if LANGUAGE_CHOICE == 9</front>
<front id="languageH-1371"></front>
<front id="languageH-1372">// Finnish</front>
<front id="languageH-1373"></front>
<front id="languageH-1374">// LCD Menu Messages</front>
<front id="languageH-1375">	#define WELCOME_MSG MACHINE_NAME " valmis"</front>
<front id="languageH-1376">	#define MSG_SD_INSERTED "Kortti asetettu"</front>
<front id="languageH-1377">	#define MSG_SD_REMOVED "Kortti poistettu"</front>
<front id="languageH-1378">	#define MSG_MAIN "Palaa"</front>
<front id="languageH-1379">	#define MSG_AUTOSTART "Automaatti"</front>
<front id="languageH-1380">	#define MSG_DISABLE_STEPPERS "Vapauta moottorit"</front>
<front id="languageH-1381">	#define MSG_AUTO_HOME "Aja referenssiin"</front>
<front id="languageH-1382">	#define MSG_SET_ORIGIN "Aseta origo"</front>
<front id="languageH-1383">	#define MSG_PREHEAT_PLA "Esilammita PLA"</front>
<front id="languageH-1384">	#define MSG_PREHEAT_PLA_SETTINGS "Esilammita PLA konf"</front>
<front id="languageH-1385">	#define MSG_PREHEAT_ABS "Esilammita ABS"</front>
<front id="languageH-1386">	#define MSG_PREHEAT_ABS_SETTINGS "Esilammita ABS konf"</front>
<front id="languageH-1387">	#define MSG_COOLDOWN "Jaahdyta"</front>
<front id="languageH-1388">	#define MSG_SWITCH_PS_ON "Switch Power On"</front>
<front id="languageH-1389">	#define MSG_SWITCH_PS_OFF "Switch Power Off"</front>
<front id="languageH-1390">	#define MSG_EXTRUDE "Pursota"</front>
<front id="languageH-1391">	#define MSG_RETRACT "Veda takaisin"</front>
<front id="languageH-1392">	#define MSG_MOVE_AXIS "Liikuta akseleita"</front>
<front id="languageH-1393">	#define MSG_SPEED "Nopeus"</front>
<front id="languageH-1394">	#define MSG_NOZZLE "Suutin"</front>
<front id="languageH-1395">	#define MSG_NOZZLE1 "Suutin2"</front>
<front id="languageH-1396">	#define MSG_NOZZLE2 "Suutin3"</front>
<front id="languageH-1397">	#define MSG_BED "Alusta"</front>
<front id="languageH-1398">	#define MSG_FAN_SPEED "Tuul. nopeus"</front>
<front id="languageH-1399">	#define MSG_FLOW "Virtaus"</front>
<front id="languageH-1400">	#define MSG_CONTROL "Kontrolli"</front>
<front id="languageH-1401">	#define MSG_MIN " \002 Min"</front>
<front id="languageH-1402">	#define MSG_MAX " \002 Max"</front>
<front id="languageH-1403">	#define MSG_FACTOR " \002 Kerr"</front>
<front id="languageH-1404">	#define MSG_AUTOTEMP "Autotemp"</front>
<front id="languageH-1405">	#define MSG_ON "On "</front>
<front id="languageH-1406">	#define MSG_OFF "Off"</front>
<front id="languageH-1407">	#define MSG_PID_P "PID-P"</front>
<front id="languageH-1408">	#define MSG_PID_I "PID-I"</front>
<front id="languageH-1409">	#define MSG_PID_D "PID-D"</front>
<front id="languageH-1410">	#define MSG_PID_C "PID-C"</front>
<front id="languageH-1411">	#define MSG_ACC  "Kiihtyv"</front>
<front id="languageH-1412">	#define MSG_VXY_JERK "Vxy-jerk"</front>
<front id="languageH-1413">	#define MSG_VZ_JERK "Vz-jerk"</front>
<front id="languageH-1414">	#define MSG_VE_JERK "Ve-jerk"</front>
<front id="languageH-1415">	#define MSG_VMAX "Vmax "</front>
<front id="languageH-1416">	#define MSG_X "x"</front>
<front id="languageH-1417">	#define MSG_Y "y"</front>
<front id="languageH-1418">	#define MSG_Z "z"</front>
<front id="languageH-1419">	#define MSG_E "e"</front>
<front id="languageH-1420">	#define MSG_VMIN "Vmin"</front>
<front id="languageH-1421">	#define MSG_VTRAV_MIN "VLiike min"</front>
<front id="languageH-1422">	#define MSG_AMAX "Amax "</front>
<front id="languageH-1423">	#define MSG_A_RETRACT "A-peruuta"</front>
<front id="languageH-1424">	#define MSG_XSTEPS "Xsteps/mm"</front>
<front id="languageH-1425">	#define MSG_YSTEPS "Ysteps/mm"</front>
<front id="languageH-1426">	#define MSG_ZSTEPS "Zsteps/mm"</front>
<front id="languageH-1427">	#define MSG_ESTEPS "Esteps/mm"</front>
<front id="languageH-1428">	#define MSG_RECTRACT "Veda takaisin"</front>
<front id="languageH-1429">	#define MSG_TEMPERATURE "Lampotila"</front>
<front id="languageH-1430">	#define MSG_MOTION "Liike"</front>
<front id="languageH-1431">	#define MSG_CONTRAST "LCD contrast"</front>
<front id="languageH-1432">	#define MSG_STORE_EPROM "Tallenna muistiin"</front>
<front id="languageH-1433">	#define MSG_LOAD_EPROM "Lataa muistista"</front>
<front id="languageH-1434">	#define MSG_RESTORE_FAILSAFE "Palauta oletus"</front>
<front id="languageH-1435">	#define MSG_REFRESH "Paivita"</front>
<front id="languageH-1436">	#define MSG_WATCH "Seuraa"</front>
<front id="languageH-1437">	#define MSG_PREPARE "Valmistele"</front>
<front id="languageH-1438">	#define MSG_TUNE "Saada"</front>
<front id="languageH-1439">	#define MSG_PAUSE_PRINT "Keskeyta tulostus"</front>
<front id="languageH-1440">	#define MSG_RESUME_PRINT "Jatka tulostusta"</front>
<front id="languageH-1441">	#define MSG_STOP_PRINT "Pysayta tulostus"</front>
<front id="languageH-1442">	#define MSG_CARD_MENU "Korttivalikko"</front>
<front id="languageH-1443">	#define MSG_NO_CARD "Ei korttia"</front>
<front id="languageH-1444">	#define MSG_DWELL "Nukkumassa..."</front>
<front id="languageH-1445">	#define MSG_USERWAIT "Odotetaan valintaa..."</front>
<front id="languageH-1446">	#define MSG_RESUMING "Jatketaan tulostusta"</front>
<front id="languageH-1447">	#define MSG_NO_MOVE "Ei liiketta."</front>
<front id="languageH-1448">	#define MSG_KILLED "KILLED. "</front>
<front id="languageH-1449">	#define MSG_STOPPED "STOPPED. "</front>
<front id="languageH-1450">	#define MSG_CONTROL_RETRACT  "Veda mm"</front>
<front id="languageH-1451">	#define MSG_CONTROL_RETRACTF "Veda F"</front>
<front id="languageH-1452">	#define MSG_CONTROL_RETRACT_ZLIFT "Z mm"</front>
<front id="languageH-1453">	#define MSG_CONTROL_RETRACT_RECOVER "UnRet +mm"</front>
<front id="languageH-1454">	#define MSG_CONTROL_RETRACT_RECOVERF "UnRet  F"</front>
<front id="languageH-1455">	#define MSG_AUTORETRACT "AutoVeto."</front>
<front id="languageH-1456">	#define MSG_FILAMENTCHANGE "Change filament"</front>
<front id="languageH-1457">	#define MSG_INIT_SDCARD "Init. SD-Card"	</front>
<front id="languageH-1458">	#define MSG_CNG_SDCARD "Change SD-Card"</front>
<front id="languageH-1459"></front>
<front id="languageH-1460">// Serial Console Messages</front>
<front id="languageH-1461"></front>
<front id="languageH-1462">	#define MSG_Enqueing "jonoon \""</front>
<front id="languageH-1463">	#define MSG_POWERUP "Kaynnistys"</front>
<front id="languageH-1464">	#define MSG_EXTERNAL_RESET " Ulkoinen Reset"</front>
<front id="languageH-1465">	#define MSG_BROWNOUT_RESET " Alajannite Reset"</front>
<front id="languageH-1466">	#define MSG_WATCHDOG_RESET " Vahtikoira Reset"</front>
<front id="languageH-1467">	#define MSG_SOFTWARE_RESET " Ohjelmisto Reset"</front>
<front id="languageH-1468">	#define MSG_MARLIN "Marlin "</front>
<front id="languageH-1469">	#define MSG_AUTHOR " | Author: "</front>
<front id="languageH-1470">	#define MSG_CONFIGURATION_VER " Paivitetty viimeksi: "</front>
<front id="languageH-1471">	#define MSG_FREE_MEMORY " Vapaata muistia: "</front>
<front id="languageH-1472">	#define MSG_PLANNER_BUFFER_BYTES "  PlannerBufferBytes: "</front>
<front id="languageH-1473">	#define MSG_OK "ok"</front>
<front id="languageH-1474">	#define MSG_FILE_SAVED "Tiedosto tallennettu."</front>
<front id="languageH-1475">	#define MSG_ERR_LINE_NO "Rivinumero ei ole Viimeisin rivi+1, Viimeisin rivi: "</front>
<front id="languageH-1476">	#define MSG_ERR_CHECKSUM_MISMATCH "Tarkistesummassa virhe, Viimeisin rivi: "</front>
<front id="languageH-1477">	#define MSG_ERR_NO_CHECKSUM "Rivilla ei tarkistesummaa, Viimeisin rivi: "</front>
<front id="languageH-1478">	#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "Ei rivinumeroa tarkistesumman kanssa, Viimeisin rivi: "</front>
<front id="languageH-1479">	#define MSG_FILE_PRINTED "Tiedoston tulostus valmis"</front>
<front id="languageH-1480">	#define MSG_BEGIN_FILE_LIST "Tiedostolistauksen alku"</front>
<front id="languageH-1481">	#define MSG_END_FILE_LIST "Tiedostolistauksen loppu"</front>
<front id="languageH-1482">	#define MSG_M104_INVALID_EXTRUDER "M104 Virheellinen suutin "</front>
<front id="languageH-1483">	#define MSG_M105_INVALID_EXTRUDER "M105 Virheellinen suutin "</front>
<front id="languageH-1484">	#define MSG_M218_INVALID_EXTRUDER "M218 Virheellinen suutin "</front>
<front id="languageH-1485">	#define MSG_ERR_NO_THERMISTORS "Ei termistoreja - ei lampotiloja"</front>
<front id="languageH-1486">	#define MSG_M109_INVALID_EXTRUDER "M109 Virheellinen suutin "</front>
<front id="languageH-1487">	#define MSG_HEATING "Lammitan..."</front>
<front id="languageH-1488">	#define MSG_HEATING_COMPLETE "Lammitys valmis."</front>
<front id="languageH-1489">	#define MSG_BED_HEATING "Alusta lampiaa."</front>
<front id="languageH-1490">	#define MSG_BED_DONE "Alusta valmis."</front>
<front id="languageH-1491">	#define MSG_M115_REPORT "FIRMWARE_NAME:Marlin V1; Sprinter/grbl mashup for gen6 FIRMWARE_URL:" FIRMWARE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) "\n"</front>
<front id="languageH-1492">	#define MSG_COUNT_X " Laskuri X: "</front>
<front id="languageH-1493">	#define MSG_ERR_KILLED "Tulostin pysaytetty. kill():ia kutsuttu!"</front>
<front id="languageH-1494">	#define MSG_ERR_STOPPED "Tulostin pysaytetty virheiden vuoksi. Korjaa virheet ja kayta M999 kaynnistaaksesi uudelleen. (Lampotila nollattiin. Aseta lampotila sen jalkeen kun jatkat.)"</front>
<front id="languageH-1495">	#define MSG_RESEND "Uudelleenlahetys: "</front>
<front id="languageH-1496">	#define MSG_UNKNOWN_COMMAND "Tuntematon komento: \""</front>
<front id="languageH-1497">	#define MSG_ACTIVE_EXTRUDER "Aktiivinen suutin: "</front>
<front id="languageH-1498">	#define MSG_INVALID_EXTRUDER "Virheellinen suutin"</front>
<front id="languageH-1499">	#define MSG_X_MIN "x_min: "</front>
<front id="languageH-1500">	#define MSG_X_MAX "x_max: "</front>
<front id="languageH-1501">	#define MSG_Y_MIN "y_min: "</front>
<front id="languageH-1502">	#define MSG_Y_MAX "y_max: "</front>
<front id="languageH-1503">	#define MSG_Z_MIN "z_min: "</front>
<front id="languageH-1504">	#define MSG_Z_MAX "z_max: "</front>
<front id="languageH-1505">	#define MSG_M119_REPORT "Rajakytkimien tilaraportti"</front>
<front id="languageH-1506">	#define MSG_ENDSTOP_HIT "AKTIIVISENA"</front>
<front id="languageH-1507">	#define MSG_ENDSTOP_OPEN "avoinna"</front>
<front id="languageH-1508">	#define MSG_HOTEND_OFFSET "Hotend offsets:"</front>
<front id="languageH-1509"></front>
<front id="languageH-1510">	#define MSG_SD_CANT_OPEN_SUBDIR "Alihakemistoa ei voitu avata"</front>
<front id="languageH-1511">	#define MSG_SD_INIT_FAIL "SD alustus epaonnistui"</front>
<front id="languageH-1512">	#define MSG_SD_VOL_INIT_FAIL "volume.init epaonnistui"</front>
<front id="languageH-1513">	#define MSG_SD_OPENROOT_FAIL "openRoot epaonnistui"</front>
<front id="languageH-1514">	#define MSG_SD_CARD_OK "SD kortti ok"</front>
<front id="languageH-1515">	#define MSG_SD_WORKDIR_FAIL "workDir open epaonnistui"</front>
<front id="languageH-1516">	#define MSG_SD_OPEN_FILE_FAIL "avaus epaonnistui, Tiedosto: "</front>
<front id="languageH-1517">	#define MSG_SD_FILE_OPENED "Tiedosto avattu: "</front>
<front id="languageH-1518">	#define MSG_SD_SIZE " Koko: "</front>
<front id="languageH-1519">	#define MSG_SD_FILE_SELECTED "Tiedosto valittu"</front>
<front id="languageH-1520">	#define MSG_SD_WRITE_TO_FILE "Kirjoitetaan tiedostoon: "</front>
<front id="languageH-1521">	#define MSG_SD_PRINTING_BYTE "SD tulostus byte "</front>
<front id="languageH-1522">	#define MSG_SD_NOT_PRINTING "Ei SD tulostus"</front>
<front id="languageH-1523">	#define MSG_SD_ERR_WRITE_TO_FILE "virhe kirjoitettaessa tiedostoon"</front>
<front id="languageH-1524">	#define MSG_SD_CANT_ENTER_SUBDIR "Alihakemistoon ei voitu siirtya: "</front>
<front id="languageH-1525"></front>
<front id="languageH-1526">	#define MSG_STEPPER_TOO_HIGH "Askellustaajuus liian suuri: "</front>
<front id="languageH-1527">	#define MSG_ENDSTOPS_HIT "paatyrajat aktivoitu: "</front>
<front id="languageH-1528">	#define MSG_ERR_COLD_EXTRUDE_STOP " kylmana pursotus estetty"</front>
<front id="languageH-1529">	#define MSG_ERR_LONG_EXTRUDE_STOP " liian pitka pursotus estetty"</front>
<front id="languageH-1530"></front>
<front id="languageH-1531">#endif</front>
<front id="languageH-1532">#endif // ifndef LANGUAGE_H</front>
 </pre>
<h1>LiquidCrystalRus.cpp</h1>
<pre  class="prettyprint linenums"><front id="LiquidCrystalRusCPP-1">#include "LiquidCrystalRus.h"</front>
<front id="LiquidCrystalRusCPP-2"></front>
<front id="LiquidCrystalRusCPP-3">#include &lt;stdio.h&gt;</front>
<front id="LiquidCrystalRusCPP-4">#include &lt;string.h&gt;</front>
<front id="LiquidCrystalRusCPP-5">#include &lt;inttypes.h&gt;</front>
<front id="LiquidCrystalRusCPP-6">#include &lt;avr/pgmspace.h&gt;</front>
<front id="LiquidCrystalRusCPP-7"></front>
<front id="LiquidCrystalRusCPP-8">#if defined(ARDUINO) && ARDUINO &gt;= 100</front>
<front id="LiquidCrystalRusCPP-9">  #include "Arduino.h"</front>
<front id="LiquidCrystalRusCPP-10">#else</front>
<front id="LiquidCrystalRusCPP-11">  #include "WProgram.h"</front>
<front id="LiquidCrystalRusCPP-12">#endif</front>
<front id="LiquidCrystalRusCPP-13"></front>
<front id="LiquidCrystalRusCPP-14">// it is a russian alphabet translation</front>
<front id="LiquidCrystalRusCPP-15">// except 0401 --&gt; 0xa2 = , 0451 --&gt; 0xb5</front>
<front id="LiquidCrystalRusCPP-16">const PROGMEM uint8_t utf_recode[] = </front>
<front id="LiquidCrystalRusCPP-17">       { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,</front>
<front id="LiquidCrystalRusCPP-18">         0xa8,0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,</front>
<front id="LiquidCrystalRusCPP-19">         0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,</front>
<front id="LiquidCrystalRusCPP-20">         0xbe,0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7</front>
<front id="LiquidCrystalRusCPP-21">        };     </front>
<front id="LiquidCrystalRusCPP-22"></front>
<front id="LiquidCrystalRusCPP-23">// When the display powers up, it is configured as follows:</front>
<front id="LiquidCrystalRusCPP-24">//</front>
<front id="LiquidCrystalRusCPP-25">// 1. Display clear</front>
<front id="LiquidCrystalRusCPP-26">// 2. Function set: </front>
<front id="LiquidCrystalRusCPP-27">//    DL = 1; 8-bit interface data </front>
<front id="LiquidCrystalRusCPP-28">//    N = 0; 1-line display </front>
<front id="LiquidCrystalRusCPP-29">//    F = 0; 5x8 dot character font </front>
<front id="LiquidCrystalRusCPP-30">// 3. Display on/off control: </front>
<front id="LiquidCrystalRusCPP-31">//    D = 0; Display off </front>
<front id="LiquidCrystalRusCPP-32">//    C = 0; Cursor off </front>
<front id="LiquidCrystalRusCPP-33">//    B = 0; Blinking off </front>
<front id="LiquidCrystalRusCPP-34">// 4. Entry mode set: </front>
<front id="LiquidCrystalRusCPP-35">//    I/D = 1; Increment by 1 </front>
<front id="LiquidCrystalRusCPP-36">//    S = 0; No shift </front>
<front id="LiquidCrystalRusCPP-37">//</front>
<front id="LiquidCrystalRusCPP-38">// Note, however, that resetting the Arduino doesn't reset the LCD, so we</front>
<front id="LiquidCrystalRusCPP-39">// can't assume that it's in that state when a sketch starts (and the</front>
<front id="LiquidCrystalRusCPP-40">// LiquidCrystal constructor is called).</front>
<front id="LiquidCrystalRusCPP-41">// </front>
<front id="LiquidCrystalRusCPP-42">// modified 27 Jul 2011</front>
<front id="LiquidCrystalRusCPP-43">// by Ilya V. Danilov http://mk90.ru/</front>
<front id="LiquidCrystalRusCPP-44"></front>
<front id="LiquidCrystalRusCPP-45"></front>
<front id="LiquidCrystalRusCPP-46">LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,</front>
<front id="LiquidCrystalRusCPP-47">			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,</front>
<front id="LiquidCrystalRusCPP-48">			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)</front>
<front id="LiquidCrystalRusCPP-49">{</front>
<front id="LiquidCrystalRusCPP-50">  init(0, rs, rw, enable, d0, d1, d2, d3, d4, d5, d6, d7);</front>
<front id="LiquidCrystalRusCPP-51">}</front>
<front id="LiquidCrystalRusCPP-52"></front>
<front id="LiquidCrystalRusCPP-53">LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t enable,</front>
<front id="LiquidCrystalRusCPP-54">			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,</front>
<front id="LiquidCrystalRusCPP-55">			     uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)</front>
<front id="LiquidCrystalRusCPP-56">{</front>
<front id="LiquidCrystalRusCPP-57">  init(0, rs, 255, enable, d0, d1, d2, d3, d4, d5, d6, d7);</front>
<front id="LiquidCrystalRusCPP-58">}</front>
<front id="LiquidCrystalRusCPP-59"></front>
<front id="LiquidCrystalRusCPP-60">LiquidCrystalRus::LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,</front>
<front id="LiquidCrystalRusCPP-61">			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)</front>
<front id="LiquidCrystalRusCPP-62">{</front>
<front id="LiquidCrystalRusCPP-63">  init(1, rs, rw, enable, d0, d1, d2, d3, 0, 0, 0, 0);</front>
<front id="LiquidCrystalRusCPP-64">}</front>
<front id="LiquidCrystalRusCPP-65"></front>
<front id="LiquidCrystalRusCPP-66">LiquidCrystalRus::LiquidCrystalRus(uint8_t rs,  uint8_t enable,</front>
<front id="LiquidCrystalRusCPP-67">			     uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3)</front>
<front id="LiquidCrystalRusCPP-68">{</front>
<front id="LiquidCrystalRusCPP-69">  init(1, rs, 255, enable, d0, d1, d2, d3, 0, 0, 0, 0);</front>
<front id="LiquidCrystalRusCPP-70">}</front>
<front id="LiquidCrystalRusCPP-71"></front>
<front id="LiquidCrystalRusCPP-72">void LiquidCrystalRus::init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,</front>
<front id="LiquidCrystalRusCPP-73">			 uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,</front>
<front id="LiquidCrystalRusCPP-74">			 uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7)</front>
<front id="LiquidCrystalRusCPP-75">{</front>
<front id="LiquidCrystalRusCPP-76">  _rs_pin = rs;</front>
<front id="LiquidCrystalRusCPP-77">  _rw_pin = rw;</front>
<front id="LiquidCrystalRusCPP-78">  _enable_pin = enable;</front>
<front id="LiquidCrystalRusCPP-79">  </front>
<front id="LiquidCrystalRusCPP-80">  _data_pins[0] = d0;</front>
<front id="LiquidCrystalRusCPP-81">  _data_pins[1] = d1;</front>
<front id="LiquidCrystalRusCPP-82">  _data_pins[2] = d2;</front>
<front id="LiquidCrystalRusCPP-83">  _data_pins[3] = d3; </front>
<front id="LiquidCrystalRusCPP-84">  _data_pins[4] = d4;</front>
<front id="LiquidCrystalRusCPP-85">  _data_pins[5] = d5;</front>
<front id="LiquidCrystalRusCPP-86">  _data_pins[6] = d6;</front>
<front id="LiquidCrystalRusCPP-87">  _data_pins[7] = d7; </front>
<front id="LiquidCrystalRusCPP-88"></front>
<front id="LiquidCrystalRusCPP-89">  pinMode(_rs_pin, OUTPUT);</front>
<front id="LiquidCrystalRusCPP-90">  // we can save 1 pin by not using RW. Indicate by passing 255 instead of pin#</front>
<front id="LiquidCrystalRusCPP-91">  if (_rw_pin != 255) { </front>
<front id="LiquidCrystalRusCPP-92">    pinMode(_rw_pin, OUTPUT);</front>
<front id="LiquidCrystalRusCPP-93">  }</front>
<front id="LiquidCrystalRusCPP-94">  pinMode(_enable_pin, OUTPUT);</front>
<front id="LiquidCrystalRusCPP-95">  </front>
<front id="LiquidCrystalRusCPP-96">  if (fourbitmode)</front>
<front id="LiquidCrystalRusCPP-97">    _displayfunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;</front>
<front id="LiquidCrystalRusCPP-98">  else </front>
<front id="LiquidCrystalRusCPP-99">    _displayfunction = LCD_8BITMODE | LCD_1LINE | LCD_5x8DOTS;</front>
<front id="LiquidCrystalRusCPP-100">  </front>
<front id="LiquidCrystalRusCPP-101">  begin(16, 1);  </front>
<front id="LiquidCrystalRusCPP-102">}</front>
<front id="LiquidCrystalRusCPP-103"></front>
<front id="LiquidCrystalRusCPP-104">void LiquidCrystalRus::begin(uint8_t cols, uint8_t lines, uint8_t dotsize) {</front>
<front id="LiquidCrystalRusCPP-105">  if (lines &gt; 1) {</front>
<front id="LiquidCrystalRusCPP-106">    _displayfunction |= LCD_2LINE;</front>
<front id="LiquidCrystalRusCPP-107">  }</front>
<front id="LiquidCrystalRusCPP-108">  _numlines = lines;</front>
<front id="LiquidCrystalRusCPP-109">  _currline = 0;</front>
<front id="LiquidCrystalRusCPP-110"></front>
<front id="LiquidCrystalRusCPP-111">  // for some 1 line displays you can select a 10 pixel high font</front>
<front id="LiquidCrystalRusCPP-112">  if ((dotsize != 0) && (lines == 1)) {</front>
<front id="LiquidCrystalRusCPP-113">    _displayfunction |= LCD_5x10DOTS;</front>
<front id="LiquidCrystalRusCPP-114">  }</front>
<front id="LiquidCrystalRusCPP-115"></front>
<front id="LiquidCrystalRusCPP-116">  // SEE PAGE 45/46 FOR INITIALIZATION SPECIFICATION!</front>
<front id="LiquidCrystalRusCPP-117">  // according to datasheet, we need at least 40ms after power rises above 2.7V</front>
<front id="LiquidCrystalRusCPP-118">  // before sending commands. Arduino can turn on way befer 4.5V so we'll wait 50</front>
<front id="LiquidCrystalRusCPP-119">  delayMicroseconds(50000); </front>
<front id="LiquidCrystalRusCPP-120">  // Now we pull both RS and R/W low to begin commands</front>
<front id="LiquidCrystalRusCPP-121">  digitalWrite(_rs_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-122">  digitalWrite(_enable_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-123">  if (_rw_pin != 255) { </front>
<front id="LiquidCrystalRusCPP-124">    digitalWrite(_rw_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-125">  }</front>
<front id="LiquidCrystalRusCPP-126">  </front>
<front id="LiquidCrystalRusCPP-127">  //put the LCD into 4 bit or 8 bit mode</front>
<front id="LiquidCrystalRusCPP-128">  if (! (_displayfunction & LCD_8BITMODE)) {</front>
<front id="LiquidCrystalRusCPP-129">    // this is according to the hitachi HD44780 datasheet</front>
<front id="LiquidCrystalRusCPP-130">    // figure 24, pg 46</front>
<front id="LiquidCrystalRusCPP-131"></front>
<front id="LiquidCrystalRusCPP-132">    // we start in 8bit mode, try to set 4 bit mode</front>
<front id="LiquidCrystalRusCPP-133">    writeNbits(0x03,4);</front>
<front id="LiquidCrystalRusCPP-134">    delayMicroseconds(4500); // wait min 4.1ms</front>
<front id="LiquidCrystalRusCPP-135"></front>
<front id="LiquidCrystalRusCPP-136">    // second try</front>
<front id="LiquidCrystalRusCPP-137">    writeNbits(0x03,4);</front>
<front id="LiquidCrystalRusCPP-138">    delayMicroseconds(4500); // wait min 4.1ms</front>
<front id="LiquidCrystalRusCPP-139">    </front>
<front id="LiquidCrystalRusCPP-140">    // third go!</front>
<front id="LiquidCrystalRusCPP-141">    writeNbits(0x03,4); </front>
<front id="LiquidCrystalRusCPP-142">    delayMicroseconds(150);</front>
<front id="LiquidCrystalRusCPP-143"></front>
<front id="LiquidCrystalRusCPP-144">    // finally, set to 8-bit interface</front>
<front id="LiquidCrystalRusCPP-145">    writeNbits(0x02,4); </front>
<front id="LiquidCrystalRusCPP-146">  } else {</front>
<front id="LiquidCrystalRusCPP-147">    // this is according to the hitachi HD44780 datasheet</front>
<front id="LiquidCrystalRusCPP-148">    // page 45 figure 23</front>
<front id="LiquidCrystalRusCPP-149"></front>
<front id="LiquidCrystalRusCPP-150">    // Send function set command sequence</front>
<front id="LiquidCrystalRusCPP-151">    command(LCD_FUNCTIONSET | _displayfunction);</front>
<front id="LiquidCrystalRusCPP-152">    delayMicroseconds(4500);  // wait more than 4.1ms</front>
<front id="LiquidCrystalRusCPP-153"></front>
<front id="LiquidCrystalRusCPP-154">    // second try</front>
<front id="LiquidCrystalRusCPP-155">    command(LCD_FUNCTIONSET | _displayfunction);</front>
<front id="LiquidCrystalRusCPP-156">    delayMicroseconds(150);</front>
<front id="LiquidCrystalRusCPP-157"></front>
<front id="LiquidCrystalRusCPP-158">    // third go</front>
<front id="LiquidCrystalRusCPP-159">    command(LCD_FUNCTIONSET | _displayfunction);</front>
<front id="LiquidCrystalRusCPP-160">  }</front>
<front id="LiquidCrystalRusCPP-161"></front>
<front id="LiquidCrystalRusCPP-162">  // finally, set # lines, font size, etc.</front>
<front id="LiquidCrystalRusCPP-163">  command(LCD_FUNCTIONSET | _displayfunction);  </front>
<front id="LiquidCrystalRusCPP-164"></front>
<front id="LiquidCrystalRusCPP-165">  // turn the display on with no cursor or blinking default</front>
<front id="LiquidCrystalRusCPP-166">  _displaycontrol = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;  </front>
<front id="LiquidCrystalRusCPP-167">  display();</front>
<front id="LiquidCrystalRusCPP-168"></front>
<front id="LiquidCrystalRusCPP-169">  // clear it off</front>
<front id="LiquidCrystalRusCPP-170">  clear();</front>
<front id="LiquidCrystalRusCPP-171"></front>
<front id="LiquidCrystalRusCPP-172">  // Initialize to default text direction (for romance languages)</front>
<front id="LiquidCrystalRusCPP-173">  _displaymode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;</front>
<front id="LiquidCrystalRusCPP-174">  // set the entry mode</front>
<front id="LiquidCrystalRusCPP-175">  command(LCD_ENTRYMODESET | _displaymode);</front>
<front id="LiquidCrystalRusCPP-176"></front>
<front id="LiquidCrystalRusCPP-177">}</front>
<front id="LiquidCrystalRusCPP-178"></front>
<front id="LiquidCrystalRusCPP-179">void LiquidCrystalRus::setDRAMModel(uint8_t model) {</front>
<front id="LiquidCrystalRusCPP-180">  _dram_model = model;</front>
<front id="LiquidCrystalRusCPP-181">}</front>
<front id="LiquidCrystalRusCPP-182"></front>
<front id="LiquidCrystalRusCPP-183">/********** high level commands, for the user! */</front>
<front id="LiquidCrystalRusCPP-184">void LiquidCrystalRus::clear()</front>
<front id="LiquidCrystalRusCPP-185">{</front>
<front id="LiquidCrystalRusCPP-186">  command(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero</front>
<front id="LiquidCrystalRusCPP-187">  delayMicroseconds(2000);  // this command takes a long time!</front>
<front id="LiquidCrystalRusCPP-188">}</front>
<front id="LiquidCrystalRusCPP-189"></front>
<front id="LiquidCrystalRusCPP-190">void LiquidCrystalRus::home()</front>
<front id="LiquidCrystalRusCPP-191">{</front>
<front id="LiquidCrystalRusCPP-192">  command(LCD_RETURNHOME);  // set cursor position to zero</front>
<front id="LiquidCrystalRusCPP-193">  delayMicroseconds(2000);  // this command takes a long time!</front>
<front id="LiquidCrystalRusCPP-194">}</front>
<front id="LiquidCrystalRusCPP-195"></front>
<front id="LiquidCrystalRusCPP-196">void LiquidCrystalRus::setCursor(uint8_t col, uint8_t row)</front>
<front id="LiquidCrystalRusCPP-197">{</front>
<front id="LiquidCrystalRusCPP-198">  int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };</front>
<front id="LiquidCrystalRusCPP-199">  if ( row &gt;= _numlines ) {</front>
<front id="LiquidCrystalRusCPP-200">    row = _numlines-1;    // we count rows starting w/0</front>
<front id="LiquidCrystalRusCPP-201">  }</front>
<front id="LiquidCrystalRusCPP-202">  </front>
<front id="LiquidCrystalRusCPP-203">  command(LCD_SETDDRAMADDR | (col + row_offsets[row]));</front>
<front id="LiquidCrystalRusCPP-204">}</front>
<front id="LiquidCrystalRusCPP-205"></front>
<front id="LiquidCrystalRusCPP-206">// Turn the display on/off (quickly)</front>
<front id="LiquidCrystalRusCPP-207">void LiquidCrystalRus::noDisplay() {</front>
<front id="LiquidCrystalRusCPP-208">  _displaycontrol &= ~LCD_DISPLAYON;</front>
<front id="LiquidCrystalRusCPP-209">  command(LCD_DISPLAYCONTROL | _displaycontrol);</front>
<front id="LiquidCrystalRusCPP-210">}</front>
<front id="LiquidCrystalRusCPP-211">void LiquidCrystalRus::display() {</front>
<front id="LiquidCrystalRusCPP-212">  _displaycontrol |= LCD_DISPLAYON;</front>
<front id="LiquidCrystalRusCPP-213">  command(LCD_DISPLAYCONTROL | _displaycontrol);</front>
<front id="LiquidCrystalRusCPP-214">}</front>
<front id="LiquidCrystalRusCPP-215"></front>
<front id="LiquidCrystalRusCPP-216">// Turns the underline cursor on/off</front>
<front id="LiquidCrystalRusCPP-217">void LiquidCrystalRus::noCursor() {</front>
<front id="LiquidCrystalRusCPP-218">  _displaycontrol &= ~LCD_CURSORON;</front>
<front id="LiquidCrystalRusCPP-219">  command(LCD_DISPLAYCONTROL | _displaycontrol);</front>
<front id="LiquidCrystalRusCPP-220">}</front>
<front id="LiquidCrystalRusCPP-221">void LiquidCrystalRus::cursor() {</front>
<front id="LiquidCrystalRusCPP-222">  _displaycontrol |= LCD_CURSORON;</front>
<front id="LiquidCrystalRusCPP-223">  command(LCD_DISPLAYCONTROL | _displaycontrol);</front>
<front id="LiquidCrystalRusCPP-224">}</front>
<front id="LiquidCrystalRusCPP-225"></front>
<front id="LiquidCrystalRusCPP-226">// Turn on and off the blinking cursor</front>
<front id="LiquidCrystalRusCPP-227">void LiquidCrystalRus::noBlink() {</front>
<front id="LiquidCrystalRusCPP-228">  _displaycontrol &= ~LCD_BLINKON;</front>
<front id="LiquidCrystalRusCPP-229">  command(LCD_DISPLAYCONTROL | _displaycontrol);</front>
<front id="LiquidCrystalRusCPP-230">}</front>
<front id="LiquidCrystalRusCPP-231">void LiquidCrystalRus::blink() {</front>
<front id="LiquidCrystalRusCPP-232">  _displaycontrol |= LCD_BLINKON;</front>
<front id="LiquidCrystalRusCPP-233">  command(LCD_DISPLAYCONTROL | _displaycontrol);</front>
<front id="LiquidCrystalRusCPP-234">}</front>
<front id="LiquidCrystalRusCPP-235"></front>
<front id="LiquidCrystalRusCPP-236">// These commands scroll the display without changing the RAM</front>
<front id="LiquidCrystalRusCPP-237">void LiquidCrystalRus::scrollDisplayLeft(void) {</front>
<front id="LiquidCrystalRusCPP-238">  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);</front>
<front id="LiquidCrystalRusCPP-239">}</front>
<front id="LiquidCrystalRusCPP-240">void LiquidCrystalRus::scrollDisplayRight(void) {</front>
<front id="LiquidCrystalRusCPP-241">  command(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);</front>
<front id="LiquidCrystalRusCPP-242">}</front>
<front id="LiquidCrystalRusCPP-243"></front>
<front id="LiquidCrystalRusCPP-244">// This is for text that flows Left to Right</front>
<front id="LiquidCrystalRusCPP-245">void LiquidCrystalRus::leftToRight(void) {</front>
<front id="LiquidCrystalRusCPP-246">  _displaymode |= LCD_ENTRYLEFT;</front>
<front id="LiquidCrystalRusCPP-247">  command(LCD_ENTRYMODESET | _displaymode);</front>
<front id="LiquidCrystalRusCPP-248">}</front>
<front id="LiquidCrystalRusCPP-249"></front>
<front id="LiquidCrystalRusCPP-250">// This is for text that flows Right to Left</front>
<front id="LiquidCrystalRusCPP-251">void LiquidCrystalRus::rightToLeft(void) {</front>
<front id="LiquidCrystalRusCPP-252">  _displaymode &= ~LCD_ENTRYLEFT;</front>
<front id="LiquidCrystalRusCPP-253">  command(LCD_ENTRYMODESET | _displaymode);</front>
<front id="LiquidCrystalRusCPP-254">}</front>
<front id="LiquidCrystalRusCPP-255"></front>
<front id="LiquidCrystalRusCPP-256">// This will 'right justify' text from the cursor</front>
<front id="LiquidCrystalRusCPP-257">void LiquidCrystalRus::autoscroll(void) {</front>
<front id="LiquidCrystalRusCPP-258">  _displaymode |= LCD_ENTRYSHIFTINCREMENT;</front>
<front id="LiquidCrystalRusCPP-259">  command(LCD_ENTRYMODESET | _displaymode);</front>
<front id="LiquidCrystalRusCPP-260">}</front>
<front id="LiquidCrystalRusCPP-261"></front>
<front id="LiquidCrystalRusCPP-262">// This will 'left justify' text from the cursor</front>
<front id="LiquidCrystalRusCPP-263">void LiquidCrystalRus::noAutoscroll(void) {</front>
<front id="LiquidCrystalRusCPP-264">  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;</front>
<front id="LiquidCrystalRusCPP-265">  command(LCD_ENTRYMODESET | _displaymode);</front>
<front id="LiquidCrystalRusCPP-266">}</front>
<front id="LiquidCrystalRusCPP-267"></front>
<front id="LiquidCrystalRusCPP-268">// Allows us to fill the first 8 CGRAM locations</front>
<front id="LiquidCrystalRusCPP-269">// with custom characters</front>
<front id="LiquidCrystalRusCPP-270">void LiquidCrystalRus::createChar(uint8_t location, uint8_t charmap[]) {</front>
<front id="LiquidCrystalRusCPP-271">  location &= 0x7; // we only have 8 locations 0-7</front>
<front id="LiquidCrystalRusCPP-272">  command(LCD_SETCGRAMADDR | (location &lt;&lt; 3));</front>
<front id="LiquidCrystalRusCPP-273">  for (int i=0; i&lt;8; i++) {</front>
<front id="LiquidCrystalRusCPP-274">    write(charmap[i]);</front>
<front id="LiquidCrystalRusCPP-275">  }</front>
<front id="LiquidCrystalRusCPP-276">}</front>
<front id="LiquidCrystalRusCPP-277"></front>
<front id="LiquidCrystalRusCPP-278">/*********** mid level commands, for sending data/cmds */</front>
<front id="LiquidCrystalRusCPP-279"></front>
<front id="LiquidCrystalRusCPP-280">inline void LiquidCrystalRus::command(uint8_t value) {</front>
<front id="LiquidCrystalRusCPP-281">  send(value, LOW);</front>
<front id="LiquidCrystalRusCPP-282">}</front>
<front id="LiquidCrystalRusCPP-283"></front>
<front id="LiquidCrystalRusCPP-284">#if defined(ARDUINO) && ARDUINO &gt;= 100</front>
<front id="LiquidCrystalRusCPP-285">  size_t LiquidCrystalRus::write(uint8_t value)</front>
<front id="LiquidCrystalRusCPP-286">#else</front>
<front id="LiquidCrystalRusCPP-287">  void   LiquidCrystalRus::write(uint8_t value)</front>
<front id="LiquidCrystalRusCPP-288">#endif</front>
<front id="LiquidCrystalRusCPP-289">{</front>
<front id="LiquidCrystalRusCPP-290">  uint8_t out_char=value;</front>
<front id="LiquidCrystalRusCPP-291"></front>
<front id="LiquidCrystalRusCPP-292">  if (_dram_model == LCD_DRAM_WH1601) {  </front>
<front id="LiquidCrystalRusCPP-293">    uint8_t ac=recv(LOW) & 0x7f;</front>
<front id="LiquidCrystalRusCPP-294">    if (ac&gt;7 && ac&lt;0x14) command(LCD_SETDDRAMADDR | (0x40+ac-8));</front>
<front id="LiquidCrystalRusCPP-295">  }</front>
<front id="LiquidCrystalRusCPP-296"></front>
<front id="LiquidCrystalRusCPP-297">  if (value&gt;=0x80) { // UTF-8 handling</front>
<front id="LiquidCrystalRusCPP-298">    if (value &gt;= 0xc0) {</front>
<front id="LiquidCrystalRusCPP-299">      utf_hi_char = value - 0xd0;</front>
<front id="LiquidCrystalRusCPP-300">    } else {</front>
<front id="LiquidCrystalRusCPP-301">      value &= 0x3f;</front>
<front id="LiquidCrystalRusCPP-302">      if (!utf_hi_char && (value == 1)) </front>
<front id="LiquidCrystalRusCPP-303">        send(0xa2,HIGH); // </front>
<front id="LiquidCrystalRusCPP-304">      else if ((utf_hi_char == 1) && (value == 0x11)) </front>
<front id="LiquidCrystalRusCPP-305">        send(0xb5,HIGH); // </front>
<front id="LiquidCrystalRusCPP-306">      else </front>
<front id="LiquidCrystalRusCPP-307">        send(pgm_read_byte_near(utf_recode + value + (utf_hi_char&lt;&lt;6) - 0x10), HIGH);</front>
<front id="LiquidCrystalRusCPP-308">    }    </front>
<front id="LiquidCrystalRusCPP-309">  } else send(out_char, HIGH);</front>
<front id="LiquidCrystalRusCPP-310">#if defined(ARDUINO) && ARDUINO &gt;= 100</front>
<front id="LiquidCrystalRusCPP-311">  return 1; // assume sucess </front>
<front id="LiquidCrystalRusCPP-312">#endif</front>
<front id="LiquidCrystalRusCPP-313">}</front>
<front id="LiquidCrystalRusCPP-314"></front>
<front id="LiquidCrystalRusCPP-315">/************ low level data pushing commands **********/</front>
<front id="LiquidCrystalRusCPP-316"></front>
<front id="LiquidCrystalRusCPP-317">// write either command or data, with automatic 4/8-bit selection</front>
<front id="LiquidCrystalRusCPP-318">void LiquidCrystalRus::send(uint8_t value, uint8_t mode) {</front>
<front id="LiquidCrystalRusCPP-319">  digitalWrite(_rs_pin, mode);</front>
<front id="LiquidCrystalRusCPP-320"></front>
<front id="LiquidCrystalRusCPP-321">  // if there is a RW pin indicated, set it low to Write</front>
<front id="LiquidCrystalRusCPP-322">  if (_rw_pin != 255) { </front>
<front id="LiquidCrystalRusCPP-323">    digitalWrite(_rw_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-324">  }</front>
<front id="LiquidCrystalRusCPP-325">  </front>
<front id="LiquidCrystalRusCPP-326">  if (_displayfunction & LCD_8BITMODE) {</front>
<front id="LiquidCrystalRusCPP-327">    writeNbits(value,8); </front>
<front id="LiquidCrystalRusCPP-328">  } else {</front>
<front id="LiquidCrystalRusCPP-329">    writeNbits(value&gt;&gt;4,4);</front>
<front id="LiquidCrystalRusCPP-330">    writeNbits(value,4);</front>
<front id="LiquidCrystalRusCPP-331">  }</front>
<front id="LiquidCrystalRusCPP-332">}</front>
<front id="LiquidCrystalRusCPP-333"></front>
<front id="LiquidCrystalRusCPP-334">// read  data, with automatic 4/8-bit selection</front>
<front id="LiquidCrystalRusCPP-335">uint8_t LiquidCrystalRus::recv(uint8_t mode) {</front>
<front id="LiquidCrystalRusCPP-336">  uint8_t retval;</front>
<front id="LiquidCrystalRusCPP-337">  digitalWrite(_rs_pin, mode);</front>
<front id="LiquidCrystalRusCPP-338"></front>
<front id="LiquidCrystalRusCPP-339">  // if there is a RW pin indicated, set it low to Write</front>
<front id="LiquidCrystalRusCPP-340">  if (_rw_pin != 255) { </front>
<front id="LiquidCrystalRusCPP-341">    digitalWrite(_rw_pin, HIGH);</front>
<front id="LiquidCrystalRusCPP-342">  }</front>
<front id="LiquidCrystalRusCPP-343">  </front>
<front id="LiquidCrystalRusCPP-344">  if (_displayfunction & LCD_8BITMODE) {</front>
<front id="LiquidCrystalRusCPP-345">    retval = readNbits(8); </front>
<front id="LiquidCrystalRusCPP-346">  } else {</front>
<front id="LiquidCrystalRusCPP-347">    retval = readNbits(4) &lt;&lt; 4;</front>
<front id="LiquidCrystalRusCPP-348">    retval |= readNbits(4);</front>
<front id="LiquidCrystalRusCPP-349">  }</front>
<front id="LiquidCrystalRusCPP-350">  return retval;</front>
<front id="LiquidCrystalRusCPP-351">}</front>
<front id="LiquidCrystalRusCPP-352">void LiquidCrystalRus::pulseEnable() {</front>
<front id="LiquidCrystalRusCPP-353">  digitalWrite(_enable_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-354">  delayMicroseconds(1);    </front>
<front id="LiquidCrystalRusCPP-355">  digitalWrite(_enable_pin, HIGH);</front>
<front id="LiquidCrystalRusCPP-356">  delayMicroseconds(1);    // enable pulse must be &gt;450ns</front>
<front id="LiquidCrystalRusCPP-357">  digitalWrite(_enable_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-358">  delayMicroseconds(100);   // commands need &gt; 37us to settle</front>
<front id="LiquidCrystalRusCPP-359">}</front>
<front id="LiquidCrystalRusCPP-360"></front>
<front id="LiquidCrystalRusCPP-361">void LiquidCrystalRus::writeNbits(uint8_t value, uint8_t n) {</front>
<front id="LiquidCrystalRusCPP-362">  for (int i = 0; i &lt; n; i++) {</front>
<front id="LiquidCrystalRusCPP-363">    pinMode(_data_pins[i], OUTPUT);</front>
<front id="LiquidCrystalRusCPP-364">    digitalWrite(_data_pins[i], (value &gt;&gt; i) & 0x01);</front>
<front id="LiquidCrystalRusCPP-365">  }</front>
<front id="LiquidCrystalRusCPP-366"></front>
<front id="LiquidCrystalRusCPP-367">  pulseEnable();</front>
<front id="LiquidCrystalRusCPP-368">}</front>
<front id="LiquidCrystalRusCPP-369"></front>
<front id="LiquidCrystalRusCPP-370">uint8_t LiquidCrystalRus::readNbits(uint8_t n) {</front>
<front id="LiquidCrystalRusCPP-371">  uint8_t retval=0;</front>
<front id="LiquidCrystalRusCPP-372">  for (int i = 0; i &lt; n; i++) {</front>
<front id="LiquidCrystalRusCPP-373">    pinMode(_data_pins[i], INPUT);</front>
<front id="LiquidCrystalRusCPP-374">  }</front>
<front id="LiquidCrystalRusCPP-375"></front>
<front id="LiquidCrystalRusCPP-376">  digitalWrite(_enable_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-377">  delayMicroseconds(1);    </front>
<front id="LiquidCrystalRusCPP-378">  digitalWrite(_enable_pin, HIGH);</front>
<front id="LiquidCrystalRusCPP-379">  delayMicroseconds(1);    // enable pulse must be &gt;450ns</front>
<front id="LiquidCrystalRusCPP-380">  </front>
<front id="LiquidCrystalRusCPP-381">  for (int i = 0; i &lt; n; i++) {</front>
<front id="LiquidCrystalRusCPP-382">    retval |= (digitalRead(_data_pins[i]) == HIGH)?(1 &lt;&lt; i):0;</front>
<front id="LiquidCrystalRusCPP-383">  }</front>
<front id="LiquidCrystalRusCPP-384"></front>
<front id="LiquidCrystalRusCPP-385">  digitalWrite(_enable_pin, LOW);</front>
<front id="LiquidCrystalRusCPP-386"></front>
<front id="LiquidCrystalRusCPP-387">  return retval;</front>
<front id="LiquidCrystalRusCPP-388">}</front>
<front id="LiquidCrystalRusCPP-389"></front>
 </pre>
<h1>LiquidCrystalRus.h</h1>
<pre  class="prettyprint linenums"><front id="LiquidCrystalRusH-1">//</front>
<front id="LiquidCrystalRusH-2">// based on LiquidCrystal library from ArduinoIDE, see http://arduino.cc</front>
<front id="LiquidCrystalRusH-3">//  modified 27 Jul 2011</front>
<front id="LiquidCrystalRusH-4">// by Ilya V. Danilov http://mk90.ru/</front>
<front id="LiquidCrystalRusH-5">// </front>
<front id="LiquidCrystalRusH-6"></front>
<front id="LiquidCrystalRusH-7">#ifndef LiquidCrystalRus_h</front>
<front id="LiquidCrystalRusH-8">#define LiquidCrystalRus_h</front>
<front id="LiquidCrystalRusH-9"></front>
<front id="LiquidCrystalRusH-10">#include &lt;inttypes.h&gt;</front>
<front id="LiquidCrystalRusH-11">#include "Print.h"</front>
<front id="LiquidCrystalRusH-12"></front>
<front id="LiquidCrystalRusH-13">// commands</front>
<front id="LiquidCrystalRusH-14">#define LCD_CLEARDISPLAY 0x01</front>
<front id="LiquidCrystalRusH-15">#define LCD_RETURNHOME 0x02</front>
<front id="LiquidCrystalRusH-16">#define LCD_ENTRYMODESET 0x04</front>
<front id="LiquidCrystalRusH-17">#define LCD_DISPLAYCONTROL 0x08</front>
<front id="LiquidCrystalRusH-18">#define LCD_CURSORSHIFT 0x10</front>
<front id="LiquidCrystalRusH-19">#define LCD_FUNCTIONSET 0x20</front>
<front id="LiquidCrystalRusH-20">#define LCD_SETCGRAMADDR 0x40</front>
<front id="LiquidCrystalRusH-21">#define LCD_SETDDRAMADDR 0x80</front>
<front id="LiquidCrystalRusH-22"></front>
<front id="LiquidCrystalRusH-23">// flags for display entry mode</front>
<front id="LiquidCrystalRusH-24">#define LCD_ENTRYRIGHT 0x00</front>
<front id="LiquidCrystalRusH-25">#define LCD_ENTRYLEFT 0x02</front>
<front id="LiquidCrystalRusH-26">#define LCD_ENTRYSHIFTINCREMENT 0x01</front>
<front id="LiquidCrystalRusH-27">#define LCD_ENTRYSHIFTDECREMENT 0x00</front>
<front id="LiquidCrystalRusH-28"></front>
<front id="LiquidCrystalRusH-29">// flags for display on/off control</front>
<front id="LiquidCrystalRusH-30">#define LCD_DISPLAYON 0x04</front>
<front id="LiquidCrystalRusH-31">#define LCD_DISPLAYOFF 0x00</front>
<front id="LiquidCrystalRusH-32">#define LCD_CURSORON 0x02</front>
<front id="LiquidCrystalRusH-33">#define LCD_CURSOROFF 0x00</front>
<front id="LiquidCrystalRusH-34">#define LCD_BLINKON 0x01</front>
<front id="LiquidCrystalRusH-35">#define LCD_BLINKOFF 0x00</front>
<front id="LiquidCrystalRusH-36"></front>
<front id="LiquidCrystalRusH-37">// flags for display/cursor shift</front>
<front id="LiquidCrystalRusH-38">#define LCD_DISPLAYMOVE 0x08</front>
<front id="LiquidCrystalRusH-39">#define LCD_CURSORMOVE 0x00</front>
<front id="LiquidCrystalRusH-40">#define LCD_MOVERIGHT 0x04</front>
<front id="LiquidCrystalRusH-41">#define LCD_MOVELEFT 0x00</front>
<front id="LiquidCrystalRusH-42"></front>
<front id="LiquidCrystalRusH-43">// flags for function set</front>
<front id="LiquidCrystalRusH-44">#define LCD_8BITMODE 0x10</front>
<front id="LiquidCrystalRusH-45">#define LCD_4BITMODE 0x00</front>
<front id="LiquidCrystalRusH-46">#define LCD_2LINE 0x08</front>
<front id="LiquidCrystalRusH-47">#define LCD_1LINE 0x00</front>
<front id="LiquidCrystalRusH-48">#define LCD_5x10DOTS 0x04</front>
<front id="LiquidCrystalRusH-49">#define LCD_5x8DOTS 0x00</front>
<front id="LiquidCrystalRusH-50"></front>
<front id="LiquidCrystalRusH-51">// enum for </front>
<front id="LiquidCrystalRusH-52">#define LCD_DRAM_Normal 0x00</front>
<front id="LiquidCrystalRusH-53">#define LCD_DRAM_WH1601 0x01</front>
<front id="LiquidCrystalRusH-54"></front>
<front id="LiquidCrystalRusH-55"></front>
<front id="LiquidCrystalRusH-56">class LiquidCrystalRus : public Print {</front>
<front id="LiquidCrystalRusH-57">public:</front>
<front id="LiquidCrystalRusH-58">  LiquidCrystalRus(uint8_t rs, uint8_t enable,</front>
<front id="LiquidCrystalRusH-59">		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,</front>
<front id="LiquidCrystalRusH-60">		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);</front>
<front id="LiquidCrystalRusH-61">  LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,</front>
<front id="LiquidCrystalRusH-62">		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,</front>
<front id="LiquidCrystalRusH-63">		uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);</front>
<front id="LiquidCrystalRusH-64">  LiquidCrystalRus(uint8_t rs, uint8_t rw, uint8_t enable,</front>
<front id="LiquidCrystalRusH-65">		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);</front>
<front id="LiquidCrystalRusH-66">  LiquidCrystalRus(uint8_t rs, uint8_t enable,</front>
<front id="LiquidCrystalRusH-67">		uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);</front>
<front id="LiquidCrystalRusH-68"></front>
<front id="LiquidCrystalRusH-69">  void init(uint8_t fourbitmode, uint8_t rs, uint8_t rw, uint8_t enable,</front>
<front id="LiquidCrystalRusH-70">	    uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,</front>
<front id="LiquidCrystalRusH-71">	    uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);</front>
<front id="LiquidCrystalRusH-72">    </front>
<front id="LiquidCrystalRusH-73">  void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS);</front>
<front id="LiquidCrystalRusH-74"></front>
<front id="LiquidCrystalRusH-75">  void clear();</front>
<front id="LiquidCrystalRusH-76">  void home();</front>
<front id="LiquidCrystalRusH-77"></front>
<front id="LiquidCrystalRusH-78">  void noDisplay();</front>
<front id="LiquidCrystalRusH-79">  void display();</front>
<front id="LiquidCrystalRusH-80">  void noBlink();</front>
<front id="LiquidCrystalRusH-81">  void blink();</front>
<front id="LiquidCrystalRusH-82">  void noCursor();</front>
<front id="LiquidCrystalRusH-83">  void cursor();</front>
<front id="LiquidCrystalRusH-84">  void scrollDisplayLeft();</front>
<front id="LiquidCrystalRusH-85">  void scrollDisplayRight();</front>
<front id="LiquidCrystalRusH-86">  void leftToRight();</front>
<front id="LiquidCrystalRusH-87">  void rightToLeft();</front>
<front id="LiquidCrystalRusH-88">  void autoscroll();</front>
<front id="LiquidCrystalRusH-89">  void noAutoscroll();</front>
<front id="LiquidCrystalRusH-90"></front>
<front id="LiquidCrystalRusH-91">  void createChar(uint8_t, uint8_t[]);</front>
<front id="LiquidCrystalRusH-92">  void setCursor(uint8_t, uint8_t);</front>
<front id="LiquidCrystalRusH-93"> </front>
<front id="LiquidCrystalRusH-94">#if defined(ARDUINO) && ARDUINO &gt;= 100</front>
<front id="LiquidCrystalRusH-95">  virtual size_t write(uint8_t);</front>
<front id="LiquidCrystalRusH-96">  using Print::write;</front>
<front id="LiquidCrystalRusH-97">#else</front>
<front id="LiquidCrystalRusH-98">  virtual void write(uint8_t);</front>
<front id="LiquidCrystalRusH-99">#endif</front>
<front id="LiquidCrystalRusH-100"></front>
<front id="LiquidCrystalRusH-101">  void command(uint8_t);</front>
<front id="LiquidCrystalRusH-102"></front>
<front id="LiquidCrystalRusH-103">  void setDRAMModel(uint8_t);</front>
<front id="LiquidCrystalRusH-104"></front>
<front id="LiquidCrystalRusH-105">private:</front>
<front id="LiquidCrystalRusH-106">  void send(uint8_t, uint8_t);</front>
<front id="LiquidCrystalRusH-107">  void writeNbits(uint8_t, uint8_t);</front>
<front id="LiquidCrystalRusH-108">  uint8_t recv(uint8_t);</front>
<front id="LiquidCrystalRusH-109">  uint8_t readNbits(uint8_t); </front>
<front id="LiquidCrystalRusH-110">  void pulseEnable();</front>
<front id="LiquidCrystalRusH-111"></front>
<front id="LiquidCrystalRusH-112">  uint8_t _rs_pin; // LOW: command.  HIGH: character.</front>
<front id="LiquidCrystalRusH-113">  uint8_t _rw_pin; // LOW: write to LCD.  HIGH: read from LCD.</front>
<front id="LiquidCrystalRusH-114">  uint8_t _enable_pin; // activated by a HIGH pulse.</front>
<front id="LiquidCrystalRusH-115">  uint8_t _data_pins[8];</front>
<front id="LiquidCrystalRusH-116"></front>
<front id="LiquidCrystalRusH-117">  uint8_t _displayfunction;</front>
<front id="LiquidCrystalRusH-118">  uint8_t _displaycontrol;</front>
<front id="LiquidCrystalRusH-119">  uint8_t _displaymode;</front>
<front id="LiquidCrystalRusH-120"></front>
<front id="LiquidCrystalRusH-121">  uint8_t _initialized;</front>
<front id="LiquidCrystalRusH-122"></front>
<front id="LiquidCrystalRusH-123">  uint8_t _numlines,_currline;</front>
<front id="LiquidCrystalRusH-124"></front>
<front id="LiquidCrystalRusH-125">  uint8_t _dram_model;</front>
<front id="LiquidCrystalRusH-126">  uint8_t utf_hi_char; // UTF-8 high part</front>
<front id="LiquidCrystalRusH-127">};</front>
<front id="LiquidCrystalRusH-128"></front>
<front id="LiquidCrystalRusH-129">#endif</front>
 </pre>
<h1>Marlin.h</h1>
<pre  class="prettyprint linenums"><front id="MarlinH-1">// Tonokip RepRap firmware rewrite based off of Hydra-mmm firmware.</front>
<front id="MarlinH-2">// Licence: GPL</front>
<front id="MarlinH-3"></front>
<front id="MarlinH-4">#ifndef MARLIN_H</front>
<front id="MarlinH-5">#define MARLIN_H</front>
<front id="MarlinH-6"></front>
<front id="MarlinH-7">#define  FORCE_INLINE __attribute__((always_inline)) inline</front>
<front id="MarlinH-8"></front>
<front id="MarlinH-9">#include &lt;math.h&gt;</front>
<front id="MarlinH-10">#include &lt;stdio.h&gt;</front>
<front id="MarlinH-11">#include &lt;stdlib.h&gt;</front>
<front id="MarlinH-12">#include &lt;string.h&gt;</front>
<front id="MarlinH-13">#include &lt;inttypes.h&gt;</front>
<front id="MarlinH-14"></front>
<front id="MarlinH-15">#include &lt;util/delay.h&gt;</front>
<front id="MarlinH-16">#include &lt;avr/pgmspace.h&gt;</front>
<front id="MarlinH-17">#include &lt;avr/eeprom.h&gt;</front>
<front id="MarlinH-18">#include &lt;avr/interrupt.h&gt;</front>
<front id="MarlinH-19"></front>
<front id="MarlinH-20"></front>
<front id="MarlinH-21">#include "fastio.h"</front>
<front id="MarlinH-22">#include "Configuration.h"</front>
<front id="MarlinH-23">#include "pins.h"</front>
<front id="MarlinH-24"></front>
<front id="MarlinH-25">#ifndef AT90USB</front>
<front id="MarlinH-26">#define  HardwareSerial_h // trick to disable the standard HWserial</front>
<front id="MarlinH-27">#endif</front>
<front id="MarlinH-28"></front>
<front id="MarlinH-29">#if (ARDUINO &gt;= 100)</front>
<front id="MarlinH-30"># include "Arduino.h"</front>
<front id="MarlinH-31">#else</front>
<front id="MarlinH-32"># include "WProgram.h"</front>
<front id="MarlinH-33">  //Arduino &lt; 1.0.0 does not define this, so we need to do it ourselfs</front>
<front id="MarlinH-34"># define analogInputToDigitalPin(p) ((p) + A0)</front>
<front id="MarlinH-35">#endif</front>
<front id="MarlinH-36"></front>
<front id="MarlinH-37">#include "MarlinSerial.h"</front>
<front id="MarlinH-38"></front>
<front id="MarlinH-39">#ifndef cbi</front>
<front id="MarlinH-40">#define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))</front>
<front id="MarlinH-41">#endif</front>
<front id="MarlinH-42">#ifndef sbi</front>
<front id="MarlinH-43">#define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))</front>
<front id="MarlinH-44">#endif</front>
<front id="MarlinH-45"></front>
<front id="MarlinH-46">#include "WString.h"</front>
<front id="MarlinH-47"></front>
<front id="MarlinH-48">#ifdef AT90USB</front>
<front id="MarlinH-49">  #define MYSERIAL Serial</front>
<front id="MarlinH-50">#else</front>
<front id="MarlinH-51">  #define MYSERIAL MSerial</front>
<front id="MarlinH-52">#endif</front>
<front id="MarlinH-53"></front>
<front id="MarlinH-54">#define SERIAL_PROTOCOL(x) (MYSERIAL.print(x))</front>
<front id="MarlinH-55">#define SERIAL_PROTOCOL_F(x,y) (MYSERIAL.print(x,y))</front>
<front id="MarlinH-56">#define SERIAL_PROTOCOLPGM(x) (serialprintPGM(PSTR(x)))</front>
<front id="MarlinH-57">#define SERIAL_PROTOCOLLN(x) (MYSERIAL.print(x),MYSERIAL.write('\n'))</front>
<front id="MarlinH-58">#define SERIAL_PROTOCOLLNPGM(x) (serialprintPGM(PSTR(x)),MYSERIAL.write('\n'))</front>
<front id="MarlinH-59"></front>
<front id="MarlinH-60"></front>
<front id="MarlinH-61">const char errormagic[] PROGMEM ="Error:";</front>
<front id="MarlinH-62">const char echomagic[] PROGMEM ="echo:";</front>
<front id="MarlinH-63">#define SERIAL_ERROR_START (serialprintPGM(errormagic))</front>
<front id="MarlinH-64">#define SERIAL_ERROR(x) SERIAL_PROTOCOL(x)</front>
<front id="MarlinH-65">#define SERIAL_ERRORPGM(x) SERIAL_PROTOCOLPGM(x)</front>
<front id="MarlinH-66">#define SERIAL_ERRORLN(x) SERIAL_PROTOCOLLN(x)</front>
<front id="MarlinH-67">#define SERIAL_ERRORLNPGM(x) SERIAL_PROTOCOLLNPGM(x)</front>
<front id="MarlinH-68"></front>
<front id="MarlinH-69">#define SERIAL_ECHO_START (serialprintPGM(echomagic))</front>
<front id="MarlinH-70">#define SERIAL_ECHO(x) SERIAL_PROTOCOL(x)</front>
<front id="MarlinH-71">#define SERIAL_ECHOPGM(x) SERIAL_PROTOCOLPGM(x)</front>
<front id="MarlinH-72">#define SERIAL_ECHOLN(x) SERIAL_PROTOCOLLN(x)</front>
<front id="MarlinH-73">#define SERIAL_ECHOLNPGM(x) SERIAL_PROTOCOLLNPGM(x)</front>
<front id="MarlinH-74"></front>
<front id="MarlinH-75">#define SERIAL_ECHOPAIR(name,value) (serial_echopair_P(PSTR(name),(value)))</front>
<front id="MarlinH-76"></front>
<front id="MarlinH-77">void serial_echopair_P(const char *s_P, float v);</front>
<front id="MarlinH-78">void serial_echopair_P(const char *s_P, double v);</front>
<front id="MarlinH-79">void serial_echopair_P(const char *s_P, unsigned long v);</front>
<front id="MarlinH-80"></front>
<front id="MarlinH-81"></front>
<front id="MarlinH-82">//things to write to serial from Programmemory. saves 400 to 2k of RAM.</front>
<front id="MarlinH-83">FORCE_INLINE void serialprintPGM(const char *str)</front>
<front id="MarlinH-84">{</front>
<front id="MarlinH-85">  char ch=pgm_read_byte(str);</front>
<front id="MarlinH-86">  while(ch)</front>
<front id="MarlinH-87">  {</front>
<front id="MarlinH-88">    MYSERIAL.write(ch);</front>
<front id="MarlinH-89">    ch=pgm_read_byte(++str);</front>
<front id="MarlinH-90">  }</front>
<front id="MarlinH-91">}</front>
<front id="MarlinH-92"></front>
<front id="MarlinH-93"></front>
<front id="MarlinH-94">void get_command();</front>
<front id="MarlinH-95">void process_commands();</front>
<front id="MarlinH-96"></front>
<front id="MarlinH-97">void manage_inactivity();</front>
<front id="MarlinH-98"></front>
<front id="MarlinH-99">#if defined(DUAL_X_CARRIAGE) && defined(X_ENABLE_PIN) && X_ENABLE_PIN &gt; -1 \</front>
<front id="MarlinH-100">    && defined(X2_ENABLE_PIN) && X2_ENABLE_PIN &gt; -1</front>
<front id="MarlinH-101">  #define  enable_x() do { WRITE(X_ENABLE_PIN, X_ENABLE_ON); WRITE(X2_ENABLE_PIN, X_ENABLE_ON); } while (0)</front>
<front id="MarlinH-102">  #define disable_x() do { WRITE(X_ENABLE_PIN,!X_ENABLE_ON); WRITE(X2_ENABLE_PIN,!X_ENABLE_ON); } while (0)</front>
<front id="MarlinH-103">#elif defined(X_ENABLE_PIN) && X_ENABLE_PIN &gt; -1</front>
<front id="MarlinH-104">  #define  enable_x() WRITE(X_ENABLE_PIN, X_ENABLE_ON)</front>
<front id="MarlinH-105">  #define disable_x() WRITE(X_ENABLE_PIN,!X_ENABLE_ON)</front>
<front id="MarlinH-106">#else</front>
<front id="MarlinH-107">  #define enable_x() ;</front>
<front id="MarlinH-108">  #define disable_x() ;</front>
<front id="MarlinH-109">#endif</front>
<front id="MarlinH-110"></front>
<front id="MarlinH-111">#if defined(Y_ENABLE_PIN) && Y_ENABLE_PIN &gt; -1</front>
<front id="MarlinH-112">  #define  enable_y() WRITE(Y_ENABLE_PIN, Y_ENABLE_ON)</front>
<front id="MarlinH-113">  #define disable_y() WRITE(Y_ENABLE_PIN,!Y_ENABLE_ON)</front>
<front id="MarlinH-114">#else</front>
<front id="MarlinH-115">  #define enable_y() ;</front>
<front id="MarlinH-116">  #define disable_y() ;</front>
<front id="MarlinH-117">#endif</front>
<front id="MarlinH-118"></front>
<front id="MarlinH-119">#if defined(Z_ENABLE_PIN) && Z_ENABLE_PIN &gt; -1</front>
<front id="MarlinH-120">  #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="MarlinH-121">    #define  enable_z() { WRITE(Z_ENABLE_PIN, Z_ENABLE_ON); WRITE(Z2_ENABLE_PIN, Z_ENABLE_ON); }</front>
<front id="MarlinH-122">    #define disable_z() { WRITE(Z_ENABLE_PIN,!Z_ENABLE_ON); WRITE(Z2_ENABLE_PIN,!Z_ENABLE_ON); }</front>
<front id="MarlinH-123">  #else</front>
<front id="MarlinH-124">    #define  enable_z() WRITE(Z_ENABLE_PIN, Z_ENABLE_ON)</front>
<front id="MarlinH-125">    #define disable_z() WRITE(Z_ENABLE_PIN,!Z_ENABLE_ON)</front>
<front id="MarlinH-126">  #endif</front>
<front id="MarlinH-127">#else</front>
<front id="MarlinH-128">  #define enable_z() ;</front>
<front id="MarlinH-129">  #define disable_z() ;</front>
<front id="MarlinH-130">#endif</front>
<front id="MarlinH-131"></front>
<front id="MarlinH-132">#if defined(E0_ENABLE_PIN) && (E0_ENABLE_PIN &gt; -1)</front>
<front id="MarlinH-133">  #define enable_e0() WRITE(E0_ENABLE_PIN, E_ENABLE_ON)</front>
<front id="MarlinH-134">  #define disable_e0() WRITE(E0_ENABLE_PIN,!E_ENABLE_ON)</front>
<front id="MarlinH-135">#else</front>
<front id="MarlinH-136">  #define enable_e0()  /* nothing */</front>
<front id="MarlinH-137">  #define disable_e0() /* nothing */</front>
<front id="MarlinH-138">#endif</front>
<front id="MarlinH-139"></front>
<front id="MarlinH-140">#if (EXTRUDERS &gt; 1) && defined(E1_ENABLE_PIN) && (E1_ENABLE_PIN &gt; -1)</front>
<front id="MarlinH-141">  #define enable_e1() WRITE(E1_ENABLE_PIN, E_ENABLE_ON)</front>
<front id="MarlinH-142">  #define disable_e1() WRITE(E1_ENABLE_PIN,!E_ENABLE_ON)</front>
<front id="MarlinH-143">#else</front>
<front id="MarlinH-144">  #define enable_e1()  /* nothing */</front>
<front id="MarlinH-145">  #define disable_e1() /* nothing */</front>
<front id="MarlinH-146">#endif</front>
<front id="MarlinH-147"></front>
<front id="MarlinH-148">#if (EXTRUDERS &gt; 2) && defined(E2_ENABLE_PIN) && (E2_ENABLE_PIN &gt; -1)</front>
<front id="MarlinH-149">  #define enable_e2() WRITE(E2_ENABLE_PIN, E_ENABLE_ON)</front>
<front id="MarlinH-150">  #define disable_e2() WRITE(E2_ENABLE_PIN,!E_ENABLE_ON)</front>
<front id="MarlinH-151">#else</front>
<front id="MarlinH-152">  #define enable_e2()  /* nothing */</front>
<front id="MarlinH-153">  #define disable_e2() /* nothing */</front>
<front id="MarlinH-154">#endif</front>
<front id="MarlinH-155"></front>
<front id="MarlinH-156"></front>
<front id="MarlinH-157">enum AxisEnum {X_AXIS=0, Y_AXIS=1, Z_AXIS=2, E_AXIS=3};</front>
<front id="MarlinH-158"></front>
<front id="MarlinH-159"></front>
<front id="MarlinH-160">void FlushSerialRequestResend();</front>
<front id="MarlinH-161">void ClearToSend();</front>
<front id="MarlinH-162"></front>
<front id="MarlinH-163">void get_coordinates();</front>
<front id="MarlinH-164">#ifdef DELTA</front>
<front id="MarlinH-165">void calculate_delta(float cartesian[3]);</front>
<front id="MarlinH-166">extern float delta[3];</front>
<front id="MarlinH-167">#endif</front>
<front id="MarlinH-168">void prepare_move();</front>
<front id="MarlinH-169">void kill();</front>
<front id="MarlinH-170">void Stop();</front>
<front id="MarlinH-171"></front>
<front id="MarlinH-172">bool IsStopped();</front>
<front id="MarlinH-173"></front>
<front id="MarlinH-174">void enquecommand(const char *cmd); //put an ascii command at the end of the current buffer.</front>
<front id="MarlinH-175">void enquecommand_P(const char *cmd); //put an ascii command at the end of the current buffer, read from flash</front>
<front id="MarlinH-176">void prepare_arc_move(char isclockwise);</front>
<front id="MarlinH-177">void clamp_to_software_endstops(float target[3]);</front>
<front id="MarlinH-178"></front>
<front id="MarlinH-179">#ifdef FAST_PWM_FAN</front>
<front id="MarlinH-180">void setPwmFrequency(uint8_t pin, int val);</front>
<front id="MarlinH-181">#endif</front>
<front id="MarlinH-182"></front>
<front id="MarlinH-183">#ifndef CRITICAL_SECTION_START</front>
<front id="MarlinH-184">  #define CRITICAL_SECTION_START  unsigned char _sreg = SREG; cli();</front>
<front id="MarlinH-185">  #define CRITICAL_SECTION_END    SREG = _sreg;</front>
<front id="MarlinH-186">#endif //CRITICAL_SECTION_START</front>
<front id="MarlinH-187"></front>
<front id="MarlinH-188">extern float homing_feedrate[];</front>
<front id="MarlinH-189">extern bool axis_relative_modes[];</front>
<front id="MarlinH-190">extern int feedmultiply;</front>
<front id="MarlinH-191">extern int extrudemultiply; // Sets extrude multiply factor (in percent)</front>
<front id="MarlinH-192">extern float current_position[NUM_AXIS] ;</front>
<front id="MarlinH-193">extern float add_homeing[3];</front>
<front id="MarlinH-194">#ifdef DELTA</front>
<front id="MarlinH-195">extern float endstop_adj[3];</front>
<front id="MarlinH-196">#endif</front>
<front id="MarlinH-197">extern float min_pos[3];</front>
<front id="MarlinH-198">extern float max_pos[3];</front>
<front id="MarlinH-199">extern int fanSpeed;</front>
<front id="MarlinH-200">#ifdef BARICUDA</front>
<front id="MarlinH-201">extern int ValvePressure;</front>
<front id="MarlinH-202">extern int EtoPPressure;</front>
<front id="MarlinH-203">#endif</front>
<front id="MarlinH-204"></front>
<front id="MarlinH-205">#ifdef FAN_SOFT_PWM</front>
<front id="MarlinH-206">extern unsigned char fanSpeedSoftPwm;</front>
<front id="MarlinH-207">#endif</front>
<front id="MarlinH-208"></front>
<front id="MarlinH-209">#ifdef FWRETRACT</front>
<front id="MarlinH-210">extern bool autoretract_enabled;</front>
<front id="MarlinH-211">extern bool retracted;</front>
<front id="MarlinH-212">extern float retract_length, retract_feedrate, retract_zlift;</front>
<front id="MarlinH-213">extern float retract_recover_length, retract_recover_feedrate;</front>
<front id="MarlinH-214">#endif</front>
<front id="MarlinH-215"></front>
<front id="MarlinH-216">extern unsigned long starttime;</front>
<front id="MarlinH-217">extern unsigned long stoptime;</front>
<front id="MarlinH-218"></front>
<front id="MarlinH-219">// Handling multiple extruders pins</front>
<front id="MarlinH-220">extern uint8_t active_extruder;</front>
<front id="MarlinH-221"></front>
<front id="MarlinH-222">#endif</front>
 </pre>
<h1>Marlin_main.cpp</h1>
<pre  class="prettyprint linenums"><front id="Marlin_mainCPP-1">/* -*- c++ -*- */</front>
<front id="Marlin_mainCPP-2"></front>
<front id="Marlin_mainCPP-3">/*</front>
<front id="Marlin_mainCPP-4">    Reprap firmware based on Sprinter and grbl.</front>
<front id="Marlin_mainCPP-5"> Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm</front>
<front id="Marlin_mainCPP-6"></front>
<front id="Marlin_mainCPP-7"> This program is free software: you can redistribute it and/or modify</front>
<front id="Marlin_mainCPP-8"> it under the terms of the GNU General Public License as published by</front>
<front id="Marlin_mainCPP-9"> the Free Software Foundation, either version 3 of the License, or</front>
<front id="Marlin_mainCPP-10"> (at your option) any later version.</front>
<front id="Marlin_mainCPP-11"></front>
<front id="Marlin_mainCPP-12"> This program is distributed in the hope that it will be useful,</front>
<front id="Marlin_mainCPP-13"> but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Marlin_mainCPP-14"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Marlin_mainCPP-15"> GNU General Public License for more details.</front>
<front id="Marlin_mainCPP-16"></front>
<front id="Marlin_mainCPP-17"> You should have received a copy of the GNU General Public License</front>
<front id="Marlin_mainCPP-18"> along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Marlin_mainCPP-19"> */</front>
<front id="Marlin_mainCPP-20"></front>
<front id="Marlin_mainCPP-21">/*</front>
<front id="Marlin_mainCPP-22"> This firmware is a mashup between Sprinter and grbl.</front>
<front id="Marlin_mainCPP-23">  (https://github.com/kliment/Sprinter)</front>
<front id="Marlin_mainCPP-24">  (https://github.com/simen/grbl/tree)</front>
<front id="Marlin_mainCPP-25"></front>
<front id="Marlin_mainCPP-26"> It has preliminary support for Matthew Roberts advance algorithm</front>
<front id="Marlin_mainCPP-27">    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html</front>
<front id="Marlin_mainCPP-28"> */</front>
<front id="Marlin_mainCPP-29"></front>
<front id="Marlin_mainCPP-30">#include "Marlin.h"</front>
<front id="Marlin_mainCPP-31"></front>
<front id="Marlin_mainCPP-32">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-33">#include "vector_3.h"</front>
<front id="Marlin_mainCPP-34">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-35"></front>
<front id="Marlin_mainCPP-36">#include "ultralcd.h"</front>
<front id="Marlin_mainCPP-37">#include "planner.h"</front>
<front id="Marlin_mainCPP-38">#include "stepper.h"</front>
<front id="Marlin_mainCPP-39">#include "temperature.h"</front>
<front id="Marlin_mainCPP-40">#include "motion_control.h"</front>
<front id="Marlin_mainCPP-41">#include "cardreader.h"</front>
<front id="Marlin_mainCPP-42">#include "watchdog.h"</front>
<front id="Marlin_mainCPP-43">#include "ConfigurationStore.h"</front>
<front id="Marlin_mainCPP-44">#include "language.h"</front>
<front id="Marlin_mainCPP-45">#include "pins_arduino.h"</front>
<front id="Marlin_mainCPP-46"></front>
<front id="Marlin_mainCPP-47">#if NUM_SERVOS &gt; 0</front>
<front id="Marlin_mainCPP-48">#include "Servo.h"</front>
<front id="Marlin_mainCPP-49">#endif</front>
<front id="Marlin_mainCPP-50"></front>
<front id="Marlin_mainCPP-51">#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="Marlin_mainCPP-52">#include &lt;SPI.h&gt;</front>
<front id="Marlin_mainCPP-53">#endif</front>
<front id="Marlin_mainCPP-54"></front>
<front id="Marlin_mainCPP-55">#define VERSION_STRING  "1.0.0"</front>
<front id="Marlin_mainCPP-56"></front>
<front id="Marlin_mainCPP-57">// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html</front>
<front id="Marlin_mainCPP-58">// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes</front>
<front id="Marlin_mainCPP-59"></front>
<front id="Marlin_mainCPP-60">//Implemented Codes</front>
<front id="Marlin_mainCPP-61">//-------------------</front>
<front id="Marlin_mainCPP-62">// G0  -&gt; G1</front>
<front id="Marlin_mainCPP-63">// G1  - Coordinated Movement X Y Z E</front>
<front id="Marlin_mainCPP-64">// G2  - CW ARC</front>
<front id="Marlin_mainCPP-65">// G3  - CCW ARC</front>
<front id="Marlin_mainCPP-66">// G4  - Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</front>
<front id="Marlin_mainCPP-67">// G10 - retract filament according to settings of M207</front>
<front id="Marlin_mainCPP-68">// G11 - retract recover filament according to settings of M208</front>
<front id="Marlin_mainCPP-69">// G28 - Home all Axis</front>
<front id="Marlin_mainCPP-70">// G29 - Detailed Z-Probe, probes the bed at 3 points.  You must de at the home position for this to work correctly.</front>
<front id="Marlin_mainCPP-71">// G30 - Single Z Probe, probes bed at current XY location.</front>
<front id="Marlin_mainCPP-72">// G90 - Use Absolute Coordinates</front>
<front id="Marlin_mainCPP-73">// G91 - Use Relative Coordinates</front>
<front id="Marlin_mainCPP-74">// G92 - Set current position to cordinates given</front>
<front id="Marlin_mainCPP-75"></front>
<front id="Marlin_mainCPP-76">// M Codes</front>
<front id="Marlin_mainCPP-77">// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)</front>
<front id="Marlin_mainCPP-78">// M1   - Same as M0</front>
<front id="Marlin_mainCPP-79">// M17  - Enable/Power all stepper motors</front>
<front id="Marlin_mainCPP-80">// M18  - Disable all stepper motors; same as M84</front>
<front id="Marlin_mainCPP-81">// M20  - List SD card</front>
<front id="Marlin_mainCPP-82">// M21  - Init SD card</front>
<front id="Marlin_mainCPP-83">// M22  - Release SD card</front>
<front id="Marlin_mainCPP-84">// M23  - Select SD file (M23 filename.g)</front>
<front id="Marlin_mainCPP-85">// M24  - Start/resume SD print</front>
<front id="Marlin_mainCPP-86">// M25  - Pause SD print</front>
<front id="Marlin_mainCPP-87">// M26  - Set SD position in bytes (M26 S12345)</front>
<front id="Marlin_mainCPP-88">// M27  - Report SD print status</front>
<front id="Marlin_mainCPP-89">// M28  - Start SD write (M28 filename.g)</front>
<front id="Marlin_mainCPP-90">// M29  - Stop SD write</front>
<front id="Marlin_mainCPP-91">// M30  - Delete file from SD (M30 filename.g)</front>
<front id="Marlin_mainCPP-92">// M31  - Output time since last M109 or SD card start to serial</front>
<front id="Marlin_mainCPP-93">// M32  - Select file and start SD print (Can be used when printing from SD card)</front>
<front id="Marlin_mainCPP-94">// M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.</front>
<front id="Marlin_mainCPP-95">// M80  - Turn on Power Supply</front>
<front id="Marlin_mainCPP-96">// M81  - Turn off Power Supply</front>
<front id="Marlin_mainCPP-97">// M82  - Set E codes absolute (default)</front>
<front id="Marlin_mainCPP-98">// M83  - Set E codes relative while in Absolute Coordinates (G90) mode</front>
<front id="Marlin_mainCPP-99">// M84  - Disable steppers until next move,</front>
<front id="Marlin_mainCPP-100">//        or use S&lt;seconds&gt; to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.</front>
<front id="Marlin_mainCPP-101">// M85  - Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</front>
<front id="Marlin_mainCPP-102">// M92  - Set axis_steps_per_unit - same syntax as G92</front>
<front id="Marlin_mainCPP-103">// M104 - Set extruder target temp</front>
<front id="Marlin_mainCPP-104">// M105 - Read current temp</front>
<front id="Marlin_mainCPP-105">// M106 - Fan on</front>
<front id="Marlin_mainCPP-106">// M107 - Fan off</front>
<front id="Marlin_mainCPP-107">// M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-108">//        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-109">// M114 - Output current position to serial port</front>
<front id="Marlin_mainCPP-110">// M115 - Capabilities string</front>
<front id="Marlin_mainCPP-111">// M117 - display message</front>
<front id="Marlin_mainCPP-112">// M119 - Output Endstop status to serial port</front>
<front id="Marlin_mainCPP-113">// M126 - Solenoid Air Valve Open (BariCUDA support by jmil)</front>
<front id="Marlin_mainCPP-114">// M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)</front>
<front id="Marlin_mainCPP-115">// M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)</front>
<front id="Marlin_mainCPP-116">// M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)</front>
<front id="Marlin_mainCPP-117">// M140 - Set bed target temp</front>
<front id="Marlin_mainCPP-118">// M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-119">//        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-120">// M200 - Set filament diameter</front>
<front id="Marlin_mainCPP-121">// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</front>
<front id="Marlin_mainCPP-122">// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!</front>
<front id="Marlin_mainCPP-123">// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</front>
<front id="Marlin_mainCPP-124">// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate</front>
<front id="Marlin_mainCPP-125">// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk</front>
<front id="Marlin_mainCPP-126">// M206 - set additional homeing offset</front>
<front id="Marlin_mainCPP-127">// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]</front>
<front id="Marlin_mainCPP-128">// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]</front>
<front id="Marlin_mainCPP-129">// M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-130">// M218 - set hotend offset (in mm): T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-131">// M220 S&lt;factor in percent&gt;- set speed factor override percentage</front>
<front id="Marlin_mainCPP-132">// M221 S&lt;factor in percent&gt;- set extrude factor override percentage</front>
<front id="Marlin_mainCPP-133">// M240 - Trigger a camera to take a photograph</front>
<front id="Marlin_mainCPP-134">// M250 - Set LCD contrast C&lt;contrast value&gt; (value 0..63)</front>
<front id="Marlin_mainCPP-135">// M280 - set servo position absolute. P: servo index, S: angle or microseconds</front>
<front id="Marlin_mainCPP-136">// M300 - Play beepsound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</front>
<front id="Marlin_mainCPP-137">// M301 - Set PID parameters P I and D</front>
<front id="Marlin_mainCPP-138">// M302 - Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</front>
<front id="Marlin_mainCPP-139">// M303 - PID relay autotune S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</front>
<front id="Marlin_mainCPP-140">// M304 - Set bed PID parameters P I and D</front>
<front id="Marlin_mainCPP-141">// M400 - Finish all moves</front>
<front id="Marlin_mainCPP-142">// M401 - Lower z-probe if present</front>
<front id="Marlin_mainCPP-143">// M402 - Raise z-probe if present</front>
<front id="Marlin_mainCPP-144">// M500 - stores paramters in EEPROM</front>
<front id="Marlin_mainCPP-145">// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).</front>
<front id="Marlin_mainCPP-146">// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.</front>
<front id="Marlin_mainCPP-147">// M503 - print the current settings (from memory not from eeprom)</front>
<front id="Marlin_mainCPP-148">// M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-149">// M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</front>
<front id="Marlin_mainCPP-150">// M666 - set delta endstop adjustemnt</front>
<front id="Marlin_mainCPP-151">// M605 - Set dual x-carriage movement mode: S&lt;mode&gt; [ X&lt;duplication x-offset&gt; R&lt;duplication temp offset&gt; ]</front>
<front id="Marlin_mainCPP-152">// M907 - Set digital trimpot motor current using axis codes.</front>
<front id="Marlin_mainCPP-153">// M908 - Control digital trimpot directly.</front>
<front id="Marlin_mainCPP-154">// M350 - Set microstepping mode.</front>
<front id="Marlin_mainCPP-155">// M351 - Toggle MS1 MS2 pins directly.</front>
<front id="Marlin_mainCPP-156">// M928 - Start SD logging (M928 filename.g) - ended by M29</front>
<front id="Marlin_mainCPP-157">// M999 - Restart after being stopped by error</front>
<front id="Marlin_mainCPP-158"></front>
<front id="Marlin_mainCPP-159">//Stepper Movement Variables</front>
<front id="Marlin_mainCPP-160"></front>
<front id="Marlin_mainCPP-161">//===========================================================================</front>
<front id="Marlin_mainCPP-162">//=============================imported variables============================</front>
<front id="Marlin_mainCPP-163">//===========================================================================</front>
<front id="Marlin_mainCPP-164"></front>
<front id="Marlin_mainCPP-165"></front>
<front id="Marlin_mainCPP-166">//===========================================================================</front>
<front id="Marlin_mainCPP-167">//=============================public variables=============================</front>
<front id="Marlin_mainCPP-168">//===========================================================================</front>
<front id="Marlin_mainCPP-169">#ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-170">CardReader card;</front>
<front id="Marlin_mainCPP-171">#endif</front>
<front id="Marlin_mainCPP-172">float homing_feedrate[] = HOMING_FEEDRATE;</front>
<front id="Marlin_mainCPP-173">bool axis_relative_modes[] = AXIS_RELATIVE_MODES;</front>
<front id="Marlin_mainCPP-174">int feedmultiply=100; //100-&gt;1 200-&gt;2</front>
<front id="Marlin_mainCPP-175">int saved_feedmultiply;</front>
<front id="Marlin_mainCPP-176">int extrudemultiply=100; //100-&gt;1 200-&gt;2</front>
<front id="Marlin_mainCPP-177">float current_position[NUM_AXIS] = { 0.0, 0.0, 0.0, 0.0 };</front>
<front id="Marlin_mainCPP-178">float add_homeing[3]={0,0,0};</front>
<front id="Marlin_mainCPP-179">#ifdef DELTA</front>
<front id="Marlin_mainCPP-180">float endstop_adj[3]={0,0,0};</front>
<front id="Marlin_mainCPP-181">#endif</front>
<front id="Marlin_mainCPP-182">float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };</front>
<front id="Marlin_mainCPP-183">float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };</front>
<front id="Marlin_mainCPP-184"></front>
<front id="Marlin_mainCPP-185">// Extruder offset</front>
<front id="Marlin_mainCPP-186">#if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-187">#ifndef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-188">  #define NUM_EXTRUDER_OFFSETS 2 // only in XY plane</front>
<front id="Marlin_mainCPP-189">#else</front>
<front id="Marlin_mainCPP-190">  #define NUM_EXTRUDER_OFFSETS 3 // supports offsets in XYZ plane</front>
<front id="Marlin_mainCPP-191">#endif</front>
<front id="Marlin_mainCPP-192">float extruder_offset[NUM_EXTRUDER_OFFSETS][EXTRUDERS] = {</front>
<front id="Marlin_mainCPP-193">#if defined(EXTRUDER_OFFSET_X) && defined(EXTRUDER_OFFSET_Y)</front>
<front id="Marlin_mainCPP-194">  EXTRUDER_OFFSET_X, EXTRUDER_OFFSET_Y</front>
<front id="Marlin_mainCPP-195">#endif</front>
<front id="Marlin_mainCPP-196">};</front>
<front id="Marlin_mainCPP-197">#endif</front>
<front id="Marlin_mainCPP-198">uint8_t active_extruder = 0;</front>
<front id="Marlin_mainCPP-199">int fanSpeed=0;</front>
<front id="Marlin_mainCPP-200">#ifdef SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-201">  int servo_endstops[] = SERVO_ENDSTOPS;</front>
<front id="Marlin_mainCPP-202">  int servo_endstop_angles[] = SERVO_ENDSTOP_ANGLES;</front>
<front id="Marlin_mainCPP-203">#endif</front>
<front id="Marlin_mainCPP-204">#ifdef BARICUDA</front>
<front id="Marlin_mainCPP-205">int ValvePressure=0;</front>
<front id="Marlin_mainCPP-206">int EtoPPressure=0;</front>
<front id="Marlin_mainCPP-207">#endif</front>
<front id="Marlin_mainCPP-208"></front>
<front id="Marlin_mainCPP-209">#ifdef FWRETRACT</front>
<front id="Marlin_mainCPP-210">  bool autoretract_enabled=true;</front>
<front id="Marlin_mainCPP-211">  bool retracted=false;</front>
<front id="Marlin_mainCPP-212">  float retract_length=3, retract_feedrate=17*60, retract_zlift=0.8;</front>
<front id="Marlin_mainCPP-213">  float retract_recover_length=0, retract_recover_feedrate=8*60;</front>
<front id="Marlin_mainCPP-214">#endif</front>
<front id="Marlin_mainCPP-215"></front>
<front id="Marlin_mainCPP-216">#ifdef ULTIPANEL</front>
<front id="Marlin_mainCPP-217">	bool powersupply = true;</front>
<front id="Marlin_mainCPP-218">#endif</front>
<front id="Marlin_mainCPP-219"></front>
<front id="Marlin_mainCPP-220">#ifdef DELTA</front>
<front id="Marlin_mainCPP-221">float delta[3] = {0.0, 0.0, 0.0};</front>
<front id="Marlin_mainCPP-222">#endif</front>
<front id="Marlin_mainCPP-223"></front>
<front id="Marlin_mainCPP-224">//===========================================================================</front>
<front id="Marlin_mainCPP-225">//=============================private variables=============================</front>
<front id="Marlin_mainCPP-226">//===========================================================================</front>
<front id="Marlin_mainCPP-227">const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};</front>
<front id="Marlin_mainCPP-228">static float destination[NUM_AXIS] = {  0.0, 0.0, 0.0, 0.0};</front>
<front id="Marlin_mainCPP-229">static float offset[3] = {0.0, 0.0, 0.0};</front>
<front id="Marlin_mainCPP-230">static bool home_all_axis = true;</front>
<front id="Marlin_mainCPP-231">static float feedrate = 1500.0, next_feedrate, saved_feedrate;</front>
<front id="Marlin_mainCPP-232">static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;</front>
<front id="Marlin_mainCPP-233"></front>
<front id="Marlin_mainCPP-234">static bool relative_mode = false;  //Determines Absolute or Relative Coordinates</front>
<front id="Marlin_mainCPP-235"></front>
<front id="Marlin_mainCPP-236">static char cmdbuffer[BUFSIZE][MAX_CMD_SIZE];</front>
<front id="Marlin_mainCPP-237">static bool fromsd[BUFSIZE];</front>
<front id="Marlin_mainCPP-238">static int bufindr = 0;</front>
<front id="Marlin_mainCPP-239">static int bufindw = 0;</front>
<front id="Marlin_mainCPP-240">static int buflen = 0;</front>
<front id="Marlin_mainCPP-241">//static int i = 0;</front>
<front id="Marlin_mainCPP-242">static char serial_char;</front>
<front id="Marlin_mainCPP-243">static int serial_count = 0;</front>
<front id="Marlin_mainCPP-244">static boolean comment_mode = false;</front>
<front id="Marlin_mainCPP-245">static char *strchr_pointer; // just a pointer to find chars in the cmd string like X, Y, Z, E, etc</front>
<front id="Marlin_mainCPP-246"></front>
<front id="Marlin_mainCPP-247">const int sensitive_pins[] = SENSITIVE_PINS; // Sensitive pin list for M42</front>
<front id="Marlin_mainCPP-248"></front>
<front id="Marlin_mainCPP-249">//static float tt = 0;</front>
<front id="Marlin_mainCPP-250">//static float bt = 0;</front>
<front id="Marlin_mainCPP-251"></front>
<front id="Marlin_mainCPP-252">//Inactivity shutdown variables</front>
<front id="Marlin_mainCPP-253">static unsigned long previous_millis_cmd = 0;</front>
<front id="Marlin_mainCPP-254">static unsigned long max_inactive_time = 0;</front>
<front id="Marlin_mainCPP-255">static unsigned long stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME*1000l;</front>
<front id="Marlin_mainCPP-256"></front>
<front id="Marlin_mainCPP-257">unsigned long starttime=0;</front>
<front id="Marlin_mainCPP-258">unsigned long stoptime=0;</front>
<front id="Marlin_mainCPP-259"></front>
<front id="Marlin_mainCPP-260">static uint8_t tmp_extruder;</front>
<front id="Marlin_mainCPP-261"></front>
<front id="Marlin_mainCPP-262"></front>
<front id="Marlin_mainCPP-263">bool Stopped=false;</front>
<front id="Marlin_mainCPP-264"></front>
<front id="Marlin_mainCPP-265">#if NUM_SERVOS &gt; 0</front>
<front id="Marlin_mainCPP-266">  Servo servos[NUM_SERVOS];</front>
<front id="Marlin_mainCPP-267">#endif</front>
<front id="Marlin_mainCPP-268"></front>
<front id="Marlin_mainCPP-269">bool CooldownNoWait = true;</front>
<front id="Marlin_mainCPP-270">bool target_direction;</front>
<front id="Marlin_mainCPP-271"></front>
<front id="Marlin_mainCPP-272">//===========================================================================</front>
<front id="Marlin_mainCPP-273">//=============================ROUTINES=============================</front>
<front id="Marlin_mainCPP-274">//===========================================================================</front>
<front id="Marlin_mainCPP-275"></front>
<front id="Marlin_mainCPP-276">void get_arc_coordinates();</front>
<front id="Marlin_mainCPP-277">bool setTargetedHotend(int code);</front>
<front id="Marlin_mainCPP-278"></front>
<front id="Marlin_mainCPP-279">void serial_echopair_P(const char *s_P, float v)</front>
<front id="Marlin_mainCPP-280">    { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-281">void serial_echopair_P(const char *s_P, double v)</front>
<front id="Marlin_mainCPP-282">    { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-283">void serial_echopair_P(const char *s_P, unsigned long v)</front>
<front id="Marlin_mainCPP-284">    { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-285"></front>
<front id="Marlin_mainCPP-286">extern "C"{</front>
<front id="Marlin_mainCPP-287">  extern unsigned int __bss_end;</front>
<front id="Marlin_mainCPP-288">  extern unsigned int __heap_start;</front>
<front id="Marlin_mainCPP-289">  extern void *__brkval;</front>
<front id="Marlin_mainCPP-290"></front>
<front id="Marlin_mainCPP-291">  int freeMemory() {</front>
<front id="Marlin_mainCPP-292">    int free_memory;</front>
<front id="Marlin_mainCPP-293"></front>
<front id="Marlin_mainCPP-294">    if((int)__brkval == 0)</front>
<front id="Marlin_mainCPP-295">      free_memory = ((int)&free_memory) - ((int)&__bss_end);</front>
<front id="Marlin_mainCPP-296">    else</front>
<front id="Marlin_mainCPP-297">      free_memory = ((int)&free_memory) - ((int)__brkval);</front>
<front id="Marlin_mainCPP-298"></front>
<front id="Marlin_mainCPP-299">    return free_memory;</front>
<front id="Marlin_mainCPP-300">  }</front>
<front id="Marlin_mainCPP-301">}</front>
<front id="Marlin_mainCPP-302"></front>
<front id="Marlin_mainCPP-303">//adds an command to the main command buffer</front>
<front id="Marlin_mainCPP-304">//thats really done in a non-safe way.</front>
<front id="Marlin_mainCPP-305">//needs overworking someday</front>
<front id="Marlin_mainCPP-306">void enquecommand(const char *cmd)</front>
<front id="Marlin_mainCPP-307">{</front>
<front id="Marlin_mainCPP-308">  if(buflen &lt; BUFSIZE)</front>
<front id="Marlin_mainCPP-309">  {</front>
<front id="Marlin_mainCPP-310">    //this is dangerous if a mixing of serial and this happsens</front>
<front id="Marlin_mainCPP-311">    strcpy(&(cmdbuffer[bufindw][0]),cmd);</front>
<front id="Marlin_mainCPP-312">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-313">    SERIAL_ECHOPGM("enqueing \"");</front>
<front id="Marlin_mainCPP-314">    SERIAL_ECHO(cmdbuffer[bufindw]);</front>
<front id="Marlin_mainCPP-315">    SERIAL_ECHOLNPGM("\"");</front>
<front id="Marlin_mainCPP-316">    bufindw= (bufindw + 1)%BUFSIZE;</front>
<front id="Marlin_mainCPP-317">    buflen += 1;</front>
<front id="Marlin_mainCPP-318">  }</front>
<front id="Marlin_mainCPP-319">}</front>
<front id="Marlin_mainCPP-320"></front>
<front id="Marlin_mainCPP-321">void enquecommand_P(const char *cmd)</front>
<front id="Marlin_mainCPP-322">{</front>
<front id="Marlin_mainCPP-323">  if(buflen &lt; BUFSIZE)</front>
<front id="Marlin_mainCPP-324">  {</front>
<front id="Marlin_mainCPP-325">    //this is dangerous if a mixing of serial and this happsens</front>
<front id="Marlin_mainCPP-326">    strcpy_P(&(cmdbuffer[bufindw][0]),cmd);</front>
<front id="Marlin_mainCPP-327">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-328">    SERIAL_ECHOPGM("enqueing \"");</front>
<front id="Marlin_mainCPP-329">    SERIAL_ECHO(cmdbuffer[bufindw]);</front>
<front id="Marlin_mainCPP-330">    SERIAL_ECHOLNPGM("\"");</front>
<front id="Marlin_mainCPP-331">    bufindw= (bufindw + 1)%BUFSIZE;</front>
<front id="Marlin_mainCPP-332">    buflen += 1;</front>
<front id="Marlin_mainCPP-333">  }</front>
<front id="Marlin_mainCPP-334">}</front>
<front id="Marlin_mainCPP-335"></front>
<front id="Marlin_mainCPP-336">void setup_killpin()</front>
<front id="Marlin_mainCPP-337">{</front>
<front id="Marlin_mainCPP-338">  #if defined(KILL_PIN) && KILL_PIN &gt; -1</front>
<front id="Marlin_mainCPP-339">    pinMode(KILL_PIN,INPUT);</front>
<front id="Marlin_mainCPP-340">    WRITE(KILL_PIN,HIGH);</front>
<front id="Marlin_mainCPP-341">  #endif</front>
<front id="Marlin_mainCPP-342">}</front>
<front id="Marlin_mainCPP-343"></front>
<front id="Marlin_mainCPP-344">void setup_photpin()</front>
<front id="Marlin_mainCPP-345">{</front>
<front id="Marlin_mainCPP-346">  #if defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN &gt; -1</front>
<front id="Marlin_mainCPP-347">    SET_OUTPUT(PHOTOGRAPH_PIN);</front>
<front id="Marlin_mainCPP-348">    WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-349">  #endif</front>
<front id="Marlin_mainCPP-350">}</front>
<front id="Marlin_mainCPP-351"></front>
<front id="Marlin_mainCPP-352">void setup_powerhold()</front>
<front id="Marlin_mainCPP-353">{</front>
<front id="Marlin_mainCPP-354">  #if defined(SUICIDE_PIN) && SUICIDE_PIN &gt; -1</front>
<front id="Marlin_mainCPP-355">    SET_OUTPUT(SUICIDE_PIN);</front>
<front id="Marlin_mainCPP-356">    WRITE(SUICIDE_PIN, HIGH);</front>
<front id="Marlin_mainCPP-357">  #endif</front>
<front id="Marlin_mainCPP-358">  #if defined(PS_ON_PIN) && PS_ON_PIN &gt; -1</front>
<front id="Marlin_mainCPP-359">    SET_OUTPUT(PS_ON_PIN);</front>
<front id="Marlin_mainCPP-360">    WRITE(PS_ON_PIN, PS_ON_AWAKE);</front>
<front id="Marlin_mainCPP-361">  #endif</front>
<front id="Marlin_mainCPP-362">}</front>
<front id="Marlin_mainCPP-363"></front>
<front id="Marlin_mainCPP-364">void suicide()</front>
<front id="Marlin_mainCPP-365">{</front>
<front id="Marlin_mainCPP-366">  #if defined(SUICIDE_PIN) && SUICIDE_PIN &gt; -1</front>
<front id="Marlin_mainCPP-367">    SET_OUTPUT(SUICIDE_PIN);</front>
<front id="Marlin_mainCPP-368">    WRITE(SUICIDE_PIN, LOW);</front>
<front id="Marlin_mainCPP-369">  #endif</front>
<front id="Marlin_mainCPP-370">}</front>
<front id="Marlin_mainCPP-371"></front>
<front id="Marlin_mainCPP-372">void servo_init()</front>
<front id="Marlin_mainCPP-373">{</front>
<front id="Marlin_mainCPP-374">  #if (NUM_SERVOS &gt;= 1) && defined(SERVO0_PIN) && (SERVO0_PIN &gt; -1)</front>
<front id="Marlin_mainCPP-375">    servos[0].attach(SERVO0_PIN);</front>
<front id="Marlin_mainCPP-376">  #endif</front>
<front id="Marlin_mainCPP-377">  #if (NUM_SERVOS &gt;= 2) && defined(SERVO1_PIN) && (SERVO1_PIN &gt; -1)</front>
<front id="Marlin_mainCPP-378">    servos[1].attach(SERVO1_PIN);</front>
<front id="Marlin_mainCPP-379">  #endif</front>
<front id="Marlin_mainCPP-380">  #if (NUM_SERVOS &gt;= 3) && defined(SERVO2_PIN) && (SERVO2_PIN &gt; -1)</front>
<front id="Marlin_mainCPP-381">    servos[2].attach(SERVO2_PIN);</front>
<front id="Marlin_mainCPP-382">  #endif</front>
<front id="Marlin_mainCPP-383">  #if (NUM_SERVOS &gt;= 4) && defined(SERVO3_PIN) && (SERVO3_PIN &gt; -1)</front>
<front id="Marlin_mainCPP-384">    servos[3].attach(SERVO3_PIN);</front>
<front id="Marlin_mainCPP-385">  #endif</front>
<front id="Marlin_mainCPP-386">  #if (NUM_SERVOS &gt;= 5)</front>
<front id="Marlin_mainCPP-387">    #error "TODO: enter initalisation code for more servos"</front>
<front id="Marlin_mainCPP-388">  #endif</front>
<front id="Marlin_mainCPP-389"></front>
<front id="Marlin_mainCPP-390">  // Set position of Servo Endstops that are defined</front>
<front id="Marlin_mainCPP-391">  #ifdef SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-392">  for(int8_t i = 0; i &lt; 3; i++)</front>
<front id="Marlin_mainCPP-393">  {</front>
<front id="Marlin_mainCPP-394">    if(servo_endstops[i] &gt; -1) {</front>
<front id="Marlin_mainCPP-395">      servos[servo_endstops[i]].write(servo_endstop_angles[i * 2 + 1]);</front>
<front id="Marlin_mainCPP-396">    }</front>
<front id="Marlin_mainCPP-397">  }</front>
<front id="Marlin_mainCPP-398">  #endif</front>
<front id="Marlin_mainCPP-399"></front>
<front id="Marlin_mainCPP-400">  #if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-401">  delay(PROBE_SERVO_DEACTIVATION_DELAY);</front>
<front id="Marlin_mainCPP-402">  servos[servo_endstops[Z_AXIS]].detach();  </front>
<front id="Marlin_mainCPP-403">  #endif</front>
<front id="Marlin_mainCPP-404">}</front>
<front id="Marlin_mainCPP-405"></front>
<front id="Marlin_mainCPP-406">void setup()</front>
<front id="Marlin_mainCPP-407">{</front>
<front id="Marlin_mainCPP-408">  setup_killpin();</front>
<front id="Marlin_mainCPP-409">  setup_powerhold();</front>
<front id="Marlin_mainCPP-410">  MYSERIAL.begin(BAUDRATE);</front>
<front id="Marlin_mainCPP-411">  SERIAL_PROTOCOLLNPGM("start");</front>
<front id="Marlin_mainCPP-412">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-413"></front>
<front id="Marlin_mainCPP-414">  // Check startup - does nothing if bootloader sets MCUSR to 0</front>
<front id="Marlin_mainCPP-415">  byte mcu = MCUSR;</front>
<front id="Marlin_mainCPP-416">  if(mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);</front>
<front id="Marlin_mainCPP-417">  if(mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);</front>
<front id="Marlin_mainCPP-418">  if(mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);</front>
<front id="Marlin_mainCPP-419">  if(mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);</front>
<front id="Marlin_mainCPP-420">  if(mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);</front>
<front id="Marlin_mainCPP-421">  MCUSR=0;</front>
<front id="Marlin_mainCPP-422"></front>
<front id="Marlin_mainCPP-423">  SERIAL_ECHOPGM(MSG_MARLIN);</front>
<front id="Marlin_mainCPP-424">  SERIAL_ECHOLNPGM(VERSION_STRING);</front>
<front id="Marlin_mainCPP-425">  #ifdef STRING_VERSION_CONFIG_H</front>
<front id="Marlin_mainCPP-426">    #ifdef STRING_CONFIG_H_AUTHOR</front>
<front id="Marlin_mainCPP-427">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-428">      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);</front>
<front id="Marlin_mainCPP-429">      SERIAL_ECHOPGM(STRING_VERSION_CONFIG_H);</front>
<front id="Marlin_mainCPP-430">      SERIAL_ECHOPGM(MSG_AUTHOR);</front>
<front id="Marlin_mainCPP-431">      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);</front>
<front id="Marlin_mainCPP-432">      SERIAL_ECHOPGM("Compiled: ");</front>
<front id="Marlin_mainCPP-433">      SERIAL_ECHOLNPGM(__DATE__);</front>
<front id="Marlin_mainCPP-434">    #endif</front>
<front id="Marlin_mainCPP-435">  #endif</front>
<front id="Marlin_mainCPP-436">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-437">  SERIAL_ECHOPGM(MSG_FREE_MEMORY);</front>
<front id="Marlin_mainCPP-438">  SERIAL_ECHO(freeMemory());</front>
<front id="Marlin_mainCPP-439">  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);</front>
<front id="Marlin_mainCPP-440">  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);</front>
<front id="Marlin_mainCPP-441">  for(int8_t i = 0; i &lt; BUFSIZE; i++)</front>
<front id="Marlin_mainCPP-442">  {</front>
<front id="Marlin_mainCPP-443">    fromsd[i] = false;</front>
<front id="Marlin_mainCPP-444">  }</front>
<front id="Marlin_mainCPP-445"></front>
<front id="Marlin_mainCPP-446">  // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)</front>
<front id="Marlin_mainCPP-447">  Config_RetrieveSettings();</front>
<front id="Marlin_mainCPP-448"></front>
<front id="Marlin_mainCPP-449">  tp_init();    // Initialize temperature loop</front>
<front id="Marlin_mainCPP-450">  plan_init();  // Initialize planner;</front>
<front id="Marlin_mainCPP-451">  watchdog_init();</front>
<front id="Marlin_mainCPP-452">  st_init();    // Initialize stepper, this enables interrupts!</front>
<front id="Marlin_mainCPP-453">  setup_photpin();</front>
<front id="Marlin_mainCPP-454">  servo_init();</front>
<front id="Marlin_mainCPP-455"></front>
<front id="Marlin_mainCPP-456">  lcd_init();</front>
<front id="Marlin_mainCPP-457">  _delay_ms(1000);	// wait 1sec to display the splash screen</front>
<front id="Marlin_mainCPP-458"></front>
<front id="Marlin_mainCPP-459">  #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-460">    SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan</front>
<front id="Marlin_mainCPP-461">  #endif</front>
<front id="Marlin_mainCPP-462">}</front>
<front id="Marlin_mainCPP-463"></front>
<front id="Marlin_mainCPP-464"></front>
<front id="Marlin_mainCPP-465">void loop()</front>
<front id="Marlin_mainCPP-466">{</front>
<front id="Marlin_mainCPP-467">  if(buflen &lt; (BUFSIZE-1))</front>
<front id="Marlin_mainCPP-468">    get_command();</front>
<front id="Marlin_mainCPP-469">  #ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-470">  card.checkautostart(false);</front>
<front id="Marlin_mainCPP-471">  #endif</front>
<front id="Marlin_mainCPP-472">  if(buflen)</front>
<front id="Marlin_mainCPP-473">  {</front>
<front id="Marlin_mainCPP-474">    #ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-475">      if(card.saving)</front>
<front id="Marlin_mainCPP-476">      {</front>
<front id="Marlin_mainCPP-477">        if(strstr_P(cmdbuffer[bufindr], PSTR("M29")) == NULL)</front>
<front id="Marlin_mainCPP-478">        {</front>
<front id="Marlin_mainCPP-479">          card.write_command(cmdbuffer[bufindr]);</front>
<front id="Marlin_mainCPP-480">          if(card.logging)</front>
<front id="Marlin_mainCPP-481">          {</front>
<front id="Marlin_mainCPP-482">            process_commands();</front>
<front id="Marlin_mainCPP-483">          }</front>
<front id="Marlin_mainCPP-484">          else</front>
<front id="Marlin_mainCPP-485">          {</front>
<front id="Marlin_mainCPP-486">            SERIAL_PROTOCOLLNPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-487">          }</front>
<front id="Marlin_mainCPP-488">        }</front>
<front id="Marlin_mainCPP-489">        else</front>
<front id="Marlin_mainCPP-490">        {</front>
<front id="Marlin_mainCPP-491">          card.closefile();</front>
<front id="Marlin_mainCPP-492">          SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);</front>
<front id="Marlin_mainCPP-493">        }</front>
<front id="Marlin_mainCPP-494">      }</front>
<front id="Marlin_mainCPP-495">      else</front>
<front id="Marlin_mainCPP-496">      {</front>
<front id="Marlin_mainCPP-497">        process_commands();</front>
<front id="Marlin_mainCPP-498">      }</front>
<front id="Marlin_mainCPP-499">    #else</front>
<front id="Marlin_mainCPP-500">      process_commands();</front>
<front id="Marlin_mainCPP-501">    #endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-502">    buflen = (buflen-1);</front>
<front id="Marlin_mainCPP-503">    bufindr = (bufindr + 1)%BUFSIZE;</front>
<front id="Marlin_mainCPP-504">  }</front>
<front id="Marlin_mainCPP-505">  //check heater every n milliseconds</front>
<front id="Marlin_mainCPP-506">  manage_heater();</front>
<front id="Marlin_mainCPP-507">  manage_inactivity();</front>
<front id="Marlin_mainCPP-508">  checkHitEndstops();</front>
<front id="Marlin_mainCPP-509">  lcd_update();</front>
<front id="Marlin_mainCPP-510">}</front>
<front id="Marlin_mainCPP-511"></front>
<front id="Marlin_mainCPP-512">void get_command()</front>
<front id="Marlin_mainCPP-513">{</front>
<front id="Marlin_mainCPP-514">  while( MYSERIAL.available() &gt; 0  && buflen &lt; BUFSIZE) {</front>
<front id="Marlin_mainCPP-515">    serial_char = MYSERIAL.read();</front>
<front id="Marlin_mainCPP-516">    if(serial_char == '\n' ||</front>
<front id="Marlin_mainCPP-517">       serial_char == '\r' ||</front>
<front id="Marlin_mainCPP-518">       (serial_char == ':' && comment_mode == false) ||</front>
<front id="Marlin_mainCPP-519">       serial_count &gt;= (MAX_CMD_SIZE - 1) )</front>
<front id="Marlin_mainCPP-520">    {</front>
<front id="Marlin_mainCPP-521">      if(!serial_count) { //if empty line</front>
<front id="Marlin_mainCPP-522">        comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-523">        return;</front>
<front id="Marlin_mainCPP-524">      }</front>
<front id="Marlin_mainCPP-525">      cmdbuffer[bufindw][serial_count] = 0; //terminate string</front>
<front id="Marlin_mainCPP-526">      if(!comment_mode){</front>
<front id="Marlin_mainCPP-527">        comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-528">        fromsd[bufindw] = false;</front>
<front id="Marlin_mainCPP-529">        if(strchr(cmdbuffer[bufindw], 'N') != NULL)</front>
<front id="Marlin_mainCPP-530">        {</front>
<front id="Marlin_mainCPP-531">          strchr_pointer = strchr(cmdbuffer[bufindw], 'N');</front>
<front id="Marlin_mainCPP-532">          gcode_N = (strtol(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL, 10));</front>
<front id="Marlin_mainCPP-533">          if(gcode_N != gcode_LastN+1 && (strstr_P(cmdbuffer[bufindw], PSTR("M110")) == NULL) ) {</front>
<front id="Marlin_mainCPP-534">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-535">            SERIAL_ERRORPGM(MSG_ERR_LINE_NO);</front>
<front id="Marlin_mainCPP-536">            SERIAL_ERRORLN(gcode_LastN);</front>
<front id="Marlin_mainCPP-537">            //Serial.println(gcode_N);</front>
<front id="Marlin_mainCPP-538">            FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-539">            serial_count = 0;</front>
<front id="Marlin_mainCPP-540">            return;</front>
<front id="Marlin_mainCPP-541">          }</front>
<front id="Marlin_mainCPP-542"></front>
<front id="Marlin_mainCPP-543">          if(strchr(cmdbuffer[bufindw], '*') != NULL)</front>
<front id="Marlin_mainCPP-544">          {</front>
<front id="Marlin_mainCPP-545">            byte checksum = 0;</front>
<front id="Marlin_mainCPP-546">            byte count = 0;</front>
<front id="Marlin_mainCPP-547">            while(cmdbuffer[bufindw][count] != '*') checksum = checksum^cmdbuffer[bufindw][count++];</front>
<front id="Marlin_mainCPP-548">            strchr_pointer = strchr(cmdbuffer[bufindw], '*');</front>
<front id="Marlin_mainCPP-549"></front>
<front id="Marlin_mainCPP-550">            if( (int)(strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)) != checksum) {</front>
<front id="Marlin_mainCPP-551">              SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-552">              SERIAL_ERRORPGM(MSG_ERR_CHECKSUM_MISMATCH);</front>
<front id="Marlin_mainCPP-553">              SERIAL_ERRORLN(gcode_LastN);</front>
<front id="Marlin_mainCPP-554">              FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-555">              serial_count = 0;</front>
<front id="Marlin_mainCPP-556">              return;</front>
<front id="Marlin_mainCPP-557">            }</front>
<front id="Marlin_mainCPP-558">            //if no errors, continue parsing</front>
<front id="Marlin_mainCPP-559">          }</front>
<front id="Marlin_mainCPP-560">          else</front>
<front id="Marlin_mainCPP-561">          {</front>
<front id="Marlin_mainCPP-562">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-563">            SERIAL_ERRORPGM(MSG_ERR_NO_CHECKSUM);</front>
<front id="Marlin_mainCPP-564">            SERIAL_ERRORLN(gcode_LastN);</front>
<front id="Marlin_mainCPP-565">            FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-566">            serial_count = 0;</front>
<front id="Marlin_mainCPP-567">            return;</front>
<front id="Marlin_mainCPP-568">          }</front>
<front id="Marlin_mainCPP-569"></front>
<front id="Marlin_mainCPP-570">          gcode_LastN = gcode_N;</front>
<front id="Marlin_mainCPP-571">          //if no errors, continue parsing</front>
<front id="Marlin_mainCPP-572">        }</front>
<front id="Marlin_mainCPP-573">        else  // if we don't receive 'N' but still see '*'</front>
<front id="Marlin_mainCPP-574">        {</front>
<front id="Marlin_mainCPP-575">          if((strchr(cmdbuffer[bufindw], '*') != NULL))</front>
<front id="Marlin_mainCPP-576">          {</front>
<front id="Marlin_mainCPP-577">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-578">            SERIAL_ERRORPGM(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM);</front>
<front id="Marlin_mainCPP-579">            SERIAL_ERRORLN(gcode_LastN);</front>
<front id="Marlin_mainCPP-580">            serial_count = 0;</front>
<front id="Marlin_mainCPP-581">            return;</front>
<front id="Marlin_mainCPP-582">          }</front>
<front id="Marlin_mainCPP-583">        }</front>
<front id="Marlin_mainCPP-584">        if((strchr(cmdbuffer[bufindw], 'G') != NULL)){</front>
<front id="Marlin_mainCPP-585">          strchr_pointer = strchr(cmdbuffer[bufindw], 'G');</front>
<front id="Marlin_mainCPP-586">          switch((int)((strtod(&cmdbuffer[bufindw][strchr_pointer - cmdbuffer[bufindw] + 1], NULL)))){</front>
<front id="Marlin_mainCPP-587">          case 0:</front>
<front id="Marlin_mainCPP-588">          case 1:</front>
<front id="Marlin_mainCPP-589">          case 2:</front>
<front id="Marlin_mainCPP-590">          case 3:</front>
<front id="Marlin_mainCPP-591">            if(Stopped == false) { // If printer is stopped by an error the G[0-3] codes are ignored.</front>
<front id="Marlin_mainCPP-592">          #ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-593">              if(card.saving)</front>
<front id="Marlin_mainCPP-594">                break;</front>
<front id="Marlin_mainCPP-595">          #endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-596">              SERIAL_PROTOCOLLNPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-597">            }</front>
<front id="Marlin_mainCPP-598">            else {</front>
<front id="Marlin_mainCPP-599">              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);</front>
<front id="Marlin_mainCPP-600">              LCD_MESSAGEPGM(MSG_STOPPED);</front>
<front id="Marlin_mainCPP-601">            }</front>
<front id="Marlin_mainCPP-602">            break;</front>
<front id="Marlin_mainCPP-603">          default:</front>
<front id="Marlin_mainCPP-604">            break;</front>
<front id="Marlin_mainCPP-605">          }</front>
<front id="Marlin_mainCPP-606"></front>
<front id="Marlin_mainCPP-607">        }</front>
<front id="Marlin_mainCPP-608">        bufindw = (bufindw + 1)%BUFSIZE;</front>
<front id="Marlin_mainCPP-609">        buflen += 1;</front>
<front id="Marlin_mainCPP-610">      }</front>
<front id="Marlin_mainCPP-611">      serial_count = 0; //clear buffer</front>
<front id="Marlin_mainCPP-612">    }</front>
<front id="Marlin_mainCPP-613">    else</front>
<front id="Marlin_mainCPP-614">    {</front>
<front id="Marlin_mainCPP-615">      if(serial_char == ';') comment_mode = true;</front>
<front id="Marlin_mainCPP-616">      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-617">    }</front>
<front id="Marlin_mainCPP-618">  }</front>
<front id="Marlin_mainCPP-619">  #ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-620">  if(!card.sdprinting || serial_count!=0){</front>
<front id="Marlin_mainCPP-621">    return;</front>
<front id="Marlin_mainCPP-622">  }</front>
<front id="Marlin_mainCPP-623">  while( !card.eof()  && buflen &lt; BUFSIZE) {</front>
<front id="Marlin_mainCPP-624">    int16_t n=card.get();</front>
<front id="Marlin_mainCPP-625">    serial_char = (char)n;</front>
<front id="Marlin_mainCPP-626">    if(serial_char == '\n' ||</front>
<front id="Marlin_mainCPP-627">       serial_char == '\r' ||</front>
<front id="Marlin_mainCPP-628">       (serial_char == ':' && comment_mode == false) ||</front>
<front id="Marlin_mainCPP-629">       serial_count &gt;= (MAX_CMD_SIZE - 1)||n==-1)</front>
<front id="Marlin_mainCPP-630">    {</front>
<front id="Marlin_mainCPP-631">      if(card.eof()){</front>
<front id="Marlin_mainCPP-632">        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);</front>
<front id="Marlin_mainCPP-633">        stoptime=millis();</front>
<front id="Marlin_mainCPP-634">        char time[30];</front>
<front id="Marlin_mainCPP-635">        unsigned long t=(stoptime-starttime)/1000;</front>
<front id="Marlin_mainCPP-636">        int hours, minutes;</front>
<front id="Marlin_mainCPP-637">        minutes=(t/60)%60;</front>
<front id="Marlin_mainCPP-638">        hours=t/60/60;</front>
<front id="Marlin_mainCPP-639">        sprintf_P(time, PSTR("%i hours %i minutes"),hours, minutes);</front>
<front id="Marlin_mainCPP-640">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-641">        SERIAL_ECHOLN(time);</front>
<front id="Marlin_mainCPP-642">        lcd_setstatus(time);</front>
<front id="Marlin_mainCPP-643">        card.printingHasFinished();</front>
<front id="Marlin_mainCPP-644">        card.checkautostart(true);</front>
<front id="Marlin_mainCPP-645"></front>
<front id="Marlin_mainCPP-646">      }</front>
<front id="Marlin_mainCPP-647">      if(!serial_count)</front>
<front id="Marlin_mainCPP-648">      {</front>
<front id="Marlin_mainCPP-649">        comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-650">        return; //if empty line</front>
<front id="Marlin_mainCPP-651">      }</front>
<front id="Marlin_mainCPP-652">      cmdbuffer[bufindw][serial_count] = 0; //terminate string</front>
<front id="Marlin_mainCPP-653">//      if(!comment_mode){</front>
<front id="Marlin_mainCPP-654">        fromsd[bufindw] = true;</front>
<front id="Marlin_mainCPP-655">        buflen += 1;</front>
<front id="Marlin_mainCPP-656">        bufindw = (bufindw + 1)%BUFSIZE;</front>
<front id="Marlin_mainCPP-657">//      }</front>
<front id="Marlin_mainCPP-658">      comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-659">      serial_count = 0; //clear buffer</front>
<front id="Marlin_mainCPP-660">    }</front>
<front id="Marlin_mainCPP-661">    else</front>
<front id="Marlin_mainCPP-662">    {</front>
<front id="Marlin_mainCPP-663">      if(serial_char == ';') comment_mode = true;</front>
<front id="Marlin_mainCPP-664">      if(!comment_mode) cmdbuffer[bufindw][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-665">    }</front>
<front id="Marlin_mainCPP-666">  }</front>
<front id="Marlin_mainCPP-667"></front>
<front id="Marlin_mainCPP-668">  #endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-669"></front>
<front id="Marlin_mainCPP-670">}</front>
<front id="Marlin_mainCPP-671"></front>
<front id="Marlin_mainCPP-672"></front>
<front id="Marlin_mainCPP-673">float code_value()</front>
<front id="Marlin_mainCPP-674">{</front>
<front id="Marlin_mainCPP-675">  return (strtod(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL));</front>
<front id="Marlin_mainCPP-676">}</front>
<front id="Marlin_mainCPP-677"></front>
<front id="Marlin_mainCPP-678">long code_value_long()</front>
<front id="Marlin_mainCPP-679">{</front>
<front id="Marlin_mainCPP-680">  return (strtol(&cmdbuffer[bufindr][strchr_pointer - cmdbuffer[bufindr] + 1], NULL, 10));</front>
<front id="Marlin_mainCPP-681">}</front>
<front id="Marlin_mainCPP-682"></front>
<front id="Marlin_mainCPP-683">bool code_seen(char code)</front>
<front id="Marlin_mainCPP-684">{</front>
<front id="Marlin_mainCPP-685">  strchr_pointer = strchr(cmdbuffer[bufindr], code);</front>
<front id="Marlin_mainCPP-686">  return (strchr_pointer != NULL);  //Return True if a character was found</front>
<front id="Marlin_mainCPP-687">}</front>
<front id="Marlin_mainCPP-688"></front>
<front id="Marlin_mainCPP-689">#define DEFINE_PGM_READ_ANY(type, reader)       \</front>
<front id="Marlin_mainCPP-690">    static inline type pgm_read_any(const type *p)  \</front>
<front id="Marlin_mainCPP-691">    { return pgm_read_##reader##_near(p); }</front>
<front id="Marlin_mainCPP-692"></front>
<front id="Marlin_mainCPP-693">DEFINE_PGM_READ_ANY(float,       float);</front>
<front id="Marlin_mainCPP-694">DEFINE_PGM_READ_ANY(signed char, byte);</front>
<front id="Marlin_mainCPP-695"></front>
<front id="Marlin_mainCPP-696">#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \</front>
<front id="Marlin_mainCPP-697">static const PROGMEM type array##_P[3] =        \</front>
<front id="Marlin_mainCPP-698">    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \</front>
<front id="Marlin_mainCPP-699">static inline type array(int axis)          \</front>
<front id="Marlin_mainCPP-700">    { return pgm_read_any(&array##_P[axis]); }</front>
<front id="Marlin_mainCPP-701"></front>
<front id="Marlin_mainCPP-702">XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,    MIN_POS);</front>
<front id="Marlin_mainCPP-703">XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);</front>
<front id="Marlin_mainCPP-704">XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);</front>
<front id="Marlin_mainCPP-705">XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);</front>
<front id="Marlin_mainCPP-706">XYZ_CONSTS_FROM_CONFIG(float, home_retract_mm, HOME_RETRACT_MM);</front>
<front id="Marlin_mainCPP-707">XYZ_CONSTS_FROM_CONFIG(signed char, home_dir,  HOME_DIR);</front>
<front id="Marlin_mainCPP-708"></front>
<front id="Marlin_mainCPP-709">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-710">  #if EXTRUDERS == 1 || defined(COREXY) \</front>
<front id="Marlin_mainCPP-711">      || !defined(X2_ENABLE_PIN) || !defined(X2_STEP_PIN) || !defined(X2_DIR_PIN) \</front>
<front id="Marlin_mainCPP-712">      || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \</front>
<front id="Marlin_mainCPP-713">      || !defined(X_MAX_PIN) || X_MAX_PIN &lt; 0</front>
<front id="Marlin_mainCPP-714">    #error "Missing or invalid definitions for DUAL_X_CARRIAGE mode."</front>
<front id="Marlin_mainCPP-715">  #endif</front>
<front id="Marlin_mainCPP-716">  #if X_HOME_DIR != -1 || X2_HOME_DIR != 1</front>
<front id="Marlin_mainCPP-717">    #error "Please use canonical x-carriage assignment" // the x-carriages are defined by their homing directions</front>
<front id="Marlin_mainCPP-718">  #endif  </front>
<front id="Marlin_mainCPP-719"></front>
<front id="Marlin_mainCPP-720">#define DXC_FULL_CONTROL_MODE 0</front>
<front id="Marlin_mainCPP-721">#define DXC_AUTO_PARK_MODE    1</front>
<front id="Marlin_mainCPP-722">#define DXC_DUPLICATION_MODE  2</front>
<front id="Marlin_mainCPP-723">static int dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;</front>
<front id="Marlin_mainCPP-724"> </front>
<front id="Marlin_mainCPP-725">static float x_home_pos(int extruder) {</front>
<front id="Marlin_mainCPP-726">  if (extruder == 0)</front>
<front id="Marlin_mainCPP-727">    return base_home_pos(X_AXIS) + add_homeing[X_AXIS];</front>
<front id="Marlin_mainCPP-728">  else</front>
<front id="Marlin_mainCPP-729">    // In dual carriage mode the extruder offset provides an override of the</front>
<front id="Marlin_mainCPP-730">    // second X-carriage offset when homed - otherwise X2_HOME_POS is used.</front>
<front id="Marlin_mainCPP-731">    // This allow soft recalibration of the second extruder offset position without firmware reflash</front>
<front id="Marlin_mainCPP-732">    // (through the M218 command).</front>
<front id="Marlin_mainCPP-733">    return (extruder_offset[X_AXIS][1] &gt; 0) ? extruder_offset[X_AXIS][1] : X2_HOME_POS;</front>
<front id="Marlin_mainCPP-734">}</front>
<front id="Marlin_mainCPP-735"></front>
<front id="Marlin_mainCPP-736">static int x_home_dir(int extruder) {</front>
<front id="Marlin_mainCPP-737">  return (extruder == 0) ? X_HOME_DIR : X2_HOME_DIR;</front>
<front id="Marlin_mainCPP-738">}</front>
<front id="Marlin_mainCPP-739"></front>
<front id="Marlin_mainCPP-740">static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1</front>
<front id="Marlin_mainCPP-741">static bool active_extruder_parked = false; // used in mode 1 & 2</front>
<front id="Marlin_mainCPP-742">static float raised_parked_position[NUM_AXIS]; // used in mode 1 </front>
<front id="Marlin_mainCPP-743">static unsigned long delayed_move_time = 0; // used in mode 1 </front>
<front id="Marlin_mainCPP-744">static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2</front>
<front id="Marlin_mainCPP-745">static float duplicate_extruder_temp_offset = 0; // used in mode 2</front>
<front id="Marlin_mainCPP-746">bool extruder_duplication_enabled = false; // used in mode 2</front>
<front id="Marlin_mainCPP-747">#endif //DUAL_X_CARRIAGE    </front>
<front id="Marlin_mainCPP-748"></front>
<front id="Marlin_mainCPP-749">static void axis_is_at_home(int axis) {</front>
<front id="Marlin_mainCPP-750">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-751">  if (axis == X_AXIS) {</front>
<front id="Marlin_mainCPP-752">    if (active_extruder != 0) {</front>
<front id="Marlin_mainCPP-753">      current_position[X_AXIS] = x_home_pos(active_extruder);</front>
<front id="Marlin_mainCPP-754">      min_pos[X_AXIS] =          X2_MIN_POS;</front>
<front id="Marlin_mainCPP-755">      max_pos[X_AXIS] =          max(extruder_offset[X_AXIS][1], X2_MAX_POS);</front>
<front id="Marlin_mainCPP-756">      return;</front>
<front id="Marlin_mainCPP-757">    }</front>
<front id="Marlin_mainCPP-758">    else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {</front>
<front id="Marlin_mainCPP-759">      current_position[X_AXIS] = base_home_pos(X_AXIS) + add_homeing[X_AXIS];</front>
<front id="Marlin_mainCPP-760">      min_pos[X_AXIS] =          base_min_pos(X_AXIS) + add_homeing[X_AXIS]; </front>
<front id="Marlin_mainCPP-761">      max_pos[X_AXIS] =          min(base_max_pos(X_AXIS) + add_homeing[X_AXIS], </front>
<front id="Marlin_mainCPP-762">                                  max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);</front>
<front id="Marlin_mainCPP-763">      return;</front>
<front id="Marlin_mainCPP-764">    }</front>
<front id="Marlin_mainCPP-765">  }</front>
<front id="Marlin_mainCPP-766">#endif</front>
<front id="Marlin_mainCPP-767">  current_position[axis] = base_home_pos(axis) + add_homeing[axis];</front>
<front id="Marlin_mainCPP-768">  min_pos[axis] =          base_min_pos(axis) + add_homeing[axis];</front>
<front id="Marlin_mainCPP-769">  max_pos[axis] =          base_max_pos(axis) + add_homeing[axis];</front>
<front id="Marlin_mainCPP-770">}</front>
<front id="Marlin_mainCPP-771"></front>
<front id="Marlin_mainCPP-772">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-773">static void set_bed_level_equation(float z_at_xLeft_yFront, float z_at_xRight_yFront, float z_at_xLeft_yBack) {</front>
<front id="Marlin_mainCPP-774">    plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-775"></front>
<front id="Marlin_mainCPP-776">    vector_3 xLeftyFront = vector_3(LEFT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, z_at_xLeft_yFront);</front>
<front id="Marlin_mainCPP-777">    vector_3 xLeftyBack = vector_3(LEFT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION, z_at_xLeft_yBack);</front>
<front id="Marlin_mainCPP-778">    vector_3 xRightyFront = vector_3(RIGHT_PROBE_BED_POSITION, FRONT_PROBE_BED_POSITION, z_at_xRight_yFront);</front>
<front id="Marlin_mainCPP-779"></front>
<front id="Marlin_mainCPP-780">    vector_3 xPositive = (xRightyFront - xLeftyFront).get_normal();</front>
<front id="Marlin_mainCPP-781">    vector_3 yPositive = (xLeftyBack - xLeftyFront).get_normal();</front>
<front id="Marlin_mainCPP-782">    vector_3 planeNormal = vector_3::cross(yPositive, xPositive).get_normal();</front>
<front id="Marlin_mainCPP-783"></front>
<front id="Marlin_mainCPP-784">    //planeNormal.debug("planeNormal");</front>
<front id="Marlin_mainCPP-785">    //yPositive.debug("yPositive");</front>
<front id="Marlin_mainCPP-786">    matrix_3x3 bedLevel = matrix_3x3::create_look_at(planeNormal, yPositive);</front>
<front id="Marlin_mainCPP-787">    //bedLevel.debug("bedLevel");</front>
<front id="Marlin_mainCPP-788"></front>
<front id="Marlin_mainCPP-789">    //plan_bed_level_matrix.debug("bed level before");</front>
<front id="Marlin_mainCPP-790">    //vector_3 uncorrected_position = plan_get_position_mm();</front>
<front id="Marlin_mainCPP-791">    //uncorrected_position.debug("position before");</front>
<front id="Marlin_mainCPP-792"></front>
<front id="Marlin_mainCPP-793">    // and set our bed level equation to do the right thing</front>
<front id="Marlin_mainCPP-794">    plan_bed_level_matrix = matrix_3x3::create_inverse(bedLevel);</front>
<front id="Marlin_mainCPP-795">    //plan_bed_level_matrix.debug("bed level after");</front>
<front id="Marlin_mainCPP-796"></front>
<front id="Marlin_mainCPP-797">    vector_3 corrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-798">    //corrected_position.debug("position after");</front>
<front id="Marlin_mainCPP-799">    current_position[X_AXIS] = corrected_position.x;</front>
<front id="Marlin_mainCPP-800">    current_position[Y_AXIS] = corrected_position.y;</front>
<front id="Marlin_mainCPP-801">    current_position[Z_AXIS] = corrected_position.z;</front>
<front id="Marlin_mainCPP-802"></front>
<front id="Marlin_mainCPP-803">    // but the bed at 0 so we don't go below it.</front>
<front id="Marlin_mainCPP-804">    current_position[Z_AXIS] = -Z_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-805"></front>
<front id="Marlin_mainCPP-806">    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-807">}</front>
<front id="Marlin_mainCPP-808"></front>
<front id="Marlin_mainCPP-809">static void run_z_probe() {</front>
<front id="Marlin_mainCPP-810">    plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-811">    feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-812"></front>
<front id="Marlin_mainCPP-813">    // move down until you find the bed</front>
<front id="Marlin_mainCPP-814">    float zPosition = -10;</front>
<front id="Marlin_mainCPP-815">    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-816">    st_synchronize();</front>
<front id="Marlin_mainCPP-817"></front>
<front id="Marlin_mainCPP-818">        // we have to let the planner know where we are right now as it is not where we said to go.</front>
<front id="Marlin_mainCPP-819">    zPosition = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-820">    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-821"></front>
<front id="Marlin_mainCPP-822">    // move up the retract distance</front>
<front id="Marlin_mainCPP-823">    zPosition += home_retract_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-824">    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-825">    st_synchronize();</front>
<front id="Marlin_mainCPP-826"></front>
<front id="Marlin_mainCPP-827">    // move back down slowly to find bed</front>
<front id="Marlin_mainCPP-828">    feedrate = homing_feedrate[Z_AXIS]/4; </front>
<front id="Marlin_mainCPP-829">    zPosition -= home_retract_mm(Z_AXIS) * 2;</front>
<front id="Marlin_mainCPP-830">    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-831">    st_synchronize();</front>
<front id="Marlin_mainCPP-832"></front>
<front id="Marlin_mainCPP-833">    current_position[Z_AXIS] = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-834">    // make sure the planner knows where we are as it may be a bit different than we last said to move to</front>
<front id="Marlin_mainCPP-835">    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-836">}</front>
<front id="Marlin_mainCPP-837"></front>
<front id="Marlin_mainCPP-838">static void do_blocking_move_to(float x, float y, float z) {</front>
<front id="Marlin_mainCPP-839">    float oldFeedRate = feedrate;</front>
<front id="Marlin_mainCPP-840"></front>
<front id="Marlin_mainCPP-841">    feedrate = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-842"></front>
<front id="Marlin_mainCPP-843">    current_position[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-844">    current_position[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-845">    current_position[Z_AXIS] = z;</front>
<front id="Marlin_mainCPP-846">    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-847">    st_synchronize();</front>
<front id="Marlin_mainCPP-848"></front>
<front id="Marlin_mainCPP-849">    feedrate = oldFeedRate;</front>
<front id="Marlin_mainCPP-850">}</front>
<front id="Marlin_mainCPP-851"></front>
<front id="Marlin_mainCPP-852">static void do_blocking_move_relative(float offset_x, float offset_y, float offset_z) {</front>
<front id="Marlin_mainCPP-853">    do_blocking_move_to(current_position[X_AXIS] + offset_x, current_position[Y_AXIS] + offset_y, current_position[Z_AXIS] + offset_z);</front>
<front id="Marlin_mainCPP-854">}</front>
<front id="Marlin_mainCPP-855"></front>
<front id="Marlin_mainCPP-856">static void setup_for_endstop_move() {</front>
<front id="Marlin_mainCPP-857">    saved_feedrate = feedrate;</front>
<front id="Marlin_mainCPP-858">    saved_feedmultiply = feedmultiply;</front>
<front id="Marlin_mainCPP-859">    feedmultiply = 100;</front>
<front id="Marlin_mainCPP-860">    previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-861"></front>
<front id="Marlin_mainCPP-862">    enable_endstops(true);</front>
<front id="Marlin_mainCPP-863">}</front>
<front id="Marlin_mainCPP-864"></front>
<front id="Marlin_mainCPP-865">static void clean_up_after_endstop_move() {</front>
<front id="Marlin_mainCPP-866">#ifdef ENDSTOPS_ONLY_FOR_HOMING</front>
<front id="Marlin_mainCPP-867">    enable_endstops(false);</front>
<front id="Marlin_mainCPP-868">#endif</front>
<front id="Marlin_mainCPP-869"></front>
<front id="Marlin_mainCPP-870">    feedrate = saved_feedrate;</front>
<front id="Marlin_mainCPP-871">    feedmultiply = saved_feedmultiply;</front>
<front id="Marlin_mainCPP-872">    previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-873">}</front>
<front id="Marlin_mainCPP-874"></front>
<front id="Marlin_mainCPP-875">static void engage_z_probe() {</front>
<front id="Marlin_mainCPP-876">    // Engage Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-877">    #ifdef SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-878">    if (servo_endstops[Z_AXIS] &gt; -1) {</front>
<front id="Marlin_mainCPP-879">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-880">        servos[servo_endstops[Z_AXIS]].attach(0);</front>
<front id="Marlin_mainCPP-881">#endif</front>
<front id="Marlin_mainCPP-882">        servos[servo_endstops[Z_AXIS]].write(servo_endstop_angles[Z_AXIS * 2]);</front>
<front id="Marlin_mainCPP-883">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-884">        delay(PROBE_SERVO_DEACTIVATION_DELAY);</front>
<front id="Marlin_mainCPP-885">        servos[servo_endstops[Z_AXIS]].detach();</front>
<front id="Marlin_mainCPP-886">#endif</front>
<front id="Marlin_mainCPP-887">    }</front>
<front id="Marlin_mainCPP-888">    #endif</front>
<front id="Marlin_mainCPP-889">}</front>
<front id="Marlin_mainCPP-890"></front>
<front id="Marlin_mainCPP-891">static void retract_z_probe() {</front>
<front id="Marlin_mainCPP-892">    // Retract Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-893">    #ifdef SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-894">    if (servo_endstops[Z_AXIS] &gt; -1) {</front>
<front id="Marlin_mainCPP-895">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-896">        servos[servo_endstops[Z_AXIS]].attach(0);</front>
<front id="Marlin_mainCPP-897">#endif</front>
<front id="Marlin_mainCPP-898">        servos[servo_endstops[Z_AXIS]].write(servo_endstop_angles[Z_AXIS * 2 + 1]);</front>
<front id="Marlin_mainCPP-899">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-900">        delay(PROBE_SERVO_DEACTIVATION_DELAY);</front>
<front id="Marlin_mainCPP-901">        servos[servo_endstops[Z_AXIS]].detach();</front>
<front id="Marlin_mainCPP-902">#endif</front>
<front id="Marlin_mainCPP-903">    }</front>
<front id="Marlin_mainCPP-904">    #endif</front>
<front id="Marlin_mainCPP-905">}</front>
<front id="Marlin_mainCPP-906"></front>
<front id="Marlin_mainCPP-907">#endif // #ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-908"></front>
<front id="Marlin_mainCPP-909">static void homeaxis(int axis) {</front>
<front id="Marlin_mainCPP-910">#define HOMEAXIS_DO(LETTER) \</front>
<front id="Marlin_mainCPP-911">  ((LETTER##_MIN_PIN &gt; -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN &gt; -1 && LETTER##_HOME_DIR==1))</front>
<front id="Marlin_mainCPP-912"></front>
<front id="Marlin_mainCPP-913">  if (axis==X_AXIS ? HOMEAXIS_DO(X) :</front>
<front id="Marlin_mainCPP-914">      axis==Y_AXIS ? HOMEAXIS_DO(Y) :</front>
<front id="Marlin_mainCPP-915">      axis==Z_AXIS ? HOMEAXIS_DO(Z) :</front>
<front id="Marlin_mainCPP-916">      0) {</front>
<front id="Marlin_mainCPP-917">    int axis_home_dir = home_dir(axis);</front>
<front id="Marlin_mainCPP-918">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-919">    if (axis == X_AXIS)</front>
<front id="Marlin_mainCPP-920">      axis_home_dir = x_home_dir(active_extruder);</front>
<front id="Marlin_mainCPP-921">#endif</front>
<front id="Marlin_mainCPP-922"></front>
<front id="Marlin_mainCPP-923">    // Engage Servo endstop if enabled</front>
<front id="Marlin_mainCPP-924">    #ifdef SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-925">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-926">    if (axis==Z_AXIS) engage_z_probe();</front>
<front id="Marlin_mainCPP-927">	else</front>
<front id="Marlin_mainCPP-928">#endif</front>
<front id="Marlin_mainCPP-929">      if (servo_endstops[axis] &gt; -1) {</front>
<front id="Marlin_mainCPP-930">        servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2]);</front>
<front id="Marlin_mainCPP-931">      }</front>
<front id="Marlin_mainCPP-932">    #endif</front>
<front id="Marlin_mainCPP-933"></front>
<front id="Marlin_mainCPP-934">    current_position[axis] = 0;</front>
<front id="Marlin_mainCPP-935">    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-936">    destination[axis] = 1.5 * max_length(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-937">    feedrate = homing_feedrate[axis];</front>
<front id="Marlin_mainCPP-938">    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-939">    st_synchronize();</front>
<front id="Marlin_mainCPP-940"></front>
<front id="Marlin_mainCPP-941">    current_position[axis] = 0;</front>
<front id="Marlin_mainCPP-942">    plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-943">    destination[axis] = -home_retract_mm(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-944">    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-945">    st_synchronize();</front>
<front id="Marlin_mainCPP-946"></front>
<front id="Marlin_mainCPP-947">    destination[axis] = 2*home_retract_mm(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-948">#ifdef DELTA</front>
<front id="Marlin_mainCPP-949">    feedrate = homing_feedrate[axis]/10;</front>
<front id="Marlin_mainCPP-950">#else</front>
<front id="Marlin_mainCPP-951">    feedrate = homing_feedrate[axis]/2 ;</front>
<front id="Marlin_mainCPP-952">#endif</front>
<front id="Marlin_mainCPP-953">    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-954">    st_synchronize();</front>
<front id="Marlin_mainCPP-955">#ifdef DELTA</front>
<front id="Marlin_mainCPP-956">    // retrace by the amount specified in endstop_adj</front>
<front id="Marlin_mainCPP-957">    if (endstop_adj[axis] * axis_home_dir &lt; 0) {</front>
<front id="Marlin_mainCPP-958">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-959">      destination[axis] = endstop_adj[axis];</front>
<front id="Marlin_mainCPP-960">      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-961">      st_synchronize();</front>
<front id="Marlin_mainCPP-962">    }</front>
<front id="Marlin_mainCPP-963">#endif</front>
<front id="Marlin_mainCPP-964">    axis_is_at_home(axis);</front>
<front id="Marlin_mainCPP-965">    destination[axis] = current_position[axis];</front>
<front id="Marlin_mainCPP-966">    feedrate = 0.0;</front>
<front id="Marlin_mainCPP-967">    endstops_hit_on_purpose();</front>
<front id="Marlin_mainCPP-968"></front>
<front id="Marlin_mainCPP-969">    // Retract Servo endstop if enabled</front>
<front id="Marlin_mainCPP-970">    #ifdef SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-971">      if (servo_endstops[axis] &gt; -1) {</front>
<front id="Marlin_mainCPP-972">        servos[servo_endstops[axis]].write(servo_endstop_angles[axis * 2 + 1]);</front>
<front id="Marlin_mainCPP-973">      }</front>
<front id="Marlin_mainCPP-974">    #endif</front>
<front id="Marlin_mainCPP-975">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-976">    if (axis==Z_AXIS) retract_z_probe();</front>
<front id="Marlin_mainCPP-977">#endif</front>
<front id="Marlin_mainCPP-978">    </front>
<front id="Marlin_mainCPP-979">  }</front>
<front id="Marlin_mainCPP-980">}</front>
<front id="Marlin_mainCPP-981">#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)</front>
<front id="Marlin_mainCPP-982"></front>
<front id="Marlin_mainCPP-983">void process_commands()</front>
<front id="Marlin_mainCPP-984">{</front>
<front id="Marlin_mainCPP-985">  unsigned long codenum; //throw away variable</front>
<front id="Marlin_mainCPP-986">  char *starpos = NULL;</front>
<front id="Marlin_mainCPP-987">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-988">  float x_tmp, y_tmp, z_tmp, real_z;</front>
<front id="Marlin_mainCPP-989">#endif</front>
<front id="Marlin_mainCPP-990">  if(code_seen('G'))</front>
<front id="Marlin_mainCPP-991">  {</front>
<front id="Marlin_mainCPP-992">    switch((int)code_value())</front>
<front id="Marlin_mainCPP-993">    {</front>
<front id="Marlin_mainCPP-994">    case 0: // G0 -&gt; G1</front>
<front id="Marlin_mainCPP-995">    case 1: // G1</front>
<front id="Marlin_mainCPP-996">      if(Stopped == false) {</front>
<front id="Marlin_mainCPP-997">        get_coordinates(); // For X Y Z E F</front>
<front id="Marlin_mainCPP-998">        prepare_move();</front>
<front id="Marlin_mainCPP-999">        //ClearToSend();</front>
<front id="Marlin_mainCPP-1000">        return;</front>
<front id="Marlin_mainCPP-1001">      }</front>
<front id="Marlin_mainCPP-1002">      //break;</front>
<front id="Marlin_mainCPP-1003">    case 2: // G2  - CW ARC</front>
<front id="Marlin_mainCPP-1004">      if(Stopped == false) {</front>
<front id="Marlin_mainCPP-1005">        get_arc_coordinates();</front>
<front id="Marlin_mainCPP-1006">        prepare_arc_move(true);</front>
<front id="Marlin_mainCPP-1007">        return;</front>
<front id="Marlin_mainCPP-1008">      }</front>
<front id="Marlin_mainCPP-1009">    case 3: // G3  - CCW ARC</front>
<front id="Marlin_mainCPP-1010">      if(Stopped == false) {</front>
<front id="Marlin_mainCPP-1011">        get_arc_coordinates();</front>
<front id="Marlin_mainCPP-1012">        prepare_arc_move(false);</front>
<front id="Marlin_mainCPP-1013">        return;</front>
<front id="Marlin_mainCPP-1014">      }</front>
<front id="Marlin_mainCPP-1015">    case 4: // G4 dwell</front>
<front id="Marlin_mainCPP-1016">      LCD_MESSAGEPGM(MSG_DWELL);</front>
<front id="Marlin_mainCPP-1017">      codenum = 0;</front>
<front id="Marlin_mainCPP-1018">      if(code_seen('P')) codenum = code_value(); // milliseconds to wait</front>
<front id="Marlin_mainCPP-1019">      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait</front>
<front id="Marlin_mainCPP-1020"></front>
<front id="Marlin_mainCPP-1021">      st_synchronize();</front>
<front id="Marlin_mainCPP-1022">      codenum += millis();  // keep track of when we started waiting</front>
<front id="Marlin_mainCPP-1023">      previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-1024">      while(millis()  &lt; codenum ){</front>
<front id="Marlin_mainCPP-1025">        manage_heater();</front>
<front id="Marlin_mainCPP-1026">        manage_inactivity();</front>
<front id="Marlin_mainCPP-1027">        lcd_update();</front>
<front id="Marlin_mainCPP-1028">      }</front>
<front id="Marlin_mainCPP-1029">      break;</front>
<front id="Marlin_mainCPP-1030">      #ifdef FWRETRACT</front>
<front id="Marlin_mainCPP-1031">      case 10: // G10 retract</front>
<front id="Marlin_mainCPP-1032">      if(!retracted)</front>
<front id="Marlin_mainCPP-1033">      {</front>
<front id="Marlin_mainCPP-1034">        destination[X_AXIS]=current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-1035">        destination[Y_AXIS]=current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-1036">        destination[Z_AXIS]=current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1037">        current_position[Z_AXIS]+=-retract_zlift;</front>
<front id="Marlin_mainCPP-1038">        destination[E_AXIS]=current_position[E_AXIS]-retract_length;</front>
<front id="Marlin_mainCPP-1039">        feedrate=retract_feedrate;</front>
<front id="Marlin_mainCPP-1040">        retracted=true;</front>
<front id="Marlin_mainCPP-1041">        prepare_move();</front>
<front id="Marlin_mainCPP-1042">      }</front>
<front id="Marlin_mainCPP-1043"></front>
<front id="Marlin_mainCPP-1044">      break;</front>
<front id="Marlin_mainCPP-1045">      case 11: // G10 retract_recover</front>
<front id="Marlin_mainCPP-1046">      if(!retracted)</front>
<front id="Marlin_mainCPP-1047">      {</front>
<front id="Marlin_mainCPP-1048">        destination[X_AXIS]=current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-1049">        destination[Y_AXIS]=current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-1050">        destination[Z_AXIS]=current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1051"></front>
<front id="Marlin_mainCPP-1052">        current_position[Z_AXIS]+=retract_zlift;</front>
<front id="Marlin_mainCPP-1053">        current_position[E_AXIS]+=-retract_recover_length;</front>
<front id="Marlin_mainCPP-1054">        feedrate=retract_recover_feedrate;</front>
<front id="Marlin_mainCPP-1055">        retracted=false;</front>
<front id="Marlin_mainCPP-1056">        prepare_move();</front>
<front id="Marlin_mainCPP-1057">      }</front>
<front id="Marlin_mainCPP-1058">      break;</front>
<front id="Marlin_mainCPP-1059">      #endif //FWRETRACT</front>
<front id="Marlin_mainCPP-1060">    case 28: //G28 Home all Axis one at a time</front>
<front id="Marlin_mainCPP-1061">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-1062">      plan_bed_level_matrix.set_to_identity();  //Reset the plane ("erase" all leveling data)</front>
<front id="Marlin_mainCPP-1063">#endif //ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-1064"></front>
<front id="Marlin_mainCPP-1065"></front>
<front id="Marlin_mainCPP-1066">      saved_feedrate = feedrate;</front>
<front id="Marlin_mainCPP-1067">      saved_feedmultiply = feedmultiply;</front>
<front id="Marlin_mainCPP-1068">      feedmultiply = 100;</front>
<front id="Marlin_mainCPP-1069">      previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-1070"></front>
<front id="Marlin_mainCPP-1071">      enable_endstops(true);</front>
<front id="Marlin_mainCPP-1072"></front>
<front id="Marlin_mainCPP-1073">      for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-1074">        destination[i] = current_position[i];</front>
<front id="Marlin_mainCPP-1075">      }</front>
<front id="Marlin_mainCPP-1076">      feedrate = 0.0;</front>
<front id="Marlin_mainCPP-1077"></front>
<front id="Marlin_mainCPP-1078">#ifdef DELTA</front>
<front id="Marlin_mainCPP-1079">          // A delta can only safely home all axis at the same time</front>
<front id="Marlin_mainCPP-1080">          // all axis have to home at the same time</front>
<front id="Marlin_mainCPP-1081"></front>
<front id="Marlin_mainCPP-1082">          // Move all carriages up together until the first endstop is hit.</front>
<front id="Marlin_mainCPP-1083">          current_position[X_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1084">          current_position[Y_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1085">          current_position[Z_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1086">          plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1087"></front>
<front id="Marlin_mainCPP-1088">          destination[X_AXIS] = 3 * Z_MAX_LENGTH;</front>
<front id="Marlin_mainCPP-1089">          destination[Y_AXIS] = 3 * Z_MAX_LENGTH;</front>
<front id="Marlin_mainCPP-1090">          destination[Z_AXIS] = 3 * Z_MAX_LENGTH;</front>
<front id="Marlin_mainCPP-1091">          feedrate = 1.732 * homing_feedrate[X_AXIS];</front>
<front id="Marlin_mainCPP-1092">          plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1093">          st_synchronize();</front>
<front id="Marlin_mainCPP-1094">          endstops_hit_on_purpose();</front>
<front id="Marlin_mainCPP-1095"></front>
<front id="Marlin_mainCPP-1096">          current_position[X_AXIS] = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-1097">          current_position[Y_AXIS] = destination[Y_AXIS];</front>
<front id="Marlin_mainCPP-1098">          current_position[Z_AXIS] = destination[Z_AXIS];</front>
<front id="Marlin_mainCPP-1099"></front>
<front id="Marlin_mainCPP-1100">          // take care of back off and rehome now we are all at the top</front>
<front id="Marlin_mainCPP-1101">          HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-1102">          HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-1103">          HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-1104"></front>
<front id="Marlin_mainCPP-1105">          calculate_delta(current_position);</front>
<front id="Marlin_mainCPP-1106">          plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1107"></front>
<front id="Marlin_mainCPP-1108">#else // NOT DELTA</front>
<front id="Marlin_mainCPP-1109"></front>
<front id="Marlin_mainCPP-1110">      home_all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2])));</front>
<front id="Marlin_mainCPP-1111"></front>
<front id="Marlin_mainCPP-1112">      #if Z_HOME_DIR &gt; 0                      // If homing away from BED do Z first</front>
<front id="Marlin_mainCPP-1113">      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {</front>
<front id="Marlin_mainCPP-1114">        HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-1115">      }</front>
<front id="Marlin_mainCPP-1116">      #endif</front>
<front id="Marlin_mainCPP-1117"></front>
<front id="Marlin_mainCPP-1118">      #ifdef QUICK_HOME</front>
<front id="Marlin_mainCPP-1119">      if((home_all_axis)||( code_seen(axis_codes[X_AXIS]) && code_seen(axis_codes[Y_AXIS])) )  //first diagonal move</front>
<front id="Marlin_mainCPP-1120">      {</front>
<front id="Marlin_mainCPP-1121">        current_position[X_AXIS] = 0;current_position[Y_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1122"></front>
<front id="Marlin_mainCPP-1123">       #ifndef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1124">        int x_axis_home_dir = home_dir(X_AXIS);</front>
<front id="Marlin_mainCPP-1125">       #else</front>
<front id="Marlin_mainCPP-1126">        int x_axis_home_dir = x_home_dir(active_extruder);</front>
<front id="Marlin_mainCPP-1127">        extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-1128">       #endif</front>
<front id="Marlin_mainCPP-1129"></front>
<front id="Marlin_mainCPP-1130">        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1131">        destination[X_AXIS] = 1.5 * max_length(X_AXIS) * x_axis_home_dir;destination[Y_AXIS] = 1.5 * max_length(Y_AXIS) * home_dir(Y_AXIS);</front>
<front id="Marlin_mainCPP-1132">        feedrate = homing_feedrate[X_AXIS];</front>
<front id="Marlin_mainCPP-1133">        if(homing_feedrate[Y_AXIS]&lt;feedrate)</front>
<front id="Marlin_mainCPP-1134">          feedrate =homing_feedrate[Y_AXIS];</front>
<front id="Marlin_mainCPP-1135">        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1136">        st_synchronize();</front>
<front id="Marlin_mainCPP-1137"></front>
<front id="Marlin_mainCPP-1138">        axis_is_at_home(X_AXIS);</front>
<front id="Marlin_mainCPP-1139">        axis_is_at_home(Y_AXIS);</front>
<front id="Marlin_mainCPP-1140">        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1141">        destination[X_AXIS] = current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-1142">        destination[Y_AXIS] = current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-1143">        plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1144">        feedrate = 0.0;</front>
<front id="Marlin_mainCPP-1145">        st_synchronize();</front>
<front id="Marlin_mainCPP-1146">        endstops_hit_on_purpose();</front>
<front id="Marlin_mainCPP-1147"></front>
<front id="Marlin_mainCPP-1148">        current_position[X_AXIS] = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-1149">        current_position[Y_AXIS] = destination[Y_AXIS];</front>
<front id="Marlin_mainCPP-1150">        current_position[Z_AXIS] = destination[Z_AXIS];</front>
<front id="Marlin_mainCPP-1151">      }</front>
<front id="Marlin_mainCPP-1152">      #endif</front>
<front id="Marlin_mainCPP-1153"></front>
<front id="Marlin_mainCPP-1154">      if((home_all_axis) || (code_seen(axis_codes[X_AXIS])))</front>
<front id="Marlin_mainCPP-1155">      {</front>
<front id="Marlin_mainCPP-1156">      #ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1157">        int tmp_extruder = active_extruder;</front>
<front id="Marlin_mainCPP-1158">        extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-1159">        active_extruder = !active_extruder;</front>
<front id="Marlin_mainCPP-1160">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-1161">        inactive_extruder_x_pos = current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-1162">        active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-1163">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-1164">        // reset state used by the different modes</front>
<front id="Marlin_mainCPP-1165">        memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));</front>
<front id="Marlin_mainCPP-1166">        delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-1167">        active_extruder_parked = true; </front>
<front id="Marlin_mainCPP-1168">      #else      </front>
<front id="Marlin_mainCPP-1169">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-1170">      #endif         </front>
<front id="Marlin_mainCPP-1171">      }</front>
<front id="Marlin_mainCPP-1172"></front>
<front id="Marlin_mainCPP-1173">      if((home_all_axis) || (code_seen(axis_codes[Y_AXIS]))) {</front>
<front id="Marlin_mainCPP-1174">        HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-1175">      }</front>
<front id="Marlin_mainCPP-1176"></front>
<front id="Marlin_mainCPP-1177">      #if Z_HOME_DIR &lt; 0                      // If homing towards BED do Z last</front>
<front id="Marlin_mainCPP-1178">      if((home_all_axis) || (code_seen(axis_codes[Z_AXIS]))) {</front>
<front id="Marlin_mainCPP-1179">        HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-1180">      }</front>
<front id="Marlin_mainCPP-1181">      #endif</front>
<front id="Marlin_mainCPP-1182"></front>
<front id="Marlin_mainCPP-1183">      if(code_seen(axis_codes[X_AXIS]))</front>
<front id="Marlin_mainCPP-1184">      {</front>
<front id="Marlin_mainCPP-1185">        if(code_value_long() != 0) {</front>
<front id="Marlin_mainCPP-1186">          current_position[X_AXIS]=code_value()+add_homeing[0];</front>
<front id="Marlin_mainCPP-1187">        }</front>
<front id="Marlin_mainCPP-1188">      }</front>
<front id="Marlin_mainCPP-1189"></front>
<front id="Marlin_mainCPP-1190">      if(code_seen(axis_codes[Y_AXIS])) {</front>
<front id="Marlin_mainCPP-1191">        if(code_value_long() != 0) {</front>
<front id="Marlin_mainCPP-1192">          current_position[Y_AXIS]=code_value()+add_homeing[1];</front>
<front id="Marlin_mainCPP-1193">        }</front>
<front id="Marlin_mainCPP-1194">      }</front>
<front id="Marlin_mainCPP-1195"></front>
<front id="Marlin_mainCPP-1196">      if(code_seen(axis_codes[Z_AXIS])) {</front>
<front id="Marlin_mainCPP-1197">        if(code_value_long() != 0) {</front>
<front id="Marlin_mainCPP-1198">          current_position[Z_AXIS]=code_value()+add_homeing[2];</front>
<front id="Marlin_mainCPP-1199">        }</front>
<front id="Marlin_mainCPP-1200">      }</front>
<front id="Marlin_mainCPP-1201">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1202">#endif // else DELTA</front>
<front id="Marlin_mainCPP-1203"></front>
<front id="Marlin_mainCPP-1204">      #ifdef ENDSTOPS_ONLY_FOR_HOMING</front>
<front id="Marlin_mainCPP-1205">        enable_endstops(false);</front>
<front id="Marlin_mainCPP-1206">      #endif</front>
<front id="Marlin_mainCPP-1207"></front>
<front id="Marlin_mainCPP-1208">      feedrate = saved_feedrate;</front>
<front id="Marlin_mainCPP-1209">      feedmultiply = saved_feedmultiply;</front>
<front id="Marlin_mainCPP-1210">      previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-1211">      endstops_hit_on_purpose();</front>
<front id="Marlin_mainCPP-1212">      break;</front>
<front id="Marlin_mainCPP-1213"></front>
<front id="Marlin_mainCPP-1214">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-1215">    case 29: // G29 Detailed Z-Probe, probes the bed at 3 points.</front>
<front id="Marlin_mainCPP-1216">        {</front>
<front id="Marlin_mainCPP-1217">            #if Z_MIN_PIN == -1</front>
<front id="Marlin_mainCPP-1218">            #error "You must have a Z_MIN endstop in order to enable Auto Bed Leveling feature!!! Z_MIN_PIN must point to a valid hardware pin."</front>
<front id="Marlin_mainCPP-1219">            #endif</front>
<front id="Marlin_mainCPP-1220"></front>
<front id="Marlin_mainCPP-1221">            st_synchronize();</front>
<front id="Marlin_mainCPP-1222">            // make sure the bed_level_rotation_matrix is identity or the planner will get it incorectly</front>
<front id="Marlin_mainCPP-1223">            //vector_3 corrected_position = plan_get_position_mm();</front>
<front id="Marlin_mainCPP-1224">            //corrected_position.debug("position before G29");</front>
<front id="Marlin_mainCPP-1225">            plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-1226">            vector_3 uncorrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-1227">            //uncorrected_position.debug("position durring G29");</front>
<front id="Marlin_mainCPP-1228">            current_position[X_AXIS] = uncorrected_position.x;</front>
<front id="Marlin_mainCPP-1229">            current_position[Y_AXIS] = uncorrected_position.y;</front>
<front id="Marlin_mainCPP-1230">            current_position[Z_AXIS] = uncorrected_position.z;</front>
<front id="Marlin_mainCPP-1231">            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1232">            setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-1233"></front>
<front id="Marlin_mainCPP-1234">            feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-1235"></front>
<front id="Marlin_mainCPP-1236">            // prob 1</front>
<front id="Marlin_mainCPP-1237">            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], Z_RAISE_BEFORE_PROBING);</front>
<front id="Marlin_mainCPP-1238">            do_blocking_move_to(LEFT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, BACK_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1239"></front>
<front id="Marlin_mainCPP-1240">            engage_z_probe();   // Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-1241">            </front>
<front id="Marlin_mainCPP-1242">            run_z_probe();</front>
<front id="Marlin_mainCPP-1243">            float z_at_xLeft_yBack = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1244"></front>
<front id="Marlin_mainCPP-1245">            SERIAL_PROTOCOLPGM("Bed x: ");</front>
<front id="Marlin_mainCPP-1246">            SERIAL_PROTOCOL(LEFT_PROBE_BED_POSITION);</front>
<front id="Marlin_mainCPP-1247">            SERIAL_PROTOCOLPGM(" y: ");</front>
<front id="Marlin_mainCPP-1248">            SERIAL_PROTOCOL(BACK_PROBE_BED_POSITION);</front>
<front id="Marlin_mainCPP-1249">            SERIAL_PROTOCOLPGM(" z: ");</front>
<front id="Marlin_mainCPP-1250">            SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1251">            SERIAL_PROTOCOLPGM("\n");</front>
<front id="Marlin_mainCPP-1252"></front>
<front id="Marlin_mainCPP-1253">            // prob 2</front>
<front id="Marlin_mainCPP-1254">            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);</front>
<front id="Marlin_mainCPP-1255">            do_blocking_move_to(LEFT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, FRONT_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1256">            run_z_probe();</front>
<front id="Marlin_mainCPP-1257">            float z_at_xLeft_yFront = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1258"></front>
<front id="Marlin_mainCPP-1259">            SERIAL_PROTOCOLPGM("Bed x: ");</front>
<front id="Marlin_mainCPP-1260">            SERIAL_PROTOCOL(LEFT_PROBE_BED_POSITION);</front>
<front id="Marlin_mainCPP-1261">            SERIAL_PROTOCOLPGM(" y: ");</front>
<front id="Marlin_mainCPP-1262">            SERIAL_PROTOCOL(FRONT_PROBE_BED_POSITION);</front>
<front id="Marlin_mainCPP-1263">            SERIAL_PROTOCOLPGM(" z: ");</front>
<front id="Marlin_mainCPP-1264">            SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1265">            SERIAL_PROTOCOLPGM("\n");</front>
<front id="Marlin_mainCPP-1266"></front>
<front id="Marlin_mainCPP-1267">            // prob 3</front>
<front id="Marlin_mainCPP-1268">            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS);</front>
<front id="Marlin_mainCPP-1269">            // the current position will be updated by the blocking move so the head will not lower on this next call.</front>
<front id="Marlin_mainCPP-1270">            do_blocking_move_to(RIGHT_PROBE_BED_POSITION - X_PROBE_OFFSET_FROM_EXTRUDER, FRONT_PROBE_BED_POSITION - Y_PROBE_OFFSET_FROM_EXTRUDER, current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1271">            run_z_probe();</front>
<front id="Marlin_mainCPP-1272">            float z_at_xRight_yFront = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1273"></front>
<front id="Marlin_mainCPP-1274">            SERIAL_PROTOCOLPGM("Bed x: ");</front>
<front id="Marlin_mainCPP-1275">            SERIAL_PROTOCOL(RIGHT_PROBE_BED_POSITION);</front>
<front id="Marlin_mainCPP-1276">            SERIAL_PROTOCOLPGM(" y: ");</front>
<front id="Marlin_mainCPP-1277">            SERIAL_PROTOCOL(FRONT_PROBE_BED_POSITION);</front>
<front id="Marlin_mainCPP-1278">            SERIAL_PROTOCOLPGM(" z: ");</front>
<front id="Marlin_mainCPP-1279">            SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1280">            SERIAL_PROTOCOLPGM("\n");</front>
<front id="Marlin_mainCPP-1281"></front>
<front id="Marlin_mainCPP-1282">            clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-1283"></front>
<front id="Marlin_mainCPP-1284">            set_bed_level_equation(z_at_xLeft_yFront, z_at_xRight_yFront, z_at_xLeft_yBack);</front>
<front id="Marlin_mainCPP-1285"></front>
<front id="Marlin_mainCPP-1286">            retract_z_probe(); // Retract Z Servo endstop if available</front>
<front id="Marlin_mainCPP-1287">            </front>
<front id="Marlin_mainCPP-1288">            st_synchronize();            </front>
<front id="Marlin_mainCPP-1289"></front>
<front id="Marlin_mainCPP-1290">            // The following code correct the Z height difference from z-probe position and hotend tip position.</front>
<front id="Marlin_mainCPP-1291">            // The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend. </front>
<front id="Marlin_mainCPP-1292">            // When the bed is uneven, this height must be corrected.</front>
<front id="Marlin_mainCPP-1293">            real_z = float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS];  //get the real Z (since the auto bed leveling is already correcting the plane)</front>
<front id="Marlin_mainCPP-1294">            x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-1295">            y_tmp = current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-1296">            z_tmp = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1297"></front>
<front id="Marlin_mainCPP-1298">            apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp);         //Apply the correction sending the probe offset</front>
<front id="Marlin_mainCPP-1299">            current_position[Z_AXIS] = z_tmp - real_z + current_position[Z_AXIS];   //The difference is added to current position and sent to planner.</front>
<front id="Marlin_mainCPP-1300">            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1301">        }</front>
<front id="Marlin_mainCPP-1302">        break;</front>
<front id="Marlin_mainCPP-1303">        </front>
<front id="Marlin_mainCPP-1304">    case 30: // G30 Single Z Probe</front>
<front id="Marlin_mainCPP-1305">        {</front>
<front id="Marlin_mainCPP-1306">            engage_z_probe(); // Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-1307">            </front>
<front id="Marlin_mainCPP-1308">            st_synchronize();</front>
<front id="Marlin_mainCPP-1309">            // TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly</front>
<front id="Marlin_mainCPP-1310">            setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-1311"></front>
<front id="Marlin_mainCPP-1312">            feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-1313"></front>
<front id="Marlin_mainCPP-1314">            run_z_probe();</front>
<front id="Marlin_mainCPP-1315">            SERIAL_PROTOCOLPGM("Bed Position X: ");</front>
<front id="Marlin_mainCPP-1316">            SERIAL_PROTOCOL(current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-1317">            SERIAL_PROTOCOLPGM(" Y: ");</front>
<front id="Marlin_mainCPP-1318">            SERIAL_PROTOCOL(current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1319">            SERIAL_PROTOCOLPGM(" Z: ");</front>
<front id="Marlin_mainCPP-1320">            SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1321">            SERIAL_PROTOCOLPGM("\n");</front>
<front id="Marlin_mainCPP-1322"></front>
<front id="Marlin_mainCPP-1323">            clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-1324"></front>
<front id="Marlin_mainCPP-1325">            retract_z_probe(); // Retract Z Servo endstop if available</front>
<front id="Marlin_mainCPP-1326">        }</front>
<front id="Marlin_mainCPP-1327">        break;</front>
<front id="Marlin_mainCPP-1328">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="Marlin_mainCPP-1329">    case 90: // G90</front>
<front id="Marlin_mainCPP-1330">      relative_mode = false;</front>
<front id="Marlin_mainCPP-1331">      break;</front>
<front id="Marlin_mainCPP-1332">    case 91: // G91</front>
<front id="Marlin_mainCPP-1333">      relative_mode = true;</front>
<front id="Marlin_mainCPP-1334">      break;</front>
<front id="Marlin_mainCPP-1335">    case 92: // G92</front>
<front id="Marlin_mainCPP-1336">      if(!code_seen(axis_codes[E_AXIS]))</front>
<front id="Marlin_mainCPP-1337">        st_synchronize();</front>
<front id="Marlin_mainCPP-1338">      for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-1339">        if(code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-1340">           if(i == E_AXIS) {</front>
<front id="Marlin_mainCPP-1341">             current_position[i] = code_value();</front>
<front id="Marlin_mainCPP-1342">             plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1343">           }</front>
<front id="Marlin_mainCPP-1344">           else {</front>
<front id="Marlin_mainCPP-1345">             current_position[i] = code_value()+add_homeing[i];</front>
<front id="Marlin_mainCPP-1346">             plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1347">           }</front>
<front id="Marlin_mainCPP-1348">        }</front>
<front id="Marlin_mainCPP-1349">      }</front>
<front id="Marlin_mainCPP-1350">      break;</front>
<front id="Marlin_mainCPP-1351">    }</front>
<front id="Marlin_mainCPP-1352">  }</front>
<front id="Marlin_mainCPP-1353"></front>
<front id="Marlin_mainCPP-1354">  else if(code_seen('M'))</front>
<front id="Marlin_mainCPP-1355">  {</front>
<front id="Marlin_mainCPP-1356">    switch( (int)code_value() )</front>
<front id="Marlin_mainCPP-1357">    {</front>
<front id="Marlin_mainCPP-1358">#ifdef ULTIPANEL</front>
<front id="Marlin_mainCPP-1359">    case 0: // M0 - Unconditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-1360">    case 1: // M1 - Conditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-1361">    {</front>
<front id="Marlin_mainCPP-1362">      LCD_MESSAGEPGM(MSG_USERWAIT);</front>
<front id="Marlin_mainCPP-1363">      codenum = 0;</front>
<front id="Marlin_mainCPP-1364">      if(code_seen('P')) codenum = code_value(); // milliseconds to wait</front>
<front id="Marlin_mainCPP-1365">      if(code_seen('S')) codenum = code_value() * 1000; // seconds to wait</front>
<front id="Marlin_mainCPP-1366"></front>
<front id="Marlin_mainCPP-1367">      st_synchronize();</front>
<front id="Marlin_mainCPP-1368">      previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-1369">      if (codenum &gt; 0){</front>
<front id="Marlin_mainCPP-1370">        codenum += millis();  // keep track of when we started waiting</front>
<front id="Marlin_mainCPP-1371">        while(millis()  &lt; codenum && !lcd_clicked()){</front>
<front id="Marlin_mainCPP-1372">          manage_heater();</front>
<front id="Marlin_mainCPP-1373">          manage_inactivity();</front>
<front id="Marlin_mainCPP-1374">          lcd_update();</front>
<front id="Marlin_mainCPP-1375">        }</front>
<front id="Marlin_mainCPP-1376">      }else{</front>
<front id="Marlin_mainCPP-1377">        while(!lcd_clicked()){</front>
<front id="Marlin_mainCPP-1378">          manage_heater();</front>
<front id="Marlin_mainCPP-1379">          manage_inactivity();</front>
<front id="Marlin_mainCPP-1380">          lcd_update();</front>
<front id="Marlin_mainCPP-1381">        }</front>
<front id="Marlin_mainCPP-1382">      }</front>
<front id="Marlin_mainCPP-1383">      LCD_MESSAGEPGM(MSG_RESUMING);</front>
<front id="Marlin_mainCPP-1384">    }</front>
<front id="Marlin_mainCPP-1385">    break;</front>
<front id="Marlin_mainCPP-1386">#endif</front>
<front id="Marlin_mainCPP-1387">    case 17:</front>
<front id="Marlin_mainCPP-1388">        LCD_MESSAGEPGM(MSG_NO_MOVE);</front>
<front id="Marlin_mainCPP-1389">        enable_x();</front>
<front id="Marlin_mainCPP-1390">        enable_y();</front>
<front id="Marlin_mainCPP-1391">        enable_z();</front>
<front id="Marlin_mainCPP-1392">        enable_e0();</front>
<front id="Marlin_mainCPP-1393">        enable_e1();</front>
<front id="Marlin_mainCPP-1394">        enable_e2();</front>
<front id="Marlin_mainCPP-1395">      break;</front>
<front id="Marlin_mainCPP-1396"></front>
<front id="Marlin_mainCPP-1397">#ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-1398">    case 20: // M20 - list SD card</front>
<front id="Marlin_mainCPP-1399">      SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);</front>
<front id="Marlin_mainCPP-1400">      card.ls();</front>
<front id="Marlin_mainCPP-1401">      SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);</front>
<front id="Marlin_mainCPP-1402">      break;</front>
<front id="Marlin_mainCPP-1403">    case 21: // M21 - init SD card</front>
<front id="Marlin_mainCPP-1404"></front>
<front id="Marlin_mainCPP-1405">      card.initsd();</front>
<front id="Marlin_mainCPP-1406"></front>
<front id="Marlin_mainCPP-1407">      break;</front>
<front id="Marlin_mainCPP-1408">    case 22: //M22 - release SD card</front>
<front id="Marlin_mainCPP-1409">      card.release();</front>
<front id="Marlin_mainCPP-1410"></front>
<front id="Marlin_mainCPP-1411">      break;</front>
<front id="Marlin_mainCPP-1412">    case 23: //M23 - Select file</front>
<front id="Marlin_mainCPP-1413">      starpos = (strchr(strchr_pointer + 4,'*'));</front>
<front id="Marlin_mainCPP-1414">      if(starpos!=NULL)</front>
<front id="Marlin_mainCPP-1415">        *(starpos-1)='\0';</front>
<front id="Marlin_mainCPP-1416">      card.openFile(strchr_pointer + 4,true);</front>
<front id="Marlin_mainCPP-1417">      break;</front>
<front id="Marlin_mainCPP-1418">    case 24: //M24 - Start SD print</front>
<front id="Marlin_mainCPP-1419">      card.startFileprint();</front>
<front id="Marlin_mainCPP-1420">      starttime=millis();</front>
<front id="Marlin_mainCPP-1421">      break;</front>
<front id="Marlin_mainCPP-1422">    case 25: //M25 - Pause SD print</front>
<front id="Marlin_mainCPP-1423">      card.pauseSDPrint();</front>
<front id="Marlin_mainCPP-1424">      break;</front>
<front id="Marlin_mainCPP-1425">    case 26: //M26 - Set SD index</front>
<front id="Marlin_mainCPP-1426">      if(card.cardOK && code_seen('S')) {</front>
<front id="Marlin_mainCPP-1427">        card.setIndex(code_value_long());</front>
<front id="Marlin_mainCPP-1428">      }</front>
<front id="Marlin_mainCPP-1429">      break;</front>
<front id="Marlin_mainCPP-1430">    case 27: //M27 - Get SD status</front>
<front id="Marlin_mainCPP-1431">      card.getStatus();</front>
<front id="Marlin_mainCPP-1432">      break;</front>
<front id="Marlin_mainCPP-1433">    case 28: //M28 - Start SD write</front>
<front id="Marlin_mainCPP-1434">      starpos = (strchr(strchr_pointer + 4,'*'));</front>
<front id="Marlin_mainCPP-1435">      if(starpos != NULL){</front>
<front id="Marlin_mainCPP-1436">        char* npos = strchr(cmdbuffer[bufindr], 'N');</front>
<front id="Marlin_mainCPP-1437">        strchr_pointer = strchr(npos,' ') + 1;</front>
<front id="Marlin_mainCPP-1438">        *(starpos-1) = '\0';</front>
<front id="Marlin_mainCPP-1439">      }</front>
<front id="Marlin_mainCPP-1440">      card.openFile(strchr_pointer+4,false);</front>
<front id="Marlin_mainCPP-1441">      break;</front>
<front id="Marlin_mainCPP-1442">    case 29: //M29 - Stop SD write</front>
<front id="Marlin_mainCPP-1443">      //processed in write to file routine above</front>
<front id="Marlin_mainCPP-1444">      //card,saving = false;</front>
<front id="Marlin_mainCPP-1445">      break;</front>
<front id="Marlin_mainCPP-1446">    case 30: //M30 &lt;filename&gt; Delete File</front>
<front id="Marlin_mainCPP-1447">      if (card.cardOK){</front>
<front id="Marlin_mainCPP-1448">        card.closefile();</front>
<front id="Marlin_mainCPP-1449">        starpos = (strchr(strchr_pointer + 4,'*'));</front>
<front id="Marlin_mainCPP-1450">        if(starpos != NULL){</front>
<front id="Marlin_mainCPP-1451">          char* npos = strchr(cmdbuffer[bufindr], 'N');</front>
<front id="Marlin_mainCPP-1452">          strchr_pointer = strchr(npos,' ') + 1;</front>
<front id="Marlin_mainCPP-1453">          *(starpos-1) = '\0';</front>
<front id="Marlin_mainCPP-1454">        }</front>
<front id="Marlin_mainCPP-1455">        card.removeFile(strchr_pointer + 4);</front>
<front id="Marlin_mainCPP-1456">      }</front>
<front id="Marlin_mainCPP-1457">      break;</front>
<front id="Marlin_mainCPP-1458">    case 32: //M32 - Select file and start SD print</front>
<front id="Marlin_mainCPP-1459">      if(card.sdprinting) {</front>
<front id="Marlin_mainCPP-1460">        st_synchronize();</front>
<front id="Marlin_mainCPP-1461">        card.closefile();</front>
<front id="Marlin_mainCPP-1462">        card.sdprinting = false;</front>
<front id="Marlin_mainCPP-1463">      }</front>
<front id="Marlin_mainCPP-1464">      starpos = (strchr(strchr_pointer + 4,'*'));</front>
<front id="Marlin_mainCPP-1465">      if(starpos!=NULL)</front>
<front id="Marlin_mainCPP-1466">        *(starpos-1)='\0';</front>
<front id="Marlin_mainCPP-1467">      card.openFile(strchr_pointer + 4,true);</front>
<front id="Marlin_mainCPP-1468">      card.startFileprint();</front>
<front id="Marlin_mainCPP-1469">      starttime=millis();</front>
<front id="Marlin_mainCPP-1470">      break;</front>
<front id="Marlin_mainCPP-1471">    case 928: //M928 - Start SD write</front>
<front id="Marlin_mainCPP-1472">      starpos = (strchr(strchr_pointer + 5,'*'));</front>
<front id="Marlin_mainCPP-1473">      if(starpos != NULL){</front>
<front id="Marlin_mainCPP-1474">        char* npos = strchr(cmdbuffer[bufindr], 'N');</front>
<front id="Marlin_mainCPP-1475">        strchr_pointer = strchr(npos,' ') + 1;</front>
<front id="Marlin_mainCPP-1476">        *(starpos-1) = '\0';</front>
<front id="Marlin_mainCPP-1477">      }</front>
<front id="Marlin_mainCPP-1478">      card.openLogFile(strchr_pointer+5);</front>
<front id="Marlin_mainCPP-1479">      break;</front>
<front id="Marlin_mainCPP-1480"></front>
<front id="Marlin_mainCPP-1481">#endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-1482"></front>
<front id="Marlin_mainCPP-1483">    case 31: //M31 take time since the start of the SD print or an M109 command</front>
<front id="Marlin_mainCPP-1484">      {</front>
<front id="Marlin_mainCPP-1485">      stoptime=millis();</front>
<front id="Marlin_mainCPP-1486">      char time[30];</front>
<front id="Marlin_mainCPP-1487">      unsigned long t=(stoptime-starttime)/1000;</front>
<front id="Marlin_mainCPP-1488">      int sec,min;</front>
<front id="Marlin_mainCPP-1489">      min=t/60;</front>
<front id="Marlin_mainCPP-1490">      sec=t%60;</front>
<front id="Marlin_mainCPP-1491">      sprintf_P(time, PSTR("%i min, %i sec"), min, sec);</front>
<front id="Marlin_mainCPP-1492">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-1493">      SERIAL_ECHOLN(time);</front>
<front id="Marlin_mainCPP-1494">      lcd_setstatus(time);</front>
<front id="Marlin_mainCPP-1495">      autotempShutdown();</front>
<front id="Marlin_mainCPP-1496">      }</front>
<front id="Marlin_mainCPP-1497">      break;</front>
<front id="Marlin_mainCPP-1498">    case 42: //M42 -Change pin status via gcode</front>
<front id="Marlin_mainCPP-1499">      if (code_seen('S'))</front>
<front id="Marlin_mainCPP-1500">      {</front>
<front id="Marlin_mainCPP-1501">        int pin_status = code_value();</front>
<front id="Marlin_mainCPP-1502">        int pin_number = LED_PIN;</front>
<front id="Marlin_mainCPP-1503">        if (code_seen('P') && pin_status &gt;= 0 && pin_status &lt;= 255)</front>
<front id="Marlin_mainCPP-1504">          pin_number = code_value();</front>
<front id="Marlin_mainCPP-1505">        for(int8_t i = 0; i &lt; (int8_t)sizeof(sensitive_pins); i++)</front>
<front id="Marlin_mainCPP-1506">        {</front>
<front id="Marlin_mainCPP-1507">          if (sensitive_pins[i] == pin_number)</front>
<front id="Marlin_mainCPP-1508">          {</front>
<front id="Marlin_mainCPP-1509">            pin_number = -1;</front>
<front id="Marlin_mainCPP-1510">            break;</front>
<front id="Marlin_mainCPP-1511">          }</front>
<front id="Marlin_mainCPP-1512">        }</front>
<front id="Marlin_mainCPP-1513">      #if defined(FAN_PIN) && FAN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1514">        if (pin_number == FAN_PIN)</front>
<front id="Marlin_mainCPP-1515">          fanSpeed = pin_status;</front>
<front id="Marlin_mainCPP-1516">      #endif</front>
<front id="Marlin_mainCPP-1517">        if (pin_number &gt; -1)</front>
<front id="Marlin_mainCPP-1518">        {</front>
<front id="Marlin_mainCPP-1519">          pinMode(pin_number, OUTPUT);</front>
<front id="Marlin_mainCPP-1520">          digitalWrite(pin_number, pin_status);</front>
<front id="Marlin_mainCPP-1521">          analogWrite(pin_number, pin_status);</front>
<front id="Marlin_mainCPP-1522">        }</front>
<front id="Marlin_mainCPP-1523">      }</front>
<front id="Marlin_mainCPP-1524">     break;</front>
<front id="Marlin_mainCPP-1525">    case 104: // M104</front>
<front id="Marlin_mainCPP-1526">      if(setTargetedHotend(104)){</front>
<front id="Marlin_mainCPP-1527">        break;</front>
<front id="Marlin_mainCPP-1528">      }</front>
<front id="Marlin_mainCPP-1529">      if (code_seen('S')) setTargetHotend(code_value(), tmp_extruder);</front>
<front id="Marlin_mainCPP-1530">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1531">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)</front>
<front id="Marlin_mainCPP-1532">        setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-1533">#endif          </front>
<front id="Marlin_mainCPP-1534">      setWatch();</front>
<front id="Marlin_mainCPP-1535">      break;</front>
<front id="Marlin_mainCPP-1536">    case 140: // M140 set bed temp</front>
<front id="Marlin_mainCPP-1537">      if (code_seen('S')) setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-1538">      break;</front>
<front id="Marlin_mainCPP-1539">    case 105 : // M105</front>
<front id="Marlin_mainCPP-1540">      if(setTargetedHotend(105)){</front>
<front id="Marlin_mainCPP-1541">        break;</front>
<front id="Marlin_mainCPP-1542">        }</front>
<front id="Marlin_mainCPP-1543">      #if defined(TEMP_0_PIN) && TEMP_0_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1544">        SERIAL_PROTOCOLPGM("ok T:");</front>
<front id="Marlin_mainCPP-1545">        SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);</front>
<front id="Marlin_mainCPP-1546">        SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-1547">        SERIAL_PROTOCOL_F(degTargetHotend(tmp_extruder),1);</front>
<front id="Marlin_mainCPP-1548">        #if defined(TEMP_BED_PIN) && TEMP_BED_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1549">          SERIAL_PROTOCOLPGM(" B:");</front>
<front id="Marlin_mainCPP-1550">          SERIAL_PROTOCOL_F(degBed(),1);</front>
<front id="Marlin_mainCPP-1551">          SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-1552">          SERIAL_PROTOCOL_F(degTargetBed(),1);</front>
<front id="Marlin_mainCPP-1553">        #endif //TEMP_BED_PIN</front>
<front id="Marlin_mainCPP-1554">        for (int8_t cur_extruder = 0; cur_extruder &lt; EXTRUDERS; ++cur_extruder) {</front>
<front id="Marlin_mainCPP-1555">          SERIAL_PROTOCOLPGM(" T");</front>
<front id="Marlin_mainCPP-1556">          SERIAL_PROTOCOL(cur_extruder);</front>
<front id="Marlin_mainCPP-1557">          SERIAL_PROTOCOLPGM(":");</front>
<front id="Marlin_mainCPP-1558">          SERIAL_PROTOCOL_F(degHotend(cur_extruder),1);</front>
<front id="Marlin_mainCPP-1559">          SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-1560">          SERIAL_PROTOCOL_F(degTargetHotend(cur_extruder),1);</front>
<front id="Marlin_mainCPP-1561">        }</front>
<front id="Marlin_mainCPP-1562">      #else</front>
<front id="Marlin_mainCPP-1563">        SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-1564">        SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);</front>
<front id="Marlin_mainCPP-1565">      #endif</front>
<front id="Marlin_mainCPP-1566"></front>
<front id="Marlin_mainCPP-1567">        SERIAL_PROTOCOLPGM(" @:");</front>
<front id="Marlin_mainCPP-1568">        SERIAL_PROTOCOL(getHeaterPower(tmp_extruder));</front>
<front id="Marlin_mainCPP-1569"></front>
<front id="Marlin_mainCPP-1570">        SERIAL_PROTOCOLPGM(" B@:");</front>
<front id="Marlin_mainCPP-1571">        SERIAL_PROTOCOL(getHeaterPower(-1));</front>
<front id="Marlin_mainCPP-1572"></front>
<front id="Marlin_mainCPP-1573">        SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-1574">      return;</front>
<front id="Marlin_mainCPP-1575">      break;</front>
<front id="Marlin_mainCPP-1576">    case 109:</front>
<front id="Marlin_mainCPP-1577">    {// M109 - Wait for extruder heater to reach target.</front>
<front id="Marlin_mainCPP-1578">      if(setTargetedHotend(109)){</front>
<front id="Marlin_mainCPP-1579">        break;</front>
<front id="Marlin_mainCPP-1580">      }</front>
<front id="Marlin_mainCPP-1581">      LCD_MESSAGEPGM(MSG_HEATING);</front>
<front id="Marlin_mainCPP-1582">      #ifdef AUTOTEMP</front>
<front id="Marlin_mainCPP-1583">        autotemp_enabled=false;</front>
<front id="Marlin_mainCPP-1584">      #endif</front>
<front id="Marlin_mainCPP-1585">      if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-1586">        setTargetHotend(code_value(), tmp_extruder);</front>
<front id="Marlin_mainCPP-1587">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1588">        if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)</front>
<front id="Marlin_mainCPP-1589">          setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-1590">#endif          </front>
<front id="Marlin_mainCPP-1591">        CooldownNoWait = true;</front>
<front id="Marlin_mainCPP-1592">      } else if (code_seen('R')) {</front>
<front id="Marlin_mainCPP-1593">        setTargetHotend(code_value(), tmp_extruder);</front>
<front id="Marlin_mainCPP-1594">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1595">        if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && tmp_extruder == 0)</front>
<front id="Marlin_mainCPP-1596">          setTargetHotend1(code_value() == 0.0 ? 0.0 : code_value() + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-1597">#endif          </front>
<front id="Marlin_mainCPP-1598">        CooldownNoWait = false;</front>
<front id="Marlin_mainCPP-1599">      }</front>
<front id="Marlin_mainCPP-1600">      #ifdef AUTOTEMP</front>
<front id="Marlin_mainCPP-1601">        if (code_seen('S')) autotemp_min=code_value();</front>
<front id="Marlin_mainCPP-1602">        if (code_seen('B')) autotemp_max=code_value();</front>
<front id="Marlin_mainCPP-1603">        if (code_seen('F'))</front>
<front id="Marlin_mainCPP-1604">        {</front>
<front id="Marlin_mainCPP-1605">          autotemp_factor=code_value();</front>
<front id="Marlin_mainCPP-1606">          autotemp_enabled=true;</front>
<front id="Marlin_mainCPP-1607">        }</front>
<front id="Marlin_mainCPP-1608">      #endif</front>
<front id="Marlin_mainCPP-1609"></front>
<front id="Marlin_mainCPP-1610">      setWatch();</front>
<front id="Marlin_mainCPP-1611">      codenum = millis();</front>
<front id="Marlin_mainCPP-1612"></front>
<front id="Marlin_mainCPP-1613">      /* See if we are heating up or cooling down */</front>
<front id="Marlin_mainCPP-1614">      target_direction = isHeatingHotend(tmp_extruder); // true if heating, false if cooling</front>
<front id="Marlin_mainCPP-1615"></front>
<front id="Marlin_mainCPP-1616">      #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-1617">        long residencyStart;</front>
<front id="Marlin_mainCPP-1618">        residencyStart = -1;</front>
<front id="Marlin_mainCPP-1619">        /* continue to loop until we have reached the target temp</front>
<front id="Marlin_mainCPP-1620">          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */</front>
<front id="Marlin_mainCPP-1621">        while((residencyStart == -1) ||</front>
<front id="Marlin_mainCPP-1622">              (residencyStart &gt;= 0 && (((unsigned int) (millis() - residencyStart)) &lt; (TEMP_RESIDENCY_TIME * 1000UL))) ) {</front>
<front id="Marlin_mainCPP-1623">      #else</front>
<front id="Marlin_mainCPP-1624">        while ( target_direction ? (isHeatingHotend(tmp_extruder)) : (isCoolingHotend(tmp_extruder)&&(CooldownNoWait==false)) ) {</front>
<front id="Marlin_mainCPP-1625">      #endif //TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-1626">          if( (millis() - codenum) &gt; 1000UL )</front>
<front id="Marlin_mainCPP-1627">          { //Print Temp Reading and remaining time every 1 second while heating up/cooling down</front>
<front id="Marlin_mainCPP-1628">            SERIAL_PROTOCOLPGM("T:");</front>
<front id="Marlin_mainCPP-1629">            SERIAL_PROTOCOL_F(degHotend(tmp_extruder),1);</front>
<front id="Marlin_mainCPP-1630">            SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-1631">            SERIAL_PROTOCOL((int)tmp_extruder);</front>
<front id="Marlin_mainCPP-1632">            #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-1633">              SERIAL_PROTOCOLPGM(" W:");</front>
<front id="Marlin_mainCPP-1634">              if(residencyStart &gt; -1)</front>
<front id="Marlin_mainCPP-1635">              {</front>
<front id="Marlin_mainCPP-1636">                 codenum = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residencyStart)) / 1000UL;</front>
<front id="Marlin_mainCPP-1637">                 SERIAL_PROTOCOLLN( codenum );</front>
<front id="Marlin_mainCPP-1638">              }</front>
<front id="Marlin_mainCPP-1639">              else</front>
<front id="Marlin_mainCPP-1640">              {</front>
<front id="Marlin_mainCPP-1641">                 SERIAL_PROTOCOLLN( "?" );</front>
<front id="Marlin_mainCPP-1642">              }</front>
<front id="Marlin_mainCPP-1643">            #else</front>
<front id="Marlin_mainCPP-1644">              SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-1645">            #endif</front>
<front id="Marlin_mainCPP-1646">            codenum = millis();</front>
<front id="Marlin_mainCPP-1647">          }</front>
<front id="Marlin_mainCPP-1648">          manage_heater();</front>
<front id="Marlin_mainCPP-1649">          manage_inactivity();</front>
<front id="Marlin_mainCPP-1650">          lcd_update();</front>
<front id="Marlin_mainCPP-1651">        #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-1652">            /* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time</front>
<front id="Marlin_mainCPP-1653">              or when current temp falls outside the hysteresis after target temp was reached */</front>
<front id="Marlin_mainCPP-1654">          if ((residencyStart == -1 &&  target_direction && (degHotend(tmp_extruder) &gt;= (degTargetHotend(tmp_extruder)-TEMP_WINDOW))) ||</front>
<front id="Marlin_mainCPP-1655">              (residencyStart == -1 && !target_direction && (degHotend(tmp_extruder) &lt;= (degTargetHotend(tmp_extruder)+TEMP_WINDOW))) ||</front>
<front id="Marlin_mainCPP-1656">              (residencyStart &gt; -1 && labs(degHotend(tmp_extruder) - degTargetHotend(tmp_extruder)) &gt; TEMP_HYSTERESIS) )</front>
<front id="Marlin_mainCPP-1657">          {</front>
<front id="Marlin_mainCPP-1658">            residencyStart = millis();</front>
<front id="Marlin_mainCPP-1659">          }</front>
<front id="Marlin_mainCPP-1660">        #endif //TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-1661">        }</front>
<front id="Marlin_mainCPP-1662">        LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);</front>
<front id="Marlin_mainCPP-1663">        starttime=millis();</front>
<front id="Marlin_mainCPP-1664">        previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-1665">      }</front>
<front id="Marlin_mainCPP-1666">      break;</front>
<front id="Marlin_mainCPP-1667">    case 190: // M190 - Wait for bed heater to reach target.</front>
<front id="Marlin_mainCPP-1668">    #if defined(TEMP_BED_PIN) && TEMP_BED_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1669">        LCD_MESSAGEPGM(MSG_BED_HEATING);</front>
<front id="Marlin_mainCPP-1670">        if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-1671">          setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-1672">          CooldownNoWait = true;</front>
<front id="Marlin_mainCPP-1673">        } else if (code_seen('R')) {</front>
<front id="Marlin_mainCPP-1674">          setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-1675">          CooldownNoWait = false;</front>
<front id="Marlin_mainCPP-1676">        }</front>
<front id="Marlin_mainCPP-1677">        codenum = millis();</front>
<front id="Marlin_mainCPP-1678"></front>
<front id="Marlin_mainCPP-1679">        target_direction = isHeatingBed(); // true if heating, false if cooling</front>
<front id="Marlin_mainCPP-1680"></front>
<front id="Marlin_mainCPP-1681">        while ( target_direction ? (isHeatingBed()) : (isCoolingBed()&&(CooldownNoWait==false)) )</front>
<front id="Marlin_mainCPP-1682">        {</front>
<front id="Marlin_mainCPP-1683">          if(( millis() - codenum) &gt; 1000 ) //Print Temp Reading every 1 second while heating up.</front>
<front id="Marlin_mainCPP-1684">          {</front>
<front id="Marlin_mainCPP-1685">            float tt=degHotend(active_extruder);</front>
<front id="Marlin_mainCPP-1686">            SERIAL_PROTOCOLPGM("T:");</front>
<front id="Marlin_mainCPP-1687">            SERIAL_PROTOCOL(tt);</front>
<front id="Marlin_mainCPP-1688">            SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-1689">            SERIAL_PROTOCOL((int)active_extruder);</front>
<front id="Marlin_mainCPP-1690">            SERIAL_PROTOCOLPGM(" B:");</front>
<front id="Marlin_mainCPP-1691">            SERIAL_PROTOCOL_F(degBed(),1);</front>
<front id="Marlin_mainCPP-1692">            SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-1693">            codenum = millis();</front>
<front id="Marlin_mainCPP-1694">          }</front>
<front id="Marlin_mainCPP-1695">          manage_heater();</front>
<front id="Marlin_mainCPP-1696">          manage_inactivity();</front>
<front id="Marlin_mainCPP-1697">          lcd_update();</front>
<front id="Marlin_mainCPP-1698">        }</front>
<front id="Marlin_mainCPP-1699">        LCD_MESSAGEPGM(MSG_BED_DONE);</front>
<front id="Marlin_mainCPP-1700">        previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-1701">    #endif</front>
<front id="Marlin_mainCPP-1702">        break;</front>
<front id="Marlin_mainCPP-1703"></front>
<front id="Marlin_mainCPP-1704">    #if defined(FAN_PIN) && FAN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1705">      case 106: //M106 Fan On</front>
<front id="Marlin_mainCPP-1706">        if (code_seen('S')){</front>
<front id="Marlin_mainCPP-1707">           fanSpeed=constrain(code_value(),0,255);</front>
<front id="Marlin_mainCPP-1708">        }</front>
<front id="Marlin_mainCPP-1709">        else {</front>
<front id="Marlin_mainCPP-1710">          fanSpeed=255;</front>
<front id="Marlin_mainCPP-1711">        }</front>
<front id="Marlin_mainCPP-1712">        break;</front>
<front id="Marlin_mainCPP-1713">      case 107: //M107 Fan Off</front>
<front id="Marlin_mainCPP-1714">        fanSpeed = 0;</front>
<front id="Marlin_mainCPP-1715">        break;</front>
<front id="Marlin_mainCPP-1716">    #endif //FAN_PIN</front>
<front id="Marlin_mainCPP-1717">    #ifdef BARICUDA</front>
<front id="Marlin_mainCPP-1718">      // PWM for HEATER_1_PIN</front>
<front id="Marlin_mainCPP-1719">      #if defined(HEATER_1_PIN) && HEATER_1_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1720">        case 126: //M126 valve open</front>
<front id="Marlin_mainCPP-1721">          if (code_seen('S')){</front>
<front id="Marlin_mainCPP-1722">             ValvePressure=constrain(code_value(),0,255);</front>
<front id="Marlin_mainCPP-1723">          }</front>
<front id="Marlin_mainCPP-1724">          else {</front>
<front id="Marlin_mainCPP-1725">            ValvePressure=255;</front>
<front id="Marlin_mainCPP-1726">          }</front>
<front id="Marlin_mainCPP-1727">          break;</front>
<front id="Marlin_mainCPP-1728">        case 127: //M127 valve closed</front>
<front id="Marlin_mainCPP-1729">          ValvePressure = 0;</front>
<front id="Marlin_mainCPP-1730">          break;</front>
<front id="Marlin_mainCPP-1731">      #endif //HEATER_1_PIN</front>
<front id="Marlin_mainCPP-1732"></front>
<front id="Marlin_mainCPP-1733">      // PWM for HEATER_2_PIN</front>
<front id="Marlin_mainCPP-1734">      #if defined(HEATER_2_PIN) && HEATER_2_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1735">        case 128: //M128 valve open</front>
<front id="Marlin_mainCPP-1736">          if (code_seen('S')){</front>
<front id="Marlin_mainCPP-1737">             EtoPPressure=constrain(code_value(),0,255);</front>
<front id="Marlin_mainCPP-1738">          }</front>
<front id="Marlin_mainCPP-1739">          else {</front>
<front id="Marlin_mainCPP-1740">            EtoPPressure=255;</front>
<front id="Marlin_mainCPP-1741">          }</front>
<front id="Marlin_mainCPP-1742">          break;</front>
<front id="Marlin_mainCPP-1743">        case 129: //M129 valve closed</front>
<front id="Marlin_mainCPP-1744">          EtoPPressure = 0;</front>
<front id="Marlin_mainCPP-1745">          break;</front>
<front id="Marlin_mainCPP-1746">      #endif //HEATER_2_PIN</front>
<front id="Marlin_mainCPP-1747">    #endif</front>
<front id="Marlin_mainCPP-1748"></front>
<front id="Marlin_mainCPP-1749">    #if defined(PS_ON_PIN) && PS_ON_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1750">      case 80: // M80 - Turn on Power Supply</front>
<front id="Marlin_mainCPP-1751">        SET_OUTPUT(PS_ON_PIN); //GND</front>
<front id="Marlin_mainCPP-1752">        WRITE(PS_ON_PIN, PS_ON_AWAKE);</front>
<front id="Marlin_mainCPP-1753">        #ifdef ULTIPANEL</front>
<front id="Marlin_mainCPP-1754">          powersupply = true;</front>
<front id="Marlin_mainCPP-1755">          LCD_MESSAGEPGM(WELCOME_MSG);</front>
<front id="Marlin_mainCPP-1756">          lcd_update();</front>
<front id="Marlin_mainCPP-1757">        #endif</front>
<front id="Marlin_mainCPP-1758">        break;</front>
<front id="Marlin_mainCPP-1759">      #endif</front>
<front id="Marlin_mainCPP-1760"></front>
<front id="Marlin_mainCPP-1761">      case 81: // M81 - Turn off Power Supply</front>
<front id="Marlin_mainCPP-1762">        disable_heater();</front>
<front id="Marlin_mainCPP-1763">        st_synchronize();</front>
<front id="Marlin_mainCPP-1764">        disable_e0();</front>
<front id="Marlin_mainCPP-1765">        disable_e1();</front>
<front id="Marlin_mainCPP-1766">        disable_e2();</front>
<front id="Marlin_mainCPP-1767">        finishAndDisableSteppers();</front>
<front id="Marlin_mainCPP-1768">        fanSpeed = 0;</front>
<front id="Marlin_mainCPP-1769">        delay(1000); // Wait a little before to switch off</front>
<front id="Marlin_mainCPP-1770">      #if defined(SUICIDE_PIN) && SUICIDE_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1771">        st_synchronize();</front>
<front id="Marlin_mainCPP-1772">        suicide();</front>
<front id="Marlin_mainCPP-1773">      #elif defined(PS_ON_PIN) && PS_ON_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1774">        SET_OUTPUT(PS_ON_PIN);</front>
<front id="Marlin_mainCPP-1775">        WRITE(PS_ON_PIN, PS_ON_ASLEEP);</front>
<front id="Marlin_mainCPP-1776">      #endif</front>
<front id="Marlin_mainCPP-1777">      #ifdef ULTIPANEL</front>
<front id="Marlin_mainCPP-1778">        powersupply = false;</front>
<front id="Marlin_mainCPP-1779">        LCD_MESSAGEPGM(MACHINE_NAME" "MSG_OFF".");</front>
<front id="Marlin_mainCPP-1780">        lcd_update();</front>
<front id="Marlin_mainCPP-1781">      #endif</front>
<front id="Marlin_mainCPP-1782">	  break;</front>
<front id="Marlin_mainCPP-1783"></front>
<front id="Marlin_mainCPP-1784">    case 82:</front>
<front id="Marlin_mainCPP-1785">      axis_relative_modes[3] = false;</front>
<front id="Marlin_mainCPP-1786">      break;</front>
<front id="Marlin_mainCPP-1787">    case 83:</front>
<front id="Marlin_mainCPP-1788">      axis_relative_modes[3] = true;</front>
<front id="Marlin_mainCPP-1789">      break;</front>
<front id="Marlin_mainCPP-1790">    case 18: //compatibility</front>
<front id="Marlin_mainCPP-1791">    case 84: // M84</front>
<front id="Marlin_mainCPP-1792">      if(code_seen('S')){</front>
<front id="Marlin_mainCPP-1793">        stepper_inactive_time = code_value() * 1000;</front>
<front id="Marlin_mainCPP-1794">      }</front>
<front id="Marlin_mainCPP-1795">      else</front>
<front id="Marlin_mainCPP-1796">      {</front>
<front id="Marlin_mainCPP-1797">        bool all_axis = !((code_seen(axis_codes[0])) || (code_seen(axis_codes[1])) || (code_seen(axis_codes[2]))|| (code_seen(axis_codes[3])));</front>
<front id="Marlin_mainCPP-1798">        if(all_axis)</front>
<front id="Marlin_mainCPP-1799">        {</front>
<front id="Marlin_mainCPP-1800">          st_synchronize();</front>
<front id="Marlin_mainCPP-1801">          disable_e0();</front>
<front id="Marlin_mainCPP-1802">          disable_e1();</front>
<front id="Marlin_mainCPP-1803">          disable_e2();</front>
<front id="Marlin_mainCPP-1804">          finishAndDisableSteppers();</front>
<front id="Marlin_mainCPP-1805">        }</front>
<front id="Marlin_mainCPP-1806">        else</front>
<front id="Marlin_mainCPP-1807">        {</front>
<front id="Marlin_mainCPP-1808">          st_synchronize();</front>
<front id="Marlin_mainCPP-1809">          if(code_seen('X')) disable_x();</front>
<front id="Marlin_mainCPP-1810">          if(code_seen('Y')) disable_y();</front>
<front id="Marlin_mainCPP-1811">          if(code_seen('Z')) disable_z();</front>
<front id="Marlin_mainCPP-1812">          #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS</front>
<front id="Marlin_mainCPP-1813">            if(code_seen('E')) {</front>
<front id="Marlin_mainCPP-1814">              disable_e0();</front>
<front id="Marlin_mainCPP-1815">              disable_e1();</front>
<front id="Marlin_mainCPP-1816">              disable_e2();</front>
<front id="Marlin_mainCPP-1817">            }</front>
<front id="Marlin_mainCPP-1818">          #endif</front>
<front id="Marlin_mainCPP-1819">        }</front>
<front id="Marlin_mainCPP-1820">      }</front>
<front id="Marlin_mainCPP-1821">      break;</front>
<front id="Marlin_mainCPP-1822">    case 85: // M85</front>
<front id="Marlin_mainCPP-1823">      code_seen('S');</front>
<front id="Marlin_mainCPP-1824">      max_inactive_time = code_value() * 1000;</front>
<front id="Marlin_mainCPP-1825">      break;</front>
<front id="Marlin_mainCPP-1826">    case 92: // M92</front>
<front id="Marlin_mainCPP-1827">      for(int8_t i=0; i &lt; NUM_AXIS; i++)</front>
<front id="Marlin_mainCPP-1828">      {</front>
<front id="Marlin_mainCPP-1829">        if(code_seen(axis_codes[i]))</front>
<front id="Marlin_mainCPP-1830">        {</front>
<front id="Marlin_mainCPP-1831">          if(i == 3) { // E</front>
<front id="Marlin_mainCPP-1832">            float value = code_value();</front>
<front id="Marlin_mainCPP-1833">            if(value &lt; 20.0) {</front>
<front id="Marlin_mainCPP-1834">              float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.</front>
<front id="Marlin_mainCPP-1835">              max_e_jerk *= factor;</front>
<front id="Marlin_mainCPP-1836">              max_feedrate[i] *= factor;</front>
<front id="Marlin_mainCPP-1837">              axis_steps_per_sqr_second[i] *= factor;</front>
<front id="Marlin_mainCPP-1838">            }</front>
<front id="Marlin_mainCPP-1839">            axis_steps_per_unit[i] = value;</front>
<front id="Marlin_mainCPP-1840">          }</front>
<front id="Marlin_mainCPP-1841">          else {</front>
<front id="Marlin_mainCPP-1842">            axis_steps_per_unit[i] = code_value();</front>
<front id="Marlin_mainCPP-1843">          }</front>
<front id="Marlin_mainCPP-1844">        }</front>
<front id="Marlin_mainCPP-1845">      }</front>
<front id="Marlin_mainCPP-1846">      break;</front>
<front id="Marlin_mainCPP-1847">    case 115: // M115</front>
<front id="Marlin_mainCPP-1848">      SERIAL_PROTOCOLPGM(MSG_M115_REPORT);</front>
<front id="Marlin_mainCPP-1849">      break;</front>
<front id="Marlin_mainCPP-1850">    case 117: // M117 display message</front>
<front id="Marlin_mainCPP-1851">      starpos = (strchr(strchr_pointer + 5,'*'));</front>
<front id="Marlin_mainCPP-1852">      if(starpos!=NULL)</front>
<front id="Marlin_mainCPP-1853">        *(starpos-1)='\0';</front>
<front id="Marlin_mainCPP-1854">      lcd_setstatus(strchr_pointer + 5);</front>
<front id="Marlin_mainCPP-1855">      break;</front>
<front id="Marlin_mainCPP-1856">    case 114: // M114</front>
<front id="Marlin_mainCPP-1857">      SERIAL_PROTOCOLPGM("X:");</front>
<front id="Marlin_mainCPP-1858">      SERIAL_PROTOCOL(current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-1859">      SERIAL_PROTOCOLPGM("Y:");</front>
<front id="Marlin_mainCPP-1860">      SERIAL_PROTOCOL(current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1861">      SERIAL_PROTOCOLPGM("Z:");</front>
<front id="Marlin_mainCPP-1862">      SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1863">      SERIAL_PROTOCOLPGM("E:");</front>
<front id="Marlin_mainCPP-1864">      SERIAL_PROTOCOL(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1865"></front>
<front id="Marlin_mainCPP-1866">      SERIAL_PROTOCOLPGM(MSG_COUNT_X);</front>
<front id="Marlin_mainCPP-1867">      SERIAL_PROTOCOL(float(st_get_position(X_AXIS))/axis_steps_per_unit[X_AXIS]);</front>
<front id="Marlin_mainCPP-1868">      SERIAL_PROTOCOLPGM("Y:");</front>
<front id="Marlin_mainCPP-1869">      SERIAL_PROTOCOL(float(st_get_position(Y_AXIS))/axis_steps_per_unit[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1870">      SERIAL_PROTOCOLPGM("Z:");</front>
<front id="Marlin_mainCPP-1871">      SERIAL_PROTOCOL(float(st_get_position(Z_AXIS))/axis_steps_per_unit[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1872"></front>
<front id="Marlin_mainCPP-1873">      SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-1874">      break;</front>
<front id="Marlin_mainCPP-1875">    case 120: // M120</front>
<front id="Marlin_mainCPP-1876">      enable_endstops(false) ;</front>
<front id="Marlin_mainCPP-1877">      break;</front>
<front id="Marlin_mainCPP-1878">    case 121: // M121</front>
<front id="Marlin_mainCPP-1879">      enable_endstops(true) ;</front>
<front id="Marlin_mainCPP-1880">      break;</front>
<front id="Marlin_mainCPP-1881">    case 119: // M119</front>
<front id="Marlin_mainCPP-1882">    SERIAL_PROTOCOLLN(MSG_M119_REPORT);</front>
<front id="Marlin_mainCPP-1883">      #if defined(X_MIN_PIN) && X_MIN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1884">        SERIAL_PROTOCOLPGM(MSG_X_MIN);</front>
<front id="Marlin_mainCPP-1885">        SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-1886">      #endif</front>
<front id="Marlin_mainCPP-1887">      #if defined(X_MAX_PIN) && X_MAX_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1888">        SERIAL_PROTOCOLPGM(MSG_X_MAX);</front>
<front id="Marlin_mainCPP-1889">        SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-1890">      #endif</front>
<front id="Marlin_mainCPP-1891">      #if defined(Y_MIN_PIN) && Y_MIN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1892">        SERIAL_PROTOCOLPGM(MSG_Y_MIN);</front>
<front id="Marlin_mainCPP-1893">        SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-1894">      #endif</front>
<front id="Marlin_mainCPP-1895">      #if defined(Y_MAX_PIN) && Y_MAX_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1896">        SERIAL_PROTOCOLPGM(MSG_Y_MAX);</front>
<front id="Marlin_mainCPP-1897">        SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-1898">      #endif</front>
<front id="Marlin_mainCPP-1899">      #if defined(Z_MIN_PIN) && Z_MIN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1900">        SERIAL_PROTOCOLPGM(MSG_Z_MIN);</front>
<front id="Marlin_mainCPP-1901">        SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-1902">      #endif</front>
<front id="Marlin_mainCPP-1903">      #if defined(Z_MAX_PIN) && Z_MAX_PIN &gt; -1</front>
<front id="Marlin_mainCPP-1904">        SERIAL_PROTOCOLPGM(MSG_Z_MAX);</front>
<front id="Marlin_mainCPP-1905">        SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-1906">      #endif</front>
<front id="Marlin_mainCPP-1907">      break;</front>
<front id="Marlin_mainCPP-1908">      //TODO: update for all axis, use for loop</front>
<front id="Marlin_mainCPP-1909">    case 201: // M201</front>
<front id="Marlin_mainCPP-1910">      for(int8_t i=0; i &lt; NUM_AXIS; i++)</front>
<front id="Marlin_mainCPP-1911">      {</front>
<front id="Marlin_mainCPP-1912">        if(code_seen(axis_codes[i]))</front>
<front id="Marlin_mainCPP-1913">        {</front>
<front id="Marlin_mainCPP-1914">          max_acceleration_units_per_sq_second[i] = code_value();</front>
<front id="Marlin_mainCPP-1915">        }</front>
<front id="Marlin_mainCPP-1916">      }</front>
<front id="Marlin_mainCPP-1917">      // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</front>
<front id="Marlin_mainCPP-1918">      reset_acceleration_rates();</front>
<front id="Marlin_mainCPP-1919">      break;</front>
<front id="Marlin_mainCPP-1920">    #if 0 // Not used for Sprinter/grbl gen6</front>
<front id="Marlin_mainCPP-1921">    case 202: // M202</front>
<front id="Marlin_mainCPP-1922">      for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-1923">        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];</front>
<front id="Marlin_mainCPP-1924">      }</front>
<front id="Marlin_mainCPP-1925">      break;</front>
<front id="Marlin_mainCPP-1926">    #endif</front>
<front id="Marlin_mainCPP-1927">    case 203: // M203 max feedrate mm/sec</front>
<front id="Marlin_mainCPP-1928">      for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-1929">        if(code_seen(axis_codes[i])) max_feedrate[i] = code_value();</front>
<front id="Marlin_mainCPP-1930">      }</front>
<front id="Marlin_mainCPP-1931">      break;</front>
<front id="Marlin_mainCPP-1932">    case 204: // M204 acclereration S normal moves T filmanent only moves</front>
<front id="Marlin_mainCPP-1933">      {</front>
<front id="Marlin_mainCPP-1934">        if(code_seen('S')) acceleration = code_value() ;</front>
<front id="Marlin_mainCPP-1935">        if(code_seen('T')) retract_acceleration = code_value() ;</front>
<front id="Marlin_mainCPP-1936">      }</front>
<front id="Marlin_mainCPP-1937">      break;</front>
<front id="Marlin_mainCPP-1938">    case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk</front>
<front id="Marlin_mainCPP-1939">    {</front>
<front id="Marlin_mainCPP-1940">      if(code_seen('S')) minimumfeedrate = code_value();</front>
<front id="Marlin_mainCPP-1941">      if(code_seen('T')) mintravelfeedrate = code_value();</front>
<front id="Marlin_mainCPP-1942">      if(code_seen('B')) minsegmenttime = code_value() ;</front>
<front id="Marlin_mainCPP-1943">      if(code_seen('X')) max_xy_jerk = code_value() ;</front>
<front id="Marlin_mainCPP-1944">      if(code_seen('Z')) max_z_jerk = code_value() ;</front>
<front id="Marlin_mainCPP-1945">      if(code_seen('E')) max_e_jerk = code_value() ;</front>
<front id="Marlin_mainCPP-1946">    }</front>
<front id="Marlin_mainCPP-1947">    break;</front>
<front id="Marlin_mainCPP-1948">    case 206: // M206 additional homeing offset</front>
<front id="Marlin_mainCPP-1949">      for(int8_t i=0; i &lt; 3; i++)</front>
<front id="Marlin_mainCPP-1950">      {</front>
<front id="Marlin_mainCPP-1951">        if(code_seen(axis_codes[i])) add_homeing[i] = code_value();</front>
<front id="Marlin_mainCPP-1952">      }</front>
<front id="Marlin_mainCPP-1953">      break;</front>
<front id="Marlin_mainCPP-1954">    #ifdef DELTA</front>
<front id="Marlin_mainCPP-1955">    case 666: // M666 set delta endstop adjustemnt</front>
<front id="Marlin_mainCPP-1956">      for(int8_t i=0; i &lt; 3; i++)</front>
<front id="Marlin_mainCPP-1957">      {</front>
<front id="Marlin_mainCPP-1958">        if(code_seen(axis_codes[i])) endstop_adj[i] = code_value();</front>
<front id="Marlin_mainCPP-1959">      }</front>
<front id="Marlin_mainCPP-1960">      break;</front>
<front id="Marlin_mainCPP-1961">    #endif</front>
<front id="Marlin_mainCPP-1962">    #ifdef FWRETRACT</front>
<front id="Marlin_mainCPP-1963">    case 207: //M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]</front>
<front id="Marlin_mainCPP-1964">    {</front>
<front id="Marlin_mainCPP-1965">      if(code_seen('S'))</front>
<front id="Marlin_mainCPP-1966">      {</front>
<front id="Marlin_mainCPP-1967">        retract_length = code_value() ;</front>
<front id="Marlin_mainCPP-1968">      }</front>
<front id="Marlin_mainCPP-1969">      if(code_seen('F'))</front>
<front id="Marlin_mainCPP-1970">      {</front>
<front id="Marlin_mainCPP-1971">        retract_feedrate = code_value() ;</front>
<front id="Marlin_mainCPP-1972">      }</front>
<front id="Marlin_mainCPP-1973">      if(code_seen('Z'))</front>
<front id="Marlin_mainCPP-1974">      {</front>
<front id="Marlin_mainCPP-1975">        retract_zlift = code_value() ;</front>
<front id="Marlin_mainCPP-1976">      }</front>
<front id="Marlin_mainCPP-1977">    }break;</front>
<front id="Marlin_mainCPP-1978">    case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]</front>
<front id="Marlin_mainCPP-1979">    {</front>
<front id="Marlin_mainCPP-1980">      if(code_seen('S'))</front>
<front id="Marlin_mainCPP-1981">      {</front>
<front id="Marlin_mainCPP-1982">        retract_recover_length = code_value() ;</front>
<front id="Marlin_mainCPP-1983">      }</front>
<front id="Marlin_mainCPP-1984">      if(code_seen('F'))</front>
<front id="Marlin_mainCPP-1985">      {</front>
<front id="Marlin_mainCPP-1986">        retract_recover_feedrate = code_value() ;</front>
<front id="Marlin_mainCPP-1987">      }</front>
<front id="Marlin_mainCPP-1988">    }break;</front>
<front id="Marlin_mainCPP-1989">    case 209: // M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-1990">    {</front>
<front id="Marlin_mainCPP-1991">      if(code_seen('S'))</front>
<front id="Marlin_mainCPP-1992">      {</front>
<front id="Marlin_mainCPP-1993">        int t= code_value() ;</front>
<front id="Marlin_mainCPP-1994">        switch(t)</front>
<front id="Marlin_mainCPP-1995">        {</front>
<front id="Marlin_mainCPP-1996">          case 0: autoretract_enabled=false;retracted=false;break;</front>
<front id="Marlin_mainCPP-1997">          case 1: autoretract_enabled=true;retracted=false;break;</front>
<front id="Marlin_mainCPP-1998">          default:</front>
<front id="Marlin_mainCPP-1999">            SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2000">            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);</front>
<front id="Marlin_mainCPP-2001">            SERIAL_ECHO(cmdbuffer[bufindr]);</front>
<front id="Marlin_mainCPP-2002">            SERIAL_ECHOLNPGM("\"");</front>
<front id="Marlin_mainCPP-2003">        }</front>
<front id="Marlin_mainCPP-2004">      }</front>
<front id="Marlin_mainCPP-2005"></front>
<front id="Marlin_mainCPP-2006">    }break;</front>
<front id="Marlin_mainCPP-2007">    #endif // FWRETRACT</front>
<front id="Marlin_mainCPP-2008">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-2009">    case 218: // M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-2010">    {</front>
<front id="Marlin_mainCPP-2011">      if(setTargetedHotend(218)){</front>
<front id="Marlin_mainCPP-2012">        break;</front>
<front id="Marlin_mainCPP-2013">      }</front>
<front id="Marlin_mainCPP-2014">      if(code_seen('X'))</front>
<front id="Marlin_mainCPP-2015">      {</front>
<front id="Marlin_mainCPP-2016">        extruder_offset[X_AXIS][tmp_extruder] = code_value();</front>
<front id="Marlin_mainCPP-2017">      }</front>
<front id="Marlin_mainCPP-2018">      if(code_seen('Y'))</front>
<front id="Marlin_mainCPP-2019">      {</front>
<front id="Marlin_mainCPP-2020">        extruder_offset[Y_AXIS][tmp_extruder] = code_value();</front>
<front id="Marlin_mainCPP-2021">      }</front>
<front id="Marlin_mainCPP-2022">      #ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2023">      if(code_seen('Z'))</front>
<front id="Marlin_mainCPP-2024">      {</front>
<front id="Marlin_mainCPP-2025">        extruder_offset[Z_AXIS][tmp_extruder] = code_value();</front>
<front id="Marlin_mainCPP-2026">      }</front>
<front id="Marlin_mainCPP-2027">      #endif       </front>
<front id="Marlin_mainCPP-2028">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2029">      SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);</front>
<front id="Marlin_mainCPP-2030">      for(tmp_extruder = 0; tmp_extruder &lt; EXTRUDERS; tmp_extruder++)</front>
<front id="Marlin_mainCPP-2031">      {</front>
<front id="Marlin_mainCPP-2032">         SERIAL_ECHO(" ");</front>
<front id="Marlin_mainCPP-2033">         SERIAL_ECHO(extruder_offset[X_AXIS][tmp_extruder]);</front>
<front id="Marlin_mainCPP-2034">         SERIAL_ECHO(",");</front>
<front id="Marlin_mainCPP-2035">         SERIAL_ECHO(extruder_offset[Y_AXIS][tmp_extruder]);</front>
<front id="Marlin_mainCPP-2036">      #ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2037">         SERIAL_ECHO(",");</front>
<front id="Marlin_mainCPP-2038">         SERIAL_ECHO(extruder_offset[Z_AXIS][tmp_extruder]);</front>
<front id="Marlin_mainCPP-2039">      #endif</front>
<front id="Marlin_mainCPP-2040">      }</front>
<front id="Marlin_mainCPP-2041">      SERIAL_ECHOLN("");</front>
<front id="Marlin_mainCPP-2042">    }break;</front>
<front id="Marlin_mainCPP-2043">    #endif</front>
<front id="Marlin_mainCPP-2044">    case 220: // M220 S&lt;factor in percent&gt;- set speed factor override percentage</front>
<front id="Marlin_mainCPP-2045">    {</front>
<front id="Marlin_mainCPP-2046">      if(code_seen('S'))</front>
<front id="Marlin_mainCPP-2047">      {</front>
<front id="Marlin_mainCPP-2048">        feedmultiply = code_value() ;</front>
<front id="Marlin_mainCPP-2049">      }</front>
<front id="Marlin_mainCPP-2050">    }</front>
<front id="Marlin_mainCPP-2051">    break;</front>
<front id="Marlin_mainCPP-2052">    case 221: // M221 S&lt;factor in percent&gt;- set extrude factor override percentage</front>
<front id="Marlin_mainCPP-2053">    {</front>
<front id="Marlin_mainCPP-2054">      if(code_seen('S'))</front>
<front id="Marlin_mainCPP-2055">      {</front>
<front id="Marlin_mainCPP-2056">        extrudemultiply = code_value() ;</front>
<front id="Marlin_mainCPP-2057">      }</front>
<front id="Marlin_mainCPP-2058">    }</front>
<front id="Marlin_mainCPP-2059">    break;</front>
<front id="Marlin_mainCPP-2060"></front>
<front id="Marlin_mainCPP-2061">    #if NUM_SERVOS &gt; 0</front>
<front id="Marlin_mainCPP-2062">    case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds</front>
<front id="Marlin_mainCPP-2063">      {</front>
<front id="Marlin_mainCPP-2064">        int servo_index = -1;</front>
<front id="Marlin_mainCPP-2065">        int servo_position = 0;</front>
<front id="Marlin_mainCPP-2066">        if (code_seen('P'))</front>
<front id="Marlin_mainCPP-2067">          servo_index = code_value();</front>
<front id="Marlin_mainCPP-2068">        if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-2069">          servo_position = code_value();</front>
<front id="Marlin_mainCPP-2070">          if ((servo_index &gt;= 0) && (servo_index &lt; NUM_SERVOS)) {</front>
<front id="Marlin_mainCPP-2071">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-2072">		      servos[servo_index].attach(0);</front>
<front id="Marlin_mainCPP-2073">#endif</front>
<front id="Marlin_mainCPP-2074">            servos[servo_index].write(servo_position);</front>
<front id="Marlin_mainCPP-2075">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="Marlin_mainCPP-2076">              delay(PROBE_SERVO_DEACTIVATION_DELAY);</front>
<front id="Marlin_mainCPP-2077">              servos[servo_index].detach();</front>
<front id="Marlin_mainCPP-2078">#endif</front>
<front id="Marlin_mainCPP-2079">          }</front>
<front id="Marlin_mainCPP-2080">          else {</front>
<front id="Marlin_mainCPP-2081">            SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2082">            SERIAL_ECHO("Servo ");</front>
<front id="Marlin_mainCPP-2083">            SERIAL_ECHO(servo_index);</front>
<front id="Marlin_mainCPP-2084">            SERIAL_ECHOLN(" out of range");</front>
<front id="Marlin_mainCPP-2085">          }</front>
<front id="Marlin_mainCPP-2086">        }</front>
<front id="Marlin_mainCPP-2087">        else if (servo_index &gt;= 0) {</front>
<front id="Marlin_mainCPP-2088">          SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-2089">          SERIAL_PROTOCOL(" Servo ");</front>
<front id="Marlin_mainCPP-2090">          SERIAL_PROTOCOL(servo_index);</front>
<front id="Marlin_mainCPP-2091">          SERIAL_PROTOCOL(": ");</front>
<front id="Marlin_mainCPP-2092">          SERIAL_PROTOCOL(servos[servo_index].read());</front>
<front id="Marlin_mainCPP-2093">          SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-2094">        }</front>
<front id="Marlin_mainCPP-2095">      }</front>
<front id="Marlin_mainCPP-2096">      break;</front>
<front id="Marlin_mainCPP-2097">    #endif // NUM_SERVOS &gt; 0</front>
<front id="Marlin_mainCPP-2098"></front>
<front id="Marlin_mainCPP-2099">    #if LARGE_FLASH == true && ( BEEPER &gt; 0 || defined(ULTRALCD) )</front>
<front id="Marlin_mainCPP-2100">    case 300: // M300</front>
<front id="Marlin_mainCPP-2101">    {</front>
<front id="Marlin_mainCPP-2102">      int beepS = code_seen('S') ? code_value() : 110;</front>
<front id="Marlin_mainCPP-2103">      int beepP = code_seen('P') ? code_value() : 1000;</front>
<front id="Marlin_mainCPP-2104">      if (beepS &gt; 0)</front>
<front id="Marlin_mainCPP-2105">      {</front>
<front id="Marlin_mainCPP-2106">        #if BEEPER &gt; 0</front>
<front id="Marlin_mainCPP-2107">          tone(BEEPER, beepS);</front>
<front id="Marlin_mainCPP-2108">          delay(beepP);</front>
<front id="Marlin_mainCPP-2109">          noTone(BEEPER);</front>
<front id="Marlin_mainCPP-2110">        #elif defined(ULTRALCD)</front>
<front id="Marlin_mainCPP-2111">          lcd_buzz(beepS, beepP);</front>
<front id="Marlin_mainCPP-2112">        #endif</front>
<front id="Marlin_mainCPP-2113">      }</front>
<front id="Marlin_mainCPP-2114">      else</front>
<front id="Marlin_mainCPP-2115">      {</front>
<front id="Marlin_mainCPP-2116">        delay(beepP);</front>
<front id="Marlin_mainCPP-2117">      }</front>
<front id="Marlin_mainCPP-2118">    }</front>
<front id="Marlin_mainCPP-2119">    break;</front>
<front id="Marlin_mainCPP-2120">    #endif // M300</front>
<front id="Marlin_mainCPP-2121"></front>
<front id="Marlin_mainCPP-2122">    #ifdef PIDTEMP</front>
<front id="Marlin_mainCPP-2123">    case 301: // M301</front>
<front id="Marlin_mainCPP-2124">      {</front>
<front id="Marlin_mainCPP-2125">        if(code_seen('P')) Kp = code_value();</front>
<front id="Marlin_mainCPP-2126">        if(code_seen('I')) Ki = scalePID_i(code_value());</front>
<front id="Marlin_mainCPP-2127">        if(code_seen('D')) Kd = scalePID_d(code_value());</front>
<front id="Marlin_mainCPP-2128"></front>
<front id="Marlin_mainCPP-2129">        #ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="Marlin_mainCPP-2130">        if(code_seen('C')) Kc = code_value();</front>
<front id="Marlin_mainCPP-2131">        #endif</front>
<front id="Marlin_mainCPP-2132"></front>
<front id="Marlin_mainCPP-2133">        updatePID();</front>
<front id="Marlin_mainCPP-2134">        SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-2135">        SERIAL_PROTOCOL(" p:");</front>
<front id="Marlin_mainCPP-2136">        SERIAL_PROTOCOL(Kp);</front>
<front id="Marlin_mainCPP-2137">        SERIAL_PROTOCOL(" i:");</front>
<front id="Marlin_mainCPP-2138">        SERIAL_PROTOCOL(unscalePID_i(Ki));</front>
<front id="Marlin_mainCPP-2139">        SERIAL_PROTOCOL(" d:");</front>
<front id="Marlin_mainCPP-2140">        SERIAL_PROTOCOL(unscalePID_d(Kd));</front>
<front id="Marlin_mainCPP-2141">        #ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="Marlin_mainCPP-2142">        SERIAL_PROTOCOL(" c:");</front>
<front id="Marlin_mainCPP-2143">        //Kc does not have scaling applied above, or in resetting defaults</front>
<front id="Marlin_mainCPP-2144">        SERIAL_PROTOCOL(Kc);</front>
<front id="Marlin_mainCPP-2145">        #endif</front>
<front id="Marlin_mainCPP-2146">        SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-2147">      }</front>
<front id="Marlin_mainCPP-2148">      break;</front>
<front id="Marlin_mainCPP-2149">    #endif //PIDTEMP</front>
<front id="Marlin_mainCPP-2150">    #ifdef PIDTEMPBED</front>
<front id="Marlin_mainCPP-2151">    case 304: // M304</front>
<front id="Marlin_mainCPP-2152">      {</front>
<front id="Marlin_mainCPP-2153">        if(code_seen('P')) bedKp = code_value();</front>
<front id="Marlin_mainCPP-2154">        if(code_seen('I')) bedKi = scalePID_i(code_value());</front>
<front id="Marlin_mainCPP-2155">        if(code_seen('D')) bedKd = scalePID_d(code_value());</front>
<front id="Marlin_mainCPP-2156"></front>
<front id="Marlin_mainCPP-2157">        updatePID();</front>
<front id="Marlin_mainCPP-2158">        SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-2159">        SERIAL_PROTOCOL(" p:");</front>
<front id="Marlin_mainCPP-2160">        SERIAL_PROTOCOL(bedKp);</front>
<front id="Marlin_mainCPP-2161">        SERIAL_PROTOCOL(" i:");</front>
<front id="Marlin_mainCPP-2162">        SERIAL_PROTOCOL(unscalePID_i(bedKi));</front>
<front id="Marlin_mainCPP-2163">        SERIAL_PROTOCOL(" d:");</front>
<front id="Marlin_mainCPP-2164">        SERIAL_PROTOCOL(unscalePID_d(bedKd));</front>
<front id="Marlin_mainCPP-2165">        SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-2166">      }</front>
<front id="Marlin_mainCPP-2167">      break;</front>
<front id="Marlin_mainCPP-2168">    #endif //PIDTEMP</front>
<front id="Marlin_mainCPP-2169">    case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="Marlin_mainCPP-2170">     {</front>
<front id="Marlin_mainCPP-2171">      #if defined(PHOTOGRAPH_PIN) && PHOTOGRAPH_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2172">        const uint8_t NUM_PULSES=16;</front>
<front id="Marlin_mainCPP-2173">        const float PULSE_LENGTH=0.01524;</front>
<front id="Marlin_mainCPP-2174">        for(int i=0; i &lt; NUM_PULSES; i++) {</front>
<front id="Marlin_mainCPP-2175">          WRITE(PHOTOGRAPH_PIN, HIGH);</front>
<front id="Marlin_mainCPP-2176">          _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-2177">          WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-2178">          _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-2179">        }</front>
<front id="Marlin_mainCPP-2180">        delay(7.33);</front>
<front id="Marlin_mainCPP-2181">        for(int i=0; i &lt; NUM_PULSES; i++) {</front>
<front id="Marlin_mainCPP-2182">          WRITE(PHOTOGRAPH_PIN, HIGH);</front>
<front id="Marlin_mainCPP-2183">          _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-2184">          WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-2185">          _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-2186">        }</front>
<front id="Marlin_mainCPP-2187">      #endif</front>
<front id="Marlin_mainCPP-2188">     }</front>
<front id="Marlin_mainCPP-2189">    break;</front>
<front id="Marlin_mainCPP-2190">#ifdef DOGLCD</front>
<front id="Marlin_mainCPP-2191">    case 250: // M250  Set LCD contrast value: C&lt;value&gt; (value 0..63)</front>
<front id="Marlin_mainCPP-2192">     {</front>
<front id="Marlin_mainCPP-2193">	  if (code_seen('C')) {</front>
<front id="Marlin_mainCPP-2194">	   lcd_setcontrast( ((int)code_value())&63 );</front>
<front id="Marlin_mainCPP-2195">          }</front>
<front id="Marlin_mainCPP-2196">          SERIAL_PROTOCOLPGM("lcd contrast value: ");</front>
<front id="Marlin_mainCPP-2197">          SERIAL_PROTOCOL(lcd_contrast);</front>
<front id="Marlin_mainCPP-2198">          SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-2199">     }</front>
<front id="Marlin_mainCPP-2200">    break;</front>
<front id="Marlin_mainCPP-2201">#endif</front>
<front id="Marlin_mainCPP-2202">    #ifdef PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-2203">    case 302: // allow cold extrudes, or set the minimum extrude temperature</front>
<front id="Marlin_mainCPP-2204">    {</front>
<front id="Marlin_mainCPP-2205">	  float temp = .0;</front>
<front id="Marlin_mainCPP-2206">	  if (code_seen('S')) temp=code_value();</front>
<front id="Marlin_mainCPP-2207">      set_extrude_min_temp(temp);</front>
<front id="Marlin_mainCPP-2208">    }</front>
<front id="Marlin_mainCPP-2209">    break;</front>
<front id="Marlin_mainCPP-2210">	#endif</front>
<front id="Marlin_mainCPP-2211">    case 303: // M303 PID autotune</front>
<front id="Marlin_mainCPP-2212">    {</front>
<front id="Marlin_mainCPP-2213">      float temp = 150.0;</front>
<front id="Marlin_mainCPP-2214">      int e=0;</front>
<front id="Marlin_mainCPP-2215">      int c=5;</front>
<front id="Marlin_mainCPP-2216">      if (code_seen('E')) e=code_value();</front>
<front id="Marlin_mainCPP-2217">        if (e&lt;0)</front>
<front id="Marlin_mainCPP-2218">          temp=70;</front>
<front id="Marlin_mainCPP-2219">      if (code_seen('S')) temp=code_value();</front>
<front id="Marlin_mainCPP-2220">      if (code_seen('C')) c=code_value();</front>
<front id="Marlin_mainCPP-2221">      PID_autotune(temp, e, c);</front>
<front id="Marlin_mainCPP-2222">    }</front>
<front id="Marlin_mainCPP-2223">    break;</front>
<front id="Marlin_mainCPP-2224">    case 400: // M400 finish all moves</front>
<front id="Marlin_mainCPP-2225">    {</front>
<front id="Marlin_mainCPP-2226">      st_synchronize();</front>
<front id="Marlin_mainCPP-2227">    }</front>
<front id="Marlin_mainCPP-2228">    break;</front>
<front id="Marlin_mainCPP-2229">#if defined(ENABLE_AUTO_BED_LEVELING) && defined(SERVO_ENDSTOPS)</front>
<front id="Marlin_mainCPP-2230">    case 401:</front>
<front id="Marlin_mainCPP-2231">    {</front>
<front id="Marlin_mainCPP-2232">        engage_z_probe();    // Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-2233">    }</front>
<front id="Marlin_mainCPP-2234">    break;</front>
<front id="Marlin_mainCPP-2235">    </front>
<front id="Marlin_mainCPP-2236">    case 402:</front>
<front id="Marlin_mainCPP-2237">    {</front>
<front id="Marlin_mainCPP-2238">        retract_z_probe();    // Retract Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-2239">    }</front>
<front id="Marlin_mainCPP-2240">    break;</front>
<front id="Marlin_mainCPP-2241">#endif    </front>
<front id="Marlin_mainCPP-2242">    case 500: // M500 Store settings in EEPROM</front>
<front id="Marlin_mainCPP-2243">    {</front>
<front id="Marlin_mainCPP-2244">        Config_StoreSettings();</front>
<front id="Marlin_mainCPP-2245">    }</front>
<front id="Marlin_mainCPP-2246">    break;</front>
<front id="Marlin_mainCPP-2247">    case 501: // M501 Read settings from EEPROM</front>
<front id="Marlin_mainCPP-2248">    {</front>
<front id="Marlin_mainCPP-2249">        Config_RetrieveSettings();</front>
<front id="Marlin_mainCPP-2250">    }</front>
<front id="Marlin_mainCPP-2251">    break;</front>
<front id="Marlin_mainCPP-2252">    case 502: // M502 Revert to default settings</front>
<front id="Marlin_mainCPP-2253">    {</front>
<front id="Marlin_mainCPP-2254">        Config_ResetDefault();</front>
<front id="Marlin_mainCPP-2255">    }</front>
<front id="Marlin_mainCPP-2256">    break;</front>
<front id="Marlin_mainCPP-2257">    case 503: // M503 print settings currently in memory</front>
<front id="Marlin_mainCPP-2258">    {</front>
<front id="Marlin_mainCPP-2259">        Config_PrintSettings();</front>
<front id="Marlin_mainCPP-2260">    }</front>
<front id="Marlin_mainCPP-2261">    break;</front>
<front id="Marlin_mainCPP-2262">    #ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="Marlin_mainCPP-2263">    case 540:</front>
<front id="Marlin_mainCPP-2264">    {</front>
<front id="Marlin_mainCPP-2265">        if(code_seen('S')) abort_on_endstop_hit = code_value() &gt; 0;</front>
<front id="Marlin_mainCPP-2266">    }</front>
<front id="Marlin_mainCPP-2267">    break;</front>
<front id="Marlin_mainCPP-2268">    #endif</front>
<front id="Marlin_mainCPP-2269">    #ifdef FILAMENTCHANGEENABLE</front>
<front id="Marlin_mainCPP-2270">    case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</front>
<front id="Marlin_mainCPP-2271">    {</front>
<front id="Marlin_mainCPP-2272">        float target[4];</front>
<front id="Marlin_mainCPP-2273">        float lastpos[4];</front>
<front id="Marlin_mainCPP-2274">        target[X_AXIS]=current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-2275">        target[Y_AXIS]=current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-2276">        target[Z_AXIS]=current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-2277">        target[E_AXIS]=current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-2278">        lastpos[X_AXIS]=current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-2279">        lastpos[Y_AXIS]=current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-2280">        lastpos[Z_AXIS]=current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-2281">        lastpos[E_AXIS]=current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-2282">        //retract by E</front>
<front id="Marlin_mainCPP-2283">        if(code_seen('E'))</front>
<front id="Marlin_mainCPP-2284">        {</front>
<front id="Marlin_mainCPP-2285">          target[E_AXIS]+= code_value();</front>
<front id="Marlin_mainCPP-2286">        }</front>
<front id="Marlin_mainCPP-2287">        else</front>
<front id="Marlin_mainCPP-2288">        {</front>
<front id="Marlin_mainCPP-2289">          #ifdef FILAMENTCHANGE_FIRSTRETRACT</front>
<front id="Marlin_mainCPP-2290">            target[E_AXIS]+= FILAMENTCHANGE_FIRSTRETRACT ;</front>
<front id="Marlin_mainCPP-2291">          #endif</front>
<front id="Marlin_mainCPP-2292">        }</front>
<front id="Marlin_mainCPP-2293">        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-2294"></front>
<front id="Marlin_mainCPP-2295">        //lift Z</front>
<front id="Marlin_mainCPP-2296">        if(code_seen('Z'))</front>
<front id="Marlin_mainCPP-2297">        {</front>
<front id="Marlin_mainCPP-2298">          target[Z_AXIS]+= code_value();</front>
<front id="Marlin_mainCPP-2299">        }</front>
<front id="Marlin_mainCPP-2300">        else</front>
<front id="Marlin_mainCPP-2301">        {</front>
<front id="Marlin_mainCPP-2302">          #ifdef FILAMENTCHANGE_ZADD</front>
<front id="Marlin_mainCPP-2303">            target[Z_AXIS]+= FILAMENTCHANGE_ZADD ;</front>
<front id="Marlin_mainCPP-2304">          #endif</front>
<front id="Marlin_mainCPP-2305">        }</front>
<front id="Marlin_mainCPP-2306">        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-2307"></front>
<front id="Marlin_mainCPP-2308">        //move xy</front>
<front id="Marlin_mainCPP-2309">        if(code_seen('X'))</front>
<front id="Marlin_mainCPP-2310">        {</front>
<front id="Marlin_mainCPP-2311">          target[X_AXIS]+= code_value();</front>
<front id="Marlin_mainCPP-2312">        }</front>
<front id="Marlin_mainCPP-2313">        else</front>
<front id="Marlin_mainCPP-2314">        {</front>
<front id="Marlin_mainCPP-2315">          #ifdef FILAMENTCHANGE_XPOS</front>
<front id="Marlin_mainCPP-2316">            target[X_AXIS]= FILAMENTCHANGE_XPOS ;</front>
<front id="Marlin_mainCPP-2317">          #endif</front>
<front id="Marlin_mainCPP-2318">        }</front>
<front id="Marlin_mainCPP-2319">        if(code_seen('Y'))</front>
<front id="Marlin_mainCPP-2320">        {</front>
<front id="Marlin_mainCPP-2321">          target[Y_AXIS]= code_value();</front>
<front id="Marlin_mainCPP-2322">        }</front>
<front id="Marlin_mainCPP-2323">        else</front>
<front id="Marlin_mainCPP-2324">        {</front>
<front id="Marlin_mainCPP-2325">          #ifdef FILAMENTCHANGE_YPOS</front>
<front id="Marlin_mainCPP-2326">            target[Y_AXIS]= FILAMENTCHANGE_YPOS ;</front>
<front id="Marlin_mainCPP-2327">          #endif</front>
<front id="Marlin_mainCPP-2328">        }</front>
<front id="Marlin_mainCPP-2329"></front>
<front id="Marlin_mainCPP-2330">        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-2331"></front>
<front id="Marlin_mainCPP-2332">        if(code_seen('L'))</front>
<front id="Marlin_mainCPP-2333">        {</front>
<front id="Marlin_mainCPP-2334">          target[E_AXIS]+= code_value();</front>
<front id="Marlin_mainCPP-2335">        }</front>
<front id="Marlin_mainCPP-2336">        else</front>
<front id="Marlin_mainCPP-2337">        {</front>
<front id="Marlin_mainCPP-2338">          #ifdef FILAMENTCHANGE_FINALRETRACT</front>
<front id="Marlin_mainCPP-2339">            target[E_AXIS]+= FILAMENTCHANGE_FINALRETRACT ;</front>
<front id="Marlin_mainCPP-2340">          #endif</front>
<front id="Marlin_mainCPP-2341">        }</front>
<front id="Marlin_mainCPP-2342"></front>
<front id="Marlin_mainCPP-2343">        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-2344"></front>
<front id="Marlin_mainCPP-2345">        //finish moves</front>
<front id="Marlin_mainCPP-2346">        st_synchronize();</front>
<front id="Marlin_mainCPP-2347">        //disable extruder steppers so filament can be removed</front>
<front id="Marlin_mainCPP-2348">        disable_e0();</front>
<front id="Marlin_mainCPP-2349">        disable_e1();</front>
<front id="Marlin_mainCPP-2350">        disable_e2();</front>
<front id="Marlin_mainCPP-2351">        delay(100);</front>
<front id="Marlin_mainCPP-2352">        LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);</front>
<front id="Marlin_mainCPP-2353">        uint8_t cnt=0;</front>
<front id="Marlin_mainCPP-2354">        while(!lcd_clicked()){</front>
<front id="Marlin_mainCPP-2355">          cnt++;</front>
<front id="Marlin_mainCPP-2356">          manage_heater();</front>
<front id="Marlin_mainCPP-2357">          manage_inactivity();</front>
<front id="Marlin_mainCPP-2358">          lcd_update();</front>
<front id="Marlin_mainCPP-2359">          if(cnt==0)</front>
<front id="Marlin_mainCPP-2360">          {</front>
<front id="Marlin_mainCPP-2361">          #if BEEPER &gt; 0</front>
<front id="Marlin_mainCPP-2362">            SET_OUTPUT(BEEPER);</front>
<front id="Marlin_mainCPP-2363"></front>
<front id="Marlin_mainCPP-2364">            WRITE(BEEPER,HIGH);</front>
<front id="Marlin_mainCPP-2365">            delay(3);</front>
<front id="Marlin_mainCPP-2366">            WRITE(BEEPER,LOW);</front>
<front id="Marlin_mainCPP-2367">            delay(3);</front>
<front id="Marlin_mainCPP-2368">          #else</front>
<front id="Marlin_mainCPP-2369">            lcd_buzz(1000/6,100);</front>
<front id="Marlin_mainCPP-2370">          #endif</front>
<front id="Marlin_mainCPP-2371">          }</front>
<front id="Marlin_mainCPP-2372">        }</front>
<front id="Marlin_mainCPP-2373"></front>
<front id="Marlin_mainCPP-2374">        //return to normal</front>
<front id="Marlin_mainCPP-2375">        if(code_seen('L'))</front>
<front id="Marlin_mainCPP-2376">        {</front>
<front id="Marlin_mainCPP-2377">          target[E_AXIS]+= -code_value();</front>
<front id="Marlin_mainCPP-2378">        }</front>
<front id="Marlin_mainCPP-2379">        else</front>
<front id="Marlin_mainCPP-2380">        {</front>
<front id="Marlin_mainCPP-2381">          #ifdef FILAMENTCHANGE_FINALRETRACT</front>
<front id="Marlin_mainCPP-2382">            target[E_AXIS]+=(-1)*FILAMENTCHANGE_FINALRETRACT ;</front>
<front id="Marlin_mainCPP-2383">          #endif</front>
<front id="Marlin_mainCPP-2384">        }</front>
<front id="Marlin_mainCPP-2385">        current_position[E_AXIS]=target[E_AXIS]; //the long retract of L is compensated by manual filament feeding</front>
<front id="Marlin_mainCPP-2386">        plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2387">        plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //should do nothing</front>
<front id="Marlin_mainCPP-2388">        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], target[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move xy back</front>
<front id="Marlin_mainCPP-2389">        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], target[E_AXIS], feedrate/60, active_extruder); //move z back</front>
<front id="Marlin_mainCPP-2390">        plan_buffer_line(lastpos[X_AXIS], lastpos[Y_AXIS], lastpos[Z_AXIS], lastpos[E_AXIS], feedrate/60, active_extruder); //final untretract</front>
<front id="Marlin_mainCPP-2391">    }</front>
<front id="Marlin_mainCPP-2392">    break;</front>
<front id="Marlin_mainCPP-2393">    #endif //FILAMENTCHANGEENABLE</front>
<front id="Marlin_mainCPP-2394">    #ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2395">    case 605: // Set dual x-carriage movement mode:</front>
<front id="Marlin_mainCPP-2396">              //    M605 S0: Full control mode. The slicer has full control over x-carriage movement</front>
<front id="Marlin_mainCPP-2397">              //    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement</front>
<front id="Marlin_mainCPP-2398">              //    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn</front>
<front id="Marlin_mainCPP-2399">              //                         millimeters x-offset and an optional differential hotend temperature of </front>
<front id="Marlin_mainCPP-2400">              //                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate</front>
<front id="Marlin_mainCPP-2401">              //                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.</front>
<front id="Marlin_mainCPP-2402">              //</front>
<front id="Marlin_mainCPP-2403">              //    Note: the X axis should be homed after changing dual x-carriage mode.</front>
<front id="Marlin_mainCPP-2404">    {</front>
<front id="Marlin_mainCPP-2405">        st_synchronize();</front>
<front id="Marlin_mainCPP-2406">        </front>
<front id="Marlin_mainCPP-2407">        if (code_seen('S'))</front>
<front id="Marlin_mainCPP-2408">          dual_x_carriage_mode = code_value();</front>
<front id="Marlin_mainCPP-2409"></front>
<front id="Marlin_mainCPP-2410">        if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)</front>
<front id="Marlin_mainCPP-2411">        {</front>
<front id="Marlin_mainCPP-2412">          if (code_seen('X'))</front>
<front id="Marlin_mainCPP-2413">            duplicate_extruder_x_offset = max(code_value(),X2_MIN_POS - x_home_pos(0));</front>
<front id="Marlin_mainCPP-2414"></front>
<front id="Marlin_mainCPP-2415">          if (code_seen('R'))</front>
<front id="Marlin_mainCPP-2416">            duplicate_extruder_temp_offset = code_value();</front>
<front id="Marlin_mainCPP-2417">            </front>
<front id="Marlin_mainCPP-2418">          SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2419">          SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);</front>
<front id="Marlin_mainCPP-2420">          SERIAL_ECHO(" ");</front>
<front id="Marlin_mainCPP-2421">          SERIAL_ECHO(extruder_offset[X_AXIS][0]);</front>
<front id="Marlin_mainCPP-2422">          SERIAL_ECHO(",");</front>
<front id="Marlin_mainCPP-2423">          SERIAL_ECHO(extruder_offset[Y_AXIS][0]);</front>
<front id="Marlin_mainCPP-2424">          SERIAL_ECHO(" ");</front>
<front id="Marlin_mainCPP-2425">          SERIAL_ECHO(duplicate_extruder_x_offset);</front>
<front id="Marlin_mainCPP-2426">          SERIAL_ECHO(",");</front>
<front id="Marlin_mainCPP-2427">          SERIAL_ECHOLN(extruder_offset[Y_AXIS][1]);</front>
<front id="Marlin_mainCPP-2428">        }</front>
<front id="Marlin_mainCPP-2429">        else if (dual_x_carriage_mode != DXC_FULL_CONTROL_MODE && dual_x_carriage_mode != DXC_AUTO_PARK_MODE)</front>
<front id="Marlin_mainCPP-2430">        {</front>
<front id="Marlin_mainCPP-2431">          dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;</front>
<front id="Marlin_mainCPP-2432">        }</front>
<front id="Marlin_mainCPP-2433">        </front>
<front id="Marlin_mainCPP-2434">        active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-2435">        extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-2436">        delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-2437">    }</front>
<front id="Marlin_mainCPP-2438">    break;</front>
<front id="Marlin_mainCPP-2439">    #endif //DUAL_X_CARRIAGE         </front>
<front id="Marlin_mainCPP-2440"></front>
<front id="Marlin_mainCPP-2441">    case 907: // M907 Set digital trimpot motor current using axis codes.</front>
<front id="Marlin_mainCPP-2442">    {</front>
<front id="Marlin_mainCPP-2443">      #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2444">        for(int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_current(i,code_value());</front>
<front id="Marlin_mainCPP-2445">        if(code_seen('B')) digipot_current(4,code_value());</front>
<front id="Marlin_mainCPP-2446">        if(code_seen('S')) for(int i=0;i&lt;=4;i++) digipot_current(i,code_value());</front>
<front id="Marlin_mainCPP-2447">      #endif</front>
<front id="Marlin_mainCPP-2448">    }</front>
<front id="Marlin_mainCPP-2449">    break;</front>
<front id="Marlin_mainCPP-2450">    case 908: // M908 Control digital trimpot directly.</front>
<front id="Marlin_mainCPP-2451">    {</front>
<front id="Marlin_mainCPP-2452">      #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2453">        uint8_t channel,current;</front>
<front id="Marlin_mainCPP-2454">        if(code_seen('P')) channel=code_value();</front>
<front id="Marlin_mainCPP-2455">        if(code_seen('S')) current=code_value();</front>
<front id="Marlin_mainCPP-2456">        digitalPotWrite(channel, current);</front>
<front id="Marlin_mainCPP-2457">      #endif</front>
<front id="Marlin_mainCPP-2458">    }</front>
<front id="Marlin_mainCPP-2459">    break;</front>
<front id="Marlin_mainCPP-2460">    case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</front>
<front id="Marlin_mainCPP-2461">    {</front>
<front id="Marlin_mainCPP-2462">      #if defined(X_MS1_PIN) && X_MS1_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2463">        if(code_seen('S')) for(int i=0;i&lt;=4;i++) microstep_mode(i,code_value());</front>
<front id="Marlin_mainCPP-2464">        for(int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());</front>
<front id="Marlin_mainCPP-2465">        if(code_seen('B')) microstep_mode(4,code_value());</front>
<front id="Marlin_mainCPP-2466">        microstep_readings();</front>
<front id="Marlin_mainCPP-2467">      #endif</front>
<front id="Marlin_mainCPP-2468">    }</front>
<front id="Marlin_mainCPP-2469">    break;</front>
<front id="Marlin_mainCPP-2470">    case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.</front>
<front id="Marlin_mainCPP-2471">    {</front>
<front id="Marlin_mainCPP-2472">      #if defined(X_MS1_PIN) && X_MS1_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2473">      if(code_seen('S')) switch((int)code_value())</front>
<front id="Marlin_mainCPP-2474">      {</front>
<front id="Marlin_mainCPP-2475">        case 1:</front>
<front id="Marlin_mainCPP-2476">          for(int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,code_value(),-1);</front>
<front id="Marlin_mainCPP-2477">          if(code_seen('B')) microstep_ms(4,code_value(),-1);</front>
<front id="Marlin_mainCPP-2478">          break;</front>
<front id="Marlin_mainCPP-2479">        case 2:</front>
<front id="Marlin_mainCPP-2480">          for(int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_ms(i,-1,code_value());</front>
<front id="Marlin_mainCPP-2481">          if(code_seen('B')) microstep_ms(4,-1,code_value());</front>
<front id="Marlin_mainCPP-2482">          break;</front>
<front id="Marlin_mainCPP-2483">      }</front>
<front id="Marlin_mainCPP-2484">      microstep_readings();</front>
<front id="Marlin_mainCPP-2485">      #endif</front>
<front id="Marlin_mainCPP-2486">    }</front>
<front id="Marlin_mainCPP-2487">    break;</front>
<front id="Marlin_mainCPP-2488">    case 999: // M999: Restart after being stopped</front>
<front id="Marlin_mainCPP-2489">      Stopped = false;</front>
<front id="Marlin_mainCPP-2490">      lcd_reset_alert_level();</front>
<front id="Marlin_mainCPP-2491">      gcode_LastN = Stopped_gcode_LastN;</front>
<front id="Marlin_mainCPP-2492">      FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-2493">    break;</front>
<front id="Marlin_mainCPP-2494">    }</front>
<front id="Marlin_mainCPP-2495">  }</front>
<front id="Marlin_mainCPP-2496"></front>
<front id="Marlin_mainCPP-2497">  else if(code_seen('T'))</front>
<front id="Marlin_mainCPP-2498">  {</front>
<front id="Marlin_mainCPP-2499">    tmp_extruder = code_value();</front>
<front id="Marlin_mainCPP-2500">    if(tmp_extruder &gt;= EXTRUDERS) {</front>
<front id="Marlin_mainCPP-2501">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2502">      SERIAL_ECHO("T");</front>
<front id="Marlin_mainCPP-2503">      SERIAL_ECHO(tmp_extruder);</front>
<front id="Marlin_mainCPP-2504">      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-2505">    }</front>
<front id="Marlin_mainCPP-2506">    else {</front>
<front id="Marlin_mainCPP-2507">      boolean make_move = false;</front>
<front id="Marlin_mainCPP-2508">      if(code_seen('F')) {</front>
<front id="Marlin_mainCPP-2509">        make_move = true;</front>
<front id="Marlin_mainCPP-2510">        next_feedrate = code_value();</front>
<front id="Marlin_mainCPP-2511">        if(next_feedrate &gt; 0.0) {</front>
<front id="Marlin_mainCPP-2512">          feedrate = next_feedrate;</front>
<front id="Marlin_mainCPP-2513">        }</front>
<front id="Marlin_mainCPP-2514">      }</front>
<front id="Marlin_mainCPP-2515">      #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-2516">      if(tmp_extruder != active_extruder) {</front>
<front id="Marlin_mainCPP-2517">        // Save current position to return to after applying extruder offset</front>
<front id="Marlin_mainCPP-2518">        memcpy(destination, current_position, sizeof(destination));</front>
<front id="Marlin_mainCPP-2519">      #ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2520">        if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && Stopped == false && </front>
<front id="Marlin_mainCPP-2521">            (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder)))</front>
<front id="Marlin_mainCPP-2522">        {</front>
<front id="Marlin_mainCPP-2523">          // Park old head: 1) raise 2) move to park position 3) lower</front>
<front id="Marlin_mainCPP-2524">          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, </front>
<front id="Marlin_mainCPP-2525">                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-2526">          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT, </front>
<front id="Marlin_mainCPP-2527">                current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-2528">          plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS], </front>
<front id="Marlin_mainCPP-2529">                current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-2530">          st_synchronize();</front>
<front id="Marlin_mainCPP-2531">        }</front>
<front id="Marlin_mainCPP-2532">        </front>
<front id="Marlin_mainCPP-2533">        // apply Y & Z extruder offset (x offset is already used in determining home pos)</front>
<front id="Marlin_mainCPP-2534">        current_position[Y_AXIS] = current_position[Y_AXIS] -</front>
<front id="Marlin_mainCPP-2535">                     extruder_offset[Y_AXIS][active_extruder] +</front>
<front id="Marlin_mainCPP-2536">                     extruder_offset[Y_AXIS][tmp_extruder];</front>
<front id="Marlin_mainCPP-2537">        current_position[Z_AXIS] = current_position[Z_AXIS] -</front>
<front id="Marlin_mainCPP-2538">                     extruder_offset[Z_AXIS][active_extruder] +</front>
<front id="Marlin_mainCPP-2539">                     extruder_offset[Z_AXIS][tmp_extruder];</front>
<front id="Marlin_mainCPP-2540">                     </front>
<front id="Marlin_mainCPP-2541">        active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-2542"></front>
<front id="Marlin_mainCPP-2543">        // This function resets the max/min values - the current position may be overwritten below.</front>
<front id="Marlin_mainCPP-2544">        axis_is_at_home(X_AXIS);</front>
<front id="Marlin_mainCPP-2545"></front>
<front id="Marlin_mainCPP-2546">        if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE)</front>
<front id="Marlin_mainCPP-2547">        {</front>
<front id="Marlin_mainCPP-2548">          current_position[X_AXIS] = inactive_extruder_x_pos; </front>
<front id="Marlin_mainCPP-2549">          inactive_extruder_x_pos = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-2550">        }</front>
<front id="Marlin_mainCPP-2551">        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE)</front>
<front id="Marlin_mainCPP-2552">        {</front>
<front id="Marlin_mainCPP-2553">          active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position</front>
<front id="Marlin_mainCPP-2554">          if (active_extruder == 0 || active_extruder_parked)</front>
<front id="Marlin_mainCPP-2555">            current_position[X_AXIS] = inactive_extruder_x_pos; </front>
<front id="Marlin_mainCPP-2556">          else</front>
<front id="Marlin_mainCPP-2557">            current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset; </front>
<front id="Marlin_mainCPP-2558">          inactive_extruder_x_pos = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-2559">          extruder_duplication_enabled = false; </front>
<front id="Marlin_mainCPP-2560">        }</front>
<front id="Marlin_mainCPP-2561">        else</front>
<front id="Marlin_mainCPP-2562">        {</front>
<front id="Marlin_mainCPP-2563">          // record raised toolhead position for use by unpark</front>
<front id="Marlin_mainCPP-2564">          memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));</front>
<front id="Marlin_mainCPP-2565">          raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;</front>
<front id="Marlin_mainCPP-2566">          active_extruder_parked = true;</front>
<front id="Marlin_mainCPP-2567">          delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-2568">        }</front>
<front id="Marlin_mainCPP-2569">      #else    </front>
<front id="Marlin_mainCPP-2570">        // Offset extruder (only by XY)</front>
<front id="Marlin_mainCPP-2571">        int i;</front>
<front id="Marlin_mainCPP-2572">        for(i = 0; i &lt; 2; i++) {</front>
<front id="Marlin_mainCPP-2573">           current_position[i] = current_position[i] -</front>
<front id="Marlin_mainCPP-2574">                                 extruder_offset[i][active_extruder] +</front>
<front id="Marlin_mainCPP-2575">                                 extruder_offset[i][tmp_extruder];</front>
<front id="Marlin_mainCPP-2576">        }</front>
<front id="Marlin_mainCPP-2577">        // Set the new active extruder and position</front>
<front id="Marlin_mainCPP-2578">        active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-2579">      #endif //else DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2580">        plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2581">        // Move to the old position if 'F' was in the parameters</front>
<front id="Marlin_mainCPP-2582">        if(make_move && Stopped == false) {</front>
<front id="Marlin_mainCPP-2583">           prepare_move();</front>
<front id="Marlin_mainCPP-2584">        }</front>
<front id="Marlin_mainCPP-2585">      }</front>
<front id="Marlin_mainCPP-2586">      #endif</front>
<front id="Marlin_mainCPP-2587">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2588">      SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);</front>
<front id="Marlin_mainCPP-2589">      SERIAL_PROTOCOLLN((int)active_extruder);</front>
<front id="Marlin_mainCPP-2590">    }</front>
<front id="Marlin_mainCPP-2591">  }</front>
<front id="Marlin_mainCPP-2592"></front>
<front id="Marlin_mainCPP-2593">  else</front>
<front id="Marlin_mainCPP-2594">  {</front>
<front id="Marlin_mainCPP-2595">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2596">    SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);</front>
<front id="Marlin_mainCPP-2597">    SERIAL_ECHO(cmdbuffer[bufindr]);</front>
<front id="Marlin_mainCPP-2598">    SERIAL_ECHOLNPGM("\"");</front>
<front id="Marlin_mainCPP-2599">  }</front>
<front id="Marlin_mainCPP-2600"></front>
<front id="Marlin_mainCPP-2601">  ClearToSend();</front>
<front id="Marlin_mainCPP-2602">}</front>
<front id="Marlin_mainCPP-2603"></front>
<front id="Marlin_mainCPP-2604">void FlushSerialRequestResend()</front>
<front id="Marlin_mainCPP-2605">{</front>
<front id="Marlin_mainCPP-2606">  //char cmdbuffer[bufindr][100]="Resend:";</front>
<front id="Marlin_mainCPP-2607">  MYSERIAL.flush();</front>
<front id="Marlin_mainCPP-2608">  SERIAL_PROTOCOLPGM(MSG_RESEND);</front>
<front id="Marlin_mainCPP-2609">  SERIAL_PROTOCOLLN(gcode_LastN + 1);</front>
<front id="Marlin_mainCPP-2610">  ClearToSend();</front>
<front id="Marlin_mainCPP-2611">}</front>
<front id="Marlin_mainCPP-2612"></front>
<front id="Marlin_mainCPP-2613">void ClearToSend()</front>
<front id="Marlin_mainCPP-2614">{</front>
<front id="Marlin_mainCPP-2615">  previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-2616">  #ifdef SDSUPPORT</front>
<front id="Marlin_mainCPP-2617">  if(fromsd[bufindr])</front>
<front id="Marlin_mainCPP-2618">    return;</front>
<front id="Marlin_mainCPP-2619">  #endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-2620">  SERIAL_PROTOCOLLNPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-2621">}</front>
<front id="Marlin_mainCPP-2622"></front>
<front id="Marlin_mainCPP-2623">void get_coordinates()</front>
<front id="Marlin_mainCPP-2624">{</front>
<front id="Marlin_mainCPP-2625">  bool seen[4]={false,false,false,false};</front>
<front id="Marlin_mainCPP-2626">  for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2627">    if(code_seen(axis_codes[i]))</front>
<front id="Marlin_mainCPP-2628">    {</front>
<front id="Marlin_mainCPP-2629">      destination[i] = (float)code_value() + (axis_relative_modes[i] || relative_mode)*current_position[i];</front>
<front id="Marlin_mainCPP-2630">      seen[i]=true;</front>
<front id="Marlin_mainCPP-2631">    }</front>
<front id="Marlin_mainCPP-2632">    else destination[i] = current_position[i]; //Are these else lines really needed?</front>
<front id="Marlin_mainCPP-2633">  }</front>
<front id="Marlin_mainCPP-2634">  if(code_seen('F')) {</front>
<front id="Marlin_mainCPP-2635">    next_feedrate = code_value();</front>
<front id="Marlin_mainCPP-2636">    if(next_feedrate &gt; 0.0) feedrate = next_feedrate;</front>
<front id="Marlin_mainCPP-2637">  }</front>
<front id="Marlin_mainCPP-2638">  #ifdef FWRETRACT</front>
<front id="Marlin_mainCPP-2639">  if(autoretract_enabled)</front>
<front id="Marlin_mainCPP-2640">  if( !(seen[X_AXIS] || seen[Y_AXIS] || seen[Z_AXIS]) && seen[E_AXIS])</front>
<front id="Marlin_mainCPP-2641">  {</front>
<front id="Marlin_mainCPP-2642">    float echange=destination[E_AXIS]-current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-2643">    if(echange&lt;-MIN_RETRACT) //retract</front>
<front id="Marlin_mainCPP-2644">    {</front>
<front id="Marlin_mainCPP-2645">      if(!retracted)</front>
<front id="Marlin_mainCPP-2646">      {</front>
<front id="Marlin_mainCPP-2647"></front>
<front id="Marlin_mainCPP-2648">      destination[Z_AXIS]+=retract_zlift; //not sure why chaninging current_position negatively does not work.</front>
<front id="Marlin_mainCPP-2649">      //if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally</front>
<front id="Marlin_mainCPP-2650">      float correctede=-echange-retract_length;</front>
<front id="Marlin_mainCPP-2651">      //to generate the additional steps, not the destination is changed, but inversely the current position</front>
<front id="Marlin_mainCPP-2652">      current_position[E_AXIS]+=-correctede;</front>
<front id="Marlin_mainCPP-2653">      feedrate=retract_feedrate;</front>
<front id="Marlin_mainCPP-2654">      retracted=true;</front>
<front id="Marlin_mainCPP-2655">      }</front>
<front id="Marlin_mainCPP-2656"></front>
<front id="Marlin_mainCPP-2657">    }</front>
<front id="Marlin_mainCPP-2658">    else</front>
<front id="Marlin_mainCPP-2659">      if(echange&gt;MIN_RETRACT) //retract_recover</front>
<front id="Marlin_mainCPP-2660">    {</front>
<front id="Marlin_mainCPP-2661">      if(retracted)</front>
<front id="Marlin_mainCPP-2662">      {</front>
<front id="Marlin_mainCPP-2663">      //current_position[Z_AXIS]+=-retract_zlift;</front>
<front id="Marlin_mainCPP-2664">      //if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally</front>
<front id="Marlin_mainCPP-2665">      float correctede=-echange+1*retract_length+retract_recover_length; //total unretract=retract_length+retract_recover_length[surplus]</front>
<front id="Marlin_mainCPP-2666">      current_position[E_AXIS]+=correctede; //to generate the additional steps, not the destination is changed, but inversely the current position</front>
<front id="Marlin_mainCPP-2667">      feedrate=retract_recover_feedrate;</front>
<front id="Marlin_mainCPP-2668">      retracted=false;</front>
<front id="Marlin_mainCPP-2669">      }</front>
<front id="Marlin_mainCPP-2670">    }</front>
<front id="Marlin_mainCPP-2671"></front>
<front id="Marlin_mainCPP-2672">  }</front>
<front id="Marlin_mainCPP-2673">  #endif //FWRETRACT</front>
<front id="Marlin_mainCPP-2674">}</front>
<front id="Marlin_mainCPP-2675"></front>
<front id="Marlin_mainCPP-2676">void get_arc_coordinates()</front>
<front id="Marlin_mainCPP-2677">{</front>
<front id="Marlin_mainCPP-2678">#ifdef SF_ARC_FIX</front>
<front id="Marlin_mainCPP-2679">   bool relative_mode_backup = relative_mode;</front>
<front id="Marlin_mainCPP-2680">   relative_mode = true;</front>
<front id="Marlin_mainCPP-2681">#endif</front>
<front id="Marlin_mainCPP-2682">   get_coordinates();</front>
<front id="Marlin_mainCPP-2683">#ifdef SF_ARC_FIX</front>
<front id="Marlin_mainCPP-2684">   relative_mode=relative_mode_backup;</front>
<front id="Marlin_mainCPP-2685">#endif</front>
<front id="Marlin_mainCPP-2686"></front>
<front id="Marlin_mainCPP-2687">   if(code_seen('I')) {</front>
<front id="Marlin_mainCPP-2688">     offset[0] = code_value();</front>
<front id="Marlin_mainCPP-2689">   }</front>
<front id="Marlin_mainCPP-2690">   else {</front>
<front id="Marlin_mainCPP-2691">     offset[0] = 0.0;</front>
<front id="Marlin_mainCPP-2692">   }</front>
<front id="Marlin_mainCPP-2693">   if(code_seen('J')) {</front>
<front id="Marlin_mainCPP-2694">     offset[1] = code_value();</front>
<front id="Marlin_mainCPP-2695">   }</front>
<front id="Marlin_mainCPP-2696">   else {</front>
<front id="Marlin_mainCPP-2697">     offset[1] = 0.0;</front>
<front id="Marlin_mainCPP-2698">   }</front>
<front id="Marlin_mainCPP-2699">}</front>
<front id="Marlin_mainCPP-2700"></front>
<front id="Marlin_mainCPP-2701">void clamp_to_software_endstops(float target[3])</front>
<front id="Marlin_mainCPP-2702">{</front>
<front id="Marlin_mainCPP-2703">  if (min_software_endstops) {</front>
<front id="Marlin_mainCPP-2704">    if (target[X_AXIS] &lt; min_pos[X_AXIS]) target[X_AXIS] = min_pos[X_AXIS];</front>
<front id="Marlin_mainCPP-2705">    if (target[Y_AXIS] &lt; min_pos[Y_AXIS]) target[Y_AXIS] = min_pos[Y_AXIS];</front>
<front id="Marlin_mainCPP-2706">    if (target[Z_AXIS] &lt; min_pos[Z_AXIS]) target[Z_AXIS] = min_pos[Z_AXIS];</front>
<front id="Marlin_mainCPP-2707">  }</front>
<front id="Marlin_mainCPP-2708"></front>
<front id="Marlin_mainCPP-2709">  if (max_software_endstops) {</front>
<front id="Marlin_mainCPP-2710">    if (target[X_AXIS] &gt; max_pos[X_AXIS]) target[X_AXIS] = max_pos[X_AXIS];</front>
<front id="Marlin_mainCPP-2711">    if (target[Y_AXIS] &gt; max_pos[Y_AXIS]) target[Y_AXIS] = max_pos[Y_AXIS];</front>
<front id="Marlin_mainCPP-2712">    if (target[Z_AXIS] &gt; max_pos[Z_AXIS]) target[Z_AXIS] = max_pos[Z_AXIS];</front>
<front id="Marlin_mainCPP-2713">  }</front>
<front id="Marlin_mainCPP-2714">}</front>
<front id="Marlin_mainCPP-2715"></front>
<front id="Marlin_mainCPP-2716">#ifdef DELTA</front>
<front id="Marlin_mainCPP-2717">void calculate_delta(float cartesian[3])</front>
<front id="Marlin_mainCPP-2718">{</front>
<front id="Marlin_mainCPP-2719">  delta[X_AXIS] = sqrt(DELTA_DIAGONAL_ROD_2</front>
<front id="Marlin_mainCPP-2720">                       - sq(DELTA_TOWER1_X-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-2721">                       - sq(DELTA_TOWER1_Y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-2722">                       ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-2723">  delta[Y_AXIS] = sqrt(DELTA_DIAGONAL_ROD_2</front>
<front id="Marlin_mainCPP-2724">                       - sq(DELTA_TOWER2_X-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-2725">                       - sq(DELTA_TOWER2_Y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-2726">                       ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-2727">  delta[Z_AXIS] = sqrt(DELTA_DIAGONAL_ROD_2</front>
<front id="Marlin_mainCPP-2728">                       - sq(DELTA_TOWER3_X-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-2729">                       - sq(DELTA_TOWER3_Y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-2730">                       ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-2731">  /*</front>
<front id="Marlin_mainCPP-2732">  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);</front>
<front id="Marlin_mainCPP-2733">  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);</front>
<front id="Marlin_mainCPP-2734">  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);</front>
<front id="Marlin_mainCPP-2735"></front>
<front id="Marlin_mainCPP-2736">  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-2737">  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-2738">  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);</front>
<front id="Marlin_mainCPP-2739">  */</front>
<front id="Marlin_mainCPP-2740">}</front>
<front id="Marlin_mainCPP-2741">#endif</front>
<front id="Marlin_mainCPP-2742"></front>
<front id="Marlin_mainCPP-2743">void prepare_move()</front>
<front id="Marlin_mainCPP-2744">{</front>
<front id="Marlin_mainCPP-2745">  clamp_to_software_endstops(destination);</front>
<front id="Marlin_mainCPP-2746"></front>
<front id="Marlin_mainCPP-2747">  previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-2748">#ifdef DELTA</front>
<front id="Marlin_mainCPP-2749">  float difference[NUM_AXIS];</front>
<front id="Marlin_mainCPP-2750">  for (int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2751">    difference[i] = destination[i] - current_position[i];</front>
<front id="Marlin_mainCPP-2752">  }</front>
<front id="Marlin_mainCPP-2753">  float cartesian_mm = sqrt(sq(difference[X_AXIS]) +</front>
<front id="Marlin_mainCPP-2754">                            sq(difference[Y_AXIS]) +</front>
<front id="Marlin_mainCPP-2755">                            sq(difference[Z_AXIS]));</front>
<front id="Marlin_mainCPP-2756">  if (cartesian_mm &lt; 0.000001) { cartesian_mm = abs(difference[E_AXIS]); }</front>
<front id="Marlin_mainCPP-2757">  if (cartesian_mm &lt; 0.000001) { return; }</front>
<front id="Marlin_mainCPP-2758">  float seconds = 6000 * cartesian_mm / feedrate / feedmultiply;</front>
<front id="Marlin_mainCPP-2759">  int steps = max(1, int(DELTA_SEGMENTS_PER_SECOND * seconds));</front>
<front id="Marlin_mainCPP-2760">  // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);</front>
<front id="Marlin_mainCPP-2761">  // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);</front>
<front id="Marlin_mainCPP-2762">  // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);</front>
<front id="Marlin_mainCPP-2763">  for (int s = 1; s &lt;= steps; s++) {</front>
<front id="Marlin_mainCPP-2764">    float fraction = float(s) / float(steps);</front>
<front id="Marlin_mainCPP-2765">    for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2766">      destination[i] = current_position[i] + difference[i] * fraction;</front>
<front id="Marlin_mainCPP-2767">    }</front>
<front id="Marlin_mainCPP-2768">    calculate_delta(destination);</front>
<front id="Marlin_mainCPP-2769">    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS],</front>
<front id="Marlin_mainCPP-2770">                     destination[E_AXIS], feedrate*feedmultiply/60/100.0,</front>
<front id="Marlin_mainCPP-2771">                     active_extruder);</front>
<front id="Marlin_mainCPP-2772">  }</front>
<front id="Marlin_mainCPP-2773">#else</front>
<front id="Marlin_mainCPP-2774"></front>
<front id="Marlin_mainCPP-2775">#ifdef DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2776">  if (active_extruder_parked)</front>
<front id="Marlin_mainCPP-2777">  {</front>
<front id="Marlin_mainCPP-2778">    if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0)</front>
<front id="Marlin_mainCPP-2779">    {</front>
<front id="Marlin_mainCPP-2780">      // move duplicate extruder into correct duplication position.</front>
<front id="Marlin_mainCPP-2781">      plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2782">      plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset, current_position[Y_AXIS], current_position[Z_AXIS], </front>
<front id="Marlin_mainCPP-2783">          current_position[E_AXIS], max_feedrate[X_AXIS], 1);</front>
<front id="Marlin_mainCPP-2784">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2785">      st_synchronize();</front>
<front id="Marlin_mainCPP-2786">      extruder_duplication_enabled = true;</front>
<front id="Marlin_mainCPP-2787">      active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-2788">    }  </front>
<front id="Marlin_mainCPP-2789">    else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) // handle unparking of head</front>
<front id="Marlin_mainCPP-2790">    {</front>
<front id="Marlin_mainCPP-2791">      if (current_position[E_AXIS] == destination[E_AXIS])</front>
<front id="Marlin_mainCPP-2792">      {</front>
<front id="Marlin_mainCPP-2793">        // this is a travel move - skit it but keep track of current position (so that it can later</front>
<front id="Marlin_mainCPP-2794">        // be used as start of first non-travel move)</front>
<front id="Marlin_mainCPP-2795">        if (delayed_move_time != 0xFFFFFFFFUL)</front>
<front id="Marlin_mainCPP-2796">        {</front>
<front id="Marlin_mainCPP-2797">          memcpy(current_position, destination, sizeof(current_position)); </front>
<front id="Marlin_mainCPP-2798">          if (destination[Z_AXIS] &gt; raised_parked_position[Z_AXIS])</front>
<front id="Marlin_mainCPP-2799">            raised_parked_position[Z_AXIS] = destination[Z_AXIS];</front>
<front id="Marlin_mainCPP-2800">          delayed_move_time = millis();</front>
<front id="Marlin_mainCPP-2801">          return;</front>
<front id="Marlin_mainCPP-2802">        }</front>
<front id="Marlin_mainCPP-2803">      }</front>
<front id="Marlin_mainCPP-2804">      delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-2805">      // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower</front>
<front id="Marlin_mainCPP-2806">      plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS],    current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-2807">      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], </front>
<front id="Marlin_mainCPP-2808">          current_position[E_AXIS], min(max_feedrate[X_AXIS],max_feedrate[Y_AXIS]), active_extruder);</front>
<front id="Marlin_mainCPP-2809">      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], </front>
<front id="Marlin_mainCPP-2810">          current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-2811">      active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-2812">    }</front>
<front id="Marlin_mainCPP-2813">  }</front>
<front id="Marlin_mainCPP-2814">#endif //DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-2815"></front>
<front id="Marlin_mainCPP-2816">  // Do not use feedmultiply for E or Z only moves</front>
<front id="Marlin_mainCPP-2817">  if( (current_position[X_AXIS] == destination [X_AXIS]) && (current_position[Y_AXIS] == destination [Y_AXIS])) {</front>
<front id="Marlin_mainCPP-2818">      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-2819">  }</front>
<front id="Marlin_mainCPP-2820">  else {</front>
<front id="Marlin_mainCPP-2821">    plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], feedrate*feedmultiply/60/100.0, active_extruder);</front>
<front id="Marlin_mainCPP-2822">  }</front>
<front id="Marlin_mainCPP-2823">#endif //else DELTA</front>
<front id="Marlin_mainCPP-2824">  for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2825">    current_position[i] = destination[i];</front>
<front id="Marlin_mainCPP-2826">  }</front>
<front id="Marlin_mainCPP-2827">}</front>
<front id="Marlin_mainCPP-2828"></front>
<front id="Marlin_mainCPP-2829">void prepare_arc_move(char isclockwise) {</front>
<front id="Marlin_mainCPP-2830">  float r = hypot(offset[X_AXIS], offset[Y_AXIS]); // Compute arc radius for mc_arc</front>
<front id="Marlin_mainCPP-2831"></front>
<front id="Marlin_mainCPP-2832">  // Trace the arc</front>
<front id="Marlin_mainCPP-2833">  mc_arc(current_position, destination, offset, X_AXIS, Y_AXIS, Z_AXIS, feedrate*feedmultiply/60/100.0, r, isclockwise, active_extruder);</front>
<front id="Marlin_mainCPP-2834"></front>
<front id="Marlin_mainCPP-2835">  // As far as the parser is concerned, the position is now == target. In reality the</front>
<front id="Marlin_mainCPP-2836">  // motion control system might still be processing the action and the real tool position</front>
<front id="Marlin_mainCPP-2837">  // in any intermediate location.</front>
<front id="Marlin_mainCPP-2838">  for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2839">    current_position[i] = destination[i];</front>
<front id="Marlin_mainCPP-2840">  }</front>
<front id="Marlin_mainCPP-2841">  previous_millis_cmd = millis();</front>
<front id="Marlin_mainCPP-2842">}</front>
<front id="Marlin_mainCPP-2843"></front>
<front id="Marlin_mainCPP-2844">#if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2845"></front>
<front id="Marlin_mainCPP-2846">#if defined(FAN_PIN)</front>
<front id="Marlin_mainCPP-2847">  #if CONTROLLERFAN_PIN == FAN_PIN</front>
<front id="Marlin_mainCPP-2848">    #error "You cannot set CONTROLLERFAN_PIN equal to FAN_PIN"</front>
<front id="Marlin_mainCPP-2849">  #endif</front>
<front id="Marlin_mainCPP-2850">#endif</front>
<front id="Marlin_mainCPP-2851"></front>
<front id="Marlin_mainCPP-2852">unsigned long lastMotor = 0; //Save the time for when a motor was turned on last</front>
<front id="Marlin_mainCPP-2853">unsigned long lastMotorCheck = 0;</front>
<front id="Marlin_mainCPP-2854"></front>
<front id="Marlin_mainCPP-2855">void controllerFan()</front>
<front id="Marlin_mainCPP-2856">{</front>
<front id="Marlin_mainCPP-2857">  if ((millis() - lastMotorCheck) &gt;= 2500) //Not a time critical function, so we only check every 2500ms</front>
<front id="Marlin_mainCPP-2858">  {</front>
<front id="Marlin_mainCPP-2859">    lastMotorCheck = millis();</front>
<front id="Marlin_mainCPP-2860"></front>
<front id="Marlin_mainCPP-2861">    if(!READ(X_ENABLE_PIN) || !READ(Y_ENABLE_PIN) || !READ(Z_ENABLE_PIN)</front>
<front id="Marlin_mainCPP-2862">    #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-2863">       || !READ(E2_ENABLE_PIN)</front>
<front id="Marlin_mainCPP-2864">    #endif</front>
<front id="Marlin_mainCPP-2865">    #if EXTRUDER &gt; 1</front>
<front id="Marlin_mainCPP-2866">      #if defined(X2_ENABLE_PIN) && X2_ENABLE_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2867">       || !READ(X2_ENABLE_PIN)</front>
<front id="Marlin_mainCPP-2868">      #endif</front>
<front id="Marlin_mainCPP-2869">       || !READ(E1_ENABLE_PIN)</front>
<front id="Marlin_mainCPP-2870">    #endif</front>
<front id="Marlin_mainCPP-2871">       || !READ(E0_ENABLE_PIN)) //If any of the drivers are enabled...</front>
<front id="Marlin_mainCPP-2872">    {</front>
<front id="Marlin_mainCPP-2873">      lastMotor = millis(); //... set time to NOW so the fan will turn on</front>
<front id="Marlin_mainCPP-2874">    }</front>
<front id="Marlin_mainCPP-2875"></front>
<front id="Marlin_mainCPP-2876">    if ((millis() - lastMotor) &gt;= (CONTROLLERFAN_SECS*1000UL) || lastMotor == 0) //If the last time any driver was enabled, is longer since than CONTROLLERSEC...</front>
<front id="Marlin_mainCPP-2877">    {</front>
<front id="Marlin_mainCPP-2878">        digitalWrite(CONTROLLERFAN_PIN, 0);</front>
<front id="Marlin_mainCPP-2879">        analogWrite(CONTROLLERFAN_PIN, 0);</front>
<front id="Marlin_mainCPP-2880">    }</front>
<front id="Marlin_mainCPP-2881">    else</front>
<front id="Marlin_mainCPP-2882">    {</front>
<front id="Marlin_mainCPP-2883">        // allows digital or PWM fan output to be used (see M42 handling)</front>
<front id="Marlin_mainCPP-2884">        digitalWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);</front>
<front id="Marlin_mainCPP-2885">        analogWrite(CONTROLLERFAN_PIN, CONTROLLERFAN_SPEED);</front>
<front id="Marlin_mainCPP-2886">    }</front>
<front id="Marlin_mainCPP-2887">  }</front>
<front id="Marlin_mainCPP-2888">}</front>
<front id="Marlin_mainCPP-2889">#endif</front>
<front id="Marlin_mainCPP-2890"></front>
<front id="Marlin_mainCPP-2891">void manage_inactivity()</front>
<front id="Marlin_mainCPP-2892">{</front>
<front id="Marlin_mainCPP-2893">  if( (millis() - previous_millis_cmd) &gt;  max_inactive_time )</front>
<front id="Marlin_mainCPP-2894">    if(max_inactive_time)</front>
<front id="Marlin_mainCPP-2895">      kill();</front>
<front id="Marlin_mainCPP-2896">  if(stepper_inactive_time)  {</front>
<front id="Marlin_mainCPP-2897">    if( (millis() - previous_millis_cmd) &gt;  stepper_inactive_time )</front>
<front id="Marlin_mainCPP-2898">    {</front>
<front id="Marlin_mainCPP-2899">      if(blocks_queued() == false) {</front>
<front id="Marlin_mainCPP-2900">        disable_x();</front>
<front id="Marlin_mainCPP-2901">        disable_y();</front>
<front id="Marlin_mainCPP-2902">        disable_z();</front>
<front id="Marlin_mainCPP-2903">        disable_e0();</front>
<front id="Marlin_mainCPP-2904">        disable_e1();</front>
<front id="Marlin_mainCPP-2905">        disable_e2();</front>
<front id="Marlin_mainCPP-2906">      }</front>
<front id="Marlin_mainCPP-2907">    }</front>
<front id="Marlin_mainCPP-2908">  }</front>
<front id="Marlin_mainCPP-2909">  #if defined(KILL_PIN) && KILL_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2910">    if( 0 == READ(KILL_PIN) )</front>
<front id="Marlin_mainCPP-2911">      kill();</front>
<front id="Marlin_mainCPP-2912">  #endif</front>
<front id="Marlin_mainCPP-2913">  #if defined(CONTROLLERFAN_PIN) && CONTROLLERFAN_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2914">    controllerFan(); //Check if fan should be turned on to cool stepper drivers down</front>
<front id="Marlin_mainCPP-2915">  #endif</front>
<front id="Marlin_mainCPP-2916">  #ifdef EXTRUDER_RUNOUT_PREVENT</front>
<front id="Marlin_mainCPP-2917">    if( (millis() - previous_millis_cmd) &gt;  EXTRUDER_RUNOUT_SECONDS*1000 )</front>
<front id="Marlin_mainCPP-2918">    if(degHotend(active_extruder)&gt;EXTRUDER_RUNOUT_MINTEMP)</front>
<front id="Marlin_mainCPP-2919">    {</front>
<front id="Marlin_mainCPP-2920">     bool oldstatus=READ(E0_ENABLE_PIN);</front>
<front id="Marlin_mainCPP-2921">     enable_e0();</front>
<front id="Marlin_mainCPP-2922">     float oldepos=current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-2923">     float oldedes=destination[E_AXIS];</front>
<front id="Marlin_mainCPP-2924">     plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-2925">                      current_position[E_AXIS]+EXTRUDER_RUNOUT_EXTRUDE*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS],</front>
<front id="Marlin_mainCPP-2926">                      EXTRUDER_RUNOUT_SPEED/60.*EXTRUDER_RUNOUT_ESTEPS/axis_steps_per_unit[E_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-2927">     current_position[E_AXIS]=oldepos;</front>
<front id="Marlin_mainCPP-2928">     destination[E_AXIS]=oldedes;</front>
<front id="Marlin_mainCPP-2929">     plan_set_e_position(oldepos);</front>
<front id="Marlin_mainCPP-2930">     previous_millis_cmd=millis();</front>
<front id="Marlin_mainCPP-2931">     st_synchronize();</front>
<front id="Marlin_mainCPP-2932">     WRITE(E0_ENABLE_PIN,oldstatus);</front>
<front id="Marlin_mainCPP-2933">    }</front>
<front id="Marlin_mainCPP-2934">  #endif</front>
<front id="Marlin_mainCPP-2935">  #if defined(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-2936">    // handle delayed move timeout</front>
<front id="Marlin_mainCPP-2937">    if (delayed_move_time != 0 && (millis() - delayed_move_time) &gt; 1000 && Stopped == false)</front>
<front id="Marlin_mainCPP-2938">    {</front>
<front id="Marlin_mainCPP-2939">      // travel moves have been received so enact them</front>
<front id="Marlin_mainCPP-2940">      delayed_move_time = 0xFFFFFFFFUL; // force moves to be done</front>
<front id="Marlin_mainCPP-2941">      memcpy(destination,current_position,sizeof(destination));</front>
<front id="Marlin_mainCPP-2942">      prepare_move(); </front>
<front id="Marlin_mainCPP-2943">    }</front>
<front id="Marlin_mainCPP-2944">  #endif  </front>
<front id="Marlin_mainCPP-2945">  check_axes_activity();</front>
<front id="Marlin_mainCPP-2946">}</front>
<front id="Marlin_mainCPP-2947"></front>
<front id="Marlin_mainCPP-2948">void kill()</front>
<front id="Marlin_mainCPP-2949">{</front>
<front id="Marlin_mainCPP-2950">  cli(); // Stop interrupts</front>
<front id="Marlin_mainCPP-2951">  disable_heater();</front>
<front id="Marlin_mainCPP-2952"></front>
<front id="Marlin_mainCPP-2953">  disable_x();</front>
<front id="Marlin_mainCPP-2954">  disable_y();</front>
<front id="Marlin_mainCPP-2955">  disable_z();</front>
<front id="Marlin_mainCPP-2956">  disable_e0();</front>
<front id="Marlin_mainCPP-2957">  disable_e1();</front>
<front id="Marlin_mainCPP-2958">  disable_e2();</front>
<front id="Marlin_mainCPP-2959"></front>
<front id="Marlin_mainCPP-2960">#if defined(PS_ON_PIN) && PS_ON_PIN &gt; -1</front>
<front id="Marlin_mainCPP-2961">  pinMode(PS_ON_PIN,INPUT);</front>
<front id="Marlin_mainCPP-2962">#endif</front>
<front id="Marlin_mainCPP-2963">  SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-2964">  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);</front>
<front id="Marlin_mainCPP-2965">  LCD_ALERTMESSAGEPGM(MSG_KILLED);</front>
<front id="Marlin_mainCPP-2966">  suicide();</front>
<front id="Marlin_mainCPP-2967">  while(1) { /* Intentionally left empty */ } // Wait for reset</front>
<front id="Marlin_mainCPP-2968">}</front>
<front id="Marlin_mainCPP-2969"></front>
<front id="Marlin_mainCPP-2970">void Stop()</front>
<front id="Marlin_mainCPP-2971">{</front>
<front id="Marlin_mainCPP-2972">  disable_heater();</front>
<front id="Marlin_mainCPP-2973">  if(Stopped == false) {</front>
<front id="Marlin_mainCPP-2974">    Stopped = true;</front>
<front id="Marlin_mainCPP-2975">    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart</front>
<front id="Marlin_mainCPP-2976">    SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-2977">    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);</front>
<front id="Marlin_mainCPP-2978">    LCD_MESSAGEPGM(MSG_STOPPED);</front>
<front id="Marlin_mainCPP-2979">  }</front>
<front id="Marlin_mainCPP-2980">}</front>
<front id="Marlin_mainCPP-2981"></front>
<front id="Marlin_mainCPP-2982">bool IsStopped() { return Stopped; };</front>
<front id="Marlin_mainCPP-2983"></front>
<front id="Marlin_mainCPP-2984">#ifdef FAST_PWM_FAN</front>
<front id="Marlin_mainCPP-2985">void setPwmFrequency(uint8_t pin, int val)</front>
<front id="Marlin_mainCPP-2986">{</front>
<front id="Marlin_mainCPP-2987">  val &= 0x07;</front>
<front id="Marlin_mainCPP-2988">  switch(digitalPinToTimer(pin))</front>
<front id="Marlin_mainCPP-2989">  {</front>
<front id="Marlin_mainCPP-2990"></front>
<front id="Marlin_mainCPP-2991">    #if defined(TCCR0A)</front>
<front id="Marlin_mainCPP-2992">    case TIMER0A:</front>
<front id="Marlin_mainCPP-2993">    case TIMER0B:</front>
<front id="Marlin_mainCPP-2994">//         TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));</front>
<front id="Marlin_mainCPP-2995">//         TCCR0B |= val;</front>
<front id="Marlin_mainCPP-2996">         break;</front>
<front id="Marlin_mainCPP-2997">    #endif</front>
<front id="Marlin_mainCPP-2998"></front>
<front id="Marlin_mainCPP-2999">    #if defined(TCCR1A)</front>
<front id="Marlin_mainCPP-3000">    case TIMER1A:</front>
<front id="Marlin_mainCPP-3001">    case TIMER1B:</front>
<front id="Marlin_mainCPP-3002">//         TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</front>
<front id="Marlin_mainCPP-3003">//         TCCR1B |= val;</front>
<front id="Marlin_mainCPP-3004">         break;</front>
<front id="Marlin_mainCPP-3005">    #endif</front>
<front id="Marlin_mainCPP-3006"></front>
<front id="Marlin_mainCPP-3007">    #if defined(TCCR2)</front>
<front id="Marlin_mainCPP-3008">    case TIMER2:</front>
<front id="Marlin_mainCPP-3009">    case TIMER2:</front>
<front id="Marlin_mainCPP-3010">         TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</front>
<front id="Marlin_mainCPP-3011">         TCCR2 |= val;</front>
<front id="Marlin_mainCPP-3012">         break;</front>
<front id="Marlin_mainCPP-3013">    #endif</front>
<front id="Marlin_mainCPP-3014"></front>
<front id="Marlin_mainCPP-3015">    #if defined(TCCR2A)</front>
<front id="Marlin_mainCPP-3016">    case TIMER2A:</front>
<front id="Marlin_mainCPP-3017">    case TIMER2B:</front>
<front id="Marlin_mainCPP-3018">         TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));</front>
<front id="Marlin_mainCPP-3019">         TCCR2B |= val;</front>
<front id="Marlin_mainCPP-3020">         break;</front>
<front id="Marlin_mainCPP-3021">    #endif</front>
<front id="Marlin_mainCPP-3022"></front>
<front id="Marlin_mainCPP-3023">    #if defined(TCCR3A)</front>
<front id="Marlin_mainCPP-3024">    case TIMER3A:</front>
<front id="Marlin_mainCPP-3025">    case TIMER3B:</front>
<front id="Marlin_mainCPP-3026">    case TIMER3C:</front>
<front id="Marlin_mainCPP-3027">         TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));</front>
<front id="Marlin_mainCPP-3028">         TCCR3B |= val;</front>
<front id="Marlin_mainCPP-3029">         break;</front>
<front id="Marlin_mainCPP-3030">    #endif</front>
<front id="Marlin_mainCPP-3031"></front>
<front id="Marlin_mainCPP-3032">    #if defined(TCCR4A)</front>
<front id="Marlin_mainCPP-3033">    case TIMER4A:</front>
<front id="Marlin_mainCPP-3034">    case TIMER4B:</front>
<front id="Marlin_mainCPP-3035">    case TIMER4C:</front>
<front id="Marlin_mainCPP-3036">         TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));</front>
<front id="Marlin_mainCPP-3037">         TCCR4B |= val;</front>
<front id="Marlin_mainCPP-3038">         break;</front>
<front id="Marlin_mainCPP-3039">   #endif</front>
<front id="Marlin_mainCPP-3040"></front>
<front id="Marlin_mainCPP-3041">    #if defined(TCCR5A)</front>
<front id="Marlin_mainCPP-3042">    case TIMER5A:</front>
<front id="Marlin_mainCPP-3043">    case TIMER5B:</front>
<front id="Marlin_mainCPP-3044">    case TIMER5C:</front>
<front id="Marlin_mainCPP-3045">         TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));</front>
<front id="Marlin_mainCPP-3046">         TCCR5B |= val;</front>
<front id="Marlin_mainCPP-3047">         break;</front>
<front id="Marlin_mainCPP-3048">   #endif</front>
<front id="Marlin_mainCPP-3049"></front>
<front id="Marlin_mainCPP-3050">  }</front>
<front id="Marlin_mainCPP-3051">}</front>
<front id="Marlin_mainCPP-3052">#endif //FAST_PWM_FAN</front>
<front id="Marlin_mainCPP-3053"></front>
<front id="Marlin_mainCPP-3054">bool setTargetedHotend(int code){</front>
<front id="Marlin_mainCPP-3055">  tmp_extruder = active_extruder;</front>
<front id="Marlin_mainCPP-3056">  if(code_seen('T')) {</front>
<front id="Marlin_mainCPP-3057">    tmp_extruder = code_value();</front>
<front id="Marlin_mainCPP-3058">    if(tmp_extruder &gt;= EXTRUDERS) {</front>
<front id="Marlin_mainCPP-3059">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-3060">      switch(code){</front>
<front id="Marlin_mainCPP-3061">        case 104:</front>
<front id="Marlin_mainCPP-3062">          SERIAL_ECHO(MSG_M104_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-3063">          break;</front>
<front id="Marlin_mainCPP-3064">        case 105:</front>
<front id="Marlin_mainCPP-3065">          SERIAL_ECHO(MSG_M105_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-3066">          break;</front>
<front id="Marlin_mainCPP-3067">        case 109:</front>
<front id="Marlin_mainCPP-3068">          SERIAL_ECHO(MSG_M109_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-3069">          break;</front>
<front id="Marlin_mainCPP-3070">        case 218:</front>
<front id="Marlin_mainCPP-3071">          SERIAL_ECHO(MSG_M218_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-3072">          break;</front>
<front id="Marlin_mainCPP-3073">      }</front>
<front id="Marlin_mainCPP-3074">      SERIAL_ECHOLN(tmp_extruder);</front>
<front id="Marlin_mainCPP-3075">      return true;</front>
<front id="Marlin_mainCPP-3076">    }</front>
<front id="Marlin_mainCPP-3077">  }</front>
<front id="Marlin_mainCPP-3078">  return false;</front>
<front id="Marlin_mainCPP-3079">}</front>
<front id="Marlin_mainCPP-3080"></front>
 </pre>
<h1>MarlinSerial.cpp</h1>
<pre  class="prettyprint linenums"><front id="MarlinSerialCPP-1">/*</front>
<front id="MarlinSerialCPP-2">  HardwareSerial.cpp - Hardware serial library for Wiring</front>
<front id="MarlinSerialCPP-3">  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.</front>
<front id="MarlinSerialCPP-4"></front>
<front id="MarlinSerialCPP-5">  This library is free software; you can redistribute it and/or</front>
<front id="MarlinSerialCPP-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="MarlinSerialCPP-7">  License as published by the Free Software Foundation; either</front>
<front id="MarlinSerialCPP-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="MarlinSerialCPP-9"></front>
<front id="MarlinSerialCPP-10">  This library is distributed in the hope that it will be useful,</front>
<front id="MarlinSerialCPP-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="MarlinSerialCPP-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="MarlinSerialCPP-13">  Lesser General Public License for more details.</front>
<front id="MarlinSerialCPP-14"></front>
<front id="MarlinSerialCPP-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="MarlinSerialCPP-16">  License along with this library; if not, write to the Free Software</front>
<front id="MarlinSerialCPP-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="MarlinSerialCPP-18">  </front>
<front id="MarlinSerialCPP-19">  Modified 23 November 2006 by David A. Mellis</front>
<front id="MarlinSerialCPP-20">  Modified 28 September 2010 by Mark Sproul</front>
<front id="MarlinSerialCPP-21">*/</front>
<front id="MarlinSerialCPP-22"></front>
<front id="MarlinSerialCPP-23">#include "Marlin.h"</front>
<front id="MarlinSerialCPP-24">#include "MarlinSerial.h"</front>
<front id="MarlinSerialCPP-25"></front>
<front id="MarlinSerialCPP-26">#ifndef AT90USB</front>
<front id="MarlinSerialCPP-27">// this next line disables the entire HardwareSerial.cpp, </front>
<front id="MarlinSerialCPP-28">// this is so I can support Attiny series and any other chip without a uart</front>
<front id="MarlinSerialCPP-29">#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)</front>
<front id="MarlinSerialCPP-30"></front>
<front id="MarlinSerialCPP-31">#if UART_PRESENT(SERIAL_PORT)</front>
<front id="MarlinSerialCPP-32">  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };</front>
<front id="MarlinSerialCPP-33">#endif</front>
<front id="MarlinSerialCPP-34"></front>
<front id="MarlinSerialCPP-35">FORCE_INLINE void store_char(unsigned char c)</front>
<front id="MarlinSerialCPP-36">{</front>
<front id="MarlinSerialCPP-37">  int i = (unsigned int)(rx_buffer.head + 1) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialCPP-38"></front>
<front id="MarlinSerialCPP-39">  // if we should be storing the received character into the location</front>
<front id="MarlinSerialCPP-40">  // just before the tail (meaning that the head would advance to the</front>
<front id="MarlinSerialCPP-41">  // current location of the tail), we're about to overflow the buffer</front>
<front id="MarlinSerialCPP-42">  // and so we don't write the character or advance the head.</front>
<front id="MarlinSerialCPP-43">  if (i != rx_buffer.tail) {</front>
<front id="MarlinSerialCPP-44">    rx_buffer.buffer[rx_buffer.head] = c;</front>
<front id="MarlinSerialCPP-45">    rx_buffer.head = i;</front>
<front id="MarlinSerialCPP-46">  }</front>
<front id="MarlinSerialCPP-47">}</front>
<front id="MarlinSerialCPP-48"></front>
<front id="MarlinSerialCPP-49"></front>
<front id="MarlinSerialCPP-50">//#elif defined(SIG_USART_RECV)</front>
<front id="MarlinSerialCPP-51">#if defined(M_USARTx_RX_vect)</front>
<front id="MarlinSerialCPP-52">  // fixed by Mark Sproul this is on the 644/644p</front>
<front id="MarlinSerialCPP-53">  //SIGNAL(SIG_USART_RECV)</front>
<front id="MarlinSerialCPP-54">  SIGNAL(M_USARTx_RX_vect)</front>
<front id="MarlinSerialCPP-55">  {</front>
<front id="MarlinSerialCPP-56">    unsigned char c  =  M_UDRx;</front>
<front id="MarlinSerialCPP-57">    store_char(c);</front>
<front id="MarlinSerialCPP-58">  }</front>
<front id="MarlinSerialCPP-59">#endif</front>
<front id="MarlinSerialCPP-60"></front>
<front id="MarlinSerialCPP-61">// Constructors ////////////////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-62"></front>
<front id="MarlinSerialCPP-63">MarlinSerial::MarlinSerial()</front>
<front id="MarlinSerialCPP-64">{</front>
<front id="MarlinSerialCPP-65"></front>
<front id="MarlinSerialCPP-66">}</front>
<front id="MarlinSerialCPP-67"></front>
<front id="MarlinSerialCPP-68">// Public Methods //////////////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-69"></front>
<front id="MarlinSerialCPP-70">void MarlinSerial::begin(long baud)</front>
<front id="MarlinSerialCPP-71">{</front>
<front id="MarlinSerialCPP-72">  uint16_t baud_setting;</front>
<front id="MarlinSerialCPP-73">  bool useU2X = true;</front>
<front id="MarlinSerialCPP-74"></front>
<front id="MarlinSerialCPP-75">#if F_CPU == 16000000UL && SERIAL_PORT == 0</front>
<front id="MarlinSerialCPP-76">  // hardcoded exception for compatibility with the bootloader shipped</front>
<front id="MarlinSerialCPP-77">  // with the Duemilanove and previous boards and the firmware on the 8U2</front>
<front id="MarlinSerialCPP-78">  // on the Uno and Mega 2560.</front>
<front id="MarlinSerialCPP-79">  if (baud == 57600) {</front>
<front id="MarlinSerialCPP-80">    useU2X = false;</front>
<front id="MarlinSerialCPP-81">  }</front>
<front id="MarlinSerialCPP-82">#endif</front>
<front id="MarlinSerialCPP-83">  </front>
<front id="MarlinSerialCPP-84">  if (useU2X) {</front>
<front id="MarlinSerialCPP-85">    M_UCSRxA = 1 &lt;&lt; M_U2Xx;</front>
<front id="MarlinSerialCPP-86">    baud_setting = (F_CPU / 4 / baud - 1) / 2;</front>
<front id="MarlinSerialCPP-87">  } else {</front>
<front id="MarlinSerialCPP-88">    M_UCSRxA = 0;</front>
<front id="MarlinSerialCPP-89">    baud_setting = (F_CPU / 8 / baud - 1) / 2;</front>
<front id="MarlinSerialCPP-90">  }</front>
<front id="MarlinSerialCPP-91"></front>
<front id="MarlinSerialCPP-92">  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)</front>
<front id="MarlinSerialCPP-93">  M_UBRRxH = baud_setting &gt;&gt; 8;</front>
<front id="MarlinSerialCPP-94">  M_UBRRxL = baud_setting;</front>
<front id="MarlinSerialCPP-95"></front>
<front id="MarlinSerialCPP-96">  sbi(M_UCSRxB, M_RXENx);</front>
<front id="MarlinSerialCPP-97">  sbi(M_UCSRxB, M_TXENx);</front>
<front id="MarlinSerialCPP-98">  sbi(M_UCSRxB, M_RXCIEx);</front>
<front id="MarlinSerialCPP-99">}</front>
<front id="MarlinSerialCPP-100"></front>
<front id="MarlinSerialCPP-101">void MarlinSerial::end()</front>
<front id="MarlinSerialCPP-102">{</front>
<front id="MarlinSerialCPP-103">  cbi(M_UCSRxB, M_RXENx);</front>
<front id="MarlinSerialCPP-104">  cbi(M_UCSRxB, M_TXENx);</front>
<front id="MarlinSerialCPP-105">  cbi(M_UCSRxB, M_RXCIEx);  </front>
<front id="MarlinSerialCPP-106">}</front>
<front id="MarlinSerialCPP-107"></front>
<front id="MarlinSerialCPP-108"></front>
<front id="MarlinSerialCPP-109"></front>
<front id="MarlinSerialCPP-110">int MarlinSerial::peek(void)</front>
<front id="MarlinSerialCPP-111">{</front>
<front id="MarlinSerialCPP-112">  if (rx_buffer.head == rx_buffer.tail) {</front>
<front id="MarlinSerialCPP-113">    return -1;</front>
<front id="MarlinSerialCPP-114">  } else {</front>
<front id="MarlinSerialCPP-115">    return rx_buffer.buffer[rx_buffer.tail];</front>
<front id="MarlinSerialCPP-116">  }</front>
<front id="MarlinSerialCPP-117">}</front>
<front id="MarlinSerialCPP-118"></front>
<front id="MarlinSerialCPP-119">int MarlinSerial::read(void)</front>
<front id="MarlinSerialCPP-120">{</front>
<front id="MarlinSerialCPP-121">  // if the head isn't ahead of the tail, we don't have any characters</front>
<front id="MarlinSerialCPP-122">  if (rx_buffer.head == rx_buffer.tail) {</front>
<front id="MarlinSerialCPP-123">    return -1;</front>
<front id="MarlinSerialCPP-124">  } else {</front>
<front id="MarlinSerialCPP-125">    unsigned char c = rx_buffer.buffer[rx_buffer.tail];</front>
<front id="MarlinSerialCPP-126">    rx_buffer.tail = (unsigned int)(rx_buffer.tail + 1) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialCPP-127">    return c;</front>
<front id="MarlinSerialCPP-128">  }</front>
<front id="MarlinSerialCPP-129">}</front>
<front id="MarlinSerialCPP-130"></front>
<front id="MarlinSerialCPP-131">void MarlinSerial::flush()</front>
<front id="MarlinSerialCPP-132">{</front>
<front id="MarlinSerialCPP-133">  // don't reverse this or there may be problems if the RX interrupt</front>
<front id="MarlinSerialCPP-134">  // occurs after reading the value of rx_buffer_head but before writing</front>
<front id="MarlinSerialCPP-135">  // the value to rx_buffer_tail; the previous value of rx_buffer_head</front>
<front id="MarlinSerialCPP-136">  // may be written to rx_buffer_tail, making it appear as if the buffer</front>
<front id="MarlinSerialCPP-137">  // don't reverse this or there may be problems if the RX interrupt</front>
<front id="MarlinSerialCPP-138">  // occurs after reading the value of rx_buffer_head but before writing</front>
<front id="MarlinSerialCPP-139">  // the value to rx_buffer_tail; the previous value of rx_buffer_head</front>
<front id="MarlinSerialCPP-140">  // may be written to rx_buffer_tail, making it appear as if the buffer</front>
<front id="MarlinSerialCPP-141">  // were full, not empty.</front>
<front id="MarlinSerialCPP-142">  rx_buffer.head = rx_buffer.tail;</front>
<front id="MarlinSerialCPP-143">}</front>
<front id="MarlinSerialCPP-144"></front>
<front id="MarlinSerialCPP-145"></front>
<front id="MarlinSerialCPP-146"></front>
<front id="MarlinSerialCPP-147"></front>
<front id="MarlinSerialCPP-148">/// imports from print.h</front>
<front id="MarlinSerialCPP-149"></front>
<front id="MarlinSerialCPP-150"></front>
<front id="MarlinSerialCPP-151"></front>
<front id="MarlinSerialCPP-152"></front>
<front id="MarlinSerialCPP-153">void MarlinSerial::print(char c, int base)</front>
<front id="MarlinSerialCPP-154">{</front>
<front id="MarlinSerialCPP-155">  print((long) c, base);</front>
<front id="MarlinSerialCPP-156">}</front>
<front id="MarlinSerialCPP-157"></front>
<front id="MarlinSerialCPP-158">void MarlinSerial::print(unsigned char b, int base)</front>
<front id="MarlinSerialCPP-159">{</front>
<front id="MarlinSerialCPP-160">  print((unsigned long) b, base);</front>
<front id="MarlinSerialCPP-161">}</front>
<front id="MarlinSerialCPP-162"></front>
<front id="MarlinSerialCPP-163">void MarlinSerial::print(int n, int base)</front>
<front id="MarlinSerialCPP-164">{</front>
<front id="MarlinSerialCPP-165">  print((long) n, base);</front>
<front id="MarlinSerialCPP-166">}</front>
<front id="MarlinSerialCPP-167"></front>
<front id="MarlinSerialCPP-168">void MarlinSerial::print(unsigned int n, int base)</front>
<front id="MarlinSerialCPP-169">{</front>
<front id="MarlinSerialCPP-170">  print((unsigned long) n, base);</front>
<front id="MarlinSerialCPP-171">}</front>
<front id="MarlinSerialCPP-172"></front>
<front id="MarlinSerialCPP-173">void MarlinSerial::print(long n, int base)</front>
<front id="MarlinSerialCPP-174">{</front>
<front id="MarlinSerialCPP-175">  if (base == 0) {</front>
<front id="MarlinSerialCPP-176">    write(n);</front>
<front id="MarlinSerialCPP-177">  } else if (base == 10) {</front>
<front id="MarlinSerialCPP-178">    if (n &lt; 0) {</front>
<front id="MarlinSerialCPP-179">      print('-');</front>
<front id="MarlinSerialCPP-180">      n = -n;</front>
<front id="MarlinSerialCPP-181">    }</front>
<front id="MarlinSerialCPP-182">    printNumber(n, 10);</front>
<front id="MarlinSerialCPP-183">  } else {</front>
<front id="MarlinSerialCPP-184">    printNumber(n, base);</front>
<front id="MarlinSerialCPP-185">  }</front>
<front id="MarlinSerialCPP-186">}</front>
<front id="MarlinSerialCPP-187"></front>
<front id="MarlinSerialCPP-188">void MarlinSerial::print(unsigned long n, int base)</front>
<front id="MarlinSerialCPP-189">{</front>
<front id="MarlinSerialCPP-190">  if (base == 0) write(n);</front>
<front id="MarlinSerialCPP-191">  else printNumber(n, base);</front>
<front id="MarlinSerialCPP-192">}</front>
<front id="MarlinSerialCPP-193"></front>
<front id="MarlinSerialCPP-194">void MarlinSerial::print(double n, int digits)</front>
<front id="MarlinSerialCPP-195">{</front>
<front id="MarlinSerialCPP-196">  printFloat(n, digits);</front>
<front id="MarlinSerialCPP-197">}</front>
<front id="MarlinSerialCPP-198"></front>
<front id="MarlinSerialCPP-199">void MarlinSerial::println(void)</front>
<front id="MarlinSerialCPP-200">{</front>
<front id="MarlinSerialCPP-201">  print('\r');</front>
<front id="MarlinSerialCPP-202">  print('\n');  </front>
<front id="MarlinSerialCPP-203">}</front>
<front id="MarlinSerialCPP-204"></front>
<front id="MarlinSerialCPP-205">void MarlinSerial::println(const String &s)</front>
<front id="MarlinSerialCPP-206">{</front>
<front id="MarlinSerialCPP-207">  print(s);</front>
<front id="MarlinSerialCPP-208">  println();</front>
<front id="MarlinSerialCPP-209">}</front>
<front id="MarlinSerialCPP-210"></front>
<front id="MarlinSerialCPP-211">void MarlinSerial::println(const char c[])</front>
<front id="MarlinSerialCPP-212">{</front>
<front id="MarlinSerialCPP-213">  print(c);</front>
<front id="MarlinSerialCPP-214">  println();</front>
<front id="MarlinSerialCPP-215">}</front>
<front id="MarlinSerialCPP-216"></front>
<front id="MarlinSerialCPP-217">void MarlinSerial::println(char c, int base)</front>
<front id="MarlinSerialCPP-218">{</front>
<front id="MarlinSerialCPP-219">  print(c, base);</front>
<front id="MarlinSerialCPP-220">  println();</front>
<front id="MarlinSerialCPP-221">}</front>
<front id="MarlinSerialCPP-222"></front>
<front id="MarlinSerialCPP-223">void MarlinSerial::println(unsigned char b, int base)</front>
<front id="MarlinSerialCPP-224">{</front>
<front id="MarlinSerialCPP-225">  print(b, base);</front>
<front id="MarlinSerialCPP-226">  println();</front>
<front id="MarlinSerialCPP-227">}</front>
<front id="MarlinSerialCPP-228"></front>
<front id="MarlinSerialCPP-229">void MarlinSerial::println(int n, int base)</front>
<front id="MarlinSerialCPP-230">{</front>
<front id="MarlinSerialCPP-231">  print(n, base);</front>
<front id="MarlinSerialCPP-232">  println();</front>
<front id="MarlinSerialCPP-233">}</front>
<front id="MarlinSerialCPP-234"></front>
<front id="MarlinSerialCPP-235">void MarlinSerial::println(unsigned int n, int base)</front>
<front id="MarlinSerialCPP-236">{</front>
<front id="MarlinSerialCPP-237">  print(n, base);</front>
<front id="MarlinSerialCPP-238">  println();</front>
<front id="MarlinSerialCPP-239">}</front>
<front id="MarlinSerialCPP-240"></front>
<front id="MarlinSerialCPP-241">void MarlinSerial::println(long n, int base)</front>
<front id="MarlinSerialCPP-242">{</front>
<front id="MarlinSerialCPP-243">  print(n, base);</front>
<front id="MarlinSerialCPP-244">  println();</front>
<front id="MarlinSerialCPP-245">}</front>
<front id="MarlinSerialCPP-246"></front>
<front id="MarlinSerialCPP-247">void MarlinSerial::println(unsigned long n, int base)</front>
<front id="MarlinSerialCPP-248">{</front>
<front id="MarlinSerialCPP-249">  print(n, base);</front>
<front id="MarlinSerialCPP-250">  println();</front>
<front id="MarlinSerialCPP-251">}</front>
<front id="MarlinSerialCPP-252"></front>
<front id="MarlinSerialCPP-253">void MarlinSerial::println(double n, int digits)</front>
<front id="MarlinSerialCPP-254">{</front>
<front id="MarlinSerialCPP-255">  print(n, digits);</front>
<front id="MarlinSerialCPP-256">  println();</front>
<front id="MarlinSerialCPP-257">}</front>
<front id="MarlinSerialCPP-258"></front>
<front id="MarlinSerialCPP-259">// Private Methods /////////////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-260"></front>
<front id="MarlinSerialCPP-261">void MarlinSerial::printNumber(unsigned long n, uint8_t base)</front>
<front id="MarlinSerialCPP-262">{</front>
<front id="MarlinSerialCPP-263">  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. </front>
<front id="MarlinSerialCPP-264">  unsigned long i = 0;</front>
<front id="MarlinSerialCPP-265"></front>
<front id="MarlinSerialCPP-266">  if (n == 0) {</front>
<front id="MarlinSerialCPP-267">    print('0');</front>
<front id="MarlinSerialCPP-268">    return;</front>
<front id="MarlinSerialCPP-269">  } </front>
<front id="MarlinSerialCPP-270"></front>
<front id="MarlinSerialCPP-271">  while (n &gt; 0) {</front>
<front id="MarlinSerialCPP-272">    buf[i++] = n % base;</front>
<front id="MarlinSerialCPP-273">    n /= base;</front>
<front id="MarlinSerialCPP-274">  }</front>
<front id="MarlinSerialCPP-275"></front>
<front id="MarlinSerialCPP-276">  for (; i &gt; 0; i--)</front>
<front id="MarlinSerialCPP-277">    print((char) (buf[i - 1] &lt; 10 ?</front>
<front id="MarlinSerialCPP-278">      '0' + buf[i - 1] :</front>
<front id="MarlinSerialCPP-279">      'A' + buf[i - 1] - 10));</front>
<front id="MarlinSerialCPP-280">}</front>
<front id="MarlinSerialCPP-281"></front>
<front id="MarlinSerialCPP-282">void MarlinSerial::printFloat(double number, uint8_t digits) </front>
<front id="MarlinSerialCPP-283">{ </front>
<front id="MarlinSerialCPP-284">  // Handle negative numbers</front>
<front id="MarlinSerialCPP-285">  if (number &lt; 0.0)</front>
<front id="MarlinSerialCPP-286">  {</front>
<front id="MarlinSerialCPP-287">     print('-');</front>
<front id="MarlinSerialCPP-288">     number = -number;</front>
<front id="MarlinSerialCPP-289">  }</front>
<front id="MarlinSerialCPP-290"></front>
<front id="MarlinSerialCPP-291">  // Round correctly so that print(1.999, 2) prints as "2.00"</front>
<front id="MarlinSerialCPP-292">  double rounding = 0.5;</front>
<front id="MarlinSerialCPP-293">  for (uint8_t i=0; i&lt;digits; ++i)</front>
<front id="MarlinSerialCPP-294">    rounding /= 10.0;</front>
<front id="MarlinSerialCPP-295">  </front>
<front id="MarlinSerialCPP-296">  number += rounding;</front>
<front id="MarlinSerialCPP-297"></front>
<front id="MarlinSerialCPP-298">  // Extract the integer part of the number and print it</front>
<front id="MarlinSerialCPP-299">  unsigned long int_part = (unsigned long)number;</front>
<front id="MarlinSerialCPP-300">  double remainder = number - (double)int_part;</front>
<front id="MarlinSerialCPP-301">  print(int_part);</front>
<front id="MarlinSerialCPP-302"></front>
<front id="MarlinSerialCPP-303">  // Print the decimal point, but only if there are digits beyond</front>
<front id="MarlinSerialCPP-304">  if (digits &gt; 0)</front>
<front id="MarlinSerialCPP-305">    print("."); </front>
<front id="MarlinSerialCPP-306"></front>
<front id="MarlinSerialCPP-307">  // Extract digits from the remainder one at a time</front>
<front id="MarlinSerialCPP-308">  while (digits-- &gt; 0)</front>
<front id="MarlinSerialCPP-309">  {</front>
<front id="MarlinSerialCPP-310">    remainder *= 10.0;</front>
<front id="MarlinSerialCPP-311">    int toPrint = int(remainder);</front>
<front id="MarlinSerialCPP-312">    print(toPrint);</front>
<front id="MarlinSerialCPP-313">    remainder -= toPrint; </front>
<front id="MarlinSerialCPP-314">  } </front>
<front id="MarlinSerialCPP-315">}</front>
<front id="MarlinSerialCPP-316">// Preinstantiate Objects //////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-317"></front>
<front id="MarlinSerialCPP-318"></front>
<front id="MarlinSerialCPP-319">MarlinSerial MSerial;</front>
<front id="MarlinSerialCPP-320"></front>
<front id="MarlinSerialCPP-321">#endif // whole file</front>
<front id="MarlinSerialCPP-322">#endif // !AT90USB</front>
 </pre>
<h1>MarlinSerial.h</h1>
<pre  class="prettyprint linenums"><front id="MarlinSerialH-1">/*</front>
<front id="MarlinSerialH-2">  HardwareSerial.h - Hardware serial library for Wiring</front>
<front id="MarlinSerialH-3">  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.</front>
<front id="MarlinSerialH-4"></front>
<front id="MarlinSerialH-5">  This library is free software; you can redistribute it and/or</front>
<front id="MarlinSerialH-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="MarlinSerialH-7">  License as published by the Free Software Foundation; either</front>
<front id="MarlinSerialH-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="MarlinSerialH-9"></front>
<front id="MarlinSerialH-10">  This library is distributed in the hope that it will be useful,</front>
<front id="MarlinSerialH-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="MarlinSerialH-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="MarlinSerialH-13">  Lesser General Public License for more details.</front>
<front id="MarlinSerialH-14"></front>
<front id="MarlinSerialH-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="MarlinSerialH-16">  License along with this library; if not, write to the Free Software</front>
<front id="MarlinSerialH-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="MarlinSerialH-18"></front>
<front id="MarlinSerialH-19">  Modified 28 September 2010 by Mark Sproul</front>
<front id="MarlinSerialH-20">*/</front>
<front id="MarlinSerialH-21"></front>
<front id="MarlinSerialH-22">#ifndef MarlinSerial_h</front>
<front id="MarlinSerialH-23">#define MarlinSerial_h</front>
<front id="MarlinSerialH-24">#include "Marlin.h"</front>
<front id="MarlinSerialH-25"></front>
<front id="MarlinSerialH-26">#if !defined(SERIAL_PORT) </front>
<front id="MarlinSerialH-27">#define SERIAL_PORT 0</front>
<front id="MarlinSerialH-28">#endif</front>
<front id="MarlinSerialH-29"></front>
<front id="MarlinSerialH-30">// The presence of the UBRRH register is used to detect a UART.</front>
<front id="MarlinSerialH-31">#define UART_PRESENT(port) ((port == 0 && (defined(UBRRH) || defined(UBRR0H))) || \</front>
<front id="MarlinSerialH-32">						(port == 1 && defined(UBRR1H)) || (port == 2 && defined(UBRR2H)) || \</front>
<front id="MarlinSerialH-33">						(port == 3 && defined(UBRR3H)))				</front>
<front id="MarlinSerialH-34">						</front>
<front id="MarlinSerialH-35">// These are macros to build serial port register names for the selected SERIAL_PORT (C preprocessor</front>
<front id="MarlinSerialH-36">// requires two levels of indirection to expand macro values properly)</front>
<front id="MarlinSerialH-37">#define SERIAL_REGNAME(registerbase,number,suffix) SERIAL_REGNAME_INTERNAL(registerbase,number,suffix)</front>
<front id="MarlinSerialH-38">#if SERIAL_PORT == 0 && (!defined(UBRR0H) || !defined(UDR0)) // use un-numbered registers if necessary</front>
<front id="MarlinSerialH-39">#define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##suffix</front>
<front id="MarlinSerialH-40">#else</front>
<front id="MarlinSerialH-41">#define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##number##suffix</front>
<front id="MarlinSerialH-42">#endif</front>
<front id="MarlinSerialH-43"></front>
<front id="MarlinSerialH-44">// Registers used by MarlinSerial class (these are expanded </front>
<front id="MarlinSerialH-45">// depending on selected serial port</front>
<front id="MarlinSerialH-46">#define M_UCSRxA SERIAL_REGNAME(UCSR,SERIAL_PORT,A) // defines M_UCSRxA to be UCSRnA where n is the serial port number</front>
<front id="MarlinSerialH-47">#define M_UCSRxB SERIAL_REGNAME(UCSR,SERIAL_PORT,B) </front>
<front id="MarlinSerialH-48">#define M_RXENx SERIAL_REGNAME(RXEN,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-49">#define M_TXENx SERIAL_REGNAME(TXEN,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-50">#define M_RXCIEx SERIAL_REGNAME(RXCIE,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-51">#define M_UDREx SERIAL_REGNAME(UDRE,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-52">#define M_UDRx SERIAL_REGNAME(UDR,SERIAL_PORT,)  </front>
<front id="MarlinSerialH-53">#define M_UBRRxH SERIAL_REGNAME(UBRR,SERIAL_PORT,H)</front>
<front id="MarlinSerialH-54">#define M_UBRRxL SERIAL_REGNAME(UBRR,SERIAL_PORT,L)</front>
<front id="MarlinSerialH-55">#define M_RXCx SERIAL_REGNAME(RXC,SERIAL_PORT,)</front>
<front id="MarlinSerialH-56">#define M_USARTx_RX_vect SERIAL_REGNAME(USART,SERIAL_PORT,_RX_vect)</front>
<front id="MarlinSerialH-57">#define M_U2Xx SERIAL_REGNAME(U2X,SERIAL_PORT,)</front>
<front id="MarlinSerialH-58"></front>
<front id="MarlinSerialH-59"></front>
<front id="MarlinSerialH-60"></front>
<front id="MarlinSerialH-61">#define DEC 10</front>
<front id="MarlinSerialH-62">#define HEX 16</front>
<front id="MarlinSerialH-63">#define OCT 8</front>
<front id="MarlinSerialH-64">#define BIN 2</front>
<front id="MarlinSerialH-65">#define BYTE 0</front>
<front id="MarlinSerialH-66"></front>
<front id="MarlinSerialH-67"></front>
<front id="MarlinSerialH-68">#ifndef AT90USB</front>
<front id="MarlinSerialH-69">// Define constants and variables for buffering incoming serial data.  We're</front>
<front id="MarlinSerialH-70">// using a ring buffer (I think), in which rx_buffer_head is the index of the</front>
<front id="MarlinSerialH-71">// location to which to write the next incoming character and rx_buffer_tail</front>
<front id="MarlinSerialH-72">// is the index of the location from which to read.</front>
<front id="MarlinSerialH-73">#define RX_BUFFER_SIZE 128</front>
<front id="MarlinSerialH-74"></front>
<front id="MarlinSerialH-75"></front>
<front id="MarlinSerialH-76">struct ring_buffer</front>
<front id="MarlinSerialH-77">{</front>
<front id="MarlinSerialH-78">  unsigned char buffer[RX_BUFFER_SIZE];</front>
<front id="MarlinSerialH-79">  int head;</front>
<front id="MarlinSerialH-80">  int tail;</front>
<front id="MarlinSerialH-81">};</front>
<front id="MarlinSerialH-82"></front>
<front id="MarlinSerialH-83">#if UART_PRESENT(SERIAL_PORT)</front>
<front id="MarlinSerialH-84">  extern ring_buffer rx_buffer;</front>
<front id="MarlinSerialH-85">#endif</front>
<front id="MarlinSerialH-86"></front>
<front id="MarlinSerialH-87">class MarlinSerial //: public Stream</front>
<front id="MarlinSerialH-88">{</front>
<front id="MarlinSerialH-89"></front>
<front id="MarlinSerialH-90">  public:</front>
<front id="MarlinSerialH-91">    MarlinSerial();</front>
<front id="MarlinSerialH-92">    void begin(long);</front>
<front id="MarlinSerialH-93">    void end();</front>
<front id="MarlinSerialH-94">    int peek(void);</front>
<front id="MarlinSerialH-95">    int read(void);</front>
<front id="MarlinSerialH-96">    void flush(void);</front>
<front id="MarlinSerialH-97">    </front>
<front id="MarlinSerialH-98">    FORCE_INLINE int available(void)</front>
<front id="MarlinSerialH-99">    {</front>
<front id="MarlinSerialH-100">      return (unsigned int)(RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialH-101">    }</front>
<front id="MarlinSerialH-102">    </front>
<front id="MarlinSerialH-103">    FORCE_INLINE void write(uint8_t c)</front>
<front id="MarlinSerialH-104">    {</front>
<front id="MarlinSerialH-105">      while (!((M_UCSRxA) & (1 &lt;&lt; M_UDREx)))</front>
<front id="MarlinSerialH-106">        ;</front>
<front id="MarlinSerialH-107"></front>
<front id="MarlinSerialH-108">      M_UDRx = c;</front>
<front id="MarlinSerialH-109">    }</front>
<front id="MarlinSerialH-110">    </front>
<front id="MarlinSerialH-111">    </front>
<front id="MarlinSerialH-112">    FORCE_INLINE void checkRx(void)</front>
<front id="MarlinSerialH-113">    {</front>
<front id="MarlinSerialH-114">      if((M_UCSRxA & (1&lt;&lt;M_RXCx)) != 0) {</front>
<front id="MarlinSerialH-115">        unsigned char c  =  M_UDRx;</front>
<front id="MarlinSerialH-116">        int i = (unsigned int)(rx_buffer.head + 1) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialH-117"></front>
<front id="MarlinSerialH-118">        // if we should be storing the received character into the location</front>
<front id="MarlinSerialH-119">        // just before the tail (meaning that the head would advance to the</front>
<front id="MarlinSerialH-120">        // current location of the tail), we're about to overflow the buffer</front>
<front id="MarlinSerialH-121">        // and so we don't write the character or advance the head.</front>
<front id="MarlinSerialH-122">        if (i != rx_buffer.tail) {</front>
<front id="MarlinSerialH-123">          rx_buffer.buffer[rx_buffer.head] = c;</front>
<front id="MarlinSerialH-124">          rx_buffer.head = i;</front>
<front id="MarlinSerialH-125">        }</front>
<front id="MarlinSerialH-126">      }</front>
<front id="MarlinSerialH-127">    }</front>
<front id="MarlinSerialH-128">    </front>
<front id="MarlinSerialH-129">    </front>
<front id="MarlinSerialH-130">    private:</front>
<front id="MarlinSerialH-131">    void printNumber(unsigned long, uint8_t);</front>
<front id="MarlinSerialH-132">    void printFloat(double, uint8_t);</front>
<front id="MarlinSerialH-133">    </front>
<front id="MarlinSerialH-134">    </front>
<front id="MarlinSerialH-135">  public:</front>
<front id="MarlinSerialH-136">    </front>
<front id="MarlinSerialH-137">    FORCE_INLINE void write(const char *str)</front>
<front id="MarlinSerialH-138">    {</front>
<front id="MarlinSerialH-139">      while (*str)</front>
<front id="MarlinSerialH-140">        write(*str++);</front>
<front id="MarlinSerialH-141">    }</front>
<front id="MarlinSerialH-142"></front>
<front id="MarlinSerialH-143"></front>
<front id="MarlinSerialH-144">    FORCE_INLINE void write(const uint8_t *buffer, size_t size)</front>
<front id="MarlinSerialH-145">    {</front>
<front id="MarlinSerialH-146">      while (size--)</front>
<front id="MarlinSerialH-147">        write(*buffer++);</front>
<front id="MarlinSerialH-148">    }</front>
<front id="MarlinSerialH-149"></front>
<front id="MarlinSerialH-150">    FORCE_INLINE void print(const String &s)</front>
<front id="MarlinSerialH-151">    {</front>
<front id="MarlinSerialH-152">      for (int i = 0; i &lt; (int)s.length(); i++) {</front>
<front id="MarlinSerialH-153">        write(s[i]);</front>
<front id="MarlinSerialH-154">      }</front>
<front id="MarlinSerialH-155">    }</front>
<front id="MarlinSerialH-156">    </front>
<front id="MarlinSerialH-157">    FORCE_INLINE void print(const char *str)</front>
<front id="MarlinSerialH-158">    {</front>
<front id="MarlinSerialH-159">      write(str);</front>
<front id="MarlinSerialH-160">    }</front>
<front id="MarlinSerialH-161">    void print(char, int = BYTE);</front>
<front id="MarlinSerialH-162">    void print(unsigned char, int = BYTE);</front>
<front id="MarlinSerialH-163">    void print(int, int = DEC);</front>
<front id="MarlinSerialH-164">    void print(unsigned int, int = DEC);</front>
<front id="MarlinSerialH-165">    void print(long, int = DEC);</front>
<front id="MarlinSerialH-166">    void print(unsigned long, int = DEC);</front>
<front id="MarlinSerialH-167">    void print(double, int = 2);</front>
<front id="MarlinSerialH-168"></front>
<front id="MarlinSerialH-169">    void println(const String &s);</front>
<front id="MarlinSerialH-170">    void println(const char[]);</front>
<front id="MarlinSerialH-171">    void println(char, int = BYTE);</front>
<front id="MarlinSerialH-172">    void println(unsigned char, int = BYTE);</front>
<front id="MarlinSerialH-173">    void println(int, int = DEC);</front>
<front id="MarlinSerialH-174">    void println(unsigned int, int = DEC);</front>
<front id="MarlinSerialH-175">    void println(long, int = DEC);</front>
<front id="MarlinSerialH-176">    void println(unsigned long, int = DEC);</front>
<front id="MarlinSerialH-177">    void println(double, int = 2);</front>
<front id="MarlinSerialH-178">    void println(void);</front>
<front id="MarlinSerialH-179">};</front>
<front id="MarlinSerialH-180"></front>
<front id="MarlinSerialH-181">extern MarlinSerial MSerial;</front>
<front id="MarlinSerialH-182">#endif // !AT90USB</front>
<front id="MarlinSerialH-183"></front>
<front id="MarlinSerialH-184">#endif</front>
 </pre>
<h1>motion_control.cpp</h1>
<pre  class="prettyprint linenums"><front id="motion_controlCPP-1">/*</front>
<front id="motion_controlCPP-2">  motion_control.c - high level interface for issuing motion commands</front>
<front id="motion_controlCPP-3">  Part of Grbl</front>
<front id="motion_controlCPP-4"></front>
<front id="motion_controlCPP-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="motion_controlCPP-6">  Copyright (c) 2011 Sungeun K. Jeon</front>
<front id="motion_controlCPP-7">  </front>
<front id="motion_controlCPP-8">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="motion_controlCPP-9">  it under the terms of the GNU General Public License as published by</front>
<front id="motion_controlCPP-10">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="motion_controlCPP-11">  (at your option) any later version.</front>
<front id="motion_controlCPP-12"></front>
<front id="motion_controlCPP-13">  Grbl is distributed in the hope that it will be useful,</front>
<front id="motion_controlCPP-14">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="motion_controlCPP-15">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="motion_controlCPP-16">  GNU General Public License for more details.</front>
<front id="motion_controlCPP-17"></front>
<front id="motion_controlCPP-18">  You should have received a copy of the GNU General Public License</front>
<front id="motion_controlCPP-19">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="motion_controlCPP-20">*/</front>
<front id="motion_controlCPP-21"></front>
<front id="motion_controlCPP-22">#include "Marlin.h"</front>
<front id="motion_controlCPP-23">#include "stepper.h"</front>
<front id="motion_controlCPP-24">#include "planner.h"</front>
<front id="motion_controlCPP-25"></front>
<front id="motion_controlCPP-26">// The arc is approximated by generating a huge number of tiny, linear segments. The length of each </front>
<front id="motion_controlCPP-27">// segment is configured in settings.mm_per_arc_segment.  </front>
<front id="motion_controlCPP-28">void mc_arc(float *position, float *target, float *offset, uint8_t axis_0, uint8_t axis_1, </front>
<front id="motion_controlCPP-29">  uint8_t axis_linear, float feed_rate, float radius, uint8_t isclockwise, uint8_t extruder)</front>
<front id="motion_controlCPP-30">{      </front>
<front id="motion_controlCPP-31">  //   int acceleration_manager_was_enabled = plan_is_acceleration_manager_enabled();</front>
<front id="motion_controlCPP-32">  //   plan_set_acceleration_manager_enabled(false); // disable acceleration management for the duration of the arc</front>
<front id="motion_controlCPP-33">  float center_axis0 = position[axis_0] + offset[axis_0];</front>
<front id="motion_controlCPP-34">  float center_axis1 = position[axis_1] + offset[axis_1];</front>
<front id="motion_controlCPP-35">  float linear_travel = target[axis_linear] - position[axis_linear];</front>
<front id="motion_controlCPP-36">  float extruder_travel = target[E_AXIS] - position[E_AXIS];</front>
<front id="motion_controlCPP-37">  float r_axis0 = -offset[axis_0];  // Radius vector from center to current location</front>
<front id="motion_controlCPP-38">  float r_axis1 = -offset[axis_1];</front>
<front id="motion_controlCPP-39">  float rt_axis0 = target[axis_0] - center_axis0;</front>
<front id="motion_controlCPP-40">  float rt_axis1 = target[axis_1] - center_axis1;</front>
<front id="motion_controlCPP-41">  </front>
<front id="motion_controlCPP-42">  // CCW angle between position and target from circle center. Only one atan2() trig computation required.</front>
<front id="motion_controlCPP-43">  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);</front>
<front id="motion_controlCPP-44">  if (angular_travel &lt; 0) { angular_travel += 2*M_PI; }</front>
<front id="motion_controlCPP-45">  if (isclockwise) { angular_travel -= 2*M_PI; }</front>
<front id="motion_controlCPP-46">  </front>
<front id="motion_controlCPP-47">  float millimeters_of_travel = hypot(angular_travel*radius, fabs(linear_travel));</front>
<front id="motion_controlCPP-48">  if (millimeters_of_travel &lt; 0.001) { return; }</front>
<front id="motion_controlCPP-49">  uint16_t segments = floor(millimeters_of_travel/MM_PER_ARC_SEGMENT);</front>
<front id="motion_controlCPP-50">  if(segments == 0) segments = 1;</front>
<front id="motion_controlCPP-51">  </front>
<front id="motion_controlCPP-52">  /*  </front>
<front id="motion_controlCPP-53">    // Multiply inverse feed_rate to compensate for the fact that this movement is approximated</front>
<front id="motion_controlCPP-54">    // by a number of discrete segments. The inverse feed_rate should be correct for the sum of </front>
<front id="motion_controlCPP-55">    // all segments.</front>
<front id="motion_controlCPP-56">    if (invert_feed_rate) { feed_rate *= segments; }</front>
<front id="motion_controlCPP-57">  */</front>
<front id="motion_controlCPP-58">  float theta_per_segment = angular_travel/segments;</front>
<front id="motion_controlCPP-59">  float linear_per_segment = linear_travel/segments;</front>
<front id="motion_controlCPP-60">  float extruder_per_segment = extruder_travel/segments;</front>
<front id="motion_controlCPP-61">  </front>
<front id="motion_controlCPP-62">  /* Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,</front>
<front id="motion_controlCPP-63">     and phi is the angle of rotation. Based on the solution approach by Jens Geisler.</front>
<front id="motion_controlCPP-64">         r_T = [cos(phi) -sin(phi);</front>
<front id="motion_controlCPP-65">                sin(phi)  cos(phi] * r ;</front>
<front id="motion_controlCPP-66">     </front>
<front id="motion_controlCPP-67">     For arc generation, the center of the circle is the axis of rotation and the radius vector is </front>
<front id="motion_controlCPP-68">     defined from the circle center to the initial position. Each line segment is formed by successive</front>
<front id="motion_controlCPP-69">     vector rotations. This requires only two cos() and sin() computations to form the rotation</front>
<front id="motion_controlCPP-70">     matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since</front>
<front id="motion_controlCPP-71">     all double numbers are single precision on the Arduino. (True double precision will not have</front>
<front id="motion_controlCPP-72">     round off issues for CNC applications.) Single precision error can accumulate to be greater than</front>
<front id="motion_controlCPP-73">     tool precision in some cases. Therefore, arc path correction is implemented. </front>
<front id="motion_controlCPP-74"></front>
<front id="motion_controlCPP-75">     Small angle approximation may be used to reduce computation overhead further. This approximation</front>
<front id="motion_controlCPP-76">     holds for everything, but very small circles and large mm_per_arc_segment values. In other words,</front>
<front id="motion_controlCPP-77">     theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large</front>
<front id="motion_controlCPP-78">     to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for </front>
<front id="motion_controlCPP-79">     numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an</front>
<front id="motion_controlCPP-80">     issue for CNC machines with the single precision Arduino calculations.</front>
<front id="motion_controlCPP-81">     </front>
<front id="motion_controlCPP-82">     This approximation also allows mc_arc to immediately insert a line segment into the planner </front>
<front id="motion_controlCPP-83">     without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied</front>
<front id="motion_controlCPP-84">     a correction, the planner should have caught up to the lag caused by the initial mc_arc overhead. </front>
<front id="motion_controlCPP-85">     This is important when there are successive arc motions. </front>
<front id="motion_controlCPP-86">  */</front>
<front id="motion_controlCPP-87">  // Vector rotation matrix values</front>
<front id="motion_controlCPP-88">  float cos_T = 1-0.5*theta_per_segment*theta_per_segment; // Small angle approximation</front>
<front id="motion_controlCPP-89">  float sin_T = theta_per_segment;</front>
<front id="motion_controlCPP-90">  </front>
<front id="motion_controlCPP-91">  float arc_target[4];</front>
<front id="motion_controlCPP-92">  float sin_Ti;</front>
<front id="motion_controlCPP-93">  float cos_Ti;</front>
<front id="motion_controlCPP-94">  float r_axisi;</front>
<front id="motion_controlCPP-95">  uint16_t i;</front>
<front id="motion_controlCPP-96">  int8_t count = 0;</front>
<front id="motion_controlCPP-97"></front>
<front id="motion_controlCPP-98">  // Initialize the linear axis</front>
<front id="motion_controlCPP-99">  arc_target[axis_linear] = position[axis_linear];</front>
<front id="motion_controlCPP-100">  </front>
<front id="motion_controlCPP-101">  // Initialize the extruder axis</front>
<front id="motion_controlCPP-102">  arc_target[E_AXIS] = position[E_AXIS];</front>
<front id="motion_controlCPP-103"></front>
<front id="motion_controlCPP-104">  for (i = 1; i&lt;segments; i++) { // Increment (segments-1)</front>
<front id="motion_controlCPP-105">    </front>
<front id="motion_controlCPP-106">    if (count &lt; N_ARC_CORRECTION) {</front>
<front id="motion_controlCPP-107">      // Apply vector rotation matrix </front>
<front id="motion_controlCPP-108">      r_axisi = r_axis0*sin_T + r_axis1*cos_T;</front>
<front id="motion_controlCPP-109">      r_axis0 = r_axis0*cos_T - r_axis1*sin_T;</front>
<front id="motion_controlCPP-110">      r_axis1 = r_axisi;</front>
<front id="motion_controlCPP-111">      count++;</front>
<front id="motion_controlCPP-112">    } else {</front>
<front id="motion_controlCPP-113">      // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.</front>
<front id="motion_controlCPP-114">      // Compute exact location by applying transformation matrix from initial radius vector(=-offset).</front>
<front id="motion_controlCPP-115">      cos_Ti = cos(i*theta_per_segment);</front>
<front id="motion_controlCPP-116">      sin_Ti = sin(i*theta_per_segment);</front>
<front id="motion_controlCPP-117">      r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;</front>
<front id="motion_controlCPP-118">      r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;</front>
<front id="motion_controlCPP-119">      count = 0;</front>
<front id="motion_controlCPP-120">    }</front>
<front id="motion_controlCPP-121"></front>
<front id="motion_controlCPP-122">    // Update arc_target location</front>
<front id="motion_controlCPP-123">    arc_target[axis_0] = center_axis0 + r_axis0;</front>
<front id="motion_controlCPP-124">    arc_target[axis_1] = center_axis1 + r_axis1;</front>
<front id="motion_controlCPP-125">    arc_target[axis_linear] += linear_per_segment;</front>
<front id="motion_controlCPP-126">    arc_target[E_AXIS] += extruder_per_segment;</front>
<front id="motion_controlCPP-127"></front>
<front id="motion_controlCPP-128">    clamp_to_software_endstops(arc_target);</front>
<front id="motion_controlCPP-129">    plan_buffer_line(arc_target[X_AXIS], arc_target[Y_AXIS], arc_target[Z_AXIS], arc_target[E_AXIS], feed_rate, extruder);</front>
<front id="motion_controlCPP-130">    </front>
<front id="motion_controlCPP-131">  }</front>
<front id="motion_controlCPP-132">  // Ensure last segment arrives at target location.</front>
<front id="motion_controlCPP-133">  plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feed_rate, extruder);</front>
<front id="motion_controlCPP-134"></front>
<front id="motion_controlCPP-135">  //   plan_set_acceleration_manager_enabled(acceleration_manager_was_enabled);</front>
<front id="motion_controlCPP-136">}</front>
<front id="motion_controlCPP-137"></front>
 </pre>
<h1>motion_control.h</h1>
<pre  class="prettyprint linenums"><front id="motion_controlH-1">/*</front>
<front id="motion_controlH-2">  motion_control.h - high level interface for issuing motion commands</front>
<front id="motion_controlH-3">  Part of Grbl</front>
<front id="motion_controlH-4"></front>
<front id="motion_controlH-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="motion_controlH-6">  Copyright (c) 2011 Sungeun K. Jeon</front>
<front id="motion_controlH-7">  </front>
<front id="motion_controlH-8">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="motion_controlH-9">  it under the terms of the GNU General Public License as published by</front>
<front id="motion_controlH-10">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="motion_controlH-11">  (at your option) any later version.</front>
<front id="motion_controlH-12"></front>
<front id="motion_controlH-13">  Grbl is distributed in the hope that it will be useful,</front>
<front id="motion_controlH-14">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="motion_controlH-15">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="motion_controlH-16">  GNU General Public License for more details.</front>
<front id="motion_controlH-17"></front>
<front id="motion_controlH-18">  You should have received a copy of the GNU General Public License</front>
<front id="motion_controlH-19">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="motion_controlH-20">*/</front>
<front id="motion_controlH-21"></front>
<front id="motion_controlH-22">#ifndef motion_control_h</front>
<front id="motion_controlH-23">#define motion_control_h</front>
<front id="motion_controlH-24"></front>
<front id="motion_controlH-25">// Execute an arc in offset mode format. position == current xyz, target == target xyz, </front>
<front id="motion_controlH-26">// offset == offset from current xyz, axis_XXX defines circle plane in tool space, axis_linear is</front>
<front id="motion_controlH-27">// the direction of helical travel, radius == circle radius, isclockwise boolean. Used</front>
<front id="motion_controlH-28">// for vector transformation direction.</front>
<front id="motion_controlH-29">void mc_arc(float *position, float *target, float *offset, unsigned char axis_0, unsigned char axis_1,</front>
<front id="motion_controlH-30">  unsigned char axis_linear, float feed_rate, float radius, unsigned char isclockwise, uint8_t extruder);</front>
<front id="motion_controlH-31">  </front>
<front id="motion_controlH-32">#endif</front>
 </pre>
<h1>pins.h</h1>
<pre  class="prettyprint linenums"><front id="pinsH-1">#ifndef PINS_H</front>
<front id="pinsH-2">#define PINS_H</front>
<front id="pinsH-3"></front>
<front id="pinsH-4">#define X_MS1_PIN -1</front>
<front id="pinsH-5">#define X_MS2_PIN -1</front>
<front id="pinsH-6">#define Y_MS1_PIN -1</front>
<front id="pinsH-7">#define Y_MS2_PIN -1</front>
<front id="pinsH-8">#define Z_MS1_PIN -1</front>
<front id="pinsH-9">#define Z_MS2_PIN -1</front>
<front id="pinsH-10">#define E0_MS1_PIN -1</front>
<front id="pinsH-11">#define E0_MS2_PIN -1</front>
<front id="pinsH-12">#define E1_MS1_PIN -1</front>
<front id="pinsH-13">#define E1_MS2_PIN -1</front>
<front id="pinsH-14">#define DIGIPOTSS_PIN -1</front>
<front id="pinsH-15"></front>
<front id="pinsH-16">#if MOTHERBOARD == 99</front>
<front id="pinsH-17">#define KNOWN_BOARD 1</front>
<front id="pinsH-18"></front>
<front id="pinsH-19">#define X_STEP_PIN          2</front>
<front id="pinsH-20">#define X_DIR_PIN           3</front>
<front id="pinsH-21">#define X_ENABLE_PIN        -1</front>
<front id="pinsH-22">#define X_STOP_PIN          16</front>
<front id="pinsH-23"></front>
<front id="pinsH-24">#define Y_STEP_PIN          5</front>
<front id="pinsH-25">#define Y_DIR_PIN           6</front>
<front id="pinsH-26">#define Y_ENABLE_PIN       -1</front>
<front id="pinsH-27">#define Y_STOP_PIN          67</front>
<front id="pinsH-28"></front>
<front id="pinsH-29">#define Z_STEP_PIN          62</front>
<front id="pinsH-30">#define Z_DIR_PIN           63</front>
<front id="pinsH-31">#define Z_ENABLE_PIN       -1</front>
<front id="pinsH-32">#define Z_STOP_PIN          59</front>
<front id="pinsH-33"></front>
<front id="pinsH-34">#define E0_STEP_PIN         65</front>
<front id="pinsH-35">#define E0_DIR_PIN          66</front>
<front id="pinsH-36">#define E0_ENABLE_PIN      -1</front>
<front id="pinsH-37"></front>
<front id="pinsH-38">#define SDPOWER            -1</front>
<front id="pinsH-39">#define SDSS               53</front>
<front id="pinsH-40">#define LED_PIN            -1</front>
<front id="pinsH-41">#define FAN_PIN            -1</front>
<front id="pinsH-42">#define PS_ON_PIN           9</front>
<front id="pinsH-43">#define KILL_PIN           -1</front>
<front id="pinsH-44"></front>
<front id="pinsH-45">#define HEATER_0_PIN        13</front>
<front id="pinsH-46">#define HEATER_1_PIN       -1</front>
<front id="pinsH-47">#define HEATER_2_PIN       -1</front>
<front id="pinsH-48">#define TEMP_0_PIN          6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-49">#define TEMP_1_PIN         -1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-50">#define TEMP_2_PIN         -1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-51">#define HEATER_BED_PIN      4</front>
<front id="pinsH-52">#define TEMP_BED_PIN       10</front>
<front id="pinsH-53"></front>
<front id="pinsH-54">#endif /* 99 */</front>
<front id="pinsH-55"></front>
<front id="pinsH-56">/****************************************************************************************</front>
<front id="pinsH-57">* Sethi 3D_1 pin assignment - www.sethi3d.com.br</front>
<front id="pinsH-58">*</front>
<front id="pinsH-59">****************************************************************************************/</front>
<front id="pinsH-60"></front>
<front id="pinsH-61">#if MOTHERBOARD == 20</front>
<front id="pinsH-62">#define KNOWN_BOARD</front>
<front id="pinsH-63"></front>
<front id="pinsH-64">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pinsH-65">#error Oops! Make sure you have 'Sethi 3D' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-66"></front>
<front id="pinsH-67">#endif</front>
<front id="pinsH-68"></front>
<front id="pinsH-69">#ifndef GEN7_VERSION</front>
<front id="pinsH-70">#define GEN7_VERSION 12 // v1.x</front>
<front id="pinsH-71">#endif</front>
<front id="pinsH-72"></front>
<front id="pinsH-73">//x axis pins</front>
<front id="pinsH-74">#define X_STEP_PIN 19</front>
<front id="pinsH-75">#define X_DIR_PIN 18</front>
<front id="pinsH-76">#define X_ENABLE_PIN 24</front>
<front id="pinsH-77">#define X_STOP_PIN 2</front>
<front id="pinsH-78"></front>
<front id="pinsH-79">//y axis pins</front>
<front id="pinsH-80">#define Y_STEP_PIN 23</front>
<front id="pinsH-81">#define Y_DIR_PIN 22</front>
<front id="pinsH-82">#define Y_ENABLE_PIN 24</front>
<front id="pinsH-83">#define Y_STOP_PIN 0</front>
<front id="pinsH-84"></front>
<front id="pinsH-85">//z axis pins</front>
<front id="pinsH-86">#define Z_STEP_PIN 26</front>
<front id="pinsH-87">#define Z_DIR_PIN 25</front>
<front id="pinsH-88">#define Z_ENABLE_PIN 24</front>
<front id="pinsH-89">#define Z_MIN_PIN 1</front>
<front id="pinsH-90">#define Z_MAX_PIN 0</front>
<front id="pinsH-91"></front>
<front id="pinsH-92">//extruder pins</front>
<front id="pinsH-93">#define E0_STEP_PIN 28</front>
<front id="pinsH-94">#define E0_DIR_PIN 27</front>
<front id="pinsH-95">#define E0_ENABLE_PIN 24</front>
<front id="pinsH-96"></front>
<front id="pinsH-97">#define TEMP_0_PIN 1</front>
<front id="pinsH-98">#define TEMP_1_PIN -1</front>
<front id="pinsH-99">#define TEMP_2_PIN -1</front>
<front id="pinsH-100">#define TEMP_BED_PIN 2</front>
<front id="pinsH-101"></front>
<front id="pinsH-102">#define HEATER_0_PIN 4</front>
<front id="pinsH-103">#define HEATER_1_PIN -1</front>
<front id="pinsH-104">#define HEATER_2_PIN -1</front>
<front id="pinsH-105">#define HEATER_BED_PIN 3</front>
<front id="pinsH-106"></front>
<front id="pinsH-107">#define KILL_PIN -1</front>
<front id="pinsH-108"></front>
<front id="pinsH-109">#define SDPOWER -1</front>
<front id="pinsH-110">#define SDSS -1 // SCL pin of I2C header</front>
<front id="pinsH-111">#define LED_PIN -1</front>
<front id="pinsH-112"></front>
<front id="pinsH-113">#if (GEN7_VERSION &gt;= 13)</front>
<front id="pinsH-114">// Gen7 v1.3 removed the fan pin</front>
<front id="pinsH-115">#define FAN_PIN -1</front>
<front id="pinsH-116">#else</front>
<front id="pinsH-117">#define FAN_PIN 31</front>
<front id="pinsH-118">#endif</front>
<front id="pinsH-119">#define PS_ON_PIN 15</front>
<front id="pinsH-120"></front>
<front id="pinsH-121">//All these generations of Gen7 supply thermistor power</front>
<front id="pinsH-122">//via PS_ON, so ignore bad thermistor readings</front>
<front id="pinsH-123">#define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="pinsH-124"></front>
<front id="pinsH-125">//our pin for debugging.</front>
<front id="pinsH-126">#define DEBUG_PIN 0</front>
<front id="pinsH-127"></front>
<front id="pinsH-128">//our RS485 pins</front>
<front id="pinsH-129">#define TX_ENABLE_PIN 12</front>
<front id="pinsH-130">#define RX_ENABLE_PIN 13</front>
<front id="pinsH-131"></front>
<front id="pinsH-132">#endif</front>
<front id="pinsH-133"></front>
<front id="pinsH-134">/****************************************************************************************</front>
<front id="pinsH-135">* Gen7 v1.1, v1.2, v1.3 pin assignment</front>
<front id="pinsH-136">*</front>
<front id="pinsH-137">****************************************************************************************/</front>
<front id="pinsH-138"></front>
<front id="pinsH-139"></front>
<front id="pinsH-140">#if MOTHERBOARD == 12</front>
<front id="pinsH-141">#define MOTHERBOARD 11</front>
<front id="pinsH-142">#define GEN7_VERSION 13 // v1.3</front>
<front id="pinsH-143">#endif</front>
<front id="pinsH-144"></front>
<front id="pinsH-145">#if MOTHERBOARD == 11</front>
<front id="pinsH-146">#define KNOWN_BOARD</front>
<front id="pinsH-147"></front>
<front id="pinsH-148">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pinsH-149">#error Oops! Make sure you have 'Gen7' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-150"></front>
<front id="pinsH-151">#endif</front>
<front id="pinsH-152"></front>
<front id="pinsH-153">#ifndef GEN7_VERSION</front>
<front id="pinsH-154">#define GEN7_VERSION 12 // v1.x</front>
<front id="pinsH-155">#endif</front>
<front id="pinsH-156"></front>
<front id="pinsH-157">//x axis pins</front>
<front id="pinsH-158">#define X_STEP_PIN 19</front>
<front id="pinsH-159">#define X_DIR_PIN 18</front>
<front id="pinsH-160">#define X_ENABLE_PIN 24</front>
<front id="pinsH-161">#define X_STOP_PIN 7</front>
<front id="pinsH-162"></front>
<front id="pinsH-163">//y axis pins</front>
<front id="pinsH-164">#define Y_STEP_PIN 23</front>
<front id="pinsH-165">#define Y_DIR_PIN 22</front>
<front id="pinsH-166">#define Y_ENABLE_PIN 24</front>
<front id="pinsH-167">#define Y_STOP_PIN 5</front>
<front id="pinsH-168"></front>
<front id="pinsH-169">//z axis pins</front>
<front id="pinsH-170">#define Z_STEP_PIN 26</front>
<front id="pinsH-171">#define Z_DIR_PIN 25</front>
<front id="pinsH-172">#define Z_ENABLE_PIN 24</front>
<front id="pinsH-173">#define Z_MIN_PIN 1</front>
<front id="pinsH-174">#define Z_MAX_PIN 0</front>
<front id="pinsH-175"></front>
<front id="pinsH-176">//extruder pins</front>
<front id="pinsH-177">#define E0_STEP_PIN 28</front>
<front id="pinsH-178">#define E0_DIR_PIN 27</front>
<front id="pinsH-179">#define E0_ENABLE_PIN 24</front>
<front id="pinsH-180"></front>
<front id="pinsH-181">#define TEMP_0_PIN 1</front>
<front id="pinsH-182">#define TEMP_1_PIN -1</front>
<front id="pinsH-183">#define TEMP_2_PIN -1</front>
<front id="pinsH-184">#define TEMP_BED_PIN 2</front>
<front id="pinsH-185"></front>
<front id="pinsH-186">#define HEATER_0_PIN 4</front>
<front id="pinsH-187">#define HEATER_1_PIN -1</front>
<front id="pinsH-188">#define HEATER_2_PIN -1</front>
<front id="pinsH-189">#define HEATER_BED_PIN 3</front>
<front id="pinsH-190"></front>
<front id="pinsH-191">#define KILL_PIN -1</front>
<front id="pinsH-192"></front>
<front id="pinsH-193">#define SDPOWER -1</front>
<front id="pinsH-194">#define SDSS -1 // SCL pin of I2C header</front>
<front id="pinsH-195">#define LED_PIN -1</front>
<front id="pinsH-196"></front>
<front id="pinsH-197">#if (GEN7_VERSION &gt;= 13)</front>
<front id="pinsH-198">// Gen7 v1.3 removed the fan pin</front>
<front id="pinsH-199">#define FAN_PIN -1</front>
<front id="pinsH-200">#else</front>
<front id="pinsH-201">#define FAN_PIN 31</front>
<front id="pinsH-202">#endif</front>
<front id="pinsH-203">#define PS_ON_PIN 15</front>
<front id="pinsH-204"></front>
<front id="pinsH-205">//All these generations of Gen7 supply thermistor power</front>
<front id="pinsH-206">//via PS_ON, so ignore bad thermistor readings</front>
<front id="pinsH-207">#define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="pinsH-208"></front>
<front id="pinsH-209">//our pin for debugging.</front>
<front id="pinsH-210">#define DEBUG_PIN 0</front>
<front id="pinsH-211"></front>
<front id="pinsH-212">//our RS485 pins</front>
<front id="pinsH-213">#define TX_ENABLE_PIN 12</front>
<front id="pinsH-214">#define RX_ENABLE_PIN 13</front>
<front id="pinsH-215"></front>
<front id="pinsH-216">#endif</front>
<front id="pinsH-217"></front>
<front id="pinsH-218">/****************************************************************************************</front>
<front id="pinsH-219">* Gen7 v1.4 pin assignment</front>
<front id="pinsH-220">*</front>
<front id="pinsH-221">****************************************************************************************/</front>
<front id="pinsH-222"></front>
<front id="pinsH-223">#if MOTHERBOARD == 13</front>
<front id="pinsH-224">#define GEN7_VERSION 14 // v1.4</front>
<front id="pinsH-225">#endif</front>
<front id="pinsH-226"></front>
<front id="pinsH-227">#if MOTHERBOARD == 13</front>
<front id="pinsH-228">#define KNOWN_BOARD</front>
<front id="pinsH-229"></front>
<front id="pinsH-230">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pinsH-231">#error Oops! Make sure you have 'Gen7' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-232"></front>
<front id="pinsH-233">#endif</front>
<front id="pinsH-234"></front>
<front id="pinsH-235">#ifndef GEN7_VERSION</front>
<front id="pinsH-236">#define GEN7_VERSION 14 // v1.x</front>
<front id="pinsH-237">#endif</front>
<front id="pinsH-238"></front>
<front id="pinsH-239">//x axis pins</front>
<front id="pinsH-240">#define X_STEP_PIN 29</front>
<front id="pinsH-241">#define X_DIR_PIN 28</front>
<front id="pinsH-242">#define X_ENABLE_PIN 25</front>
<front id="pinsH-243">#define X_STOP_PIN 0</front>
<front id="pinsH-244"></front>
<front id="pinsH-245">//y axis pins</front>
<front id="pinsH-246">#define Y_STEP_PIN 27</front>
<front id="pinsH-247">#define Y_DIR_PIN 26</front>
<front id="pinsH-248">#define Y_ENABLE_PIN 25</front>
<front id="pinsH-249">#define Y_STOP_PIN 1</front>
<front id="pinsH-250"></front>
<front id="pinsH-251">//z axis pins</front>
<front id="pinsH-252">#define Z_STEP_PIN 23</front>
<front id="pinsH-253">#define Z_DIR_PIN 22</front>
<front id="pinsH-254">#define Z_ENABLE_PIN 25</front>
<front id="pinsH-255">#define Z_STOP_PIN 2</front>
<front id="pinsH-256"></front>
<front id="pinsH-257">//extruder pins</front>
<front id="pinsH-258">#define E0_STEP_PIN 19</front>
<front id="pinsH-259">#define E0_DIR_PIN 18</front>
<front id="pinsH-260">#define E0_ENABLE_PIN 25</front>
<front id="pinsH-261"></front>
<front id="pinsH-262">#define TEMP_0_PIN 1</front>
<front id="pinsH-263">#define TEMP_1_PIN -1</front>
<front id="pinsH-264">#define TEMP_2_PIN -1</front>
<front id="pinsH-265">#define TEMP_BED_PIN 0</front>
<front id="pinsH-266"></front>
<front id="pinsH-267">#define HEATER_0_PIN 4</front>
<front id="pinsH-268">#define HEATER_1_PIN -1</front>
<front id="pinsH-269">#define HEATER_2_PIN -1</front>
<front id="pinsH-270">#define HEATER_BED_PIN 3</front>
<front id="pinsH-271"></front>
<front id="pinsH-272">#define KILL_PIN -1</front>
<front id="pinsH-273"></front>
<front id="pinsH-274">#define SDPOWER -1</front>
<front id="pinsH-275">#define SDSS -1 // SCL pin of I2C header</front>
<front id="pinsH-276">#define LED_PIN -1</front>
<front id="pinsH-277"></front>
<front id="pinsH-278">#define FAN_PIN -1</front>
<front id="pinsH-279"></front>
<front id="pinsH-280">#define PS_ON_PIN 15</front>
<front id="pinsH-281"></front>
<front id="pinsH-282">//our pin for debugging.</front>
<front id="pinsH-283">#define DEBUG_PIN 0</front>
<front id="pinsH-284"></front>
<front id="pinsH-285">//our RS485 pins</front>
<front id="pinsH-286">#define TX_ENABLE_PIN 12</front>
<front id="pinsH-287">#define RX_ENABLE_PIN 13</front>
<front id="pinsH-288"></front>
<front id="pinsH-289">#endif</front>
<front id="pinsH-290"></front>
<front id="pinsH-291">/*******************************************************************************</front>
<front id="pinsH-292">*********</front>
<front id="pinsH-293">* Gen7 Alfons3  pin assignment</front>
<front id="pinsH-294">*</front>
<front id="pinsH-295">********************************************************************************</front>
<front id="pinsH-296">********/</front>
<front id="pinsH-297">/* These Pins are assigned for the modified GEN7 Board from Alfons3 Please review the pins and adjust it for your needs*/</front>
<front id="pinsH-298"></front>
<front id="pinsH-299">#if MOTHERBOARD == 10</front>
<front id="pinsH-300">#define KNOWN_BOARD</front>
<front id="pinsH-301"></front>
<front id="pinsH-302">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pinsH-303">    #error Oops!  Make sure you have 'Gen7' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-304"></front>
<front id="pinsH-305">#endif</front>
<front id="pinsH-306"></front>
<front id="pinsH-307">//x axis pins</front>
<front id="pinsH-308">    #define X_STEP_PIN      21                  // different from standard GEN7</front>
<front id="pinsH-309">    #define X_DIR_PIN       20                  // different from standard GEN7</front>
<front id="pinsH-310">    #define X_ENABLE_PIN    24</front>
<front id="pinsH-311">    #define X_STOP_PIN      0</front>
<front id="pinsH-312"></front>
<front id="pinsH-313">    //y axis pins</front>
<front id="pinsH-314">    #define Y_STEP_PIN      23</front>
<front id="pinsH-315">    #define Y_DIR_PIN       22</front>
<front id="pinsH-316">    #define Y_ENABLE_PIN    24</front>
<front id="pinsH-317">    #define Y_STOP_PIN      1</front>
<front id="pinsH-318"></front>
<front id="pinsH-319">    //z axis pins</front>
<front id="pinsH-320">    #define Z_STEP_PIN      26</front>
<front id="pinsH-321">    #define Z_DIR_PIN       25</front>
<front id="pinsH-322">    #define Z_ENABLE_PIN    24</front>
<front id="pinsH-323">    #define Z_STOP_PIN      2</front>
<front id="pinsH-324"></front>
<front id="pinsH-325">    //extruder pins</front>
<front id="pinsH-326">    #define E0_STEP_PIN      28</front>
<front id="pinsH-327">    #define E0_DIR_PIN       27</front>
<front id="pinsH-328">    #define E0_ENABLE_PIN    24</front>
<front id="pinsH-329"></front>
<front id="pinsH-330">    #define TEMP_0_PIN      2</front>
<front id="pinsH-331">    #define TEMP_1_PIN      -1</front>
<front id="pinsH-332">    #define TEMP_2_PIN      -1</front>
<front id="pinsH-333">    #define TEMP_BED_PIN        1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)</front>
<front id="pinsH-334"></front>
<front id="pinsH-335">    #define HEATER_0_PIN    4</front>
<front id="pinsH-336">    #define HEATER_1_PIN    -1</front>
<front id="pinsH-337">    #define HEATER_2_PIN    -1</front>
<front id="pinsH-338">    #define HEATER_BED_PIN      3  // (bed)</front>
<front id="pinsH-339"></front>
<front id="pinsH-340">    #define SDPOWER         -1</front>
<front id="pinsH-341">    #define SDSS            31                  // SCL pin of I2C header || CS Pin for SD Card support</front>
<front id="pinsH-342">    #define LED_PIN         -1</front>
<front id="pinsH-343"></front>
<front id="pinsH-344">    #define FAN_PIN         -1</front>
<front id="pinsH-345">    #define PS_ON_PIN       19</front>
<front id="pinsH-346">    //our pin for debugging.</front>
<front id="pinsH-347"></front>
<front id="pinsH-348">    #define DEBUG_PIN        -1</front>
<front id="pinsH-349"></front>
<front id="pinsH-350">    //our RS485 pins</front>
<front id="pinsH-351">    //#define TX_ENABLE_PIN       12</front>
<front id="pinsH-352">    //#define RX_ENABLE_PIN       13</front>
<front id="pinsH-353"></front>
<front id="pinsH-354">    #define BEEPER -1</front>
<front id="pinsH-355">    #define SDCARDDETECT -1</front>
<front id="pinsH-356">    #define SUICIDE_PIN -1    //has to be defined; otherwise Power_off doesn't work</front>
<front id="pinsH-357"></front>
<front id="pinsH-358">    #define KILL_PIN -1</front>
<front id="pinsH-359">    //Pins for 4bit LCD Support</front>
<front id="pinsH-360">    #define LCD_PINS_RS 18</front>
<front id="pinsH-361">    #define LCD_PINS_ENABLE 17</front>
<front id="pinsH-362">    #define LCD_PINS_D4 16</front>
<front id="pinsH-363">    #define LCD_PINS_D5 15</front>
<front id="pinsH-364">    #define LCD_PINS_D6 13</front>
<front id="pinsH-365">    #define LCD_PINS_D7 14</front>
<front id="pinsH-366"></front>
<front id="pinsH-367">     //buttons are directly attached</front>
<front id="pinsH-368">    #define BTN_EN1 11</front>
<front id="pinsH-369">    #define BTN_EN2 10</front>
<front id="pinsH-370">    #define BTN_ENC 12  //the click</front>
<front id="pinsH-371"></front>
<front id="pinsH-372">#endif</front>
<front id="pinsH-373"></front>
<front id="pinsH-374">/****************************************************************************************</front>
<front id="pinsH-375">* Arduino Mega pin assignment</front>
<front id="pinsH-376">*</front>
<front id="pinsH-377">****************************************************************************************/</front>
<front id="pinsH-378">#if MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67</front>
<front id="pinsH-379">#define KNOWN_BOARD 1</front>
<front id="pinsH-380"></front>
<front id="pinsH-381">//////////////////FIX THIS//////////////</front>
<front id="pinsH-382">#ifndef __AVR_ATmega1280__</front>
<front id="pinsH-383"> #ifndef __AVR_ATmega2560__</front>
<front id="pinsH-384"> #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-385"> #endif</front>
<front id="pinsH-386">#endif</front>
<front id="pinsH-387"></front>
<front id="pinsH-388"></front>
<front id="pinsH-389">// uncomment one of the following lines for RAMPS v1.3 or v1.0, comment both for v1.2 or 1.1</front>
<front id="pinsH-390">// #define RAMPS_V_1_3</front>
<front id="pinsH-391">// #define RAMPS_V_1_0</front>
<front id="pinsH-392"></front>
<front id="pinsH-393"></front>
<front id="pinsH-394">#if MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77 || MOTHERBOARD == 67</front>
<front id="pinsH-395"></front>
<front id="pinsH-396">  #define LARGE_FLASH true</front>
<front id="pinsH-397">  </front>
<front id="pinsH-398">  #if MOTHERBOARD == 77</front>
<front id="pinsH-399">    #define X_STEP_PIN         54</front>
<front id="pinsH-400">    #define X_DIR_PIN          55</front>
<front id="pinsH-401">    #define X_ENABLE_PIN       38</front>
<front id="pinsH-402">    #define X_MIN_PIN           3</front>
<front id="pinsH-403">    #define X_MAX_PIN           -1   //2 //Max endstops default to disabled "-1", set to commented value to enable.</front>
<front id="pinsH-404"></front>
<front id="pinsH-405">    #define Y_STEP_PIN         60</front>
<front id="pinsH-406">    #define Y_DIR_PIN          61</front>
<front id="pinsH-407">    #define Y_ENABLE_PIN       56</front>
<front id="pinsH-408">    #define Y_MIN_PIN          14</front>
<front id="pinsH-409">    #define Y_MAX_PIN          -1   //15</front>
<front id="pinsH-410"></front>
<front id="pinsH-411">    #define Z_STEP_PIN         46</front>
<front id="pinsH-412">    #define Z_DIR_PIN          48</front>
<front id="pinsH-413">    #define Z_ENABLE_PIN       63</front>
<front id="pinsH-414">    #define Z_MIN_PIN          18</front>
<front id="pinsH-415">    #define Z_MAX_PIN          -1</front>
<front id="pinsH-416"></front>
<front id="pinsH-417">    #define Z2_STEP_PIN        36</front>
<front id="pinsH-418">    #define Z2_DIR_PIN         34</front>
<front id="pinsH-419">    #define Z2_ENABLE_PIN      30</front>
<front id="pinsH-420"></front>
<front id="pinsH-421">    #define E0_STEP_PIN        26</front>
<front id="pinsH-422">    #define E0_DIR_PIN         28</front>
<front id="pinsH-423">    #define E0_ENABLE_PIN      24</front>
<front id="pinsH-424"></front>
<front id="pinsH-425">    #define E1_STEP_PIN        36</front>
<front id="pinsH-426">    #define E1_DIR_PIN         34</front>
<front id="pinsH-427">    #define E1_ENABLE_PIN      30</front>
<front id="pinsH-428"></front>
<front id="pinsH-429">    #define SDPOWER            -1</front>
<front id="pinsH-430">    #define SDSS               25//53</front>
<front id="pinsH-431">    #define LED_PIN            13</front>
<front id="pinsH-432"></front>
<front id="pinsH-433">    #define BEEPER             33    </front>
<front id="pinsH-434"></front>
<front id="pinsH-435">  #else</front>
<front id="pinsH-436"></front>
<front id="pinsH-437">    #define X_STEP_PIN         54</front>
<front id="pinsH-438">    #define X_DIR_PIN          55</front>
<front id="pinsH-439">    #define X_ENABLE_PIN       38</front>
<front id="pinsH-440">    #define X_MIN_PIN           3</front>
<front id="pinsH-441">    #define X_MAX_PIN           2</front>
<front id="pinsH-442"></front>
<front id="pinsH-443">    #define Y_STEP_PIN         60</front>
<front id="pinsH-444">    #define Y_DIR_PIN          61</front>
<front id="pinsH-445">    #define Y_ENABLE_PIN       56</front>
<front id="pinsH-446">    #define Y_MIN_PIN          14</front>
<front id="pinsH-447">    #define Y_MAX_PIN          15</front>
<front id="pinsH-448"></front>
<front id="pinsH-449">    #define Z_STEP_PIN         46</front>
<front id="pinsH-450">    #define Z_DIR_PIN          48</front>
<front id="pinsH-451">    #define Z_ENABLE_PIN       62</front>
<front id="pinsH-452">    #define Z_MIN_PIN          18</front>
<front id="pinsH-453">    #define Z_MAX_PIN          19</front>
<front id="pinsH-454"></front>
<front id="pinsH-455">    #define Z2_STEP_PIN        36</front>
<front id="pinsH-456">    #define Z2_DIR_PIN         34</front>
<front id="pinsH-457">    #define Z2_ENABLE_PIN      30</front>
<front id="pinsH-458"></front>
<front id="pinsH-459">    #define E0_STEP_PIN        26</front>
<front id="pinsH-460">    #define E0_DIR_PIN         28</front>
<front id="pinsH-461">    #define E0_ENABLE_PIN      24</front>
<front id="pinsH-462"></front>
<front id="pinsH-463">    #define E1_STEP_PIN        36</front>
<front id="pinsH-464">    #define E1_DIR_PIN         34</front>
<front id="pinsH-465">    #define E1_ENABLE_PIN      30</front>
<front id="pinsH-466"></front>
<front id="pinsH-467">    #define SDPOWER            -1</front>
<front id="pinsH-468">    #define SDSS               53</front>
<front id="pinsH-469">    #define LED_PIN            13</front>
<front id="pinsH-470">  #endif</front>
<front id="pinsH-471"></front>
<front id="pinsH-472">  #if MOTHERBOARD == 33 || MOTHERBOARD == 35 || MOTHERBOARD == 67</front>
<front id="pinsH-473">    #define FAN_PIN            9 // (Sprinter config)</front>
<front id="pinsH-474">  #else</front>
<front id="pinsH-475">    #define FAN_PIN            4 // IO pin. Buffer needed</front>
<front id="pinsH-476">  #endif</front>
<front id="pinsH-477"></front>
<front id="pinsH-478">  #if MOTHERBOARD == 77</front>
<front id="pinsH-479">    #define FAN_PIN            8 </front>
<front id="pinsH-480">  #endif</front>
<front id="pinsH-481">  </front>
<front id="pinsH-482">  #if MOTHERBOARD == 35</front>
<front id="pinsH-483">    #define CONTROLLERFAN_PIN  10 //Pin used for the fan to cool controller</front>
<front id="pinsH-484">  #endif</front>
<front id="pinsH-485"></front>
<front id="pinsH-486">  #define PS_ON_PIN          12</front>
<front id="pinsH-487"></front>
<front id="pinsH-488">  #if defined(REPRAP_DISCOUNT_SMART_CONTROLLER) || defined(G3D_PANEL)</front>
<front id="pinsH-489">    #define KILL_PIN           41</front>
<front id="pinsH-490">  #else</front>
<front id="pinsH-491">    #define KILL_PIN           -1</front>
<front id="pinsH-492">  #endif</front>
<front id="pinsH-493"></front>
<front id="pinsH-494">  #if MOTHERBOARD == 35</front>
<front id="pinsH-495">    #define HEATER_0_PIN       8</front>
<front id="pinsH-496">  #else</front>
<front id="pinsH-497">    #define HEATER_0_PIN       10   // EXTRUDER 1</front>
<front id="pinsH-498">  #endif</front>
<front id="pinsH-499"></front>
<front id="pinsH-500">  #if MOTHERBOARD == 33 || MOTHERBOARD == 67</front>
<front id="pinsH-501">    #define HEATER_1_PIN       -1</front>
<front id="pinsH-502">  #else</front>
<front id="pinsH-503">    #define HEATER_1_PIN       9    // EXTRUDER 2 (FAN On Sprinter)</front>
<front id="pinsH-504">  #endif</front>
<front id="pinsH-505"></front>
<front id="pinsH-506">  #define HEATER_2_PIN       -1 </front>
<front id="pinsH-507"></front>
<front id="pinsH-508">  #if MOTHERBOARD == 77</front>
<front id="pinsH-509">    #define HEATER_0_PIN       10   </front>
<front id="pinsH-510">    #define HEATER_1_PIN       12 </front>
<front id="pinsH-511">    #define HEATER_2_PIN       6   </front>
<front id="pinsH-512">  #endif</front>
<front id="pinsH-513"></front>
<front id="pinsH-514">  #define TEMP_0_PIN         13   // ANALOG NUMBERING</front>
<front id="pinsH-515">  #define TEMP_1_PIN         15   // ANALOG NUMBERING</front>
<front id="pinsH-516">  #define TEMP_2_PIN         -1   // ANALOG NUMBERING</front>
<front id="pinsH-517"></front>
<front id="pinsH-518">  #if MOTHERBOARD == 35</front>
<front id="pinsH-519">    #define HEATER_BED_PIN     -1    // NO BED</front>
<front id="pinsH-520">  #else</front>
<front id="pinsH-521">    #if MOTHERBOARD == 77</front>
<front id="pinsH-522">      #define HEATER_BED_PIN     9    // BED</front>
<front id="pinsH-523">    #else</front>
<front id="pinsH-524">      #define HEATER_BED_PIN     8    // BED</front>
<front id="pinsH-525">    #endif</front>
<front id="pinsH-526">  #endif</front>
<front id="pinsH-527">  #define TEMP_BED_PIN       14   // ANALOG NUMBERING</front>
<front id="pinsH-528"></front>
<front id="pinsH-529"></front>
<front id="pinsH-530"></front>
<front id="pinsH-531">  #ifdef NUM_SERVOS</front>
<front id="pinsH-532">    #define SERVO0_PIN         11</front>
<front id="pinsH-533"></front>
<front id="pinsH-534">    #if NUM_SERVOS &gt; 1</front>
<front id="pinsH-535">      #define SERVO1_PIN         6</front>
<front id="pinsH-536">    #endif</front>
<front id="pinsH-537"></front>
<front id="pinsH-538">    #if NUM_SERVOS &gt; 2</front>
<front id="pinsH-539">      #define SERVO2_PIN         5</front>
<front id="pinsH-540">    #endif</front>
<front id="pinsH-541"></front>
<front id="pinsH-542">    #if NUM_SERVOS &gt; 3</front>
<front id="pinsH-543">      #define SERVO3_PIN         4</front>
<front id="pinsH-544">    #endif</front>
<front id="pinsH-545">  #endif</front>
<front id="pinsH-546"></front>
<front id="pinsH-547">  #ifdef ULTRA_LCD</front>
<front id="pinsH-548"></front>
<front id="pinsH-549">    #ifdef NEWPANEL</front>
<front id="pinsH-550">      #define LCD_PINS_RS 16 </front>
<front id="pinsH-551">      #define LCD_PINS_ENABLE 17</front>
<front id="pinsH-552">      #define LCD_PINS_D4 23</front>
<front id="pinsH-553">      #define LCD_PINS_D5 25 </front>
<front id="pinsH-554">      #define LCD_PINS_D6 27</front>
<front id="pinsH-555">      #define LCD_PINS_D7 29</front>
<front id="pinsH-556"></front>
<front id="pinsH-557">      #ifdef REPRAP_DISCOUNT_SMART_CONTROLLER</front>
<front id="pinsH-558">        #define BEEPER 37</front>
<front id="pinsH-559"></front>
<front id="pinsH-560">        #define BTN_EN1 31</front>
<front id="pinsH-561">        #define BTN_EN2 33</front>
<front id="pinsH-562">        #define BTN_ENC 35</front>
<front id="pinsH-563"></front>
<front id="pinsH-564">        #define SDCARDDETECT 49</front>
<front id="pinsH-565">      #elif defined(LCD_I2C_PANELOLU2)</front>
<front id="pinsH-566">        #define BTN_EN1 47  //reverse if the encoder turns the wrong way.</front>
<front id="pinsH-567">        #define BTN_EN2 43</front>
<front id="pinsH-568">        #define BTN_ENC 32</front>
<front id="pinsH-569">        #define SDSS 53</front>
<front id="pinsH-570">        #define SDCARDDETECT -1</front>
<front id="pinsH-571">        #define KILL_PIN 41</front>
<front id="pinsH-572">      #elif defined(LCD_I2C_VIKI)</front>
<front id="pinsH-573">        #define BTN_EN1 22  //reverse if the encoder turns the wrong way.</front>
<front id="pinsH-574">        #define BTN_EN2 7</front>
<front id="pinsH-575">        #define BTN_ENC -1</front>
<front id="pinsH-576">        #define SDSS 53</front>
<front id="pinsH-577">        #define SDCARDDETECT 49</front>
<front id="pinsH-578">      #else</front>
<front id="pinsH-579">        //arduino pin which triggers an piezzo beeper</front>
<front id="pinsH-580">        #define BEEPER 33  // Beeper on AUX-4</front>
<front id="pinsH-581"></front>
<front id="pinsH-582">        //buttons are directly attached using AUX-2</front>
<front id="pinsH-583">        #ifdef REPRAPWORLD_KEYPAD</front>
<front id="pinsH-584">          #define BTN_EN1 64 // encoder</front>
<front id="pinsH-585">          #define BTN_EN2 59 // encoder</front>
<front id="pinsH-586">          #define BTN_ENC 63 // enter button</front>
<front id="pinsH-587">          #define SHIFT_OUT 40 // shift register</front>
<front id="pinsH-588">          #define SHIFT_CLK 44 // shift register</front>
<front id="pinsH-589">          #define SHIFT_LD 42 // shift register</front>
<front id="pinsH-590">        #else</front>
<front id="pinsH-591">          #define BTN_EN1 37</front>
<front id="pinsH-592">          #define BTN_EN2 35</front>
<front id="pinsH-593">          #define BTN_ENC 31  //the click</front>
<front id="pinsH-594">        #endif</front>
<front id="pinsH-595"></front>
<front id="pinsH-596">        #ifdef G3D_PANEL</front>
<front id="pinsH-597">          #define SDCARDDETECT 49</front>
<front id="pinsH-598">        #else</front>
<front id="pinsH-599">          #define SDCARDDETECT -1  // Ramps does not use this port</front>
<front id="pinsH-600">        #endif</front>
<front id="pinsH-601">    </front>
<front id="pinsH-602">      #endif</front>
<front id="pinsH-603">    </front>
<front id="pinsH-604">      #if MOTHERBOARD == 77 </front>
<front id="pinsH-605">        #define BEEPER -1 </front>
<front id="pinsH-606"></front>
<front id="pinsH-607">        #define LCD_PINS_RS 27 </front>
<front id="pinsH-608">        #define LCD_PINS_ENABLE 29 </front>
<front id="pinsH-609">        #define LCD_PINS_D4 37 </front>
<front id="pinsH-610">        #define LCD_PINS_D5 35 </front>
<front id="pinsH-611">        #define LCD_PINS_D6 33 </front>
<front id="pinsH-612">        #define LCD_PINS_D7 31 </front>
<front id="pinsH-613"></front>
<front id="pinsH-614">       //buttons </front>
<front id="pinsH-615">       #define BTN_EN1 16 </front>
<front id="pinsH-616">       #define BTN_EN2 17 </front>
<front id="pinsH-617">       #define BTN_ENC 23 //the click </front>
<front id="pinsH-618"></front>
<front id="pinsH-619">    #endif </front>
<front id="pinsH-620">    #else //old style panel with shift register</front>
<front id="pinsH-621">      //arduino pin witch triggers an piezzo beeper</front>
<front id="pinsH-622">      #define BEEPER 33		//No Beeper added</front>
<front id="pinsH-623"></front>
<front id="pinsH-624">      //buttons are attached to a shift register</front>
<front id="pinsH-625">	// Not wired this yet</front>
<front id="pinsH-626">      //#define SHIFT_CLK 38</front>
<front id="pinsH-627">      //#define SHIFT_LD 42</front>
<front id="pinsH-628">      //#define SHIFT_OUT 40</front>
<front id="pinsH-629">      //#define SHIFT_EN 17</front>
<front id="pinsH-630">    </front>
<front id="pinsH-631">      #define LCD_PINS_RS 16 </front>
<front id="pinsH-632">      #define LCD_PINS_ENABLE 17</front>
<front id="pinsH-633">      #define LCD_PINS_D4 23</front>
<front id="pinsH-634">      #define LCD_PINS_D5 25 </front>
<front id="pinsH-635">      #define LCD_PINS_D6 27</front>
<front id="pinsH-636">      #define LCD_PINS_D7 29</front>
<front id="pinsH-637">    #endif </front>
<front id="pinsH-638">  #endif //ULTRA_LCD</front>
<front id="pinsH-639"></front>
<front id="pinsH-640">#else // RAMPS_V_1_1 or RAMPS_V_1_2 as default (MOTHERBOARD == 3)</front>
<front id="pinsH-641"></front>
<front id="pinsH-642">#define X_STEP_PIN         26</front>
<front id="pinsH-643">#define X_DIR_PIN          28</front>
<front id="pinsH-644">#define X_ENABLE_PIN       24</front>
<front id="pinsH-645">#define X_MIN_PIN           3</front>
<front id="pinsH-646">#define X_MAX_PIN          -1    //2</front>
<front id="pinsH-647"></front>
<front id="pinsH-648">#define Y_STEP_PIN         38</front>
<front id="pinsH-649">#define Y_DIR_PIN          40</front>
<front id="pinsH-650">#define Y_ENABLE_PIN       36</front>
<front id="pinsH-651">#define Y_MIN_PIN          16</front>
<front id="pinsH-652">#define Y_MAX_PIN          -1    //17</front>
<front id="pinsH-653"></front>
<front id="pinsH-654">#define Z_STEP_PIN         44</front>
<front id="pinsH-655">#define Z_DIR_PIN          46</front>
<front id="pinsH-656">#define Z_ENABLE_PIN       42</front>
<front id="pinsH-657">#define Z_MIN_PIN          18</front>
<front id="pinsH-658">#define Z_MAX_PIN          -1    //19</front>
<front id="pinsH-659"></front>
<front id="pinsH-660">#define E0_STEP_PIN         32</front>
<front id="pinsH-661">#define E0_DIR_PIN          34</front>
<front id="pinsH-662">#define E0_ENABLE_PIN       30</front>
<front id="pinsH-663"></front>
<front id="pinsH-664">#define SDPOWER            48</front>
<front id="pinsH-665">#define SDSS               53</front>
<front id="pinsH-666">#define LED_PIN            13</front>
<front id="pinsH-667">#define PS_ON_PIN          -1</front>
<front id="pinsH-668">#define KILL_PIN           -1</front>
<front id="pinsH-669"></front>
<front id="pinsH-670">#ifdef RAMPS_V_1_0 // RAMPS_V_1_0</front>
<front id="pinsH-671">  #define HEATER_0_PIN     12    // RAMPS 1.0</front>
<front id="pinsH-672">  #define HEATER_BED_PIN   -1    // RAMPS 1.0</front>
<front id="pinsH-673">  #define FAN_PIN          11    // RAMPS 1.0</front>
<front id="pinsH-674">#else // RAMPS_V_1_1 or RAMPS_V_1_2</front>
<front id="pinsH-675">  #define HEATER_0_PIN     10    // RAMPS 1.1</front>
<front id="pinsH-676">  #define HEATER_BED_PIN    8    // RAMPS 1.1</front>
<front id="pinsH-677">  #define FAN_PIN           9    // RAMPS 1.1</front>
<front id="pinsH-678">#endif</front>
<front id="pinsH-679">#define HEATER_1_PIN        -1</front>
<front id="pinsH-680">#define HEATER_2_PIN        -1</front>
<front id="pinsH-681">#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-682">#define TEMP_1_PIN          -1   </front>
<front id="pinsH-683">#define TEMP_2_PIN          -1   </front>
<front id="pinsH-684">#define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-685"></front>
<front id="pinsH-686">#endif // MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77</front>
<front id="pinsH-687"></front>
<front id="pinsH-688">// SPI for Max6675 Thermocouple </front>
<front id="pinsH-689"></front>
<front id="pinsH-690">#ifndef SDSUPPORT</front>
<front id="pinsH-691">// these pins are defined in the SD library if building with SD support  </front>
<front id="pinsH-692">  #define MAX_SCK_PIN          52</front>
<front id="pinsH-693">  #define MAX_MISO_PIN         50</front>
<front id="pinsH-694">  #define MAX_MOSI_PIN         51</front>
<front id="pinsH-695">  #define MAX6675_SS       53</front>
<front id="pinsH-696">#else</front>
<front id="pinsH-697">  #define MAX6675_SS       49</front>
<front id="pinsH-698">#endif</front>
<front id="pinsH-699"></front>
<front id="pinsH-700">#endif //MOTHERBOARD == 3 || MOTHERBOARD == 33 || MOTHERBOARD == 34 || MOTHERBOARD == 35 || MOTHERBOARD == 77</front>
<front id="pinsH-701"></front>
<front id="pinsH-702">/****************************************************************************************</front>
<front id="pinsH-703">* Duemilanove w/ ATMega328P pin assignment</front>
<front id="pinsH-704">*</front>
<front id="pinsH-705">****************************************************************************************/</front>
<front id="pinsH-706">#if MOTHERBOARD == 4</front>
<front id="pinsH-707">#define KNOWN_BOARD 1</front>
<front id="pinsH-708"></front>
<front id="pinsH-709">#ifndef __AVR_ATmega328P__</front>
<front id="pinsH-710">#error Oops!  Make sure you have 'Arduino Duemilanove w/ ATMega328' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-711">#endif</front>
<front id="pinsH-712"></front>
<front id="pinsH-713">#define X_STEP_PIN         19</front>
<front id="pinsH-714">#define X_DIR_PIN          18</front>
<front id="pinsH-715">#define X_ENABLE_PIN       -1</front>
<front id="pinsH-716">#define X_STOP_PIN         17</front>
<front id="pinsH-717"></front>
<front id="pinsH-718">#define Y_STEP_PIN         10</front>
<front id="pinsH-719">#define Y_DIR_PIN           7</front>
<front id="pinsH-720">#define Y_ENABLE_PIN       -1</front>
<front id="pinsH-721">#define Y_STOP_PIN          8</front>
<front id="pinsH-722"></front>
<front id="pinsH-723">#define Z_STEP_PIN         13</front>
<front id="pinsH-724">#define Z_DIR_PIN           3</front>
<front id="pinsH-725">#define Z_ENABLE_PIN        2</front>
<front id="pinsH-726">#define Z_STOP_PIN          4</front>
<front id="pinsH-727"></front>
<front id="pinsH-728">#define E0_STEP_PIN         11</front>
<front id="pinsH-729">#define E0_DIR_PIN          12</front>
<front id="pinsH-730">#define E0_ENABLE_PIN       -1</front>
<front id="pinsH-731"></front>
<front id="pinsH-732">#define SDPOWER          -1</front>
<front id="pinsH-733">#define SDSS          -1</front>
<front id="pinsH-734">#define LED_PIN            -1</front>
<front id="pinsH-735">#define FAN_PIN             5</front>
<front id="pinsH-736">#define PS_ON_PIN          -1</front>
<front id="pinsH-737">#define KILL_PIN           -1</front>
<front id="pinsH-738"></front>
<front id="pinsH-739">#define HEATER_0_PIN        6</front>
<front id="pinsH-740">#define HEATER_1_PIN        -1</front>
<front id="pinsH-741">#define HEATER_2_PIN        -1</front>
<front id="pinsH-742">#define TEMP_0_PIN          0    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-743">#define TEMP_1_PIN          -1</front>
<front id="pinsH-744">#define TEMP_2_PIN          -1</front>
<front id="pinsH-745">#define HEATER_BED_PIN      -1</front>
<front id="pinsH-746">#define TEMP_BED_PIN        -1</front>
<front id="pinsH-747"></front>
<front id="pinsH-748">#endif</front>
<front id="pinsH-749"></front>
<front id="pinsH-750">/****************************************************************************************</front>
<front id="pinsH-751">* Elefu RA Board Pin Assignments</front>
<front id="pinsH-752">*</front>
<front id="pinsH-753">****************************************************************************************/</front>
<front id="pinsH-754">#if MOTHERBOARD == 21</front>
<front id="pinsH-755">#define	KNOWN_BOARD 1</front>
<front id="pinsH-756"></front>
<front id="pinsH-757">#ifndef __AVR_ATmega2560__</front>
<front id="pinsH-758"> #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-759">#endif</front>
<front id="pinsH-760"></front>
<front id="pinsH-761"></front>
<front id="pinsH-762">#define X_STEP_PIN		     49</front>
<front id="pinsH-763">#define X_DIR_PIN			     13</front>
<front id="pinsH-764">#define X_ENABLE_PIN		   48</front>
<front id="pinsH-765">#define X_MIN_PIN			     35</front>
<front id="pinsH-766">#define X_MAX_PIN			     -1 //34</front>
<front id="pinsH-767"></front>
<front id="pinsH-768">#define Y_STEP_PIN         11</front>
<front id="pinsH-769">#define Y_DIR_PIN          9</front>
<front id="pinsH-770">#define Y_ENABLE_PIN       12</front>
<front id="pinsH-771">#define Y_MIN_PIN          33</front>
<front id="pinsH-772">#define Y_MAX_PIN          -1 //32</front>
<front id="pinsH-773"></front>
<front id="pinsH-774">#define Z_STEP_PIN         7</front>
<front id="pinsH-775">#define Z_DIR_PIN          6</front>
<front id="pinsH-776">#define Z_ENABLE_PIN       8</front>
<front id="pinsH-777">#define Z_MIN_PIN          31</front>
<front id="pinsH-778">#define Z_MAX_PIN          -1 //30</front>
<front id="pinsH-779"></front>
<front id="pinsH-780">#define E2_STEP_PIN        43</front>
<front id="pinsH-781">#define E2_DIR_PIN         47</front>
<front id="pinsH-782">#define E2_ENABLE_PIN      42</front>
<front id="pinsH-783"></front>
<front id="pinsH-784">#define E1_STEP_PIN        18</front>
<front id="pinsH-785">#define E1_DIR_PIN         19</front>
<front id="pinsH-786">#define E1_ENABLE_PIN      38</front>
<front id="pinsH-787"></front>
<front id="pinsH-788">#define E0_STEP_PIN        40</front>
<front id="pinsH-789">#define E0_DIR_PIN         41</front>
<front id="pinsH-790">#define E0_ENABLE_PIN      37</front>
<front id="pinsH-791"></front>
<front id="pinsH-792">#define SDPOWER            -1</front>
<front id="pinsH-793">#define LED_PIN            -1 //Use +12V Aux port for LED Ring</front>
<front id="pinsH-794"></front>
<front id="pinsH-795">#define FAN_PIN            16 //5V PWM</front>
<front id="pinsH-796"></front>
<front id="pinsH-797">#define PS_ON_PIN          10 //Set to -1 if using a manual switch on the PWRSW Connector</front>
<front id="pinsH-798">#define SLEEP_WAKE_PIN		 26 //This feature still needs work</front>
<front id="pinsH-799"></front>
<front id="pinsH-800">#define HEATER_0_PIN       45	//12V PWM1</front>
<front id="pinsH-801">#define HEATER_1_PIN       46	//12V PWM2</front>
<front id="pinsH-802">#define HEATER_2_PIN       17	//12V PWM3</front>
<front id="pinsH-803">#define HEATER_BED_PIN     44	//DOUBLE 12V PWM</front>
<front id="pinsH-804">#define TEMP_0_PIN         3	//ANALOG NUMBERING</front>
<front id="pinsH-805">#define TEMP_1_PIN         2 	//ANALOG NUMBERING</front>
<front id="pinsH-806">#define TEMP_2_PIN         1 	//ANALOG NUMBERING</front>
<front id="pinsH-807">#define TEMP_BED_PIN       0	//ANALOG NUMBERING</front>
<front id="pinsH-808"></front>
<front id="pinsH-809">#define BEEPER 		         36</front>
<front id="pinsH-810"></front>
<front id="pinsH-811">#define KILL_PIN           -1</front>
<front id="pinsH-812"></front>
<front id="pinsH-813">// M240  Triggers a camera by emulating a Canon RC-1 Remote</front>
<front id="pinsH-814">// Data from: http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="pinsH-815">#define PHOTOGRAPH_PIN     29</front>
<front id="pinsH-816"></front>
<front id="pinsH-817">#ifdef RA_CONTROL_PANEL</front>
<front id="pinsH-818"></front>
<front id="pinsH-819">  #define SDSS             53</front>
<front id="pinsH-820">  #define SDCARDDETECT     28</front>
<front id="pinsH-821"></front>
<front id="pinsH-822">  #define BTN_EN1          14</front>
<front id="pinsH-823">  #define BTN_EN2          39</front>
<front id="pinsH-824">  #define BTN_ENC          15  //the click</front>
<front id="pinsH-825">    </front>
<front id="pinsH-826">  #define BLEN_C           2</front>
<front id="pinsH-827">  #define BLEN_B           1</front>
<front id="pinsH-828">  #define BLEN_A           0</front>
<front id="pinsH-829">    </front>
<front id="pinsH-830">  //encoder rotation values</front>
<front id="pinsH-831">  #define encrot0          0</front>
<front id="pinsH-832">  #define encrot1          2</front>
<front id="pinsH-833">  #define encrot2          3</front>
<front id="pinsH-834">  #define encrot3          1</front>
<front id="pinsH-835">  </front>
<front id="pinsH-836">#endif //RA_CONTROL_PANEL</front>
<front id="pinsH-837"></front>
<front id="pinsH-838">#ifdef RA_DISCO</front>
<front id="pinsH-839">  //variables for which pins the TLC5947 is using</front>
<front id="pinsH-840">  #define TLC_CLOCK_PIN    25</front>
<front id="pinsH-841">  #define TLC_BLANK_PIN    23</front>
<front id="pinsH-842">  #define TLC_XLAT_PIN     22</front>
<front id="pinsH-843">  #define TLC_DATA_PIN     24</front>
<front id="pinsH-844"></front>
<front id="pinsH-845">  //We also need to define pin to port number mapping for the 2560 to match the pins listed above. If you change the TLC pins, update this as well per the 2560 datasheet!</front>
<front id="pinsH-846">  //This currently only works with the RA Board.</front>
<front id="pinsH-847">  #define TLC_CLOCK_BIT 3 //bit 3 on port A</front>
<front id="pinsH-848">  #define TLC_CLOCK_PORT &PORTA //bit 3 on port A</front>
<front id="pinsH-849">  </front>
<front id="pinsH-850">  #define TLC_BLANK_BIT 1 //bit 1 on port A</front>
<front id="pinsH-851">  #define TLC_BLANK_PORT &PORTA //bit 1 on port A</front>
<front id="pinsH-852"></front>
<front id="pinsH-853">  #define TLC_DATA_BIT 2 //bit 2 on port A</front>
<front id="pinsH-854">  #define TLC_DATA_PORT &PORTA //bit 2 on port A</front>
<front id="pinsH-855"></front>
<front id="pinsH-856">  #define TLC_XLAT_BIT 0 //bit 0 on port A</front>
<front id="pinsH-857">  #define TLC_XLAT_PORT &PORTA //bit 0 on port A</front>
<front id="pinsH-858"></front>
<front id="pinsH-859">  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful </front>
<front id="pinsH-860">  //Leave it at at least 1 if you have enabled RA_LIGHTING</front>
<front id="pinsH-861">  //The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.</front>
<front id="pinsH-862">  #define NUM_TLCS 2 </front>
<front id="pinsH-863"></front>
<front id="pinsH-864">  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions. </front>
<front id="pinsH-865">  //Modify them according to your specific situation.</front>
<front id="pinsH-866">  //NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.</front>
<front id="pinsH-867">  #define TRANS_ARRAY {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8} //forwards</front>
<front id="pinsH-868">  //#define TRANS_ARRAY {7, 6, 5, 4, 3, 2, 1, 0, 8, 9, 10, 11, 12, 13, 14, 15} //backwards</front>
<front id="pinsH-869">#endif //RA_LIGHTING</front>
<front id="pinsH-870"></front>
<front id="pinsH-871"></front>
<front id="pinsH-872">#endif /* Ra Board */</front>
<front id="pinsH-873"></front>
<front id="pinsH-874"></front>
<front id="pinsH-875">/****************************************************************************************</front>
<front id="pinsH-876">* Gen6 pin assignment</front>
<front id="pinsH-877">*</front>
<front id="pinsH-878">****************************************************************************************/</front>
<front id="pinsH-879">#if MOTHERBOARD == 5 || MOTHERBOARD == 51</front>
<front id="pinsH-880">#define KNOWN_BOARD 1</front>
<front id="pinsH-881"></front>
<front id="pinsH-882">#ifndef __AVR_ATmega644P__</front>
<front id="pinsH-883">#ifndef __AVR_ATmega1284P__</front>
<front id="pinsH-884">#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-885">#endif</front>
<front id="pinsH-886">#endif</front>
<front id="pinsH-887"></front>
<front id="pinsH-888">//x axis pins</front>
<front id="pinsH-889">    #define X_STEP_PIN      15</front>
<front id="pinsH-890">    #define X_DIR_PIN       18</front>
<front id="pinsH-891">    #define X_ENABLE_PIN    19</front>
<front id="pinsH-892">    #define X_STOP_PIN      20</front>
<front id="pinsH-893"></front>
<front id="pinsH-894">    //y axis pins</front>
<front id="pinsH-895">    #define Y_STEP_PIN      23</front>
<front id="pinsH-896">    #define Y_DIR_PIN       22</front>
<front id="pinsH-897">    #define Y_ENABLE_PIN    24</front>
<front id="pinsH-898">    #define Y_STOP_PIN      25</front>
<front id="pinsH-899"></front>
<front id="pinsH-900">    //z axis pins</front>
<front id="pinsH-901">    #define Z_STEP_PIN      27</front>
<front id="pinsH-902">    #define Z_DIR_PIN       28</front>
<front id="pinsH-903">    #define Z_ENABLE_PIN    29</front>
<front id="pinsH-904">    #define Z_STOP_PIN      30</front>
<front id="pinsH-905"></front>
<front id="pinsH-906">    //extruder pins</front>
<front id="pinsH-907">    #define E0_STEP_PIN      4    //Edited @ EJE Electronics 20100715</front>
<front id="pinsH-908">    #define E0_DIR_PIN       2    //Edited @ EJE Electronics 20100715</front>
<front id="pinsH-909">    #define E0_ENABLE_PIN    3    //Added @ EJE Electronics 20100715</front>
<front id="pinsH-910">    #define TEMP_0_PIN      5     //changed @ rkoeppl 20110410</front>
<front id="pinsH-911">    #define TEMP_1_PIN      -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-912"></front>
<front id="pinsH-913"></front>
<front id="pinsH-914">    #define TEMP_2_PIN      -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-915">    #define HEATER_0_PIN    14    //changed @ rkoeppl 20110410</front>
<front id="pinsH-916">    #define HEATER_1_PIN    -1</front>
<front id="pinsH-917">    #define HEATER_2_PIN    -1</front>
<front id="pinsH-918">    #if MOTHERBOARD == 5</front>
<front id="pinsH-919">    #define HEATER_BED_PIN  -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-920">    #define TEMP_BED_PIN    -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-921">    #else</front>
<front id="pinsH-922">    #define HEATER_BED_PIN   1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-923">    #define TEMP_BED_PIN     0    //changed @ rkoeppl 20110410</front>
<front id="pinsH-924">    #endif</front>
<front id="pinsH-925">    #define SDPOWER          -1</front>
<front id="pinsH-926">    #define SDSS          17</front>
<front id="pinsH-927">    #define LED_PIN         -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-928">    #define FAN_PIN         -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-929">    #define PS_ON_PIN       -1    //changed @ rkoeppl 20110410</front>
<front id="pinsH-930">    #define KILL_PIN        -1    //changed @ drakelive 20120830</front>
<front id="pinsH-931">    //our pin for debugging.</front>
<front id="pinsH-932"></front>
<front id="pinsH-933">    #define DEBUG_PIN        0</front>
<front id="pinsH-934"></front>
<front id="pinsH-935">    //our RS485 pins</front>
<front id="pinsH-936">    #define TX_ENABLE_PIN 12</front>
<front id="pinsH-937">    #define RX_ENABLE_PIN 13</front>
<front id="pinsH-938"></front>
<front id="pinsH-939"></front>
<front id="pinsH-940">#endif</front>
<front id="pinsH-941"></front>
<front id="pinsH-942">/****************************************************************************************</front>
<front id="pinsH-943">* Sanguinololu pin assignment</front>
<front id="pinsH-944">*</front>
<front id="pinsH-945">****************************************************************************************/</front>
<front id="pinsH-946">#if MOTHERBOARD == 64</front>
<front id="pinsH-947">#define STB</front>
<front id="pinsH-948">#endif</front>
<front id="pinsH-949">#if MOTHERBOARD == 63 || MOTHERBOARD == 66</front>
<front id="pinsH-950">#define MELZI</front>
<front id="pinsH-951">#endif</front>
<front id="pinsH-952">#if MOTHERBOARD == 65</front>
<front id="pinsH-953">#define AZTEEG_X1</front>
<front id="pinsH-954">#endif</front>
<front id="pinsH-955">#if MOTHERBOARD == 62 || MOTHERBOARD == 63 || MOTHERBOARD == 64 || MOTHERBOARD == 65 || MOTHERBOARD == 66</front>
<front id="pinsH-956">#undef MOTHERBOARD</front>
<front id="pinsH-957">#define MOTHERBOARD 6</front>
<front id="pinsH-958">#define SANGUINOLOLU_V_1_2</front>
<front id="pinsH-959">#endif</front>
<front id="pinsH-960">#if MOTHERBOARD == 6</front>
<front id="pinsH-961">#define KNOWN_BOARD 1</front>
<front id="pinsH-962">#ifndef __AVR_ATmega644P__</front>
<front id="pinsH-963">#ifndef __AVR_ATmega1284P__</front>
<front id="pinsH-964">#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-965">#endif</front>
<front id="pinsH-966">#endif</front>
<front id="pinsH-967"></front>
<front id="pinsH-968">#define X_STEP_PIN         15</front>
<front id="pinsH-969">#define X_DIR_PIN          21</front>
<front id="pinsH-970">#define X_STOP_PIN         18</front>
<front id="pinsH-971"></front>
<front id="pinsH-972">#define Y_STEP_PIN         22</front>
<front id="pinsH-973">#define Y_DIR_PIN          23</front>
<front id="pinsH-974">#define Y_STOP_PIN         19</front>
<front id="pinsH-975"></front>
<front id="pinsH-976">#define Z_STEP_PIN         3</front>
<front id="pinsH-977">#define Z_DIR_PIN          2</front>
<front id="pinsH-978">#define Z_STOP_PIN         20</front>
<front id="pinsH-979"></front>
<front id="pinsH-980">#define E0_STEP_PIN         1</front>
<front id="pinsH-981">#define E0_DIR_PIN          0</front>
<front id="pinsH-982"></front>
<front id="pinsH-983">#define LED_PIN            -1</front>
<front id="pinsH-984"></front>
<front id="pinsH-985">#define FAN_PIN            -1</front>
<front id="pinsH-986"> #if FAN_PIN == 12 || FAN_PIN ==13</front>
<front id="pinsH-987">  #define FAN_SOFT_PWM</front>
<front id="pinsH-988">#endif</front>
<front id="pinsH-989"></front>
<front id="pinsH-990">#ifdef MELZI</front>
<front id="pinsH-991"> #define LED_PIN            27 /* On some broken versions of the Sanguino libraries the pin definitions are wrong, which then needs LED_PIN as pin 28. But you better upgrade your Sanguino libraries! See #368. */</front>
<front id="pinsH-992"> #define FAN_PIN            4 // Works for Panelolu2 too</front>
<front id="pinsH-993">#endif</front>
<front id="pinsH-994"></front>
<front id="pinsH-995">#ifdef STB</front>
<front id="pinsH-996"> #define FAN_PIN            4</front>
<front id="pinsH-997">	//  Uncomment this if you have the first generation (V1.10) of STBs board</front>
<front id="pinsH-998"> #define LCD_PIN_BL         17 // LCD backlight LED</front>
<front id="pinsH-999">#endif</front>
<front id="pinsH-1000"></front>
<front id="pinsH-1001">#ifdef AZTEEG_X1</front>
<front id="pinsH-1002"> #define FAN_PIN            4</front>
<front id="pinsH-1003">#endif</front>
<front id="pinsH-1004"></front>
<front id="pinsH-1005">#define PS_ON_PIN          -1</front>
<front id="pinsH-1006">#define KILL_PIN           -1</front>
<front id="pinsH-1007"></front>
<front id="pinsH-1008">#define HEATER_0_PIN       13 // (extruder)</front>
<front id="pinsH-1009">#define HEATER_1_PIN       -1</front>
<front id="pinsH-1010">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1011"></front>
<front id="pinsH-1012">#ifdef SANGUINOLOLU_V_1_2</front>
<front id="pinsH-1013"></front>
<front id="pinsH-1014"> #define HEATER_BED_PIN     12 // (bed)</front>
<front id="pinsH-1015"> #define X_ENABLE_PIN       14</front>
<front id="pinsH-1016"> #define Y_ENABLE_PIN       14</front>
<front id="pinsH-1017"> #define Z_ENABLE_PIN       26</front>
<front id="pinsH-1018"> #define E0_ENABLE_PIN      14</front>
<front id="pinsH-1019"></front>
<front id="pinsH-1020"> #ifdef LCD_I2C_PANELOLU2</front>
<front id="pinsH-1021">   #define FAN_PIN          4 // Uses Transistor1 (PWM) on Panelolu2's Sanguino Adapter Board to drive the fan</front>
<front id="pinsH-1022"> #endif</front>
<front id="pinsH-1023"></front>
<front id="pinsH-1024">#else</front>
<front id="pinsH-1025"></front>
<front id="pinsH-1026">#define HEATER_BED_PIN      14  // (bed)</front>
<front id="pinsH-1027">#define X_ENABLE_PIN       -1</front>
<front id="pinsH-1028">#define Y_ENABLE_PIN       -1</front>
<front id="pinsH-1029">#define Z_ENABLE_PIN       -1</front>
<front id="pinsH-1030">#define E0_ENABLE_PIN      -1</front>
<front id="pinsH-1031"></front>
<front id="pinsH-1032">#endif</front>
<front id="pinsH-1033"></front>
<front id="pinsH-1034">#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)</front>
<front id="pinsH-1035">#define TEMP_1_PIN         -1</front>
<front id="pinsH-1036">#define TEMP_2_PIN         -1</front>
<front id="pinsH-1037">#define TEMP_BED_PIN        6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)</front>
<front id="pinsH-1038">#define SDPOWER            -1</front>
<front id="pinsH-1039">#define SDSS               31</front>
<front id="pinsH-1040"></front>
<front id="pinsH-1041">/* On some broken versions of the Sanguino libraries the pin definitions are wrong, which then needs SDSS as pin 24. But you better upgrade your Sanguino libraries! See #368. */</front>
<front id="pinsH-1042">//#define SDSS               24</front>
<front id="pinsH-1043"></front>
<front id="pinsH-1044"> #ifdef ULTRA_LCD</front>
<front id="pinsH-1045">   #ifdef NEWPANEL</front>
<front id="pinsH-1046">     //we have no buzzer installed</front>
<front id="pinsH-1047">     #define BEEPER -1</front>
<front id="pinsH-1048">     //LCD Pins</front>
<front id="pinsH-1049">     #ifdef DOGLCD</front>
<front id="pinsH-1050">       // Pins for DOGM SPI LCD Support</front>
<front id="pinsH-1051">       #define DOGLCD_A0  30</front>
<front id="pinsH-1052">       #define DOGLCD_CS  29</front>
<front id="pinsH-1053">       // GLCD features</front>
<front id="pinsH-1054">       #define LCD_CONTRAST 1</front>
<front id="pinsH-1055">       // Uncomment screen orientation</front>
<front id="pinsH-1056">         // #define LCD_SCREEN_ROT_0</front>
<front id="pinsH-1057">         // #define LCD_SCREEN_ROT_90</front>
<front id="pinsH-1058">       #define LCD_SCREEN_ROT_180</front>
<front id="pinsH-1059">         // #define LCD_SCREEN_ROT_270</front>
<front id="pinsH-1060">       #else // standard Hitachi LCD controller</front>
<front id="pinsH-1061">       #define LCD_PINS_RS        4</front>
<front id="pinsH-1062">       #define LCD_PINS_ENABLE    17</front>
<front id="pinsH-1063">       #define LCD_PINS_D4        30</front>
<front id="pinsH-1064">       #define LCD_PINS_D5        29</front>
<front id="pinsH-1065">       #define LCD_PINS_D6        28</front>
<front id="pinsH-1066">       #define LCD_PINS_D7        27</front>
<front id="pinsH-1067">     #endif</front>
<front id="pinsH-1068">     //The encoder and click button</front>
<front id="pinsH-1069">     #define BTN_EN1 11  </front>
<front id="pinsH-1070">     #define BTN_EN2 10 </front>
<front id="pinsH-1071">     #ifdef LCD_I2C_PANELOLU2</front>
<front id="pinsH-1072">       #ifdef MELZI</front>
<front id="pinsH-1073">         #define BTN_ENC 29 //the click switch</front>
<front id="pinsH-1074">         #define SDSS 30 //to use the SD card reader on the Panelolu2 rather than the melzi board</front>
<front id="pinsH-1075">       #else</front>
<front id="pinsH-1076">         #define BTN_ENC 30 //the click switch</front>
<front id="pinsH-1077">       #endif</front>
<front id="pinsH-1078">     #else</front>
<front id="pinsH-1079">       #define BTN_ENC 16  //the click switch</front>
<front id="pinsH-1080">     #endif //Panelolu2</front>
<front id="pinsH-1081">     //not connected to a pin</front>
<front id="pinsH-1082">     #define SDCARDDETECT -1    </front>
<front id="pinsH-1083">    </front>
<front id="pinsH-1084">   #endif //Newpanel</front>
<front id="pinsH-1085"> #endif //Ultipanel</front>
<front id="pinsH-1086"></front>
<front id="pinsH-1087"> #ifdef MAKRPANEL</front>
<front id="pinsH-1088">     #define BEEPER 29</front>
<front id="pinsH-1089">     // Pins for DOGM SPI LCD Support</front>
<front id="pinsH-1090">     #define DOGLCD_A0  30</front>
<front id="pinsH-1091">     #define DOGLCD_CS  17</front>
<front id="pinsH-1092">     #define LCD_PIN_BL	28	// backlight LED on PA3</front>
<front id="pinsH-1093">     // GLCD features</front>
<front id="pinsH-1094">     #define LCD_CONTRAST 1</front>
<front id="pinsH-1095">     // Uncomment screen orientation</front>
<front id="pinsH-1096">     #define LCD_SCREEN_ROT_0</front>
<front id="pinsH-1097">       // #define LCD_SCREEN_ROT_90</front>
<front id="pinsH-1098">       // #define LCD_SCREEN_ROT_180</front>
<front id="pinsH-1099">       // #define LCD_SCREEN_ROT_270</front>
<front id="pinsH-1100">     //The encoder and click button</front>
<front id="pinsH-1101">     #define BTN_EN1 11</front>
<front id="pinsH-1102">     #define BTN_EN2 10</front>
<front id="pinsH-1103">     #define BTN_ENC 16  //the click switch</front>
<front id="pinsH-1104">     //not connected to a pin</front>
<front id="pinsH-1105">     #define SDCARDDETECT -1    </front>
<front id="pinsH-1106"> #endif //Makrpanel</front>
<front id="pinsH-1107"></front>
<front id="pinsH-1108">#endif</front>
<front id="pinsH-1109"></front>
<front id="pinsH-1110"></front>
<front id="pinsH-1111">#if MOTHERBOARD == 7</front>
<front id="pinsH-1112">#define KNOWN_BOARD</front>
<front id="pinsH-1113">/*****************************************************************</front>
<front id="pinsH-1114">* Ultimaker pin assignment</front>
<front id="pinsH-1115">******************************************************************/</front>
<front id="pinsH-1116"></front>
<front id="pinsH-1117">#ifndef __AVR_ATmega1280__</front>
<front id="pinsH-1118"> #ifndef __AVR_ATmega2560__</front>
<front id="pinsH-1119"> #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1120"> #endif</front>
<front id="pinsH-1121">#endif</front>
<front id="pinsH-1122"></front>
<front id="pinsH-1123">#define LARGE_FLASH true</front>
<front id="pinsH-1124"></front>
<front id="pinsH-1125">#define X_STEP_PIN 25</front>
<front id="pinsH-1126">#define X_DIR_PIN 23</front>
<front id="pinsH-1127">#define X_MIN_PIN 22</front>
<front id="pinsH-1128">#define X_MAX_PIN 24</front>
<front id="pinsH-1129">#define X_ENABLE_PIN 27</front>
<front id="pinsH-1130"></front>
<front id="pinsH-1131">#define Y_STEP_PIN 31</front>
<front id="pinsH-1132">#define Y_DIR_PIN 33</front>
<front id="pinsH-1133">#define Y_MIN_PIN 26</front>
<front id="pinsH-1134">#define Y_MAX_PIN 28</front>
<front id="pinsH-1135">#define Y_ENABLE_PIN 29</front>
<front id="pinsH-1136"></front>
<front id="pinsH-1137">#define Z_STEP_PIN 37</front>
<front id="pinsH-1138">#define Z_DIR_PIN 39</front>
<front id="pinsH-1139">#define Z_MIN_PIN 30</front>
<front id="pinsH-1140">#define Z_MAX_PIN 32</front>
<front id="pinsH-1141">#define Z_ENABLE_PIN 35</front>
<front id="pinsH-1142"></front>
<front id="pinsH-1143">#define HEATER_BED_PIN 4</front>
<front id="pinsH-1144">#define TEMP_BED_PIN 10</front>
<front id="pinsH-1145"></front>
<front id="pinsH-1146">#define HEATER_0_PIN  2</front>
<front id="pinsH-1147">#define TEMP_0_PIN 8</front>
<front id="pinsH-1148"></front>
<front id="pinsH-1149">#define HEATER_1_PIN 3</front>
<front id="pinsH-1150">#define TEMP_1_PIN 9</front>
<front id="pinsH-1151"></front>
<front id="pinsH-1152">#define HEATER_2_PIN -1</front>
<front id="pinsH-1153">#define TEMP_2_PIN -1</front>
<front id="pinsH-1154"></front>
<front id="pinsH-1155">#define E0_STEP_PIN         43</front>
<front id="pinsH-1156">#define E0_DIR_PIN          45</front>
<front id="pinsH-1157">#define E0_ENABLE_PIN       41</front>
<front id="pinsH-1158"></front>
<front id="pinsH-1159">#define E1_STEP_PIN         49</front>
<front id="pinsH-1160">#define E1_DIR_PIN          47</front>
<front id="pinsH-1161">#define E1_ENABLE_PIN       48</front>
<front id="pinsH-1162"></front>
<front id="pinsH-1163">#define SDPOWER            -1</front>
<front id="pinsH-1164">#define SDSS               53</front>
<front id="pinsH-1165">#define LED_PIN            13</front>
<front id="pinsH-1166">#define FAN_PIN            7</front>
<front id="pinsH-1167">#define PS_ON_PIN          12</front>
<front id="pinsH-1168">#define KILL_PIN           -1</front>
<front id="pinsH-1169">#define SUICIDE_PIN        54  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pinsH-1170"></front>
<front id="pinsH-1171">#ifdef ULTRA_LCD</front>
<front id="pinsH-1172"></front>
<front id="pinsH-1173">  #ifdef NEWPANEL</front>
<front id="pinsH-1174">  //arduino pin witch triggers an piezzo beeper</front>
<front id="pinsH-1175">    #define BEEPER 18</front>
<front id="pinsH-1176"></front>
<front id="pinsH-1177">    #define LCD_PINS_RS 20</front>
<front id="pinsH-1178">    #define LCD_PINS_ENABLE 17</front>
<front id="pinsH-1179">    #define LCD_PINS_D4 16</front>
<front id="pinsH-1180">    #define LCD_PINS_D5 21</front>
<front id="pinsH-1181">    #define LCD_PINS_D6 5</front>
<front id="pinsH-1182">    #define LCD_PINS_D7 6</front>
<front id="pinsH-1183"></front>
<front id="pinsH-1184">    //buttons are directly attached</front>
<front id="pinsH-1185">    #define BTN_EN1 40</front>
<front id="pinsH-1186">    #define BTN_EN2 42</front>
<front id="pinsH-1187">    #define BTN_ENC 19  //the click</front>
<front id="pinsH-1188">    </front>
<front id="pinsH-1189">    #define SDCARDDETECT 38</front>
<front id="pinsH-1190">    </front>
<front id="pinsH-1191">  #else //old style panel with shift register</front>
<front id="pinsH-1192">    //arduino pin witch triggers an piezzo beeper</front>
<front id="pinsH-1193">    #define BEEPER 18</front>
<front id="pinsH-1194"></front>
<front id="pinsH-1195">    //buttons are attached to a shift register</front>
<front id="pinsH-1196">    #define SHIFT_CLK 38</front>
<front id="pinsH-1197">    #define SHIFT_LD 42</front>
<front id="pinsH-1198">    #define SHIFT_OUT 40</front>
<front id="pinsH-1199">    #define SHIFT_EN 17</front>
<front id="pinsH-1200"></front>
<front id="pinsH-1201">    #define LCD_PINS_RS 16</front>
<front id="pinsH-1202">    #define LCD_PINS_ENABLE 5</front>
<front id="pinsH-1203">    #define LCD_PINS_D4 6</front>
<front id="pinsH-1204">    #define LCD_PINS_D5 21</front>
<front id="pinsH-1205">    #define LCD_PINS_D6 20</front>
<front id="pinsH-1206">    #define LCD_PINS_D7 19</front>
<front id="pinsH-1207">  </front>
<front id="pinsH-1208">    #define SDCARDDETECT -1</front>
<front id="pinsH-1209">  #endif </front>
<front id="pinsH-1210">#endif //ULTRA_LCD</front>
<front id="pinsH-1211"></front>
<front id="pinsH-1212">#endif</front>
<front id="pinsH-1213"></front>
<front id="pinsH-1214">#if MOTHERBOARD == 71</front>
<front id="pinsH-1215">#define KNOWN_BOARD</front>
<front id="pinsH-1216">/*****************************************************************</front>
<front id="pinsH-1217">* Ultimaker pin assignment (Old electronics)</front>
<front id="pinsH-1218">******************************************************************/</front>
<front id="pinsH-1219"></front>
<front id="pinsH-1220">#ifndef __AVR_ATmega1280__</front>
<front id="pinsH-1221"> #ifndef __AVR_ATmega2560__</front>
<front id="pinsH-1222"> #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1223"> #endif</front>
<front id="pinsH-1224">#endif</front>
<front id="pinsH-1225"></front>
<front id="pinsH-1226">#define LARGE_FLASH true</front>
<front id="pinsH-1227"></front>
<front id="pinsH-1228">#define X_STEP_PIN 25</front>
<front id="pinsH-1229">#define X_DIR_PIN 23</front>
<front id="pinsH-1230">#define X_MIN_PIN 15</front>
<front id="pinsH-1231">#define X_MAX_PIN 14</front>
<front id="pinsH-1232">#define X_ENABLE_PIN 27</front>
<front id="pinsH-1233"></front>
<front id="pinsH-1234">#define Y_STEP_PIN 31</front>
<front id="pinsH-1235">#define Y_DIR_PIN 33</front>
<front id="pinsH-1236">#define Y_MIN_PIN 17</front>
<front id="pinsH-1237">#define Y_MAX_PIN 16</front>
<front id="pinsH-1238">#define Y_ENABLE_PIN 29</front>
<front id="pinsH-1239"></front>
<front id="pinsH-1240">#define Z_STEP_PIN 37</front>
<front id="pinsH-1241">#define Z_DIR_PIN 39</front>
<front id="pinsH-1242">#define Z_MIN_PIN 19</front>
<front id="pinsH-1243">#define Z_MAX_PIN 18</front>
<front id="pinsH-1244">#define Z_ENABLE_PIN 35</front>
<front id="pinsH-1245"></front>
<front id="pinsH-1246">#define HEATER_BED_PIN -1</front>
<front id="pinsH-1247">#define TEMP_BED_PIN -1</front>
<front id="pinsH-1248"></front>
<front id="pinsH-1249">#define HEATER_0_PIN  2</front>
<front id="pinsH-1250">#define TEMP_0_PIN 8</front>
<front id="pinsH-1251"></front>
<front id="pinsH-1252">#define HEATER_1_PIN 1</front>
<front id="pinsH-1253">#define TEMP_1_PIN 1</front>
<front id="pinsH-1254"></front>
<front id="pinsH-1255">#define HEATER_2_PIN -1</front>
<front id="pinsH-1256">#define TEMP_2_PIN -1</front>
<front id="pinsH-1257"></front>
<front id="pinsH-1258">#define E0_STEP_PIN         43</front>
<front id="pinsH-1259">#define E0_DIR_PIN          45</front>
<front id="pinsH-1260">#define E0_ENABLE_PIN       41</front>
<front id="pinsH-1261"></front>
<front id="pinsH-1262">#define E1_STEP_PIN         -1</front>
<front id="pinsH-1263">#define E1_DIR_PIN          -1</front>
<front id="pinsH-1264">#define E1_ENABLE_PIN       -1</front>
<front id="pinsH-1265"></front>
<front id="pinsH-1266">#define SDPOWER            -1</front>
<front id="pinsH-1267">#define SDSS               -1</front>
<front id="pinsH-1268">#define LED_PIN            -1</front>
<front id="pinsH-1269">#define FAN_PIN            -1</front>
<front id="pinsH-1270">#define PS_ON_PIN          -1</front>
<front id="pinsH-1271">#define KILL_PIN           -1</front>
<front id="pinsH-1272">#define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pinsH-1273"></front>
<front id="pinsH-1274">#define LCD_PINS_RS 24</front>
<front id="pinsH-1275">#define LCD_PINS_ENABLE 22</front>
<front id="pinsH-1276">#define LCD_PINS_D4 36</front>
<front id="pinsH-1277">#define LCD_PINS_D5 34</front>
<front id="pinsH-1278">#define LCD_PINS_D6 32</front>
<front id="pinsH-1279">#define LCD_PINS_D7 30</front>
<front id="pinsH-1280"></front>
<front id="pinsH-1281">#endif</front>
<front id="pinsH-1282"></front>
<front id="pinsH-1283"></front>
<front id="pinsH-1284">/****************************************************************************************</front>
<front id="pinsH-1285">* RUMBA pin assignment</front>
<front id="pinsH-1286">*</front>
<front id="pinsH-1287">****************************************************************************************/</front>
<front id="pinsH-1288">#if MOTHERBOARD == 80</front>
<front id="pinsH-1289">#define KNOWN_BOARD 1</front>
<front id="pinsH-1290"></front>
<front id="pinsH-1291">#ifndef __AVR_ATmega2560__</front>
<front id="pinsH-1292"> #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1293">#endif</front>
<front id="pinsH-1294"></front>
<front id="pinsH-1295">#define X_STEP_PIN         17</front>
<front id="pinsH-1296">#define X_DIR_PIN          16</front>
<front id="pinsH-1297">#define X_ENABLE_PIN       48</front>
<front id="pinsH-1298">#define X_MIN_PIN          37</front>
<front id="pinsH-1299">#define X_MAX_PIN          36</front>
<front id="pinsH-1300"></front>
<front id="pinsH-1301">#define Y_STEP_PIN         54</front>
<front id="pinsH-1302">#define Y_DIR_PIN          47</front>
<front id="pinsH-1303">#define Y_ENABLE_PIN       55</front>
<front id="pinsH-1304">#define Y_MIN_PIN          35</front>
<front id="pinsH-1305">#define Y_MAX_PIN          34</front>
<front id="pinsH-1306"></front>
<front id="pinsH-1307">#define Z_STEP_PIN         57</front>
<front id="pinsH-1308">#define Z_DIR_PIN          56</front>
<front id="pinsH-1309">#define Z_ENABLE_PIN       62</front>
<front id="pinsH-1310">#define Z_MIN_PIN          33</front>
<front id="pinsH-1311">#define Z_MAX_PIN          32</front>
<front id="pinsH-1312"></front>
<front id="pinsH-1313">#define E0_STEP_PIN        23</front>
<front id="pinsH-1314">#define E0_DIR_PIN         22</front>
<front id="pinsH-1315">#define E0_ENABLE_PIN      24</front>
<front id="pinsH-1316"></front>
<front id="pinsH-1317">#define E1_STEP_PIN        26</front>
<front id="pinsH-1318">#define E1_DIR_PIN         25</front>
<front id="pinsH-1319">#define E1_ENABLE_PIN      27</front>
<front id="pinsH-1320"></front>
<front id="pinsH-1321">#define E2_STEP_PIN        29</front>
<front id="pinsH-1322">#define E2_DIR_PIN         28</front>
<front id="pinsH-1323">#define E2_ENABLE_PIN      39</front>
<front id="pinsH-1324"></front>
<front id="pinsH-1325">#define LED_PIN            13</front>
<front id="pinsH-1326"></front>
<front id="pinsH-1327">#define FAN_PIN            7</front>
<front id="pinsH-1328">//additional FAN1 PIN (e.g. useful for electronics fan or light on/off) on PIN 8</front>
<front id="pinsH-1329"></front>
<front id="pinsH-1330">#define PS_ON_PIN          45</front>
<front id="pinsH-1331">#define KILL_PIN           46</front>
<front id="pinsH-1332"></front>
<front id="pinsH-1333">#if (TEMP_SENSOR_0==0)</front>
<front id="pinsH-1334"> #define TEMP_0_PIN         -1</front>
<front id="pinsH-1335"> #define HEATER_0_PIN       -1</front>
<front id="pinsH-1336">#else</front>
<front id="pinsH-1337"> #define HEATER_0_PIN        2    // EXTRUDER 1</front>
<front id="pinsH-1338"> #if (TEMP_SENSOR_0==-1)</front>
<front id="pinsH-1339">  #define TEMP_0_PIN         6    // ANALOG NUMBERING - connector *K1* on RUMBA thermocouple ADD ON is used</front>
<front id="pinsH-1340"> #else</front>
<front id="pinsH-1341">  #define TEMP_0_PIN         15   // ANALOG NUMBERING - default connector for thermistor *T0* on rumba board is used</front>
<front id="pinsH-1342"> #endif</front>
<front id="pinsH-1343">#endif </front>
<front id="pinsH-1344"></front>
<front id="pinsH-1345">#if (TEMP_SENSOR_1==0)</front>
<front id="pinsH-1346"> #define TEMP_1_PIN         -1</front>
<front id="pinsH-1347"> #define HEATER_1_PIN       -1</front>
<front id="pinsH-1348">#else</front>
<front id="pinsH-1349"> #define HEATER_1_PIN        3    // EXTRUDER 2</front>
<front id="pinsH-1350"> #if (TEMP_SENSOR_1==-1)</front>
<front id="pinsH-1351">  #define TEMP_1_PIN         5    // ANALOG NUMBERING - connector *K2* on RUMBA thermocouple ADD ON is used</front>
<front id="pinsH-1352"> #else</front>
<front id="pinsH-1353">  #define TEMP_1_PIN         14   // ANALOG NUMBERING - default connector for thermistor *T1* on rumba board is used</front>
<front id="pinsH-1354"> #endif</front>
<front id="pinsH-1355">#endif</front>
<front id="pinsH-1356"></front>
<front id="pinsH-1357">#if (TEMP_SENSOR_2==0)</front>
<front id="pinsH-1358"> #define TEMP_2_PIN         -1</front>
<front id="pinsH-1359"> #define HEATER_2_PIN       -1</front>
<front id="pinsH-1360">#else</front>
<front id="pinsH-1361"> #define HEATER_2_PIN        6    // EXTRUDER 3</front>
<front id="pinsH-1362"> #if (TEMP_SENSOR_2==-1)</front>
<front id="pinsH-1363">  #define TEMP_2_PIN         7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used &lt;-- this can not be used when TEMP_SENSOR_BED is defined as thermocouple</front>
<front id="pinsH-1364"> #else</front>
<front id="pinsH-1365">  #define TEMP_2_PIN         13   // ANALOG NUMBERING - default connector for thermistor *T2* on rumba board is used</front>
<front id="pinsH-1366"> #endif</front>
<front id="pinsH-1367">#endif</front>
<front id="pinsH-1368"></front>
<front id="pinsH-1369">//optional for extruder 4 or chamber: #define TEMP_X_PIN         12   // ANALOG NUMBERING - default connector for thermistor *T3* on rumba board is used</front>
<front id="pinsH-1370">//optional FAN1 can be used as 4th heater output: #define HEATER_3_PIN       8    // EXTRUDER 4</front>
<front id="pinsH-1371"></front>
<front id="pinsH-1372">#if (TEMP_SENSOR_BED==0)</front>
<front id="pinsH-1373"> #define TEMP_BED_PIN       -1</front>
<front id="pinsH-1374"> #define HEATER_BED_PIN     -1</front>
<front id="pinsH-1375">#else</front>
<front id="pinsH-1376"> #define HEATER_BED_PIN      9    // BED</front>
<front id="pinsH-1377"> #if (TEMP_SENSOR_BED==-1)</front>
<front id="pinsH-1378">  #define TEMP_BED_PIN       7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used &lt;-- this can not be used when TEMP_SENSOR_2 is defined as thermocouple</front>
<front id="pinsH-1379"> #else</front>
<front id="pinsH-1380">  #define TEMP_BED_PIN       11   // ANALOG NUMBERING - default connector for thermistor *THB* on rumba board is used</front>
<front id="pinsH-1381"> #endif</front>
<front id="pinsH-1382">#endif</front>
<front id="pinsH-1383"></front>
<front id="pinsH-1384">#define SDPOWER            -1</front>
<front id="pinsH-1385">#define SDSS               53</front>
<front id="pinsH-1386">#define SDCARDDETECT       49</front>
<front id="pinsH-1387">#define BEEPER             44</front>
<front id="pinsH-1388">#define LCD_PINS_RS        19</front>
<front id="pinsH-1389">#define LCD_PINS_ENABLE    42</front>
<front id="pinsH-1390">#define LCD_PINS_D4        18</front>
<front id="pinsH-1391">#define LCD_PINS_D5        38</front>
<front id="pinsH-1392">#define LCD_PINS_D6        41</front>
<front id="pinsH-1393">#define LCD_PINS_D7        40</front>
<front id="pinsH-1394">#define BTN_EN1            11</front>
<front id="pinsH-1395">#define BTN_EN2            12</front>
<front id="pinsH-1396">#define BTN_ENC            43</front>
<front id="pinsH-1397"></front>
<front id="pinsH-1398">#endif //MOTHERBOARD==80</front>
<front id="pinsH-1399"></front>
<front id="pinsH-1400"></front>
<front id="pinsH-1401">/****************************************************************************************</front>
<front id="pinsH-1402">* Teensylu 0.7 / Printrboard pin assignments (AT90USB1286)</front>
<front id="pinsH-1403">* Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!</front>
<front id="pinsH-1404">  http://www.pjrc.com/teensy/teensyduino.html</front>
<front id="pinsH-1405">* See http://reprap.org/wiki/Printrboard for more info</front>
<front id="pinsH-1406">****************************************************************************************/</front>
<front id="pinsH-1407">#if MOTHERBOARD == 8 || MOTHERBOARD == 81</front>
<front id="pinsH-1408">#define KNOWN_BOARD 1</front>
<front id="pinsH-1409">#define AT90USB 1286  // Disable MarlinSerial etc.</front>
<front id="pinsH-1410"></front>
<front id="pinsH-1411">#ifndef __AVR_AT90USB1286__</front>
<front id="pinsH-1412">#error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1413">#endif</front>
<front id="pinsH-1414"></front>
<front id="pinsH-1415">#define LARGE_FLASH        true</front>
<front id="pinsH-1416"></front>
<front id="pinsH-1417">#define X_STEP_PIN          0</front>
<front id="pinsH-1418">#define X_DIR_PIN           1</front>
<front id="pinsH-1419">#define X_ENABLE_PIN       39</front>
<front id="pinsH-1420"></front>
<front id="pinsH-1421">#define Y_STEP_PIN          2</front>
<front id="pinsH-1422">#define Y_DIR_PIN           3</front>
<front id="pinsH-1423">#define Y_ENABLE_PIN       38</front>
<front id="pinsH-1424"></front>
<front id="pinsH-1425">#define Z_STEP_PIN          4</front>
<front id="pinsH-1426">#define Z_DIR_PIN           5</front>
<front id="pinsH-1427">#define Z_ENABLE_PIN       23</front>
<front id="pinsH-1428"></front>
<front id="pinsH-1429">#define E0_STEP_PIN         6</front>
<front id="pinsH-1430">#define E0_DIR_PIN          7</front>
<front id="pinsH-1431">#define E0_ENABLE_PIN      19</front>
<front id="pinsH-1432"></front>
<front id="pinsH-1433">#define HEATER_0_PIN       21  // Extruder</front>
<front id="pinsH-1434">#define HEATER_1_PIN       -1</front>
<front id="pinsH-1435">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1436">#define HEATER_BED_PIN     20  // Bed</front>
<front id="pinsH-1437">#define FAN_PIN            22  // Fan</front>
<front id="pinsH-1438">// You may need to change FAN_PIN to 16 because Marlin isn't using fastio.h</front>
<front id="pinsH-1439">// for the fan and Teensyduino uses a different pin mapping.</front>
<front id="pinsH-1440"></front>
<front id="pinsH-1441">#if MOTHERBOARD == 8  // Teensylu</front>
<front id="pinsH-1442">  #define X_STOP_PIN         13</front>
<front id="pinsH-1443">  #define Y_STOP_PIN         14</front>
<front id="pinsH-1444">  #define Z_STOP_PIN         15</front>
<front id="pinsH-1445">  #define TEMP_0_PIN          7  // Extruder / Analog pin numbering</front>
<front id="pinsH-1446">  #define TEMP_BED_PIN        6  // Bed / Analog pin numbering</front>
<front id="pinsH-1447">#else  // Printrboard</front>
<front id="pinsH-1448">  #define X_STOP_PIN         35</front>
<front id="pinsH-1449">  #define Y_STOP_PIN          8</front>
<front id="pinsH-1450">  #define Z_STOP_PIN         36</front>
<front id="pinsH-1451">  #define TEMP_0_PIN          1  // Extruder / Analog pin numbering</front>
<front id="pinsH-1452">  #define TEMP_BED_PIN        0  // Bed / Analog pin numbering</front>
<front id="pinsH-1453">#endif</front>
<front id="pinsH-1454"></front>
<front id="pinsH-1455">#define TEMP_1_PIN         -1</front>
<front id="pinsH-1456">#define TEMP_2_PIN         -1</front>
<front id="pinsH-1457"></front>
<front id="pinsH-1458">#define SDPOWER            -1</front>
<front id="pinsH-1459">#define SDSS                8</front>
<front id="pinsH-1460">#define LED_PIN            -1</front>
<front id="pinsH-1461">#define PS_ON_PIN          -1</front>
<front id="pinsH-1462">#define KILL_PIN           -1</front>
<front id="pinsH-1463">#define ALARM_PIN          -1</front>
<front id="pinsH-1464"></front>
<front id="pinsH-1465">#ifndef SDSUPPORT</front>
<front id="pinsH-1466">// these pins are defined in the SD library if building with SD support</front>
<front id="pinsH-1467">  #define SCK_PIN           9</front>
<front id="pinsH-1468">  #define MISO_PIN         11</front>
<front id="pinsH-1469">  #define MOSI_PIN         10</front>
<front id="pinsH-1470">#endif</front>
<front id="pinsH-1471"></front>
<front id="pinsH-1472">#endif  // MOTHERBOARD == 8 (Teensylu) or 81 (Printrboard)</front>
<front id="pinsH-1473"></front>
<front id="pinsH-1474">/****************************************************************************************</front>
<front id="pinsH-1475"> * Brainwave 1.0 pin assignments (AT90USB646)</front>
<front id="pinsH-1476"> * Requires hardware bundle for Arduino:</front>
<front id="pinsH-1477">   https://github.com/unrepentantgeek/brainwave-arduino</front>
<front id="pinsH-1478"> ****************************************************************************************/</front>
<front id="pinsH-1479">#if MOTHERBOARD == 82</front>
<front id="pinsH-1480">#define KNOWN_BOARD 1</front>
<front id="pinsH-1481">#define AT90USB 646  // Disable MarlinSerial etc.</front>
<front id="pinsH-1482"></front>
<front id="pinsH-1483">#ifndef __AVR_AT90USB646__</front>
<front id="pinsH-1484">#error Oops!  Make sure you have 'Brainwave' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1485">#endif</front>
<front id="pinsH-1486"></front>
<front id="pinsH-1487">#define X_STEP_PIN         27</front>
<front id="pinsH-1488">#define X_DIR_PIN          29</front>
<front id="pinsH-1489">#define X_ENABLE_PIN       28</front>
<front id="pinsH-1490">#define X_STOP_PIN          7</front>
<front id="pinsH-1491">#define X_ATT_PIN          26</front>
<front id="pinsH-1492"></front>
<front id="pinsH-1493">#define Y_STEP_PIN         31</front>
<front id="pinsH-1494">#define Y_DIR_PIN          33</front>
<front id="pinsH-1495">#define Y_ENABLE_PIN       32</front>
<front id="pinsH-1496">#define Y_STOP_PIN          6</front>
<front id="pinsH-1497">#define Y_ATT_PIN          30</front>
<front id="pinsH-1498"></front>
<front id="pinsH-1499">#define Z_STEP_PIN         17</front>
<front id="pinsH-1500">#define Z_DIR_PIN          19</front>
<front id="pinsH-1501">#define Z_ENABLE_PIN       18</front>
<front id="pinsH-1502">#define Z_STOP_PIN          5</front>
<front id="pinsH-1503">#define Z_ATT_PIN          16</front>
<front id="pinsH-1504"></front>
<front id="pinsH-1505">#define E0_STEP_PIN        21</front>
<front id="pinsH-1506">#define E0_DIR_PIN         23</front>
<front id="pinsH-1507">#define E0_ENABLE_PIN      22</front>
<front id="pinsH-1508">#define E0_ATT_PIN         20</front>
<front id="pinsH-1509"></front>
<front id="pinsH-1510">#define HEATER_0_PIN        4  // Extruder</front>
<front id="pinsH-1511">#define HEATER_1_PIN       -1</front>
<front id="pinsH-1512">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1513">#define HEATER_BED_PIN     38  // Bed</front>
<front id="pinsH-1514">#define FAN_PIN             3  // Fan</front>
<front id="pinsH-1515"></front>
<front id="pinsH-1516">#define TEMP_0_PIN          7  // Extruder / Analog pin numbering</front>
<front id="pinsH-1517">#define TEMP_1_PIN         -1</front>
<front id="pinsH-1518">#define TEMP_2_PIN         -1</front>
<front id="pinsH-1519">#define TEMP_BED_PIN        6  // Bed / Analog pin numbering</front>
<front id="pinsH-1520"></front>
<front id="pinsH-1521">#define SDPOWER            -1</front>
<front id="pinsH-1522">#define SDSS               -1</front>
<front id="pinsH-1523">#define LED_PIN            39</front>
<front id="pinsH-1524">#define PS_ON_PIN          -1</front>
<front id="pinsH-1525">#define KILL_PIN           -1</front>
<front id="pinsH-1526">#define ALARM_PIN          -1</front>
<front id="pinsH-1527"></front>
<front id="pinsH-1528">#ifndef SDSUPPORT</front>
<front id="pinsH-1529">// these pins are defined in the SD library if building with SD support</front>
<front id="pinsH-1530">  #define SCK_PIN           9</front>
<front id="pinsH-1531">  #define MISO_PIN         11</front>
<front id="pinsH-1532">  #define MOSI_PIN         10</front>
<front id="pinsH-1533">#endif</front>
<front id="pinsH-1534"></front>
<front id="pinsH-1535">#endif  // MOTHERBOARD == 82 (Brainwave)</front>
<front id="pinsH-1536"></front>
<front id="pinsH-1537">/****************************************************************************************</front>
<front id="pinsH-1538">* Gen3+ pin assignment</front>
<front id="pinsH-1539">*</front>
<front id="pinsH-1540">****************************************************************************************/</front>
<front id="pinsH-1541">#if MOTHERBOARD == 9</front>
<front id="pinsH-1542">#define MOTHERBOARD 6   /*TODO: Figure out, Why is this done?*/</front>
<front id="pinsH-1543">#define KNOWN_BOARD 1</front>
<front id="pinsH-1544">#ifndef __AVR_ATmega644P__</front>
<front id="pinsH-1545">#ifndef __AVR_ATmega1284P__</front>
<front id="pinsH-1546">#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1547">#endif</front>
<front id="pinsH-1548">#endif</front>
<front id="pinsH-1549"></front>
<front id="pinsH-1550">#define X_STEP_PIN         15</front>
<front id="pinsH-1551">#define X_DIR_PIN          18</front>
<front id="pinsH-1552">#define X_STOP_PIN         20</front>
<front id="pinsH-1553"></front>
<front id="pinsH-1554">#define Y_STEP_PIN         23</front>
<front id="pinsH-1555">#define Y_DIR_PIN          22</front>
<front id="pinsH-1556">#define Y_STOP_PIN         25</front>
<front id="pinsH-1557"></front>
<front id="pinsH-1558">#define Z_STEP_PIN         27</front>
<front id="pinsH-1559">#define Z_DIR_PIN          28</front>
<front id="pinsH-1560">#define Z_STOP_PIN         30</front>
<front id="pinsH-1561"></front>
<front id="pinsH-1562">#define E_STEP_PIN         17</front>
<front id="pinsH-1563">#define E_DIR_PIN          21</front>
<front id="pinsH-1564"></front>
<front id="pinsH-1565">#define LED_PIN            -1</front>
<front id="pinsH-1566"></front>
<front id="pinsH-1567">#define FAN_PIN            -1</front>
<front id="pinsH-1568"></front>
<front id="pinsH-1569">#define PS_ON_PIN         14</front>
<front id="pinsH-1570">#define KILL_PIN           -1</front>
<front id="pinsH-1571"></front>
<front id="pinsH-1572">#define HEATER_0_PIN       12 // (extruder)</front>
<front id="pinsH-1573"></front>
<front id="pinsH-1574">#define HEATER_1_PIN       16 // (bed)</front>
<front id="pinsH-1575">#define X_ENABLE_PIN       19</front>
<front id="pinsH-1576">#define Y_ENABLE_PIN       24</front>
<front id="pinsH-1577">#define Z_ENABLE_PIN       29</front>
<front id="pinsH-1578">#define E_ENABLE_PIN       13</front>
<front id="pinsH-1579"></front>
<front id="pinsH-1580">#define TEMP_0_PIN          0   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)</front>
<front id="pinsH-1581">#define TEMP_1_PIN          5   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)</front>
<front id="pinsH-1582">#define TEMP_2_PIN         -1</front>
<front id="pinsH-1583">#define SDPOWER            -1</front>
<front id="pinsH-1584">#define SDSS               4</front>
<front id="pinsH-1585">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1586"></front>
<front id="pinsH-1587">#endif</front>
<front id="pinsH-1588"></front>
<front id="pinsH-1589"></front>
<front id="pinsH-1590"></front>
<front id="pinsH-1591">/****************************************************************************************</front>
<front id="pinsH-1592">* Open Motion controller with enable based extruders</front>
<front id="pinsH-1593">*</front>
<front id="pinsH-1594">*                        ATMega644</front>
<front id="pinsH-1595">*</front>
<front id="pinsH-1596">*                        +---\/---+</front>
<front id="pinsH-1597">*            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)</front>
<front id="pinsH-1598">*            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)</front>
<front id="pinsH-1599">*       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)</front>
<front id="pinsH-1600">*        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)</front>
<front id="pinsH-1601">*        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)</front>
<front id="pinsH-1602">*       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)</front>
<front id="pinsH-1603">*       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)</front>
<front id="pinsH-1604">*        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)</front>
<front id="pinsH-1605">*                  RST  9|        |32  AREF</front>
<front id="pinsH-1606">*                  VCC 10|        |31  GND</front>
<front id="pinsH-1607">*                  GND 11|        |30  AVCC</front>
<front id="pinsH-1608">*                XTAL2 12|        |29  PC7 (D 23)</front>
<front id="pinsH-1609">*                XTAL1 13|        |28  PC6 (D 22)</front>
<front id="pinsH-1610">*       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI</front>
<front id="pinsH-1611">*       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO</front>
<front id="pinsH-1612">*  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS</front>
<front id="pinsH-1613">*  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK</front>
<front id="pinsH-1614">*       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA</front>
<front id="pinsH-1615">*       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL</front>
<front id="pinsH-1616">*       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM</front>
<front id="pinsH-1617">*                        +--------+</front>
<front id="pinsH-1618">*</front>
<front id="pinsH-1619">****************************************************************************************/</front>
<front id="pinsH-1620">#if MOTHERBOARD == 90 //Alpha OMCA board</front>
<front id="pinsH-1621">#define KNOWN_BOARD 1</front>
<front id="pinsH-1622"></front>
<front id="pinsH-1623">#ifndef __AVR_ATmega644__</front>
<front id="pinsH-1624">#error Oops!  Make sure you have 'SanguinoA' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1625">#endif</front>
<front id="pinsH-1626"></front>
<front id="pinsH-1627">#define X_STEP_PIN         21</front>
<front id="pinsH-1628">#define X_DIR_PIN          20</front>
<front id="pinsH-1629">#define X_ENABLE_PIN       24</front>
<front id="pinsH-1630">#define X_STOP_PIN         0</front>
<front id="pinsH-1631"></front>
<front id="pinsH-1632">#define Y_STEP_PIN         23</front>
<front id="pinsH-1633">#define Y_DIR_PIN          22</front>
<front id="pinsH-1634">#define Y_ENABLE_PIN       24</front>
<front id="pinsH-1635">#define Y_STOP_PIN         1</front>
<front id="pinsH-1636"></front>
<front id="pinsH-1637">#define Z_STEP_PIN         26</front>
<front id="pinsH-1638">#define Z_DIR_PIN          25</front>
<front id="pinsH-1639">#define Z_ENABLE_PIN       24</front>
<front id="pinsH-1640">#define Z_STOP_PIN         2</front>
<front id="pinsH-1641"></front>
<front id="pinsH-1642">#define E0_STEP_PIN         28</front>
<front id="pinsH-1643">#define E0_DIR_PIN          27</front>
<front id="pinsH-1644">#define E0_ENABLE_PIN       24</front>
<front id="pinsH-1645"></front>
<front id="pinsH-1646">#define E1_STEP_PIN         -1 // 19</front>
<front id="pinsH-1647">#define E1_DIR_PIN          -1 // 18</front>
<front id="pinsH-1648">#define E1_ENABLE_PIN       24</front>
<front id="pinsH-1649"></front>
<front id="pinsH-1650">#define E2_STEP_PIN         -1 // 17</front>
<front id="pinsH-1651">#define E2_DIR_PIN          -1 // 16</front>
<front id="pinsH-1652">#define E2_ENABLE_PIN       24</front>
<front id="pinsH-1653"></front>
<front id="pinsH-1654">#define SDPOWER            -1</front>
<front id="pinsH-1655">#define SDSS               11</front>
<front id="pinsH-1656">#define SDCARDDETECT       -1 // 10 optional also used as mode pin</front>
<front id="pinsH-1657">#define LED_PIN            -1</front>
<front id="pinsH-1658">#define FAN_PIN            3</front>
<front id="pinsH-1659">#define PS_ON_PIN          -1</front>
<front id="pinsH-1660">#define KILL_PIN           -1</front>
<front id="pinsH-1661"></front>
<front id="pinsH-1662">#define HEATER_0_PIN       4</front>
<front id="pinsH-1663">#define HEATER_1_PIN       -1 // 12</front>
<front id="pinsH-1664">#define HEATER_2_PIN       -1 // 13</front>
<front id="pinsH-1665">#define TEMP_0_PIN          0 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pinsH-1666">#define TEMP_1_PIN         -1 // 1</front>
<front id="pinsH-1667">#define TEMP_2_PIN         -1 // 2</front>
<front id="pinsH-1668">#define HEATER_BED_PIN     -1 // 14/15</front>
<front id="pinsH-1669">#define TEMP_BED_PIN       -1 // 1,2 or I2C</front>
<front id="pinsH-1670">/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */</front>
<front id="pinsH-1671"></front>
<front id="pinsH-1672">#endif</front>
<front id="pinsH-1673"></front>
<front id="pinsH-1674">#if MOTHERBOARD == 91  // Final OMCA board -- REF http://sanguino.cc/hardware</front>
<front id="pinsH-1675">#define KNOWN_BOARD 1</front>
<front id="pinsH-1676"></front>
<front id="pinsH-1677">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__)</front>
<front id="pinsH-1678">#error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu. (Final OMCA board)</front>
<front id="pinsH-1679">#endif</front>
<front id="pinsH-1680"></front>
<front id="pinsH-1681">#define X_STEP_PIN         26</front>
<front id="pinsH-1682">#define X_DIR_PIN          25</front>
<front id="pinsH-1683">#define X_ENABLE_PIN       10</front>
<front id="pinsH-1684">#define X_STOP_PIN         0</front>
<front id="pinsH-1685"></front>
<front id="pinsH-1686">#define Y_STEP_PIN         28</front>
<front id="pinsH-1687">#define Y_DIR_PIN          27</front>
<front id="pinsH-1688">#define Y_ENABLE_PIN       10</front>
<front id="pinsH-1689">#define Y_STOP_PIN         1</front>
<front id="pinsH-1690"></front>
<front id="pinsH-1691">#define Z_STEP_PIN         23</front>
<front id="pinsH-1692">#define Z_DIR_PIN          22</front>
<front id="pinsH-1693">#define Z_ENABLE_PIN       10</front>
<front id="pinsH-1694">#define Z_STOP_PIN         2</front>
<front id="pinsH-1695"></front>
<front id="pinsH-1696">#define E0_STEP_PIN         24</front>
<front id="pinsH-1697">#define E0_DIR_PIN          21</front>
<front id="pinsH-1698">#define E0_ENABLE_PIN       10</front>
<front id="pinsH-1699"></front>
<front id="pinsH-1700">/* future proofing */</front>
<front id="pinsH-1701">#define __FS  20</front>
<front id="pinsH-1702">#define __FD  19</front>
<front id="pinsH-1703">#define __GS  18</front>
<front id="pinsH-1704">#define __GD  13</front>
<front id="pinsH-1705"></front>
<front id="pinsH-1706">#define UNUSED_PWM           14 /* PWM on LEFT connector */</front>
<front id="pinsH-1707"></front>
<front id="pinsH-1708">#define E1_STEP_PIN         -1 // 21</front>
<front id="pinsH-1709">#define E1_DIR_PIN          -1 // 20</front>
<front id="pinsH-1710">#define E1_ENABLE_PIN       -1 // 19</front>
<front id="pinsH-1711"></front>
<front id="pinsH-1712">#define E2_STEP_PIN         -1 // 21</front>
<front id="pinsH-1713">#define E2_DIR_PIN          -1 // 20</front>
<front id="pinsH-1714">#define E2_ENABLE_PIN       -1 // 18</front>
<front id="pinsH-1715"></front>
<front id="pinsH-1716">#define SDPOWER            -1</front>
<front id="pinsH-1717">#define SDSS               11</front>
<front id="pinsH-1718">#define SDCARDDETECT       -1 // 10 optional also used as mode pin</front>
<front id="pinsH-1719">#define LED_PIN            -1</front>
<front id="pinsH-1720">#define FAN_PIN            14 /* PWM on MIDDLE connector */</front>
<front id="pinsH-1721">#define PS_ON_PIN          -1</front>
<front id="pinsH-1722">#define KILL_PIN           -1</front>
<front id="pinsH-1723"></front>
<front id="pinsH-1724">#define HEATER_0_PIN        3 /*DONE PWM on RIGHT connector */</front>
<front id="pinsH-1725">#define HEATER_1_PIN       -1</front>
<front id="pinsH-1726">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1727">#define HEATER_1_PIN       -1</front>
<front id="pinsH-1728">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1729">#define TEMP_0_PIN          0 // ANALOG INPUT NUMBERING</front>
<front id="pinsH-1730">#define TEMP_1_PIN          1 // ANALOG</front>
<front id="pinsH-1731">#define TEMP_2_PIN         -1 // 2</front>
<front id="pinsH-1732">#define HEATER_BED_PIN      4</front>
<front id="pinsH-1733">#define TEMP_BED_PIN        2 // 1,2 or I2C</front>
<front id="pinsH-1734"></front>
<front id="pinsH-1735">#define I2C_SCL       16</front>
<front id="pinsH-1736">#define I2C_SDA       17</front>
<front id="pinsH-1737"></front>
<front id="pinsH-1738">#endif</front>
<front id="pinsH-1739"></front>
<front id="pinsH-1740">#if MOTHERBOARD == 301</front>
<front id="pinsH-1741">#define KNOWN_BOARD</front>
<front id="pinsH-1742">/*****************************************************************</front>
<front id="pinsH-1743">* Rambo Pin Assignments</front>
<front id="pinsH-1744">******************************************************************/</front>
<front id="pinsH-1745"></front>
<front id="pinsH-1746">#ifndef __AVR_ATmega2560__</front>
<front id="pinsH-1747">#error Oops!  Make sure you have 'Arduino Mega 2560' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1748">#endif</front>
<front id="pinsH-1749"></front>
<front id="pinsH-1750">#define LARGE_FLASH true</front>
<front id="pinsH-1751"></front>
<front id="pinsH-1752">#define X_STEP_PIN 37</front>
<front id="pinsH-1753">#define X_DIR_PIN 48</front>
<front id="pinsH-1754">#define X_MIN_PIN 12</front>
<front id="pinsH-1755">#define X_MAX_PIN 24</front>
<front id="pinsH-1756">#define X_ENABLE_PIN 29</front>
<front id="pinsH-1757">#define X_MS1_PIN 40</front>
<front id="pinsH-1758">#define X_MS2_PIN 41</front>
<front id="pinsH-1759"></front>
<front id="pinsH-1760">#define Y_STEP_PIN 36</front>
<front id="pinsH-1761">#define Y_DIR_PIN 49</front>
<front id="pinsH-1762">#define Y_MIN_PIN 11</front>
<front id="pinsH-1763">#define Y_MAX_PIN 23</front>
<front id="pinsH-1764">#define Y_ENABLE_PIN 28</front>
<front id="pinsH-1765">#define Y_MS1_PIN 69</front>
<front id="pinsH-1766">#define Y_MS2_PIN 39</front>
<front id="pinsH-1767"></front>
<front id="pinsH-1768">#define Z_STEP_PIN 35</front>
<front id="pinsH-1769">#define Z_DIR_PIN 47</front>
<front id="pinsH-1770">#define Z_MIN_PIN 10</front>
<front id="pinsH-1771">#define Z_MAX_PIN 30</front>
<front id="pinsH-1772">#define Z_ENABLE_PIN 27</front>
<front id="pinsH-1773">#define Z_MS1_PIN 68</front>
<front id="pinsH-1774">#define Z_MS2_PIN 67</front>
<front id="pinsH-1775"></front>
<front id="pinsH-1776">#define HEATER_BED_PIN 3</front>
<front id="pinsH-1777">#define TEMP_BED_PIN 2</front>
<front id="pinsH-1778"></front>
<front id="pinsH-1779">#define HEATER_0_PIN  9</front>
<front id="pinsH-1780">#define TEMP_0_PIN 0</front>
<front id="pinsH-1781"></front>
<front id="pinsH-1782">#define HEATER_1_PIN 7</front>
<front id="pinsH-1783">#define TEMP_1_PIN 1</front>
<front id="pinsH-1784"></front>
<front id="pinsH-1785">#ifdef BARICUDA</front>
<front id="pinsH-1786">#define HEATER_2_PIN 6</front>
<front id="pinsH-1787">#else</front>
<front id="pinsH-1788">#define HEATER_2_PIN -1</front>
<front id="pinsH-1789">#endif</front>
<front id="pinsH-1790">#define TEMP_2_PIN -1</front>
<front id="pinsH-1791"></front>
<front id="pinsH-1792">#define E0_STEP_PIN         34</front>
<front id="pinsH-1793">#define E0_DIR_PIN          43</front>
<front id="pinsH-1794">#define E0_ENABLE_PIN       26</front>
<front id="pinsH-1795">#define E0_MS1_PIN 65</front>
<front id="pinsH-1796">#define E0_MS2_PIN 66</front>
<front id="pinsH-1797"></front>
<front id="pinsH-1798">#define E1_STEP_PIN         33</front>
<front id="pinsH-1799">#define E1_DIR_PIN          42</front>
<front id="pinsH-1800">#define E1_ENABLE_PIN       25</front>
<front id="pinsH-1801">#define E1_MS1_PIN 63</front>
<front id="pinsH-1802">#define E1_MS2_PIN 64</front>
<front id="pinsH-1803"></front>
<front id="pinsH-1804">#define DIGIPOTSS_PIN 38</front>
<front id="pinsH-1805">#define DIGIPOT_CHANNELS {4,5,3,0,1} // X Y Z E0 E1 digipot channels to stepper driver mapping</front>
<front id="pinsH-1806"></front>
<front id="pinsH-1807">#define SDPOWER            -1</front>
<front id="pinsH-1808">#define SDSS               53</front>
<front id="pinsH-1809">#define LED_PIN            13</front>
<front id="pinsH-1810">#define FAN_PIN            8</front>
<front id="pinsH-1811">#define PS_ON_PIN          4</front>
<front id="pinsH-1812">#define KILL_PIN           -1 //80 with Smart Controller LCD</front>
<front id="pinsH-1813">#define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pinsH-1814"></front>
<front id="pinsH-1815">#ifdef ULTRA_LCD</front>
<front id="pinsH-1816">  #define KILL_PIN 80</front>
<front id="pinsH-1817">  #ifdef NEWPANEL</front>
<front id="pinsH-1818">   //arduino pin which triggers an piezzo beeper</front>
<front id="pinsH-1819">    #define BEEPER 79      // Beeper on AUX-4</front>
<front id="pinsH-1820">    #define LCD_PINS_RS 70</front>
<front id="pinsH-1821">    #define LCD_PINS_ENABLE 71</front>
<front id="pinsH-1822">    #define LCD_PINS_D4 72</front>
<front id="pinsH-1823">    #define LCD_PINS_D5 73</front>
<front id="pinsH-1824">    #define LCD_PINS_D6 74</front>
<front id="pinsH-1825">    #define LCD_PINS_D7 75</front>
<front id="pinsH-1826"></front>
<front id="pinsH-1827">    //buttons are directly attached using AUX-2</front>
<front id="pinsH-1828">    #define BTN_EN1 76</front>
<front id="pinsH-1829">    #define BTN_EN2 77</front>
<front id="pinsH-1830">    #define BTN_ENC 78  //the click</front>
<front id="pinsH-1831"></front>
<front id="pinsH-1832">    #define BLEN_C 2</front>
<front id="pinsH-1833">    #define BLEN_B 1</front>
<front id="pinsH-1834">    #define BLEN_A 0</front>
<front id="pinsH-1835"></front>
<front id="pinsH-1836">    #define SDCARDDETECT 81    // Ramps does not use this port</front>
<front id="pinsH-1837"></front>
<front id="pinsH-1838">    //encoder rotation values</front>
<front id="pinsH-1839">    #define encrot0 0</front>
<front id="pinsH-1840">    #define encrot1 2</front>
<front id="pinsH-1841">    #define encrot2 3</front>
<front id="pinsH-1842">    #define encrot3 1</front>
<front id="pinsH-1843">  #else //old style panel with shift register</front>
<front id="pinsH-1844">    //arduino pin witch triggers an piezzo beeper</front>
<front id="pinsH-1845">    #define BEEPER 33    No Beeper added</front>
<front id="pinsH-1846">    //buttons are attached to a shift register</front>
<front id="pinsH-1847">    // Not wired this yet</front>
<front id="pinsH-1848">    // #define SHIFT_CLK 38</front>
<front id="pinsH-1849">    // #define SHIFT_LD 42</front>
<front id="pinsH-1850">    // #define SHIFT_OUT 40</front>
<front id="pinsH-1851">    // #define SHIFT_EN 17</front>
<front id="pinsH-1852"></front>
<front id="pinsH-1853">    #define LCD_PINS_RS 75</front>
<front id="pinsH-1854">    #define LCD_PINS_ENABLE 17</front>
<front id="pinsH-1855">    #define LCD_PINS_D4 23</front>
<front id="pinsH-1856">    #define LCD_PINS_D5 25</front>
<front id="pinsH-1857">    #define LCD_PINS_D6 27</front>
<front id="pinsH-1858">    #define LCD_PINS_D7 29</front>
<front id="pinsH-1859"></front>
<front id="pinsH-1860">    //encoder rotation values</front>
<front id="pinsH-1861">    #define encrot0 0</front>
<front id="pinsH-1862">    #define encrot1 2</front>
<front id="pinsH-1863">    #define encrot2 3</front>
<front id="pinsH-1864">    #define encrot3 1</front>
<front id="pinsH-1865"></front>
<front id="pinsH-1866">    //bits in the shift register that carry the buttons for:</front>
<front id="pinsH-1867">    // left up center down right red</front>
<front id="pinsH-1868">    #define BL_LE 7</front>
<front id="pinsH-1869">    #define BL_UP 6</front>
<front id="pinsH-1870">    #define BL_MI 5</front>
<front id="pinsH-1871">    #define BL_DW 4</front>
<front id="pinsH-1872">    #define BL_RI 3</front>
<front id="pinsH-1873">    #define BL_ST 2</front>
<front id="pinsH-1874">    #define BLEN_B 1</front>
<front id="pinsH-1875">    #define BLEN_A 0</front>
<front id="pinsH-1876">  #endif</front>
<front id="pinsH-1877">#endif //ULTRA_LCD</front>
<front id="pinsH-1878"></front>
<front id="pinsH-1879"></front>
<front id="pinsH-1880">#endif</front>
<front id="pinsH-1881"></front>
<front id="pinsH-1882">/****************************************************************************************</front>
<front id="pinsH-1883">* MegaTronics</front>
<front id="pinsH-1884">*</front>
<front id="pinsH-1885">****************************************************************************************/</front>
<front id="pinsH-1886">#if MOTHERBOARD == 70</front>
<front id="pinsH-1887">#define KNOWN_BOARD 1</front>
<front id="pinsH-1888"></front>
<front id="pinsH-1889"></front>
<front id="pinsH-1890"> #ifndef __AVR_ATmega2560__</front>
<front id="pinsH-1891"> #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1892"> #endif</front>
<front id="pinsH-1893"></front>
<front id="pinsH-1894"></front>
<front id="pinsH-1895">#define LARGE_FLASH        true</front>
<front id="pinsH-1896"></front>
<front id="pinsH-1897">#define X_STEP_PIN         26</front>
<front id="pinsH-1898">#define X_DIR_PIN          28</front>
<front id="pinsH-1899">#define X_ENABLE_PIN       24</front>
<front id="pinsH-1900">#define X_MIN_PIN          41</front>
<front id="pinsH-1901">#define X_MAX_PIN          37</front>
<front id="pinsH-1902"></front>
<front id="pinsH-1903">#define Y_STEP_PIN         60 // A6</front>
<front id="pinsH-1904">#define Y_DIR_PIN          61 // A7</front>
<front id="pinsH-1905">#define Y_ENABLE_PIN       22</front>
<front id="pinsH-1906">#define Y_MIN_PIN          14</front>
<front id="pinsH-1907">#define Y_MAX_PIN          15</front>
<front id="pinsH-1908"></front>
<front id="pinsH-1909">#define Z_STEP_PIN         54 // A0</front>
<front id="pinsH-1910">#define Z_DIR_PIN          55 // A1</front>
<front id="pinsH-1911">#define Z_ENABLE_PIN       56 // A2</front>
<front id="pinsH-1912">#define Z_MIN_PIN          18</front>
<front id="pinsH-1913">#define Z_MAX_PIN          19</front>
<front id="pinsH-1914"></front>
<front id="pinsH-1915">#define E0_STEP_PIN        31</front>
<front id="pinsH-1916">#define E0_DIR_PIN         32</front>
<front id="pinsH-1917">#define E0_ENABLE_PIN      38</front>
<front id="pinsH-1918"></front>
<front id="pinsH-1919">#define E1_STEP_PIN        34</front>
<front id="pinsH-1920">#define E1_DIR_PIN         36</front>
<front id="pinsH-1921">#define E1_ENABLE_PIN      30</front>
<front id="pinsH-1922"></front>
<front id="pinsH-1923">#define SDPOWER            -1</front>
<front id="pinsH-1924">#define SDSS               53</front>
<front id="pinsH-1925">#define LED_PIN            13</front>
<front id="pinsH-1926"></front>
<front id="pinsH-1927"></front>
<front id="pinsH-1928">#define FAN_PIN            7 // IO pin. Buffer needed</front>
<front id="pinsH-1929">#define PS_ON_PIN          12</front>
<front id="pinsH-1930">#define KILL_PIN           -1</front>
<front id="pinsH-1931"></front>
<front id="pinsH-1932">#define HEATER_0_PIN       9    // EXTRUDER 1</front>
<front id="pinsH-1933">#define HEATER_1_PIN       8    // EXTRUDER 2 (FAN On Sprinter)</front>
<front id="pinsH-1934">#define HEATER_2_PIN       -1</front>
<front id="pinsH-1935"></front>
<front id="pinsH-1936">#if TEMP_SENSOR_0 == -1</front>
<front id="pinsH-1937">#define TEMP_0_PIN         8   // ANALOG NUMBERING</front>
<front id="pinsH-1938">#else</front>
<front id="pinsH-1939">#define TEMP_0_PIN         13   // ANALOG NUMBERING</front>
<front id="pinsH-1940"></front>
<front id="pinsH-1941">#endif</front>
<front id="pinsH-1942"></front>
<front id="pinsH-1943">#define TEMP_1_PIN         15   // ANALOG NUMBERING</front>
<front id="pinsH-1944">#define TEMP_2_PIN         -1   // ANALOG NUMBERING</front>
<front id="pinsH-1945">#define HEATER_BED_PIN     10   // BED</front>
<front id="pinsH-1946">#define TEMP_BED_PIN       14   // ANALOG NUMBERING</front>
<front id="pinsH-1947"></front>
<front id="pinsH-1948">#define BEEPER 33     // Beeper on AUX-4</front>
<front id="pinsH-1949"></front>
<front id="pinsH-1950"></front>
<front id="pinsH-1951">#ifdef ULTRA_LCD</front>
<front id="pinsH-1952"></front>
<front id="pinsH-1953">  #ifdef NEWPANEL</front>
<front id="pinsH-1954">  //arduino pin which triggers an piezzo beeper</front>
<front id="pinsH-1955"></front>
<front id="pinsH-1956">    #define LCD_PINS_RS 16</front>
<front id="pinsH-1957">    #define LCD_PINS_ENABLE 17</front>
<front id="pinsH-1958">    #define LCD_PINS_D4 23</front>
<front id="pinsH-1959">    #define LCD_PINS_D5 25</front>
<front id="pinsH-1960">    #define LCD_PINS_D6 27</front>
<front id="pinsH-1961">    #define LCD_PINS_D7 29</front>
<front id="pinsH-1962"></front>
<front id="pinsH-1963">    //buttons are directly attached using AUX-2</front>
<front id="pinsH-1964">    #define BTN_EN1 59</front>
<front id="pinsH-1965">    #define BTN_EN2 64</front>
<front id="pinsH-1966">    #define BTN_ENC 43  //the click</front>
<front id="pinsH-1967">    </front>
<front id="pinsH-1968">    #define BLEN_C 2</front>
<front id="pinsH-1969">    #define BLEN_B 1</front>
<front id="pinsH-1970">    #define BLEN_A 0</front>
<front id="pinsH-1971">    </front>
<front id="pinsH-1972">    #define SDCARDDETECT -1		// Ramps does not use this port</front>
<front id="pinsH-1973">    </front>
<front id="pinsH-1974">      //encoder rotation values</front>
<front id="pinsH-1975">    #define encrot0 0</front>
<front id="pinsH-1976">    #define encrot1 2</front>
<front id="pinsH-1977">    #define encrot2 3</front>
<front id="pinsH-1978">    #define encrot3 1</front>
<front id="pinsH-1979">#endif</front>
<front id="pinsH-1980">#endif //ULTRA_LCD</front>
<front id="pinsH-1981"></front>
<front id="pinsH-1982">#endif</front>
<front id="pinsH-1983"></front>
<front id="pinsH-1984">/****************************************************************************************</front>
<front id="pinsH-1985">* MegaTronics v2.0</front>
<front id="pinsH-1986">*</front>
<front id="pinsH-1987">****************************************************************************************/</front>
<front id="pinsH-1988">#if MOTHERBOARD == 701</front>
<front id="pinsH-1989"> #define KNOWN_BOARD 1</front>
<front id="pinsH-1990"> </front>
<front id="pinsH-1991"> </front>
<front id="pinsH-1992"> #ifndef __AVR_ATmega2560__</front>
<front id="pinsH-1993"> #error Oops! Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-1994"> #endif</front>
<front id="pinsH-1995"> </front>
<front id="pinsH-1996"> #define LARGE_FLASH        true</front>
<front id="pinsH-1997"> </front>
<front id="pinsH-1998"> #define X_STEP_PIN 26</front>
<front id="pinsH-1999"> #define X_DIR_PIN 27</front>
<front id="pinsH-2000"> #define X_ENABLE_PIN 25</front>
<front id="pinsH-2001"> #define X_MIN_PIN 37</front>
<front id="pinsH-2002"> #define X_MAX_PIN 40 //2 //Max endstops default to disabled "-1", set to commented value to enable.</front>
<front id="pinsH-2003"> </front>
<front id="pinsH-2004"> #define Y_STEP_PIN 4 // A6</front>
<front id="pinsH-2005"> #define Y_DIR_PIN 54 // A0</front>
<front id="pinsH-2006"> #define Y_ENABLE_PIN 5</front>
<front id="pinsH-2007"> #define Y_MIN_PIN 41</front>
<front id="pinsH-2008"> #define Y_MAX_PIN 38 //15</front>
<front id="pinsH-2009"> </front>
<front id="pinsH-2010"> #define Z_STEP_PIN 56 // A2</front>
<front id="pinsH-2011"> #define Z_DIR_PIN 60 // A6</front>
<front id="pinsH-2012"> #define Z_ENABLE_PIN 55 // A1</front>
<front id="pinsH-2013"> #define Z_MIN_PIN 18</front>
<front id="pinsH-2014"> #define Z_MAX_PIN 19</front>
<front id="pinsH-2015"> </front>
<front id="pinsH-2016"> #define E0_STEP_PIN 35</front>
<front id="pinsH-2017"> #define E0_DIR_PIN 36</front>
<front id="pinsH-2018"> #define E0_ENABLE_PIN 34</front>
<front id="pinsH-2019"> </front>
<front id="pinsH-2020"> #define E1_STEP_PIN 29</front>
<front id="pinsH-2021"> #define E1_DIR_PIN 39</front>
<front id="pinsH-2022"> #define E1_ENABLE_PIN 28</front>
<front id="pinsH-2023"> </front>
<front id="pinsH-2024"> #define E2_STEP_PIN 23</front>
<front id="pinsH-2025"> #define E2_DIR_PIN 24</front>
<front id="pinsH-2026"> #define E2_ENABLE_PIN 22</front>
<front id="pinsH-2027"> </front>
<front id="pinsH-2028"> #define SDPOWER -1</front>
<front id="pinsH-2029"> #define SDSS 53</front>
<front id="pinsH-2030"> #define LED_PIN 13</front>
<front id="pinsH-2031"> </front>
<front id="pinsH-2032"> #define FAN_PIN 7</front>
<front id="pinsH-2033"> #define FAN2_PIN 6</front>
<front id="pinsH-2034"> #define PS_ON_PIN 12</front>
<front id="pinsH-2035"> #define KILL_PIN -1</front>
<front id="pinsH-2036"> </front>
<front id="pinsH-2037"> #define HEATER_0_PIN 9 // EXTRUDER 1</front>
<front id="pinsH-2038"> #define HEATER_1_PIN 8 // EXTRUDER 2</front>
<front id="pinsH-2039"> #define HEATER_2_PIN -1</front>
<front id="pinsH-2040"> </front>
<front id="pinsH-2041"> #if TEMP_SENSOR_0 == -1</front>
<front id="pinsH-2042">   #define TEMP_0_PIN 4 // ANALOG NUMBERING</front>
<front id="pinsH-2043"> #else</front>
<front id="pinsH-2044">   #define TEMP_0_PIN 13 // ANALOG NUMBERING</front>
<front id="pinsH-2045"> #endif</front>
<front id="pinsH-2046"> </front>
<front id="pinsH-2047"> </front>
<front id="pinsH-2048"> #if TEMP_SENSOR_1 == -1</front>
<front id="pinsH-2049">   #define TEMP_1_PIN 8 // ANALOG NUMBERING</front>
<front id="pinsH-2050"> #else</front>
<front id="pinsH-2051">   #define TEMP_1_PIN 15 // ANALOG NUMBERING</front>
<front id="pinsH-2052"> #endif</front>
<front id="pinsH-2053"> </front>
<front id="pinsH-2054"> #define TEMP_2_PIN -1 // ANALOG NUMBERING</front>
<front id="pinsH-2055"> </front>
<front id="pinsH-2056"> #define HEATER_BED_PIN 10 // BED</front>
<front id="pinsH-2057"> </front>
<front id="pinsH-2058"> #if TEMP_SENSOR_BED == -1</front>
<front id="pinsH-2059">   #define TEMP_BED_PIN 8 // ANALOG NUMBERING</front>
<front id="pinsH-2060"> #else </front>
<front id="pinsH-2061">   #define TEMP_BED_PIN 14 // ANALOG NUMBERING</front>
<front id="pinsH-2062"> #endif</front>
<front id="pinsH-2063"> </front>
<front id="pinsH-2064"> #define BEEPER 64	</front>
<front id="pinsH-2065"> </front>
<front id="pinsH-2066"> </front>
<front id="pinsH-2067"> #define LCD_PINS_RS 14</front>
<front id="pinsH-2068"> #define LCD_PINS_ENABLE 15</front>
<front id="pinsH-2069"> #define LCD_PINS_D4 30</front>
<front id="pinsH-2070"> #define LCD_PINS_D5 31</front>
<front id="pinsH-2071"> #define LCD_PINS_D6 32</front>
<front id="pinsH-2072"> #define LCD_PINS_D7 33</front>
<front id="pinsH-2073"> </front>
<front id="pinsH-2074"> </front>
<front id="pinsH-2075"> //buttons are directly attached using keypad</front>
<front id="pinsH-2076"> #define BTN_EN1 61</front>
<front id="pinsH-2077"> #define BTN_EN2 59</front>
<front id="pinsH-2078"> #define BTN_ENC 43 //the click</front>
<front id="pinsH-2079"> </front>
<front id="pinsH-2080"> #define BLEN_C 2</front>
<front id="pinsH-2081"> #define BLEN_B 1</front>
<front id="pinsH-2082"> #define BLEN_A 0</front>
<front id="pinsH-2083"> </front>
<front id="pinsH-2084"> #define SDCARDDETECT -1	// Megatronics does not use this port</front>
<front id="pinsH-2085"> </front>
<front id="pinsH-2086">   //encoder rotation values</front>
<front id="pinsH-2087"> #define encrot0 0</front>
<front id="pinsH-2088"> #define encrot1 2</front>
<front id="pinsH-2089"> #define encrot2 3</front>
<front id="pinsH-2090"> #define encrot3 1</front>
<front id="pinsH-2091"></front>
<front id="pinsH-2092">#endif</front>
<front id="pinsH-2093"></front>
<front id="pinsH-2094"></front>
<front id="pinsH-2095">/****************************************************************************************</front>
<front id="pinsH-2096">* Minitronics v1.0</front>
<front id="pinsH-2097">*</front>
<front id="pinsH-2098">****************************************************************************************/</front>
<front id="pinsH-2099">#if MOTHERBOARD == 702</front>
<front id="pinsH-2100"> #define KNOWN_BOARD 1</front>
<front id="pinsH-2101"> </front>
<front id="pinsH-2102"> </front>
<front id="pinsH-2103"> #ifndef __AVR_ATmega1281__</front>
<front id="pinsH-2104"> #error Oops! Make sure you have 'Minitronics ' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pinsH-2105"> #endif</front>
<front id="pinsH-2106"> </front>
<front id="pinsH-2107"> #define LARGE_FLASH        true</front>
<front id="pinsH-2108"> </front>
<front id="pinsH-2109"> #define X_STEP_PIN 48</front>
<front id="pinsH-2110"> #define X_DIR_PIN 47</front>
<front id="pinsH-2111"> #define X_ENABLE_PIN 49</front>
<front id="pinsH-2112"> #define X_MIN_PIN 5</front>
<front id="pinsH-2113"> #define X_MAX_PIN -1 //2 //Max endstops default to disabled "-1", set to commented value to enable.</front>
<front id="pinsH-2114"> </front>
<front id="pinsH-2115"> #define Y_STEP_PIN 39 // A6</front>
<front id="pinsH-2116"> #define Y_DIR_PIN 40 // A0</front>
<front id="pinsH-2117"> #define Y_ENABLE_PIN 38</front>
<front id="pinsH-2118"> #define Y_MIN_PIN 2</front>
<front id="pinsH-2119"> #define Y_MAX_PIN -1 //15</front>
<front id="pinsH-2120"> </front>
<front id="pinsH-2121"> #define Z_STEP_PIN 42 // A2</front>
<front id="pinsH-2122"> #define Z_DIR_PIN 43 // A6</front>
<front id="pinsH-2123"> #define Z_ENABLE_PIN 41 // A1</front>
<front id="pinsH-2124"> #define Z_MIN_PIN 6</front>
<front id="pinsH-2125"> #define Z_MAX_PIN -1</front>
<front id="pinsH-2126"> </front>
<front id="pinsH-2127"> #define E0_STEP_PIN 45</front>
<front id="pinsH-2128"> #define E0_DIR_PIN 44</front>
<front id="pinsH-2129"> #define E0_ENABLE_PIN 27</front>
<front id="pinsH-2130"> </front>
<front id="pinsH-2131"> #define E1_STEP_PIN 36</front>
<front id="pinsH-2132"> #define E1_DIR_PIN 35</front>
<front id="pinsH-2133"> #define E1_ENABLE_PIN 37</front>
<front id="pinsH-2134"> </front>
<front id="pinsH-2135"> #define E2_STEP_PIN -1</front>
<front id="pinsH-2136"> #define E2_DIR_PIN -1</front>
<front id="pinsH-2137"> #define E2_ENABLE_PIN -1</front>
<front id="pinsH-2138"> </front>
<front id="pinsH-2139"> #define SDPOWER -1</front>
<front id="pinsH-2140"> #define SDSS 16</front>
<front id="pinsH-2141"> #define LED_PIN 46</front>
<front id="pinsH-2142"> </front>
<front id="pinsH-2143"> #define FAN_PIN 9</front>
<front id="pinsH-2144"> #define FAN2_PIN -1</front>
<front id="pinsH-2145"> #define PS_ON_PIN -1</front>
<front id="pinsH-2146"> #define KILL_PIN -1</front>
<front id="pinsH-2147"> </front>
<front id="pinsH-2148"> #define HEATER_0_PIN 7 // EXTRUDER 1</front>
<front id="pinsH-2149"> #define HEATER_1_PIN 8 // EXTRUDER 2</front>
<front id="pinsH-2150"> #define HEATER_2_PIN -1</front>
<front id="pinsH-2151"> </front>
<front id="pinsH-2152"></front>
<front id="pinsH-2153"> #define TEMP_0_PIN 7 // ANALOG NUMBERING</front>
<front id="pinsH-2154"> #define TEMP_1_PIN 6 // ANALOG NUMBERING</front>
<front id="pinsH-2155"> #define TEMP_2_PIN -1 // ANALOG NUMBERING</front>
<front id="pinsH-2156"> </front>
<front id="pinsH-2157"> #define HEATER_BED_PIN 3 // BED</front>
<front id="pinsH-2158"> #define TEMP_BED_PIN 6 // ANALOG NUMBERING</front>
<front id="pinsH-2159"> </front>
<front id="pinsH-2160"> #define BEEPER -1	</front>
<front id="pinsH-2161"> </front>
<front id="pinsH-2162"> </front>
<front id="pinsH-2163"> #define LCD_PINS_RS -1</front>
<front id="pinsH-2164"> #define LCD_PINS_ENABLE -1</front>
<front id="pinsH-2165"> #define LCD_PINS_D4 -1</front>
<front id="pinsH-2166"> #define LCD_PINS_D5 -1</front>
<front id="pinsH-2167"> #define LCD_PINS_D6 -1</front>
<front id="pinsH-2168"> #define LCD_PINS_D7 -1</front>
<front id="pinsH-2169"> </front>
<front id="pinsH-2170"> </front>
<front id="pinsH-2171"> //buttons are directly attached using keypad</front>
<front id="pinsH-2172"> #define BTN_EN1 -1</front>
<front id="pinsH-2173"> #define BTN_EN2 -1</front>
<front id="pinsH-2174"> #define BTN_ENC -1 //the click</front>
<front id="pinsH-2175"> </front>
<front id="pinsH-2176"> #define BLEN_C 2</front>
<front id="pinsH-2177"> #define BLEN_B 1</front>
<front id="pinsH-2178"> #define BLEN_A 0</front>
<front id="pinsH-2179"> </front>
<front id="pinsH-2180"> #define SDCARDDETECT -1	// Megatronics does not use this port</front>
<front id="pinsH-2181"> </front>
<front id="pinsH-2182">   //encoder rotation values</front>
<front id="pinsH-2183"> #define encrot0 0</front>
<front id="pinsH-2184"> #define encrot1 2</front>
<front id="pinsH-2185"> #define encrot2 3</front>
<front id="pinsH-2186"> #define encrot3 1</front>
<front id="pinsH-2187"></front>
<front id="pinsH-2188">#endif</front>
<front id="pinsH-2189"></front>
<front id="pinsH-2190"></front>
<front id="pinsH-2191"></front>
<front id="pinsH-2192">#ifndef KNOWN_BOARD</front>
<front id="pinsH-2193">#error Unknown MOTHERBOARD value in configuration.h</front>
<front id="pinsH-2194">#endif</front>
<front id="pinsH-2195"></front>
<front id="pinsH-2196">//List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!</front>
<front id="pinsH-2197">#define _E0_PINS E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, HEATER_0_PIN,</front>
<front id="pinsH-2198">#if EXTRUDERS &gt; 1</front>
<front id="pinsH-2199">  #define _E1_PINS E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN, HEATER_1_PIN,</front>
<front id="pinsH-2200">#else</front>
<front id="pinsH-2201">  #define _E1_PINS</front>
<front id="pinsH-2202">#endif</front>
<front id="pinsH-2203">#if EXTRUDERS &gt; 2</front>
<front id="pinsH-2204">  #define _E2_PINS E2_STEP_PIN, E2_DIR_PIN, E2_ENABLE_PIN, HEATER_2_PIN,</front>
<front id="pinsH-2205">#else</front>
<front id="pinsH-2206">  #define _E2_PINS</front>
<front id="pinsH-2207">#endif</front>
<front id="pinsH-2208"></front>
<front id="pinsH-2209">#ifdef X_STOP_PIN</front>
<front id="pinsH-2210">  #if X_HOME_DIR &lt; 0</front>
<front id="pinsH-2211">    #define X_MIN_PIN X_STOP_PIN</front>
<front id="pinsH-2212">    #define X_MAX_PIN -1</front>
<front id="pinsH-2213">  #else</front>
<front id="pinsH-2214">    #define X_MIN_PIN -1</front>
<front id="pinsH-2215">    #define X_MAX_PIN X_STOP_PIN</front>
<front id="pinsH-2216">  #endif</front>
<front id="pinsH-2217">#endif</front>
<front id="pinsH-2218"></front>
<front id="pinsH-2219">#ifdef Y_STOP_PIN</front>
<front id="pinsH-2220">  #if Y_HOME_DIR &lt; 0</front>
<front id="pinsH-2221">    #define Y_MIN_PIN Y_STOP_PIN</front>
<front id="pinsH-2222">    #define Y_MAX_PIN -1</front>
<front id="pinsH-2223">  #else</front>
<front id="pinsH-2224">    #define Y_MIN_PIN -1</front>
<front id="pinsH-2225">    #define Y_MAX_PIN Y_STOP_PIN</front>
<front id="pinsH-2226">  #endif</front>
<front id="pinsH-2227">#endif</front>
<front id="pinsH-2228"></front>
<front id="pinsH-2229">#ifdef Z_STOP_PIN</front>
<front id="pinsH-2230">  #if Z_HOME_DIR &lt; 0</front>
<front id="pinsH-2231">    #define Z_MIN_PIN Z_STOP_PIN</front>
<front id="pinsH-2232">    #define Z_MAX_PIN -1</front>
<front id="pinsH-2233">  #else</front>
<front id="pinsH-2234">    #define Z_MIN_PIN -1</front>
<front id="pinsH-2235">    #define Z_MAX_PIN Z_STOP_PIN</front>
<front id="pinsH-2236">  #endif</front>
<front id="pinsH-2237">#endif</front>
<front id="pinsH-2238"></front>
<front id="pinsH-2239">#ifdef DISABLE_MAX_ENDSTOPS</front>
<front id="pinsH-2240">#define X_MAX_PIN          -1</front>
<front id="pinsH-2241">#define Y_MAX_PIN          -1</front>
<front id="pinsH-2242">#define Z_MAX_PIN          -1</front>
<front id="pinsH-2243">#endif</front>
<front id="pinsH-2244"></front>
<front id="pinsH-2245">#ifdef DISABLE_MIN_ENDSTOPS</front>
<front id="pinsH-2246">#define X_MIN_PIN          -1</front>
<front id="pinsH-2247">#define Y_MIN_PIN          -1</front>
<front id="pinsH-2248">#define Z_MIN_PIN          -1</front>
<front id="pinsH-2249">#endif</front>
<front id="pinsH-2250"></front>
<front id="pinsH-2251">#define SENSITIVE_PINS {0, 1, X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, PS_ON_PIN, \</front>
<front id="pinsH-2252">                        HEATER_BED_PIN, FAN_PIN,                  \</front>
<front id="pinsH-2253">                        _E0_PINS _E1_PINS _E2_PINS             \</front>
<front id="pinsH-2254">                        analogInputToDigitalPin(TEMP_0_PIN), analogInputToDigitalPin(TEMP_1_PIN), analogInputToDigitalPin(TEMP_2_PIN), analogInputToDigitalPin(TEMP_BED_PIN) }</front>
<front id="pinsH-2255">#endif</front>
<front id="pinsH-2256"></front>
 </pre>
<h1>planner.cpp</h1>
<pre  class="prettyprint linenums"><front id="plannerCPP-1">/*</front>
<front id="plannerCPP-2">  planner.c - buffers movement commands and manages the acceleration profile plan</front>
<front id="plannerCPP-3"> Part of Grbl</front>
<front id="plannerCPP-4"> </front>
<front id="plannerCPP-5"> Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="plannerCPP-6"> </front>
<front id="plannerCPP-7"> Grbl is free software: you can redistribute it and/or modify</front>
<front id="plannerCPP-8"> it under the terms of the GNU General Public License as published by</front>
<front id="plannerCPP-9"> the Free Software Foundation, either version 3 of the License, or</front>
<front id="plannerCPP-10"> (at your option) any later version.</front>
<front id="plannerCPP-11"> </front>
<front id="plannerCPP-12"> Grbl is distributed in the hope that it will be useful,</front>
<front id="plannerCPP-13"> but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="plannerCPP-14"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="plannerCPP-15"> GNU General Public License for more details.</front>
<front id="plannerCPP-16"> </front>
<front id="plannerCPP-17"> You should have received a copy of the GNU General Public License</front>
<front id="plannerCPP-18"> along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="plannerCPP-19"> */</front>
<front id="plannerCPP-20"></front>
<front id="plannerCPP-21">/* The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis. */</front>
<front id="plannerCPP-22"></front>
<front id="plannerCPP-23">/*  </front>
<front id="plannerCPP-24"> Reasoning behind the mathematics in this module (in the key of 'Mathematica'):</front>
<front id="plannerCPP-25"> </front>
<front id="plannerCPP-26"> s == speed, a == acceleration, t == time, d == distance</front>
<front id="plannerCPP-27"> </front>
<front id="plannerCPP-28"> Basic definitions:</front>
<front id="plannerCPP-29"> </front>
<front id="plannerCPP-30"> Speed[s_, a_, t_] := s + (a*t) </front>
<front id="plannerCPP-31"> Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]</front>
<front id="plannerCPP-32"> </front>
<front id="plannerCPP-33"> Distance to reach a specific speed with a constant acceleration:</front>
<front id="plannerCPP-34"> </front>
<front id="plannerCPP-35"> Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]</front>
<front id="plannerCPP-36"> d -&gt; (m^2 - s^2)/(2 a) --&gt; estimate_acceleration_distance()</front>
<front id="plannerCPP-37"> </front>
<front id="plannerCPP-38"> Speed after a given distance of travel with constant acceleration:</front>
<front id="plannerCPP-39"> </front>
<front id="plannerCPP-40"> Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]</front>
<front id="plannerCPP-41"> m -&gt; Sqrt[2 a d + s^2]    </front>
<front id="plannerCPP-42"> </front>
<front id="plannerCPP-43"> DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]</front>
<front id="plannerCPP-44"> </front>
<front id="plannerCPP-45"> When to start braking (di) to reach a specified destionation speed (s2) after accelerating</front>
<front id="plannerCPP-46"> from initial speed s1 without ever stopping at a plateau:</front>
<front id="plannerCPP-47"> </front>
<front id="plannerCPP-48"> Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]</front>
<front id="plannerCPP-49"> di -&gt; (2 a d - s1^2 + s2^2)/(4 a) --&gt; intersection_distance()</front>
<front id="plannerCPP-50"> </front>
<front id="plannerCPP-51"> IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)</front>
<front id="plannerCPP-52"> */</front>
<front id="plannerCPP-53"></front>
<front id="plannerCPP-54">#include "Marlin.h"</front>
<front id="plannerCPP-55">#include "planner.h"</front>
<front id="plannerCPP-56">#include "stepper.h"</front>
<front id="plannerCPP-57">#include "temperature.h"</front>
<front id="plannerCPP-58">#include "ultralcd.h"</front>
<front id="plannerCPP-59">#include "language.h"</front>
<front id="plannerCPP-60"></front>
<front id="plannerCPP-61">//===========================================================================</front>
<front id="plannerCPP-62">//=============================public variables ============================</front>
<front id="plannerCPP-63">//===========================================================================</front>
<front id="plannerCPP-64"></front>
<front id="plannerCPP-65">unsigned long minsegmenttime;</front>
<front id="plannerCPP-66">float max_feedrate[4]; // set the max speeds</front>
<front id="plannerCPP-67">float axis_steps_per_unit[4];</front>
<front id="plannerCPP-68">unsigned long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software</front>
<front id="plannerCPP-69">float minimumfeedrate;</front>
<front id="plannerCPP-70">float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX</front>
<front id="plannerCPP-71">float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX</front>
<front id="plannerCPP-72">float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.</front>
<front id="plannerCPP-73">float max_z_jerk;</front>
<front id="plannerCPP-74">float max_e_jerk;</front>
<front id="plannerCPP-75">float mintravelfeedrate;</front>
<front id="plannerCPP-76">unsigned long axis_steps_per_sqr_second[NUM_AXIS];</front>
<front id="plannerCPP-77"></front>
<front id="plannerCPP-78">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-79">// this holds the required transform to compensate for bed level</front>
<front id="plannerCPP-80">matrix_3x3 plan_bed_level_matrix = {</front>
<front id="plannerCPP-81">	1.0, 0.0, 0.0,</front>
<front id="plannerCPP-82">	0.0, 1.0, 0.0,</front>
<front id="plannerCPP-83">	0.0, 0.0, 1.0,</front>
<front id="plannerCPP-84">};</front>
<front id="plannerCPP-85">#endif // #ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-86"></front>
<front id="plannerCPP-87">// The current position of the tool in absolute steps</front>
<front id="plannerCPP-88">long position[4];   //rescaled from extern when axis_steps_per_unit are changed by gcode</front>
<front id="plannerCPP-89">static float previous_speed[4]; // Speed of previous path line segment</front>
<front id="plannerCPP-90">static float previous_nominal_speed; // Nominal speed of previous path line segment</front>
<front id="plannerCPP-91"></front>
<front id="plannerCPP-92">#ifdef AUTOTEMP</front>
<front id="plannerCPP-93">float autotemp_max=250;</front>
<front id="plannerCPP-94">float autotemp_min=210;</front>
<front id="plannerCPP-95">float autotemp_factor=0.1;</front>
<front id="plannerCPP-96">bool autotemp_enabled=false;</front>
<front id="plannerCPP-97">#endif</front>
<front id="plannerCPP-98"></front>
<front id="plannerCPP-99">//===========================================================================</front>
<front id="plannerCPP-100">//=================semi-private variables, used in inline  functions    =====</front>
<front id="plannerCPP-101">//===========================================================================</front>
<front id="plannerCPP-102">block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions</front>
<front id="plannerCPP-103">volatile unsigned char block_buffer_head;           // Index of the next block to be pushed</front>
<front id="plannerCPP-104">volatile unsigned char block_buffer_tail;           // Index of the block to process now</front>
<front id="plannerCPP-105"></front>
<front id="plannerCPP-106">//===========================================================================</front>
<front id="plannerCPP-107">//=============================private variables ============================</front>
<front id="plannerCPP-108">//===========================================================================</front>
<front id="plannerCPP-109">#ifdef PREVENT_DANGEROUS_EXTRUDE</front>
<front id="plannerCPP-110">float extrude_min_temp=EXTRUDE_MINTEMP;</front>
<front id="plannerCPP-111">#endif</front>
<front id="plannerCPP-112">#ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-113">#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)</front>
<front id="plannerCPP-114">// Used for the frequency limit</front>
<front id="plannerCPP-115">static unsigned char old_direction_bits = 0;               // Old direction bits. Used for speed calculations</front>
<front id="plannerCPP-116">static long x_segment_time[3]={MAX_FREQ_TIME + 1,0,0};     // Segment times (in us). Used for speed calculations</front>
<front id="plannerCPP-117">static long y_segment_time[3]={MAX_FREQ_TIME + 1,0,0};</front>
<front id="plannerCPP-118">#endif</front>
<front id="plannerCPP-119"></front>
<front id="plannerCPP-120">// Returns the index of the next block in the ring buffer</front>
<front id="plannerCPP-121">// NOTE: Removed modulo (%) operator, which uses an expensive divide and multiplication.</front>
<front id="plannerCPP-122">static int8_t next_block_index(int8_t block_index) {</front>
<front id="plannerCPP-123">  block_index++;</front>
<front id="plannerCPP-124">  if (block_index == BLOCK_BUFFER_SIZE) { </front>
<front id="plannerCPP-125">    block_index = 0; </front>
<front id="plannerCPP-126">  }</front>
<front id="plannerCPP-127">  return(block_index);</front>
<front id="plannerCPP-128">}</front>
<front id="plannerCPP-129"></front>
<front id="plannerCPP-130"></front>
<front id="plannerCPP-131">// Returns the index of the previous block in the ring buffer</front>
<front id="plannerCPP-132">static int8_t prev_block_index(int8_t block_index) {</front>
<front id="plannerCPP-133">  if (block_index == 0) { </front>
<front id="plannerCPP-134">    block_index = BLOCK_BUFFER_SIZE; </front>
<front id="plannerCPP-135">  }</front>
<front id="plannerCPP-136">  block_index--;</front>
<front id="plannerCPP-137">  return(block_index);</front>
<front id="plannerCPP-138">}</front>
<front id="plannerCPP-139"></front>
<front id="plannerCPP-140">//===========================================================================</front>
<front id="plannerCPP-141">//=============================functions         ============================</front>
<front id="plannerCPP-142">//===========================================================================</front>
<front id="plannerCPP-143"></front>
<front id="plannerCPP-144">// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the </front>
<front id="plannerCPP-145">// given acceleration:</front>
<front id="plannerCPP-146">FORCE_INLINE float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration)</front>
<front id="plannerCPP-147">{</front>
<front id="plannerCPP-148">  if (acceleration!=0) {</front>
<front id="plannerCPP-149">    return((target_rate*target_rate-initial_rate*initial_rate)/</front>
<front id="plannerCPP-150">      (2.0*acceleration));</front>
<front id="plannerCPP-151">  }</front>
<front id="plannerCPP-152">  else {</front>
<front id="plannerCPP-153">    return 0.0;  // acceleration was 0, set acceleration distance to 0</front>
<front id="plannerCPP-154">  }</front>
<front id="plannerCPP-155">}</front>
<front id="plannerCPP-156"></front>
<front id="plannerCPP-157">// This function gives you the point at which you must start braking (at the rate of -acceleration) if </front>
<front id="plannerCPP-158">// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after</front>
<front id="plannerCPP-159">// a total travel of distance. This can be used to compute the intersection point between acceleration and</front>
<front id="plannerCPP-160">// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)</front>
<front id="plannerCPP-161"></front>
<front id="plannerCPP-162">FORCE_INLINE float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) </front>
<front id="plannerCPP-163">{</front>
<front id="plannerCPP-164">  if (acceleration!=0) {</front>
<front id="plannerCPP-165">    return((2.0*acceleration*distance-initial_rate*initial_rate+final_rate*final_rate)/</front>
<front id="plannerCPP-166">      (4.0*acceleration) );</front>
<front id="plannerCPP-167">  }</front>
<front id="plannerCPP-168">  else {</front>
<front id="plannerCPP-169">    return 0.0;  // acceleration was 0, set intersection distance to 0</front>
<front id="plannerCPP-170">  }</front>
<front id="plannerCPP-171">}</front>
<front id="plannerCPP-172"></front>
<front id="plannerCPP-173">// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.</front>
<front id="plannerCPP-174"></front>
<front id="plannerCPP-175">void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exit_factor) {</front>
<front id="plannerCPP-176">  unsigned long initial_rate = ceil(block-&gt;nominal_rate*entry_factor); // (step/min)</front>
<front id="plannerCPP-177">  unsigned long final_rate = ceil(block-&gt;nominal_rate*exit_factor); // (step/min)</front>
<front id="plannerCPP-178"></front>
<front id="plannerCPP-179">  // Limit minimal step rate (Otherwise the timer will overflow.)</front>
<front id="plannerCPP-180">  if(initial_rate &lt;120) {</front>
<front id="plannerCPP-181">    initial_rate=120; </front>
<front id="plannerCPP-182">  }</front>
<front id="plannerCPP-183">  if(final_rate &lt; 120) {</front>
<front id="plannerCPP-184">    final_rate=120;  </front>
<front id="plannerCPP-185">  }</front>
<front id="plannerCPP-186"></front>
<front id="plannerCPP-187">  long acceleration = block-&gt;acceleration_st;</front>
<front id="plannerCPP-188">  int32_t accelerate_steps =</front>
<front id="plannerCPP-189">    ceil(estimate_acceleration_distance(block-&gt;initial_rate, block-&gt;nominal_rate, acceleration));</front>
<front id="plannerCPP-190">  int32_t decelerate_steps =</front>
<front id="plannerCPP-191">    floor(estimate_acceleration_distance(block-&gt;nominal_rate, block-&gt;final_rate, -acceleration));</front>
<front id="plannerCPP-192"></front>
<front id="plannerCPP-193">  // Calculate the size of Plateau of Nominal Rate.</front>
<front id="plannerCPP-194">  int32_t plateau_steps = block-&gt;step_event_count-accelerate_steps-decelerate_steps;</front>
<front id="plannerCPP-195"></front>
<front id="plannerCPP-196">  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will</front>
<front id="plannerCPP-197">  // have to use intersection_distance() to calculate when to abort acceleration and start braking</front>
<front id="plannerCPP-198">  // in order to reach the final_rate exactly at the end of this block.</front>
<front id="plannerCPP-199">  if (plateau_steps &lt; 0) {</front>
<front id="plannerCPP-200">    accelerate_steps = ceil(intersection_distance(block-&gt;initial_rate, block-&gt;final_rate, acceleration, block-&gt;step_event_count));</front>
<front id="plannerCPP-201">    accelerate_steps = max(accelerate_steps,0); // Check limits due to numerical round-off</front>
<front id="plannerCPP-202">    accelerate_steps = min((uint32_t)accelerate_steps,block-&gt;step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)</front>
<front id="plannerCPP-203">    plateau_steps = 0;</front>
<front id="plannerCPP-204">  }</front>
<front id="plannerCPP-205"></front>
<front id="plannerCPP-206">#ifdef ADVANCE</front>
<front id="plannerCPP-207">  volatile long initial_advance = block-&gt;advance*entry_factor*entry_factor; </front>
<front id="plannerCPP-208">  volatile long final_advance = block-&gt;advance*exit_factor*exit_factor;</front>
<front id="plannerCPP-209">#endif // ADVANCE</front>
<front id="plannerCPP-210"></front>
<front id="plannerCPP-211">  // block-&gt;accelerate_until = accelerate_steps;</front>
<front id="plannerCPP-212">  // block-&gt;decelerate_after = accelerate_steps+plateau_steps;</front>
<front id="plannerCPP-213">  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section</front>
<front id="plannerCPP-214">  if(block-&gt;busy == false) { // Don't update variables if block is busy.</front>
<front id="plannerCPP-215">    block-&gt;accelerate_until = accelerate_steps;</front>
<front id="plannerCPP-216">    block-&gt;decelerate_after = accelerate_steps+plateau_steps;</front>
<front id="plannerCPP-217">    block-&gt;initial_rate = initial_rate;</front>
<front id="plannerCPP-218">    block-&gt;final_rate = final_rate;</front>
<front id="plannerCPP-219">#ifdef ADVANCE</front>
<front id="plannerCPP-220">    block-&gt;initial_advance = initial_advance;</front>
<front id="plannerCPP-221">    block-&gt;final_advance = final_advance;</front>
<front id="plannerCPP-222">#endif //ADVANCE</front>
<front id="plannerCPP-223">  }</front>
<front id="plannerCPP-224">  CRITICAL_SECTION_END;</front>
<front id="plannerCPP-225">}                    </front>
<front id="plannerCPP-226"></front>
<front id="plannerCPP-227">// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the </front>
<front id="plannerCPP-228">// acceleration within the allotted distance.</front>
<front id="plannerCPP-229">FORCE_INLINE float max_allowable_speed(float acceleration, float target_velocity, float distance) {</front>
<front id="plannerCPP-230">  return  sqrt(target_velocity*target_velocity-2*acceleration*distance);</front>
<front id="plannerCPP-231">}</front>
<front id="plannerCPP-232"></front>
<front id="plannerCPP-233">// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.</front>
<front id="plannerCPP-234">// This method will calculate the junction jerk as the euclidean distance between the nominal </front>
<front id="plannerCPP-235">// velocities of the respective blocks.</front>
<front id="plannerCPP-236">//inline float junction_jerk(block_t *before, block_t *after) {</front>
<front id="plannerCPP-237">//  return sqrt(</front>
<front id="plannerCPP-238">//    pow((before-&gt;speed_x-after-&gt;speed_x), 2)+pow((before-&gt;speed_y-after-&gt;speed_y), 2));</front>
<front id="plannerCPP-239">//}</front>
<front id="plannerCPP-240"></front>
<front id="plannerCPP-241"></front>
<front id="plannerCPP-242">// The kernel called by planner_recalculate() when scanning the plan from last to first entry.</front>
<front id="plannerCPP-243">void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {</front>
<front id="plannerCPP-244">  if(!current) { </front>
<front id="plannerCPP-245">    return; </front>
<front id="plannerCPP-246">  }</front>
<front id="plannerCPP-247"></front>
<front id="plannerCPP-248">  if (next) {</front>
<front id="plannerCPP-249">    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.</front>
<front id="plannerCPP-250">    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and</front>
<front id="plannerCPP-251">    // check for maximum allowable speed reductions to ensure maximum possible planned speed.</front>
<front id="plannerCPP-252">    if (current-&gt;entry_speed != current-&gt;max_entry_speed) {</front>
<front id="plannerCPP-253"></front>
<front id="plannerCPP-254">      // If nominal length true, max junction speed is guaranteed to be reached. Only compute</front>
<front id="plannerCPP-255">      // for max allowable speed if block is decelerating and nominal length is false.</front>
<front id="plannerCPP-256">      if ((!current-&gt;nominal_length_flag) && (current-&gt;max_entry_speed &gt; next-&gt;entry_speed)) {</front>
<front id="plannerCPP-257">        current-&gt;entry_speed = min( current-&gt;max_entry_speed,</front>
<front id="plannerCPP-258">        max_allowable_speed(-current-&gt;acceleration,next-&gt;entry_speed,current-&gt;millimeters));</front>
<front id="plannerCPP-259">      } </front>
<front id="plannerCPP-260">      else {</front>
<front id="plannerCPP-261">        current-&gt;entry_speed = current-&gt;max_entry_speed;</front>
<front id="plannerCPP-262">      }</front>
<front id="plannerCPP-263">      current-&gt;recalculate_flag = true;</front>
<front id="plannerCPP-264"></front>
<front id="plannerCPP-265">    }</front>
<front id="plannerCPP-266">  } // Skip last block. Already initialized and set for recalculation.</front>
<front id="plannerCPP-267">}</front>
<front id="plannerCPP-268"></front>
<front id="plannerCPP-269">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This </front>
<front id="plannerCPP-270">// implements the reverse pass.</front>
<front id="plannerCPP-271">void planner_reverse_pass() {</front>
<front id="plannerCPP-272">  uint8_t block_index = block_buffer_head;</front>
<front id="plannerCPP-273">  </front>
<front id="plannerCPP-274">  //Make a local copy of block_buffer_tail, because the interrupt can alter it</front>
<front id="plannerCPP-275">  CRITICAL_SECTION_START;</front>
<front id="plannerCPP-276">  unsigned char tail = block_buffer_tail;</front>
<front id="plannerCPP-277">  CRITICAL_SECTION_END</front>
<front id="plannerCPP-278">  </front>
<front id="plannerCPP-279">  if(((block_buffer_head-tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1)) &gt; 3) {</front>
<front id="plannerCPP-280">    block_index = (block_buffer_head - 3) & (BLOCK_BUFFER_SIZE - 1);</front>
<front id="plannerCPP-281">    block_t *block[3] = { </front>
<front id="plannerCPP-282">      NULL, NULL, NULL         };</front>
<front id="plannerCPP-283">    while(block_index != tail) { </front>
<front id="plannerCPP-284">      block_index = prev_block_index(block_index); </front>
<front id="plannerCPP-285">      block[2]= block[1];</front>
<front id="plannerCPP-286">      block[1]= block[0];</front>
<front id="plannerCPP-287">      block[0] = &block_buffer[block_index];</front>
<front id="plannerCPP-288">      planner_reverse_pass_kernel(block[0], block[1], block[2]);</front>
<front id="plannerCPP-289">    }</front>
<front id="plannerCPP-290">  }</front>
<front id="plannerCPP-291">}</front>
<front id="plannerCPP-292"></front>
<front id="plannerCPP-293">// The kernel called by planner_recalculate() when scanning the plan from first to last entry.</front>
<front id="plannerCPP-294">void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {</front>
<front id="plannerCPP-295">  if(!previous) { </front>
<front id="plannerCPP-296">    return; </front>
<front id="plannerCPP-297">  }</front>
<front id="plannerCPP-298"></front>
<front id="plannerCPP-299">  // If the previous block is an acceleration block, but it is not long enough to complete the</front>
<front id="plannerCPP-300">  // full speed change within the block, we need to adjust the entry speed accordingly. Entry</front>
<front id="plannerCPP-301">  // speeds have already been reset, maximized, and reverse planned by reverse planner.</front>
<front id="plannerCPP-302">  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.</front>
<front id="plannerCPP-303">  if (!previous-&gt;nominal_length_flag) {</front>
<front id="plannerCPP-304">    if (previous-&gt;entry_speed &lt; current-&gt;entry_speed) {</front>
<front id="plannerCPP-305">      double entry_speed = min( current-&gt;entry_speed,</front>
<front id="plannerCPP-306">      max_allowable_speed(-previous-&gt;acceleration,previous-&gt;entry_speed,previous-&gt;millimeters) );</front>
<front id="plannerCPP-307"></front>
<front id="plannerCPP-308">      // Check for junction speed change</front>
<front id="plannerCPP-309">      if (current-&gt;entry_speed != entry_speed) {</front>
<front id="plannerCPP-310">        current-&gt;entry_speed = entry_speed;</front>
<front id="plannerCPP-311">        current-&gt;recalculate_flag = true;</front>
<front id="plannerCPP-312">      }</front>
<front id="plannerCPP-313">    }</front>
<front id="plannerCPP-314">  }</front>
<front id="plannerCPP-315">}</front>
<front id="plannerCPP-316"></front>
<front id="plannerCPP-317">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This </front>
<front id="plannerCPP-318">// implements the forward pass.</front>
<front id="plannerCPP-319">void planner_forward_pass() {</front>
<front id="plannerCPP-320">  uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-321">  block_t *block[3] = { </front>
<front id="plannerCPP-322">    NULL, NULL, NULL   };</front>
<front id="plannerCPP-323"></front>
<front id="plannerCPP-324">  while(block_index != block_buffer_head) {</front>
<front id="plannerCPP-325">    block[0] = block[1];</front>
<front id="plannerCPP-326">    block[1] = block[2];</front>
<front id="plannerCPP-327">    block[2] = &block_buffer[block_index];</front>
<front id="plannerCPP-328">    planner_forward_pass_kernel(block[0],block[1],block[2]);</front>
<front id="plannerCPP-329">    block_index = next_block_index(block_index);</front>
<front id="plannerCPP-330">  }</front>
<front id="plannerCPP-331">  planner_forward_pass_kernel(block[1], block[2], NULL);</front>
<front id="plannerCPP-332">}</front>
<front id="plannerCPP-333"></front>
<front id="plannerCPP-334">// Recalculates the trapezoid speed profiles for all blocks in the plan according to the </front>
<front id="plannerCPP-335">// entry_factor for each junction. Must be called by planner_recalculate() after </front>
<front id="plannerCPP-336">// updating the blocks.</front>
<front id="plannerCPP-337">void planner_recalculate_trapezoids() {</front>
<front id="plannerCPP-338">  int8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-339">  block_t *current;</front>
<front id="plannerCPP-340">  block_t *next = NULL;</front>
<front id="plannerCPP-341"></front>
<front id="plannerCPP-342">  while(block_index != block_buffer_head) {</front>
<front id="plannerCPP-343">    current = next;</front>
<front id="plannerCPP-344">    next = &block_buffer[block_index];</front>
<front id="plannerCPP-345">    if (current) {</front>
<front id="plannerCPP-346">      // Recalculate if current block entry or exit junction speed has changed.</front>
<front id="plannerCPP-347">      if (current-&gt;recalculate_flag || next-&gt;recalculate_flag) {</front>
<front id="plannerCPP-348">        // NOTE: Entry and exit factors always &gt; 0 by all previous logic operations.</front>
<front id="plannerCPP-349">        calculate_trapezoid_for_block(current, current-&gt;entry_speed/current-&gt;nominal_speed,</front>
<front id="plannerCPP-350">        next-&gt;entry_speed/current-&gt;nominal_speed);</front>
<front id="plannerCPP-351">        current-&gt;recalculate_flag = false; // Reset current only to ensure next trapezoid is computed</front>
<front id="plannerCPP-352">      }</front>
<front id="plannerCPP-353">    }</front>
<front id="plannerCPP-354">    block_index = next_block_index( block_index );</front>
<front id="plannerCPP-355">  }</front>
<front id="plannerCPP-356">  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.</front>
<front id="plannerCPP-357">  if(next != NULL) {</front>
<front id="plannerCPP-358">    calculate_trapezoid_for_block(next, next-&gt;entry_speed/next-&gt;nominal_speed,</front>
<front id="plannerCPP-359">    MINIMUM_PLANNER_SPEED/next-&gt;nominal_speed);</front>
<front id="plannerCPP-360">    next-&gt;recalculate_flag = false;</front>
<front id="plannerCPP-361">  }</front>
<front id="plannerCPP-362">}</front>
<front id="plannerCPP-363"></front>
<front id="plannerCPP-364">// Recalculates the motion plan according to the following algorithm:</front>
<front id="plannerCPP-365">//</front>
<front id="plannerCPP-366">//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) </front>
<front id="plannerCPP-367">//      so that:</front>
<front id="plannerCPP-368">//     a. The junction jerk is within the set limit</front>
<front id="plannerCPP-369">//     b. No speed reduction within one block requires faster deceleration than the one, true constant </front>
<front id="plannerCPP-370">//        acceleration.</front>
<front id="plannerCPP-371">//   2. Go over every block in chronological order and dial down junction speed reduction values if </front>
<front id="plannerCPP-372">//     a. The speed increase within one block would require faster accelleration than the one, true </front>
<front id="plannerCPP-373">//        constant acceleration.</front>
<front id="plannerCPP-374">//</front>
<front id="plannerCPP-375">// When these stages are complete all blocks have an entry_factor that will allow all speed changes to </front>
<front id="plannerCPP-376">// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than </front>
<front id="plannerCPP-377">// the set limit. Finally it will:</front>
<front id="plannerCPP-378">//</front>
<front id="plannerCPP-379">//   3. Recalculate trapezoids for all blocks.</front>
<front id="plannerCPP-380"></front>
<front id="plannerCPP-381">void planner_recalculate() {   </front>
<front id="plannerCPP-382">  planner_reverse_pass();</front>
<front id="plannerCPP-383">  planner_forward_pass();</front>
<front id="plannerCPP-384">  planner_recalculate_trapezoids();</front>
<front id="plannerCPP-385">}</front>
<front id="plannerCPP-386"></front>
<front id="plannerCPP-387">void plan_init() {</front>
<front id="plannerCPP-388">  block_buffer_head = 0;</front>
<front id="plannerCPP-389">  block_buffer_tail = 0;</front>
<front id="plannerCPP-390">  memset(position, 0, sizeof(position)); // clear position</front>
<front id="plannerCPP-391">  previous_speed[0] = 0.0;</front>
<front id="plannerCPP-392">  previous_speed[1] = 0.0;</front>
<front id="plannerCPP-393">  previous_speed[2] = 0.0;</front>
<front id="plannerCPP-394">  previous_speed[3] = 0.0;</front>
<front id="plannerCPP-395">  previous_nominal_speed = 0.0;</front>
<front id="plannerCPP-396">}</front>
<front id="plannerCPP-397"></front>
<front id="plannerCPP-398"></front>
<front id="plannerCPP-399"></front>
<front id="plannerCPP-400"></front>
<front id="plannerCPP-401">#ifdef AUTOTEMP</front>
<front id="plannerCPP-402">void getHighESpeed()</front>
<front id="plannerCPP-403">{</front>
<front id="plannerCPP-404">  static float oldt=0;</front>
<front id="plannerCPP-405">  if(!autotemp_enabled){</front>
<front id="plannerCPP-406">    return;</front>
<front id="plannerCPP-407">  }</front>
<front id="plannerCPP-408">  if(degTargetHotend0()+2&lt;autotemp_min) {  //probably temperature set to zero.</front>
<front id="plannerCPP-409">    return; //do nothing</front>
<front id="plannerCPP-410">  }</front>
<front id="plannerCPP-411"></front>
<front id="plannerCPP-412">  float high=0.0;</front>
<front id="plannerCPP-413">  uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-414"></front>
<front id="plannerCPP-415">  while(block_index != block_buffer_head) {</front>
<front id="plannerCPP-416">    if((block_buffer[block_index].steps_x != 0) ||</front>
<front id="plannerCPP-417">      (block_buffer[block_index].steps_y != 0) ||</front>
<front id="plannerCPP-418">      (block_buffer[block_index].steps_z != 0)) {</front>
<front id="plannerCPP-419">      float se=(float(block_buffer[block_index].steps_e)/float(block_buffer[block_index].step_event_count))*block_buffer[block_index].nominal_speed;</front>
<front id="plannerCPP-420">      //se; mm/sec;</front>
<front id="plannerCPP-421">      if(se&gt;high)</front>
<front id="plannerCPP-422">      {</front>
<front id="plannerCPP-423">        high=se;</front>
<front id="plannerCPP-424">      }</front>
<front id="plannerCPP-425">    }</front>
<front id="plannerCPP-426">    block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);</front>
<front id="plannerCPP-427">  }</front>
<front id="plannerCPP-428"></front>
<front id="plannerCPP-429">  float g=autotemp_min+high*autotemp_factor;</front>
<front id="plannerCPP-430">  float t=g;</front>
<front id="plannerCPP-431">  if(t&lt;autotemp_min)</front>
<front id="plannerCPP-432">    t=autotemp_min;</front>
<front id="plannerCPP-433">  if(t&gt;autotemp_max)</front>
<front id="plannerCPP-434">    t=autotemp_max;</front>
<front id="plannerCPP-435">  if(oldt&gt;t)</front>
<front id="plannerCPP-436">  {</front>
<front id="plannerCPP-437">    t=AUTOTEMP_OLDWEIGHT*oldt+(1-AUTOTEMP_OLDWEIGHT)*t;</front>
<front id="plannerCPP-438">  }</front>
<front id="plannerCPP-439">  oldt=t;</front>
<front id="plannerCPP-440">  setTargetHotend0(t);</front>
<front id="plannerCPP-441">}</front>
<front id="plannerCPP-442">#endif</front>
<front id="plannerCPP-443"></front>
<front id="plannerCPP-444">void check_axes_activity()</front>
<front id="plannerCPP-445">{</front>
<front id="plannerCPP-446">  unsigned char x_active = 0;</front>
<front id="plannerCPP-447">  unsigned char y_active = 0;  </front>
<front id="plannerCPP-448">  unsigned char z_active = 0;</front>
<front id="plannerCPP-449">  unsigned char e_active = 0;</front>
<front id="plannerCPP-450">  unsigned char tail_fan_speed = fanSpeed;</front>
<front id="plannerCPP-451">  #ifdef BARICUDA</front>
<front id="plannerCPP-452">  unsigned char tail_valve_pressure = ValvePressure;</front>
<front id="plannerCPP-453">  unsigned char tail_e_to_p_pressure = EtoPPressure;</front>
<front id="plannerCPP-454">  #endif</front>
<front id="plannerCPP-455">  block_t *block;</front>
<front id="plannerCPP-456"></front>
<front id="plannerCPP-457">  if(block_buffer_tail != block_buffer_head)</front>
<front id="plannerCPP-458">  {</front>
<front id="plannerCPP-459">    uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-460">    tail_fan_speed = block_buffer[block_index].fan_speed;</front>
<front id="plannerCPP-461">    #ifdef BARICUDA</front>
<front id="plannerCPP-462">    tail_valve_pressure = block_buffer[block_index].valve_pressure;</front>
<front id="plannerCPP-463">    tail_e_to_p_pressure = block_buffer[block_index].e_to_p_pressure;</front>
<front id="plannerCPP-464">    #endif</front>
<front id="plannerCPP-465">    while(block_index != block_buffer_head)</front>
<front id="plannerCPP-466">    {</front>
<front id="plannerCPP-467">      block = &block_buffer[block_index];</front>
<front id="plannerCPP-468">      if(block-&gt;steps_x != 0) x_active++;</front>
<front id="plannerCPP-469">      if(block-&gt;steps_y != 0) y_active++;</front>
<front id="plannerCPP-470">      if(block-&gt;steps_z != 0) z_active++;</front>
<front id="plannerCPP-471">      if(block-&gt;steps_e != 0) e_active++;</front>
<front id="plannerCPP-472">      block_index = (block_index+1) & (BLOCK_BUFFER_SIZE - 1);</front>
<front id="plannerCPP-473">    }</front>
<front id="plannerCPP-474">  }</front>
<front id="plannerCPP-475">  if((DISABLE_X) && (x_active == 0)) disable_x();</front>
<front id="plannerCPP-476">  if((DISABLE_Y) && (y_active == 0)) disable_y();</front>
<front id="plannerCPP-477">  if((DISABLE_Z) && (z_active == 0)) disable_z();</front>
<front id="plannerCPP-478">  if((DISABLE_E) && (e_active == 0))</front>
<front id="plannerCPP-479">  {</front>
<front id="plannerCPP-480">    disable_e0();</front>
<front id="plannerCPP-481">    disable_e1();</front>
<front id="plannerCPP-482">    disable_e2(); </front>
<front id="plannerCPP-483">  }</front>
<front id="plannerCPP-484">#if defined(FAN_PIN) && FAN_PIN &gt; -1</front>
<front id="plannerCPP-485">  #ifdef FAN_KICKSTART_TIME</front>
<front id="plannerCPP-486">    static unsigned long fan_kick_end;</front>
<front id="plannerCPP-487">    if (tail_fan_speed) {</front>
<front id="plannerCPP-488">      if (fan_kick_end == 0) {</front>
<front id="plannerCPP-489">        // Just starting up fan - run at full power.</front>
<front id="plannerCPP-490">        fan_kick_end = millis() + FAN_KICKSTART_TIME;</front>
<front id="plannerCPP-491">        tail_fan_speed = 255;</front>
<front id="plannerCPP-492">      } else if (fan_kick_end &gt; millis())</front>
<front id="plannerCPP-493">        // Fan still spinning up.</front>
<front id="plannerCPP-494">        tail_fan_speed = 255;</front>
<front id="plannerCPP-495">    } else {</front>
<front id="plannerCPP-496">      fan_kick_end = 0;</front>
<front id="plannerCPP-497">    }</front>
<front id="plannerCPP-498">  #endif//FAN_KICKSTART_TIME</front>
<front id="plannerCPP-499">  #ifdef FAN_SOFT_PWM</front>
<front id="plannerCPP-500">  fanSpeedSoftPwm = tail_fan_speed;</front>
<front id="plannerCPP-501">  #else</front>
<front id="plannerCPP-502">  analogWrite(FAN_PIN,tail_fan_speed);</front>
<front id="plannerCPP-503">  #endif//!FAN_SOFT_PWM</front>
<front id="plannerCPP-504">#endif//FAN_PIN &gt; -1</front>
<front id="plannerCPP-505">#ifdef AUTOTEMP</front>
<front id="plannerCPP-506">  getHighESpeed();</front>
<front id="plannerCPP-507">#endif</front>
<front id="plannerCPP-508"></front>
<front id="plannerCPP-509">#ifdef BARICUDA</front>
<front id="plannerCPP-510">  #if defined(HEATER_1_PIN) && HEATER_1_PIN &gt; -1</front>
<front id="plannerCPP-511">      analogWrite(HEATER_1_PIN,tail_valve_pressure);</front>
<front id="plannerCPP-512">  #endif</front>
<front id="plannerCPP-513"></front>
<front id="plannerCPP-514">  #if defined(HEATER_2_PIN) && HEATER_2_PIN &gt; -1</front>
<front id="plannerCPP-515">      analogWrite(HEATER_2_PIN,tail_e_to_p_pressure);</front>
<front id="plannerCPP-516">  #endif</front>
<front id="plannerCPP-517">#endif</front>
<front id="plannerCPP-518">}</front>
<front id="plannerCPP-519"></front>
<front id="plannerCPP-520"></front>
<front id="plannerCPP-521">float junction_deviation = 0.1;</front>
<front id="plannerCPP-522">// Add a new linear movement to the buffer. steps_x, _y and _z is the absolute position in </front>
<front id="plannerCPP-523">// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration</front>
<front id="plannerCPP-524">// calculation the caller must also provide the physical length of the line in millimeters.</front>
<front id="plannerCPP-525">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-526">void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t &extruder)</front>
<front id="plannerCPP-527">#else</front>
<front id="plannerCPP-528">void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t &extruder)</front>
<front id="plannerCPP-529">#endif  //ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-530">{</front>
<front id="plannerCPP-531">  // Calculate the buffer head after we push this byte</front>
<front id="plannerCPP-532">  int next_buffer_head = next_block_index(block_buffer_head);</front>
<front id="plannerCPP-533"></front>
<front id="plannerCPP-534">  // If the buffer is full: good! That means we are well ahead of the robot. </front>
<front id="plannerCPP-535">  // Rest here until there is room in the buffer.</front>
<front id="plannerCPP-536">  while(block_buffer_tail == next_buffer_head)</front>
<front id="plannerCPP-537">  {</front>
<front id="plannerCPP-538">    manage_heater(); </front>
<front id="plannerCPP-539">    manage_inactivity(); </front>
<front id="plannerCPP-540">    lcd_update();</front>
<front id="plannerCPP-541">  }</front>
<front id="plannerCPP-542"></front>
<front id="plannerCPP-543">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-544">  apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</front>
<front id="plannerCPP-545">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-546"></front>
<front id="plannerCPP-547">  // The target position of the tool in absolute steps</front>
<front id="plannerCPP-548">  // Calculate target position in absolute steps</front>
<front id="plannerCPP-549">  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow</front>
<front id="plannerCPP-550">  long target[4];</front>
<front id="plannerCPP-551">  target[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);</front>
<front id="plannerCPP-552">  target[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);</front>
<front id="plannerCPP-553">  target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     </front>
<front id="plannerCPP-554">  target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-555"></front>
<front id="plannerCPP-556">  #ifdef PREVENT_DANGEROUS_EXTRUDE</front>
<front id="plannerCPP-557">  if(target[E_AXIS]!=position[E_AXIS])</front>
<front id="plannerCPP-558">  {</front>
<front id="plannerCPP-559">    if(degHotend(active_extruder)&lt;extrude_min_temp)</front>
<front id="plannerCPP-560">    {</front>
<front id="plannerCPP-561">      position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part</front>
<front id="plannerCPP-562">      SERIAL_ECHO_START;</front>
<front id="plannerCPP-563">      SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);</front>
<front id="plannerCPP-564">    }</front>
<front id="plannerCPP-565">    </front>
<front id="plannerCPP-566">    #ifdef PREVENT_LENGTHY_EXTRUDE</front>
<front id="plannerCPP-567">    if(labs(target[E_AXIS]-position[E_AXIS])&gt;axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)</front>
<front id="plannerCPP-568">    {</front>
<front id="plannerCPP-569">      position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part</front>
<front id="plannerCPP-570">      SERIAL_ECHO_START;</front>
<front id="plannerCPP-571">      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);</front>
<front id="plannerCPP-572">    }</front>
<front id="plannerCPP-573">    #endif</front>
<front id="plannerCPP-574">  }</front>
<front id="plannerCPP-575">  #endif</front>
<front id="plannerCPP-576"></front>
<front id="plannerCPP-577">  // Prepare to set up new block</front>
<front id="plannerCPP-578">  block_t *block = &block_buffer[block_buffer_head];</front>
<front id="plannerCPP-579"></front>
<front id="plannerCPP-580">  // Mark block as not busy (Not executed by the stepper interrupt)</front>
<front id="plannerCPP-581">  block-&gt;busy = false;</front>
<front id="plannerCPP-582"></front>
<front id="plannerCPP-583">  // Number of steps for each axis</front>
<front id="plannerCPP-584">#ifndef COREXY</front>
<front id="plannerCPP-585">// default non-h-bot planning</front>
<front id="plannerCPP-586">block-&gt;steps_x = labs(target[X_AXIS]-position[X_AXIS]);</front>
<front id="plannerCPP-587">block-&gt;steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);</front>
<front id="plannerCPP-588">#else</front>
<front id="plannerCPP-589">// corexy planning</front>
<front id="plannerCPP-590">// these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html</front>
<front id="plannerCPP-591">block-&gt;steps_x = labs((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]));</front>
<front id="plannerCPP-592">block-&gt;steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]));</front>
<front id="plannerCPP-593">#endif</front>
<front id="plannerCPP-594">  block-&gt;steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);</front>
<front id="plannerCPP-595">  block-&gt;steps_e = labs(target[E_AXIS]-position[E_AXIS]);</front>
<front id="plannerCPP-596">  block-&gt;steps_e *= extrudemultiply;</front>
<front id="plannerCPP-597">  block-&gt;steps_e /= 100;</front>
<front id="plannerCPP-598">  block-&gt;step_event_count = max(block-&gt;steps_x, max(block-&gt;steps_y, max(block-&gt;steps_z, block-&gt;steps_e)));</front>
<front id="plannerCPP-599"></front>
<front id="plannerCPP-600">  // Bail if this is a zero-length block</front>
<front id="plannerCPP-601">  if (block-&gt;step_event_count &lt;= dropsegments)</front>
<front id="plannerCPP-602">  { </front>
<front id="plannerCPP-603">    return; </front>
<front id="plannerCPP-604">  }</front>
<front id="plannerCPP-605"></front>
<front id="plannerCPP-606">  block-&gt;fan_speed = fanSpeed;</front>
<front id="plannerCPP-607">  #ifdef BARICUDA</front>
<front id="plannerCPP-608">  block-&gt;valve_pressure = ValvePressure;</front>
<front id="plannerCPP-609">  block-&gt;e_to_p_pressure = EtoPPressure;</front>
<front id="plannerCPP-610">  #endif</front>
<front id="plannerCPP-611"></front>
<front id="plannerCPP-612">  // Compute direction bits for this block </front>
<front id="plannerCPP-613">  block-&gt;direction_bits = 0;</front>
<front id="plannerCPP-614">#ifndef COREXY</front>
<front id="plannerCPP-615">  if (target[X_AXIS] &lt; position[X_AXIS])</front>
<front id="plannerCPP-616">  {</front>
<front id="plannerCPP-617">    block-&gt;direction_bits |= (1&lt;&lt;X_AXIS); </front>
<front id="plannerCPP-618">  }</front>
<front id="plannerCPP-619">  if (target[Y_AXIS] &lt; position[Y_AXIS])</front>
<front id="plannerCPP-620">  {</front>
<front id="plannerCPP-621">    block-&gt;direction_bits |= (1&lt;&lt;Y_AXIS); </front>
<front id="plannerCPP-622">  }</front>
<front id="plannerCPP-623">#else</front>
<front id="plannerCPP-624">  if ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]) &lt; 0)</front>
<front id="plannerCPP-625">  {</front>
<front id="plannerCPP-626">    block-&gt;direction_bits |= (1&lt;&lt;X_AXIS); </front>
<front id="plannerCPP-627">  }</front>
<front id="plannerCPP-628">  if ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]) &lt; 0)</front>
<front id="plannerCPP-629">  {</front>
<front id="plannerCPP-630">    block-&gt;direction_bits |= (1&lt;&lt;Y_AXIS); </front>
<front id="plannerCPP-631">  }</front>
<front id="plannerCPP-632">#endif</front>
<front id="plannerCPP-633">  if (target[Z_AXIS] &lt; position[Z_AXIS])</front>
<front id="plannerCPP-634">  {</front>
<front id="plannerCPP-635">    block-&gt;direction_bits |= (1&lt;&lt;Z_AXIS); </front>
<front id="plannerCPP-636">  }</front>
<front id="plannerCPP-637">  if (target[E_AXIS] &lt; position[E_AXIS])</front>
<front id="plannerCPP-638">  {</front>
<front id="plannerCPP-639">    block-&gt;direction_bits |= (1&lt;&lt;E_AXIS); </front>
<front id="plannerCPP-640">  }</front>
<front id="plannerCPP-641"></front>
<front id="plannerCPP-642">  block-&gt;active_extruder = extruder;</front>
<front id="plannerCPP-643"></front>
<front id="plannerCPP-644">  //enable active axes</front>
<front id="plannerCPP-645">  #ifdef COREXY</front>
<front id="plannerCPP-646">  if((block-&gt;steps_x != 0) || (block-&gt;steps_y != 0))</front>
<front id="plannerCPP-647">  {</front>
<front id="plannerCPP-648">    enable_x();</front>
<front id="plannerCPP-649">    enable_y();</front>
<front id="plannerCPP-650">  }</front>
<front id="plannerCPP-651">  #else</front>
<front id="plannerCPP-652">  if(block-&gt;steps_x != 0) enable_x();</front>
<front id="plannerCPP-653">  if(block-&gt;steps_y != 0) enable_y();</front>
<front id="plannerCPP-654">  #endif</front>
<front id="plannerCPP-655">#ifndef Z_LATE_ENABLE</front>
<front id="plannerCPP-656">  if(block-&gt;steps_z != 0) enable_z();</front>
<front id="plannerCPP-657">#endif</front>
<front id="plannerCPP-658"></front>
<front id="plannerCPP-659">  // Enable all</front>
<front id="plannerCPP-660">  if(block-&gt;steps_e != 0)</front>
<front id="plannerCPP-661">  {</front>
<front id="plannerCPP-662">    enable_e0();</front>
<front id="plannerCPP-663">    enable_e1();</front>
<front id="plannerCPP-664">    enable_e2(); </front>
<front id="plannerCPP-665">  }</front>
<front id="plannerCPP-666"></front>
<front id="plannerCPP-667">  if (block-&gt;steps_e == 0)</front>
<front id="plannerCPP-668">  {</front>
<front id="plannerCPP-669">    if(feed_rate&lt;mintravelfeedrate) feed_rate=mintravelfeedrate;</front>
<front id="plannerCPP-670">  }</front>
<front id="plannerCPP-671">  else</front>
<front id="plannerCPP-672">  {</front>
<front id="plannerCPP-673">    if(feed_rate&lt;minimumfeedrate) feed_rate=minimumfeedrate;</front>
<front id="plannerCPP-674">  } </front>
<front id="plannerCPP-675"></front>
<front id="plannerCPP-676">  float delta_mm[4];</front>
<front id="plannerCPP-677">  #ifndef COREXY</front>
<front id="plannerCPP-678">    delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];</front>
<front id="plannerCPP-679">    delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];</front>
<front id="plannerCPP-680">  #else</front>
<front id="plannerCPP-681">    delta_mm[X_AXIS] = ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[X_AXIS];</front>
<front id="plannerCPP-682">    delta_mm[Y_AXIS] = ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[Y_AXIS];</front>
<front id="plannerCPP-683">  #endif</front>
<front id="plannerCPP-684">  delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];</front>
<front id="plannerCPP-685">  delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*extrudemultiply/100.0;</front>
<front id="plannerCPP-686">  if ( block-&gt;steps_x &lt;=dropsegments && block-&gt;steps_y &lt;=dropsegments && block-&gt;steps_z &lt;=dropsegments )</front>
<front id="plannerCPP-687">  {</front>
<front id="plannerCPP-688">    block-&gt;millimeters = fabs(delta_mm[E_AXIS]);</front>
<front id="plannerCPP-689">  } </front>
<front id="plannerCPP-690">  else</front>
<front id="plannerCPP-691">  {</front>
<front id="plannerCPP-692">    block-&gt;millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));</front>
<front id="plannerCPP-693">  }</front>
<front id="plannerCPP-694">  float inverse_millimeters = 1.0/block-&gt;millimeters;  // Inverse millimeters to remove multiple divides </front>
<front id="plannerCPP-695"></front>
<front id="plannerCPP-696">    // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.</front>
<front id="plannerCPP-697">  float inverse_second = feed_rate * inverse_millimeters;</front>
<front id="plannerCPP-698"></front>
<front id="plannerCPP-699">  int moves_queued=(block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);</front>
<front id="plannerCPP-700"></front>
<front id="plannerCPP-701">  // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill</front>
<front id="plannerCPP-702">#ifdef OLD_SLOWDOWN</front>
<front id="plannerCPP-703">  if(moves_queued &lt; (BLOCK_BUFFER_SIZE * 0.5) && moves_queued &gt; 1)</front>
<front id="plannerCPP-704">    feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); </front>
<front id="plannerCPP-705">#endif</front>
<front id="plannerCPP-706"></front>
<front id="plannerCPP-707">#ifdef SLOWDOWN</front>
<front id="plannerCPP-708">  //  segment time im micro seconds</front>
<front id="plannerCPP-709">  unsigned long segment_time = lround(1000000.0/inverse_second);</front>
<front id="plannerCPP-710">  if ((moves_queued &gt; 1) && (moves_queued &lt; (BLOCK_BUFFER_SIZE * 0.5)))</front>
<front id="plannerCPP-711">  {</front>
<front id="plannerCPP-712">    if (segment_time &lt; minsegmenttime)</front>
<front id="plannerCPP-713">    { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.</front>
<front id="plannerCPP-714">      inverse_second=1000000.0/(segment_time+lround(2*(minsegmenttime-segment_time)/moves_queued));</front>
<front id="plannerCPP-715">      #ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-716">         segment_time = lround(1000000.0/inverse_second);</front>
<front id="plannerCPP-717">      #endif</front>
<front id="plannerCPP-718">    }</front>
<front id="plannerCPP-719">  }</front>
<front id="plannerCPP-720">#endif</front>
<front id="plannerCPP-721">  //  END OF SLOW DOWN SECTION    </front>
<front id="plannerCPP-722"></front>
<front id="plannerCPP-723"></front>
<front id="plannerCPP-724">  block-&gt;nominal_speed = block-&gt;millimeters * inverse_second; // (mm/sec) Always &gt; 0</front>
<front id="plannerCPP-725">  block-&gt;nominal_rate = ceil(block-&gt;step_event_count * inverse_second); // (step/sec) Always &gt; 0</front>
<front id="plannerCPP-726"></front>
<front id="plannerCPP-727">  // Calculate and limit speed in mm/sec for each axis</front>
<front id="plannerCPP-728">  float current_speed[4];</front>
<front id="plannerCPP-729">  float speed_factor = 1.0; //factor &lt;=1 do decrease speed</front>
<front id="plannerCPP-730">  for(int i=0; i &lt; 4; i++)</front>
<front id="plannerCPP-731">  {</front>
<front id="plannerCPP-732">    current_speed[i] = delta_mm[i] * inverse_second;</front>
<front id="plannerCPP-733">    if(fabs(current_speed[i]) &gt; max_feedrate[i])</front>
<front id="plannerCPP-734">      speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));</front>
<front id="plannerCPP-735">  }</front>
<front id="plannerCPP-736"></front>
<front id="plannerCPP-737">  // Max segement time in us.</front>
<front id="plannerCPP-738">#ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-739">#define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)</front>
<front id="plannerCPP-740">  // Check and limit the xy direction change frequency</front>
<front id="plannerCPP-741">  unsigned char direction_change = block-&gt;direction_bits ^ old_direction_bits;</front>
<front id="plannerCPP-742">  old_direction_bits = block-&gt;direction_bits;</front>
<front id="plannerCPP-743">  segment_time = lround((float)segment_time / speed_factor);</front>
<front id="plannerCPP-744">  </front>
<front id="plannerCPP-745">  if((direction_change & (1&lt;&lt;X_AXIS)) == 0)</front>
<front id="plannerCPP-746">  {</front>
<front id="plannerCPP-747">    x_segment_time[0] += segment_time;</front>
<front id="plannerCPP-748">  }</front>
<front id="plannerCPP-749">  else</front>
<front id="plannerCPP-750">  {</front>
<front id="plannerCPP-751">    x_segment_time[2] = x_segment_time[1];</front>
<front id="plannerCPP-752">    x_segment_time[1] = x_segment_time[0];</front>
<front id="plannerCPP-753">    x_segment_time[0] = segment_time;</front>
<front id="plannerCPP-754">  }</front>
<front id="plannerCPP-755">  if((direction_change & (1&lt;&lt;Y_AXIS)) == 0)</front>
<front id="plannerCPP-756">  {</front>
<front id="plannerCPP-757">    y_segment_time[0] += segment_time;</front>
<front id="plannerCPP-758">  }</front>
<front id="plannerCPP-759">  else</front>
<front id="plannerCPP-760">  {</front>
<front id="plannerCPP-761">    y_segment_time[2] = y_segment_time[1];</front>
<front id="plannerCPP-762">    y_segment_time[1] = y_segment_time[0];</front>
<front id="plannerCPP-763">    y_segment_time[0] = segment_time;</front>
<front id="plannerCPP-764">  }</front>
<front id="plannerCPP-765">  long max_x_segment_time = max(x_segment_time[0], max(x_segment_time[1], x_segment_time[2]));</front>
<front id="plannerCPP-766">  long max_y_segment_time = max(y_segment_time[0], max(y_segment_time[1], y_segment_time[2]));</front>
<front id="plannerCPP-767">  long min_xy_segment_time =min(max_x_segment_time, max_y_segment_time);</front>
<front id="plannerCPP-768">  if(min_xy_segment_time &lt; MAX_FREQ_TIME)</front>
<front id="plannerCPP-769">    speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);</front>
<front id="plannerCPP-770">#endif</front>
<front id="plannerCPP-771"></front>
<front id="plannerCPP-772">  // Correct the speed  </front>
<front id="plannerCPP-773">  if( speed_factor &lt; 1.0)</front>
<front id="plannerCPP-774">  {</front>
<front id="plannerCPP-775">    for(unsigned char i=0; i &lt; 4; i++)</front>
<front id="plannerCPP-776">    {</front>
<front id="plannerCPP-777">      current_speed[i] *= speed_factor;</front>
<front id="plannerCPP-778">    }</front>
<front id="plannerCPP-779">    block-&gt;nominal_speed *= speed_factor;</front>
<front id="plannerCPP-780">    block-&gt;nominal_rate *= speed_factor;</front>
<front id="plannerCPP-781">  }</front>
<front id="plannerCPP-782"></front>
<front id="plannerCPP-783">  // Compute and limit the acceleration rate for the trapezoid generator.  </front>
<front id="plannerCPP-784">  float steps_per_mm = block-&gt;step_event_count/block-&gt;millimeters;</front>
<front id="plannerCPP-785">  if(block-&gt;steps_x == 0 && block-&gt;steps_y == 0 && block-&gt;steps_z == 0)</front>
<front id="plannerCPP-786">  {</front>
<front id="plannerCPP-787">    block-&gt;acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-788">  }</front>
<front id="plannerCPP-789">  else</front>
<front id="plannerCPP-790">  {</front>
<front id="plannerCPP-791">    block-&gt;acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-792">    // Limit acceleration per axis</front>
<front id="plannerCPP-793">    if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_x / (float)block-&gt;step_event_count) &gt; axis_steps_per_sqr_second[X_AXIS])</front>
<front id="plannerCPP-794">      block-&gt;acceleration_st = axis_steps_per_sqr_second[X_AXIS];</front>
<front id="plannerCPP-795">    if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_y / (float)block-&gt;step_event_count) &gt; axis_steps_per_sqr_second[Y_AXIS])</front>
<front id="plannerCPP-796">      block-&gt;acceleration_st = axis_steps_per_sqr_second[Y_AXIS];</front>
<front id="plannerCPP-797">    if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_e / (float)block-&gt;step_event_count) &gt; axis_steps_per_sqr_second[E_AXIS])</front>
<front id="plannerCPP-798">      block-&gt;acceleration_st = axis_steps_per_sqr_second[E_AXIS];</front>
<front id="plannerCPP-799">    if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_z / (float)block-&gt;step_event_count ) &gt; axis_steps_per_sqr_second[Z_AXIS])</front>
<front id="plannerCPP-800">      block-&gt;acceleration_st = axis_steps_per_sqr_second[Z_AXIS];</front>
<front id="plannerCPP-801">  }</front>
<front id="plannerCPP-802">  block-&gt;acceleration = block-&gt;acceleration_st / steps_per_mm;</front>
<front id="plannerCPP-803">  block-&gt;acceleration_rate = (long)((float)block-&gt;acceleration_st * (16777216.0 / (F_CPU / 8.0)));</front>
<front id="plannerCPP-804"></front>
<front id="plannerCPP-805">#if 0  // Use old jerk for now</front>
<front id="plannerCPP-806">  // Compute path unit vector</front>
<front id="plannerCPP-807">  double unit_vec[3];</front>
<front id="plannerCPP-808"></front>
<front id="plannerCPP-809">  unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-810">  unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-811">  unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-812"></front>
<front id="plannerCPP-813">  // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.</front>
<front id="plannerCPP-814">  // Let a circle be tangent to both previous and current path line segments, where the junction</front>
<front id="plannerCPP-815">  // deviation is defined as the distance from the junction to the closest edge of the circle,</front>
<front id="plannerCPP-816">  // colinear with the circle center. The circular segment joining the two paths represents the</front>
<front id="plannerCPP-817">  // path of centripetal acceleration. Solve for max velocity based on max acceleration about the</front>
<front id="plannerCPP-818">  // radius of the circle, defined indirectly by junction deviation. This may be also viewed as</front>
<front id="plannerCPP-819">  // path width or max_jerk in the previous grbl version. This approach does not actually deviate</front>
<front id="plannerCPP-820">  // from path, but used as a robust way to compute cornering speeds, as it takes into account the</front>
<front id="plannerCPP-821">  // nonlinearities of both the junction angle and junction velocity.</front>
<front id="plannerCPP-822">  double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed</front>
<front id="plannerCPP-823"></front>
<front id="plannerCPP-824">  // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.</front>
<front id="plannerCPP-825">  if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed &gt; 0.0)) {</front>
<front id="plannerCPP-826">    // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)</front>
<front id="plannerCPP-827">    // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.</front>
<front id="plannerCPP-828">    double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]</front>
<front id="plannerCPP-829">      - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]</front>
<front id="plannerCPP-830">      - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;</front>
<front id="plannerCPP-831"></front>
<front id="plannerCPP-832">    // Skip and use default max junction speed for 0 degree acute junction.</front>
<front id="plannerCPP-833">    if (cos_theta &lt; 0.95) {</front>
<front id="plannerCPP-834">      vmax_junction = min(previous_nominal_speed,block-&gt;nominal_speed);</front>
<front id="plannerCPP-835">      // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.</front>
<front id="plannerCPP-836">      if (cos_theta &gt; -0.95) {</front>
<front id="plannerCPP-837">        // Compute maximum junction velocity based on maximum acceleration and junction deviation</front>
<front id="plannerCPP-838">        double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.</front>
<front id="plannerCPP-839">        vmax_junction = min(vmax_junction,</front>
<front id="plannerCPP-840">        sqrt(block-&gt;acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );</front>
<front id="plannerCPP-841">      }</front>
<front id="plannerCPP-842">    }</front>
<front id="plannerCPP-843">  }</front>
<front id="plannerCPP-844">#endif</front>
<front id="plannerCPP-845">  // Start with a safe speed</front>
<front id="plannerCPP-846">  float vmax_junction = max_xy_jerk/2; </front>
<front id="plannerCPP-847">  float vmax_junction_factor = 1.0; </front>
<front id="plannerCPP-848">  if(fabs(current_speed[Z_AXIS]) &gt; max_z_jerk/2) </front>
<front id="plannerCPP-849">    vmax_junction = min(vmax_junction, max_z_jerk/2);</front>
<front id="plannerCPP-850">  if(fabs(current_speed[E_AXIS]) &gt; max_e_jerk/2) </front>
<front id="plannerCPP-851">    vmax_junction = min(vmax_junction, max_e_jerk/2);</front>
<front id="plannerCPP-852">  vmax_junction = min(vmax_junction, block-&gt;nominal_speed);</front>
<front id="plannerCPP-853">  float safe_speed = vmax_junction;</front>
<front id="plannerCPP-854"></front>
<front id="plannerCPP-855">  if ((moves_queued &gt; 1) && (previous_nominal_speed &gt; 0.0001)) {</front>
<front id="plannerCPP-856">    float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));</front>
<front id="plannerCPP-857">    //    if((fabs(previous_speed[X_AXIS]) &gt; 0.0001) || (fabs(previous_speed[Y_AXIS]) &gt; 0.0001)) {</front>
<front id="plannerCPP-858">    vmax_junction = block-&gt;nominal_speed;</front>
<front id="plannerCPP-859">    //    }</front>
<front id="plannerCPP-860">    if (jerk &gt; max_xy_jerk) {</front>
<front id="plannerCPP-861">      vmax_junction_factor = (max_xy_jerk/jerk);</front>
<front id="plannerCPP-862">    } </front>
<front id="plannerCPP-863">    if(fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) &gt; max_z_jerk) {</front>
<front id="plannerCPP-864">      vmax_junction_factor= min(vmax_junction_factor, (max_z_jerk/fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS])));</front>
<front id="plannerCPP-865">    } </front>
<front id="plannerCPP-866">    if(fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]) &gt; max_e_jerk) {</front>
<front id="plannerCPP-867">      vmax_junction_factor = min(vmax_junction_factor, (max_e_jerk/fabs(current_speed[E_AXIS] - previous_speed[E_AXIS])));</front>
<front id="plannerCPP-868">    } </front>
<front id="plannerCPP-869">    vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed</front>
<front id="plannerCPP-870">  }</front>
<front id="plannerCPP-871">  block-&gt;max_entry_speed = vmax_junction;</front>
<front id="plannerCPP-872"></front>
<front id="plannerCPP-873">  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.</front>
<front id="plannerCPP-874">  double v_allowable = max_allowable_speed(-block-&gt;acceleration,MINIMUM_PLANNER_SPEED,block-&gt;millimeters);</front>
<front id="plannerCPP-875">  block-&gt;entry_speed = min(vmax_junction, v_allowable);</front>
<front id="plannerCPP-876"></front>
<front id="plannerCPP-877">  // Initialize planner efficiency flags</front>
<front id="plannerCPP-878">  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.</front>
<front id="plannerCPP-879">  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then</front>
<front id="plannerCPP-880">  // the current block and next block junction speeds are guaranteed to always be at their maximum</front>
<front id="plannerCPP-881">  // junction speeds in deceleration and acceleration, respectively. This is due to how the current</front>
<front id="plannerCPP-882">  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both</front>
<front id="plannerCPP-883">  // the reverse and forward planners, the corresponding block junction speed will always be at the</front>
<front id="plannerCPP-884">  // the maximum junction speed and may always be ignored for any speed reduction checks.</front>
<front id="plannerCPP-885">  if (block-&gt;nominal_speed &lt;= v_allowable) { </front>
<front id="plannerCPP-886">    block-&gt;nominal_length_flag = true; </front>
<front id="plannerCPP-887">  }</front>
<front id="plannerCPP-888">  else { </front>
<front id="plannerCPP-889">    block-&gt;nominal_length_flag = false; </front>
<front id="plannerCPP-890">  }</front>
<front id="plannerCPP-891">  block-&gt;recalculate_flag = true; // Always calculate trapezoid for new block</front>
<front id="plannerCPP-892"></front>
<front id="plannerCPP-893">  // Update previous path unit_vector and nominal speed</front>
<front id="plannerCPP-894">  memcpy(previous_speed, current_speed, sizeof(previous_speed)); // previous_speed[] = current_speed[]</front>
<front id="plannerCPP-895">  previous_nominal_speed = block-&gt;nominal_speed;</front>
<front id="plannerCPP-896"></front>
<front id="plannerCPP-897"></front>
<front id="plannerCPP-898">#ifdef ADVANCE</front>
<front id="plannerCPP-899">  // Calculate advance rate</front>
<front id="plannerCPP-900">  if((block-&gt;steps_e == 0) || (block-&gt;steps_x == 0 && block-&gt;steps_y == 0 && block-&gt;steps_z == 0)) {</front>
<front id="plannerCPP-901">    block-&gt;advance_rate = 0;</front>
<front id="plannerCPP-902">    block-&gt;advance = 0;</front>
<front id="plannerCPP-903">  }</front>
<front id="plannerCPP-904">  else {</front>
<front id="plannerCPP-905">    long acc_dist = estimate_acceleration_distance(0, block-&gt;nominal_rate, block-&gt;acceleration_st);</front>
<front id="plannerCPP-906">    float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * </front>
<front id="plannerCPP-907">      (current_speed[E_AXIS] * current_speed[E_AXIS] * EXTRUTION_AREA * EXTRUTION_AREA)*256;</front>
<front id="plannerCPP-908">    block-&gt;advance = advance;</front>
<front id="plannerCPP-909">    if(acc_dist == 0) {</front>
<front id="plannerCPP-910">      block-&gt;advance_rate = 0;</front>
<front id="plannerCPP-911">    } </front>
<front id="plannerCPP-912">    else {</front>
<front id="plannerCPP-913">      block-&gt;advance_rate = advance / (float)acc_dist;</front>
<front id="plannerCPP-914">    }</front>
<front id="plannerCPP-915">  }</front>
<front id="plannerCPP-916">  /*</front>
<front id="plannerCPP-917">    SERIAL_ECHO_START;</front>
<front id="plannerCPP-918">   SERIAL_ECHOPGM("advance :");</front>
<front id="plannerCPP-919">   SERIAL_ECHO(block-&gt;advance/256.0);</front>
<front id="plannerCPP-920">   SERIAL_ECHOPGM("advance rate :");</front>
<front id="plannerCPP-921">   SERIAL_ECHOLN(block-&gt;advance_rate/256.0);</front>
<front id="plannerCPP-922">   */</front>
<front id="plannerCPP-923">#endif // ADVANCE</front>
<front id="plannerCPP-924"></front>
<front id="plannerCPP-925">  calculate_trapezoid_for_block(block, block-&gt;entry_speed/block-&gt;nominal_speed,</front>
<front id="plannerCPP-926">  safe_speed/block-&gt;nominal_speed);</front>
<front id="plannerCPP-927"></front>
<front id="plannerCPP-928">  // Move buffer head</front>
<front id="plannerCPP-929">  block_buffer_head = next_buffer_head;</front>
<front id="plannerCPP-930"></front>
<front id="plannerCPP-931">  // Update position</front>
<front id="plannerCPP-932">  memcpy(position, target, sizeof(target)); // position[] = target[]</front>
<front id="plannerCPP-933"></front>
<front id="plannerCPP-934">  planner_recalculate();</front>
<front id="plannerCPP-935"></front>
<front id="plannerCPP-936">  st_wake_up();</front>
<front id="plannerCPP-937">}</front>
<front id="plannerCPP-938"></front>
<front id="plannerCPP-939">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-940">vector_3 plan_get_position() {</front>
<front id="plannerCPP-941">	vector_3 position = vector_3(st_get_position_mm(X_AXIS), st_get_position_mm(Y_AXIS), st_get_position_mm(Z_AXIS));</front>
<front id="plannerCPP-942"></front>
<front id="plannerCPP-943">	//position.debug("in plan_get position");</front>
<front id="plannerCPP-944">	//plan_bed_level_matrix.debug("in plan_get bed_level");</front>
<front id="plannerCPP-945">	matrix_3x3 inverse = matrix_3x3::create_inverse(plan_bed_level_matrix);</front>
<front id="plannerCPP-946">	//inverse.debug("in plan_get inverse");</front>
<front id="plannerCPP-947">	position.apply_rotation(inverse);</front>
<front id="plannerCPP-948">	//position.debug("after rotation");</front>
<front id="plannerCPP-949"></front>
<front id="plannerCPP-950">	return position;</front>
<front id="plannerCPP-951">}</front>
<front id="plannerCPP-952">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-953"></front>
<front id="plannerCPP-954">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-955">void plan_set_position(float x, float y, float z, const float &e)</front>
<front id="plannerCPP-956">{</front>
<front id="plannerCPP-957">  apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</front>
<front id="plannerCPP-958">#else</front>
<front id="plannerCPP-959">void plan_set_position(const float &x, const float &y, const float &z, const float &e)</front>
<front id="plannerCPP-960">{</front>
<front id="plannerCPP-961">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerCPP-962"></front>
<front id="plannerCPP-963">  position[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);</front>
<front id="plannerCPP-964">  position[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);</front>
<front id="plannerCPP-965">  position[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     </front>
<front id="plannerCPP-966">  position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  </front>
<front id="plannerCPP-967">  st_set_position(position[X_AXIS], position[Y_AXIS], position[Z_AXIS], position[E_AXIS]);</front>
<front id="plannerCPP-968">  previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.</front>
<front id="plannerCPP-969">  previous_speed[0] = 0.0;</front>
<front id="plannerCPP-970">  previous_speed[1] = 0.0;</front>
<front id="plannerCPP-971">  previous_speed[2] = 0.0;</front>
<front id="plannerCPP-972">  previous_speed[3] = 0.0;</front>
<front id="plannerCPP-973">}</front>
<front id="plannerCPP-974"></front>
<front id="plannerCPP-975">void plan_set_e_position(const float &e)</front>
<front id="plannerCPP-976">{</front>
<front id="plannerCPP-977">  position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  </front>
<front id="plannerCPP-978">  st_set_e_position(position[E_AXIS]);</front>
<front id="plannerCPP-979">}</front>
<front id="plannerCPP-980"></front>
<front id="plannerCPP-981">uint8_t movesplanned()</front>
<front id="plannerCPP-982">{</front>
<front id="plannerCPP-983">  return (block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) & (BLOCK_BUFFER_SIZE - 1);</front>
<front id="plannerCPP-984">}</front>
<front id="plannerCPP-985"></front>
<front id="plannerCPP-986">#ifdef PREVENT_DANGEROUS_EXTRUDE</front>
<front id="plannerCPP-987">void set_extrude_min_temp(float temp)</front>
<front id="plannerCPP-988">{</front>
<front id="plannerCPP-989">  extrude_min_temp=temp;</front>
<front id="plannerCPP-990">}</front>
<front id="plannerCPP-991">#endif</front>
<front id="plannerCPP-992"></front>
<front id="plannerCPP-993">// Calculate the steps/s^2 acceleration rates, based on the mm/s^s</front>
<front id="plannerCPP-994">void reset_acceleration_rates()</front>
<front id="plannerCPP-995">{</front>
<front id="plannerCPP-996">	for(int8_t i=0; i &lt; NUM_AXIS; i++)</front>
<front id="plannerCPP-997">        {</front>
<front id="plannerCPP-998">        axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];</front>
<front id="plannerCPP-999">        }</front>
<front id="plannerCPP-1000">}</front>
 </pre>
<h1>planner.h</h1>
<pre  class="prettyprint linenums"><front id="plannerH-1">/*</front>
<front id="plannerH-2">  planner.h - buffers movement commands and manages the acceleration profile plan</front>
<front id="plannerH-3">  Part of Grbl</front>
<front id="plannerH-4"></front>
<front id="plannerH-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="plannerH-6"></front>
<front id="plannerH-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="plannerH-8">  it under the terms of the GNU General Public License as published by</front>
<front id="plannerH-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="plannerH-10">  (at your option) any later version.</front>
<front id="plannerH-11"></front>
<front id="plannerH-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="plannerH-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="plannerH-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="plannerH-15">  GNU General Public License for more details.</front>
<front id="plannerH-16"></front>
<front id="plannerH-17">  You should have received a copy of the GNU General Public License</front>
<front id="plannerH-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="plannerH-19">*/</front>
<front id="plannerH-20"></front>
<front id="plannerH-21">// This module is to be considered a sub-module of stepper.c. Please don't include </front>
<front id="plannerH-22">// this file from any other module.</front>
<front id="plannerH-23"></front>
<front id="plannerH-24">#ifndef planner_h</front>
<front id="plannerH-25">#define planner_h</front>
<front id="plannerH-26"></front>
<front id="plannerH-27">#include "Marlin.h"</front>
<front id="plannerH-28"></front>
<front id="plannerH-29">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-30">#include "vector_3.h"</front>
<front id="plannerH-31">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-32"></front>
<front id="plannerH-33">// This struct is used when buffering the setup for each linear movement "nominal" values are as specified in </front>
<front id="plannerH-34">// the source g-code and may never actually be reached if acceleration management is active.</front>
<front id="plannerH-35">typedef struct {</front>
<front id="plannerH-36">  // Fields used by the bresenham algorithm for tracing the line</front>
<front id="plannerH-37">  long steps_x, steps_y, steps_z, steps_e;  // Step count along each axis</front>
<front id="plannerH-38">  unsigned long step_event_count;           // The number of step events required to complete this block</front>
<front id="plannerH-39">  long accelerate_until;                    // The index of the step event on which to stop acceleration</front>
<front id="plannerH-40">  long decelerate_after;                    // The index of the step event on which to start decelerating</front>
<front id="plannerH-41">  long acceleration_rate;                   // The acceleration rate used for acceleration calculation</front>
<front id="plannerH-42">  unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)</front>
<front id="plannerH-43">  unsigned char active_extruder;            // Selects the active extruder</front>
<front id="plannerH-44">  #ifdef ADVANCE</front>
<front id="plannerH-45">    long advance_rate;</front>
<front id="plannerH-46">    volatile long initial_advance;</front>
<front id="plannerH-47">    volatile long final_advance;</front>
<front id="plannerH-48">    float advance;</front>
<front id="plannerH-49">  #endif</front>
<front id="plannerH-50"></front>
<front id="plannerH-51">  // Fields used by the motion planner to manage acceleration</front>
<front id="plannerH-52">//  float speed_x, speed_y, speed_z, speed_e;        // Nominal mm/sec for each axis</front>
<front id="plannerH-53">  float nominal_speed;                               // The nominal speed for this block in mm/sec </front>
<front id="plannerH-54">  float entry_speed;                                 // Entry speed at previous-current junction in mm/sec</front>
<front id="plannerH-55">  float max_entry_speed;                             // Maximum allowable junction entry speed in mm/sec</front>
<front id="plannerH-56">  float millimeters;                                 // The total travel of this block in mm</front>
<front id="plannerH-57">  float acceleration;                                // acceleration mm/sec^2</front>
<front id="plannerH-58">  unsigned char recalculate_flag;                    // Planner flag to recalculate trapezoids on entry junction</front>
<front id="plannerH-59">  unsigned char nominal_length_flag;                 // Planner flag for nominal speed always reached</front>
<front id="plannerH-60"></front>
<front id="plannerH-61">  // Settings for the trapezoid generator</front>
<front id="plannerH-62">  unsigned long nominal_rate;                        // The nominal step rate for this block in step_events/sec </front>
<front id="plannerH-63">  unsigned long initial_rate;                        // The jerk-adjusted step rate at start of block  </front>
<front id="plannerH-64">  unsigned long final_rate;                          // The minimal rate at exit</front>
<front id="plannerH-65">  unsigned long acceleration_st;                     // acceleration steps/sec^2</front>
<front id="plannerH-66">  unsigned long fan_speed;</front>
<front id="plannerH-67">  #ifdef BARICUDA</front>
<front id="plannerH-68">  unsigned long valve_pressure;</front>
<front id="plannerH-69">  unsigned long e_to_p_pressure;</front>
<front id="plannerH-70">  #endif</front>
<front id="plannerH-71">  volatile char busy;</front>
<front id="plannerH-72">} block_t;</front>
<front id="plannerH-73"></front>
<front id="plannerH-74">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-75">// this holds the required transform to compensate for bed level</front>
<front id="plannerH-76">extern matrix_3x3 plan_bed_level_matrix;</front>
<front id="plannerH-77">#endif // #ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-78"></front>
<front id="plannerH-79">// Initialize the motion plan subsystem      </front>
<front id="plannerH-80">void plan_init();</front>
<front id="plannerH-81"></front>
<front id="plannerH-82">// Add a new linear movement to the buffer. x, y and z is the signed, absolute target position in </front>
<front id="plannerH-83">// millimaters. Feed rate specifies the speed of the motion.</front>
<front id="plannerH-84"></front>
<front id="plannerH-85">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-86">void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t &extruder);</front>
<front id="plannerH-87"></front>
<front id="plannerH-88">// Get the position applying the bed level matrix if enabled</front>
<front id="plannerH-89">vector_3 plan_get_position();</front>
<front id="plannerH-90">#else</front>
<front id="plannerH-91">void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t &extruder);</front>
<front id="plannerH-92">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-93"></front>
<front id="plannerH-94">// Set position. Used for G92 instructions.</front>
<front id="plannerH-95">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-96">void plan_set_position(float x, float y, float z, const float &e);</front>
<front id="plannerH-97">#else</front>
<front id="plannerH-98">void plan_set_position(const float &x, const float &y, const float &z, const float &e);</front>
<front id="plannerH-99">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="plannerH-100"></front>
<front id="plannerH-101">void plan_set_e_position(const float &e);</front>
<front id="plannerH-102"></front>
<front id="plannerH-103"></front>
<front id="plannerH-104"></front>
<front id="plannerH-105">void check_axes_activity();</front>
<front id="plannerH-106">uint8_t movesplanned(); //return the nr of buffered moves</front>
<front id="plannerH-107"></front>
<front id="plannerH-108">extern unsigned long minsegmenttime;</front>
<front id="plannerH-109">extern float max_feedrate[4]; // set the max speeds</front>
<front id="plannerH-110">extern float axis_steps_per_unit[4];</front>
<front id="plannerH-111">extern unsigned long max_acceleration_units_per_sq_second[4]; // Use M201 to override by software</front>
<front id="plannerH-112">extern float minimumfeedrate;</front>
<front id="plannerH-113">extern float acceleration;         // Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX</front>
<front id="plannerH-114">extern float retract_acceleration; //  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX</front>
<front id="plannerH-115">extern float max_xy_jerk; //speed than can be stopped at once, if i understand correctly.</front>
<front id="plannerH-116">extern float max_z_jerk;</front>
<front id="plannerH-117">extern float max_e_jerk;</front>
<front id="plannerH-118">extern float mintravelfeedrate;</front>
<front id="plannerH-119">extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];</front>
<front id="plannerH-120"></front>
<front id="plannerH-121">#ifdef AUTOTEMP</front>
<front id="plannerH-122">    extern bool autotemp_enabled;</front>
<front id="plannerH-123">    extern float autotemp_max;</front>
<front id="plannerH-124">    extern float autotemp_min;</front>
<front id="plannerH-125">    extern float autotemp_factor;</front>
<front id="plannerH-126">#endif</front>
<front id="plannerH-127"></front>
<front id="plannerH-128">    </front>
<front id="plannerH-129"></front>
<front id="plannerH-130"></front>
<front id="plannerH-131">extern block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions</front>
<front id="plannerH-132">extern volatile unsigned char block_buffer_head;           // Index of the next block to be pushed</front>
<front id="plannerH-133">extern volatile unsigned char block_buffer_tail; </front>
<front id="plannerH-134">// Called when the current block is no longer needed. Discards the block and makes the memory</front>
<front id="plannerH-135">// availible for new blocks.    </front>
<front id="plannerH-136">FORCE_INLINE void plan_discard_current_block()  </front>
<front id="plannerH-137">{</front>
<front id="plannerH-138">  if (block_buffer_head != block_buffer_tail) {</front>
<front id="plannerH-139">    block_buffer_tail = (block_buffer_tail + 1) & (BLOCK_BUFFER_SIZE - 1);  </front>
<front id="plannerH-140">  }</front>
<front id="plannerH-141">}</front>
<front id="plannerH-142"></front>
<front id="plannerH-143">// Gets the current block. Returns NULL if buffer empty</front>
<front id="plannerH-144">FORCE_INLINE block_t *plan_get_current_block() </front>
<front id="plannerH-145">{</front>
<front id="plannerH-146">  if (block_buffer_head == block_buffer_tail) { </front>
<front id="plannerH-147">    return(NULL); </front>
<front id="plannerH-148">  }</front>
<front id="plannerH-149">  block_t *block = &block_buffer[block_buffer_tail];</front>
<front id="plannerH-150">  block-&gt;busy = true;</front>
<front id="plannerH-151">  return(block);</front>
<front id="plannerH-152">}</front>
<front id="plannerH-153"></front>
<front id="plannerH-154">// Gets the current block. Returns NULL if buffer empty</front>
<front id="plannerH-155">FORCE_INLINE bool blocks_queued() </front>
<front id="plannerH-156">{</front>
<front id="plannerH-157">  if (block_buffer_head == block_buffer_tail) { </front>
<front id="plannerH-158">    return false; </front>
<front id="plannerH-159">  }</front>
<front id="plannerH-160">  else</front>
<front id="plannerH-161">    return true;</front>
<front id="plannerH-162">}</front>
<front id="plannerH-163"></front>
<front id="plannerH-164">#ifdef PREVENT_DANGEROUS_EXTRUDE</front>
<front id="plannerH-165">void set_extrude_min_temp(float temp);</front>
<front id="plannerH-166">#endif</front>
<front id="plannerH-167"></front>
<front id="plannerH-168">void reset_acceleration_rates();</front>
<front id="plannerH-169">#endif</front>
 </pre>
<h1>Sd2Card.cpp</h1>
<pre  class="prettyprint linenums"><front id="Sd2CardCPP-1">/* Arduino Sd2Card Library</front>
<front id="Sd2CardCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="Sd2CardCPP-3"> *</front>
<front id="Sd2CardCPP-4"> * This file is part of the Arduino Sd2Card Library</front>
<front id="Sd2CardCPP-5"> *</front>
<front id="Sd2CardCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="Sd2CardCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="Sd2CardCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Sd2CardCPP-9"> * (at your option) any later version.</front>
<front id="Sd2CardCPP-10"> *</front>
<front id="Sd2CardCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="Sd2CardCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Sd2CardCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Sd2CardCPP-14"> * GNU General Public License for more details.</front>
<front id="Sd2CardCPP-15"> *</front>
<front id="Sd2CardCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="Sd2CardCPP-17"> * along with the Arduino Sd2Card Library.  If not, see</front>
<front id="Sd2CardCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Sd2CardCPP-19"> */</front>
<front id="Sd2CardCPP-20">#include "Marlin.h"</front>
<front id="Sd2CardCPP-21"></front>
<front id="Sd2CardCPP-22">#ifdef SDSUPPORT</front>
<front id="Sd2CardCPP-23">#include "Sd2Card.h"</front>
<front id="Sd2CardCPP-24">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-25">#ifndef SOFTWARE_SPI</front>
<front id="Sd2CardCPP-26">// functions for hardware SPI</front>
<front id="Sd2CardCPP-27">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-28">// make sure SPCR rate is in expected bits</front>
<front id="Sd2CardCPP-29">#if (SPR0 != 0 || SPR1 != 1)</front>
<front id="Sd2CardCPP-30">#error unexpected SPCR bits</front>
<front id="Sd2CardCPP-31">#endif</front>
<front id="Sd2CardCPP-32">/**</front>
<front id="Sd2CardCPP-33"> * Initialize hardware SPI</front>
<front id="Sd2CardCPP-34"> * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]</front>
<front id="Sd2CardCPP-35"> */</front>
<front id="Sd2CardCPP-36">static void spiInit(uint8_t spiRate) {</front>
<front id="Sd2CardCPP-37">  // See avr processor documentation</front>
<front id="Sd2CardCPP-38">  SPCR = (1 &lt;&lt; SPE) | (1 &lt;&lt; MSTR) | (spiRate &gt;&gt; 1);</front>
<front id="Sd2CardCPP-39">  SPSR = spiRate & 1 || spiRate == 6 ? 0 : 1 &lt;&lt; SPI2X;</front>
<front id="Sd2CardCPP-40">}</front>
<front id="Sd2CardCPP-41">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-42">/** SPI receive a byte */</front>
<front id="Sd2CardCPP-43">static uint8_t spiRec() {</front>
<front id="Sd2CardCPP-44">  SPDR = 0XFF;</front>
<front id="Sd2CardCPP-45">  while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-46">  return SPDR;</front>
<front id="Sd2CardCPP-47">}</front>
<front id="Sd2CardCPP-48">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-49">/** SPI read data - only one call so force inline */</front>
<front id="Sd2CardCPP-50">static inline __attribute__((always_inline))</front>
<front id="Sd2CardCPP-51">void spiRead(uint8_t* buf, uint16_t nbyte) {</front>
<front id="Sd2CardCPP-52">  if (nbyte-- == 0) return;</front>
<front id="Sd2CardCPP-53">  SPDR = 0XFF;</front>
<front id="Sd2CardCPP-54">  for (uint16_t i = 0; i &lt; nbyte; i++) {</front>
<front id="Sd2CardCPP-55">    while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-56">    buf[i] = SPDR;</front>
<front id="Sd2CardCPP-57">    SPDR = 0XFF;</front>
<front id="Sd2CardCPP-58">  }</front>
<front id="Sd2CardCPP-59">  while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-60">  buf[nbyte] = SPDR;</front>
<front id="Sd2CardCPP-61">}</front>
<front id="Sd2CardCPP-62">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-63">/** SPI send a byte */</front>
<front id="Sd2CardCPP-64">static void spiSend(uint8_t b) {</front>
<front id="Sd2CardCPP-65">  SPDR = b;</front>
<front id="Sd2CardCPP-66">  while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-67">}</front>
<front id="Sd2CardCPP-68">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-69">/** SPI send block - only one call so force inline */</front>
<front id="Sd2CardCPP-70">static inline __attribute__((always_inline))</front>
<front id="Sd2CardCPP-71">  void spiSendBlock(uint8_t token, const uint8_t* buf) {</front>
<front id="Sd2CardCPP-72">  SPDR = token;</front>
<front id="Sd2CardCPP-73">  for (uint16_t i = 0; i &lt; 512; i += 2) {</front>
<front id="Sd2CardCPP-74">    while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-75">    SPDR = buf[i];</front>
<front id="Sd2CardCPP-76">    while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-77">    SPDR = buf[i + 1];</front>
<front id="Sd2CardCPP-78">  }</front>
<front id="Sd2CardCPP-79">  while (!(SPSR & (1 &lt;&lt; SPIF))) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-80">}</front>
<front id="Sd2CardCPP-81">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-82">#else  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-83">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-84">/** nop to tune soft SPI timing */</front>
<front id="Sd2CardCPP-85">#define nop asm volatile ("nop\n\t")</front>
<front id="Sd2CardCPP-86">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-87">/** Soft SPI receive byte */</front>
<front id="Sd2CardCPP-88">static uint8_t spiRec() {</front>
<front id="Sd2CardCPP-89">  uint8_t data = 0;</front>
<front id="Sd2CardCPP-90">  // no interrupts during byte receive - about 8 us</front>
<front id="Sd2CardCPP-91">  cli();</front>
<front id="Sd2CardCPP-92">  // output pin high - like sending 0XFF</front>
<front id="Sd2CardCPP-93">  fastDigitalWrite(SPI_MOSI_PIN, HIGH);</front>
<front id="Sd2CardCPP-94"></front>
<front id="Sd2CardCPP-95">  for (uint8_t i = 0; i &lt; 8; i++) {</front>
<front id="Sd2CardCPP-96">    fastDigitalWrite(SPI_SCK_PIN, HIGH);</front>
<front id="Sd2CardCPP-97"></front>
<front id="Sd2CardCPP-98">    // adjust so SCK is nice</front>
<front id="Sd2CardCPP-99">    nop;</front>
<front id="Sd2CardCPP-100">    nop;</front>
<front id="Sd2CardCPP-101"></front>
<front id="Sd2CardCPP-102">    data &lt;&lt;= 1;</front>
<front id="Sd2CardCPP-103"></front>
<front id="Sd2CardCPP-104">    if (fastDigitalRead(SPI_MISO_PIN)) data |= 1;</front>
<front id="Sd2CardCPP-105"></front>
<front id="Sd2CardCPP-106">    fastDigitalWrite(SPI_SCK_PIN, LOW);</front>
<front id="Sd2CardCPP-107">  }</front>
<front id="Sd2CardCPP-108">  // enable interrupts</front>
<front id="Sd2CardCPP-109">  sei();</front>
<front id="Sd2CardCPP-110">  return data;</front>
<front id="Sd2CardCPP-111">}</front>
<front id="Sd2CardCPP-112">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-113">/** Soft SPI read data */</front>
<front id="Sd2CardCPP-114">static void spiRead(uint8_t* buf, uint16_t nbyte) {</front>
<front id="Sd2CardCPP-115">  for (uint16_t i = 0; i &lt; nbyte; i++) {</front>
<front id="Sd2CardCPP-116">    buf[i] = spiRec();</front>
<front id="Sd2CardCPP-117">  }</front>
<front id="Sd2CardCPP-118">}</front>
<front id="Sd2CardCPP-119">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-120">/** Soft SPI send byte */</front>
<front id="Sd2CardCPP-121">static void spiSend(uint8_t data) {</front>
<front id="Sd2CardCPP-122">  // no interrupts during byte send - about 8 us</front>
<front id="Sd2CardCPP-123">  cli();</front>
<front id="Sd2CardCPP-124">  for (uint8_t i = 0; i &lt; 8; i++) {</front>
<front id="Sd2CardCPP-125">    fastDigitalWrite(SPI_SCK_PIN, LOW);</front>
<front id="Sd2CardCPP-126"></front>
<front id="Sd2CardCPP-127">    fastDigitalWrite(SPI_MOSI_PIN, data & 0X80);</front>
<front id="Sd2CardCPP-128"></front>
<front id="Sd2CardCPP-129">    data &lt;&lt;= 1;</front>
<front id="Sd2CardCPP-130"></front>
<front id="Sd2CardCPP-131">    fastDigitalWrite(SPI_SCK_PIN, HIGH);</front>
<front id="Sd2CardCPP-132">  }</front>
<front id="Sd2CardCPP-133">  // hold SCK high for a few ns</front>
<front id="Sd2CardCPP-134">  nop;</front>
<front id="Sd2CardCPP-135">  nop;</front>
<front id="Sd2CardCPP-136">  nop;</front>
<front id="Sd2CardCPP-137">  nop;</front>
<front id="Sd2CardCPP-138"></front>
<front id="Sd2CardCPP-139">  fastDigitalWrite(SPI_SCK_PIN, LOW);</front>
<front id="Sd2CardCPP-140">  // enable interrupts</front>
<front id="Sd2CardCPP-141">  sei();</front>
<front id="Sd2CardCPP-142">}</front>
<front id="Sd2CardCPP-143">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-144">/** Soft SPI send block */</front>
<front id="Sd2CardCPP-145">  void spiSendBlock(uint8_t token, const uint8_t* buf) {</front>
<front id="Sd2CardCPP-146">  spiSend(token);</front>
<front id="Sd2CardCPP-147">  for (uint16_t i = 0; i &lt; 512; i++) {</front>
<front id="Sd2CardCPP-148">    spiSend(buf[i]);</front>
<front id="Sd2CardCPP-149">  }</front>
<front id="Sd2CardCPP-150">}</front>
<front id="Sd2CardCPP-151">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-152">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-153">// send command and return error code.  Return zero for OK</front>
<front id="Sd2CardCPP-154">uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {</front>
<front id="Sd2CardCPP-155">  // select card</front>
<front id="Sd2CardCPP-156">  chipSelectLow();</front>
<front id="Sd2CardCPP-157"></front>
<front id="Sd2CardCPP-158">  // wait up to 300 ms if busy</front>
<front id="Sd2CardCPP-159">  waitNotBusy(300);</front>
<front id="Sd2CardCPP-160"></front>
<front id="Sd2CardCPP-161">  // send command</front>
<front id="Sd2CardCPP-162">  spiSend(cmd | 0x40);</front>
<front id="Sd2CardCPP-163"></front>
<front id="Sd2CardCPP-164">  // send argument</front>
<front id="Sd2CardCPP-165">  for (int8_t s = 24; s &gt;= 0; s -= 8) spiSend(arg &gt;&gt; s);</front>
<front id="Sd2CardCPP-166"></front>
<front id="Sd2CardCPP-167">  // send CRC</front>
<front id="Sd2CardCPP-168">  uint8_t crc = 0XFF;</front>
<front id="Sd2CardCPP-169">  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0</front>
<front id="Sd2CardCPP-170">  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA</front>
<front id="Sd2CardCPP-171">  spiSend(crc);</front>
<front id="Sd2CardCPP-172"></front>
<front id="Sd2CardCPP-173">  // skip stuff byte for stop read</front>
<front id="Sd2CardCPP-174">  if (cmd == CMD12) spiRec();</front>
<front id="Sd2CardCPP-175"></front>
<front id="Sd2CardCPP-176">  // wait for response</front>
<front id="Sd2CardCPP-177">  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-178">  return status_;</front>
<front id="Sd2CardCPP-179">}</front>
<front id="Sd2CardCPP-180">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-181">/**</front>
<front id="Sd2CardCPP-182"> * Determine the size of an SD flash memory card.</front>
<front id="Sd2CardCPP-183"> *</front>
<front id="Sd2CardCPP-184"> * \return The number of 512 byte data blocks in the card</front>
<front id="Sd2CardCPP-185"> *         or zero if an error occurs.</front>
<front id="Sd2CardCPP-186"> */</front>
<front id="Sd2CardCPP-187">uint32_t Sd2Card::cardSize() {</front>
<front id="Sd2CardCPP-188">  csd_t csd;</front>
<front id="Sd2CardCPP-189">  if (!readCSD(&csd)) return 0;</front>
<front id="Sd2CardCPP-190">  if (csd.v1.csd_ver == 0) {</front>
<front id="Sd2CardCPP-191">    uint8_t read_bl_len = csd.v1.read_bl_len;</front>
<front id="Sd2CardCPP-192">    uint16_t c_size = (csd.v1.c_size_high &lt;&lt; 10)</front>
<front id="Sd2CardCPP-193">                      | (csd.v1.c_size_mid &lt;&lt; 2) | csd.v1.c_size_low;</front>
<front id="Sd2CardCPP-194">    uint8_t c_size_mult = (csd.v1.c_size_mult_high &lt;&lt; 1)</front>
<front id="Sd2CardCPP-195">                          | csd.v1.c_size_mult_low;</front>
<front id="Sd2CardCPP-196">    return (uint32_t)(c_size + 1) &lt;&lt; (c_size_mult + read_bl_len - 7);</front>
<front id="Sd2CardCPP-197">  } else if (csd.v2.csd_ver == 1) {</front>
<front id="Sd2CardCPP-198">    uint32_t c_size = ((uint32_t)csd.v2.c_size_high &lt;&lt; 16)</front>
<front id="Sd2CardCPP-199">                      | (csd.v2.c_size_mid &lt;&lt; 8) | csd.v2.c_size_low;</front>
<front id="Sd2CardCPP-200">    return (c_size + 1) &lt;&lt; 10;</front>
<front id="Sd2CardCPP-201">  } else {</front>
<front id="Sd2CardCPP-202">    error(SD_CARD_ERROR_BAD_CSD);</front>
<front id="Sd2CardCPP-203">    return 0;</front>
<front id="Sd2CardCPP-204">  }</front>
<front id="Sd2CardCPP-205">}</front>
<front id="Sd2CardCPP-206">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-207">void Sd2Card::chipSelectHigh() {</front>
<front id="Sd2CardCPP-208">  digitalWrite(chipSelectPin_, HIGH);</front>
<front id="Sd2CardCPP-209">}</front>
<front id="Sd2CardCPP-210">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-211">void Sd2Card::chipSelectLow() {</front>
<front id="Sd2CardCPP-212">#ifndef SOFTWARE_SPI</front>
<front id="Sd2CardCPP-213">  spiInit(spiRate_);</front>
<front id="Sd2CardCPP-214">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-215">  digitalWrite(chipSelectPin_, LOW);</front>
<front id="Sd2CardCPP-216">}</front>
<front id="Sd2CardCPP-217">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-218">/** Erase a range of blocks.</front>
<front id="Sd2CardCPP-219"> *</front>
<front id="Sd2CardCPP-220"> * \param[in] firstBlock The address of the first block in the range.</front>
<front id="Sd2CardCPP-221"> * \param[in] lastBlock The address of the last block in the range.</front>
<front id="Sd2CardCPP-222"> *</front>
<front id="Sd2CardCPP-223"> * \note This function requests the SD card to do a flash erase for a</front>
<front id="Sd2CardCPP-224"> * range of blocks.  The data on the card after an erase operation is</front>
<front id="Sd2CardCPP-225"> * either 0 or 1, depends on the card vendor.  The card must support</front>
<front id="Sd2CardCPP-226"> * single block erase.</front>
<front id="Sd2CardCPP-227"> *</front>
<front id="Sd2CardCPP-228"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-229"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-230"> */</front>
<front id="Sd2CardCPP-231">bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {</front>
<front id="Sd2CardCPP-232">  csd_t csd;</front>
<front id="Sd2CardCPP-233">  if (!readCSD(&csd)) goto fail;</front>
<front id="Sd2CardCPP-234">  // check for single block erase</front>
<front id="Sd2CardCPP-235">  if (!csd.v1.erase_blk_en) {</front>
<front id="Sd2CardCPP-236">    // erase size mask</front>
<front id="Sd2CardCPP-237">    uint8_t m = (csd.v1.sector_size_high &lt;&lt; 1) | csd.v1.sector_size_low;</front>
<front id="Sd2CardCPP-238">    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {</front>
<front id="Sd2CardCPP-239">      // error card can't erase specified area</front>
<front id="Sd2CardCPP-240">      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);</front>
<front id="Sd2CardCPP-241">      goto fail;</front>
<front id="Sd2CardCPP-242">    }</front>
<front id="Sd2CardCPP-243">  }</front>
<front id="Sd2CardCPP-244">  if (type_ != SD_CARD_TYPE_SDHC) {</front>
<front id="Sd2CardCPP-245">    firstBlock &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-246">    lastBlock &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-247">  }</front>
<front id="Sd2CardCPP-248">  if (cardCommand(CMD32, firstBlock)</front>
<front id="Sd2CardCPP-249">    || cardCommand(CMD33, lastBlock)</front>
<front id="Sd2CardCPP-250">    || cardCommand(CMD38, 0)) {</front>
<front id="Sd2CardCPP-251">      error(SD_CARD_ERROR_ERASE);</front>
<front id="Sd2CardCPP-252">      goto fail;</front>
<front id="Sd2CardCPP-253">  }</front>
<front id="Sd2CardCPP-254">  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {</front>
<front id="Sd2CardCPP-255">    error(SD_CARD_ERROR_ERASE_TIMEOUT);</front>
<front id="Sd2CardCPP-256">    goto fail;</front>
<front id="Sd2CardCPP-257">  }</front>
<front id="Sd2CardCPP-258">  chipSelectHigh();</front>
<front id="Sd2CardCPP-259">  return true;</front>
<front id="Sd2CardCPP-260"></front>
<front id="Sd2CardCPP-261"> fail:</front>
<front id="Sd2CardCPP-262">  chipSelectHigh();</front>
<front id="Sd2CardCPP-263">  return false;</front>
<front id="Sd2CardCPP-264">}</front>
<front id="Sd2CardCPP-265">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-266">/** Determine if card supports single block erase.</front>
<front id="Sd2CardCPP-267"> *</front>
<front id="Sd2CardCPP-268"> * \return The value one, true, is returned if single block erase is supported.</front>
<front id="Sd2CardCPP-269"> * The value zero, false, is returned if single block erase is not supported.</front>
<front id="Sd2CardCPP-270"> */</front>
<front id="Sd2CardCPP-271">bool Sd2Card::eraseSingleBlockEnable() {</front>
<front id="Sd2CardCPP-272">  csd_t csd;</front>
<front id="Sd2CardCPP-273">  return readCSD(&csd) ? csd.v1.erase_blk_en : false;</front>
<front id="Sd2CardCPP-274">}</front>
<front id="Sd2CardCPP-275">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-276">/**</front>
<front id="Sd2CardCPP-277"> * Initialize an SD flash memory card.</front>
<front id="Sd2CardCPP-278"> *</front>
<front id="Sd2CardCPP-279"> * \param[in] sckRateID SPI clock rate selector. See setSckRate().</front>
<front id="Sd2CardCPP-280"> * \param[in] chipSelectPin SD chip select pin number.</front>
<front id="Sd2CardCPP-281"> *</front>
<front id="Sd2CardCPP-282"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-283"> * the value zero, false, is returned for failure.  The reason for failure</front>
<front id="Sd2CardCPP-284"> * can be determined by calling errorCode() and errorData().</front>
<front id="Sd2CardCPP-285"> */</front>
<front id="Sd2CardCPP-286">bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {</front>
<front id="Sd2CardCPP-287">  errorCode_ = type_ = 0;</front>
<front id="Sd2CardCPP-288">  chipSelectPin_ = chipSelectPin;</front>
<front id="Sd2CardCPP-289">  // 16-bit init start time allows over a minute</front>
<front id="Sd2CardCPP-290">  uint16_t t0 = (uint16_t)millis();</front>
<front id="Sd2CardCPP-291">  uint32_t arg;</front>
<front id="Sd2CardCPP-292"></front>
<front id="Sd2CardCPP-293">  // set pin modes</front>
<front id="Sd2CardCPP-294">  pinMode(chipSelectPin_, OUTPUT);</front>
<front id="Sd2CardCPP-295">  chipSelectHigh();</front>
<front id="Sd2CardCPP-296">  pinMode(SPI_MISO_PIN, INPUT);</front>
<front id="Sd2CardCPP-297">  pinMode(SPI_MOSI_PIN, OUTPUT);</front>
<front id="Sd2CardCPP-298">  pinMode(SPI_SCK_PIN, OUTPUT);</front>
<front id="Sd2CardCPP-299"></front>
<front id="Sd2CardCPP-300">#ifndef SOFTWARE_SPI</front>
<front id="Sd2CardCPP-301">  // SS must be in output mode even it is not chip select</front>
<front id="Sd2CardCPP-302">  pinMode(SS_PIN, OUTPUT);</front>
<front id="Sd2CardCPP-303">  // set SS high - may be chip select for another SPI device</front>
<front id="Sd2CardCPP-304">#if SET_SPI_SS_HIGH</front>
<front id="Sd2CardCPP-305">  digitalWrite(SS_PIN, HIGH);</front>
<front id="Sd2CardCPP-306">#endif  // SET_SPI_SS_HIGH</front>
<front id="Sd2CardCPP-307">  // set SCK rate for initialization commands</front>
<front id="Sd2CardCPP-308">  spiRate_ = SPI_SD_INIT_RATE;</front>
<front id="Sd2CardCPP-309">  spiInit(spiRate_);</front>
<front id="Sd2CardCPP-310">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-311"></front>
<front id="Sd2CardCPP-312">  // must supply min of 74 clock cycles with CS high.</front>
<front id="Sd2CardCPP-313">  for (uint8_t i = 0; i &lt; 10; i++) spiSend(0XFF);</front>
<front id="Sd2CardCPP-314"></front>
<front id="Sd2CardCPP-315">  // command to go idle in SPI mode</front>
<front id="Sd2CardCPP-316">  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {</front>
<front id="Sd2CardCPP-317">    if (((uint16_t)millis() - t0) &gt; SD_INIT_TIMEOUT) {</front>
<front id="Sd2CardCPP-318">      error(SD_CARD_ERROR_CMD0);</front>
<front id="Sd2CardCPP-319">      goto fail;</front>
<front id="Sd2CardCPP-320">    }</front>
<front id="Sd2CardCPP-321">  }</front>
<front id="Sd2CardCPP-322">  // check SD version</front>
<front id="Sd2CardCPP-323">  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {</front>
<front id="Sd2CardCPP-324">    type(SD_CARD_TYPE_SD1);</front>
<front id="Sd2CardCPP-325">  } else {</front>
<front id="Sd2CardCPP-326">    // only need last byte of r7 response</front>
<front id="Sd2CardCPP-327">    for (uint8_t i = 0; i &lt; 4; i++) status_ = spiRec();</front>
<front id="Sd2CardCPP-328">    if (status_ != 0XAA) {</front>
<front id="Sd2CardCPP-329">      error(SD_CARD_ERROR_CMD8);</front>
<front id="Sd2CardCPP-330">      goto fail;</front>
<front id="Sd2CardCPP-331">    }</front>
<front id="Sd2CardCPP-332">    type(SD_CARD_TYPE_SD2);</front>
<front id="Sd2CardCPP-333">  }</front>
<front id="Sd2CardCPP-334">  // initialize card and send host supports SDHC if SD2</front>
<front id="Sd2CardCPP-335">  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;</front>
<front id="Sd2CardCPP-336"></front>
<front id="Sd2CardCPP-337">  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {</front>
<front id="Sd2CardCPP-338">    // check for timeout</front>
<front id="Sd2CardCPP-339">    if (((uint16_t)millis() - t0) &gt; SD_INIT_TIMEOUT) {</front>
<front id="Sd2CardCPP-340">      error(SD_CARD_ERROR_ACMD41);</front>
<front id="Sd2CardCPP-341">      goto fail;</front>
<front id="Sd2CardCPP-342">    }</front>
<front id="Sd2CardCPP-343">  }</front>
<front id="Sd2CardCPP-344">  // if SD2 read OCR register to check for SDHC card</front>
<front id="Sd2CardCPP-345">  if (type() == SD_CARD_TYPE_SD2) {</front>
<front id="Sd2CardCPP-346">    if (cardCommand(CMD58, 0)) {</front>
<front id="Sd2CardCPP-347">      error(SD_CARD_ERROR_CMD58);</front>
<front id="Sd2CardCPP-348">      goto fail;</front>
<front id="Sd2CardCPP-349">    }</front>
<front id="Sd2CardCPP-350">    if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);</front>
<front id="Sd2CardCPP-351">    // discard rest of ocr - contains allowed voltage range</front>
<front id="Sd2CardCPP-352">    for (uint8_t i = 0; i &lt; 3; i++) spiRec();</front>
<front id="Sd2CardCPP-353">  }</front>
<front id="Sd2CardCPP-354">  chipSelectHigh();</front>
<front id="Sd2CardCPP-355"></front>
<front id="Sd2CardCPP-356">#ifndef SOFTWARE_SPI</front>
<front id="Sd2CardCPP-357">  return setSckRate(sckRateID);</front>
<front id="Sd2CardCPP-358">#else  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-359">  return true;</front>
<front id="Sd2CardCPP-360">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-361"></front>
<front id="Sd2CardCPP-362"> fail:</front>
<front id="Sd2CardCPP-363">  chipSelectHigh();</front>
<front id="Sd2CardCPP-364">  return false;</front>
<front id="Sd2CardCPP-365">}</front>
<front id="Sd2CardCPP-366">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-367">/**</front>
<front id="Sd2CardCPP-368"> * Read a 512 byte block from an SD card.</front>
<front id="Sd2CardCPP-369"> *</front>
<front id="Sd2CardCPP-370"> * \param[in] blockNumber Logical block to be read.</front>
<front id="Sd2CardCPP-371"> * \param[out] dst Pointer to the location that will receive the data.</front>
<front id="Sd2CardCPP-372"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-373"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-374"> */</front>
<front id="Sd2CardCPP-375">bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {</front>
<front id="Sd2CardCPP-376">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-377">  if (type()!= SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-378">  if (cardCommand(CMD17, blockNumber)) {</front>
<front id="Sd2CardCPP-379">    error(SD_CARD_ERROR_CMD17);</front>
<front id="Sd2CardCPP-380">    goto fail;</front>
<front id="Sd2CardCPP-381">  }</front>
<front id="Sd2CardCPP-382">  return readData(dst, 512);</front>
<front id="Sd2CardCPP-383"></front>
<front id="Sd2CardCPP-384"> fail:</front>
<front id="Sd2CardCPP-385">  chipSelectHigh();</front>
<front id="Sd2CardCPP-386">  return false;</front>
<front id="Sd2CardCPP-387">}</front>
<front id="Sd2CardCPP-388">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-389">/** Read one data block in a multiple block read sequence</front>
<front id="Sd2CardCPP-390"> *</front>
<front id="Sd2CardCPP-391"> * \param[in] dst Pointer to the location for the data to be read.</front>
<front id="Sd2CardCPP-392"> *</front>
<front id="Sd2CardCPP-393"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-394"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-395"> */</front>
<front id="Sd2CardCPP-396">bool Sd2Card::readData(uint8_t *dst) {</front>
<front id="Sd2CardCPP-397">  chipSelectLow();</front>
<front id="Sd2CardCPP-398">  return readData(dst, 512);</front>
<front id="Sd2CardCPP-399">}</front>
<front id="Sd2CardCPP-400">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-401">bool Sd2Card::readData(uint8_t* dst, uint16_t count) {</front>
<front id="Sd2CardCPP-402">  // wait for start block token</front>
<front id="Sd2CardCPP-403">  uint16_t t0 = millis();</front>
<front id="Sd2CardCPP-404">  while ((status_ = spiRec()) == 0XFF) {</front>
<front id="Sd2CardCPP-405">    if (((uint16_t)millis() - t0) &gt; SD_READ_TIMEOUT) {</front>
<front id="Sd2CardCPP-406">      error(SD_CARD_ERROR_READ_TIMEOUT);</front>
<front id="Sd2CardCPP-407">      goto fail;</front>
<front id="Sd2CardCPP-408">    }</front>
<front id="Sd2CardCPP-409">  }</front>
<front id="Sd2CardCPP-410">  if (status_ != DATA_START_BLOCK) {</front>
<front id="Sd2CardCPP-411">    error(SD_CARD_ERROR_READ);</front>
<front id="Sd2CardCPP-412">    goto fail;</front>
<front id="Sd2CardCPP-413">  }</front>
<front id="Sd2CardCPP-414">  // transfer data</front>
<front id="Sd2CardCPP-415">  spiRead(dst, count);</front>
<front id="Sd2CardCPP-416"></front>
<front id="Sd2CardCPP-417">  // discard CRC</front>
<front id="Sd2CardCPP-418">  spiRec();</front>
<front id="Sd2CardCPP-419">  spiRec();</front>
<front id="Sd2CardCPP-420">  chipSelectHigh();</front>
<front id="Sd2CardCPP-421">  return true;</front>
<front id="Sd2CardCPP-422"></front>
<front id="Sd2CardCPP-423"> fail:</front>
<front id="Sd2CardCPP-424">  chipSelectHigh();</front>
<front id="Sd2CardCPP-425">  return false;</front>
<front id="Sd2CardCPP-426">}</front>
<front id="Sd2CardCPP-427">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-428">/** read CID or CSR register */</front>
<front id="Sd2CardCPP-429">bool Sd2Card::readRegister(uint8_t cmd, void* buf) {</front>
<front id="Sd2CardCPP-430">  uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(buf);</front>
<front id="Sd2CardCPP-431">  if (cardCommand(cmd, 0)) {</front>
<front id="Sd2CardCPP-432">    error(SD_CARD_ERROR_READ_REG);</front>
<front id="Sd2CardCPP-433">    goto fail;</front>
<front id="Sd2CardCPP-434">  }</front>
<front id="Sd2CardCPP-435">  return readData(dst, 16);</front>
<front id="Sd2CardCPP-436"></front>
<front id="Sd2CardCPP-437"> fail:</front>
<front id="Sd2CardCPP-438">  chipSelectHigh();</front>
<front id="Sd2CardCPP-439">  return false;</front>
<front id="Sd2CardCPP-440">}</front>
<front id="Sd2CardCPP-441">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-442">/** Start a read multiple blocks sequence.</front>
<front id="Sd2CardCPP-443"> *</front>
<front id="Sd2CardCPP-444"> * \param[in] blockNumber Address of first block in sequence.</front>
<front id="Sd2CardCPP-445"> *</front>
<front id="Sd2CardCPP-446"> * \note This function is used with readData() and readStop() for optimized</front>
<front id="Sd2CardCPP-447"> * multiple block reads.  SPI chipSelect must be low for the entire sequence.</front>
<front id="Sd2CardCPP-448"> *</front>
<front id="Sd2CardCPP-449"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-450"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-451"> */</front>
<front id="Sd2CardCPP-452">bool Sd2Card::readStart(uint32_t blockNumber) {</front>
<front id="Sd2CardCPP-453">  if (type()!= SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-454">  if (cardCommand(CMD18, blockNumber)) {</front>
<front id="Sd2CardCPP-455">    error(SD_CARD_ERROR_CMD18);</front>
<front id="Sd2CardCPP-456">    goto fail;</front>
<front id="Sd2CardCPP-457">  }</front>
<front id="Sd2CardCPP-458">  chipSelectHigh();</front>
<front id="Sd2CardCPP-459">  return true;</front>
<front id="Sd2CardCPP-460"></front>
<front id="Sd2CardCPP-461"> fail:</front>
<front id="Sd2CardCPP-462">  chipSelectHigh();</front>
<front id="Sd2CardCPP-463">  return false;</front>
<front id="Sd2CardCPP-464">}</front>
<front id="Sd2CardCPP-465">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-466">/** End a read multiple blocks sequence.</front>
<front id="Sd2CardCPP-467"> *</front>
<front id="Sd2CardCPP-468">* \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-469"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-470"> */</front>
<front id="Sd2CardCPP-471">bool Sd2Card::readStop() {</front>
<front id="Sd2CardCPP-472">  chipSelectLow();</front>
<front id="Sd2CardCPP-473">  if (cardCommand(CMD12, 0)) {</front>
<front id="Sd2CardCPP-474">    error(SD_CARD_ERROR_CMD12);</front>
<front id="Sd2CardCPP-475">    goto fail;</front>
<front id="Sd2CardCPP-476">  }</front>
<front id="Sd2CardCPP-477">  chipSelectHigh();</front>
<front id="Sd2CardCPP-478">  return true;</front>
<front id="Sd2CardCPP-479"></front>
<front id="Sd2CardCPP-480"> fail:</front>
<front id="Sd2CardCPP-481">  chipSelectHigh();</front>
<front id="Sd2CardCPP-482">  return false;</front>
<front id="Sd2CardCPP-483">}</front>
<front id="Sd2CardCPP-484">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-485">/**</front>
<front id="Sd2CardCPP-486"> * Set the SPI clock rate.</front>
<front id="Sd2CardCPP-487"> *</front>
<front id="Sd2CardCPP-488"> * \param[in] sckRateID A value in the range [0, 6].</front>
<front id="Sd2CardCPP-489"> *</front>
<front id="Sd2CardCPP-490"> * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum</front>
<front id="Sd2CardCPP-491"> * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128</front>
<front id="Sd2CardCPP-492"> * for \a scsRateID = 6.</front>
<front id="Sd2CardCPP-493"> *</front>
<front id="Sd2CardCPP-494"> * \return The value one, true, is returned for success and the value zero,</front>
<front id="Sd2CardCPP-495"> * false, is returned for an invalid value of \a sckRateID.</front>
<front id="Sd2CardCPP-496"> */</front>
<front id="Sd2CardCPP-497">bool Sd2Card::setSckRate(uint8_t sckRateID) {</front>
<front id="Sd2CardCPP-498">  if (sckRateID &gt; 6) {</front>
<front id="Sd2CardCPP-499">    error(SD_CARD_ERROR_SCK_RATE);</front>
<front id="Sd2CardCPP-500">    return false;</front>
<front id="Sd2CardCPP-501">  }</front>
<front id="Sd2CardCPP-502">  spiRate_ = sckRateID;</front>
<front id="Sd2CardCPP-503">  return true;</front>
<front id="Sd2CardCPP-504">}</front>
<front id="Sd2CardCPP-505">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-506">// wait for card to go not busy</front>
<front id="Sd2CardCPP-507">bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {</front>
<front id="Sd2CardCPP-508">  uint16_t t0 = millis();</front>
<front id="Sd2CardCPP-509">  while (spiRec() != 0XFF) {</front>
<front id="Sd2CardCPP-510">    if (((uint16_t)millis() - t0) &gt;= timeoutMillis) goto fail;</front>
<front id="Sd2CardCPP-511">  }</front>
<front id="Sd2CardCPP-512">  return true;</front>
<front id="Sd2CardCPP-513"></front>
<front id="Sd2CardCPP-514"> fail:</front>
<front id="Sd2CardCPP-515">  return false;</front>
<front id="Sd2CardCPP-516">}</front>
<front id="Sd2CardCPP-517">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-518">/**</front>
<front id="Sd2CardCPP-519"> * Writes a 512 byte block to an SD card.</front>
<front id="Sd2CardCPP-520"> *</front>
<front id="Sd2CardCPP-521"> * \param[in] blockNumber Logical block to be written.</front>
<front id="Sd2CardCPP-522"> * \param[in] src Pointer to the location of the data to be written.</front>
<front id="Sd2CardCPP-523"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-524"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-525"> */</front>
<front id="Sd2CardCPP-526">bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {</front>
<front id="Sd2CardCPP-527">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-528">  if (type() != SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-529">  if (cardCommand(CMD24, blockNumber)) {</front>
<front id="Sd2CardCPP-530">    error(SD_CARD_ERROR_CMD24);</front>
<front id="Sd2CardCPP-531">    goto fail;</front>
<front id="Sd2CardCPP-532">  }</front>
<front id="Sd2CardCPP-533">  if (!writeData(DATA_START_BLOCK, src)) goto fail;</front>
<front id="Sd2CardCPP-534"></front>
<front id="Sd2CardCPP-535">  // wait for flash programming to complete</front>
<front id="Sd2CardCPP-536">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {</front>
<front id="Sd2CardCPP-537">    error(SD_CARD_ERROR_WRITE_TIMEOUT);</front>
<front id="Sd2CardCPP-538">    goto fail;</front>
<front id="Sd2CardCPP-539">  }</front>
<front id="Sd2CardCPP-540">  // response is r2 so get and check two bytes for nonzero</front>
<front id="Sd2CardCPP-541">  if (cardCommand(CMD13, 0) || spiRec()) {</front>
<front id="Sd2CardCPP-542">    error(SD_CARD_ERROR_WRITE_PROGRAMMING);</front>
<front id="Sd2CardCPP-543">    goto fail;</front>
<front id="Sd2CardCPP-544">  }</front>
<front id="Sd2CardCPP-545">  chipSelectHigh();</front>
<front id="Sd2CardCPP-546">  return true;</front>
<front id="Sd2CardCPP-547"></front>
<front id="Sd2CardCPP-548"> fail:</front>
<front id="Sd2CardCPP-549">  chipSelectHigh();</front>
<front id="Sd2CardCPP-550">  return false;</front>
<front id="Sd2CardCPP-551">}</front>
<front id="Sd2CardCPP-552">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-553">/** Write one data block in a multiple block write sequence</front>
<front id="Sd2CardCPP-554"> * \param[in] src Pointer to the location of the data to be written.</front>
<front id="Sd2CardCPP-555"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-556"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-557"> */</front>
<front id="Sd2CardCPP-558">bool Sd2Card::writeData(const uint8_t* src) {</front>
<front id="Sd2CardCPP-559">  chipSelectLow();</front>
<front id="Sd2CardCPP-560">  // wait for previous write to finish</front>
<front id="Sd2CardCPP-561">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;</front>
<front id="Sd2CardCPP-562">  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto fail;</front>
<front id="Sd2CardCPP-563">  chipSelectHigh();</front>
<front id="Sd2CardCPP-564">  return true;</front>
<front id="Sd2CardCPP-565"></front>
<front id="Sd2CardCPP-566"> fail:</front>
<front id="Sd2CardCPP-567">  error(SD_CARD_ERROR_WRITE_MULTIPLE);</front>
<front id="Sd2CardCPP-568">  chipSelectHigh();</front>
<front id="Sd2CardCPP-569">  return false;</front>
<front id="Sd2CardCPP-570">}</front>
<front id="Sd2CardCPP-571">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-572">// send one block of data for write block or write multiple blocks</front>
<front id="Sd2CardCPP-573">bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {</front>
<front id="Sd2CardCPP-574">  spiSendBlock(token, src);</front>
<front id="Sd2CardCPP-575"></front>
<front id="Sd2CardCPP-576">  spiSend(0xff);  // dummy crc</front>
<front id="Sd2CardCPP-577">  spiSend(0xff);  // dummy crc</front>
<front id="Sd2CardCPP-578"></front>
<front id="Sd2CardCPP-579">  status_ = spiRec();</front>
<front id="Sd2CardCPP-580">  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {</front>
<front id="Sd2CardCPP-581">    error(SD_CARD_ERROR_WRITE);</front>
<front id="Sd2CardCPP-582">    goto fail;</front>
<front id="Sd2CardCPP-583">  }</front>
<front id="Sd2CardCPP-584">  return true;</front>
<front id="Sd2CardCPP-585"></front>
<front id="Sd2CardCPP-586"> fail:</front>
<front id="Sd2CardCPP-587">  chipSelectHigh();</front>
<front id="Sd2CardCPP-588">  return false;</front>
<front id="Sd2CardCPP-589">}</front>
<front id="Sd2CardCPP-590">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-591">/** Start a write multiple blocks sequence.</front>
<front id="Sd2CardCPP-592"> *</front>
<front id="Sd2CardCPP-593"> * \param[in] blockNumber Address of first block in sequence.</front>
<front id="Sd2CardCPP-594"> * \param[in] eraseCount The number of blocks to be pre-erased.</front>
<front id="Sd2CardCPP-595"> *</front>
<front id="Sd2CardCPP-596"> * \note This function is used with writeData() and writeStop()</front>
<front id="Sd2CardCPP-597"> * for optimized multiple block writes.</front>
<front id="Sd2CardCPP-598"> *</front>
<front id="Sd2CardCPP-599"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-600"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-601"> */</front>
<front id="Sd2CardCPP-602">bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {</front>
<front id="Sd2CardCPP-603">  // send pre-erase count</front>
<front id="Sd2CardCPP-604">  if (cardAcmd(ACMD23, eraseCount)) {</front>
<front id="Sd2CardCPP-605">    error(SD_CARD_ERROR_ACMD23);</front>
<front id="Sd2CardCPP-606">    goto fail;</front>
<front id="Sd2CardCPP-607">  }</front>
<front id="Sd2CardCPP-608">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-609">  if (type() != SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-610">  if (cardCommand(CMD25, blockNumber)) {</front>
<front id="Sd2CardCPP-611">    error(SD_CARD_ERROR_CMD25);</front>
<front id="Sd2CardCPP-612">    goto fail;</front>
<front id="Sd2CardCPP-613">  }</front>
<front id="Sd2CardCPP-614">  chipSelectHigh();</front>
<front id="Sd2CardCPP-615">  return true;</front>
<front id="Sd2CardCPP-616"></front>
<front id="Sd2CardCPP-617"> fail:</front>
<front id="Sd2CardCPP-618">  chipSelectHigh();</front>
<front id="Sd2CardCPP-619">  return false;</front>
<front id="Sd2CardCPP-620">}</front>
<front id="Sd2CardCPP-621">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-622">/** End a write multiple blocks sequence.</front>
<front id="Sd2CardCPP-623"> *</front>
<front id="Sd2CardCPP-624">* \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-625"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-626"> */</front>
<front id="Sd2CardCPP-627">bool Sd2Card::writeStop() {</front>
<front id="Sd2CardCPP-628">  chipSelectLow();</front>
<front id="Sd2CardCPP-629">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;</front>
<front id="Sd2CardCPP-630">  spiSend(STOP_TRAN_TOKEN);</front>
<front id="Sd2CardCPP-631">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;</front>
<front id="Sd2CardCPP-632">  chipSelectHigh();</front>
<front id="Sd2CardCPP-633">  return true;</front>
<front id="Sd2CardCPP-634"></front>
<front id="Sd2CardCPP-635"> fail:</front>
<front id="Sd2CardCPP-636">  error(SD_CARD_ERROR_STOP_TRAN);</front>
<front id="Sd2CardCPP-637">  chipSelectHigh();</front>
<front id="Sd2CardCPP-638">  return false;</front>
<front id="Sd2CardCPP-639">}</front>
<front id="Sd2CardCPP-640"></front>
<front id="Sd2CardCPP-641">#endif</front>
 </pre>
<h1>Sd2Card.h</h1>
<pre  class="prettyprint linenums"><front id="Sd2CardH-1">/* Arduino Sd2Card Library</front>
<front id="Sd2CardH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="Sd2CardH-3"> *</front>
<front id="Sd2CardH-4"> * This file is part of the Arduino Sd2Card Library</front>
<front id="Sd2CardH-5"> *</front>
<front id="Sd2CardH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="Sd2CardH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="Sd2CardH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Sd2CardH-9"> * (at your option) any later version.</front>
<front id="Sd2CardH-10"> *</front>
<front id="Sd2CardH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="Sd2CardH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Sd2CardH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Sd2CardH-14"> * GNU General Public License for more details.</front>
<front id="Sd2CardH-15"> *</front>
<front id="Sd2CardH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="Sd2CardH-17"> * along with the Arduino Sd2Card Library.  If not, see</front>
<front id="Sd2CardH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Sd2CardH-19"> */</front>
<front id="Sd2CardH-20"></front>
<front id="Sd2CardH-21">#include "Marlin.h"</front>
<front id="Sd2CardH-22">#ifdef SDSUPPORT</front>
<front id="Sd2CardH-23"></front>
<front id="Sd2CardH-24">#ifndef Sd2Card_h</front>
<front id="Sd2CardH-25">#define Sd2Card_h</front>
<front id="Sd2CardH-26">/**</front>
<front id="Sd2CardH-27"> * \file</front>
<front id="Sd2CardH-28"> * \brief Sd2Card class for V2 SD/SDHC cards</front>
<front id="Sd2CardH-29"> */</front>
<front id="Sd2CardH-30">#include "SdFatConfig.h"</front>
<front id="Sd2CardH-31">#include "Sd2PinMap.h"</front>
<front id="Sd2CardH-32">#include "SdInfo.h"</front>
<front id="Sd2CardH-33">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-34">// SPI speed is F_CPU/2^(1 + index), 0 &lt;= index &lt;= 6</front>
<front id="Sd2CardH-35">/** Set SCK to max rate of F_CPU/2. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-36">uint8_t const SPI_FULL_SPEED = 0;</front>
<front id="Sd2CardH-37">/** Set SCK rate to F_CPU/4. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-38">uint8_t const SPI_HALF_SPEED = 1;</front>
<front id="Sd2CardH-39">/** Set SCK rate to F_CPU/8. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-40">uint8_t const SPI_QUARTER_SPEED = 2;</front>
<front id="Sd2CardH-41">/** Set SCK rate to F_CPU/16. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-42">uint8_t const SPI_EIGHTH_SPEED = 3;</front>
<front id="Sd2CardH-43">/** Set SCK rate to F_CPU/32. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-44">uint8_t const SPI_SIXTEENTH_SPEED = 4;</front>
<front id="Sd2CardH-45">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-46">/** init timeout ms */</front>
<front id="Sd2CardH-47">uint16_t const SD_INIT_TIMEOUT = 2000;</front>
<front id="Sd2CardH-48">/** erase timeout ms */</front>
<front id="Sd2CardH-49">uint16_t const SD_ERASE_TIMEOUT = 10000;</front>
<front id="Sd2CardH-50">/** read timeout ms */</front>
<front id="Sd2CardH-51">uint16_t const SD_READ_TIMEOUT = 300;</front>
<front id="Sd2CardH-52">/** write time out ms */</front>
<front id="Sd2CardH-53">uint16_t const SD_WRITE_TIMEOUT = 600;</front>
<front id="Sd2CardH-54">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-55">// SD card errors</front>
<front id="Sd2CardH-56">/** timeout error for command CMD0 (initialize card in SPI mode) */</front>
<front id="Sd2CardH-57">uint8_t const SD_CARD_ERROR_CMD0 = 0X1;</front>
<front id="Sd2CardH-58">/** CMD8 was not accepted - not a valid SD card*/</front>
<front id="Sd2CardH-59">uint8_t const SD_CARD_ERROR_CMD8 = 0X2;</front>
<front id="Sd2CardH-60">/** card returned an error response for CMD12 (write stop) */</front>
<front id="Sd2CardH-61">uint8_t const SD_CARD_ERROR_CMD12 = 0X3;</front>
<front id="Sd2CardH-62">/** card returned an error response for CMD17 (read block) */</front>
<front id="Sd2CardH-63">uint8_t const SD_CARD_ERROR_CMD17 = 0X4;</front>
<front id="Sd2CardH-64">/** card returned an error response for CMD18 (read multiple block) */</front>
<front id="Sd2CardH-65">uint8_t const SD_CARD_ERROR_CMD18 = 0X5;</front>
<front id="Sd2CardH-66">/** card returned an error response for CMD24 (write block) */</front>
<front id="Sd2CardH-67">uint8_t const SD_CARD_ERROR_CMD24 = 0X6;</front>
<front id="Sd2CardH-68">/**  WRITE_MULTIPLE_BLOCKS command failed */</front>
<front id="Sd2CardH-69">uint8_t const SD_CARD_ERROR_CMD25 = 0X7;</front>
<front id="Sd2CardH-70">/** card returned an error response for CMD58 (read OCR) */</front>
<front id="Sd2CardH-71">uint8_t const SD_CARD_ERROR_CMD58 = 0X8;</front>
<front id="Sd2CardH-72">/** SET_WR_BLK_ERASE_COUNT failed */</front>
<front id="Sd2CardH-73">uint8_t const SD_CARD_ERROR_ACMD23 = 0X9;</front>
<front id="Sd2CardH-74">/** ACMD41 initialization process timeout */</front>
<front id="Sd2CardH-75">uint8_t const SD_CARD_ERROR_ACMD41 = 0XA;</front>
<front id="Sd2CardH-76">/** card returned a bad CSR version field */</front>
<front id="Sd2CardH-77">uint8_t const SD_CARD_ERROR_BAD_CSD = 0XB;</front>
<front id="Sd2CardH-78">/** erase block group command failed */</front>
<front id="Sd2CardH-79">uint8_t const SD_CARD_ERROR_ERASE = 0XC;</front>
<front id="Sd2CardH-80">/** card not capable of single block erase */</front>
<front id="Sd2CardH-81">uint8_t const SD_CARD_ERROR_ERASE_SINGLE_BLOCK = 0XD;</front>
<front id="Sd2CardH-82">/** Erase sequence timed out */</front>
<front id="Sd2CardH-83">uint8_t const SD_CARD_ERROR_ERASE_TIMEOUT = 0XE;</front>
<front id="Sd2CardH-84">/** card returned an error token instead of read data */</front>
<front id="Sd2CardH-85">uint8_t const SD_CARD_ERROR_READ = 0XF;</front>
<front id="Sd2CardH-86">/** read CID or CSD failed */</front>
<front id="Sd2CardH-87">uint8_t const SD_CARD_ERROR_READ_REG = 0X10;</front>
<front id="Sd2CardH-88">/** timeout while waiting for start of read data */</front>
<front id="Sd2CardH-89">uint8_t const SD_CARD_ERROR_READ_TIMEOUT = 0X11;</front>
<front id="Sd2CardH-90">/** card did not accept STOP_TRAN_TOKEN */</front>
<front id="Sd2CardH-91">uint8_t const SD_CARD_ERROR_STOP_TRAN = 0X12;</front>
<front id="Sd2CardH-92">/** card returned an error token as a response to a write operation */</front>
<front id="Sd2CardH-93">uint8_t const SD_CARD_ERROR_WRITE = 0X13;</front>
<front id="Sd2CardH-94">/** attempt to write protected block zero */</front>
<front id="Sd2CardH-95">uint8_t const SD_CARD_ERROR_WRITE_BLOCK_ZERO = 0X14;  // REMOVE - not used</front>
<front id="Sd2CardH-96">/** card did not go ready for a multiple block write */</front>
<front id="Sd2CardH-97">uint8_t const SD_CARD_ERROR_WRITE_MULTIPLE = 0X15;</front>
<front id="Sd2CardH-98">/** card returned an error to a CMD13 status check after a write */</front>
<front id="Sd2CardH-99">uint8_t const SD_CARD_ERROR_WRITE_PROGRAMMING = 0X16;</front>
<front id="Sd2CardH-100">/** timeout occurred during write programming */</front>
<front id="Sd2CardH-101">uint8_t const SD_CARD_ERROR_WRITE_TIMEOUT = 0X17;</front>
<front id="Sd2CardH-102">/** incorrect rate selected */</front>
<front id="Sd2CardH-103">uint8_t const SD_CARD_ERROR_SCK_RATE = 0X18;</front>
<front id="Sd2CardH-104">/** init() not called */</front>
<front id="Sd2CardH-105">uint8_t const SD_CARD_ERROR_INIT_NOT_CALLED = 0X19;</front>
<front id="Sd2CardH-106">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-107">// card types</front>
<front id="Sd2CardH-108">/** Standard capacity V1 SD card */</front>
<front id="Sd2CardH-109">uint8_t const SD_CARD_TYPE_SD1  = 1;</front>
<front id="Sd2CardH-110">/** Standard capacity V2 SD card */</front>
<front id="Sd2CardH-111">uint8_t const SD_CARD_TYPE_SD2  = 2;</front>
<front id="Sd2CardH-112">/** High Capacity SD card */</front>
<front id="Sd2CardH-113">uint8_t const SD_CARD_TYPE_SDHC = 3;</front>
<front id="Sd2CardH-114">/**</front>
<front id="Sd2CardH-115"> * define SOFTWARE_SPI to use bit-bang SPI</front>
<front id="Sd2CardH-116"> */</front>
<front id="Sd2CardH-117">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-118">#if MEGA_SOFT_SPI && (defined(__AVR_ATmega1280__)||defined(__AVR_ATmega2560__))</front>
<front id="Sd2CardH-119">#define SOFTWARE_SPI</front>
<front id="Sd2CardH-120">#elif USE_SOFTWARE_SPI</front>
<front id="Sd2CardH-121">#define SOFTWARE_SPI</front>
<front id="Sd2CardH-122">#endif  // MEGA_SOFT_SPI</front>
<front id="Sd2CardH-123">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-124">// SPI pin definitions - do not edit here - change in SdFatConfig.h</front>
<front id="Sd2CardH-125">//</front>
<front id="Sd2CardH-126">#ifndef SOFTWARE_SPI</front>
<front id="Sd2CardH-127">// hardware pin defs</front>
<front id="Sd2CardH-128">/** The default chip select pin for the SD card is SS. */</front>
<front id="Sd2CardH-129">uint8_t const  SD_CHIP_SELECT_PIN = SS_PIN;</front>
<front id="Sd2CardH-130">// The following three pins must not be redefined for hardware SPI.</front>
<front id="Sd2CardH-131">/** SPI Master Out Slave In pin */</front>
<front id="Sd2CardH-132">uint8_t const  SPI_MOSI_PIN = MOSI_PIN;</front>
<front id="Sd2CardH-133">/** SPI Master In Slave Out pin */</front>
<front id="Sd2CardH-134">uint8_t const  SPI_MISO_PIN = MISO_PIN;</front>
<front id="Sd2CardH-135">/** SPI Clock pin */</front>
<front id="Sd2CardH-136">uint8_t const  SPI_SCK_PIN = SCK_PIN;</front>
<front id="Sd2CardH-137"></front>
<front id="Sd2CardH-138">#else  // SOFTWARE_SPI</front>
<front id="Sd2CardH-139"></front>
<front id="Sd2CardH-140">/** SPI chip select pin */</front>
<front id="Sd2CardH-141">uint8_t const SD_CHIP_SELECT_PIN = SOFT_SPI_CS_PIN;</front>
<front id="Sd2CardH-142">/** SPI Master Out Slave In pin */</front>
<front id="Sd2CardH-143">uint8_t const SPI_MOSI_PIN = SOFT_SPI_MOSI_PIN;</front>
<front id="Sd2CardH-144">/** SPI Master In Slave Out pin */</front>
<front id="Sd2CardH-145">uint8_t const SPI_MISO_PIN = SOFT_SPI_MISO_PIN;</front>
<front id="Sd2CardH-146">/** SPI Clock pin */</front>
<front id="Sd2CardH-147">uint8_t const SPI_SCK_PIN = SOFT_SPI_SCK_PIN;</front>
<front id="Sd2CardH-148">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardH-149">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-150">/**</front>
<front id="Sd2CardH-151"> * \class Sd2Card</front>
<front id="Sd2CardH-152"> * \brief Raw access to SD and SDHC flash memory cards.</front>
<front id="Sd2CardH-153"> */</front>
<front id="Sd2CardH-154">class Sd2Card {</front>
<front id="Sd2CardH-155"> public:</front>
<front id="Sd2CardH-156">  /** Construct an instance of Sd2Card. */</front>
<front id="Sd2CardH-157">  Sd2Card() : errorCode_(SD_CARD_ERROR_INIT_NOT_CALLED), type_(0) {}</front>
<front id="Sd2CardH-158">  uint32_t cardSize();</front>
<front id="Sd2CardH-159">  bool erase(uint32_t firstBlock, uint32_t lastBlock);</front>
<front id="Sd2CardH-160">  bool eraseSingleBlockEnable();</front>
<front id="Sd2CardH-161">  /**</front>
<front id="Sd2CardH-162">   *  Set SD error code.</front>
<front id="Sd2CardH-163">   *  \param[in] code value for error code.</front>
<front id="Sd2CardH-164">   */</front>
<front id="Sd2CardH-165">  void error(uint8_t code) {errorCode_ = code;}</front>
<front id="Sd2CardH-166">  /**</front>
<front id="Sd2CardH-167">   * \return error code for last error. See Sd2Card.h for a list of error codes.</front>
<front id="Sd2CardH-168">   */</front>
<front id="Sd2CardH-169">  int errorCode() const {return errorCode_;}</front>
<front id="Sd2CardH-170">  /** \return error data for last error. */</front>
<front id="Sd2CardH-171">  int errorData() const {return status_;}</front>
<front id="Sd2CardH-172">  /**</front>
<front id="Sd2CardH-173">   * Initialize an SD flash memory card with default clock rate and chip</front>
<front id="Sd2CardH-174">   * select pin.  See sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin).</front>
<front id="Sd2CardH-175">   *</front>
<front id="Sd2CardH-176">   * \return true for success or false for failure.</front>
<front id="Sd2CardH-177">   */</front>
<front id="Sd2CardH-178">  bool init(uint8_t sckRateID = SPI_FULL_SPEED,</front>
<front id="Sd2CardH-179">    uint8_t chipSelectPin = SD_CHIP_SELECT_PIN);</front>
<front id="Sd2CardH-180">  bool readBlock(uint32_t block, uint8_t* dst);</front>
<front id="Sd2CardH-181">  /**</front>
<front id="Sd2CardH-182">   * Read a card's CID register. The CID contains card identification</front>
<front id="Sd2CardH-183">   * information such as Manufacturer ID, Product name, Product serial</front>
<front id="Sd2CardH-184">   * number and Manufacturing date. </front>
<front id="Sd2CardH-185">   *</front>
<front id="Sd2CardH-186">   * \param[out] cid pointer to area for returned data.</front>
<front id="Sd2CardH-187">   *</front>
<front id="Sd2CardH-188">   * \return true for success or false for failure.</front>
<front id="Sd2CardH-189">   */</front>
<front id="Sd2CardH-190">  bool readCID(cid_t* cid) {</front>
<front id="Sd2CardH-191">    return readRegister(CMD10, cid);</front>
<front id="Sd2CardH-192">  }</front>
<front id="Sd2CardH-193">  /**</front>
<front id="Sd2CardH-194">   * Read a card's CSD register. The CSD contains Card-Specific Data that</front>
<front id="Sd2CardH-195">   * provides information regarding access to the card's contents.</front>
<front id="Sd2CardH-196">   *</front>
<front id="Sd2CardH-197">   * \param[out] csd pointer to area for returned data.</front>
<front id="Sd2CardH-198">   *</front>
<front id="Sd2CardH-199">   * \return true for success or false for failure.</front>
<front id="Sd2CardH-200">   */</front>
<front id="Sd2CardH-201">  bool readCSD(csd_t* csd) {</front>
<front id="Sd2CardH-202">    return readRegister(CMD9, csd);</front>
<front id="Sd2CardH-203">  }</front>
<front id="Sd2CardH-204">  bool readData(uint8_t *dst);</front>
<front id="Sd2CardH-205">  bool readStart(uint32_t blockNumber);</front>
<front id="Sd2CardH-206">  bool readStop();</front>
<front id="Sd2CardH-207">  bool setSckRate(uint8_t sckRateID);</front>
<front id="Sd2CardH-208">  /** Return the card type: SD V1, SD V2 or SDHC</front>
<front id="Sd2CardH-209">   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC.</front>
<front id="Sd2CardH-210">   */</front>
<front id="Sd2CardH-211">  int type() const {return type_;}</front>
<front id="Sd2CardH-212">  bool writeBlock(uint32_t blockNumber, const uint8_t* src);</front>
<front id="Sd2CardH-213">  bool writeData(const uint8_t* src);</front>
<front id="Sd2CardH-214">  bool writeStart(uint32_t blockNumber, uint32_t eraseCount);</front>
<front id="Sd2CardH-215">  bool writeStop();</front>
<front id="Sd2CardH-216"> private:</front>
<front id="Sd2CardH-217">  //----------------------------------------------------------------------------</front>
<front id="Sd2CardH-218">  uint8_t chipSelectPin_;</front>
<front id="Sd2CardH-219">  uint8_t errorCode_;</front>
<front id="Sd2CardH-220">  uint8_t spiRate_;</front>
<front id="Sd2CardH-221">  uint8_t status_;</front>
<front id="Sd2CardH-222">  uint8_t type_;</front>
<front id="Sd2CardH-223">  // private functions</front>
<front id="Sd2CardH-224">  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {</front>
<front id="Sd2CardH-225">    cardCommand(CMD55, 0);</front>
<front id="Sd2CardH-226">    return cardCommand(cmd, arg);</front>
<front id="Sd2CardH-227">  }</front>
<front id="Sd2CardH-228">  uint8_t cardCommand(uint8_t cmd, uint32_t arg);</front>
<front id="Sd2CardH-229"></front>
<front id="Sd2CardH-230">  bool readData(uint8_t* dst, uint16_t count);</front>
<front id="Sd2CardH-231">  bool readRegister(uint8_t cmd, void* buf);</front>
<front id="Sd2CardH-232">  void chipSelectHigh();</front>
<front id="Sd2CardH-233">  void chipSelectLow();</front>
<front id="Sd2CardH-234">  void type(uint8_t value) {type_ = value;}</front>
<front id="Sd2CardH-235">  bool waitNotBusy(uint16_t timeoutMillis);</front>
<front id="Sd2CardH-236">  bool writeData(uint8_t token, const uint8_t* src);</front>
<front id="Sd2CardH-237">};</front>
<front id="Sd2CardH-238">#endif  // Sd2Card_h</front>
<front id="Sd2CardH-239"></front>
<front id="Sd2CardH-240"></front>
<front id="Sd2CardH-241">#endif</front>
 </pre>
<h1>Sd2PinMap.h</h1>
<pre  class="prettyprint linenums"><front id="Sd2PinMapH-1">/* Arduino SdFat Library</front>
<front id="Sd2PinMapH-2"> * Copyright (C) 2010 by William Greiman</front>
<front id="Sd2PinMapH-3"> *</front>
<front id="Sd2PinMapH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="Sd2PinMapH-5"> *</front>
<front id="Sd2PinMapH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="Sd2PinMapH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="Sd2PinMapH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Sd2PinMapH-9"> * (at your option) any later version.</front>
<front id="Sd2PinMapH-10"> *</front>
<front id="Sd2PinMapH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="Sd2PinMapH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Sd2PinMapH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Sd2PinMapH-14"> * GNU General Public License for more details.</front>
<front id="Sd2PinMapH-15"> *</front>
<front id="Sd2PinMapH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="Sd2PinMapH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="Sd2PinMapH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Sd2PinMapH-19"> */</front>
<front id="Sd2PinMapH-20">// Warning this file was generated by a program.</front>
<front id="Sd2PinMapH-21">#include "Marlin.h"</front>
<front id="Sd2PinMapH-22">#ifdef SDSUPPORT</front>
<front id="Sd2PinMapH-23"></front>
<front id="Sd2PinMapH-24">#ifndef Sd2PinMap_h</front>
<front id="Sd2PinMapH-25">#define Sd2PinMap_h</front>
<front id="Sd2PinMapH-26">#include &lt;avr/io.h&gt;</front>
<front id="Sd2PinMapH-27">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-28">/** struct for mapping digital pins */</front>
<front id="Sd2PinMapH-29">struct pin_map_t {</front>
<front id="Sd2PinMapH-30">  volatile uint8_t* ddr;</front>
<front id="Sd2PinMapH-31">  volatile uint8_t* pin;</front>
<front id="Sd2PinMapH-32">  volatile uint8_t* port;</front>
<front id="Sd2PinMapH-33">  uint8_t bit;</front>
<front id="Sd2PinMapH-34">};</front>
<front id="Sd2PinMapH-35">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-36">#if defined(__AVR_ATmega1280__)\</front>
<front id="Sd2PinMapH-37">|| defined(__AVR_ATmega2560__)</front>
<front id="Sd2PinMapH-38">// Mega</front>
<front id="Sd2PinMapH-39"></front>
<front id="Sd2PinMapH-40">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-41">uint8_t const SDA_PIN = 20;  // D1</front>
<front id="Sd2PinMapH-42">uint8_t const SCL_PIN = 21;  // D0</front>
<front id="Sd2PinMapH-43"></front>
<front id="Sd2PinMapH-44">#undef MOSI_PIN</front>
<front id="Sd2PinMapH-45">#undef MISO_PIN</front>
<front id="Sd2PinMapH-46">// SPI port</front>
<front id="Sd2PinMapH-47">uint8_t const SS_PIN = 53;    // B0</front>
<front id="Sd2PinMapH-48">uint8_t const MOSI_PIN = 51;  // B2</front>
<front id="Sd2PinMapH-49">uint8_t const MISO_PIN = 50;  // B3</front>
<front id="Sd2PinMapH-50">uint8_t const SCK_PIN = 52;   // B1</front>
<front id="Sd2PinMapH-51"></front>
<front id="Sd2PinMapH-52">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-53">  {&DDRE, &PINE, &PORTE, 0},  // E0  0</front>
<front id="Sd2PinMapH-54">  {&DDRE, &PINE, &PORTE, 1},  // E1  1</front>
<front id="Sd2PinMapH-55">  {&DDRE, &PINE, &PORTE, 4},  // E4  2</front>
<front id="Sd2PinMapH-56">  {&DDRE, &PINE, &PORTE, 5},  // E5  3</front>
<front id="Sd2PinMapH-57">  {&DDRG, &PING, &PORTG, 5},  // G5  4</front>
<front id="Sd2PinMapH-58">  {&DDRE, &PINE, &PORTE, 3},  // E3  5</front>
<front id="Sd2PinMapH-59">  {&DDRH, &PINH, &PORTH, 3},  // H3  6</front>
<front id="Sd2PinMapH-60">  {&DDRH, &PINH, &PORTH, 4},  // H4  7</front>
<front id="Sd2PinMapH-61">  {&DDRH, &PINH, &PORTH, 5},  // H5  8</front>
<front id="Sd2PinMapH-62">  {&DDRH, &PINH, &PORTH, 6},  // H6  9</front>
<front id="Sd2PinMapH-63">  {&DDRB, &PINB, &PORTB, 4},  // B4 10</front>
<front id="Sd2PinMapH-64">  {&DDRB, &PINB, &PORTB, 5},  // B5 11</front>
<front id="Sd2PinMapH-65">  {&DDRB, &PINB, &PORTB, 6},  // B6 12</front>
<front id="Sd2PinMapH-66">  {&DDRB, &PINB, &PORTB, 7},  // B7 13</front>
<front id="Sd2PinMapH-67">  {&DDRJ, &PINJ, &PORTJ, 1},  // J1 14</front>
<front id="Sd2PinMapH-68">  {&DDRJ, &PINJ, &PORTJ, 0},  // J0 15</front>
<front id="Sd2PinMapH-69">  {&DDRH, &PINH, &PORTH, 1},  // H1 16</front>
<front id="Sd2PinMapH-70">  {&DDRH, &PINH, &PORTH, 0},  // H0 17</front>
<front id="Sd2PinMapH-71">  {&DDRD, &PIND, &PORTD, 3},  // D3 18</front>
<front id="Sd2PinMapH-72">  {&DDRD, &PIND, &PORTD, 2},  // D2 19</front>
<front id="Sd2PinMapH-73">  {&DDRD, &PIND, &PORTD, 1},  // D1 20</front>
<front id="Sd2PinMapH-74">  {&DDRD, &PIND, &PORTD, 0},  // D0 21</front>
<front id="Sd2PinMapH-75">  {&DDRA, &PINA, &PORTA, 0},  // A0 22</front>
<front id="Sd2PinMapH-76">  {&DDRA, &PINA, &PORTA, 1},  // A1 23</front>
<front id="Sd2PinMapH-77">  {&DDRA, &PINA, &PORTA, 2},  // A2 24</front>
<front id="Sd2PinMapH-78">  {&DDRA, &PINA, &PORTA, 3},  // A3 25</front>
<front id="Sd2PinMapH-79">  {&DDRA, &PINA, &PORTA, 4},  // A4 26</front>
<front id="Sd2PinMapH-80">  {&DDRA, &PINA, &PORTA, 5},  // A5 27</front>
<front id="Sd2PinMapH-81">  {&DDRA, &PINA, &PORTA, 6},  // A6 28</front>
<front id="Sd2PinMapH-82">  {&DDRA, &PINA, &PORTA, 7},  // A7 29</front>
<front id="Sd2PinMapH-83">  {&DDRC, &PINC, &PORTC, 7},  // C7 30</front>
<front id="Sd2PinMapH-84">  {&DDRC, &PINC, &PORTC, 6},  // C6 31</front>
<front id="Sd2PinMapH-85">  {&DDRC, &PINC, &PORTC, 5},  // C5 32</front>
<front id="Sd2PinMapH-86">  {&DDRC, &PINC, &PORTC, 4},  // C4 33</front>
<front id="Sd2PinMapH-87">  {&DDRC, &PINC, &PORTC, 3},  // C3 34</front>
<front id="Sd2PinMapH-88">  {&DDRC, &PINC, &PORTC, 2},  // C2 35</front>
<front id="Sd2PinMapH-89">  {&DDRC, &PINC, &PORTC, 1},  // C1 36</front>
<front id="Sd2PinMapH-90">  {&DDRC, &PINC, &PORTC, 0},  // C0 37</front>
<front id="Sd2PinMapH-91">  {&DDRD, &PIND, &PORTD, 7},  // D7 38</front>
<front id="Sd2PinMapH-92">  {&DDRG, &PING, &PORTG, 2},  // G2 39</front>
<front id="Sd2PinMapH-93">  {&DDRG, &PING, &PORTG, 1},  // G1 40</front>
<front id="Sd2PinMapH-94">  {&DDRG, &PING, &PORTG, 0},  // G0 41</front>
<front id="Sd2PinMapH-95">  {&DDRL, &PINL, &PORTL, 7},  // L7 42</front>
<front id="Sd2PinMapH-96">  {&DDRL, &PINL, &PORTL, 6},  // L6 43</front>
<front id="Sd2PinMapH-97">  {&DDRL, &PINL, &PORTL, 5},  // L5 44</front>
<front id="Sd2PinMapH-98">  {&DDRL, &PINL, &PORTL, 4},  // L4 45</front>
<front id="Sd2PinMapH-99">  {&DDRL, &PINL, &PORTL, 3},  // L3 46</front>
<front id="Sd2PinMapH-100">  {&DDRL, &PINL, &PORTL, 2},  // L2 47</front>
<front id="Sd2PinMapH-101">  {&DDRL, &PINL, &PORTL, 1},  // L1 48</front>
<front id="Sd2PinMapH-102">  {&DDRL, &PINL, &PORTL, 0},  // L0 49</front>
<front id="Sd2PinMapH-103">  {&DDRB, &PINB, &PORTB, 3},  // B3 50</front>
<front id="Sd2PinMapH-104">  {&DDRB, &PINB, &PORTB, 2},  // B2 51</front>
<front id="Sd2PinMapH-105">  {&DDRB, &PINB, &PORTB, 1},  // B1 52</front>
<front id="Sd2PinMapH-106">  {&DDRB, &PINB, &PORTB, 0},  // B0 53</front>
<front id="Sd2PinMapH-107">  {&DDRF, &PINF, &PORTF, 0},  // F0 54</front>
<front id="Sd2PinMapH-108">  {&DDRF, &PINF, &PORTF, 1},  // F1 55</front>
<front id="Sd2PinMapH-109">  {&DDRF, &PINF, &PORTF, 2},  // F2 56</front>
<front id="Sd2PinMapH-110">  {&DDRF, &PINF, &PORTF, 3},  // F3 57</front>
<front id="Sd2PinMapH-111">  {&DDRF, &PINF, &PORTF, 4},  // F4 58</front>
<front id="Sd2PinMapH-112">  {&DDRF, &PINF, &PORTF, 5},  // F5 59</front>
<front id="Sd2PinMapH-113">  {&DDRF, &PINF, &PORTF, 6},  // F6 60</front>
<front id="Sd2PinMapH-114">  {&DDRF, &PINF, &PORTF, 7},  // F7 61</front>
<front id="Sd2PinMapH-115">  {&DDRK, &PINK, &PORTK, 0},  // K0 62</front>
<front id="Sd2PinMapH-116">  {&DDRK, &PINK, &PORTK, 1},  // K1 63</front>
<front id="Sd2PinMapH-117">  {&DDRK, &PINK, &PORTK, 2},  // K2 64</front>
<front id="Sd2PinMapH-118">  {&DDRK, &PINK, &PORTK, 3},  // K3 65</front>
<front id="Sd2PinMapH-119">  {&DDRK, &PINK, &PORTK, 4},  // K4 66</front>
<front id="Sd2PinMapH-120">  {&DDRK, &PINK, &PORTK, 5},  // K5 67</front>
<front id="Sd2PinMapH-121">  {&DDRK, &PINK, &PORTK, 6},  // K6 68</front>
<front id="Sd2PinMapH-122">  {&DDRK, &PINK, &PORTK, 7}   // K7 69</front>
<front id="Sd2PinMapH-123">};</front>
<front id="Sd2PinMapH-124">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-125">#elif defined(__AVR_ATmega644P__)\</front>
<front id="Sd2PinMapH-126">|| defined(__AVR_ATmega644__)\</front>
<front id="Sd2PinMapH-127">|| defined(__AVR_ATmega1284P__)</front>
<front id="Sd2PinMapH-128">// Sanguino</front>
<front id="Sd2PinMapH-129"></front>
<front id="Sd2PinMapH-130">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-131">uint8_t const SDA_PIN = 17;  // C1</front>
<front id="Sd2PinMapH-132">uint8_t const SCL_PIN = 18;  // C2</front>
<front id="Sd2PinMapH-133"></front>
<front id="Sd2PinMapH-134">// SPI port</front>
<front id="Sd2PinMapH-135">uint8_t const SS_PIN = 4;    // B4</front>
<front id="Sd2PinMapH-136">uint8_t const MOSI_PIN = 5;  // B5</front>
<front id="Sd2PinMapH-137">uint8_t const MISO_PIN = 6;  // B6</front>
<front id="Sd2PinMapH-138">uint8_t const SCK_PIN = 7;   // B7</front>
<front id="Sd2PinMapH-139"></front>
<front id="Sd2PinMapH-140">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-141">  {&DDRB, &PINB, &PORTB, 0},  // B0  0</front>
<front id="Sd2PinMapH-142">  {&DDRB, &PINB, &PORTB, 1},  // B1  1</front>
<front id="Sd2PinMapH-143">  {&DDRB, &PINB, &PORTB, 2},  // B2  2</front>
<front id="Sd2PinMapH-144">  {&DDRB, &PINB, &PORTB, 3},  // B3  3</front>
<front id="Sd2PinMapH-145">  {&DDRB, &PINB, &PORTB, 4},  // B4  4</front>
<front id="Sd2PinMapH-146">  {&DDRB, &PINB, &PORTB, 5},  // B5  5</front>
<front id="Sd2PinMapH-147">  {&DDRB, &PINB, &PORTB, 6},  // B6  6</front>
<front id="Sd2PinMapH-148">  {&DDRB, &PINB, &PORTB, 7},  // B7  7</front>
<front id="Sd2PinMapH-149">  {&DDRD, &PIND, &PORTD, 0},  // D0  8</front>
<front id="Sd2PinMapH-150">  {&DDRD, &PIND, &PORTD, 1},  // D1  9</front>
<front id="Sd2PinMapH-151">  {&DDRD, &PIND, &PORTD, 2},  // D2 10</front>
<front id="Sd2PinMapH-152">  {&DDRD, &PIND, &PORTD, 3},  // D3 11</front>
<front id="Sd2PinMapH-153">  {&DDRD, &PIND, &PORTD, 4},  // D4 12</front>
<front id="Sd2PinMapH-154">  {&DDRD, &PIND, &PORTD, 5},  // D5 13</front>
<front id="Sd2PinMapH-155">  {&DDRD, &PIND, &PORTD, 6},  // D6 14</front>
<front id="Sd2PinMapH-156">  {&DDRD, &PIND, &PORTD, 7},  // D7 15</front>
<front id="Sd2PinMapH-157">  {&DDRC, &PINC, &PORTC, 0},  // C0 16</front>
<front id="Sd2PinMapH-158">  {&DDRC, &PINC, &PORTC, 1},  // C1 17</front>
<front id="Sd2PinMapH-159">  {&DDRC, &PINC, &PORTC, 2},  // C2 18</front>
<front id="Sd2PinMapH-160">  {&DDRC, &PINC, &PORTC, 3},  // C3 19</front>
<front id="Sd2PinMapH-161">  {&DDRC, &PINC, &PORTC, 4},  // C4 20</front>
<front id="Sd2PinMapH-162">  {&DDRC, &PINC, &PORTC, 5},  // C5 21</front>
<front id="Sd2PinMapH-163">  {&DDRC, &PINC, &PORTC, 6},  // C6 22</front>
<front id="Sd2PinMapH-164">  {&DDRC, &PINC, &PORTC, 7},  // C7 23</front>
<front id="Sd2PinMapH-165">  {&DDRA, &PINA, &PORTA, 7},  // A7 24</front>
<front id="Sd2PinMapH-166">  {&DDRA, &PINA, &PORTA, 6},  // A6 25</front>
<front id="Sd2PinMapH-167">  {&DDRA, &PINA, &PORTA, 5},  // A5 26</front>
<front id="Sd2PinMapH-168">  {&DDRA, &PINA, &PORTA, 4},  // A4 27</front>
<front id="Sd2PinMapH-169">  {&DDRA, &PINA, &PORTA, 3},  // A3 28</front>
<front id="Sd2PinMapH-170">  {&DDRA, &PINA, &PORTA, 2},  // A2 29</front>
<front id="Sd2PinMapH-171">  {&DDRA, &PINA, &PORTA, 1},  // A1 30</front>
<front id="Sd2PinMapH-172">  {&DDRA, &PINA, &PORTA, 0}   // A0 31</front>
<front id="Sd2PinMapH-173">};</front>
<front id="Sd2PinMapH-174">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-175">#elif defined(__AVR_ATmega32U4__)</front>
<front id="Sd2PinMapH-176">// Teensy 2.0</front>
<front id="Sd2PinMapH-177"></front>
<front id="Sd2PinMapH-178">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-179">uint8_t const SDA_PIN = 6;  // D1</front>
<front id="Sd2PinMapH-180">uint8_t const SCL_PIN = 5;  // D0</front>
<front id="Sd2PinMapH-181"></front>
<front id="Sd2PinMapH-182">// SPI port</front>
<front id="Sd2PinMapH-183">uint8_t const SS_PIN = 0;    // B0</front>
<front id="Sd2PinMapH-184">uint8_t const MOSI_PIN = 2;  // B2</front>
<front id="Sd2PinMapH-185">uint8_t const MISO_PIN = 3;  // B3</front>
<front id="Sd2PinMapH-186">uint8_t const SCK_PIN = 1;   // B1</front>
<front id="Sd2PinMapH-187"></front>
<front id="Sd2PinMapH-188">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-189">  {&DDRB, &PINB, &PORTB, 0},  // B0  0</front>
<front id="Sd2PinMapH-190">  {&DDRB, &PINB, &PORTB, 1},  // B1  1</front>
<front id="Sd2PinMapH-191">  {&DDRB, &PINB, &PORTB, 2},  // B2  2</front>
<front id="Sd2PinMapH-192">  {&DDRB, &PINB, &PORTB, 3},  // B3  3</front>
<front id="Sd2PinMapH-193">  {&DDRB, &PINB, &PORTB, 7},  // B7  4</front>
<front id="Sd2PinMapH-194">  {&DDRD, &PIND, &PORTD, 0},  // D0  5</front>
<front id="Sd2PinMapH-195">  {&DDRD, &PIND, &PORTD, 1},  // D1  6</front>
<front id="Sd2PinMapH-196">  {&DDRD, &PIND, &PORTD, 2},  // D2  7</front>
<front id="Sd2PinMapH-197">  {&DDRD, &PIND, &PORTD, 3},  // D3  8</front>
<front id="Sd2PinMapH-198">  {&DDRC, &PINC, &PORTC, 6},  // C6  9</front>
<front id="Sd2PinMapH-199">  {&DDRC, &PINC, &PORTC, 7},  // C7 10</front>
<front id="Sd2PinMapH-200">  {&DDRD, &PIND, &PORTD, 6},  // D6 11</front>
<front id="Sd2PinMapH-201">  {&DDRD, &PIND, &PORTD, 7},  // D7 12</front>
<front id="Sd2PinMapH-202">  {&DDRB, &PINB, &PORTB, 4},  // B4 13</front>
<front id="Sd2PinMapH-203">  {&DDRB, &PINB, &PORTB, 5},  // B5 14</front>
<front id="Sd2PinMapH-204">  {&DDRB, &PINB, &PORTB, 6},  // B6 15</front>
<front id="Sd2PinMapH-205">  {&DDRF, &PINF, &PORTF, 7},  // F7 16</front>
<front id="Sd2PinMapH-206">  {&DDRF, &PINF, &PORTF, 6},  // F6 17</front>
<front id="Sd2PinMapH-207">  {&DDRF, &PINF, &PORTF, 5},  // F5 18</front>
<front id="Sd2PinMapH-208">  {&DDRF, &PINF, &PORTF, 4},  // F4 19</front>
<front id="Sd2PinMapH-209">  {&DDRF, &PINF, &PORTF, 1},  // F1 20</front>
<front id="Sd2PinMapH-210">  {&DDRF, &PINF, &PORTF, 0},  // F0 21</front>
<front id="Sd2PinMapH-211">  {&DDRD, &PIND, &PORTD, 4},  // D4 22</front>
<front id="Sd2PinMapH-212">  {&DDRD, &PIND, &PORTD, 5},  // D5 23</front>
<front id="Sd2PinMapH-213">  {&DDRE, &PINE, &PORTE, 6}   // E6 24</front>
<front id="Sd2PinMapH-214">};</front>
<front id="Sd2PinMapH-215">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-216">#elif defined(__AVR_AT90USB646__)\</front>
<front id="Sd2PinMapH-217">|| defined(__AVR_AT90USB1286__)</front>
<front id="Sd2PinMapH-218">// Teensy++ 1.0 & 2.0</front>
<front id="Sd2PinMapH-219"></front>
<front id="Sd2PinMapH-220">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-221">uint8_t const SDA_PIN = 1;  // D1</front>
<front id="Sd2PinMapH-222">uint8_t const SCL_PIN = 0;  // D0</front>
<front id="Sd2PinMapH-223"></front>
<front id="Sd2PinMapH-224">// SPI port</front>
<front id="Sd2PinMapH-225">uint8_t const SS_PIN = 20;    // B0</front>
<front id="Sd2PinMapH-226">uint8_t const MOSI_PIN = 22;  // B2</front>
<front id="Sd2PinMapH-227">uint8_t const MISO_PIN = 23;  // B3</front>
<front id="Sd2PinMapH-228">uint8_t const SCK_PIN = 21;   // B1</front>
<front id="Sd2PinMapH-229"></front>
<front id="Sd2PinMapH-230">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-231">  {&DDRD, &PIND, &PORTD, 0},  // D0  0</front>
<front id="Sd2PinMapH-232">  {&DDRD, &PIND, &PORTD, 1},  // D1  1</front>
<front id="Sd2PinMapH-233">  {&DDRD, &PIND, &PORTD, 2},  // D2  2</front>
<front id="Sd2PinMapH-234">  {&DDRD, &PIND, &PORTD, 3},  // D3  3</front>
<front id="Sd2PinMapH-235">  {&DDRD, &PIND, &PORTD, 4},  // D4  4</front>
<front id="Sd2PinMapH-236">  {&DDRD, &PIND, &PORTD, 5},  // D5  5</front>
<front id="Sd2PinMapH-237">  {&DDRD, &PIND, &PORTD, 6},  // D6  6</front>
<front id="Sd2PinMapH-238">  {&DDRD, &PIND, &PORTD, 7},  // D7  7</front>
<front id="Sd2PinMapH-239">  {&DDRE, &PINE, &PORTE, 0},  // E0  8</front>
<front id="Sd2PinMapH-240">  {&DDRE, &PINE, &PORTE, 1},  // E1  9</front>
<front id="Sd2PinMapH-241">  {&DDRC, &PINC, &PORTC, 0},  // C0 10</front>
<front id="Sd2PinMapH-242">  {&DDRC, &PINC, &PORTC, 1},  // C1 11</front>
<front id="Sd2PinMapH-243">  {&DDRC, &PINC, &PORTC, 2},  // C2 12</front>
<front id="Sd2PinMapH-244">  {&DDRC, &PINC, &PORTC, 3},  // C3 13</front>
<front id="Sd2PinMapH-245">  {&DDRC, &PINC, &PORTC, 4},  // C4 14</front>
<front id="Sd2PinMapH-246">  {&DDRC, &PINC, &PORTC, 5},  // C5 15</front>
<front id="Sd2PinMapH-247">  {&DDRC, &PINC, &PORTC, 6},  // C6 16</front>
<front id="Sd2PinMapH-248">  {&DDRC, &PINC, &PORTC, 7},  // C7 17</front>
<front id="Sd2PinMapH-249">  {&DDRE, &PINE, &PORTE, 6},  // E6 18</front>
<front id="Sd2PinMapH-250">  {&DDRE, &PINE, &PORTE, 7},  // E7 19</front>
<front id="Sd2PinMapH-251">  {&DDRB, &PINB, &PORTB, 0},  // B0 20</front>
<front id="Sd2PinMapH-252">  {&DDRB, &PINB, &PORTB, 1},  // B1 21</front>
<front id="Sd2PinMapH-253">  {&DDRB, &PINB, &PORTB, 2},  // B2 22</front>
<front id="Sd2PinMapH-254">  {&DDRB, &PINB, &PORTB, 3},  // B3 23</front>
<front id="Sd2PinMapH-255">  {&DDRB, &PINB, &PORTB, 4},  // B4 24</front>
<front id="Sd2PinMapH-256">  {&DDRB, &PINB, &PORTB, 5},  // B5 25</front>
<front id="Sd2PinMapH-257">  {&DDRB, &PINB, &PORTB, 6},  // B6 26</front>
<front id="Sd2PinMapH-258">  {&DDRB, &PINB, &PORTB, 7},  // B7 27</front>
<front id="Sd2PinMapH-259">  {&DDRA, &PINA, &PORTA, 0},  // A0 28</front>
<front id="Sd2PinMapH-260">  {&DDRA, &PINA, &PORTA, 1},  // A1 29</front>
<front id="Sd2PinMapH-261">  {&DDRA, &PINA, &PORTA, 2},  // A2 30</front>
<front id="Sd2PinMapH-262">  {&DDRA, &PINA, &PORTA, 3},  // A3 31</front>
<front id="Sd2PinMapH-263">  {&DDRA, &PINA, &PORTA, 4},  // A4 32</front>
<front id="Sd2PinMapH-264">  {&DDRA, &PINA, &PORTA, 5},  // A5 33</front>
<front id="Sd2PinMapH-265">  {&DDRA, &PINA, &PORTA, 6},  // A6 34</front>
<front id="Sd2PinMapH-266">  {&DDRA, &PINA, &PORTA, 7},  // A7 35</front>
<front id="Sd2PinMapH-267">  {&DDRE, &PINE, &PORTE, 4},  // E4 36</front>
<front id="Sd2PinMapH-268">  {&DDRE, &PINE, &PORTE, 5},  // E5 37</front>
<front id="Sd2PinMapH-269">  {&DDRF, &PINF, &PORTF, 0},  // F0 38</front>
<front id="Sd2PinMapH-270">  {&DDRF, &PINF, &PORTF, 1},  // F1 39</front>
<front id="Sd2PinMapH-271">  {&DDRF, &PINF, &PORTF, 2},  // F2 40</front>
<front id="Sd2PinMapH-272">  {&DDRF, &PINF, &PORTF, 3},  // F3 41</front>
<front id="Sd2PinMapH-273">  {&DDRF, &PINF, &PORTF, 4},  // F4 42</front>
<front id="Sd2PinMapH-274">  {&DDRF, &PINF, &PORTF, 5},  // F5 43</front>
<front id="Sd2PinMapH-275">  {&DDRF, &PINF, &PORTF, 6},  // F6 44</front>
<front id="Sd2PinMapH-276">  {&DDRF, &PINF, &PORTF, 7}   // F7 45</front>
<front id="Sd2PinMapH-277">};</front>
<front id="Sd2PinMapH-278">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-279">#elif defined(__AVR_ATmega168__)\</front>
<front id="Sd2PinMapH-280">||defined(__AVR_ATmega168P__)\</front>
<front id="Sd2PinMapH-281">||defined(__AVR_ATmega328P__)</front>
<front id="Sd2PinMapH-282">// 168 and 328 Arduinos</front>
<front id="Sd2PinMapH-283"></front>
<front id="Sd2PinMapH-284">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-285">uint8_t const SDA_PIN = 18;  // C4</front>
<front id="Sd2PinMapH-286">uint8_t const SCL_PIN = 19;  // C5</front>
<front id="Sd2PinMapH-287"></front>
<front id="Sd2PinMapH-288">// SPI port</front>
<front id="Sd2PinMapH-289">uint8_t const SS_PIN = 10;    // B2</front>
<front id="Sd2PinMapH-290">uint8_t const MOSI_PIN = 11;  // B3</front>
<front id="Sd2PinMapH-291">uint8_t const MISO_PIN = 12;  // B4</front>
<front id="Sd2PinMapH-292">uint8_t const SCK_PIN = 13;   // B5</front>
<front id="Sd2PinMapH-293"></front>
<front id="Sd2PinMapH-294">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-295">  {&DDRD, &PIND, &PORTD, 0},  // D0  0</front>
<front id="Sd2PinMapH-296">  {&DDRD, &PIND, &PORTD, 1},  // D1  1</front>
<front id="Sd2PinMapH-297">  {&DDRD, &PIND, &PORTD, 2},  // D2  2</front>
<front id="Sd2PinMapH-298">  {&DDRD, &PIND, &PORTD, 3},  // D3  3</front>
<front id="Sd2PinMapH-299">  {&DDRD, &PIND, &PORTD, 4},  // D4  4</front>
<front id="Sd2PinMapH-300">  {&DDRD, &PIND, &PORTD, 5},  // D5  5</front>
<front id="Sd2PinMapH-301">  {&DDRD, &PIND, &PORTD, 6},  // D6  6</front>
<front id="Sd2PinMapH-302">  {&DDRD, &PIND, &PORTD, 7},  // D7  7</front>
<front id="Sd2PinMapH-303">  {&DDRB, &PINB, &PORTB, 0},  // B0  8</front>
<front id="Sd2PinMapH-304">  {&DDRB, &PINB, &PORTB, 1},  // B1  9</front>
<front id="Sd2PinMapH-305">  {&DDRB, &PINB, &PORTB, 2},  // B2 10</front>
<front id="Sd2PinMapH-306">  {&DDRB, &PINB, &PORTB, 3},  // B3 11</front>
<front id="Sd2PinMapH-307">  {&DDRB, &PINB, &PORTB, 4},  // B4 12</front>
<front id="Sd2PinMapH-308">  {&DDRB, &PINB, &PORTB, 5},  // B5 13</front>
<front id="Sd2PinMapH-309">  {&DDRC, &PINC, &PORTC, 0},  // C0 14</front>
<front id="Sd2PinMapH-310">  {&DDRC, &PINC, &PORTC, 1},  // C1 15</front>
<front id="Sd2PinMapH-311">  {&DDRC, &PINC, &PORTC, 2},  // C2 16</front>
<front id="Sd2PinMapH-312">  {&DDRC, &PINC, &PORTC, 3},  // C3 17</front>
<front id="Sd2PinMapH-313">  {&DDRC, &PINC, &PORTC, 4},  // C4 18</front>
<front id="Sd2PinMapH-314">  {&DDRC, &PINC, &PORTC, 5}   // C5 19</front>
<front id="Sd2PinMapH-315">};</front>
<front id="Sd2PinMapH-316">#else  // defined(__AVR_ATmega1280__)</front>
<front id="Sd2PinMapH-317">#error unknown chip</front>
<front id="Sd2PinMapH-318">#endif  // defined(__AVR_ATmega1280__)</front>
<front id="Sd2PinMapH-319">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-320">static const uint8_t digitalPinCount = sizeof(digitalPinMap)/sizeof(pin_map_t);</front>
<front id="Sd2PinMapH-321"></front>
<front id="Sd2PinMapH-322">uint8_t badPinNumber(void)</front>
<front id="Sd2PinMapH-323">  __attribute__((error("Pin number is too large or not a constant")));</front>
<front id="Sd2PinMapH-324"></front>
<front id="Sd2PinMapH-325">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-326">  bool getPinMode(uint8_t pin) {</front>
<front id="Sd2PinMapH-327">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-328">    return (*digitalPinMap[pin].ddr &gt;&gt; digitalPinMap[pin].bit) & 1;</front>
<front id="Sd2PinMapH-329">  } else {</front>
<front id="Sd2PinMapH-330">    return badPinNumber();</front>
<front id="Sd2PinMapH-331">  }</front>
<front id="Sd2PinMapH-332">}</front>
<front id="Sd2PinMapH-333">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-334">  void setPinMode(uint8_t pin, uint8_t mode) {</front>
<front id="Sd2PinMapH-335">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-336">    if (mode) {</front>
<front id="Sd2PinMapH-337">      *digitalPinMap[pin].ddr |= 1 &lt;&lt; digitalPinMap[pin].bit;</front>
<front id="Sd2PinMapH-338">    } else {</front>
<front id="Sd2PinMapH-339">      *digitalPinMap[pin].ddr &= ~(1 &lt;&lt; digitalPinMap[pin].bit);</front>
<front id="Sd2PinMapH-340">    }</front>
<front id="Sd2PinMapH-341">  } else {</front>
<front id="Sd2PinMapH-342">    badPinNumber();</front>
<front id="Sd2PinMapH-343">  }</front>
<front id="Sd2PinMapH-344">}</front>
<front id="Sd2PinMapH-345">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-346">  bool fastDigitalRead(uint8_t pin) {</front>
<front id="Sd2PinMapH-347">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-348">    return (*digitalPinMap[pin].pin &gt;&gt; digitalPinMap[pin].bit) & 1;</front>
<front id="Sd2PinMapH-349">  } else {</front>
<front id="Sd2PinMapH-350">    return badPinNumber();</front>
<front id="Sd2PinMapH-351">  }</front>
<front id="Sd2PinMapH-352">}</front>
<front id="Sd2PinMapH-353">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-354">  void fastDigitalWrite(uint8_t pin, uint8_t value) {</front>
<front id="Sd2PinMapH-355">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-356">    if (value) {</front>
<front id="Sd2PinMapH-357">      *digitalPinMap[pin].port |= 1 &lt;&lt; digitalPinMap[pin].bit;</front>
<front id="Sd2PinMapH-358">    } else {</front>
<front id="Sd2PinMapH-359">      *digitalPinMap[pin].port &= ~(1 &lt;&lt; digitalPinMap[pin].bit);</front>
<front id="Sd2PinMapH-360">    }</front>
<front id="Sd2PinMapH-361">  } else {</front>
<front id="Sd2PinMapH-362">    badPinNumber();</front>
<front id="Sd2PinMapH-363">  }</front>
<front id="Sd2PinMapH-364">}</front>
<front id="Sd2PinMapH-365">#endif  // Sd2PinMap_h</front>
<front id="Sd2PinMapH-366"></front>
<front id="Sd2PinMapH-367"></front>
<front id="Sd2PinMapH-368">#endif</front>
 </pre>
<h1>SdBaseFile.cpp</h1>
<pre  class="prettyprint linenums"><front id="SdBaseFileCPP-1">/* Arduino SdFat Library</front>
<front id="SdBaseFileCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdBaseFileCPP-3"> *</front>
<front id="SdBaseFileCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdBaseFileCPP-5"> *</front>
<front id="SdBaseFileCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdBaseFileCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdBaseFileCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdBaseFileCPP-9"> * (at your option) any later version.</front>
<front id="SdBaseFileCPP-10"> *</front>
<front id="SdBaseFileCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdBaseFileCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdBaseFileCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdBaseFileCPP-14"> * GNU General Public License for more details.</front>
<front id="SdBaseFileCPP-15"> *</front>
<front id="SdBaseFileCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdBaseFileCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdBaseFileCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdBaseFileCPP-19"> */</front>
<front id="SdBaseFileCPP-20"></front>
<front id="SdBaseFileCPP-21">#include "Marlin.h"</front>
<front id="SdBaseFileCPP-22">#ifdef SDSUPPORT</front>
<front id="SdBaseFileCPP-23"></front>
<front id="SdBaseFileCPP-24">#include "SdBaseFile.h"</front>
<front id="SdBaseFileCPP-25">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-26">// pointer to cwd directory</front>
<front id="SdBaseFileCPP-27">SdBaseFile* SdBaseFile::cwd_ = 0;</front>
<front id="SdBaseFileCPP-28">// callback function for date/time</front>
<front id="SdBaseFileCPP-29">void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;</front>
<front id="SdBaseFileCPP-30">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-31">// add a cluster to a file</front>
<front id="SdBaseFileCPP-32">bool SdBaseFile::addCluster() {</front>
<front id="SdBaseFileCPP-33">  if (!vol_-&gt;allocContiguous(1, &curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-34"></front>
<front id="SdBaseFileCPP-35">  // if first cluster of file link to directory entry</front>
<front id="SdBaseFileCPP-36">  if (firstCluster_ == 0) {</front>
<front id="SdBaseFileCPP-37">    firstCluster_ = curCluster_;</front>
<front id="SdBaseFileCPP-38">    flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-39">  }</front>
<front id="SdBaseFileCPP-40">  return true;</front>
<front id="SdBaseFileCPP-41"></front>
<front id="SdBaseFileCPP-42"> fail:</front>
<front id="SdBaseFileCPP-43">  return false;</front>
<front id="SdBaseFileCPP-44">}</front>
<front id="SdBaseFileCPP-45">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-46">// Add a cluster to a directory file and zero the cluster.</front>
<front id="SdBaseFileCPP-47">// return with first block of cluster in the cache</front>
<front id="SdBaseFileCPP-48">bool SdBaseFile::addDirCluster() {</front>
<front id="SdBaseFileCPP-49">  uint32_t block;</front>
<front id="SdBaseFileCPP-50">  // max folder size</front>
<front id="SdBaseFileCPP-51">  if (fileSize_/sizeof(dir_t) &gt;= 0XFFFF) goto fail;</front>
<front id="SdBaseFileCPP-52"></front>
<front id="SdBaseFileCPP-53">  if (!addCluster()) goto fail;</front>
<front id="SdBaseFileCPP-54">  if (!vol_-&gt;cacheFlush()) goto fail;</front>
<front id="SdBaseFileCPP-55"></front>
<front id="SdBaseFileCPP-56">  block = vol_-&gt;clusterStartBlock(curCluster_);</front>
<front id="SdBaseFileCPP-57"></front>
<front id="SdBaseFileCPP-58">  // set cache to first block of cluster</front>
<front id="SdBaseFileCPP-59">  vol_-&gt;cacheSetBlockNumber(block, true);</front>
<front id="SdBaseFileCPP-60"></front>
<front id="SdBaseFileCPP-61">  // zero first block of cluster</front>
<front id="SdBaseFileCPP-62">  memset(vol_-&gt;cacheBuffer_.data, 0, 512);</front>
<front id="SdBaseFileCPP-63"></front>
<front id="SdBaseFileCPP-64">  // zero rest of cluster</front>
<front id="SdBaseFileCPP-65">  for (uint8_t i = 1; i &lt; vol_-&gt;blocksPerCluster_; i++) {</front>
<front id="SdBaseFileCPP-66">    if (!vol_-&gt;writeBlock(block + i, vol_-&gt;cacheBuffer_.data)) goto fail;</front>
<front id="SdBaseFileCPP-67">  }</front>
<front id="SdBaseFileCPP-68">  // Increase directory file size by cluster size</front>
<front id="SdBaseFileCPP-69">  fileSize_ += 512UL &lt;&lt; vol_-&gt;clusterSizeShift_;</front>
<front id="SdBaseFileCPP-70">  return true;</front>
<front id="SdBaseFileCPP-71"></front>
<front id="SdBaseFileCPP-72"> fail:</front>
<front id="SdBaseFileCPP-73">  return false;</front>
<front id="SdBaseFileCPP-74">}</front>
<front id="SdBaseFileCPP-75">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-76">// cache a file's directory entry</front>
<front id="SdBaseFileCPP-77">// return pointer to cached entry or null for failure</front>
<front id="SdBaseFileCPP-78">dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {</front>
<front id="SdBaseFileCPP-79">  if (!vol_-&gt;cacheRawBlock(dirBlock_, action)) goto fail;</front>
<front id="SdBaseFileCPP-80">  return vol_-&gt;cache()-&gt;dir + dirIndex_;</front>
<front id="SdBaseFileCPP-81"></front>
<front id="SdBaseFileCPP-82"> fail:</front>
<front id="SdBaseFileCPP-83">  return 0;</front>
<front id="SdBaseFileCPP-84">}</front>
<front id="SdBaseFileCPP-85">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-86">/** Close a file and force cached data and directory information</front>
<front id="SdBaseFileCPP-87"> *  to be written to the storage device.</front>
<front id="SdBaseFileCPP-88"> *</front>
<front id="SdBaseFileCPP-89"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-90"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-91"> * Reasons for failure include no file is open or an I/O error.</front>
<front id="SdBaseFileCPP-92"> */</front>
<front id="SdBaseFileCPP-93">bool SdBaseFile::close() {</front>
<front id="SdBaseFileCPP-94">  bool rtn = sync();</front>
<front id="SdBaseFileCPP-95">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-96">  return rtn;</front>
<front id="SdBaseFileCPP-97">}</front>
<front id="SdBaseFileCPP-98">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-99">/** Check for contiguous file and return its raw block range.</front>
<front id="SdBaseFileCPP-100"> *</front>
<front id="SdBaseFileCPP-101"> * \param[out] bgnBlock the first block address for the file.</front>
<front id="SdBaseFileCPP-102"> * \param[out] endBlock the last  block address for the file.</front>
<front id="SdBaseFileCPP-103"> *</front>
<front id="SdBaseFileCPP-104"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-105"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-106"> * Reasons for failure include file is not contiguous, file has zero length</front>
<front id="SdBaseFileCPP-107"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-108"> */</front>
<front id="SdBaseFileCPP-109">bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {</front>
<front id="SdBaseFileCPP-110">  // error if no blocks</front>
<front id="SdBaseFileCPP-111">  if (firstCluster_ == 0) goto fail;</front>
<front id="SdBaseFileCPP-112"></front>
<front id="SdBaseFileCPP-113">  for (uint32_t c = firstCluster_; ; c++) {</front>
<front id="SdBaseFileCPP-114">    uint32_t next;</front>
<front id="SdBaseFileCPP-115">    if (!vol_-&gt;fatGet(c, &next)) goto fail;</front>
<front id="SdBaseFileCPP-116"></front>
<front id="SdBaseFileCPP-117">    // check for contiguous</front>
<front id="SdBaseFileCPP-118">    if (next != (c + 1)) {</front>
<front id="SdBaseFileCPP-119">      // error if not end of chain</front>
<front id="SdBaseFileCPP-120">      if (!vol_-&gt;isEOC(next)) goto fail;</front>
<front id="SdBaseFileCPP-121">      *bgnBlock = vol_-&gt;clusterStartBlock(firstCluster_);</front>
<front id="SdBaseFileCPP-122">      *endBlock = vol_-&gt;clusterStartBlock(c)</front>
<front id="SdBaseFileCPP-123">                  + vol_-&gt;blocksPerCluster_ - 1;</front>
<front id="SdBaseFileCPP-124">      return true;</front>
<front id="SdBaseFileCPP-125">    }</front>
<front id="SdBaseFileCPP-126">  }</front>
<front id="SdBaseFileCPP-127"></front>
<front id="SdBaseFileCPP-128"> fail:</front>
<front id="SdBaseFileCPP-129">  return false;</front>
<front id="SdBaseFileCPP-130">}</front>
<front id="SdBaseFileCPP-131">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-132">/** Create and open a new contiguous file of a specified size.</front>
<front id="SdBaseFileCPP-133"> *</front>
<front id="SdBaseFileCPP-134"> * \note This function only supports short DOS 8.3 names.</front>
<front id="SdBaseFileCPP-135"> * See open() for more information.</front>
<front id="SdBaseFileCPP-136"> *</front>
<front id="SdBaseFileCPP-137"> * \param[in] dirFile The directory where the file will be created.</front>
<front id="SdBaseFileCPP-138"> * \param[in] path A path with a valid DOS 8.3 file name.</front>
<front id="SdBaseFileCPP-139"> * \param[in] size The desired file size.</front>
<front id="SdBaseFileCPP-140"> *</front>
<front id="SdBaseFileCPP-141"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-142"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-143"> * Reasons for failure include \a path contains</front>
<front id="SdBaseFileCPP-144"> * an invalid DOS 8.3 file name, the FAT volume has not been initialized,</front>
<front id="SdBaseFileCPP-145"> * a file is already open, the file already exists, the root</front>
<front id="SdBaseFileCPP-146"> * directory is full or an I/O error.</front>
<front id="SdBaseFileCPP-147"> *</front>
<front id="SdBaseFileCPP-148"> */</front>
<front id="SdBaseFileCPP-149">bool SdBaseFile::createContiguous(SdBaseFile* dirFile,</front>
<front id="SdBaseFileCPP-150">        const char* path, uint32_t size) {</front>
<front id="SdBaseFileCPP-151">  uint32_t count;</front>
<front id="SdBaseFileCPP-152">  // don't allow zero length file</front>
<front id="SdBaseFileCPP-153">  if (size == 0) goto fail;</front>
<front id="SdBaseFileCPP-154">  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto fail;</front>
<front id="SdBaseFileCPP-155"></front>
<front id="SdBaseFileCPP-156">  // calculate number of clusters needed</front>
<front id="SdBaseFileCPP-157">  count = ((size - 1) &gt;&gt; (vol_-&gt;clusterSizeShift_ + 9)) + 1;</front>
<front id="SdBaseFileCPP-158"></front>
<front id="SdBaseFileCPP-159">  // allocate clusters</front>
<front id="SdBaseFileCPP-160">  if (!vol_-&gt;allocContiguous(count, &firstCluster_)) {</front>
<front id="SdBaseFileCPP-161">    remove();</front>
<front id="SdBaseFileCPP-162">    goto fail;</front>
<front id="SdBaseFileCPP-163">  }</front>
<front id="SdBaseFileCPP-164">  fileSize_ = size;</front>
<front id="SdBaseFileCPP-165"></front>
<front id="SdBaseFileCPP-166">  // insure sync() will update dir entry</front>
<front id="SdBaseFileCPP-167">  flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-168"></front>
<front id="SdBaseFileCPP-169">  return sync();</front>
<front id="SdBaseFileCPP-170"></front>
<front id="SdBaseFileCPP-171"> fail:</front>
<front id="SdBaseFileCPP-172">  return false;</front>
<front id="SdBaseFileCPP-173">}</front>
<front id="SdBaseFileCPP-174">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-175">/** Return a file's directory entry.</front>
<front id="SdBaseFileCPP-176"> *</front>
<front id="SdBaseFileCPP-177"> * \param[out] dir Location for return of the file's directory entry.</front>
<front id="SdBaseFileCPP-178"> *</front>
<front id="SdBaseFileCPP-179"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-180"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-181"> */</front>
<front id="SdBaseFileCPP-182">bool SdBaseFile::dirEntry(dir_t* dir) {</front>
<front id="SdBaseFileCPP-183">  dir_t* p;</front>
<front id="SdBaseFileCPP-184">  // make sure fields on SD are correct</front>
<front id="SdBaseFileCPP-185">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-186"></front>
<front id="SdBaseFileCPP-187">  // read entry</front>
<front id="SdBaseFileCPP-188">  p = cacheDirEntry(SdVolume::CACHE_FOR_READ);</front>
<front id="SdBaseFileCPP-189">  if (!p) goto fail;</front>
<front id="SdBaseFileCPP-190"></front>
<front id="SdBaseFileCPP-191">  // copy to caller's struct</front>
<front id="SdBaseFileCPP-192">  memcpy(dir, p, sizeof(dir_t));</front>
<front id="SdBaseFileCPP-193">  return true;</front>
<front id="SdBaseFileCPP-194"></front>
<front id="SdBaseFileCPP-195"> fail:</front>
<front id="SdBaseFileCPP-196">  return false;</front>
<front id="SdBaseFileCPP-197">}</front>
<front id="SdBaseFileCPP-198">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-199">/** Format the name field of \a dir into the 13 byte array</front>
<front id="SdBaseFileCPP-200"> * \a name in standard 8.3 short name format.</front>
<front id="SdBaseFileCPP-201"> *</front>
<front id="SdBaseFileCPP-202"> * \param[in] dir The directory structure containing the name.</front>
<front id="SdBaseFileCPP-203"> * \param[out] name A 13 byte char array for the formatted name.</front>
<front id="SdBaseFileCPP-204"> */</front>
<front id="SdBaseFileCPP-205">void SdBaseFile::dirName(const dir_t& dir, char* name) {</front>
<front id="SdBaseFileCPP-206">  uint8_t j = 0;</front>
<front id="SdBaseFileCPP-207">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="SdBaseFileCPP-208">    if (dir.name[i] == ' ')continue;</front>
<front id="SdBaseFileCPP-209">    if (i == 8) name[j++] = '.';</front>
<front id="SdBaseFileCPP-210">    name[j++] = dir.name[i];</front>
<front id="SdBaseFileCPP-211">  }</front>
<front id="SdBaseFileCPP-212">  name[j] = 0;</front>
<front id="SdBaseFileCPP-213">}</front>
<front id="SdBaseFileCPP-214">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-215">/** Test for the existence of a file in a directory</front>
<front id="SdBaseFileCPP-216"> *</front>
<front id="SdBaseFileCPP-217"> * \param[in] name Name of the file to be tested for.</front>
<front id="SdBaseFileCPP-218"> *</front>
<front id="SdBaseFileCPP-219"> * The calling instance must be an open directory file.</front>
<front id="SdBaseFileCPP-220"> *</front>
<front id="SdBaseFileCPP-221"> * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory</front>
<front id="SdBaseFileCPP-222"> * dirFile.</front>
<front id="SdBaseFileCPP-223"> *</front>
<front id="SdBaseFileCPP-224"> * \return true if the file exists else false.</front>
<front id="SdBaseFileCPP-225"> */</front>
<front id="SdBaseFileCPP-226">bool SdBaseFile::exists(const char* name) {</front>
<front id="SdBaseFileCPP-227">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-228">  return file.open(this, name, O_READ);</front>
<front id="SdBaseFileCPP-229">}</front>
<front id="SdBaseFileCPP-230">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-231">/**</front>
<front id="SdBaseFileCPP-232"> * Get a string from a file.</front>
<front id="SdBaseFileCPP-233"> *</front>
<front id="SdBaseFileCPP-234"> * fgets() reads bytes from a file into the array pointed to by \a str, until</front>
<front id="SdBaseFileCPP-235"> * \a num - 1 bytes are read, or a delimiter is read and transferred to \a str,</front>
<front id="SdBaseFileCPP-236"> * or end-of-file is encountered. The string is then terminated</front>
<front id="SdBaseFileCPP-237"> * with a null byte.</front>
<front id="SdBaseFileCPP-238"> *</front>
<front id="SdBaseFileCPP-239"> * fgets() deletes CR, '\\r', from the string.  This insures only a '\\n'</front>
<front id="SdBaseFileCPP-240"> * terminates the string for Windows text files which use CRLF for newline.</front>
<front id="SdBaseFileCPP-241"> *</front>
<front id="SdBaseFileCPP-242"> * \param[out] str Pointer to the array where the string is stored.</front>
<front id="SdBaseFileCPP-243"> * \param[in] num Maximum number of characters to be read</front>
<front id="SdBaseFileCPP-244"> * (including the final null byte). Usually the length</front>
<front id="SdBaseFileCPP-245"> * of the array \a str is used.</front>
<front id="SdBaseFileCPP-246"> * \param[in] delim Optional set of delimiters. The default is "\n".</front>
<front id="SdBaseFileCPP-247"> *</front>
<front id="SdBaseFileCPP-248"> * \return For success fgets() returns the length of the string in \a str.</front>
<front id="SdBaseFileCPP-249"> * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.</front>
<front id="SdBaseFileCPP-250"> **/</front>
<front id="SdBaseFileCPP-251">int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {</front>
<front id="SdBaseFileCPP-252">  char ch;</front>
<front id="SdBaseFileCPP-253">  int16_t n = 0;</front>
<front id="SdBaseFileCPP-254">  int16_t r = -1;</front>
<front id="SdBaseFileCPP-255">  while ((n + 1) &lt; num && (r = read(&ch, 1)) == 1) {</front>
<front id="SdBaseFileCPP-256">    // delete CR</front>
<front id="SdBaseFileCPP-257">    if (ch == '\r') continue;</front>
<front id="SdBaseFileCPP-258">    str[n++] = ch;</front>
<front id="SdBaseFileCPP-259">    if (!delim) {</front>
<front id="SdBaseFileCPP-260">      if (ch == '\n') break;</front>
<front id="SdBaseFileCPP-261">    } else {</front>
<front id="SdBaseFileCPP-262">      if (strchr(delim, ch)) break;</front>
<front id="SdBaseFileCPP-263">    }</front>
<front id="SdBaseFileCPP-264">  }</front>
<front id="SdBaseFileCPP-265">  if (r &lt; 0) {</front>
<front id="SdBaseFileCPP-266">    // read error</front>
<front id="SdBaseFileCPP-267">    return -1;</front>
<front id="SdBaseFileCPP-268">  }</front>
<front id="SdBaseFileCPP-269">  str[n] = '\0';</front>
<front id="SdBaseFileCPP-270">  return n;</front>
<front id="SdBaseFileCPP-271">}</front>
<front id="SdBaseFileCPP-272">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-273">/** Get a file's name</front>
<front id="SdBaseFileCPP-274"> *</front>
<front id="SdBaseFileCPP-275"> * \param[out] name An array of 13 characters for the file's name.</front>
<front id="SdBaseFileCPP-276"> *</front>
<front id="SdBaseFileCPP-277"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-278"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-279"> */</front>
<front id="SdBaseFileCPP-280">bool SdBaseFile::getFilename(char* name) {</front>
<front id="SdBaseFileCPP-281">  if (!isOpen()) return false;</front>
<front id="SdBaseFileCPP-282"></front>
<front id="SdBaseFileCPP-283">  if (isRoot()) {</front>
<front id="SdBaseFileCPP-284">    name[0] = '/';</front>
<front id="SdBaseFileCPP-285">    name[1] = '\0';</front>
<front id="SdBaseFileCPP-286">    return true;</front>
<front id="SdBaseFileCPP-287">  }</front>
<front id="SdBaseFileCPP-288">  // cache entry</front>
<front id="SdBaseFileCPP-289">  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);</front>
<front id="SdBaseFileCPP-290">  if (!p) return false;</front>
<front id="SdBaseFileCPP-291"></front>
<front id="SdBaseFileCPP-292">  // format name</front>
<front id="SdBaseFileCPP-293">  dirName(*p, name);</front>
<front id="SdBaseFileCPP-294">  return true;</front>
<front id="SdBaseFileCPP-295">}</front>
<front id="SdBaseFileCPP-296">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-297">void SdBaseFile::getpos(fpos_t* pos) {</front>
<front id="SdBaseFileCPP-298">  pos-&gt;position = curPosition_;</front>
<front id="SdBaseFileCPP-299">  pos-&gt;cluster = curCluster_;</front>
<front id="SdBaseFileCPP-300">}</front>
<front id="SdBaseFileCPP-301"></front>
<front id="SdBaseFileCPP-302">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-303">/** List directory contents.</front>
<front id="SdBaseFileCPP-304"> *</front>
<front id="SdBaseFileCPP-305"> * \param[in] pr Print stream for list.</front>
<front id="SdBaseFileCPP-306"> *</front>
<front id="SdBaseFileCPP-307"> * \param[in] flags The inclusive OR of</front>
<front id="SdBaseFileCPP-308"> *</front>
<front id="SdBaseFileCPP-309"> * LS_DATE - %Print file modification date</front>
<front id="SdBaseFileCPP-310"> *</front>
<front id="SdBaseFileCPP-311"> * LS_SIZE - %Print file size.</front>
<front id="SdBaseFileCPP-312"> *</front>
<front id="SdBaseFileCPP-313"> * LS_R - Recursive list of subdirectories.</front>
<front id="SdBaseFileCPP-314"> *</front>
<front id="SdBaseFileCPP-315"> * \param[in] indent Amount of space before file name. Used for recursive</front>
<front id="SdBaseFileCPP-316"> * list to indicate subdirectory level.</front>
<front id="SdBaseFileCPP-317"> */</front>
<front id="SdBaseFileCPP-318">void SdBaseFile::ls(uint8_t flags, uint8_t indent) {</front>
<front id="SdBaseFileCPP-319">  rewind();</front>
<front id="SdBaseFileCPP-320">  int8_t status;</front>
<front id="SdBaseFileCPP-321">  while ((status = lsPrintNext( flags, indent))) {</front>
<front id="SdBaseFileCPP-322">    if (status &gt; 1 && (flags & LS_R)) {</front>
<front id="SdBaseFileCPP-323">      uint16_t index = curPosition()/32 - 1;</front>
<front id="SdBaseFileCPP-324">      SdBaseFile s;</front>
<front id="SdBaseFileCPP-325">      if (s.open(this, index, O_READ)) s.ls( flags, indent + 2);</front>
<front id="SdBaseFileCPP-326">      seekSet(32 * (index + 1));</front>
<front id="SdBaseFileCPP-327">    }</front>
<front id="SdBaseFileCPP-328">  }</front>
<front id="SdBaseFileCPP-329">}</front>
<front id="SdBaseFileCPP-330">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-331">// saves 32 bytes on stack for ls recursion</front>
<front id="SdBaseFileCPP-332">// return 0 - EOF, 1 - normal file, or 2 - directory</front>
<front id="SdBaseFileCPP-333">int8_t SdBaseFile::lsPrintNext( uint8_t flags, uint8_t indent) {</front>
<front id="SdBaseFileCPP-334">  dir_t dir;</front>
<front id="SdBaseFileCPP-335">  uint8_t w = 0;</front>
<front id="SdBaseFileCPP-336"></front>
<front id="SdBaseFileCPP-337">  while (1) {</front>
<front id="SdBaseFileCPP-338">    if (read(&dir, sizeof(dir)) != sizeof(dir)) return 0;</front>
<front id="SdBaseFileCPP-339">    if (dir.name[0] == DIR_NAME_FREE) return 0;</front>
<front id="SdBaseFileCPP-340"></front>
<front id="SdBaseFileCPP-341">    // skip deleted entry and entries for . and  ..</front>
<front id="SdBaseFileCPP-342">    if (dir.name[0] != DIR_NAME_DELETED && dir.name[0] != '.'</front>
<front id="SdBaseFileCPP-343">      && DIR_IS_FILE_OR_SUBDIR(&dir)) break;</front>
<front id="SdBaseFileCPP-344">  }</front>
<front id="SdBaseFileCPP-345">  // indent for dir level</front>
<front id="SdBaseFileCPP-346">  for (uint8_t i = 0; i &lt; indent; i++) MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-347"></front>
<front id="SdBaseFileCPP-348">  // print name</front>
<front id="SdBaseFileCPP-349">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="SdBaseFileCPP-350">    if (dir.name[i] == ' ')continue;</front>
<front id="SdBaseFileCPP-351">    if (i == 8) {</front>
<front id="SdBaseFileCPP-352">      MYSERIAL.write('.');</front>
<front id="SdBaseFileCPP-353">      w++;</front>
<front id="SdBaseFileCPP-354">    }</front>
<front id="SdBaseFileCPP-355">    MYSERIAL.write(dir.name[i]);</front>
<front id="SdBaseFileCPP-356">    w++;</front>
<front id="SdBaseFileCPP-357">  }</front>
<front id="SdBaseFileCPP-358">  if (DIR_IS_SUBDIR(&dir)) {</front>
<front id="SdBaseFileCPP-359">    MYSERIAL.write('/');</front>
<front id="SdBaseFileCPP-360">    w++;</front>
<front id="SdBaseFileCPP-361">  }</front>
<front id="SdBaseFileCPP-362">  if (flags & (LS_DATE | LS_SIZE)) {</front>
<front id="SdBaseFileCPP-363">    while (w++ &lt; 14) MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-364">  }</front>
<front id="SdBaseFileCPP-365">  // print modify date/time if requested</front>
<front id="SdBaseFileCPP-366">  if (flags & LS_DATE) {</front>
<front id="SdBaseFileCPP-367">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-368">    printFatDate( dir.lastWriteDate);</front>
<front id="SdBaseFileCPP-369">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-370">    printFatTime( dir.lastWriteTime);</front>
<front id="SdBaseFileCPP-371">  }</front>
<front id="SdBaseFileCPP-372">  // print size if requested</front>
<front id="SdBaseFileCPP-373">  if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {</front>
<front id="SdBaseFileCPP-374">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-375">    MYSERIAL.print(dir.fileSize);</front>
<front id="SdBaseFileCPP-376">  }</front>
<front id="SdBaseFileCPP-377">  MYSERIAL.println();</front>
<front id="SdBaseFileCPP-378">  return DIR_IS_FILE(&dir) ? 1 : 2;</front>
<front id="SdBaseFileCPP-379">}</front>
<front id="SdBaseFileCPP-380">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-381">// format directory name field from a 8.3 name string</front>
<front id="SdBaseFileCPP-382">bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {</front>
<front id="SdBaseFileCPP-383">  uint8_t c;</front>
<front id="SdBaseFileCPP-384">  uint8_t n = 7;  // max index for part before dot</front>
<front id="SdBaseFileCPP-385">  uint8_t i = 0;</front>
<front id="SdBaseFileCPP-386">  // blank fill name and extension</front>
<front id="SdBaseFileCPP-387">  while (i &lt; 11) name[i++] = ' ';</front>
<front id="SdBaseFileCPP-388">  i = 0;</front>
<front id="SdBaseFileCPP-389">  while (*str != '\0' && *str != '/') {</front>
<front id="SdBaseFileCPP-390">    c = *str++;</front>
<front id="SdBaseFileCPP-391">    if (c == '.') {</front>
<front id="SdBaseFileCPP-392">      if (n == 10) goto fail;  // only one dot allowed</front>
<front id="SdBaseFileCPP-393">      n = 10;  // max index for full 8.3 name</front>
<front id="SdBaseFileCPP-394">      i = 8;   // place for extension</front>
<front id="SdBaseFileCPP-395">    } else {</front>
<front id="SdBaseFileCPP-396">      // illegal FAT characters</front>
<front id="SdBaseFileCPP-397">      PGM_P p = PSTR("|&lt;&gt;^+=?/[];,*\"\\");</front>
<front id="SdBaseFileCPP-398">      uint8_t b;</front>
<front id="SdBaseFileCPP-399">      while ((b = pgm_read_byte(p++))) if (b == c) goto fail;</front>
<front id="SdBaseFileCPP-400">      // check size and only allow ASCII printable characters</front>
<front id="SdBaseFileCPP-401">      if (i &gt; n || c &lt; 0X21 || c &gt; 0X7E)goto fail;</front>
<front id="SdBaseFileCPP-402">      // only upper case allowed in 8.3 names - convert lower to upper</front>
<front id="SdBaseFileCPP-403">      name[i++] = (c &lt; 'a' || c &gt; 'z') ?  (c) : (c + ('A' - 'a'));</front>
<front id="SdBaseFileCPP-404">    }</front>
<front id="SdBaseFileCPP-405">  }</front>
<front id="SdBaseFileCPP-406">  *ptr = str;</front>
<front id="SdBaseFileCPP-407">  // must have a file name, extension is optional</front>
<front id="SdBaseFileCPP-408">  return name[0] != ' ';</front>
<front id="SdBaseFileCPP-409"></front>
<front id="SdBaseFileCPP-410"> fail:</front>
<front id="SdBaseFileCPP-411">  return false;</front>
<front id="SdBaseFileCPP-412">}</front>
<front id="SdBaseFileCPP-413">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-414">/** Make a new directory.</front>
<front id="SdBaseFileCPP-415"> *</front>
<front id="SdBaseFileCPP-416"> * \param[in] parent An open SdFat instance for the directory that will contain</front>
<front id="SdBaseFileCPP-417"> * the new directory.</front>
<front id="SdBaseFileCPP-418"> *</front>
<front id="SdBaseFileCPP-419"> * \param[in] path A path with a valid 8.3 DOS name for the new directory.</front>
<front id="SdBaseFileCPP-420"> *</front>
<front id="SdBaseFileCPP-421"> * \param[in] pFlag Create missing parent directories if true.</front>
<front id="SdBaseFileCPP-422"> *</front>
<front id="SdBaseFileCPP-423"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-424"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-425"> * Reasons for failure include this file is already open, \a parent is not a</front>
<front id="SdBaseFileCPP-426"> * directory, \a path is invalid or already exists in \a parent.</front>
<front id="SdBaseFileCPP-427"> */</front>
<front id="SdBaseFileCPP-428">bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {</front>
<front id="SdBaseFileCPP-429">  uint8_t dname[11];</front>
<front id="SdBaseFileCPP-430">  SdBaseFile dir1, dir2;</front>
<front id="SdBaseFileCPP-431">  SdBaseFile* sub = &dir1;</front>
<front id="SdBaseFileCPP-432">  SdBaseFile* start = parent;</front>
<front id="SdBaseFileCPP-433"></front>
<front id="SdBaseFileCPP-434">  if (!parent || isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-435"></front>
<front id="SdBaseFileCPP-436">  if (*path == '/') {</front>
<front id="SdBaseFileCPP-437">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-438">    if (!parent-&gt;isRoot()) {</front>
<front id="SdBaseFileCPP-439">      if (!dir2.openRoot(parent-&gt;vol_)) goto fail;</front>
<front id="SdBaseFileCPP-440">      parent = &dir2;</front>
<front id="SdBaseFileCPP-441">    }</front>
<front id="SdBaseFileCPP-442">  }</front>
<front id="SdBaseFileCPP-443">  while (1) {</front>
<front id="SdBaseFileCPP-444">    if (!make83Name(path, dname, &path)) goto fail;</front>
<front id="SdBaseFileCPP-445">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-446">    if (!*path) break;</front>
<front id="SdBaseFileCPP-447">    if (!sub-&gt;open(parent, dname, O_READ)) {</front>
<front id="SdBaseFileCPP-448">      if (!pFlag || !sub-&gt;mkdir(parent, dname)) {</front>
<front id="SdBaseFileCPP-449">        goto fail;</front>
<front id="SdBaseFileCPP-450">      }</front>
<front id="SdBaseFileCPP-451">    }</front>
<front id="SdBaseFileCPP-452">    if (parent != start) parent-&gt;close();</front>
<front id="SdBaseFileCPP-453">    parent = sub;</front>
<front id="SdBaseFileCPP-454">    sub = parent != &dir1 ? &dir1 : &dir2;</front>
<front id="SdBaseFileCPP-455">  }</front>
<front id="SdBaseFileCPP-456">  return mkdir(parent, dname);</front>
<front id="SdBaseFileCPP-457"></front>
<front id="SdBaseFileCPP-458">  fail:</front>
<front id="SdBaseFileCPP-459">  return false;</front>
<front id="SdBaseFileCPP-460">}</front>
<front id="SdBaseFileCPP-461">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-462">bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {</front>
<front id="SdBaseFileCPP-463">  uint32_t block;</front>
<front id="SdBaseFileCPP-464">  dir_t d;</front>
<front id="SdBaseFileCPP-465">  dir_t* p;</front>
<front id="SdBaseFileCPP-466"></front>
<front id="SdBaseFileCPP-467">  if (!parent-&gt;isDir()) goto fail;</front>
<front id="SdBaseFileCPP-468"></front>
<front id="SdBaseFileCPP-469">  // create a normal file</front>
<front id="SdBaseFileCPP-470">  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto fail;</front>
<front id="SdBaseFileCPP-471"></front>
<front id="SdBaseFileCPP-472">  // convert file to directory</front>
<front id="SdBaseFileCPP-473">  flags_ = O_READ;</front>
<front id="SdBaseFileCPP-474">  type_ = FAT_FILE_TYPE_SUBDIR;</front>
<front id="SdBaseFileCPP-475"></front>
<front id="SdBaseFileCPP-476">  // allocate and zero first cluster</front>
<front id="SdBaseFileCPP-477">  if (!addDirCluster())goto fail;</front>
<front id="SdBaseFileCPP-478"></front>
<front id="SdBaseFileCPP-479">  // force entry to SD</front>
<front id="SdBaseFileCPP-480">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-481"></front>
<front id="SdBaseFileCPP-482">  // cache entry - should already be in cache due to sync() call</front>
<front id="SdBaseFileCPP-483">  p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-484">  if (!p) goto fail;</front>
<front id="SdBaseFileCPP-485"></front>
<front id="SdBaseFileCPP-486">  // change directory entry  attribute</front>
<front id="SdBaseFileCPP-487">  p-&gt;attributes = DIR_ATT_DIRECTORY;</front>
<front id="SdBaseFileCPP-488"></front>
<front id="SdBaseFileCPP-489">  // make entry for '.'</front>
<front id="SdBaseFileCPP-490">  memcpy(&d, p, sizeof(d));</front>
<front id="SdBaseFileCPP-491">  d.name[0] = '.';</front>
<front id="SdBaseFileCPP-492">  for (uint8_t i = 1; i &lt; 11; i++) d.name[i] = ' ';</front>
<front id="SdBaseFileCPP-493"></front>
<front id="SdBaseFileCPP-494">  // cache block for '.'  and '..'</front>
<front id="SdBaseFileCPP-495">  block = vol_-&gt;clusterStartBlock(firstCluster_);</front>
<front id="SdBaseFileCPP-496">  if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-497"></front>
<front id="SdBaseFileCPP-498">  // copy '.' to block</front>
<front id="SdBaseFileCPP-499">  memcpy(&vol_-&gt;cache()-&gt;dir[0], &d, sizeof(d));</front>
<front id="SdBaseFileCPP-500"></front>
<front id="SdBaseFileCPP-501">  // make entry for '..'</front>
<front id="SdBaseFileCPP-502">  d.name[1] = '.';</front>
<front id="SdBaseFileCPP-503">  if (parent-&gt;isRoot()) {</front>
<front id="SdBaseFileCPP-504">    d.firstClusterLow = 0;</front>
<front id="SdBaseFileCPP-505">    d.firstClusterHigh = 0;</front>
<front id="SdBaseFileCPP-506">  } else {</front>
<front id="SdBaseFileCPP-507">    d.firstClusterLow = parent-&gt;firstCluster_ & 0XFFFF;</front>
<front id="SdBaseFileCPP-508">    d.firstClusterHigh = parent-&gt;firstCluster_ &gt;&gt; 16;</front>
<front id="SdBaseFileCPP-509">  }</front>
<front id="SdBaseFileCPP-510">  // copy '..' to block</front>
<front id="SdBaseFileCPP-511">  memcpy(&vol_-&gt;cache()-&gt;dir[1], &d, sizeof(d));</front>
<front id="SdBaseFileCPP-512"></front>
<front id="SdBaseFileCPP-513">  // write first block</front>
<front id="SdBaseFileCPP-514">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-515"></front>
<front id="SdBaseFileCPP-516"> fail:</front>
<front id="SdBaseFileCPP-517">  return false;</front>
<front id="SdBaseFileCPP-518">}</front>
<front id="SdBaseFileCPP-519">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-520"> /** Open a file in the current working directory.</front>
<front id="SdBaseFileCPP-521">  *</front>
<front id="SdBaseFileCPP-522">  * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileCPP-523">  *</front>
<front id="SdBaseFileCPP-524">  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-525">  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).</front>
<front id="SdBaseFileCPP-526">  *</front>
<front id="SdBaseFileCPP-527">  * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-528">  * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-529">  */</front>
<front id="SdBaseFileCPP-530">  bool SdBaseFile::open(const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-531">    return open(cwd_, path, oflag);</front>
<front id="SdBaseFileCPP-532">  }</front>
<front id="SdBaseFileCPP-533">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-534">/** Open a file or directory by name.</front>
<front id="SdBaseFileCPP-535"> *</front>
<front id="SdBaseFileCPP-536"> * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileCPP-537"> * file to be opened.</front>
<front id="SdBaseFileCPP-538"> *</front>
<front id="SdBaseFileCPP-539"> * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileCPP-540"> *</front>
<front id="SdBaseFileCPP-541"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-542"> * OR of flags from the following list</front>
<front id="SdBaseFileCPP-543"> *</front>
<front id="SdBaseFileCPP-544"> * O_READ - Open for reading.</front>
<front id="SdBaseFileCPP-545"> *</front>
<front id="SdBaseFileCPP-546"> * O_RDONLY - Same as O_READ.</front>
<front id="SdBaseFileCPP-547"> *</front>
<front id="SdBaseFileCPP-548"> * O_WRITE - Open for writing.</front>
<front id="SdBaseFileCPP-549"> *</front>
<front id="SdBaseFileCPP-550"> * O_WRONLY - Same as O_WRITE.</front>
<front id="SdBaseFileCPP-551"> *</front>
<front id="SdBaseFileCPP-552"> * O_RDWR - Open for reading and writing.</front>
<front id="SdBaseFileCPP-553"> *</front>
<front id="SdBaseFileCPP-554"> * O_APPEND - If set, the file offset shall be set to the end of the</front>
<front id="SdBaseFileCPP-555"> * file prior to each write.</front>
<front id="SdBaseFileCPP-556"> *</front>
<front id="SdBaseFileCPP-557"> * O_AT_END - Set the initial position at the end of the file.</front>
<front id="SdBaseFileCPP-558"> *</front>
<front id="SdBaseFileCPP-559"> * O_CREAT - If the file exists, this flag has no effect except as noted</front>
<front id="SdBaseFileCPP-560"> * under O_EXCL below. Otherwise, the file shall be created</front>
<front id="SdBaseFileCPP-561"> *</front>
<front id="SdBaseFileCPP-562"> * O_EXCL - If O_CREAT and O_EXCL are set, open() shall fail if the file exists.</front>
<front id="SdBaseFileCPP-563"> *</front>
<front id="SdBaseFileCPP-564"> * O_SYNC - Call sync() after each write.  This flag should not be used with</front>
<front id="SdBaseFileCPP-565"> * write(uint8_t), write_P(PGM_P), writeln_P(PGM_P), or the Arduino Print class.</front>
<front id="SdBaseFileCPP-566"> * These functions do character at a time writes so sync() will be called</front>
<front id="SdBaseFileCPP-567"> * after each byte.</front>
<front id="SdBaseFileCPP-568"> *</front>
<front id="SdBaseFileCPP-569"> * O_TRUNC - If the file exists and is a regular file, and the file is</front>
<front id="SdBaseFileCPP-570"> * successfully opened and is not read only, its length shall be truncated to 0.</front>
<front id="SdBaseFileCPP-571"> *</front>
<front id="SdBaseFileCPP-572"> * WARNING: A given file must not be opened by more than one SdBaseFile object</front>
<front id="SdBaseFileCPP-573"> * of file corruption may occur.</front>
<front id="SdBaseFileCPP-574"> *</front>
<front id="SdBaseFileCPP-575"> * \note Directory files must be opened read only.  Write and truncation is</front>
<front id="SdBaseFileCPP-576"> * not allowed for directory files.</front>
<front id="SdBaseFileCPP-577"> *</front>
<front id="SdBaseFileCPP-578"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-579"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-580"> * Reasons for failure include this file is already open, \a dirFile is not</front>
<front id="SdBaseFileCPP-581"> * a directory, \a path is invalid, the file does not exist</front>
<front id="SdBaseFileCPP-582"> * or can't be opened in the access mode specified by oflag.</front>
<front id="SdBaseFileCPP-583"> */</front>
<front id="SdBaseFileCPP-584">bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-585">  uint8_t dname[11];</front>
<front id="SdBaseFileCPP-586">  SdBaseFile dir1, dir2;</front>
<front id="SdBaseFileCPP-587">  SdBaseFile *parent = dirFile;</front>
<front id="SdBaseFileCPP-588">  SdBaseFile *sub = &dir1;</front>
<front id="SdBaseFileCPP-589"></front>
<front id="SdBaseFileCPP-590">  if (!dirFile) goto fail;</front>
<front id="SdBaseFileCPP-591"></front>
<front id="SdBaseFileCPP-592">  // error if already open</front>
<front id="SdBaseFileCPP-593">  if (isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-594"></front>
<front id="SdBaseFileCPP-595">  if (*path == '/') {</front>
<front id="SdBaseFileCPP-596">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-597">    if (!dirFile-&gt;isRoot()) {</front>
<front id="SdBaseFileCPP-598">      if (!dir2.openRoot(dirFile-&gt;vol_)) goto fail;</front>
<front id="SdBaseFileCPP-599">      parent = &dir2;</front>
<front id="SdBaseFileCPP-600">    }</front>
<front id="SdBaseFileCPP-601">  }</front>
<front id="SdBaseFileCPP-602">  while (1) {</front>
<front id="SdBaseFileCPP-603">    if (!make83Name(path, dname, &path)) goto fail;</front>
<front id="SdBaseFileCPP-604">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-605">    if (!*path) break;</front>
<front id="SdBaseFileCPP-606">    if (!sub-&gt;open(parent, dname, O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-607">    if (parent != dirFile) parent-&gt;close();</front>
<front id="SdBaseFileCPP-608">    parent = sub;</front>
<front id="SdBaseFileCPP-609">    sub = parent != &dir1 ? &dir1 : &dir2;</front>
<front id="SdBaseFileCPP-610">  }</front>
<front id="SdBaseFileCPP-611">  return open(parent, dname, oflag);</front>
<front id="SdBaseFileCPP-612"></front>
<front id="SdBaseFileCPP-613"> fail:</front>
<front id="SdBaseFileCPP-614">  return false;</front>
<front id="SdBaseFileCPP-615">}</front>
<front id="SdBaseFileCPP-616">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-617">// open with filename in dname</front>
<front id="SdBaseFileCPP-618">bool SdBaseFile::open(SdBaseFile* dirFile,</front>
<front id="SdBaseFileCPP-619">  const uint8_t dname[11], uint8_t oflag) {</front>
<front id="SdBaseFileCPP-620">  bool emptyFound = false;</front>
<front id="SdBaseFileCPP-621">  bool fileFound = false;</front>
<front id="SdBaseFileCPP-622">  uint8_t index;</front>
<front id="SdBaseFileCPP-623">  dir_t* p;</front>
<front id="SdBaseFileCPP-624"></front>
<front id="SdBaseFileCPP-625">  vol_ = dirFile-&gt;vol_;</front>
<front id="SdBaseFileCPP-626"></front>
<front id="SdBaseFileCPP-627">  dirFile-&gt;rewind();</front>
<front id="SdBaseFileCPP-628">  // search for file</front>
<front id="SdBaseFileCPP-629"></front>
<front id="SdBaseFileCPP-630">  while (dirFile-&gt;curPosition_ &lt; dirFile-&gt;fileSize_) {</front>
<front id="SdBaseFileCPP-631">    index = 0XF & (dirFile-&gt;curPosition_ &gt;&gt; 5);</front>
<front id="SdBaseFileCPP-632">    p = dirFile-&gt;readDirCache();</front>
<front id="SdBaseFileCPP-633">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-634"></front>
<front id="SdBaseFileCPP-635">    if (p-&gt;name[0] == DIR_NAME_FREE || p-&gt;name[0] == DIR_NAME_DELETED) {</front>
<front id="SdBaseFileCPP-636">      // remember first empty slot</front>
<front id="SdBaseFileCPP-637">      if (!emptyFound) {</front>
<front id="SdBaseFileCPP-638">        dirBlock_ = dirFile-&gt;vol_-&gt;cacheBlockNumber();</front>
<front id="SdBaseFileCPP-639">        dirIndex_ = index;</front>
<front id="SdBaseFileCPP-640">        emptyFound = true;</front>
<front id="SdBaseFileCPP-641">      }</front>
<front id="SdBaseFileCPP-642">      // done if no entries follow</front>
<front id="SdBaseFileCPP-643">      if (p-&gt;name[0] == DIR_NAME_FREE) break;</front>
<front id="SdBaseFileCPP-644">    } else if (!memcmp(dname, p-&gt;name, 11)) {</front>
<front id="SdBaseFileCPP-645">      fileFound = true;</front>
<front id="SdBaseFileCPP-646">      break;</front>
<front id="SdBaseFileCPP-647">    }</front>
<front id="SdBaseFileCPP-648">  }</front>
<front id="SdBaseFileCPP-649">  if (fileFound) {</front>
<front id="SdBaseFileCPP-650">    // don't open existing file if O_EXCL</front>
<front id="SdBaseFileCPP-651">    if (oflag & O_EXCL) goto fail;</front>
<front id="SdBaseFileCPP-652">  } else {</front>
<front id="SdBaseFileCPP-653">    // don't create unless O_CREAT and O_WRITE</front>
<front id="SdBaseFileCPP-654">    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-655">    if (emptyFound) {</front>
<front id="SdBaseFileCPP-656">      index = dirIndex_;</front>
<front id="SdBaseFileCPP-657">      p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-658">      if (!p) goto fail;</front>
<front id="SdBaseFileCPP-659">    } else {</front>
<front id="SdBaseFileCPP-660">      if (dirFile-&gt;type_ == FAT_FILE_TYPE_ROOT_FIXED) goto fail;</front>
<front id="SdBaseFileCPP-661"></front>
<front id="SdBaseFileCPP-662">      // add and zero cluster for dirFile - first cluster is in cache for write</front>
<front id="SdBaseFileCPP-663">      if (!dirFile-&gt;addDirCluster()) goto fail;</front>
<front id="SdBaseFileCPP-664"></front>
<front id="SdBaseFileCPP-665">      // use first entry in cluster</front>
<front id="SdBaseFileCPP-666">      p = dirFile-&gt;vol_-&gt;cache()-&gt;dir;</front>
<front id="SdBaseFileCPP-667">      index = 0;</front>
<front id="SdBaseFileCPP-668">    }</front>
<front id="SdBaseFileCPP-669">    // initialize as empty file</front>
<front id="SdBaseFileCPP-670">    memset(p, 0, sizeof(dir_t));</front>
<front id="SdBaseFileCPP-671">    memcpy(p-&gt;name, dname, 11);</front>
<front id="SdBaseFileCPP-672"></front>
<front id="SdBaseFileCPP-673">    // set timestamps</front>
<front id="SdBaseFileCPP-674">    if (dateTime_) {</front>
<front id="SdBaseFileCPP-675">      // call user date/time function</front>
<front id="SdBaseFileCPP-676">      dateTime_(&p-&gt;creationDate, &p-&gt;creationTime);</front>
<front id="SdBaseFileCPP-677">    } else {</front>
<front id="SdBaseFileCPP-678">      // use default date/time</front>
<front id="SdBaseFileCPP-679">      p-&gt;creationDate = FAT_DEFAULT_DATE;</front>
<front id="SdBaseFileCPP-680">      p-&gt;creationTime = FAT_DEFAULT_TIME;</front>
<front id="SdBaseFileCPP-681">    }</front>
<front id="SdBaseFileCPP-682">    p-&gt;lastAccessDate = p-&gt;creationDate;</front>
<front id="SdBaseFileCPP-683">    p-&gt;lastWriteDate = p-&gt;creationDate;</front>
<front id="SdBaseFileCPP-684">    p-&gt;lastWriteTime = p-&gt;creationTime;</front>
<front id="SdBaseFileCPP-685"></front>
<front id="SdBaseFileCPP-686">    // write entry to SD</front>
<front id="SdBaseFileCPP-687">    if (!dirFile-&gt;vol_-&gt;cacheFlush()) goto fail;</front>
<front id="SdBaseFileCPP-688">  }</front>
<front id="SdBaseFileCPP-689">  // open entry in cache</front>
<front id="SdBaseFileCPP-690">  return openCachedEntry(index, oflag);</front>
<front id="SdBaseFileCPP-691"></front>
<front id="SdBaseFileCPP-692"> fail:</front>
<front id="SdBaseFileCPP-693">  return false;</front>
<front id="SdBaseFileCPP-694">}</front>
<front id="SdBaseFileCPP-695">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-696">/** Open a file by index.</front>
<front id="SdBaseFileCPP-697"> *</front>
<front id="SdBaseFileCPP-698"> * \param[in] dirFile An open SdFat instance for the directory.</front>
<front id="SdBaseFileCPP-699"> *</front>
<front id="SdBaseFileCPP-700"> * \param[in] index The \a index of the directory entry for the file to be</front>
<front id="SdBaseFileCPP-701"> * opened.  The value for \a index is (directory file position)/32.</front>
<front id="SdBaseFileCPP-702"> *</front>
<front id="SdBaseFileCPP-703"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-704"> * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileCPP-705"> *</front>
<front id="SdBaseFileCPP-706"> * See open() by path for definition of flags.</front>
<front id="SdBaseFileCPP-707"> * \return true for success or false for failure.</front>
<front id="SdBaseFileCPP-708"> */</front>
<front id="SdBaseFileCPP-709">bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-710">  dir_t* p;</front>
<front id="SdBaseFileCPP-711"></front>
<front id="SdBaseFileCPP-712">  vol_ = dirFile-&gt;vol_;</front>
<front id="SdBaseFileCPP-713"></front>
<front id="SdBaseFileCPP-714">  // error if already open</front>
<front id="SdBaseFileCPP-715">  if (isOpen() || !dirFile) goto fail;</front>
<front id="SdBaseFileCPP-716"></front>
<front id="SdBaseFileCPP-717">  // don't open existing file if O_EXCL - user call error</front>
<front id="SdBaseFileCPP-718">  if (oflag & O_EXCL) goto fail;</front>
<front id="SdBaseFileCPP-719"></front>
<front id="SdBaseFileCPP-720">  // seek to location of entry</front>
<front id="SdBaseFileCPP-721">  if (!dirFile-&gt;seekSet(32 * index)) goto fail;</front>
<front id="SdBaseFileCPP-722"></front>
<front id="SdBaseFileCPP-723">  // read entry into cache</front>
<front id="SdBaseFileCPP-724">  p = dirFile-&gt;readDirCache();</front>
<front id="SdBaseFileCPP-725">  if (!p) goto fail;</front>
<front id="SdBaseFileCPP-726"></front>
<front id="SdBaseFileCPP-727">  // error if empty slot or '.' or '..'</front>
<front id="SdBaseFileCPP-728">  if (p-&gt;name[0] == DIR_NAME_FREE ||</front>
<front id="SdBaseFileCPP-729">      p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') {</front>
<front id="SdBaseFileCPP-730">    goto fail;</front>
<front id="SdBaseFileCPP-731">  }</front>
<front id="SdBaseFileCPP-732">  // open cached entry</front>
<front id="SdBaseFileCPP-733">  return openCachedEntry(index & 0XF, oflag);</front>
<front id="SdBaseFileCPP-734"></front>
<front id="SdBaseFileCPP-735"> fail:</front>
<front id="SdBaseFileCPP-736">  return false;</front>
<front id="SdBaseFileCPP-737">}</front>
<front id="SdBaseFileCPP-738">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-739">// open a cached directory entry. Assumes vol_ is initialized</front>
<front id="SdBaseFileCPP-740">bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-741">  // location of entry in cache</front>
<front id="SdBaseFileCPP-742">  dir_t* p = &vol_-&gt;cache()-&gt;dir[dirIndex];</front>
<front id="SdBaseFileCPP-743"></front>
<front id="SdBaseFileCPP-744">  // write or truncate is an error for a directory or read-only file</front>
<front id="SdBaseFileCPP-745">  if (p-&gt;attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {</front>
<front id="SdBaseFileCPP-746">    if (oflag & (O_WRITE | O_TRUNC)) goto fail;</front>
<front id="SdBaseFileCPP-747">  }</front>
<front id="SdBaseFileCPP-748">  // remember location of directory entry on SD</front>
<front id="SdBaseFileCPP-749">  dirBlock_ = vol_-&gt;cacheBlockNumber();</front>
<front id="SdBaseFileCPP-750">  dirIndex_ = dirIndex;</front>
<front id="SdBaseFileCPP-751"></front>
<front id="SdBaseFileCPP-752">  // copy first cluster number for directory fields</front>
<front id="SdBaseFileCPP-753">  firstCluster_ = (uint32_t)p-&gt;firstClusterHigh &lt;&lt; 16;</front>
<front id="SdBaseFileCPP-754">  firstCluster_ |= p-&gt;firstClusterLow;</front>
<front id="SdBaseFileCPP-755"></front>
<front id="SdBaseFileCPP-756">  // make sure it is a normal file or subdirectory</front>
<front id="SdBaseFileCPP-757">  if (DIR_IS_FILE(p)) {</front>
<front id="SdBaseFileCPP-758">    fileSize_ = p-&gt;fileSize;</front>
<front id="SdBaseFileCPP-759">    type_ = FAT_FILE_TYPE_NORMAL;</front>
<front id="SdBaseFileCPP-760">  } else if (DIR_IS_SUBDIR(p)) {</front>
<front id="SdBaseFileCPP-761">    if (!vol_-&gt;chainSize(firstCluster_, &fileSize_)) goto fail;</front>
<front id="SdBaseFileCPP-762">    type_ = FAT_FILE_TYPE_SUBDIR;</front>
<front id="SdBaseFileCPP-763">  } else {</front>
<front id="SdBaseFileCPP-764">    goto fail;</front>
<front id="SdBaseFileCPP-765">  }</front>
<front id="SdBaseFileCPP-766">  // save open flags for read/write</front>
<front id="SdBaseFileCPP-767">  flags_ = oflag & F_OFLAG;</front>
<front id="SdBaseFileCPP-768"></front>
<front id="SdBaseFileCPP-769">  // set to start of file</front>
<front id="SdBaseFileCPP-770">  curCluster_ = 0;</front>
<front id="SdBaseFileCPP-771">  curPosition_ = 0;</front>
<front id="SdBaseFileCPP-772">  if ((oflag & O_TRUNC) && !truncate(0)) return false;</front>
<front id="SdBaseFileCPP-773">  return oflag & O_AT_END ? seekEnd(0) : true;</front>
<front id="SdBaseFileCPP-774"></front>
<front id="SdBaseFileCPP-775"> fail:</front>
<front id="SdBaseFileCPP-776">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-777">  return false;</front>
<front id="SdBaseFileCPP-778">}</front>
<front id="SdBaseFileCPP-779">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-780">/** Open the next file or subdirectory in a directory.</front>
<front id="SdBaseFileCPP-781"> *</front>
<front id="SdBaseFileCPP-782"> * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileCPP-783"> * file to be opened.</front>
<front id="SdBaseFileCPP-784"> *</front>
<front id="SdBaseFileCPP-785"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-786"> * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileCPP-787"> *</front>
<front id="SdBaseFileCPP-788"> * See open() by path for definition of flags.</front>
<front id="SdBaseFileCPP-789"> * \return true for success or false for failure.</front>
<front id="SdBaseFileCPP-790"> */</front>
<front id="SdBaseFileCPP-791">bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-792">  dir_t* p;</front>
<front id="SdBaseFileCPP-793">  uint8_t index;</front>
<front id="SdBaseFileCPP-794"></front>
<front id="SdBaseFileCPP-795">  if (!dirFile) goto fail;</front>
<front id="SdBaseFileCPP-796"></front>
<front id="SdBaseFileCPP-797">  // error if already open</front>
<front id="SdBaseFileCPP-798">  if (isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-799"></front>
<front id="SdBaseFileCPP-800">  vol_ = dirFile-&gt;vol_;</front>
<front id="SdBaseFileCPP-801"></front>
<front id="SdBaseFileCPP-802">  while (1) {</front>
<front id="SdBaseFileCPP-803">    index = 0XF & (dirFile-&gt;curPosition_ &gt;&gt; 5);</front>
<front id="SdBaseFileCPP-804"></front>
<front id="SdBaseFileCPP-805">    // read entry into cache</front>
<front id="SdBaseFileCPP-806">    p = dirFile-&gt;readDirCache();</front>
<front id="SdBaseFileCPP-807">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-808"></front>
<front id="SdBaseFileCPP-809">    // done if last entry</front>
<front id="SdBaseFileCPP-810">    if (p-&gt;name[0] == DIR_NAME_FREE) goto fail;</front>
<front id="SdBaseFileCPP-811"></front>
<front id="SdBaseFileCPP-812">    // skip empty slot or '.' or '..'</front>
<front id="SdBaseFileCPP-813">    if (p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') {</front>
<front id="SdBaseFileCPP-814">      continue;</front>
<front id="SdBaseFileCPP-815">    }</front>
<front id="SdBaseFileCPP-816">    // must be file or dir</front>
<front id="SdBaseFileCPP-817">    if (DIR_IS_FILE_OR_SUBDIR(p)) {</front>
<front id="SdBaseFileCPP-818">      return openCachedEntry(index, oflag);</front>
<front id="SdBaseFileCPP-819">    }</front>
<front id="SdBaseFileCPP-820">  }</front>
<front id="SdBaseFileCPP-821"></front>
<front id="SdBaseFileCPP-822"> fail:</front>
<front id="SdBaseFileCPP-823">  return false;</front>
<front id="SdBaseFileCPP-824">}</front>
<front id="SdBaseFileCPP-825">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-826">/** Open a directory's parent directory.</front>
<front id="SdBaseFileCPP-827"> *</front>
<front id="SdBaseFileCPP-828"> * \param[in] dir Parent of this directory will be opened.  Must not be root.</front>
<front id="SdBaseFileCPP-829"> *</front>
<front id="SdBaseFileCPP-830"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-831"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-832"> */</front>
<front id="SdBaseFileCPP-833">bool SdBaseFile::openParent(SdBaseFile* dir) {</front>
<front id="SdBaseFileCPP-834">  dir_t entry;</front>
<front id="SdBaseFileCPP-835">  dir_t* p;</front>
<front id="SdBaseFileCPP-836">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-837">  uint32_t c;</front>
<front id="SdBaseFileCPP-838">  uint32_t cluster;</front>
<front id="SdBaseFileCPP-839">  uint32_t lbn;</front>
<front id="SdBaseFileCPP-840">  // error if already open or dir is root or dir is not a directory</front>
<front id="SdBaseFileCPP-841">  if (isOpen() || !dir || dir-&gt;isRoot() || !dir-&gt;isDir()) goto fail;</front>
<front id="SdBaseFileCPP-842">  vol_ = dir-&gt;vol_;</front>
<front id="SdBaseFileCPP-843">  // position to '..'</front>
<front id="SdBaseFileCPP-844">  if (!dir-&gt;seekSet(32)) goto fail;</front>
<front id="SdBaseFileCPP-845">  // read '..' entry</front>
<front id="SdBaseFileCPP-846">  if (dir-&gt;read(&entry, sizeof(entry)) != 32) goto fail;</front>
<front id="SdBaseFileCPP-847">  // verify it is '..'</front>
<front id="SdBaseFileCPP-848">  if (entry.name[0] != '.' || entry.name[1] != '.') goto fail;</front>
<front id="SdBaseFileCPP-849">  // start cluster for '..'</front>
<front id="SdBaseFileCPP-850">  cluster = entry.firstClusterLow;</front>
<front id="SdBaseFileCPP-851">  cluster |= (uint32_t)entry.firstClusterHigh &lt;&lt; 16;</front>
<front id="SdBaseFileCPP-852">  if (cluster == 0) return openRoot(vol_);</front>
<front id="SdBaseFileCPP-853">  // start block for '..'</front>
<front id="SdBaseFileCPP-854">  lbn = vol_-&gt;clusterStartBlock(cluster);</front>
<front id="SdBaseFileCPP-855">  // first block of parent dir</front>
<front id="SdBaseFileCPP-856">  if (!vol_-&gt;cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {</front>
<front id="SdBaseFileCPP-857">    goto fail;</front>
<front id="SdBaseFileCPP-858">  }</front>
<front id="SdBaseFileCPP-859">  p = &vol_-&gt;cacheBuffer_.dir[1];</front>
<front id="SdBaseFileCPP-860">  // verify name for '../..'</front>
<front id="SdBaseFileCPP-861">  if (p-&gt;name[0] != '.' || p-&gt;name[1] != '.') goto fail;</front>
<front id="SdBaseFileCPP-862">  // '..' is pointer to first cluster of parent. open '../..' to find parent</front>
<front id="SdBaseFileCPP-863">  if (p-&gt;firstClusterHigh == 0 && p-&gt;firstClusterLow == 0) {</front>
<front id="SdBaseFileCPP-864">    if (!file.openRoot(dir-&gt;volume())) goto fail;</front>
<front id="SdBaseFileCPP-865">  } else {</front>
<front id="SdBaseFileCPP-866">    if (!file.openCachedEntry(1, O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-867">  }</front>
<front id="SdBaseFileCPP-868">  // search for parent in '../..'</front>
<front id="SdBaseFileCPP-869">  do {</front>
<front id="SdBaseFileCPP-870">    if (file.readDir(&entry, NULL) != 32) goto fail;</front>
<front id="SdBaseFileCPP-871">    c = entry.firstClusterLow;</front>
<front id="SdBaseFileCPP-872">    c |= (uint32_t)entry.firstClusterHigh &lt;&lt; 16;</front>
<front id="SdBaseFileCPP-873">  } while (c != cluster);</front>
<front id="SdBaseFileCPP-874">  // open parent</front>
<front id="SdBaseFileCPP-875">  return open(&file, file.curPosition()/32 - 1, O_READ);</front>
<front id="SdBaseFileCPP-876"></front>
<front id="SdBaseFileCPP-877"> fail:</front>
<front id="SdBaseFileCPP-878">  return false;</front>
<front id="SdBaseFileCPP-879">}</front>
<front id="SdBaseFileCPP-880">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-881">/** Open a volume's root directory.</front>
<front id="SdBaseFileCPP-882"> *</front>
<front id="SdBaseFileCPP-883"> * \param[in] vol The FAT volume containing the root directory to be opened.</front>
<front id="SdBaseFileCPP-884"> *</front>
<front id="SdBaseFileCPP-885"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-886"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-887"> * Reasons for failure include the file is already open, the FAT volume has</front>
<front id="SdBaseFileCPP-888"> * not been initialized or it a FAT12 volume.</front>
<front id="SdBaseFileCPP-889"> */</front>
<front id="SdBaseFileCPP-890">bool SdBaseFile::openRoot(SdVolume* vol) {</front>
<front id="SdBaseFileCPP-891">  // error if file is already open</front>
<front id="SdBaseFileCPP-892">  if (isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-893"></front>
<front id="SdBaseFileCPP-894">  if (vol-&gt;fatType() == 16 || (FAT12_SUPPORT && vol-&gt;fatType() == 12)) {</front>
<front id="SdBaseFileCPP-895">    type_ = FAT_FILE_TYPE_ROOT_FIXED;</front>
<front id="SdBaseFileCPP-896">    firstCluster_ = 0;</front>
<front id="SdBaseFileCPP-897">    fileSize_ = 32 * vol-&gt;rootDirEntryCount();</front>
<front id="SdBaseFileCPP-898">  } else if (vol-&gt;fatType() == 32) {</front>
<front id="SdBaseFileCPP-899">    type_ = FAT_FILE_TYPE_ROOT32;</front>
<front id="SdBaseFileCPP-900">    firstCluster_ = vol-&gt;rootDirStart();</front>
<front id="SdBaseFileCPP-901">    if (!vol-&gt;chainSize(firstCluster_, &fileSize_)) goto fail;</front>
<front id="SdBaseFileCPP-902">  } else {</front>
<front id="SdBaseFileCPP-903">    // volume is not initialized, invalid, or FAT12 without support</front>
<front id="SdBaseFileCPP-904">    return false;</front>
<front id="SdBaseFileCPP-905">  }</front>
<front id="SdBaseFileCPP-906">  vol_ = vol;</front>
<front id="SdBaseFileCPP-907">  // read only</front>
<front id="SdBaseFileCPP-908">  flags_ = O_READ;</front>
<front id="SdBaseFileCPP-909"></front>
<front id="SdBaseFileCPP-910">  // set to start of file</front>
<front id="SdBaseFileCPP-911">  curCluster_ = 0;</front>
<front id="SdBaseFileCPP-912">  curPosition_ = 0;</front>
<front id="SdBaseFileCPP-913"></front>
<front id="SdBaseFileCPP-914">  // root has no directory entry</front>
<front id="SdBaseFileCPP-915">  dirBlock_ = 0;</front>
<front id="SdBaseFileCPP-916">  dirIndex_ = 0;</front>
<front id="SdBaseFileCPP-917">  return true;</front>
<front id="SdBaseFileCPP-918"></front>
<front id="SdBaseFileCPP-919"> fail:</front>
<front id="SdBaseFileCPP-920">  return false;</front>
<front id="SdBaseFileCPP-921">}</front>
<front id="SdBaseFileCPP-922">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-923">/** Return the next available byte without consuming it.</front>
<front id="SdBaseFileCPP-924"> *</front>
<front id="SdBaseFileCPP-925"> * \return The byte if no error and not at eof else -1;</front>
<front id="SdBaseFileCPP-926"> */</front>
<front id="SdBaseFileCPP-927">int SdBaseFile::peek() {</front>
<front id="SdBaseFileCPP-928">  fpos_t pos;</front>
<front id="SdBaseFileCPP-929">  getpos(&pos);</front>
<front id="SdBaseFileCPP-930">  int c = read();</front>
<front id="SdBaseFileCPP-931">  if (c &gt;= 0) setpos(&pos);</front>
<front id="SdBaseFileCPP-932">  return c;</front>
<front id="SdBaseFileCPP-933">}</front>
<front id="SdBaseFileCPP-934"></front>
<front id="SdBaseFileCPP-935">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-936">/** %Print the name field of a directory entry in 8.3 format.</front>
<front id="SdBaseFileCPP-937"> * \param[in] pr Print stream for output.</front>
<front id="SdBaseFileCPP-938"> * \param[in] dir The directory structure containing the name.</front>
<front id="SdBaseFileCPP-939"> * \param[in] width Blank fill name if length is less than \a width.</front>
<front id="SdBaseFileCPP-940"> * \param[in] printSlash Print '/' after directory names if true.</front>
<front id="SdBaseFileCPP-941"> */</front>
<front id="SdBaseFileCPP-942">void SdBaseFile::printDirName(const dir_t& dir,</front>
<front id="SdBaseFileCPP-943">  uint8_t width, bool printSlash) {</front>
<front id="SdBaseFileCPP-944">  uint8_t w = 0;</front>
<front id="SdBaseFileCPP-945">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="SdBaseFileCPP-946">    if (dir.name[i] == ' ')continue;</front>
<front id="SdBaseFileCPP-947">    if (i == 8) {</front>
<front id="SdBaseFileCPP-948">      MYSERIAL.write('.');</front>
<front id="SdBaseFileCPP-949">      w++;</front>
<front id="SdBaseFileCPP-950">    }</front>
<front id="SdBaseFileCPP-951">    MYSERIAL.write(dir.name[i]);</front>
<front id="SdBaseFileCPP-952">    w++;</front>
<front id="SdBaseFileCPP-953">  }</front>
<front id="SdBaseFileCPP-954">  if (DIR_IS_SUBDIR(&dir) && printSlash) {</front>
<front id="SdBaseFileCPP-955">    MYSERIAL.write('/');</front>
<front id="SdBaseFileCPP-956">    w++;</front>
<front id="SdBaseFileCPP-957">  }</front>
<front id="SdBaseFileCPP-958">  while (w &lt; width) {</front>
<front id="SdBaseFileCPP-959">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-960">    w++;</front>
<front id="SdBaseFileCPP-961">  }</front>
<front id="SdBaseFileCPP-962">}</front>
<front id="SdBaseFileCPP-963">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-964">// print uint8_t with width 2</front>
<front id="SdBaseFileCPP-965">static void print2u( uint8_t v) {</front>
<front id="SdBaseFileCPP-966">  if (v &lt; 10) MYSERIAL.write('0');</front>
<front id="SdBaseFileCPP-967">  MYSERIAL.print(v, DEC);</front>
<front id="SdBaseFileCPP-968">}</front>
<front id="SdBaseFileCPP-969">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-970">/** %Print a directory date field to Serial.</front>
<front id="SdBaseFileCPP-971"> *</front>
<front id="SdBaseFileCPP-972"> *  Format is yyyy-mm-dd.</front>
<front id="SdBaseFileCPP-973"> *</front>
<front id="SdBaseFileCPP-974"> * \param[in] fatDate The date field from a directory entry.</front>
<front id="SdBaseFileCPP-975"> */</front>
<front id="SdBaseFileCPP-976"></front>
<front id="SdBaseFileCPP-977">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-978">/** %Print a directory date field.</front>
<front id="SdBaseFileCPP-979"> *</front>
<front id="SdBaseFileCPP-980"> *  Format is yyyy-mm-dd.</front>
<front id="SdBaseFileCPP-981"> *</front>
<front id="SdBaseFileCPP-982"> * \param[in] pr Print stream for output.</front>
<front id="SdBaseFileCPP-983"> * \param[in] fatDate The date field from a directory entry.</front>
<front id="SdBaseFileCPP-984"> */</front>
<front id="SdBaseFileCPP-985">void SdBaseFile::printFatDate(uint16_t fatDate) {</front>
<front id="SdBaseFileCPP-986">  MYSERIAL.print(FAT_YEAR(fatDate));</front>
<front id="SdBaseFileCPP-987">  MYSERIAL.write('-');</front>
<front id="SdBaseFileCPP-988">  print2u( FAT_MONTH(fatDate));</front>
<front id="SdBaseFileCPP-989">  MYSERIAL.write('-');</front>
<front id="SdBaseFileCPP-990">  print2u( FAT_DAY(fatDate));</front>
<front id="SdBaseFileCPP-991">}</front>
<front id="SdBaseFileCPP-992"></front>
<front id="SdBaseFileCPP-993">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-994">/** %Print a directory time field.</front>
<front id="SdBaseFileCPP-995"> *</front>
<front id="SdBaseFileCPP-996"> * Format is hh:mm:ss.</front>
<front id="SdBaseFileCPP-997"> *</front>
<front id="SdBaseFileCPP-998"> * \param[in] pr Print stream for output.</front>
<front id="SdBaseFileCPP-999"> * \param[in] fatTime The time field from a directory entry.</front>
<front id="SdBaseFileCPP-1000"> */</front>
<front id="SdBaseFileCPP-1001">void SdBaseFile::printFatTime( uint16_t fatTime) {</front>
<front id="SdBaseFileCPP-1002">  print2u( FAT_HOUR(fatTime));</front>
<front id="SdBaseFileCPP-1003">  MYSERIAL.write(':');</front>
<front id="SdBaseFileCPP-1004">  print2u( FAT_MINUTE(fatTime));</front>
<front id="SdBaseFileCPP-1005">  MYSERIAL.write(':');</front>
<front id="SdBaseFileCPP-1006">  print2u( FAT_SECOND(fatTime));</front>
<front id="SdBaseFileCPP-1007">}</front>
<front id="SdBaseFileCPP-1008">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1009">/** Print a file's name to Serial</front>
<front id="SdBaseFileCPP-1010"> *</front>
<front id="SdBaseFileCPP-1011"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1012"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1013"> */</front>
<front id="SdBaseFileCPP-1014">bool SdBaseFile::printName() {</front>
<front id="SdBaseFileCPP-1015">  char name[13];</front>
<front id="SdBaseFileCPP-1016">  if (!getFilename(name)) return false;</front>
<front id="SdBaseFileCPP-1017">  MYSERIAL.print(name);</front>
<front id="SdBaseFileCPP-1018">  return true;</front>
<front id="SdBaseFileCPP-1019">}</front>
<front id="SdBaseFileCPP-1020">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1021">/** Read the next byte from a file.</front>
<front id="SdBaseFileCPP-1022"> *</front>
<front id="SdBaseFileCPP-1023"> * \return For success read returns the next byte in the file as an int.</front>
<front id="SdBaseFileCPP-1024"> * If an error occurs or end of file is reached -1 is returned.</front>
<front id="SdBaseFileCPP-1025"> */</front>
<front id="SdBaseFileCPP-1026">int16_t SdBaseFile::read() {</front>
<front id="SdBaseFileCPP-1027">  uint8_t b;</front>
<front id="SdBaseFileCPP-1028">  return read(&b, 1) == 1 ? b : -1;</front>
<front id="SdBaseFileCPP-1029">}</front>
<front id="SdBaseFileCPP-1030">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1031">/** Read data from a file starting at the current position.</front>
<front id="SdBaseFileCPP-1032"> *</front>
<front id="SdBaseFileCPP-1033"> * \param[out] buf Pointer to the location that will receive the data.</front>
<front id="SdBaseFileCPP-1034"> *</front>
<front id="SdBaseFileCPP-1035"> * \param[in] nbyte Maximum number of bytes to read.</front>
<front id="SdBaseFileCPP-1036"> *</front>
<front id="SdBaseFileCPP-1037"> * \return For success read() returns the number of bytes read.</front>
<front id="SdBaseFileCPP-1038"> * A value less than \a nbyte, including zero, will be returned</front>
<front id="SdBaseFileCPP-1039"> * if end of file is reached.</front>
<front id="SdBaseFileCPP-1040"> * If an error occurs, read() returns -1.  Possible errors include</front>
<front id="SdBaseFileCPP-1041"> * read() called before a file has been opened, corrupt file system</front>
<front id="SdBaseFileCPP-1042"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1043"> */</front>
<front id="SdBaseFileCPP-1044">int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {</front>
<front id="SdBaseFileCPP-1045">  uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(buf);</front>
<front id="SdBaseFileCPP-1046">  uint16_t offset;</front>
<front id="SdBaseFileCPP-1047">  uint16_t toRead;</front>
<front id="SdBaseFileCPP-1048">  uint32_t block;  // raw device block number</front>
<front id="SdBaseFileCPP-1049"></front>
<front id="SdBaseFileCPP-1050">  // error if not open or write only</front>
<front id="SdBaseFileCPP-1051">  if (!isOpen() || !(flags_ & O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1052"></front>
<front id="SdBaseFileCPP-1053">  // max bytes left in file</front>
<front id="SdBaseFileCPP-1054">  if (nbyte &gt;= (fileSize_ - curPosition_)) {</front>
<front id="SdBaseFileCPP-1055">    nbyte = fileSize_ - curPosition_;</front>
<front id="SdBaseFileCPP-1056">  }</front>
<front id="SdBaseFileCPP-1057">  // amount left to read</front>
<front id="SdBaseFileCPP-1058">  toRead = nbyte;</front>
<front id="SdBaseFileCPP-1059">  while (toRead &gt; 0) {</front>
<front id="SdBaseFileCPP-1060">    offset = curPosition_ & 0X1FF;  // offset in block</front>
<front id="SdBaseFileCPP-1061">    if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {</front>
<front id="SdBaseFileCPP-1062">      block = vol_-&gt;rootDirStart() + (curPosition_ &gt;&gt; 9);</front>
<front id="SdBaseFileCPP-1063">    } else {</front>
<front id="SdBaseFileCPP-1064">      uint8_t blockOfCluster = vol_-&gt;blockOfCluster(curPosition_);</front>
<front id="SdBaseFileCPP-1065">      if (offset == 0 && blockOfCluster == 0) {</front>
<front id="SdBaseFileCPP-1066">        // start of new cluster</front>
<front id="SdBaseFileCPP-1067">        if (curPosition_ == 0) {</front>
<front id="SdBaseFileCPP-1068">          // use first cluster in file</front>
<front id="SdBaseFileCPP-1069">          curCluster_ = firstCluster_;</front>
<front id="SdBaseFileCPP-1070">        } else {</front>
<front id="SdBaseFileCPP-1071">          // get next cluster from FAT</front>
<front id="SdBaseFileCPP-1072">          if (!vol_-&gt;fatGet(curCluster_, &curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1073">        }</front>
<front id="SdBaseFileCPP-1074">      }</front>
<front id="SdBaseFileCPP-1075">      block = vol_-&gt;clusterStartBlock(curCluster_) + blockOfCluster;</front>
<front id="SdBaseFileCPP-1076">    }</front>
<front id="SdBaseFileCPP-1077">    uint16_t n = toRead;</front>
<front id="SdBaseFileCPP-1078"></front>
<front id="SdBaseFileCPP-1079">    // amount to be read from current block</front>
<front id="SdBaseFileCPP-1080">    if (n &gt; (512 - offset)) n = 512 - offset;</front>
<front id="SdBaseFileCPP-1081"></front>
<front id="SdBaseFileCPP-1082">    // no buffering needed if n == 512</front>
<front id="SdBaseFileCPP-1083">    if (n == 512 && block != vol_-&gt;cacheBlockNumber()) {</front>
<front id="SdBaseFileCPP-1084">      if (!vol_-&gt;readBlock(block, dst)) goto fail;</front>
<front id="SdBaseFileCPP-1085">    } else {</front>
<front id="SdBaseFileCPP-1086">      // read block to cache and copy data to caller</front>
<front id="SdBaseFileCPP-1087">      if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1088">      uint8_t* src = vol_-&gt;cache()-&gt;data + offset;</front>
<front id="SdBaseFileCPP-1089">      memcpy(dst, src, n);</front>
<front id="SdBaseFileCPP-1090">    }</front>
<front id="SdBaseFileCPP-1091">    dst += n;</front>
<front id="SdBaseFileCPP-1092">    curPosition_ += n;</front>
<front id="SdBaseFileCPP-1093">    toRead -= n;</front>
<front id="SdBaseFileCPP-1094">  }</front>
<front id="SdBaseFileCPP-1095">  return nbyte;</front>
<front id="SdBaseFileCPP-1096"></front>
<front id="SdBaseFileCPP-1097"> fail:</front>
<front id="SdBaseFileCPP-1098">  return -1;</front>
<front id="SdBaseFileCPP-1099">}</front>
<front id="SdBaseFileCPP-1100">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1101">/** Read the next directory entry from a directory file.</front>
<front id="SdBaseFileCPP-1102"> *</front>
<front id="SdBaseFileCPP-1103"> * \param[out] dir The dir_t struct that will receive the data.</front>
<front id="SdBaseFileCPP-1104"> *</front>
<front id="SdBaseFileCPP-1105"> * \return For success readDir() returns the number of bytes read.</front>
<front id="SdBaseFileCPP-1106"> * A value of zero will be returned if end of file is reached.</front>
<front id="SdBaseFileCPP-1107"> * If an error occurs, readDir() returns -1.  Possible errors include</front>
<front id="SdBaseFileCPP-1108"> * readDir() called before a directory has been opened, this is not</front>
<front id="SdBaseFileCPP-1109"> * a directory file or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1110"> */</front>
<front id="SdBaseFileCPP-1111">int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {</front>
<front id="SdBaseFileCPP-1112">  int16_t n;</front>
<front id="SdBaseFileCPP-1113">  // if not a directory file or miss-positioned return an error</front>
<front id="SdBaseFileCPP-1114">  if (!isDir() || (0X1F & curPosition_)) return -1;</front>
<front id="SdBaseFileCPP-1115">  </front>
<front id="SdBaseFileCPP-1116">  //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.</front>
<front id="SdBaseFileCPP-1117">  if (longFilename != NULL)</front>
<front id="SdBaseFileCPP-1118">  {</front>
<front id="SdBaseFileCPP-1119">  	longFilename[0] = '\0';</front>
<front id="SdBaseFileCPP-1120">  }</front>
<front id="SdBaseFileCPP-1121"></front>
<front id="SdBaseFileCPP-1122">  while (1) {</front>
<front id="SdBaseFileCPP-1123">    n = read(dir, sizeof(dir_t));</front>
<front id="SdBaseFileCPP-1124">    if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;</front>
<front id="SdBaseFileCPP-1125">    // last entry if DIR_NAME_FREE</front>
<front id="SdBaseFileCPP-1126">    if (dir-&gt;name[0] == DIR_NAME_FREE) return 0;</front>
<front id="SdBaseFileCPP-1127">    // skip empty entries and entry for .  and ..</front>
<front id="SdBaseFileCPP-1128">    if (dir-&gt;name[0] == DIR_NAME_DELETED || dir-&gt;name[0] == '.') continue;</front>
<front id="SdBaseFileCPP-1129">    //Fill the long filename if we have a long filename entry,</front>
<front id="SdBaseFileCPP-1130">	// long filename entries are stored before the actual filename.</front>
<front id="SdBaseFileCPP-1131">	if (DIR_IS_LONG_NAME(dir) && longFilename != NULL)</front>
<front id="SdBaseFileCPP-1132">    {</front>
<front id="SdBaseFileCPP-1133">    	vfat_t *VFAT = (vfat_t*)dir;</front>
<front id="SdBaseFileCPP-1134">		//Sanity check the VFAT entry. The first cluster is always set to zero. And th esequence number should be higher then 0</front>
<front id="SdBaseFileCPP-1135">    	if (VFAT-&gt;firstClusterLow == 0 && (VFAT-&gt;sequenceNumber & 0x1F) &gt; 0 && (VFAT-&gt;sequenceNumber & 0x1F) &lt;= MAX_VFAT_ENTRIES)</front>
<front id="SdBaseFileCPP-1136">    	{</front>
<front id="SdBaseFileCPP-1137">			//TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.</front>
<front id="SdBaseFileCPP-1138">    		n = ((VFAT-&gt;sequenceNumber & 0x1F) - 1) * 13;</front>
<front id="SdBaseFileCPP-1139">			longFilename[n+0] = VFAT-&gt;name1[0];</front>
<front id="SdBaseFileCPP-1140">			longFilename[n+1] = VFAT-&gt;name1[1];</front>
<front id="SdBaseFileCPP-1141">			longFilename[n+2] = VFAT-&gt;name1[2];</front>
<front id="SdBaseFileCPP-1142">			longFilename[n+3] = VFAT-&gt;name1[3];</front>
<front id="SdBaseFileCPP-1143">			longFilename[n+4] = VFAT-&gt;name1[4];</front>
<front id="SdBaseFileCPP-1144">			longFilename[n+5] = VFAT-&gt;name2[0];</front>
<front id="SdBaseFileCPP-1145">			longFilename[n+6] = VFAT-&gt;name2[1];</front>
<front id="SdBaseFileCPP-1146">			longFilename[n+7] = VFAT-&gt;name2[2];</front>
<front id="SdBaseFileCPP-1147">			longFilename[n+8] = VFAT-&gt;name2[3];</front>
<front id="SdBaseFileCPP-1148">			longFilename[n+9] = VFAT-&gt;name2[4];</front>
<front id="SdBaseFileCPP-1149">			longFilename[n+10] = VFAT-&gt;name2[5];</front>
<front id="SdBaseFileCPP-1150">			longFilename[n+11] = VFAT-&gt;name3[0];</front>
<front id="SdBaseFileCPP-1151">			longFilename[n+12] = VFAT-&gt;name3[1];</front>
<front id="SdBaseFileCPP-1152">			//If this VFAT entry is the last one, add a NUL terminator at the end of the string</front>
<front id="SdBaseFileCPP-1153">			if (VFAT-&gt;sequenceNumber & 0x40)</front>
<front id="SdBaseFileCPP-1154">				longFilename[n+13] = '\0';</front>
<front id="SdBaseFileCPP-1155">		}</front>
<front id="SdBaseFileCPP-1156">    }</front>
<front id="SdBaseFileCPP-1157">    // return if normal file or subdirectory</front>
<front id="SdBaseFileCPP-1158">    if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;</front>
<front id="SdBaseFileCPP-1159">  }</front>
<front id="SdBaseFileCPP-1160">}</front>
<front id="SdBaseFileCPP-1161">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1162">// Read next directory entry into the cache</front>
<front id="SdBaseFileCPP-1163">// Assumes file is correctly positioned</front>
<front id="SdBaseFileCPP-1164">dir_t* SdBaseFile::readDirCache() {</front>
<front id="SdBaseFileCPP-1165">  uint8_t i;</front>
<front id="SdBaseFileCPP-1166">  // error if not directory</front>
<front id="SdBaseFileCPP-1167">  if (!isDir()) goto fail;</front>
<front id="SdBaseFileCPP-1168"></front>
<front id="SdBaseFileCPP-1169">  // index of entry in cache</front>
<front id="SdBaseFileCPP-1170">  i = (curPosition_ &gt;&gt; 5) & 0XF;</front>
<front id="SdBaseFileCPP-1171"></front>
<front id="SdBaseFileCPP-1172">  // use read to locate and cache block</front>
<front id="SdBaseFileCPP-1173">  if (read() &lt; 0) goto fail;</front>
<front id="SdBaseFileCPP-1174"></front>
<front id="SdBaseFileCPP-1175">  // advance to next entry</front>
<front id="SdBaseFileCPP-1176">  curPosition_ += 31;</front>
<front id="SdBaseFileCPP-1177"></front>
<front id="SdBaseFileCPP-1178">  // return pointer to entry</front>
<front id="SdBaseFileCPP-1179">  return vol_-&gt;cache()-&gt;dir + i;</front>
<front id="SdBaseFileCPP-1180"></front>
<front id="SdBaseFileCPP-1181"> fail:</front>
<front id="SdBaseFileCPP-1182">  return 0;</front>
<front id="SdBaseFileCPP-1183">}</front>
<front id="SdBaseFileCPP-1184">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1185">/** Remove a file.</front>
<front id="SdBaseFileCPP-1186"> *</front>
<front id="SdBaseFileCPP-1187"> * The directory entry and all data for the file are deleted.</front>
<front id="SdBaseFileCPP-1188"> *</front>
<front id="SdBaseFileCPP-1189"> * \note This function should not be used to delete the 8.3 version of a</front>
<front id="SdBaseFileCPP-1190"> * file that has a long name. For example if a file has the long name</front>
<front id="SdBaseFileCPP-1191"> * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".</front>
<front id="SdBaseFileCPP-1192"> *</front>
<front id="SdBaseFileCPP-1193"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1194"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1195"> * Reasons for failure include the file read-only, is a directory,</front>
<front id="SdBaseFileCPP-1196"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1197"> */</front>
<front id="SdBaseFileCPP-1198">bool SdBaseFile::remove() {</front>
<front id="SdBaseFileCPP-1199">  dir_t* d;</front>
<front id="SdBaseFileCPP-1200">  // free any clusters - will fail if read-only or directory</front>
<front id="SdBaseFileCPP-1201">  if (!truncate(0)) goto fail;</front>
<front id="SdBaseFileCPP-1202"></front>
<front id="SdBaseFileCPP-1203">  // cache directory entry</front>
<front id="SdBaseFileCPP-1204">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1205">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1206"></front>
<front id="SdBaseFileCPP-1207">  // mark entry deleted</front>
<front id="SdBaseFileCPP-1208">  d-&gt;name[0] = DIR_NAME_DELETED;</front>
<front id="SdBaseFileCPP-1209"></front>
<front id="SdBaseFileCPP-1210">  // set this file closed</front>
<front id="SdBaseFileCPP-1211">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-1212"></front>
<front id="SdBaseFileCPP-1213">  // write entry to SD</front>
<front id="SdBaseFileCPP-1214">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1215">  return true;</front>
<front id="SdBaseFileCPP-1216"></front>
<front id="SdBaseFileCPP-1217"> fail:</front>
<front id="SdBaseFileCPP-1218">  return false;</front>
<front id="SdBaseFileCPP-1219">}</front>
<front id="SdBaseFileCPP-1220">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1221">/** Remove a file.</front>
<front id="SdBaseFileCPP-1222"> *</front>
<front id="SdBaseFileCPP-1223"> * The directory entry and all data for the file are deleted.</front>
<front id="SdBaseFileCPP-1224"> *</front>
<front id="SdBaseFileCPP-1225"> * \param[in] dirFile The directory that contains the file.</front>
<front id="SdBaseFileCPP-1226"> * \param[in] path Path for the file to be removed.</front>
<front id="SdBaseFileCPP-1227"> *</front>
<front id="SdBaseFileCPP-1228"> * \note This function should not be used to delete the 8.3 version of a</front>
<front id="SdBaseFileCPP-1229"> * file that has a long name. For example if a file has the long name</front>
<front id="SdBaseFileCPP-1230"> * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".</front>
<front id="SdBaseFileCPP-1231"> *</front>
<front id="SdBaseFileCPP-1232"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1233"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1234"> * Reasons for failure include the file is a directory, is read only,</front>
<front id="SdBaseFileCPP-1235"> * \a dirFile is not a directory, \a path is not found</front>
<front id="SdBaseFileCPP-1236"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1237"> */</front>
<front id="SdBaseFileCPP-1238">bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {</front>
<front id="SdBaseFileCPP-1239">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-1240">  if (!file.open(dirFile, path, O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1241">  return file.remove();</front>
<front id="SdBaseFileCPP-1242"></front>
<front id="SdBaseFileCPP-1243"> fail:</front>
<front id="SdBaseFileCPP-1244">  // can't set iostate - static function</front>
<front id="SdBaseFileCPP-1245">  return false;</front>
<front id="SdBaseFileCPP-1246">}</front>
<front id="SdBaseFileCPP-1247">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1248">/** Rename a file or subdirectory.</front>
<front id="SdBaseFileCPP-1249"> *</front>
<front id="SdBaseFileCPP-1250"> * \param[in] dirFile Directory for the new path.</front>
<front id="SdBaseFileCPP-1251"> * \param[in] newPath New path name for the file/directory.</front>
<front id="SdBaseFileCPP-1252"> *</front>
<front id="SdBaseFileCPP-1253"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1254"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1255"> * Reasons for failure include \a dirFile is not open or is not a directory</front>
<front id="SdBaseFileCPP-1256"> * file, newPath is invalid or already exists, or an I/O error occurs.</front>
<front id="SdBaseFileCPP-1257"> */</front>
<front id="SdBaseFileCPP-1258">bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {</front>
<front id="SdBaseFileCPP-1259">  dir_t entry;</front>
<front id="SdBaseFileCPP-1260">  uint32_t dirCluster = 0;</front>
<front id="SdBaseFileCPP-1261">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-1262">  dir_t* d;</front>
<front id="SdBaseFileCPP-1263"></front>
<front id="SdBaseFileCPP-1264">  // must be an open file or subdirectory</front>
<front id="SdBaseFileCPP-1265">  if (!(isFile() || isSubDir())) goto fail;</front>
<front id="SdBaseFileCPP-1266"></front>
<front id="SdBaseFileCPP-1267">  // can't move file</front>
<front id="SdBaseFileCPP-1268">  if (vol_ != dirFile-&gt;vol_) goto fail;</front>
<front id="SdBaseFileCPP-1269"></front>
<front id="SdBaseFileCPP-1270">  // sync() and cache directory entry</front>
<front id="SdBaseFileCPP-1271">  sync();</front>
<front id="SdBaseFileCPP-1272">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1273">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1274"></front>
<front id="SdBaseFileCPP-1275">  // save directory entry</front>
<front id="SdBaseFileCPP-1276">  memcpy(&entry, d, sizeof(entry));</front>
<front id="SdBaseFileCPP-1277"></front>
<front id="SdBaseFileCPP-1278">  // mark entry deleted</front>
<front id="SdBaseFileCPP-1279">  d-&gt;name[0] = DIR_NAME_DELETED;</front>
<front id="SdBaseFileCPP-1280"></front>
<front id="SdBaseFileCPP-1281">  // make directory entry for new path</front>
<front id="SdBaseFileCPP-1282">  if (isFile()) {</front>
<front id="SdBaseFileCPP-1283">    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {</front>
<front id="SdBaseFileCPP-1284">      goto restore;</front>
<front id="SdBaseFileCPP-1285">    }</front>
<front id="SdBaseFileCPP-1286">  } else {</front>
<front id="SdBaseFileCPP-1287">    // don't create missing path prefix components</front>
<front id="SdBaseFileCPP-1288">    if (!file.mkdir(dirFile, newPath, false)) {</front>
<front id="SdBaseFileCPP-1289">      goto restore;</front>
<front id="SdBaseFileCPP-1290">    }</front>
<front id="SdBaseFileCPP-1291">    // save cluster containing new dot dot</front>
<front id="SdBaseFileCPP-1292">    dirCluster = file.firstCluster_;</front>
<front id="SdBaseFileCPP-1293">  }</front>
<front id="SdBaseFileCPP-1294">  // change to new directory entry</front>
<front id="SdBaseFileCPP-1295">  dirBlock_ = file.dirBlock_;</front>
<front id="SdBaseFileCPP-1296">  dirIndex_ = file.dirIndex_;</front>
<front id="SdBaseFileCPP-1297"></front>
<front id="SdBaseFileCPP-1298">  // mark closed to avoid possible destructor close call</front>
<front id="SdBaseFileCPP-1299">  file.type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-1300"></front>
<front id="SdBaseFileCPP-1301">  // cache new directory entry</front>
<front id="SdBaseFileCPP-1302">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1303">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1304"></front>
<front id="SdBaseFileCPP-1305">  // copy all but name field to new directory entry</front>
<front id="SdBaseFileCPP-1306">  memcpy(&d-&gt;attributes, &entry.attributes, sizeof(entry) - sizeof(d-&gt;name));</front>
<front id="SdBaseFileCPP-1307"></front>
<front id="SdBaseFileCPP-1308">  // update dot dot if directory</front>
<front id="SdBaseFileCPP-1309">  if (dirCluster) {</front>
<front id="SdBaseFileCPP-1310">    // get new dot dot</front>
<front id="SdBaseFileCPP-1311">    uint32_t block = vol_-&gt;clusterStartBlock(dirCluster);</front>
<front id="SdBaseFileCPP-1312">    if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1313">    memcpy(&entry, &vol_-&gt;cache()-&gt;dir[1], sizeof(entry));</front>
<front id="SdBaseFileCPP-1314"></front>
<front id="SdBaseFileCPP-1315">    // free unused cluster</front>
<front id="SdBaseFileCPP-1316">    if (!vol_-&gt;freeChain(dirCluster)) goto fail;</front>
<front id="SdBaseFileCPP-1317"></front>
<front id="SdBaseFileCPP-1318">    // store new dot dot</front>
<front id="SdBaseFileCPP-1319">    block = vol_-&gt;clusterStartBlock(firstCluster_);</front>
<front id="SdBaseFileCPP-1320">    if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1321">    memcpy(&vol_-&gt;cache()-&gt;dir[1], &entry, sizeof(entry));</front>
<front id="SdBaseFileCPP-1322">  }</front>
<front id="SdBaseFileCPP-1323">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1324"></front>
<front id="SdBaseFileCPP-1325"> restore:</front>
<front id="SdBaseFileCPP-1326">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1327">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1328">  // restore entry</front>
<front id="SdBaseFileCPP-1329">  d-&gt;name[0] = entry.name[0];</front>
<front id="SdBaseFileCPP-1330">  vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1331"></front>
<front id="SdBaseFileCPP-1332"> fail:</front>
<front id="SdBaseFileCPP-1333">  return false;</front>
<front id="SdBaseFileCPP-1334">}</front>
<front id="SdBaseFileCPP-1335">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1336">/** Remove a directory file.</front>
<front id="SdBaseFileCPP-1337"> *</front>
<front id="SdBaseFileCPP-1338"> * The directory file will be removed only if it is empty and is not the</front>
<front id="SdBaseFileCPP-1339"> * root directory.  rmdir() follows DOS and Windows and ignores the</front>
<front id="SdBaseFileCPP-1340"> * read-only attribute for the directory.</front>
<front id="SdBaseFileCPP-1341"> *</front>
<front id="SdBaseFileCPP-1342"> * \note This function should not be used to delete the 8.3 version of a</front>
<front id="SdBaseFileCPP-1343"> * directory that has a long name. For example if a directory has the</front>
<front id="SdBaseFileCPP-1344"> * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".</front>
<front id="SdBaseFileCPP-1345"> *</front>
<front id="SdBaseFileCPP-1346"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1347"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1348"> * Reasons for failure include the file is not a directory, is the root</front>
<front id="SdBaseFileCPP-1349"> * directory, is not empty, or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1350"> */</front>
<front id="SdBaseFileCPP-1351">bool SdBaseFile::rmdir() {</front>
<front id="SdBaseFileCPP-1352">  // must be open subdirectory</front>
<front id="SdBaseFileCPP-1353">  if (!isSubDir()) goto fail;</front>
<front id="SdBaseFileCPP-1354"></front>
<front id="SdBaseFileCPP-1355">  rewind();</front>
<front id="SdBaseFileCPP-1356"></front>
<front id="SdBaseFileCPP-1357">  // make sure directory is empty</front>
<front id="SdBaseFileCPP-1358">  while (curPosition_ &lt; fileSize_) {</front>
<front id="SdBaseFileCPP-1359">    dir_t* p = readDirCache();</front>
<front id="SdBaseFileCPP-1360">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-1361">    // done if past last used entry</front>
<front id="SdBaseFileCPP-1362">    if (p-&gt;name[0] == DIR_NAME_FREE) break;</front>
<front id="SdBaseFileCPP-1363">    // skip empty slot, '.' or '..'</front>
<front id="SdBaseFileCPP-1364">    if (p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') continue;</front>
<front id="SdBaseFileCPP-1365">    // error not empty</front>
<front id="SdBaseFileCPP-1366">    if (DIR_IS_FILE_OR_SUBDIR(p)) goto fail;</front>
<front id="SdBaseFileCPP-1367">  }</front>
<front id="SdBaseFileCPP-1368">  // convert empty directory to normal file for remove</front>
<front id="SdBaseFileCPP-1369">  type_ = FAT_FILE_TYPE_NORMAL;</front>
<front id="SdBaseFileCPP-1370">  flags_ |= O_WRITE;</front>
<front id="SdBaseFileCPP-1371">  return remove();</front>
<front id="SdBaseFileCPP-1372"></front>
<front id="SdBaseFileCPP-1373"> fail:</front>
<front id="SdBaseFileCPP-1374">  return false;</front>
<front id="SdBaseFileCPP-1375">}</front>
<front id="SdBaseFileCPP-1376">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1377">/** Recursively delete a directory and all contained files.</front>
<front id="SdBaseFileCPP-1378"> *</front>
<front id="SdBaseFileCPP-1379"> * This is like the Unix/Linux 'rm -rf *' if called with the root directory</front>
<front id="SdBaseFileCPP-1380"> * hence the name.</front>
<front id="SdBaseFileCPP-1381"> *</front>
<front id="SdBaseFileCPP-1382"> * Warning - This will remove all contents of the directory including</front>
<front id="SdBaseFileCPP-1383"> * subdirectories.  The directory will then be removed if it is not root.</front>
<front id="SdBaseFileCPP-1384"> * The read-only attribute for files will be ignored.</front>
<front id="SdBaseFileCPP-1385"> *</front>
<front id="SdBaseFileCPP-1386"> * \note This function should not be used to delete the 8.3 version of</front>
<front id="SdBaseFileCPP-1387"> * a directory that has a long name.  See remove() and rmdir().</front>
<front id="SdBaseFileCPP-1388"> *</front>
<front id="SdBaseFileCPP-1389"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1390"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1391"> */</front>
<front id="SdBaseFileCPP-1392">bool SdBaseFile::rmRfStar() {</front>
<front id="SdBaseFileCPP-1393">  uint16_t index;</front>
<front id="SdBaseFileCPP-1394">  SdBaseFile f;</front>
<front id="SdBaseFileCPP-1395">  rewind();</front>
<front id="SdBaseFileCPP-1396">  while (curPosition_ &lt; fileSize_) {</front>
<front id="SdBaseFileCPP-1397">    // remember position</front>
<front id="SdBaseFileCPP-1398">    index = curPosition_/32;</front>
<front id="SdBaseFileCPP-1399"></front>
<front id="SdBaseFileCPP-1400">    dir_t* p = readDirCache();</front>
<front id="SdBaseFileCPP-1401">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-1402"></front>
<front id="SdBaseFileCPP-1403">    // done if past last entry</front>
<front id="SdBaseFileCPP-1404">    if (p-&gt;name[0] == DIR_NAME_FREE) break;</front>
<front id="SdBaseFileCPP-1405"></front>
<front id="SdBaseFileCPP-1406">    // skip empty slot or '.' or '..'</front>
<front id="SdBaseFileCPP-1407">    if (p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') continue;</front>
<front id="SdBaseFileCPP-1408"></front>
<front id="SdBaseFileCPP-1409">    // skip if part of long file name or volume label in root</front>
<front id="SdBaseFileCPP-1410">    if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;</front>
<front id="SdBaseFileCPP-1411"></front>
<front id="SdBaseFileCPP-1412">    if (!f.open(this, index, O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1413">    if (f.isSubDir()) {</front>
<front id="SdBaseFileCPP-1414">      // recursively delete</front>
<front id="SdBaseFileCPP-1415">      if (!f.rmRfStar()) goto fail;</front>
<front id="SdBaseFileCPP-1416">    } else {</front>
<front id="SdBaseFileCPP-1417">      // ignore read-only</front>
<front id="SdBaseFileCPP-1418">      f.flags_ |= O_WRITE;</front>
<front id="SdBaseFileCPP-1419">      if (!f.remove()) goto fail;</front>
<front id="SdBaseFileCPP-1420">    }</front>
<front id="SdBaseFileCPP-1421">    // position to next entry if required</front>
<front id="SdBaseFileCPP-1422">    if (curPosition_ != (32*(index + 1))) {</front>
<front id="SdBaseFileCPP-1423">      if (!seekSet(32*(index + 1))) goto fail;</front>
<front id="SdBaseFileCPP-1424">    }</front>
<front id="SdBaseFileCPP-1425">  }</front>
<front id="SdBaseFileCPP-1426">  // don't try to delete root</front>
<front id="SdBaseFileCPP-1427">  if (!isRoot()) {</front>
<front id="SdBaseFileCPP-1428">    if (!rmdir()) goto fail;</front>
<front id="SdBaseFileCPP-1429">  }</front>
<front id="SdBaseFileCPP-1430">  return true;</front>
<front id="SdBaseFileCPP-1431"></front>
<front id="SdBaseFileCPP-1432"> fail:</front>
<front id="SdBaseFileCPP-1433">  return false;</front>
<front id="SdBaseFileCPP-1434">}</front>
<front id="SdBaseFileCPP-1435">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1436">/**  Create a file object and open it in the current working directory.</front>
<front id="SdBaseFileCPP-1437"> *</front>
<front id="SdBaseFileCPP-1438"> * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileCPP-1439"> *</front>
<front id="SdBaseFileCPP-1440"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-1441"> * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).</front>
<front id="SdBaseFileCPP-1442"> */</front>
<front id="SdBaseFileCPP-1443">SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-1444">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-1445">  writeError = false;</front>
<front id="SdBaseFileCPP-1446">  open(path, oflag);</front>
<front id="SdBaseFileCPP-1447">}</front>
<front id="SdBaseFileCPP-1448">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1449">/** Sets a file's position.</front>
<front id="SdBaseFileCPP-1450"> *</front>
<front id="SdBaseFileCPP-1451"> * \param[in] pos The new position in bytes from the beginning of the file.</front>
<front id="SdBaseFileCPP-1452"> *</front>
<front id="SdBaseFileCPP-1453"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1454"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1455"> */</front>
<front id="SdBaseFileCPP-1456">bool SdBaseFile::seekSet(uint32_t pos) {</front>
<front id="SdBaseFileCPP-1457">  uint32_t nCur;</front>
<front id="SdBaseFileCPP-1458">  uint32_t nNew;</front>
<front id="SdBaseFileCPP-1459">  // error if file not open or seek past end of file</front>
<front id="SdBaseFileCPP-1460">  if (!isOpen() || pos &gt; fileSize_) goto fail;</front>
<front id="SdBaseFileCPP-1461"></front>
<front id="SdBaseFileCPP-1462">  if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {</front>
<front id="SdBaseFileCPP-1463">    curPosition_ = pos;</front>
<front id="SdBaseFileCPP-1464">    goto done;</front>
<front id="SdBaseFileCPP-1465">  }</front>
<front id="SdBaseFileCPP-1466">  if (pos == 0) {</front>
<front id="SdBaseFileCPP-1467">    // set position to start of file</front>
<front id="SdBaseFileCPP-1468">    curCluster_ = 0;</front>
<front id="SdBaseFileCPP-1469">    curPosition_ = 0;</front>
<front id="SdBaseFileCPP-1470">    goto done;</front>
<front id="SdBaseFileCPP-1471">  }</front>
<front id="SdBaseFileCPP-1472">  // calculate cluster index for cur and new position</front>
<front id="SdBaseFileCPP-1473">  nCur = (curPosition_ - 1) &gt;&gt; (vol_-&gt;clusterSizeShift_ + 9);</front>
<front id="SdBaseFileCPP-1474">  nNew = (pos - 1) &gt;&gt; (vol_-&gt;clusterSizeShift_ + 9);</front>
<front id="SdBaseFileCPP-1475"></front>
<front id="SdBaseFileCPP-1476">  if (nNew &lt; nCur || curPosition_ == 0) {</front>
<front id="SdBaseFileCPP-1477">    // must follow chain from first cluster</front>
<front id="SdBaseFileCPP-1478">    curCluster_ = firstCluster_;</front>
<front id="SdBaseFileCPP-1479">  } else {</front>
<front id="SdBaseFileCPP-1480">    // advance from curPosition</front>
<front id="SdBaseFileCPP-1481">    nNew -= nCur;</front>
<front id="SdBaseFileCPP-1482">  }</front>
<front id="SdBaseFileCPP-1483">  while (nNew--) {</front>
<front id="SdBaseFileCPP-1484">    if (!vol_-&gt;fatGet(curCluster_, &curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1485">  }</front>
<front id="SdBaseFileCPP-1486">  curPosition_ = pos;</front>
<front id="SdBaseFileCPP-1487"></front>
<front id="SdBaseFileCPP-1488"> done:</front>
<front id="SdBaseFileCPP-1489">  return true;</front>
<front id="SdBaseFileCPP-1490"></front>
<front id="SdBaseFileCPP-1491"> fail:</front>
<front id="SdBaseFileCPP-1492">  return false;</front>
<front id="SdBaseFileCPP-1493">}</front>
<front id="SdBaseFileCPP-1494">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1495">void SdBaseFile::setpos(fpos_t* pos) {</front>
<front id="SdBaseFileCPP-1496">  curPosition_ = pos-&gt;position;</front>
<front id="SdBaseFileCPP-1497">  curCluster_ = pos-&gt;cluster;</front>
<front id="SdBaseFileCPP-1498">}</front>
<front id="SdBaseFileCPP-1499">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1500">/** The sync() call causes all modified data and directory fields</front>
<front id="SdBaseFileCPP-1501"> * to be written to the storage device.</front>
<front id="SdBaseFileCPP-1502"> *</front>
<front id="SdBaseFileCPP-1503"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1504"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1505"> * Reasons for failure include a call to sync() before a file has been</front>
<front id="SdBaseFileCPP-1506"> * opened or an I/O error.</front>
<front id="SdBaseFileCPP-1507"> */</front>
<front id="SdBaseFileCPP-1508">bool SdBaseFile::sync() {</front>
<front id="SdBaseFileCPP-1509">  // only allow open files and directories</front>
<front id="SdBaseFileCPP-1510">  if (!isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-1511"></front>
<front id="SdBaseFileCPP-1512">  if (flags_ & F_FILE_DIR_DIRTY) {</front>
<front id="SdBaseFileCPP-1513">    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1514">    // check for deleted by another open file object</front>
<front id="SdBaseFileCPP-1515">    if (!d || d-&gt;name[0] == DIR_NAME_DELETED) goto fail;</front>
<front id="SdBaseFileCPP-1516"></front>
<front id="SdBaseFileCPP-1517">    // do not set filesize for dir files</front>
<front id="SdBaseFileCPP-1518">    if (!isDir()) d-&gt;fileSize = fileSize_;</front>
<front id="SdBaseFileCPP-1519"></front>
<front id="SdBaseFileCPP-1520">    // update first cluster fields</front>
<front id="SdBaseFileCPP-1521">    d-&gt;firstClusterLow = firstCluster_ & 0XFFFF;</front>
<front id="SdBaseFileCPP-1522">    d-&gt;firstClusterHigh = firstCluster_ &gt;&gt; 16;</front>
<front id="SdBaseFileCPP-1523"></front>
<front id="SdBaseFileCPP-1524">    // set modify time if user supplied a callback date/time function</front>
<front id="SdBaseFileCPP-1525">    if (dateTime_) {</front>
<front id="SdBaseFileCPP-1526">      dateTime_(&d-&gt;lastWriteDate, &d-&gt;lastWriteTime);</front>
<front id="SdBaseFileCPP-1527">      d-&gt;lastAccessDate = d-&gt;lastWriteDate;</front>
<front id="SdBaseFileCPP-1528">    }</front>
<front id="SdBaseFileCPP-1529">    // clear directory dirty</front>
<front id="SdBaseFileCPP-1530">    flags_ &= ~F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1531">  }</front>
<front id="SdBaseFileCPP-1532">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1533"></front>
<front id="SdBaseFileCPP-1534"> fail:</front>
<front id="SdBaseFileCPP-1535">  writeError = true;</front>
<front id="SdBaseFileCPP-1536">  return false;</front>
<front id="SdBaseFileCPP-1537">}</front>
<front id="SdBaseFileCPP-1538">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1539">/** Copy a file's timestamps</front>
<front id="SdBaseFileCPP-1540"> *</front>
<front id="SdBaseFileCPP-1541"> * \param[in] file File to copy timestamps from.</front>
<front id="SdBaseFileCPP-1542"> *</front>
<front id="SdBaseFileCPP-1543"> * \note</front>
<front id="SdBaseFileCPP-1544"> * Modify and access timestamps may be overwritten if a date time callback</front>
<front id="SdBaseFileCPP-1545"> * function has been set by dateTimeCallback().</front>
<front id="SdBaseFileCPP-1546"> *</front>
<front id="SdBaseFileCPP-1547"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1548"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1549"> */</front>
<front id="SdBaseFileCPP-1550">bool SdBaseFile::timestamp(SdBaseFile* file) {</front>
<front id="SdBaseFileCPP-1551">  dir_t* d;</front>
<front id="SdBaseFileCPP-1552">  dir_t dir;</front>
<front id="SdBaseFileCPP-1553"></front>
<front id="SdBaseFileCPP-1554">  // get timestamps</front>
<front id="SdBaseFileCPP-1555">  if (!file-&gt;dirEntry(&dir)) goto fail;</front>
<front id="SdBaseFileCPP-1556"></front>
<front id="SdBaseFileCPP-1557">  // update directory fields</front>
<front id="SdBaseFileCPP-1558">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1559"></front>
<front id="SdBaseFileCPP-1560">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1561">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1562"></front>
<front id="SdBaseFileCPP-1563">  // copy timestamps</front>
<front id="SdBaseFileCPP-1564">  d-&gt;lastAccessDate = dir.lastAccessDate;</front>
<front id="SdBaseFileCPP-1565">  d-&gt;creationDate = dir.creationDate;</front>
<front id="SdBaseFileCPP-1566">  d-&gt;creationTime = dir.creationTime;</front>
<front id="SdBaseFileCPP-1567">  d-&gt;creationTimeTenths = dir.creationTimeTenths;</front>
<front id="SdBaseFileCPP-1568">  d-&gt;lastWriteDate = dir.lastWriteDate;</front>
<front id="SdBaseFileCPP-1569">  d-&gt;lastWriteTime = dir.lastWriteTime;</front>
<front id="SdBaseFileCPP-1570"></front>
<front id="SdBaseFileCPP-1571">  // write back entry</front>
<front id="SdBaseFileCPP-1572">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1573"></front>
<front id="SdBaseFileCPP-1574"> fail:</front>
<front id="SdBaseFileCPP-1575">  return false;</front>
<front id="SdBaseFileCPP-1576">}</front>
<front id="SdBaseFileCPP-1577">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1578">/** Set a file's timestamps in its directory entry.</front>
<front id="SdBaseFileCPP-1579"> *</front>
<front id="SdBaseFileCPP-1580"> * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-1581"> * OR of flags from the following list</front>
<front id="SdBaseFileCPP-1582"> *</front>
<front id="SdBaseFileCPP-1583"> * T_ACCESS - Set the file's last access date.</front>
<front id="SdBaseFileCPP-1584"> *</front>
<front id="SdBaseFileCPP-1585"> * T_CREATE - Set the file's creation date and time.</front>
<front id="SdBaseFileCPP-1586"> *</front>
<front id="SdBaseFileCPP-1587"> * T_WRITE - Set the file's last write/modification date and time.</front>
<front id="SdBaseFileCPP-1588"> *</front>
<front id="SdBaseFileCPP-1589"> * \param[in] year Valid range 1980 - 2107 inclusive.</front>
<front id="SdBaseFileCPP-1590"> *</front>
<front id="SdBaseFileCPP-1591"> * \param[in] month Valid range 1 - 12 inclusive.</front>
<front id="SdBaseFileCPP-1592"> *</front>
<front id="SdBaseFileCPP-1593"> * \param[in] day Valid range 1 - 31 inclusive.</front>
<front id="SdBaseFileCPP-1594"> *</front>
<front id="SdBaseFileCPP-1595"> * \param[in] hour Valid range 0 - 23 inclusive.</front>
<front id="SdBaseFileCPP-1596"> *</front>
<front id="SdBaseFileCPP-1597"> * \param[in] minute Valid range 0 - 59 inclusive.</front>
<front id="SdBaseFileCPP-1598"> *</front>
<front id="SdBaseFileCPP-1599"> * \param[in] second Valid range 0 - 59 inclusive</front>
<front id="SdBaseFileCPP-1600"> *</front>
<front id="SdBaseFileCPP-1601"> * \note It is possible to set an invalid date since there is no check for</front>
<front id="SdBaseFileCPP-1602"> * the number of days in a month.</front>
<front id="SdBaseFileCPP-1603"> *</front>
<front id="SdBaseFileCPP-1604"> * \note</front>
<front id="SdBaseFileCPP-1605"> * Modify and access timestamps may be overwritten if a date time callback</front>
<front id="SdBaseFileCPP-1606"> * function has been set by dateTimeCallback().</front>
<front id="SdBaseFileCPP-1607"> *</front>
<front id="SdBaseFileCPP-1608"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1609"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1610"> */</front>
<front id="SdBaseFileCPP-1611">bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,</front>
<front id="SdBaseFileCPP-1612">         uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {</front>
<front id="SdBaseFileCPP-1613">  uint16_t dirDate;</front>
<front id="SdBaseFileCPP-1614">  uint16_t dirTime;</front>
<front id="SdBaseFileCPP-1615">  dir_t* d;</front>
<front id="SdBaseFileCPP-1616"></front>
<front id="SdBaseFileCPP-1617">  if (!isOpen()</front>
<front id="SdBaseFileCPP-1618">    || year &lt; 1980</front>
<front id="SdBaseFileCPP-1619">    || year &gt; 2107</front>
<front id="SdBaseFileCPP-1620">    || month &lt; 1</front>
<front id="SdBaseFileCPP-1621">    || month &gt; 12</front>
<front id="SdBaseFileCPP-1622">    || day &lt; 1</front>
<front id="SdBaseFileCPP-1623">    || day &gt; 31</front>
<front id="SdBaseFileCPP-1624">    || hour &gt; 23</front>
<front id="SdBaseFileCPP-1625">    || minute &gt; 59</front>
<front id="SdBaseFileCPP-1626">    || second &gt; 59) {</front>
<front id="SdBaseFileCPP-1627">      goto fail;</front>
<front id="SdBaseFileCPP-1628">  }</front>
<front id="SdBaseFileCPP-1629">  // update directory entry</front>
<front id="SdBaseFileCPP-1630">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1631"></front>
<front id="SdBaseFileCPP-1632">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1633">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1634"></front>
<front id="SdBaseFileCPP-1635">  dirDate = FAT_DATE(year, month, day);</front>
<front id="SdBaseFileCPP-1636">  dirTime = FAT_TIME(hour, minute, second);</front>
<front id="SdBaseFileCPP-1637">  if (flags & T_ACCESS) {</front>
<front id="SdBaseFileCPP-1638">    d-&gt;lastAccessDate = dirDate;</front>
<front id="SdBaseFileCPP-1639">  }</front>
<front id="SdBaseFileCPP-1640">  if (flags & T_CREATE) {</front>
<front id="SdBaseFileCPP-1641">    d-&gt;creationDate = dirDate;</front>
<front id="SdBaseFileCPP-1642">    d-&gt;creationTime = dirTime;</front>
<front id="SdBaseFileCPP-1643">    // seems to be units of 1/100 second not 1/10 as Microsoft states</front>
<front id="SdBaseFileCPP-1644">    d-&gt;creationTimeTenths = second & 1 ? 100 : 0;</front>
<front id="SdBaseFileCPP-1645">  }</front>
<front id="SdBaseFileCPP-1646">  if (flags & T_WRITE) {</front>
<front id="SdBaseFileCPP-1647">    d-&gt;lastWriteDate = dirDate;</front>
<front id="SdBaseFileCPP-1648">    d-&gt;lastWriteTime = dirTime;</front>
<front id="SdBaseFileCPP-1649">  }</front>
<front id="SdBaseFileCPP-1650">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1651"></front>
<front id="SdBaseFileCPP-1652"> fail:</front>
<front id="SdBaseFileCPP-1653">  return false;</front>
<front id="SdBaseFileCPP-1654">}</front>
<front id="SdBaseFileCPP-1655">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1656">/** Truncate a file to a specified length.  The current file position</front>
<front id="SdBaseFileCPP-1657"> * will be maintained if it is less than or equal to \a length otherwise</front>
<front id="SdBaseFileCPP-1658"> * it will be set to end of file.</front>
<front id="SdBaseFileCPP-1659"> *</front>
<front id="SdBaseFileCPP-1660"> * \param[in] length The desired length for the file.</front>
<front id="SdBaseFileCPP-1661"> *</front>
<front id="SdBaseFileCPP-1662"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1663"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1664"> * Reasons for failure include file is read only, file is a directory,</front>
<front id="SdBaseFileCPP-1665"> * \a length is greater than the current file size or an I/O error occurs.</front>
<front id="SdBaseFileCPP-1666"> */</front>
<front id="SdBaseFileCPP-1667">bool SdBaseFile::truncate(uint32_t length) {</front>
<front id="SdBaseFileCPP-1668">  uint32_t newPos;</front>
<front id="SdBaseFileCPP-1669">  // error if not a normal file or read-only</front>
<front id="SdBaseFileCPP-1670">  if (!isFile() || !(flags_ & O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1671"></front>
<front id="SdBaseFileCPP-1672">  // error if length is greater than current size</front>
<front id="SdBaseFileCPP-1673">  if (length &gt; fileSize_) goto fail;</front>
<front id="SdBaseFileCPP-1674"></front>
<front id="SdBaseFileCPP-1675">  // fileSize and length are zero - nothing to do</front>
<front id="SdBaseFileCPP-1676">  if (fileSize_ == 0) return true;</front>
<front id="SdBaseFileCPP-1677"></front>
<front id="SdBaseFileCPP-1678">  // remember position for seek after truncation</front>
<front id="SdBaseFileCPP-1679">  newPos = curPosition_ &gt; length ? length : curPosition_;</front>
<front id="SdBaseFileCPP-1680"></front>
<front id="SdBaseFileCPP-1681">  // position to last cluster in truncated file</front>
<front id="SdBaseFileCPP-1682">  if (!seekSet(length)) goto fail;</front>
<front id="SdBaseFileCPP-1683"></front>
<front id="SdBaseFileCPP-1684">  if (length == 0) {</front>
<front id="SdBaseFileCPP-1685">    // free all clusters</front>
<front id="SdBaseFileCPP-1686">    if (!vol_-&gt;freeChain(firstCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1687">    firstCluster_ = 0;</front>
<front id="SdBaseFileCPP-1688">  } else {</front>
<front id="SdBaseFileCPP-1689">    uint32_t toFree;</front>
<front id="SdBaseFileCPP-1690">    if (!vol_-&gt;fatGet(curCluster_, &toFree)) goto fail;</front>
<front id="SdBaseFileCPP-1691"></front>
<front id="SdBaseFileCPP-1692">    if (!vol_-&gt;isEOC(toFree)) {</front>
<front id="SdBaseFileCPP-1693">      // free extra clusters</front>
<front id="SdBaseFileCPP-1694">      if (!vol_-&gt;freeChain(toFree)) goto fail;</front>
<front id="SdBaseFileCPP-1695"></front>
<front id="SdBaseFileCPP-1696">      // current cluster is end of chain</front>
<front id="SdBaseFileCPP-1697">      if (!vol_-&gt;fatPutEOC(curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1698">    }</front>
<front id="SdBaseFileCPP-1699">  }</front>
<front id="SdBaseFileCPP-1700">  fileSize_ = length;</front>
<front id="SdBaseFileCPP-1701"></front>
<front id="SdBaseFileCPP-1702">  // need to update directory entry</front>
<front id="SdBaseFileCPP-1703">  flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1704"></front>
<front id="SdBaseFileCPP-1705">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1706"></front>
<front id="SdBaseFileCPP-1707">  // set file to correct position</front>
<front id="SdBaseFileCPP-1708">  return seekSet(newPos);</front>
<front id="SdBaseFileCPP-1709"></front>
<front id="SdBaseFileCPP-1710"> fail:</front>
<front id="SdBaseFileCPP-1711">  return false;</front>
<front id="SdBaseFileCPP-1712">}</front>
<front id="SdBaseFileCPP-1713">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1714">/** Write data to an open file.</front>
<front id="SdBaseFileCPP-1715"> *</front>
<front id="SdBaseFileCPP-1716"> * \note Data is moved to the cache but may not be written to the</front>
<front id="SdBaseFileCPP-1717"> * storage device until sync() is called.</front>
<front id="SdBaseFileCPP-1718"> *</front>
<front id="SdBaseFileCPP-1719"> * \param[in] buf Pointer to the location of the data to be written.</front>
<front id="SdBaseFileCPP-1720"> *</front>
<front id="SdBaseFileCPP-1721"> * \param[in] nbyte Number of bytes to write.</front>
<front id="SdBaseFileCPP-1722"> *</front>
<front id="SdBaseFileCPP-1723"> * \return For success write() returns the number of bytes written, always</front>
<front id="SdBaseFileCPP-1724"> * \a nbyte.  If an error occurs, write() returns -1.  Possible errors</front>
<front id="SdBaseFileCPP-1725"> * include write() is called before a file has been opened, write is called</front>
<front id="SdBaseFileCPP-1726"> * for a read-only file, device is full, a corrupt file system or an I/O error.</front>
<front id="SdBaseFileCPP-1727"> *</front>
<front id="SdBaseFileCPP-1728"> */</front>
<front id="SdBaseFileCPP-1729">int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {</front>
<front id="SdBaseFileCPP-1730">  // convert void* to uint8_t*  -  must be before goto statements</front>
<front id="SdBaseFileCPP-1731">  const uint8_t* src = reinterpret_cast&lt;const uint8_t*&gt;(buf);</front>
<front id="SdBaseFileCPP-1732"></front>
<front id="SdBaseFileCPP-1733">  // number of bytes left to write  -  must be before goto statements</front>
<front id="SdBaseFileCPP-1734">  uint16_t nToWrite = nbyte;</front>
<front id="SdBaseFileCPP-1735"></front>
<front id="SdBaseFileCPP-1736">  // error if not a normal file or is read-only</front>
<front id="SdBaseFileCPP-1737">  if (!isFile() || !(flags_ & O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1738"></front>
<front id="SdBaseFileCPP-1739">  // seek to end of file if append flag</front>
<front id="SdBaseFileCPP-1740">  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {</front>
<front id="SdBaseFileCPP-1741">    if (!seekEnd()) goto fail;</front>
<front id="SdBaseFileCPP-1742">  }</front>
<front id="SdBaseFileCPP-1743"></front>
<front id="SdBaseFileCPP-1744">  while (nToWrite &gt; 0) {</front>
<front id="SdBaseFileCPP-1745">    uint8_t blockOfCluster = vol_-&gt;blockOfCluster(curPosition_);</front>
<front id="SdBaseFileCPP-1746">    uint16_t blockOffset = curPosition_ & 0X1FF;</front>
<front id="SdBaseFileCPP-1747">    if (blockOfCluster == 0 && blockOffset == 0) {</front>
<front id="SdBaseFileCPP-1748">      // start of new cluster</front>
<front id="SdBaseFileCPP-1749">      if (curCluster_ == 0) {</front>
<front id="SdBaseFileCPP-1750">        if (firstCluster_ == 0) {</front>
<front id="SdBaseFileCPP-1751">          // allocate first cluster of file</front>
<front id="SdBaseFileCPP-1752">          if (!addCluster()) goto fail;</front>
<front id="SdBaseFileCPP-1753">        } else {</front>
<front id="SdBaseFileCPP-1754">          curCluster_ = firstCluster_;</front>
<front id="SdBaseFileCPP-1755">        }</front>
<front id="SdBaseFileCPP-1756">      } else {</front>
<front id="SdBaseFileCPP-1757">        uint32_t next;</front>
<front id="SdBaseFileCPP-1758">        if (!vol_-&gt;fatGet(curCluster_, &next)) goto fail;</front>
<front id="SdBaseFileCPP-1759">        if (vol_-&gt;isEOC(next)) {</front>
<front id="SdBaseFileCPP-1760">          // add cluster if at end of chain</front>
<front id="SdBaseFileCPP-1761">          if (!addCluster()) goto fail;</front>
<front id="SdBaseFileCPP-1762">        } else {</front>
<front id="SdBaseFileCPP-1763">          curCluster_ = next;</front>
<front id="SdBaseFileCPP-1764">        }</front>
<front id="SdBaseFileCPP-1765">      }</front>
<front id="SdBaseFileCPP-1766">    }</front>
<front id="SdBaseFileCPP-1767">    // max space in block</front>
<front id="SdBaseFileCPP-1768">    uint16_t n = 512 - blockOffset;</front>
<front id="SdBaseFileCPP-1769"></front>
<front id="SdBaseFileCPP-1770">    // lesser of space and amount to write</front>
<front id="SdBaseFileCPP-1771">    if (n &gt; nToWrite) n = nToWrite;</front>
<front id="SdBaseFileCPP-1772"></front>
<front id="SdBaseFileCPP-1773">    // block for data write</front>
<front id="SdBaseFileCPP-1774">    uint32_t block = vol_-&gt;clusterStartBlock(curCluster_) + blockOfCluster;</front>
<front id="SdBaseFileCPP-1775">    if (n == 512) {</front>
<front id="SdBaseFileCPP-1776">      // full block - don't need to use cache</front>
<front id="SdBaseFileCPP-1777">      if (vol_-&gt;cacheBlockNumber() == block) {</front>
<front id="SdBaseFileCPP-1778">        // invalidate cache if block is in cache</front>
<front id="SdBaseFileCPP-1779">        vol_-&gt;cacheSetBlockNumber(0XFFFFFFFF, false);</front>
<front id="SdBaseFileCPP-1780">      }</front>
<front id="SdBaseFileCPP-1781">      if (!vol_-&gt;writeBlock(block, src)) goto fail;</front>
<front id="SdBaseFileCPP-1782">    } else {</front>
<front id="SdBaseFileCPP-1783">      if (blockOffset == 0 && curPosition_ &gt;= fileSize_) {</front>
<front id="SdBaseFileCPP-1784">        // start of new block don't need to read into cache</front>
<front id="SdBaseFileCPP-1785">        if (!vol_-&gt;cacheFlush()) goto fail;</front>
<front id="SdBaseFileCPP-1786">        // set cache dirty and SD address of block</front>
<front id="SdBaseFileCPP-1787">        vol_-&gt;cacheSetBlockNumber(block, true);</front>
<front id="SdBaseFileCPP-1788">      } else {</front>
<front id="SdBaseFileCPP-1789">        // rewrite part of block</front>
<front id="SdBaseFileCPP-1790">        if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1791">      }</front>
<front id="SdBaseFileCPP-1792">      uint8_t* dst = vol_-&gt;cache()-&gt;data + blockOffset;</front>
<front id="SdBaseFileCPP-1793">      memcpy(dst, src, n);</front>
<front id="SdBaseFileCPP-1794">    }</front>
<front id="SdBaseFileCPP-1795">    curPosition_ += n;</front>
<front id="SdBaseFileCPP-1796">    src += n;</front>
<front id="SdBaseFileCPP-1797">    nToWrite -= n;</front>
<front id="SdBaseFileCPP-1798">  }</front>
<front id="SdBaseFileCPP-1799">  if (curPosition_ &gt; fileSize_) {</front>
<front id="SdBaseFileCPP-1800">    // update fileSize and insure sync will update dir entry</front>
<front id="SdBaseFileCPP-1801">    fileSize_ = curPosition_;</front>
<front id="SdBaseFileCPP-1802">    flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1803">  } else if (dateTime_ && nbyte) {</front>
<front id="SdBaseFileCPP-1804">    // insure sync will update modified date and time</front>
<front id="SdBaseFileCPP-1805">    flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1806">  }</front>
<front id="SdBaseFileCPP-1807"></front>
<front id="SdBaseFileCPP-1808">  if (flags_ & O_SYNC) {</front>
<front id="SdBaseFileCPP-1809">    if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1810">  }</front>
<front id="SdBaseFileCPP-1811">  return nbyte;</front>
<front id="SdBaseFileCPP-1812"></front>
<front id="SdBaseFileCPP-1813"> fail:</front>
<front id="SdBaseFileCPP-1814">  // return for write error</front>
<front id="SdBaseFileCPP-1815">  writeError = true;</front>
<front id="SdBaseFileCPP-1816">  return -1;</front>
<front id="SdBaseFileCPP-1817">}</front>
<front id="SdBaseFileCPP-1818">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1819">// suppress cpplint warnings with NOLINT comment</front>
<front id="SdBaseFileCPP-1820">#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)</front>
<front id="SdBaseFileCPP-1821">void (*SdBaseFile::oldDateTime_)(uint16_t& date, uint16_t& time) = 0;  // NOLINT</front>
<front id="SdBaseFileCPP-1822">#endif  // ALLOW_DEPRECATED_FUNCTIONS</front>
<front id="SdBaseFileCPP-1823"></front>
<front id="SdBaseFileCPP-1824"></front>
<front id="SdBaseFileCPP-1825">#endif</front>
 </pre>
<h1>SdBaseFile.h</h1>
<pre  class="prettyprint linenums"><front id="SdBaseFileH-1">/* Arduino SdFat Library</front>
<front id="SdBaseFileH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdBaseFileH-3"> *</front>
<front id="SdBaseFileH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdBaseFileH-5"> *</front>
<front id="SdBaseFileH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdBaseFileH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdBaseFileH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdBaseFileH-9"> * (at your option) any later version.</front>
<front id="SdBaseFileH-10"> *</front>
<front id="SdBaseFileH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdBaseFileH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdBaseFileH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdBaseFileH-14"> * GNU General Public License for more details.</front>
<front id="SdBaseFileH-15"> *</front>
<front id="SdBaseFileH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdBaseFileH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdBaseFileH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdBaseFileH-19"> */</front>
<front id="SdBaseFileH-20">#include "Marlin.h"</front>
<front id="SdBaseFileH-21">#ifdef SDSUPPORT</front>
<front id="SdBaseFileH-22"></front>
<front id="SdBaseFileH-23">#ifndef SdBaseFile_h</front>
<front id="SdBaseFileH-24">#define SdBaseFile_h</front>
<front id="SdBaseFileH-25">/**</front>
<front id="SdBaseFileH-26"> * \file</front>
<front id="SdBaseFileH-27"> * \brief SdBaseFile class</front>
<front id="SdBaseFileH-28"> */</front>
<front id="SdBaseFileH-29">#include "Marlin.h"</front>
<front id="SdBaseFileH-30">#include "SdFatConfig.h"</front>
<front id="SdBaseFileH-31">#include "SdVolume.h"</front>
<front id="SdBaseFileH-32">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-33">/**</front>
<front id="SdBaseFileH-34"> * \struct fpos_t</front>
<front id="SdBaseFileH-35"> * \brief internal type for istream</front>
<front id="SdBaseFileH-36"> * do not use in user apps</front>
<front id="SdBaseFileH-37"> */</front>
<front id="SdBaseFileH-38">struct fpos_t {</front>
<front id="SdBaseFileH-39">  /** stream position */</front>
<front id="SdBaseFileH-40">  uint32_t position;</front>
<front id="SdBaseFileH-41">  /** cluster for position */</front>
<front id="SdBaseFileH-42">  uint32_t cluster;</front>
<front id="SdBaseFileH-43">  fpos_t() : position(0), cluster(0) {}</front>
<front id="SdBaseFileH-44">};</front>
<front id="SdBaseFileH-45"></front>
<front id="SdBaseFileH-46">// use the gnu style oflag in open()</front>
<front id="SdBaseFileH-47">/** open() oflag for reading */</front>
<front id="SdBaseFileH-48">uint8_t const O_READ = 0X01;</front>
<front id="SdBaseFileH-49">/** open() oflag - same as O_IN */</front>
<front id="SdBaseFileH-50">uint8_t const O_RDONLY = O_READ;</front>
<front id="SdBaseFileH-51">/** open() oflag for write */</front>
<front id="SdBaseFileH-52">uint8_t const O_WRITE = 0X02;</front>
<front id="SdBaseFileH-53">/** open() oflag - same as O_WRITE */</front>
<front id="SdBaseFileH-54">uint8_t const O_WRONLY = O_WRITE;</front>
<front id="SdBaseFileH-55">/** open() oflag for reading and writing */</front>
<front id="SdBaseFileH-56">uint8_t const O_RDWR = (O_READ | O_WRITE);</front>
<front id="SdBaseFileH-57">/** open() oflag mask for access modes */</front>
<front id="SdBaseFileH-58">uint8_t const O_ACCMODE = (O_READ | O_WRITE);</front>
<front id="SdBaseFileH-59">/** The file offset shall be set to the end of the file prior to each write. */</front>
<front id="SdBaseFileH-60">uint8_t const O_APPEND = 0X04;</front>
<front id="SdBaseFileH-61">/** synchronous writes - call sync() after each write */</front>
<front id="SdBaseFileH-62">uint8_t const O_SYNC = 0X08;</front>
<front id="SdBaseFileH-63">/** truncate the file to zero length */</front>
<front id="SdBaseFileH-64">uint8_t const O_TRUNC = 0X10;</front>
<front id="SdBaseFileH-65">/** set the initial position at the end of the file */</front>
<front id="SdBaseFileH-66">uint8_t const O_AT_END = 0X20;</front>
<front id="SdBaseFileH-67">/** create the file if nonexistent */</front>
<front id="SdBaseFileH-68">uint8_t const O_CREAT = 0X40;</front>
<front id="SdBaseFileH-69">/** If O_CREAT and O_EXCL are set, open() shall fail if the file exists */</front>
<front id="SdBaseFileH-70">uint8_t const O_EXCL = 0X80;</front>
<front id="SdBaseFileH-71"></front>
<front id="SdBaseFileH-72">// SdBaseFile class static and const definitions</front>
<front id="SdBaseFileH-73">// flags for ls()</front>
<front id="SdBaseFileH-74">/** ls() flag to print modify date */</front>
<front id="SdBaseFileH-75">uint8_t const LS_DATE = 1;</front>
<front id="SdBaseFileH-76">/** ls() flag to print file size */</front>
<front id="SdBaseFileH-77">uint8_t const LS_SIZE = 2;</front>
<front id="SdBaseFileH-78">/** ls() flag for recursive list of subdirectories */</front>
<front id="SdBaseFileH-79">uint8_t const LS_R = 4;</front>
<front id="SdBaseFileH-80"></front>
<front id="SdBaseFileH-81"></front>
<front id="SdBaseFileH-82">// flags for timestamp</front>
<front id="SdBaseFileH-83">/** set the file's last access date */</front>
<front id="SdBaseFileH-84">uint8_t const T_ACCESS = 1;</front>
<front id="SdBaseFileH-85">/** set the file's creation date and time */</front>
<front id="SdBaseFileH-86">uint8_t const T_CREATE = 2;</front>
<front id="SdBaseFileH-87">/** Set the file's write date and time */</front>
<front id="SdBaseFileH-88">uint8_t const T_WRITE = 4;</front>
<front id="SdBaseFileH-89">// values for type_</front>
<front id="SdBaseFileH-90">/** This file has not been opened. */</front>
<front id="SdBaseFileH-91">uint8_t const FAT_FILE_TYPE_CLOSED = 0;</front>
<front id="SdBaseFileH-92">/** A normal file */</front>
<front id="SdBaseFileH-93">uint8_t const FAT_FILE_TYPE_NORMAL = 1;</front>
<front id="SdBaseFileH-94">/** A FAT12 or FAT16 root directory */</front>
<front id="SdBaseFileH-95">uint8_t const FAT_FILE_TYPE_ROOT_FIXED = 2;</front>
<front id="SdBaseFileH-96">/** A FAT32 root directory */</front>
<front id="SdBaseFileH-97">uint8_t const FAT_FILE_TYPE_ROOT32 = 3;</front>
<front id="SdBaseFileH-98">/** A subdirectory file*/</front>
<front id="SdBaseFileH-99">uint8_t const FAT_FILE_TYPE_SUBDIR = 4;</front>
<front id="SdBaseFileH-100">/** Test value for directory type */</front>
<front id="SdBaseFileH-101">uint8_t const FAT_FILE_TYPE_MIN_DIR = FAT_FILE_TYPE_ROOT_FIXED;</front>
<front id="SdBaseFileH-102"></front>
<front id="SdBaseFileH-103">/** date field for FAT directory entry</front>
<front id="SdBaseFileH-104"> * \param[in] year [1980,2107]</front>
<front id="SdBaseFileH-105"> * \param[in] month [1,12]</front>
<front id="SdBaseFileH-106"> * \param[in] day [1,31]</front>
<front id="SdBaseFileH-107"> *</front>
<front id="SdBaseFileH-108"> * \return Packed date for dir_t entry.</front>
<front id="SdBaseFileH-109"> */</front>
<front id="SdBaseFileH-110">static inline uint16_t FAT_DATE(uint16_t year, uint8_t month, uint8_t day) {</front>
<front id="SdBaseFileH-111">  return (year - 1980) &lt;&lt; 9 | month &lt;&lt; 5 | day;</front>
<front id="SdBaseFileH-112">}</front>
<front id="SdBaseFileH-113">/** year part of FAT directory date field</front>
<front id="SdBaseFileH-114"> * \param[in] fatDate Date in packed dir format.</front>
<front id="SdBaseFileH-115"> *</front>
<front id="SdBaseFileH-116"> * \return Extracted year [1980,2107]</front>
<front id="SdBaseFileH-117"> */</front>
<front id="SdBaseFileH-118">static inline uint16_t FAT_YEAR(uint16_t fatDate) {</front>
<front id="SdBaseFileH-119">  return 1980 + (fatDate &gt;&gt; 9);</front>
<front id="SdBaseFileH-120">}</front>
<front id="SdBaseFileH-121">/** month part of FAT directory date field</front>
<front id="SdBaseFileH-122"> * \param[in] fatDate Date in packed dir format.</front>
<front id="SdBaseFileH-123"> *</front>
<front id="SdBaseFileH-124"> * \return Extracted month [1,12]</front>
<front id="SdBaseFileH-125"> */</front>
<front id="SdBaseFileH-126">static inline uint8_t FAT_MONTH(uint16_t fatDate) {</front>
<front id="SdBaseFileH-127">  return (fatDate &gt;&gt; 5) & 0XF;</front>
<front id="SdBaseFileH-128">}</front>
<front id="SdBaseFileH-129">/** day part of FAT directory date field</front>
<front id="SdBaseFileH-130"> * \param[in] fatDate Date in packed dir format.</front>
<front id="SdBaseFileH-131"> *</front>
<front id="SdBaseFileH-132"> * \return Extracted day [1,31]</front>
<front id="SdBaseFileH-133"> */</front>
<front id="SdBaseFileH-134">static inline uint8_t FAT_DAY(uint16_t fatDate) {</front>
<front id="SdBaseFileH-135">  return fatDate & 0X1F;</front>
<front id="SdBaseFileH-136">}</front>
<front id="SdBaseFileH-137">/** time field for FAT directory entry</front>
<front id="SdBaseFileH-138"> * \param[in] hour [0,23]</front>
<front id="SdBaseFileH-139"> * \param[in] minute [0,59]</front>
<front id="SdBaseFileH-140"> * \param[in] second [0,59]</front>
<front id="SdBaseFileH-141"> *</front>
<front id="SdBaseFileH-142"> * \return Packed time for dir_t entry.</front>
<front id="SdBaseFileH-143"> */</front>
<front id="SdBaseFileH-144">static inline uint16_t FAT_TIME(uint8_t hour, uint8_t minute, uint8_t second) {</front>
<front id="SdBaseFileH-145">  return hour &lt;&lt; 11 | minute &lt;&lt; 5 | second &gt;&gt; 1;</front>
<front id="SdBaseFileH-146">}</front>
<front id="SdBaseFileH-147">/** hour part of FAT directory time field</front>
<front id="SdBaseFileH-148"> * \param[in] fatTime Time in packed dir format.</front>
<front id="SdBaseFileH-149"> *</front>
<front id="SdBaseFileH-150"> * \return Extracted hour [0,23]</front>
<front id="SdBaseFileH-151"> */</front>
<front id="SdBaseFileH-152">static inline uint8_t FAT_HOUR(uint16_t fatTime) {</front>
<front id="SdBaseFileH-153">  return fatTime &gt;&gt; 11;</front>
<front id="SdBaseFileH-154">}</front>
<front id="SdBaseFileH-155">/** minute part of FAT directory time field</front>
<front id="SdBaseFileH-156"> * \param[in] fatTime Time in packed dir format.</front>
<front id="SdBaseFileH-157"> *</front>
<front id="SdBaseFileH-158"> * \return Extracted minute [0,59]</front>
<front id="SdBaseFileH-159"> */</front>
<front id="SdBaseFileH-160">static inline uint8_t FAT_MINUTE(uint16_t fatTime) {</front>
<front id="SdBaseFileH-161">  return(fatTime &gt;&gt; 5) & 0X3F;</front>
<front id="SdBaseFileH-162">}</front>
<front id="SdBaseFileH-163">/** second part of FAT directory time field</front>
<front id="SdBaseFileH-164"> * Note second/2 is stored in packed time.</front>
<front id="SdBaseFileH-165"> *</front>
<front id="SdBaseFileH-166"> * \param[in] fatTime Time in packed dir format.</front>
<front id="SdBaseFileH-167"> *</front>
<front id="SdBaseFileH-168"> * \return Extracted second [0,58]</front>
<front id="SdBaseFileH-169"> */</front>
<front id="SdBaseFileH-170">static inline uint8_t FAT_SECOND(uint16_t fatTime) {</front>
<front id="SdBaseFileH-171">  return 2*(fatTime & 0X1F);</front>
<front id="SdBaseFileH-172">}</front>
<front id="SdBaseFileH-173">/** Default date for file timestamps is 1 Jan 2000 */</front>
<front id="SdBaseFileH-174">uint16_t const FAT_DEFAULT_DATE = ((2000 - 1980) &lt;&lt; 9) | (1 &lt;&lt; 5) | 1;</front>
<front id="SdBaseFileH-175">/** Default time for file timestamp is 1 am */</front>
<front id="SdBaseFileH-176">uint16_t const FAT_DEFAULT_TIME = (1 &lt;&lt; 11);</front>
<front id="SdBaseFileH-177">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-178">/**</front>
<front id="SdBaseFileH-179"> * \class SdBaseFile</front>
<front id="SdBaseFileH-180"> * \brief Base class for SdFile with Print and C++ streams.</front>
<front id="SdBaseFileH-181"> */</front>
<front id="SdBaseFileH-182">class SdBaseFile {</front>
<front id="SdBaseFileH-183"> public:</front>
<front id="SdBaseFileH-184">  /** Create an instance. */</front>
<front id="SdBaseFileH-185">  SdBaseFile() : writeError(false), type_(FAT_FILE_TYPE_CLOSED) {}</front>
<front id="SdBaseFileH-186">  SdBaseFile(const char* path, uint8_t oflag);</front>
<front id="SdBaseFileH-187">  ~SdBaseFile() {if(isOpen()) close();}</front>
<front id="SdBaseFileH-188">  /**</front>
<front id="SdBaseFileH-189">   * writeError is set to true if an error occurs during a write().</front>
<front id="SdBaseFileH-190">   * Set writeError to false before calling print() and/or write() and check</front>
<front id="SdBaseFileH-191">   * for true after calls to print() and/or write().</front>
<front id="SdBaseFileH-192">   */</front>
<front id="SdBaseFileH-193">  bool writeError;</front>
<front id="SdBaseFileH-194">  //----------------------------------------------------------------------------</front>
<front id="SdBaseFileH-195">  // helpers for stream classes</front>
<front id="SdBaseFileH-196">  /** get position for streams</front>
<front id="SdBaseFileH-197">   * \param[out] pos struct to receive position</front>
<front id="SdBaseFileH-198">   */</front>
<front id="SdBaseFileH-199">  void getpos(fpos_t* pos);</front>
<front id="SdBaseFileH-200">  /** set position for streams</front>
<front id="SdBaseFileH-201">   * \param[out] pos struct with value for new position</front>
<front id="SdBaseFileH-202">   */</front>
<front id="SdBaseFileH-203">  void setpos(fpos_t* pos);</front>
<front id="SdBaseFileH-204">  //----------------------------------------------------------------------------</front>
<front id="SdBaseFileH-205">  bool close();</front>
<front id="SdBaseFileH-206">  bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);</front>
<front id="SdBaseFileH-207">  bool createContiguous(SdBaseFile* dirFile,</front>
<front id="SdBaseFileH-208">          const char* path, uint32_t size);</front>
<front id="SdBaseFileH-209">  /** \return The current cluster number for a file or directory. */</front>
<front id="SdBaseFileH-210">  uint32_t curCluster() const {return curCluster_;}</front>
<front id="SdBaseFileH-211">  /** \return The current position for a file or directory. */</front>
<front id="SdBaseFileH-212">  uint32_t curPosition() const {return curPosition_;}</front>
<front id="SdBaseFileH-213">  /** \return Current working directory */</front>
<front id="SdBaseFileH-214">  static SdBaseFile* cwd() {return cwd_;}</front>
<front id="SdBaseFileH-215">  /** Set the date/time callback function</front>
<front id="SdBaseFileH-216">   *</front>
<front id="SdBaseFileH-217">   * \param[in] dateTime The user's call back function.  The callback</front>
<front id="SdBaseFileH-218">   * function is of the form:</front>
<front id="SdBaseFileH-219">   *</front>
<front id="SdBaseFileH-220">   * \code</front>
<front id="SdBaseFileH-221">   * void dateTime(uint16_t* date, uint16_t* time) {</front>
<front id="SdBaseFileH-222">   *   uint16_t year;</front>
<front id="SdBaseFileH-223">   *   uint8_t month, day, hour, minute, second;</front>
<front id="SdBaseFileH-224">   *</front>
<front id="SdBaseFileH-225">   *   // User gets date and time from GPS or real-time clock here</front>
<front id="SdBaseFileH-226">   *</front>
<front id="SdBaseFileH-227">   *   // return date using FAT_DATE macro to format fields</front>
<front id="SdBaseFileH-228">   *   *date = FAT_DATE(year, month, day);</front>
<front id="SdBaseFileH-229">   *</front>
<front id="SdBaseFileH-230">   *   // return time using FAT_TIME macro to format fields</front>
<front id="SdBaseFileH-231">   *   *time = FAT_TIME(hour, minute, second);</front>
<front id="SdBaseFileH-232">   * }</front>
<front id="SdBaseFileH-233">   * \endcode</front>
<front id="SdBaseFileH-234">   *</front>
<front id="SdBaseFileH-235">   * Sets the function that is called when a file is created or when</front>
<front id="SdBaseFileH-236">   * a file's directory entry is modified by sync(). All timestamps,</front>
<front id="SdBaseFileH-237">   * access, creation, and modify, are set when a file is created.</front>
<front id="SdBaseFileH-238">   * sync() maintains the last access date and last modify date/time.</front>
<front id="SdBaseFileH-239">   *</front>
<front id="SdBaseFileH-240">   * See the timestamp() function.</front>
<front id="SdBaseFileH-241">   */</front>
<front id="SdBaseFileH-242">  static void dateTimeCallback(</front>
<front id="SdBaseFileH-243">    void (*dateTime)(uint16_t* date, uint16_t* time)) {</front>
<front id="SdBaseFileH-244">    dateTime_ = dateTime;</front>
<front id="SdBaseFileH-245">  }</front>
<front id="SdBaseFileH-246">  /**  Cancel the date/time callback function. */</front>
<front id="SdBaseFileH-247">  static void dateTimeCallbackCancel() {dateTime_ = 0;}</front>
<front id="SdBaseFileH-248">  bool dirEntry(dir_t* dir);</front>
<front id="SdBaseFileH-249">  static void dirName(const dir_t& dir, char* name);</front>
<front id="SdBaseFileH-250">  bool exists(const char* name);</front>
<front id="SdBaseFileH-251">  int16_t fgets(char* str, int16_t num, char* delim = 0);</front>
<front id="SdBaseFileH-252">  /** \return The total number of bytes in a file or directory. */</front>
<front id="SdBaseFileH-253">  uint32_t fileSize() const {return fileSize_;}</front>
<front id="SdBaseFileH-254">  /** \return The first cluster number for a file or directory. */</front>
<front id="SdBaseFileH-255">  uint32_t firstCluster() const {return firstCluster_;}</front>
<front id="SdBaseFileH-256">  bool getFilename(char* name);</front>
<front id="SdBaseFileH-257">  /** \return True if this is a directory else false. */</front>
<front id="SdBaseFileH-258">  bool isDir() const {return type_ &gt;= FAT_FILE_TYPE_MIN_DIR;}</front>
<front id="SdBaseFileH-259">  /** \return True if this is a normal file else false. */</front>
<front id="SdBaseFileH-260">  bool isFile() const {return type_ == FAT_FILE_TYPE_NORMAL;}</front>
<front id="SdBaseFileH-261">  /** \return True if this is an open file/directory else false. */</front>
<front id="SdBaseFileH-262">  bool isOpen() const {return type_ != FAT_FILE_TYPE_CLOSED;}</front>
<front id="SdBaseFileH-263">  /** \return True if this is a subdirectory else false. */</front>
<front id="SdBaseFileH-264">  bool isSubDir() const {return type_ == FAT_FILE_TYPE_SUBDIR;}</front>
<front id="SdBaseFileH-265">  /** \return True if this is the root directory. */</front>
<front id="SdBaseFileH-266">  bool isRoot() const {</front>
<front id="SdBaseFileH-267">    return type_ == FAT_FILE_TYPE_ROOT_FIXED || type_ == FAT_FILE_TYPE_ROOT32;</front>
<front id="SdBaseFileH-268">  }</front>
<front id="SdBaseFileH-269">  void ls( uint8_t flags = 0, uint8_t indent = 0);</front>
<front id="SdBaseFileH-270">  bool mkdir(SdBaseFile* dir, const char* path, bool pFlag = true);</front>
<front id="SdBaseFileH-271">  // alias for backward compactability</front>
<front id="SdBaseFileH-272">  bool makeDir(SdBaseFile* dir, const char* path) {</front>
<front id="SdBaseFileH-273">    return mkdir(dir, path, false);</front>
<front id="SdBaseFileH-274">  }</front>
<front id="SdBaseFileH-275">  bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);</front>
<front id="SdBaseFileH-276">  bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);</front>
<front id="SdBaseFileH-277">  bool open(const char* path, uint8_t oflag = O_READ);</front>
<front id="SdBaseFileH-278">  bool openNext(SdBaseFile* dirFile, uint8_t oflag);</front>
<front id="SdBaseFileH-279">  bool openRoot(SdVolume* vol);</front>
<front id="SdBaseFileH-280">  int peek();</front>
<front id="SdBaseFileH-281">  static void printFatDate(uint16_t fatDate);</front>
<front id="SdBaseFileH-282">  static void printFatTime( uint16_t fatTime);</front>
<front id="SdBaseFileH-283">  bool printName();</front>
<front id="SdBaseFileH-284">  int16_t read();</front>
<front id="SdBaseFileH-285">  int16_t read(void* buf, uint16_t nbyte);</front>
<front id="SdBaseFileH-286">  int8_t readDir(dir_t* dir, char* longFilename);</front>
<front id="SdBaseFileH-287">  static bool remove(SdBaseFile* dirFile, const char* path);</front>
<front id="SdBaseFileH-288">  bool remove();</front>
<front id="SdBaseFileH-289">  /** Set the file's current position to zero. */</front>
<front id="SdBaseFileH-290">  void rewind() {seekSet(0);}</front>
<front id="SdBaseFileH-291">  bool rename(SdBaseFile* dirFile, const char* newPath);</front>
<front id="SdBaseFileH-292">  bool rmdir();</front>
<front id="SdBaseFileH-293">  // for backward compatibility</front>
<front id="SdBaseFileH-294">  bool rmDir() {return rmdir();}</front>
<front id="SdBaseFileH-295">  bool rmRfStar();</front>
<front id="SdBaseFileH-296">  /** Set the files position to current position + \a pos. See seekSet().</front>
<front id="SdBaseFileH-297">   * \param[in] offset The new position in bytes from the current position.</front>
<front id="SdBaseFileH-298">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-299">   */</front>
<front id="SdBaseFileH-300">  bool seekCur(int32_t offset) {</front>
<front id="SdBaseFileH-301">    return seekSet(curPosition_ + offset);</front>
<front id="SdBaseFileH-302">  }</front>
<front id="SdBaseFileH-303">  /** Set the files position to end-of-file + \a offset. See seekSet().</front>
<front id="SdBaseFileH-304">   * \param[in] offset The new position in bytes from end-of-file.</front>
<front id="SdBaseFileH-305">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-306">   */</front>
<front id="SdBaseFileH-307">  bool seekEnd(int32_t offset = 0) {return seekSet(fileSize_ + offset);}</front>
<front id="SdBaseFileH-308">  bool seekSet(uint32_t pos);</front>
<front id="SdBaseFileH-309">  bool sync();</front>
<front id="SdBaseFileH-310">  bool timestamp(SdBaseFile* file);</front>
<front id="SdBaseFileH-311">  bool timestamp(uint8_t flag, uint16_t year, uint8_t month, uint8_t day,</front>
<front id="SdBaseFileH-312">          uint8_t hour, uint8_t minute, uint8_t second);</front>
<front id="SdBaseFileH-313">  /** Type of file.  You should use isFile() or isDir() instead of type()</front>
<front id="SdBaseFileH-314">   * if possible.</front>
<front id="SdBaseFileH-315">   *</front>
<front id="SdBaseFileH-316">   * \return The file or directory type.</front>
<front id="SdBaseFileH-317">   */</front>
<front id="SdBaseFileH-318">  uint8_t type() const {return type_;}</front>
<front id="SdBaseFileH-319">  bool truncate(uint32_t size);</front>
<front id="SdBaseFileH-320">  /** \return SdVolume that contains this file. */</front>
<front id="SdBaseFileH-321">  SdVolume* volume() const {return vol_;}</front>
<front id="SdBaseFileH-322">  int16_t write(const void* buf, uint16_t nbyte);</front>
<front id="SdBaseFileH-323">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-324"> private:</front>
<front id="SdBaseFileH-325">  // allow SdFat to set cwd_</front>
<front id="SdBaseFileH-326">  friend class SdFat;</front>
<front id="SdBaseFileH-327">  // global pointer to cwd dir</front>
<front id="SdBaseFileH-328">  static SdBaseFile* cwd_;</front>
<front id="SdBaseFileH-329">  // data time callback function</front>
<front id="SdBaseFileH-330">  static void (*dateTime_)(uint16_t* date, uint16_t* time);</front>
<front id="SdBaseFileH-331">  // bits defined in flags_</front>
<front id="SdBaseFileH-332">  // should be 0X0F</front>
<front id="SdBaseFileH-333">  static uint8_t const F_OFLAG = (O_ACCMODE | O_APPEND | O_SYNC);</front>
<front id="SdBaseFileH-334">  // sync of directory entry required</front>
<front id="SdBaseFileH-335">  static uint8_t const F_FILE_DIR_DIRTY = 0X80;</front>
<front id="SdBaseFileH-336"></front>
<front id="SdBaseFileH-337">  // private data</front>
<front id="SdBaseFileH-338">  uint8_t   flags_;         // See above for definition of flags_ bits</front>
<front id="SdBaseFileH-339">  uint8_t   fstate_;        // error and eof indicator</front>
<front id="SdBaseFileH-340">  uint8_t   type_;          // type of file see above for values</front>
<front id="SdBaseFileH-341">  uint32_t  curCluster_;    // cluster for current file position</front>
<front id="SdBaseFileH-342">  uint32_t  curPosition_;   // current file position in bytes from beginning</front>
<front id="SdBaseFileH-343">  uint32_t  dirBlock_;      // block for this files directory entry</front>
<front id="SdBaseFileH-344">  uint8_t   dirIndex_;      // index of directory entry in dirBlock</front>
<front id="SdBaseFileH-345">  uint32_t  fileSize_;      // file size in bytes</front>
<front id="SdBaseFileH-346">  uint32_t  firstCluster_;  // first cluster of file</front>
<front id="SdBaseFileH-347">  SdVolume* vol_;           // volume where file is located</front>
<front id="SdBaseFileH-348"></front>
<front id="SdBaseFileH-349">  /** experimental don't use */</front>
<front id="SdBaseFileH-350">  bool openParent(SdBaseFile* dir);</front>
<front id="SdBaseFileH-351">  // private functions</front>
<front id="SdBaseFileH-352">  bool addCluster();</front>
<front id="SdBaseFileH-353">  bool addDirCluster();</front>
<front id="SdBaseFileH-354">  dir_t* cacheDirEntry(uint8_t action);</front>
<front id="SdBaseFileH-355">  int8_t lsPrintNext( uint8_t flags, uint8_t indent);</front>
<front id="SdBaseFileH-356">  static bool make83Name(const char* str, uint8_t* name, const char** ptr);</front>
<front id="SdBaseFileH-357">  bool mkdir(SdBaseFile* parent, const uint8_t dname[11]);</front>
<front id="SdBaseFileH-358">  bool open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag);</front>
<front id="SdBaseFileH-359">  bool openCachedEntry(uint8_t cacheIndex, uint8_t oflags);</front>
<front id="SdBaseFileH-360">  dir_t* readDirCache();</front>
<front id="SdBaseFileH-361">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-362">// to be deleted</front>
<front id="SdBaseFileH-363">  static void printDirName( const dir_t& dir,</front>
<front id="SdBaseFileH-364">    uint8_t width, bool printSlash);</front>
<front id="SdBaseFileH-365">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-366">// Deprecated functions  - suppress cpplint warnings with NOLINT comment</front>
<front id="SdBaseFileH-367">#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)</front>
<front id="SdBaseFileH-368"> public:</front>
<front id="SdBaseFileH-369">  /** \deprecated Use:</front>
<front id="SdBaseFileH-370">   * bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);</front>
<front id="SdBaseFileH-371">   * \param[out] bgnBlock the first block address for the file.</front>
<front id="SdBaseFileH-372">   * \param[out] endBlock the last  block address for the file.</front>
<front id="SdBaseFileH-373">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-374">   */</front>
<front id="SdBaseFileH-375">  bool contiguousRange(uint32_t& bgnBlock, uint32_t& endBlock) {  // NOLINT</front>
<front id="SdBaseFileH-376">    return contiguousRange(&bgnBlock, &endBlock);</front>
<front id="SdBaseFileH-377">  }</front>
<front id="SdBaseFileH-378"> /** \deprecated Use:</front>
<front id="SdBaseFileH-379">   * bool createContiguous(SdBaseFile* dirFile,</front>
<front id="SdBaseFileH-380">   *   const char* path, uint32_t size)</front>
<front id="SdBaseFileH-381">   * \param[in] dirFile The directory where the file will be created.</front>
<front id="SdBaseFileH-382">   * \param[in] path A path with a valid DOS 8.3 file name.</front>
<front id="SdBaseFileH-383">   * \param[in] size The desired file size.</front>
<front id="SdBaseFileH-384">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-385">   */</front>
<front id="SdBaseFileH-386">  bool createContiguous(SdBaseFile& dirFile,  // NOLINT</front>
<front id="SdBaseFileH-387">    const char* path, uint32_t size) {</front>
<front id="SdBaseFileH-388">    return createContiguous(&dirFile, path, size);</front>
<front id="SdBaseFileH-389">  }</front>
<front id="SdBaseFileH-390">  /** \deprecated Use:</front>
<front id="SdBaseFileH-391">   * static void dateTimeCallback(</front>
<front id="SdBaseFileH-392">   *   void (*dateTime)(uint16_t* date, uint16_t* time));</front>
<front id="SdBaseFileH-393">   * \param[in] dateTime The user's call back function.</front>
<front id="SdBaseFileH-394">   */</front>
<front id="SdBaseFileH-395">  static void dateTimeCallback(</front>
<front id="SdBaseFileH-396">    void (*dateTime)(uint16_t& date, uint16_t& time)) {  // NOLINT</front>
<front id="SdBaseFileH-397">    oldDateTime_ = dateTime;</front>
<front id="SdBaseFileH-398">    dateTime_ = dateTime ? oldToNew : 0;</front>
<front id="SdBaseFileH-399">  }</front>
<front id="SdBaseFileH-400">  /** \deprecated Use: bool dirEntry(dir_t* dir);</front>
<front id="SdBaseFileH-401">   * \param[out] dir Location for return of the file's directory entry.</front>
<front id="SdBaseFileH-402">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-403">   */</front>
<front id="SdBaseFileH-404">  bool dirEntry(dir_t& dir) {return dirEntry(&dir);}  // NOLINT</front>
<front id="SdBaseFileH-405">  /** \deprecated Use:</front>
<front id="SdBaseFileH-406">   * bool mkdir(SdBaseFile* dir, const char* path);</front>
<front id="SdBaseFileH-407">   * \param[in] dir An open SdFat instance for the directory that will contain</front>
<front id="SdBaseFileH-408">   * the new directory.</front>
<front id="SdBaseFileH-409">   * \param[in] path A path with a valid 8.3 DOS name for the new directory.</front>
<front id="SdBaseFileH-410">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-411">   */</front>
<front id="SdBaseFileH-412">  bool mkdir(SdBaseFile& dir, const char* path) {  // NOLINT</front>
<front id="SdBaseFileH-413">    return mkdir(&dir, path);</front>
<front id="SdBaseFileH-414">  }</front>
<front id="SdBaseFileH-415">  /** \deprecated Use:</front>
<front id="SdBaseFileH-416">   * bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);</front>
<front id="SdBaseFileH-417">   * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileH-418">   * file to be opened.</front>
<front id="SdBaseFileH-419">   * \param[in] path A path with a valid 8.3 DOS name for the file.</front>
<front id="SdBaseFileH-420">   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileH-421">   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileH-422">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-423">   */</front>
<front id="SdBaseFileH-424">  bool open(SdBaseFile& dirFile, // NOLINT</front>
<front id="SdBaseFileH-425">    const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileH-426">    return open(&dirFile, path, oflag);</front>
<front id="SdBaseFileH-427">  }</front>
<front id="SdBaseFileH-428">  /** \deprecated  Do not use in new apps</front>
<front id="SdBaseFileH-429">   * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileH-430">   * file to be opened.</front>
<front id="SdBaseFileH-431">   * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileH-432">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-433">   */</front>
<front id="SdBaseFileH-434">  bool open(SdBaseFile& dirFile, const char* path) {  // NOLINT</front>
<front id="SdBaseFileH-435">    return open(dirFile, path, O_RDWR);</front>
<front id="SdBaseFileH-436">  }</front>
<front id="SdBaseFileH-437">  /** \deprecated Use:</front>
<front id="SdBaseFileH-438">   * bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);</front>
<front id="SdBaseFileH-439">   * \param[in] dirFile An open SdFat instance for the directory.</front>
<front id="SdBaseFileH-440">   * \param[in] index The \a index of the directory entry for the file to be</front>
<front id="SdBaseFileH-441">   * opened.  The value for \a index is (directory file position)/32.</front>
<front id="SdBaseFileH-442">   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileH-443">   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileH-444">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-445">   */</front>
<front id="SdBaseFileH-446">  bool open(SdBaseFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT</front>
<front id="SdBaseFileH-447">    return open(&dirFile, index, oflag);</front>
<front id="SdBaseFileH-448">  }</front>
<front id="SdBaseFileH-449">  /** \deprecated Use: bool openRoot(SdVolume* vol);</front>
<front id="SdBaseFileH-450">   * \param[in] vol The FAT volume containing the root directory to be opened.</front>
<front id="SdBaseFileH-451">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-452">   */</front>
<front id="SdBaseFileH-453">  bool openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT</front>
<front id="SdBaseFileH-454">  /** \deprecated Use: int8_t readDir(dir_t* dir);</front>
<front id="SdBaseFileH-455">   * \param[out] dir The dir_t struct that will receive the data.</front>
<front id="SdBaseFileH-456">   * \return bytes read for success zero for eof or -1 for failure.</front>
<front id="SdBaseFileH-457">   */</front>
<front id="SdBaseFileH-458">  int8_t readDir(dir_t& dir, char* longFilename) {return readDir(&dir, longFilename);}  // NOLINT</front>
<front id="SdBaseFileH-459">  /** \deprecated Use:</front>
<front id="SdBaseFileH-460">   * static uint8_t remove(SdBaseFile* dirFile, const char* path);</front>
<front id="SdBaseFileH-461">   * \param[in] dirFile The directory that contains the file.</front>
<front id="SdBaseFileH-462">   * \param[in] path The name of the file to be removed.</front>
<front id="SdBaseFileH-463">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-464">   */</front>
<front id="SdBaseFileH-465">  static bool remove(SdBaseFile& dirFile, const char* path) {  // NOLINT</front>
<front id="SdBaseFileH-466">    return remove(&dirFile, path);</front>
<front id="SdBaseFileH-467">  }</front>
<front id="SdBaseFileH-468">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-469">// rest are private</front>
<front id="SdBaseFileH-470"> private:</front>
<front id="SdBaseFileH-471">  static void (*oldDateTime_)(uint16_t& date, uint16_t& time);  // NOLINT</front>
<front id="SdBaseFileH-472">  static void oldToNew(uint16_t* date, uint16_t* time) {</front>
<front id="SdBaseFileH-473">    uint16_t d;</front>
<front id="SdBaseFileH-474">    uint16_t t;</front>
<front id="SdBaseFileH-475">    oldDateTime_(d, t);</front>
<front id="SdBaseFileH-476">    *date = d;</front>
<front id="SdBaseFileH-477">    *time = t;</front>
<front id="SdBaseFileH-478">  }</front>
<front id="SdBaseFileH-479">#endif  // ALLOW_DEPRECATED_FUNCTIONS</front>
<front id="SdBaseFileH-480">};</front>
<front id="SdBaseFileH-481"></front>
<front id="SdBaseFileH-482">#endif  // SdBaseFile_h</front>
<front id="SdBaseFileH-483">#endif</front>
 </pre>
<h1>SdFatConfig.h</h1>
<pre  class="prettyprint linenums"><front id="SdFatConfigH-1">/* Arduino SdFat Library</front>
<front id="SdFatConfigH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFatConfigH-3"> *</front>
<front id="SdFatConfigH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatConfigH-5"> *</front>
<front id="SdFatConfigH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatConfigH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatConfigH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatConfigH-9"> * (at your option) any later version.</front>
<front id="SdFatConfigH-10"> *</front>
<front id="SdFatConfigH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatConfigH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatConfigH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatConfigH-14"> * GNU General Public License for more details.</front>
<front id="SdFatConfigH-15"> *</front>
<front id="SdFatConfigH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatConfigH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatConfigH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatConfigH-19"> */</front>
<front id="SdFatConfigH-20">/**</front>
<front id="SdFatConfigH-21"> * \file</front>
<front id="SdFatConfigH-22"> * \brief configuration definitions</front>
<front id="SdFatConfigH-23"> */</front>
<front id="SdFatConfigH-24">#include "Marlin.h"</front>
<front id="SdFatConfigH-25">#ifdef SDSUPPORT</front>
<front id="SdFatConfigH-26"></front>
<front id="SdFatConfigH-27">#ifndef SdFatConfig_h</front>
<front id="SdFatConfigH-28">#define SdFatConfig_h</front>
<front id="SdFatConfigH-29">#include &lt;stdint.h&gt;</front>
<front id="SdFatConfigH-30">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-31">/**</front>
<front id="SdFatConfigH-32"> * To use multiple SD cards set USE_MULTIPLE_CARDS nonzero.</front>
<front id="SdFatConfigH-33"> *</front>
<front id="SdFatConfigH-34"> * Using multiple cards costs 400 - 500  bytes of flash.</front>
<front id="SdFatConfigH-35"> *</front>
<front id="SdFatConfigH-36"> * Each card requires about 550 bytes of SRAM so use of a Mega is recommended.</front>
<front id="SdFatConfigH-37"> */</front>
<front id="SdFatConfigH-38">#define USE_MULTIPLE_CARDS 0</front>
<front id="SdFatConfigH-39">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-40">/**</front>
<front id="SdFatConfigH-41"> * Call flush for endl if ENDL_CALLS_FLUSH is nonzero</front>
<front id="SdFatConfigH-42"> *</front>
<front id="SdFatConfigH-43"> * The standard for iostreams is to call flush.  This is very costly for</front>
<front id="SdFatConfigH-44"> * SdFat.  Each call to flush causes 2048 bytes of I/O to the SD.</front>
<front id="SdFatConfigH-45"> *</front>
<front id="SdFatConfigH-46"> * SdFat has a single 512 byte buffer for SD I/O so it must write the current</front>
<front id="SdFatConfigH-47"> * data block to the SD, read the directory block from the SD, update the</front>
<front id="SdFatConfigH-48"> * directory entry, write the directory block to the SD and read the data</front>
<front id="SdFatConfigH-49"> * block back into the buffer.</front>
<front id="SdFatConfigH-50"> *</front>
<front id="SdFatConfigH-51"> * The SD flash memory controller is not designed for this many rewrites</front>
<front id="SdFatConfigH-52"> * so performance may be reduced by more than a factor of 100.</front>
<front id="SdFatConfigH-53"> *</front>
<front id="SdFatConfigH-54"> * If ENDL_CALLS_FLUSH is zero, you must call flush and/or close to force</front>
<front id="SdFatConfigH-55"> * all data to be written to the SD.</front>
<front id="SdFatConfigH-56"> */</front>
<front id="SdFatConfigH-57">#define ENDL_CALLS_FLUSH 0</front>
<front id="SdFatConfigH-58">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-59">/**</front>
<front id="SdFatConfigH-60"> * Allow use of deprecated functions if ALLOW_DEPRECATED_FUNCTIONS is nonzero</front>
<front id="SdFatConfigH-61"> */</front>
<front id="SdFatConfigH-62">#define ALLOW_DEPRECATED_FUNCTIONS 1</front>
<front id="SdFatConfigH-63">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-64">/**</front>
<front id="SdFatConfigH-65"> * Allow FAT12 volumes if FAT12_SUPPORT is nonzero.</front>
<front id="SdFatConfigH-66"> * FAT12 has not been well tested.</front>
<front id="SdFatConfigH-67"> */</front>
<front id="SdFatConfigH-68">#define FAT12_SUPPORT 0</front>
<front id="SdFatConfigH-69">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-70">/**</front>
<front id="SdFatConfigH-71"> * SPI init rate for SD initialization commands. Must be 5 (F_CPU/64)</front>
<front id="SdFatConfigH-72"> * or 6 (F_CPU/128).</front>
<front id="SdFatConfigH-73"> */</front>
<front id="SdFatConfigH-74">#define SPI_SD_INIT_RATE 5</front>
<front id="SdFatConfigH-75">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-76">/**</front>
<front id="SdFatConfigH-77"> * Set the SS pin high for hardware SPI.  If SS is chip select for another SPI</front>
<front id="SdFatConfigH-78"> * device this will disable that device during the SD init phase.</front>
<front id="SdFatConfigH-79"> */</front>
<front id="SdFatConfigH-80">#define SET_SPI_SS_HIGH 1</front>
<front id="SdFatConfigH-81">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-82">/**</front>
<front id="SdFatConfigH-83"> * Define MEGA_SOFT_SPI nonzero to use software SPI on Mega Arduinos.</front>
<front id="SdFatConfigH-84"> * Pins used are SS 10, MOSI 11, MISO 12, and SCK 13.</front>
<front id="SdFatConfigH-85"> *</front>
<front id="SdFatConfigH-86"> * MEGA_SOFT_SPI allows an unmodified Adafruit GPS Shield to be used</front>
<front id="SdFatConfigH-87"> * on Mega Arduinos.  Software SPI works well with GPS Shield V1.1</front>
<front id="SdFatConfigH-88"> * but many SD cards will fail with GPS Shield V1.0.</front>
<front id="SdFatConfigH-89"> */</front>
<front id="SdFatConfigH-90">#define MEGA_SOFT_SPI 0</front>
<front id="SdFatConfigH-91">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-92">/**</front>
<front id="SdFatConfigH-93"> * Set USE_SOFTWARE_SPI nonzero to always use software SPI.</front>
<front id="SdFatConfigH-94"> */</front>
<front id="SdFatConfigH-95">#define USE_SOFTWARE_SPI 0</front>
<front id="SdFatConfigH-96">// define software SPI pins so Mega can use unmodified 168/328 shields</front>
<front id="SdFatConfigH-97">/** Software SPI chip select pin for the SD */</front>
<front id="SdFatConfigH-98">uint8_t const SOFT_SPI_CS_PIN = 10;</front>
<front id="SdFatConfigH-99">/** Software SPI Master Out Slave In pin */</front>
<front id="SdFatConfigH-100">uint8_t const SOFT_SPI_MOSI_PIN = 11;</front>
<front id="SdFatConfigH-101">/** Software SPI Master In Slave Out pin */</front>
<front id="SdFatConfigH-102">uint8_t const SOFT_SPI_MISO_PIN = 12;</front>
<front id="SdFatConfigH-103">/** Software SPI Clock pin */</front>
<front id="SdFatConfigH-104">uint8_t const SOFT_SPI_SCK_PIN = 13;</front>
<front id="SdFatConfigH-105">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-106">/**</front>
<front id="SdFatConfigH-107"> * The __cxa_pure_virtual function is an error handler that is invoked when</front>
<front id="SdFatConfigH-108"> * a pure virtual function is called.</front>
<front id="SdFatConfigH-109"> */</front>
<front id="SdFatConfigH-110">#define USE_CXA_PURE_VIRTUAL 1</front>
<front id="SdFatConfigH-111">/**</front>
<front id="SdFatConfigH-112"> * Defines for long (vfat) filenames</front>
<front id="SdFatConfigH-113"> */</front>
<front id="SdFatConfigH-114">/** Number of VFAT entries used. Every entry has 13 UTF-16 characters */</front>
<front id="SdFatConfigH-115">#define MAX_VFAT_ENTRIES (2)</front>
<front id="SdFatConfigH-116">/** Total size of the buffer used to store the long filenames */</front>
<front id="SdFatConfigH-117">#define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)</front>
<front id="SdFatConfigH-118">#endif  // SdFatConfig_h</front>
<front id="SdFatConfigH-119"></front>
<front id="SdFatConfigH-120"></front>
<front id="SdFatConfigH-121">#endif</front>
 </pre>
<h1>SdFatStructs.h</h1>
<pre  class="prettyprint linenums"><front id="SdFatStructsH-1">/* Arduino SdFat Library</front>
<front id="SdFatStructsH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFatStructsH-3"> *</front>
<front id="SdFatStructsH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatStructsH-5"> *</front>
<front id="SdFatStructsH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatStructsH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatStructsH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatStructsH-9"> * (at your option) any later version.</front>
<front id="SdFatStructsH-10"> *</front>
<front id="SdFatStructsH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatStructsH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatStructsH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatStructsH-14"> * GNU General Public License for more details.</front>
<front id="SdFatStructsH-15"> *</front>
<front id="SdFatStructsH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatStructsH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatStructsH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatStructsH-19"> */</front>
<front id="SdFatStructsH-20">#include "Marlin.h"</front>
<front id="SdFatStructsH-21">#ifdef SDSUPPORT</front>
<front id="SdFatStructsH-22"></front>
<front id="SdFatStructsH-23">#ifndef SdFatStructs_h</front>
<front id="SdFatStructsH-24">#define SdFatStructs_h</front>
<front id="SdFatStructsH-25"></front>
<front id="SdFatStructsH-26">#define PACKED __attribute__((__packed__))</front>
<front id="SdFatStructsH-27">/**</front>
<front id="SdFatStructsH-28"> * \file</front>
<front id="SdFatStructsH-29"> * \brief FAT file structures</front>
<front id="SdFatStructsH-30"> */</front>
<front id="SdFatStructsH-31">/*</front>
<front id="SdFatStructsH-32"> * mostly from Microsoft document fatgen103.doc</front>
<front id="SdFatStructsH-33"> * http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx</front>
<front id="SdFatStructsH-34"> */</front>
<front id="SdFatStructsH-35">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-36">/** Value for byte 510 of boot block or MBR */</front>
<front id="SdFatStructsH-37">uint8_t const BOOTSIG0 = 0X55;</front>
<front id="SdFatStructsH-38">/** Value for byte 511 of boot block or MBR */</front>
<front id="SdFatStructsH-39">uint8_t const BOOTSIG1 = 0XAA;</front>
<front id="SdFatStructsH-40">/** Value for bootSignature field int FAT/FAT32 boot sector */</front>
<front id="SdFatStructsH-41">uint8_t const EXTENDED_BOOT_SIG = 0X29;</front>
<front id="SdFatStructsH-42">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-43">/**</front>
<front id="SdFatStructsH-44"> * \struct partitionTable</front>
<front id="SdFatStructsH-45"> * \brief MBR partition table entry</front>
<front id="SdFatStructsH-46"> *</front>
<front id="SdFatStructsH-47"> * A partition table entry for a MBR formatted storage device.</front>
<front id="SdFatStructsH-48"> * The MBR partition table has four entries.</front>
<front id="SdFatStructsH-49"> */</front>
<front id="SdFatStructsH-50">struct partitionTable {</front>
<front id="SdFatStructsH-51">          /**</front>
<front id="SdFatStructsH-52">           * Boot Indicator . Indicates whether the volume is the active</front>
<front id="SdFatStructsH-53">           * partition.  Legal values include: 0X00. Do not use for booting.</front>
<front id="SdFatStructsH-54">           * 0X80 Active partition.</front>
<front id="SdFatStructsH-55">           */</front>
<front id="SdFatStructsH-56">  uint8_t  boot;</front>
<front id="SdFatStructsH-57">          /**</front>
<front id="SdFatStructsH-58">            * Head part of Cylinder-head-sector address of the first block in</front>
<front id="SdFatStructsH-59">            * the partition. Legal values are 0-255. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-60">            */</front>
<front id="SdFatStructsH-61">  uint8_t  beginHead;</front>
<front id="SdFatStructsH-62">          /**</front>
<front id="SdFatStructsH-63">           * Sector part of Cylinder-head-sector address of the first block in</front>
<front id="SdFatStructsH-64">           * the partition. Legal values are 1-63. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-65">           */</front>
<front id="SdFatStructsH-66">  unsigned beginSector : 6;</front>
<front id="SdFatStructsH-67">           /** High bits cylinder for first block in partition. */</front>
<front id="SdFatStructsH-68">  unsigned beginCylinderHigh : 2;</front>
<front id="SdFatStructsH-69">          /**</front>
<front id="SdFatStructsH-70">           * Combine beginCylinderLow with beginCylinderHigh. Legal values</front>
<front id="SdFatStructsH-71">           * are 0-1023.  Only used in old PC BIOS.</front>
<front id="SdFatStructsH-72">           */</front>
<front id="SdFatStructsH-73">  uint8_t  beginCylinderLow;</front>
<front id="SdFatStructsH-74">          /**</front>
<front id="SdFatStructsH-75">           * Partition type. See defines that begin with PART_TYPE_ for</front>
<front id="SdFatStructsH-76">           * some Microsoft partition types.</front>
<front id="SdFatStructsH-77">           */</front>
<front id="SdFatStructsH-78">  uint8_t  type;</front>
<front id="SdFatStructsH-79">          /**</front>
<front id="SdFatStructsH-80">           * head part of cylinder-head-sector address of the last sector in the</front>
<front id="SdFatStructsH-81">           * partition.  Legal values are 0-255. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-82">           */</front>
<front id="SdFatStructsH-83">  uint8_t  endHead;</front>
<front id="SdFatStructsH-84">          /**</front>
<front id="SdFatStructsH-85">           * Sector part of cylinder-head-sector address of the last sector in</front>
<front id="SdFatStructsH-86">           * the partition.  Legal values are 1-63. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-87">           */</front>
<front id="SdFatStructsH-88">  unsigned endSector : 6;</front>
<front id="SdFatStructsH-89">           /** High bits of end cylinder */</front>
<front id="SdFatStructsH-90">  unsigned endCylinderHigh : 2;</front>
<front id="SdFatStructsH-91">          /**</front>
<front id="SdFatStructsH-92">           * Combine endCylinderLow with endCylinderHigh. Legal values</front>
<front id="SdFatStructsH-93">           * are 0-1023.  Only used in old PC BIOS.</front>
<front id="SdFatStructsH-94">           */</front>
<front id="SdFatStructsH-95">  uint8_t  endCylinderLow;</front>
<front id="SdFatStructsH-96">           /** Logical block address of the first block in the partition. */</front>
<front id="SdFatStructsH-97">  uint32_t firstSector;</front>
<front id="SdFatStructsH-98">           /** Length of the partition, in blocks. */</front>
<front id="SdFatStructsH-99">  uint32_t totalSectors;</front>
<front id="SdFatStructsH-100">} PACKED;</front>
<front id="SdFatStructsH-101">/** Type name for partitionTable */</front>
<front id="SdFatStructsH-102">typedef struct partitionTable part_t;</front>
<front id="SdFatStructsH-103">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-104">/**</front>
<front id="SdFatStructsH-105"> * \struct masterBootRecord</front>
<front id="SdFatStructsH-106"> *</front>
<front id="SdFatStructsH-107"> * \brief Master Boot Record</front>
<front id="SdFatStructsH-108"> *</front>
<front id="SdFatStructsH-109"> * The first block of a storage device that is formatted with a MBR.</front>
<front id="SdFatStructsH-110"> */</front>
<front id="SdFatStructsH-111">struct masterBootRecord {</front>
<front id="SdFatStructsH-112">           /** Code Area for master boot program. */</front>
<front id="SdFatStructsH-113">  uint8_t  codeArea[440];</front>
<front id="SdFatStructsH-114">           /** Optional Windows NT disk signature. May contain boot code. */</front>
<front id="SdFatStructsH-115">  uint32_t diskSignature;</front>
<front id="SdFatStructsH-116">           /** Usually zero but may be more boot code. */</front>
<front id="SdFatStructsH-117">  uint16_t usuallyZero;</front>
<front id="SdFatStructsH-118">           /** Partition tables. */</front>
<front id="SdFatStructsH-119">  part_t   part[4];</front>
<front id="SdFatStructsH-120">           /** First MBR signature byte. Must be 0X55 */</front>
<front id="SdFatStructsH-121">  uint8_t  mbrSig0;</front>
<front id="SdFatStructsH-122">           /** Second MBR signature byte. Must be 0XAA */</front>
<front id="SdFatStructsH-123">  uint8_t  mbrSig1;</front>
<front id="SdFatStructsH-124">} PACKED;</front>
<front id="SdFatStructsH-125">/** Type name for masterBootRecord */</front>
<front id="SdFatStructsH-126">typedef struct masterBootRecord mbr_t;</front>
<front id="SdFatStructsH-127">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-128">/**</front>
<front id="SdFatStructsH-129"> * \struct fat_boot</front>
<front id="SdFatStructsH-130"> *</front>
<front id="SdFatStructsH-131"> * \brief Boot sector for a FAT12/FAT16 volume.</front>
<front id="SdFatStructsH-132"> *</front>
<front id="SdFatStructsH-133"> */</front>
<front id="SdFatStructsH-134">struct fat_boot {</front>
<front id="SdFatStructsH-135">         /**</front>
<front id="SdFatStructsH-136">          * The first three bytes of the boot sector must be valid,</front>
<front id="SdFatStructsH-137">          * executable x 86-based CPU instructions. This includes a</front>
<front id="SdFatStructsH-138">          * jump instruction that skips the next nonexecutable bytes.</front>
<front id="SdFatStructsH-139">          */</front>
<front id="SdFatStructsH-140">  uint8_t jump[3];</front>
<front id="SdFatStructsH-141">         /**</front>
<front id="SdFatStructsH-142">          * This is typically a string of characters that identifies</front>
<front id="SdFatStructsH-143">          * the operating system that formatted the volume.</front>
<front id="SdFatStructsH-144">          */</front>
<front id="SdFatStructsH-145">  char    oemId[8];</front>
<front id="SdFatStructsH-146">          /**</front>
<front id="SdFatStructsH-147">           * The size of a hardware sector. Valid decimal values for this</front>
<front id="SdFatStructsH-148">           * field are 512, 1024, 2048, and 4096. For most disks used in</front>
<front id="SdFatStructsH-149">           * the United States, the value of this field is 512.</front>
<front id="SdFatStructsH-150">           */</front>
<front id="SdFatStructsH-151">  uint16_t bytesPerSector;</front>
<front id="SdFatStructsH-152">          /**</front>
<front id="SdFatStructsH-153">           * Number of sectors per allocation unit. This value must be a</front>
<front id="SdFatStructsH-154">           * power of 2 that is greater than 0. The legal values are</front>
<front id="SdFatStructsH-155">           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.</front>
<front id="SdFatStructsH-156">           */</front>
<front id="SdFatStructsH-157">  uint8_t  sectorsPerCluster;</front>
<front id="SdFatStructsH-158">          /**</front>
<front id="SdFatStructsH-159">           * The number of sectors preceding the start of the first FAT,</front>
<front id="SdFatStructsH-160">           * including the boot sector. The value of this field is always 1.</front>
<front id="SdFatStructsH-161">           */</front>
<front id="SdFatStructsH-162">  uint16_t reservedSectorCount;</front>
<front id="SdFatStructsH-163">          /**</front>
<front id="SdFatStructsH-164">           * The number of copies of the FAT on the volume.</front>
<front id="SdFatStructsH-165">           * The value of this field is always 2.</front>
<front id="SdFatStructsH-166">           */</front>
<front id="SdFatStructsH-167">  uint8_t  fatCount;</front>
<front id="SdFatStructsH-168">          /**</front>
<front id="SdFatStructsH-169">           * For FAT12 and FAT16 volumes, this field contains the count of</front>
<front id="SdFatStructsH-170">           * 32-byte directory entries in the root directory. For FAT32 volumes,</front>
<front id="SdFatStructsH-171">           * this field must be set to 0. For FAT12 and FAT16 volumes, this</front>
<front id="SdFatStructsH-172">           * value should always specify a count that when multiplied by 32</front>
<front id="SdFatStructsH-173">           * results in a multiple of bytesPerSector.  FAT16 volumes should</front>
<front id="SdFatStructsH-174">           * use the value 512.</front>
<front id="SdFatStructsH-175">           */</front>
<front id="SdFatStructsH-176">  uint16_t rootDirEntryCount;</front>
<front id="SdFatStructsH-177">          /**</front>
<front id="SdFatStructsH-178">           * This field is the old 16-bit total count of sectors on the volume.</front>
<front id="SdFatStructsH-179">           * This count includes the count of all sectors in all four regions</front>
<front id="SdFatStructsH-180">           * of the volume. This field can be 0; if it is 0, then totalSectors32</front>
<front id="SdFatStructsH-181">           * must be nonzero.  For FAT32 volumes, this field must be 0. For</front>
<front id="SdFatStructsH-182">           * FAT12 and FAT16 volumes, this field contains the sector count, and</front>
<front id="SdFatStructsH-183">           * totalSectors32 is 0 if the total sector count fits</front>
<front id="SdFatStructsH-184">           * (is less than 0x10000).</front>
<front id="SdFatStructsH-185">           */</front>
<front id="SdFatStructsH-186">  uint16_t totalSectors16;</front>
<front id="SdFatStructsH-187">          /**</front>
<front id="SdFatStructsH-188">           * This dates back to the old MS-DOS 1.x media determination and is</front>
<front id="SdFatStructsH-189">           * no longer usually used for anything.  0xF8 is the standard value</front>
<front id="SdFatStructsH-190">           * for fixed (nonremovable) media. For removable media, 0xF0 is</front>
<front id="SdFatStructsH-191">           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.</front>
<front id="SdFatStructsH-192">           */</front>
<front id="SdFatStructsH-193">  uint8_t  mediaType;</front>
<front id="SdFatStructsH-194">          /**</front>
<front id="SdFatStructsH-195">           * Count of sectors occupied by one FAT on FAT12/FAT16 volumes.</front>
<front id="SdFatStructsH-196">           * On FAT32 volumes this field must be 0, and sectorsPerFat32</front>
<front id="SdFatStructsH-197">           * contains the FAT size count.</front>
<front id="SdFatStructsH-198">           */</front>
<front id="SdFatStructsH-199">  uint16_t sectorsPerFat16;</front>
<front id="SdFatStructsH-200">           /** Sectors per track for interrupt 0x13. Not used otherwise. */</front>
<front id="SdFatStructsH-201">  uint16_t sectorsPerTrack;</front>
<front id="SdFatStructsH-202">           /** Number of heads for interrupt 0x13.  Not used otherwise. */</front>
<front id="SdFatStructsH-203">  uint16_t headCount;</front>
<front id="SdFatStructsH-204">          /**</front>
<front id="SdFatStructsH-205">           * Count of hidden sectors preceding the partition that contains this</front>
<front id="SdFatStructsH-206">           * FAT volume. This field is generally only relevant for media</front>
<front id="SdFatStructsH-207">           * visible on interrupt 0x13.</front>
<front id="SdFatStructsH-208">           */</front>
<front id="SdFatStructsH-209">  uint32_t hidddenSectors;</front>
<front id="SdFatStructsH-210">          /**</front>
<front id="SdFatStructsH-211">           * This field is the new 32-bit total count of sectors on the volume.</front>
<front id="SdFatStructsH-212">           * This count includes the count of all sectors in all four regions</front>
<front id="SdFatStructsH-213">           * of the volume.  This field can be 0; if it is 0, then</front>
<front id="SdFatStructsH-214">           * totalSectors16 must be nonzero.</front>
<front id="SdFatStructsH-215">           */</front>
<front id="SdFatStructsH-216">  uint32_t totalSectors32;</front>
<front id="SdFatStructsH-217">           /**</front>
<front id="SdFatStructsH-218">            * Related to the BIOS physical drive number. Floppy drives are</front>
<front id="SdFatStructsH-219">            * identified as 0x00 and physical hard disks are identified as</front>
<front id="SdFatStructsH-220">            * 0x80, regardless of the number of physical disk drives.</front>
<front id="SdFatStructsH-221">            * Typically, this value is set prior to issuing an INT 13h BIOS</front>
<front id="SdFatStructsH-222">            * call to specify the device to access. The value is only</front>
<front id="SdFatStructsH-223">            * relevant if the device is a boot device.</front>
<front id="SdFatStructsH-224">            */</front>
<front id="SdFatStructsH-225">  uint8_t  driveNumber;</front>
<front id="SdFatStructsH-226">           /** used by Windows NT - should be zero for FAT */</front>
<front id="SdFatStructsH-227">  uint8_t  reserved1;</front>
<front id="SdFatStructsH-228">           /** 0X29 if next three fields are valid */</front>
<front id="SdFatStructsH-229">  uint8_t  bootSignature;</front>
<front id="SdFatStructsH-230">           /**</front>
<front id="SdFatStructsH-231">            * A random serial number created when formatting a disk,</front>
<front id="SdFatStructsH-232">            * which helps to distinguish between disks.</front>
<front id="SdFatStructsH-233">            * Usually generated by combining date and time.</front>
<front id="SdFatStructsH-234">            */</front>
<front id="SdFatStructsH-235">  uint32_t volumeSerialNumber;</front>
<front id="SdFatStructsH-236">           /**</front>
<front id="SdFatStructsH-237">            * A field once used to store the volume label. The volume label</front>
<front id="SdFatStructsH-238">            * is now stored as a special file in the root directory.</front>
<front id="SdFatStructsH-239">            */</front>
<front id="SdFatStructsH-240">  char     volumeLabel[11];</front>
<front id="SdFatStructsH-241">           /**</front>
<front id="SdFatStructsH-242">            * A field with a value of either FAT, FAT12 or FAT16,</front>
<front id="SdFatStructsH-243">            * depending on the disk format.</front>
<front id="SdFatStructsH-244">            */</front>
<front id="SdFatStructsH-245">  char     fileSystemType[8];</front>
<front id="SdFatStructsH-246">           /** X86 boot code */</front>
<front id="SdFatStructsH-247">  uint8_t  bootCode[448];</front>
<front id="SdFatStructsH-248">           /** must be 0X55 */</front>
<front id="SdFatStructsH-249">  uint8_t  bootSectorSig0;</front>
<front id="SdFatStructsH-250">           /** must be 0XAA */</front>
<front id="SdFatStructsH-251">  uint8_t  bootSectorSig1;</front>
<front id="SdFatStructsH-252">} PACKED;</front>
<front id="SdFatStructsH-253">/** Type name for FAT Boot Sector */</front>
<front id="SdFatStructsH-254">typedef struct fat_boot fat_boot_t;</front>
<front id="SdFatStructsH-255">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-256">/**</front>
<front id="SdFatStructsH-257"> * \struct fat32_boot</front>
<front id="SdFatStructsH-258"> *</front>
<front id="SdFatStructsH-259"> * \brief Boot sector for a FAT32 volume.</front>
<front id="SdFatStructsH-260"> *</front>
<front id="SdFatStructsH-261"> */</front>
<front id="SdFatStructsH-262">struct fat32_boot {</front>
<front id="SdFatStructsH-263">         /**</front>
<front id="SdFatStructsH-264">          * The first three bytes of the boot sector must be valid,</front>
<front id="SdFatStructsH-265">          * executable x 86-based CPU instructions. This includes a</front>
<front id="SdFatStructsH-266">          * jump instruction that skips the next nonexecutable bytes.</front>
<front id="SdFatStructsH-267">          */</front>
<front id="SdFatStructsH-268">  uint8_t jump[3];</front>
<front id="SdFatStructsH-269">         /**</front>
<front id="SdFatStructsH-270">          * This is typically a string of characters that identifies</front>
<front id="SdFatStructsH-271">          * the operating system that formatted the volume.</front>
<front id="SdFatStructsH-272">          */</front>
<front id="SdFatStructsH-273">  char    oemId[8];</front>
<front id="SdFatStructsH-274">          /**</front>
<front id="SdFatStructsH-275">           * The size of a hardware sector. Valid decimal values for this</front>
<front id="SdFatStructsH-276">           * field are 512, 1024, 2048, and 4096. For most disks used in</front>
<front id="SdFatStructsH-277">           * the United States, the value of this field is 512.</front>
<front id="SdFatStructsH-278">           */</front>
<front id="SdFatStructsH-279">  uint16_t bytesPerSector;</front>
<front id="SdFatStructsH-280">          /**</front>
<front id="SdFatStructsH-281">           * Number of sectors per allocation unit. This value must be a</front>
<front id="SdFatStructsH-282">           * power of 2 that is greater than 0. The legal values are</front>
<front id="SdFatStructsH-283">           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.</front>
<front id="SdFatStructsH-284">           */</front>
<front id="SdFatStructsH-285">  uint8_t  sectorsPerCluster;</front>
<front id="SdFatStructsH-286">          /**</front>
<front id="SdFatStructsH-287">           * The number of sectors preceding the start of the first FAT,</front>
<front id="SdFatStructsH-288">           * including the boot sector. Must not be zero</front>
<front id="SdFatStructsH-289">           */</front>
<front id="SdFatStructsH-290">  uint16_t reservedSectorCount;</front>
<front id="SdFatStructsH-291">          /**</front>
<front id="SdFatStructsH-292">           * The number of copies of the FAT on the volume.</front>
<front id="SdFatStructsH-293">           * The value of this field is always 2.</front>
<front id="SdFatStructsH-294">           */</front>
<front id="SdFatStructsH-295">  uint8_t  fatCount;</front>
<front id="SdFatStructsH-296">          /**</front>
<front id="SdFatStructsH-297">           * FAT12/FAT16 only. For FAT32 volumes, this field must be set to 0.</front>
<front id="SdFatStructsH-298">           */</front>
<front id="SdFatStructsH-299">  uint16_t rootDirEntryCount;</front>
<front id="SdFatStructsH-300">          /**</front>
<front id="SdFatStructsH-301">           * For FAT32 volumes, this field must be 0.</front>
<front id="SdFatStructsH-302">           */</front>
<front id="SdFatStructsH-303">  uint16_t totalSectors16;</front>
<front id="SdFatStructsH-304">          /**</front>
<front id="SdFatStructsH-305">           * This dates back to the old MS-DOS 1.x media determination and is</front>
<front id="SdFatStructsH-306">           * no longer usually used for anything.  0xF8 is the standard value</front>
<front id="SdFatStructsH-307">           * for fixed (nonremovable) media. For removable media, 0xF0 is</front>
<front id="SdFatStructsH-308">           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.</front>
<front id="SdFatStructsH-309">           */</front>
<front id="SdFatStructsH-310">  uint8_t  mediaType;</front>
<front id="SdFatStructsH-311">          /**</front>
<front id="SdFatStructsH-312">           * On FAT32 volumes this field must be 0, and sectorsPerFat32</front>
<front id="SdFatStructsH-313">           * contains the FAT size count.</front>
<front id="SdFatStructsH-314">           */</front>
<front id="SdFatStructsH-315">  uint16_t sectorsPerFat16;</front>
<front id="SdFatStructsH-316">           /** Sectors per track for interrupt 0x13. Not used otherwise. */</front>
<front id="SdFatStructsH-317">  uint16_t sectorsPerTrack;</front>
<front id="SdFatStructsH-318">           /** Number of heads for interrupt 0x13.  Not used otherwise. */</front>
<front id="SdFatStructsH-319">  uint16_t headCount;</front>
<front id="SdFatStructsH-320">          /**</front>
<front id="SdFatStructsH-321">           * Count of hidden sectors preceding the partition that contains this</front>
<front id="SdFatStructsH-322">           * FAT volume. This field is generally only relevant for media</front>
<front id="SdFatStructsH-323">           * visible on interrupt 0x13.</front>
<front id="SdFatStructsH-324">           */</front>
<front id="SdFatStructsH-325">  uint32_t hidddenSectors;</front>
<front id="SdFatStructsH-326">          /**</front>
<front id="SdFatStructsH-327">           * Contains the total number of sectors in the FAT32 volume.</front>
<front id="SdFatStructsH-328">           */</front>
<front id="SdFatStructsH-329">  uint32_t totalSectors32;</front>
<front id="SdFatStructsH-330">         /**</front>
<front id="SdFatStructsH-331">           * Count of sectors occupied by one FAT on FAT32 volumes.</front>
<front id="SdFatStructsH-332">           */</front>
<front id="SdFatStructsH-333">  uint32_t sectorsPerFat32;</front>
<front id="SdFatStructsH-334">          /**</front>
<front id="SdFatStructsH-335">           * This field is only defined for FAT32 media and does not exist on</front>
<front id="SdFatStructsH-336">           * FAT12 and FAT16 media.</front>
<front id="SdFatStructsH-337">           * Bits 0-3 -- Zero-based number of active FAT.</front>
<front id="SdFatStructsH-338">           *             Only valid if mirroring is disabled.</front>
<front id="SdFatStructsH-339">           * Bits 4-6 -- Reserved.</front>
<front id="SdFatStructsH-340">           * Bit 7	-- 0 means the FAT is mirrored at runtime into all FATs.</front>
<front id="SdFatStructsH-341">	         *        -- 1 means only one FAT is active; it is the one referenced</front>
<front id="SdFatStructsH-342">	         *             in bits 0-3.</front>
<front id="SdFatStructsH-343">           * Bits 8-15 	-- Reserved.</front>
<front id="SdFatStructsH-344">           */</front>
<front id="SdFatStructsH-345">  uint16_t fat32Flags;</front>
<front id="SdFatStructsH-346">          /**</front>
<front id="SdFatStructsH-347">           * FAT32 version. High byte is major revision number.</front>
<front id="SdFatStructsH-348">           * Low byte is minor revision number. Only 0.0 define.</front>
<front id="SdFatStructsH-349">           */</front>
<front id="SdFatStructsH-350">  uint16_t fat32Version;</front>
<front id="SdFatStructsH-351">          /**</front>
<front id="SdFatStructsH-352">           * Cluster number of the first cluster of the root directory for FAT32.</front>
<front id="SdFatStructsH-353">           * This usually 2 but not required to be 2.</front>
<front id="SdFatStructsH-354">           */</front>
<front id="SdFatStructsH-355">  uint32_t fat32RootCluster;</front>
<front id="SdFatStructsH-356">          /**</front>
<front id="SdFatStructsH-357">           * Sector number of FSINFO structure in the reserved area of the</front>
<front id="SdFatStructsH-358">           * FAT32 volume. Usually 1.</front>
<front id="SdFatStructsH-359">           */</front>
<front id="SdFatStructsH-360">  uint16_t fat32FSInfo;</front>
<front id="SdFatStructsH-361">          /**</front>
<front id="SdFatStructsH-362">           * If nonzero, indicates the sector number in the reserved area</front>
<front id="SdFatStructsH-363">           * of the volume of a copy of the boot record. Usually 6.</front>
<front id="SdFatStructsH-364">           * No value other than 6 is recommended.</front>
<front id="SdFatStructsH-365">           */</front>
<front id="SdFatStructsH-366">  uint16_t fat32BackBootBlock;</front>
<front id="SdFatStructsH-367">          /**</front>
<front id="SdFatStructsH-368">           * Reserved for future expansion. Code that formats FAT32 volumes</front>
<front id="SdFatStructsH-369">           * should always set all of the bytes of this field to 0.</front>
<front id="SdFatStructsH-370">           */</front>
<front id="SdFatStructsH-371">  uint8_t  fat32Reserved[12];</front>
<front id="SdFatStructsH-372">           /**</front>
<front id="SdFatStructsH-373">            * Related to the BIOS physical drive number. Floppy drives are</front>
<front id="SdFatStructsH-374">            * identified as 0x00 and physical hard disks are identified as</front>
<front id="SdFatStructsH-375">            * 0x80, regardless of the number of physical disk drives.</front>
<front id="SdFatStructsH-376">            * Typically, this value is set prior to issuing an INT 13h BIOS</front>
<front id="SdFatStructsH-377">            * call to specify the device to access. The value is only</front>
<front id="SdFatStructsH-378">            * relevant if the device is a boot device.</front>
<front id="SdFatStructsH-379">            */</front>
<front id="SdFatStructsH-380">  uint8_t  driveNumber;</front>
<front id="SdFatStructsH-381">           /** used by Windows NT - should be zero for FAT */</front>
<front id="SdFatStructsH-382">  uint8_t  reserved1;</front>
<front id="SdFatStructsH-383">           /** 0X29 if next three fields are valid */</front>
<front id="SdFatStructsH-384">  uint8_t  bootSignature;</front>
<front id="SdFatStructsH-385">           /**</front>
<front id="SdFatStructsH-386">            * A random serial number created when formatting a disk,</front>
<front id="SdFatStructsH-387">            * which helps to distinguish between disks.</front>
<front id="SdFatStructsH-388">            * Usually generated by combining date and time.</front>
<front id="SdFatStructsH-389">            */</front>
<front id="SdFatStructsH-390">  uint32_t volumeSerialNumber;</front>
<front id="SdFatStructsH-391">           /**</front>
<front id="SdFatStructsH-392">            * A field once used to store the volume label. The volume label</front>
<front id="SdFatStructsH-393">            * is now stored as a special file in the root directory.</front>
<front id="SdFatStructsH-394">            */</front>
<front id="SdFatStructsH-395">  char     volumeLabel[11];</front>
<front id="SdFatStructsH-396">           /**</front>
<front id="SdFatStructsH-397">            * A text field with a value of FAT32.</front>
<front id="SdFatStructsH-398">            */</front>
<front id="SdFatStructsH-399">  char     fileSystemType[8];</front>
<front id="SdFatStructsH-400">           /** X86 boot code */</front>
<front id="SdFatStructsH-401">  uint8_t  bootCode[420];</front>
<front id="SdFatStructsH-402">           /** must be 0X55 */</front>
<front id="SdFatStructsH-403">  uint8_t  bootSectorSig0;</front>
<front id="SdFatStructsH-404">           /** must be 0XAA */</front>
<front id="SdFatStructsH-405">  uint8_t  bootSectorSig1;</front>
<front id="SdFatStructsH-406">} PACKED;</front>
<front id="SdFatStructsH-407">/** Type name for FAT32 Boot Sector */</front>
<front id="SdFatStructsH-408">typedef struct fat32_boot fat32_boot_t;</front>
<front id="SdFatStructsH-409">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-410">/** Lead signature for a FSINFO sector */</front>
<front id="SdFatStructsH-411">uint32_t const FSINFO_LEAD_SIG = 0x41615252;</front>
<front id="SdFatStructsH-412">/** Struct signature for a FSINFO sector */</front>
<front id="SdFatStructsH-413">uint32_t const FSINFO_STRUCT_SIG = 0x61417272;</front>
<front id="SdFatStructsH-414">/**</front>
<front id="SdFatStructsH-415"> * \struct fat32_fsinfo</front>
<front id="SdFatStructsH-416"> *</front>
<front id="SdFatStructsH-417"> * \brief FSINFO sector for a FAT32 volume.</front>
<front id="SdFatStructsH-418"> *</front>
<front id="SdFatStructsH-419"> */</front>
<front id="SdFatStructsH-420">struct fat32_fsinfo {</front>
<front id="SdFatStructsH-421">           /** must be 0X52, 0X52, 0X61, 0X41 */</front>
<front id="SdFatStructsH-422">  uint32_t  leadSignature;</front>
<front id="SdFatStructsH-423">           /** must be zero */</front>
<front id="SdFatStructsH-424">  uint8_t  reserved1[480];</front>
<front id="SdFatStructsH-425">           /** must be 0X72, 0X72, 0X41, 0X61 */</front>
<front id="SdFatStructsH-426">  uint32_t  structSignature;</front>
<front id="SdFatStructsH-427">          /**</front>
<front id="SdFatStructsH-428">           * Contains the last known free cluster count on the volume.</front>
<front id="SdFatStructsH-429">           * If the value is 0xFFFFFFFF, then the free count is unknown</front>
<front id="SdFatStructsH-430">           * and must be computed. Any other value can be used, but is</front>
<front id="SdFatStructsH-431">           * not necessarily correct. It should be range checked at least</front>
<front id="SdFatStructsH-432">           * to make sure it is &lt;= volume cluster count.</front>
<front id="SdFatStructsH-433">           */</front>
<front id="SdFatStructsH-434">  uint32_t freeCount;</front>
<front id="SdFatStructsH-435">          /**</front>
<front id="SdFatStructsH-436">           * This is a hint for the FAT driver. It indicates the cluster</front>
<front id="SdFatStructsH-437">           * number at which the driver should start looking for free clusters.</front>
<front id="SdFatStructsH-438">           * If the value is 0xFFFFFFFF, then there is no hint and the driver</front>
<front id="SdFatStructsH-439">           * should start looking at cluster 2.</front>
<front id="SdFatStructsH-440">           */</front>
<front id="SdFatStructsH-441">  uint32_t nextFree;</front>
<front id="SdFatStructsH-442">           /** must be zero */</front>
<front id="SdFatStructsH-443">  uint8_t  reserved2[12];</front>
<front id="SdFatStructsH-444">           /** must be 0X00, 0X00, 0X55, 0XAA */</front>
<front id="SdFatStructsH-445">  uint8_t  tailSignature[4];</front>
<front id="SdFatStructsH-446">} PACKED;</front>
<front id="SdFatStructsH-447">/** Type name for FAT32 FSINFO Sector */</front>
<front id="SdFatStructsH-448">typedef struct fat32_fsinfo fat32_fsinfo_t;</front>
<front id="SdFatStructsH-449">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-450">// End Of Chain values for FAT entries</front>
<front id="SdFatStructsH-451">/** FAT12 end of chain value used by Microsoft. */</front>
<front id="SdFatStructsH-452">uint16_t const FAT12EOC = 0XFFF;</front>
<front id="SdFatStructsH-453">/** Minimum value for FAT12 EOC.  Use to test for EOC. */</front>
<front id="SdFatStructsH-454">uint16_t const FAT12EOC_MIN = 0XFF8;</front>
<front id="SdFatStructsH-455">/** FAT16 end of chain value used by Microsoft. */</front>
<front id="SdFatStructsH-456">uint16_t const FAT16EOC = 0XFFFF;</front>
<front id="SdFatStructsH-457">/** Minimum value for FAT16 EOC.  Use to test for EOC. */</front>
<front id="SdFatStructsH-458">uint16_t const FAT16EOC_MIN = 0XFFF8;</front>
<front id="SdFatStructsH-459">/** FAT32 end of chain value used by Microsoft. */</front>
<front id="SdFatStructsH-460">uint32_t const FAT32EOC = 0X0FFFFFFF;</front>
<front id="SdFatStructsH-461">/** Minimum value for FAT32 EOC.  Use to test for EOC. */</front>
<front id="SdFatStructsH-462">uint32_t const FAT32EOC_MIN = 0X0FFFFFF8;</front>
<front id="SdFatStructsH-463">/** Mask a for FAT32 entry. Entries are 28 bits. */</front>
<front id="SdFatStructsH-464">uint32_t const FAT32MASK = 0X0FFFFFFF;</front>
<front id="SdFatStructsH-465">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-466">/**</front>
<front id="SdFatStructsH-467"> * \struct directoryEntry</front>
<front id="SdFatStructsH-468"> * \brief FAT short directory entry</front>
<front id="SdFatStructsH-469"> *</front>
<front id="SdFatStructsH-470"> * Short means short 8.3 name, not the entry size.</front>
<front id="SdFatStructsH-471"> *  </front>
<front id="SdFatStructsH-472"> * Date Format. A FAT directory entry date stamp is a 16-bit field that is </front>
<front id="SdFatStructsH-473"> * basically a date relative to the MS-DOS epoch of 01/01/1980. Here is the</front>
<front id="SdFatStructsH-474"> * format (bit 0 is the LSB of the 16-bit word, bit 15 is the MSB of the </front>
<front id="SdFatStructsH-475"> * 16-bit word):</front>
<front id="SdFatStructsH-476"> *   </front>
<front id="SdFatStructsH-477"> * Bits 9-15: Count of years from 1980, valid value range 0-127 </front>
<front id="SdFatStructsH-478"> * inclusive (1980-2107).</front>
<front id="SdFatStructsH-479"> *   </front>
<front id="SdFatStructsH-480"> * Bits 5-8: Month of year, 1 = January, valid value range 1-12 inclusive.</front>
<front id="SdFatStructsH-481"> *</front>
<front id="SdFatStructsH-482"> * Bits 0-4: Day of month, valid value range 1-31 inclusive.</front>
<front id="SdFatStructsH-483"> *</front>
<front id="SdFatStructsH-484"> * Time Format. A FAT directory entry time stamp is a 16-bit field that has</front>
<front id="SdFatStructsH-485"> * a granularity of 2 seconds. Here is the format (bit 0 is the LSB of the </front>
<front id="SdFatStructsH-486"> * 16-bit word, bit 15 is the MSB of the 16-bit word).</front>
<front id="SdFatStructsH-487"> *   </front>
<front id="SdFatStructsH-488"> * Bits 11-15: Hours, valid value range 0-23 inclusive.</front>
<front id="SdFatStructsH-489"> * </front>
<front id="SdFatStructsH-490"> * Bits 5-10: Minutes, valid value range 0-59 inclusive.</front>
<front id="SdFatStructsH-491"> *      </front>
<front id="SdFatStructsH-492"> * Bits 0-4: 2-second count, valid value range 0-29 inclusive (0 - 58 seconds).</front>
<front id="SdFatStructsH-493"> *   </front>
<front id="SdFatStructsH-494"> * The valid time range is from Midnight 00:00:00 to 23:59:58.</front>
<front id="SdFatStructsH-495"> */</front>
<front id="SdFatStructsH-496">struct directoryEntry {</front>
<front id="SdFatStructsH-497">           /** Short 8.3 name.</front>
<front id="SdFatStructsH-498">            *</front>
<front id="SdFatStructsH-499">            * The first eight bytes contain the file name with blank fill.</front>
<front id="SdFatStructsH-500">            * The last three bytes contain the file extension with blank fill.</front>
<front id="SdFatStructsH-501">            */</front>
<front id="SdFatStructsH-502">  uint8_t  name[11];</front>
<front id="SdFatStructsH-503">          /** Entry attributes.</front>
<front id="SdFatStructsH-504">           *</front>
<front id="SdFatStructsH-505">           * The upper two bits of the attribute byte are reserved and should</front>
<front id="SdFatStructsH-506">           * always be set to 0 when a file is created and never modified or</front>
<front id="SdFatStructsH-507">           * looked at after that.  See defines that begin with DIR_ATT_.</front>
<front id="SdFatStructsH-508">           */</front>
<front id="SdFatStructsH-509">  uint8_t  attributes;</front>
<front id="SdFatStructsH-510">          /**</front>
<front id="SdFatStructsH-511">           * Reserved for use by Windows NT. Set value to 0 when a file is</front>
<front id="SdFatStructsH-512">           * created and never modify or look at it after that.</front>
<front id="SdFatStructsH-513">           */</front>
<front id="SdFatStructsH-514">  uint8_t  reservedNT;</front>
<front id="SdFatStructsH-515">          /**</front>
<front id="SdFatStructsH-516">           * The granularity of the seconds part of creationTime is 2 seconds</front>
<front id="SdFatStructsH-517">           * so this field is a count of tenths of a second and its valid</front>
<front id="SdFatStructsH-518">           * value range is 0-199 inclusive. (WHG note - seems to be hundredths)</front>
<front id="SdFatStructsH-519">           */</front>
<front id="SdFatStructsH-520">  uint8_t  creationTimeTenths;</front>
<front id="SdFatStructsH-521">           /** Time file was created. */</front>
<front id="SdFatStructsH-522">  uint16_t creationTime;</front>
<front id="SdFatStructsH-523">           /** Date file was created. */</front>
<front id="SdFatStructsH-524">  uint16_t creationDate;</front>
<front id="SdFatStructsH-525">          /**</front>
<front id="SdFatStructsH-526">           * Last access date. Note that there is no last access time, only</front>
<front id="SdFatStructsH-527">           * a date.  This is the date of last read or write. In the case of</front>
<front id="SdFatStructsH-528">           * a write, this should be set to the same date as lastWriteDate.</front>
<front id="SdFatStructsH-529">           */</front>
<front id="SdFatStructsH-530">  uint16_t lastAccessDate;</front>
<front id="SdFatStructsH-531">          /**</front>
<front id="SdFatStructsH-532">           * High word of this entry's first cluster number (always 0 for a</front>
<front id="SdFatStructsH-533">           * FAT12 or FAT16 volume).</front>
<front id="SdFatStructsH-534">           */</front>
<front id="SdFatStructsH-535">  uint16_t firstClusterHigh;</front>
<front id="SdFatStructsH-536">           /** Time of last write. File creation is considered a write. */</front>
<front id="SdFatStructsH-537">  uint16_t lastWriteTime;</front>
<front id="SdFatStructsH-538">           /** Date of last write. File creation is considered a write. */</front>
<front id="SdFatStructsH-539">  uint16_t lastWriteDate;</front>
<front id="SdFatStructsH-540">           /** Low word of this entry's first cluster number. */</front>
<front id="SdFatStructsH-541">  uint16_t firstClusterLow;</front>
<front id="SdFatStructsH-542">           /** 32-bit unsigned holding this file's size in bytes. */</front>
<front id="SdFatStructsH-543">  uint32_t fileSize;</front>
<front id="SdFatStructsH-544">} PACKED;</front>
<front id="SdFatStructsH-545">/**</front>
<front id="SdFatStructsH-546"> * \struct directoryVFATEntry</front>
<front id="SdFatStructsH-547"> * \brief VFAT long filename directory entry</front>
<front id="SdFatStructsH-548"> *</front>
<front id="SdFatStructsH-549"> * directoryVFATEntries are found in the same list as normal directoryEntry.</front>
<front id="SdFatStructsH-550"> * But have the attribute field set to DIR_ATT_LONG_NAME.</front>
<front id="SdFatStructsH-551"> * </front>
<front id="SdFatStructsH-552"> * Long filenames are saved in multiple directoryVFATEntries.</front>
<front id="SdFatStructsH-553"> * Each entry containing 13 UTF-16 characters.</front>
<front id="SdFatStructsH-554"> */</front>
<front id="SdFatStructsH-555">struct directoryVFATEntry {</front>
<front id="SdFatStructsH-556">  /**</front>
<front id="SdFatStructsH-557">   * Sequence number. Consists of 2 parts:</front>
<front id="SdFatStructsH-558">   *  bit 6:   indicates first long filename block for the next file</front>
<front id="SdFatStructsH-559">   *  bit 0-4: the position of this long filename block (first block is 1)</front>
<front id="SdFatStructsH-560">   */</front>
<front id="SdFatStructsH-561">  uint8_t  sequenceNumber;</front>
<front id="SdFatStructsH-562">  /** First set of UTF-16 characters */</front>
<front id="SdFatStructsH-563">  uint16_t name1[5];//UTF-16</front>
<front id="SdFatStructsH-564">  /** attributes (at the same location as in directoryEntry), always 0x0F */</front>
<front id="SdFatStructsH-565">  uint8_t  attributes;</front>
<front id="SdFatStructsH-566">  /** Reserved for use by Windows NT. Always 0. */</front>
<front id="SdFatStructsH-567">  uint8_t  reservedNT;</front>
<front id="SdFatStructsH-568">  /** Checksum of the short 8.3 filename, can be used to checked if the file system as modified by a not-long-filename aware implementation. */</front>
<front id="SdFatStructsH-569">  uint8_t  checksum;</front>
<front id="SdFatStructsH-570">  /** Second set of UTF-16 characters */</front>
<front id="SdFatStructsH-571">  uint16_t name2[6];//UTF-16</front>
<front id="SdFatStructsH-572">  /** firstClusterLow is always zero for longFilenames */</front>
<front id="SdFatStructsH-573">  uint16_t firstClusterLow;</front>
<front id="SdFatStructsH-574">  /** Third set of UTF-16 characters */</front>
<front id="SdFatStructsH-575">  uint16_t name3[2];//UTF-16</front>
<front id="SdFatStructsH-576">} PACKED;</front>
<front id="SdFatStructsH-577">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-578">// Definitions for directory entries</front>
<front id="SdFatStructsH-579">//</front>
<front id="SdFatStructsH-580">/** Type name for directoryEntry */</front>
<front id="SdFatStructsH-581">typedef struct directoryEntry dir_t;</front>
<front id="SdFatStructsH-582">/** Type name for directoryVFATEntry */</front>
<front id="SdFatStructsH-583">typedef struct directoryVFATEntry vfat_t;</front>
<front id="SdFatStructsH-584">/** escape for name[0] = 0XE5 */</front>
<front id="SdFatStructsH-585">uint8_t const DIR_NAME_0XE5 = 0X05;</front>
<front id="SdFatStructsH-586">/** name[0] value for entry that is free after being "deleted" */</front>
<front id="SdFatStructsH-587">uint8_t const DIR_NAME_DELETED = 0XE5;</front>
<front id="SdFatStructsH-588">/** name[0] value for entry that is free and no allocated entries follow */</front>
<front id="SdFatStructsH-589">uint8_t const DIR_NAME_FREE = 0X00;</front>
<front id="SdFatStructsH-590">/** file is read-only */</front>
<front id="SdFatStructsH-591">uint8_t const DIR_ATT_READ_ONLY = 0X01;</front>
<front id="SdFatStructsH-592">/** File should hidden in directory listings */</front>
<front id="SdFatStructsH-593">uint8_t const DIR_ATT_HIDDEN = 0X02;</front>
<front id="SdFatStructsH-594">/** Entry is for a system file */</front>
<front id="SdFatStructsH-595">uint8_t const DIR_ATT_SYSTEM = 0X04;</front>
<front id="SdFatStructsH-596">/** Directory entry contains the volume label */</front>
<front id="SdFatStructsH-597">uint8_t const DIR_ATT_VOLUME_ID = 0X08;</front>
<front id="SdFatStructsH-598">/** Entry is for a directory */</front>
<front id="SdFatStructsH-599">uint8_t const DIR_ATT_DIRECTORY = 0X10;</front>
<front id="SdFatStructsH-600">/** Old DOS archive bit for backup support */</front>
<front id="SdFatStructsH-601">uint8_t const DIR_ATT_ARCHIVE = 0X20;</front>
<front id="SdFatStructsH-602">/** Test value for long name entry.  Test is</front>
<front id="SdFatStructsH-603">  (d-&gt;attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME. */</front>
<front id="SdFatStructsH-604">uint8_t const DIR_ATT_LONG_NAME = 0X0F;</front>
<front id="SdFatStructsH-605">/** Test mask for long name entry */</front>
<front id="SdFatStructsH-606">uint8_t const DIR_ATT_LONG_NAME_MASK = 0X3F;</front>
<front id="SdFatStructsH-607">/** defined attribute bits */</front>
<front id="SdFatStructsH-608">uint8_t const DIR_ATT_DEFINED_BITS = 0X3F;</front>
<front id="SdFatStructsH-609">/** Directory entry is part of a long name</front>
<front id="SdFatStructsH-610"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-611"> *</front>
<front id="SdFatStructsH-612"> * \return true if the entry is for part of a long name else false.</front>
<front id="SdFatStructsH-613"> */</front>
<front id="SdFatStructsH-614">static inline uint8_t DIR_IS_LONG_NAME(const dir_t* dir) {</front>
<front id="SdFatStructsH-615">  return (dir-&gt;attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME;</front>
<front id="SdFatStructsH-616">}</front>
<front id="SdFatStructsH-617">/** Mask for file/subdirectory tests */</front>
<front id="SdFatStructsH-618">uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);</front>
<front id="SdFatStructsH-619">/** Directory entry is for a file</front>
<front id="SdFatStructsH-620"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-621"> *</front>
<front id="SdFatStructsH-622"> * \return true if the entry is for a normal file else false.</front>
<front id="SdFatStructsH-623"> */</front>
<front id="SdFatStructsH-624">static inline uint8_t DIR_IS_FILE(const dir_t* dir) {</front>
<front id="SdFatStructsH-625">  return (dir-&gt;attributes & DIR_ATT_FILE_TYPE_MASK) == 0;</front>
<front id="SdFatStructsH-626">}</front>
<front id="SdFatStructsH-627">/** Directory entry is for a subdirectory</front>
<front id="SdFatStructsH-628"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-629"> *</front>
<front id="SdFatStructsH-630"> * \return true if the entry is for a subdirectory else false.</front>
<front id="SdFatStructsH-631"> */</front>
<front id="SdFatStructsH-632">static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {</front>
<front id="SdFatStructsH-633">  return (dir-&gt;attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;</front>
<front id="SdFatStructsH-634">}</front>
<front id="SdFatStructsH-635">/** Directory entry is for a file or subdirectory</front>
<front id="SdFatStructsH-636"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-637"> *</front>
<front id="SdFatStructsH-638"> * \return true if the entry is for a normal file or subdirectory else false.</front>
<front id="SdFatStructsH-639"> */</front>
<front id="SdFatStructsH-640">static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {</front>
<front id="SdFatStructsH-641">  return (dir-&gt;attributes & DIR_ATT_VOLUME_ID) == 0;</front>
<front id="SdFatStructsH-642">}</front>
<front id="SdFatStructsH-643">#endif  // SdFatStructs_h</front>
<front id="SdFatStructsH-644"></front>
<front id="SdFatStructsH-645"></front>
<front id="SdFatStructsH-646">#endif</front>
 </pre>
<h1>SdFatUtil.cpp</h1>
<pre  class="prettyprint linenums"><front id="SdFatUtilCPP-1">/* Arduino SdFat Library</front>
<front id="SdFatUtilCPP-2"> * Copyright (C) 2008 by William Greiman</front>
<front id="SdFatUtilCPP-3"> *</front>
<front id="SdFatUtilCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatUtilCPP-5"> *</front>
<front id="SdFatUtilCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatUtilCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatUtilCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatUtilCPP-9"> * (at your option) any later version.</front>
<front id="SdFatUtilCPP-10"> *</front>
<front id="SdFatUtilCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatUtilCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatUtilCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatUtilCPP-14"> * GNU General Public License for more details.</front>
<front id="SdFatUtilCPP-15"></front>
<front id="SdFatUtilCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatUtilCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatUtilCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatUtilCPP-19"> */</front>
<front id="SdFatUtilCPP-20">#include "Marlin.h"</front>
<front id="SdFatUtilCPP-21"></front>
<front id="SdFatUtilCPP-22">#ifdef SDSUPPORT</front>
<front id="SdFatUtilCPP-23">#include "SdFatUtil.h"</front>
<front id="SdFatUtilCPP-24"></front>
<front id="SdFatUtilCPP-25">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-26">/** Amount of free RAM</front>
<front id="SdFatUtilCPP-27"> * \return The number of free bytes.</front>
<front id="SdFatUtilCPP-28"> */</front>
<front id="SdFatUtilCPP-29">int SdFatUtil::FreeRam() {</front>
<front id="SdFatUtilCPP-30">  extern int  __bss_end;</front>
<front id="SdFatUtilCPP-31">  extern int* __brkval;</front>
<front id="SdFatUtilCPP-32">  int free_memory;</front>
<front id="SdFatUtilCPP-33">  if (reinterpret_cast&lt;int&gt;(__brkval) == 0) {</front>
<front id="SdFatUtilCPP-34">    // if no heap use from end of bss section</front>
<front id="SdFatUtilCPP-35">    free_memory = reinterpret_cast&lt;int&gt;(&free_memory)</front>
<front id="SdFatUtilCPP-36">                  - reinterpret_cast&lt;int&gt;(&__bss_end);</front>
<front id="SdFatUtilCPP-37">  } else {</front>
<front id="SdFatUtilCPP-38">    // use from top of stack to heap</front>
<front id="SdFatUtilCPP-39">    free_memory = reinterpret_cast&lt;int&gt;(&free_memory)</front>
<front id="SdFatUtilCPP-40">                  - reinterpret_cast&lt;int&gt;(__brkval);</front>
<front id="SdFatUtilCPP-41">  }</front>
<front id="SdFatUtilCPP-42">  return free_memory;</front>
<front id="SdFatUtilCPP-43">}</front>
<front id="SdFatUtilCPP-44">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-45">/** %Print a string in flash memory.</front>
<front id="SdFatUtilCPP-46"> *</front>
<front id="SdFatUtilCPP-47"> * \param[in] pr Print object for output.</front>
<front id="SdFatUtilCPP-48"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-49"> */</front>
<front id="SdFatUtilCPP-50">void SdFatUtil::print_P( PGM_P str) {</front>
<front id="SdFatUtilCPP-51">  for (uint8_t c; (c = pgm_read_byte(str)); str++) MYSERIAL.write(c);</front>
<front id="SdFatUtilCPP-52">}</front>
<front id="SdFatUtilCPP-53">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-54">/** %Print a string in flash memory followed by a CR/LF.</front>
<front id="SdFatUtilCPP-55"> *</front>
<front id="SdFatUtilCPP-56"> * \param[in] pr Print object for output.</front>
<front id="SdFatUtilCPP-57"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-58"> */</front>
<front id="SdFatUtilCPP-59">void SdFatUtil::println_P( PGM_P str) {</front>
<front id="SdFatUtilCPP-60">  print_P( str);</front>
<front id="SdFatUtilCPP-61">  MYSERIAL.println();</front>
<front id="SdFatUtilCPP-62">}</front>
<front id="SdFatUtilCPP-63">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-64">/** %Print a string in flash memory to Serial.</front>
<front id="SdFatUtilCPP-65"> *</front>
<front id="SdFatUtilCPP-66"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-67"> */</front>
<front id="SdFatUtilCPP-68">void SdFatUtil::SerialPrint_P(PGM_P str) {</front>
<front id="SdFatUtilCPP-69">  print_P(str);</front>
<front id="SdFatUtilCPP-70">}</front>
<front id="SdFatUtilCPP-71">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-72">/** %Print a string in flash memory to Serial followed by a CR/LF.</front>
<front id="SdFatUtilCPP-73"> *</front>
<front id="SdFatUtilCPP-74"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-75"> */</front>
<front id="SdFatUtilCPP-76">void SdFatUtil::SerialPrintln_P(PGM_P str) {</front>
<front id="SdFatUtilCPP-77">  println_P( str);</front>
<front id="SdFatUtilCPP-78">}</front>
<front id="SdFatUtilCPP-79">#endif</front>
 </pre>
<h1>SdFatUtil.h</h1>
<pre  class="prettyprint linenums"><front id="SdFatUtilH-1">/* Arduino SdFat Library</front>
<front id="SdFatUtilH-2"> * Copyright (C) 2008 by William Greiman</front>
<front id="SdFatUtilH-3"> *</front>
<front id="SdFatUtilH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatUtilH-5"> *</front>
<front id="SdFatUtilH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatUtilH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatUtilH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatUtilH-9"> * (at your option) any later version.</front>
<front id="SdFatUtilH-10"> *</front>
<front id="SdFatUtilH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatUtilH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatUtilH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatUtilH-14"> * GNU General Public License for more details.</front>
<front id="SdFatUtilH-15"></front>
<front id="SdFatUtilH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatUtilH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatUtilH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatUtilH-19"> */</front>
<front id="SdFatUtilH-20">#include "Marlin.h"</front>
<front id="SdFatUtilH-21">#ifdef SDSUPPORT</front>
<front id="SdFatUtilH-22"></front>
<front id="SdFatUtilH-23">#ifndef SdFatUtil_h</front>
<front id="SdFatUtilH-24">#define SdFatUtil_h</front>
<front id="SdFatUtilH-25">/**</front>
<front id="SdFatUtilH-26"> * \file</front>
<front id="SdFatUtilH-27"> * \brief Useful utility functions.</front>
<front id="SdFatUtilH-28"> */</front>
<front id="SdFatUtilH-29">#include "Marlin.h"</front>
<front id="SdFatUtilH-30">#include "MarlinSerial.h"</front>
<front id="SdFatUtilH-31">/** Store and print a string in flash memory.*/</front>
<front id="SdFatUtilH-32">#define PgmPrint(x) SerialPrint_P(PSTR(x))</front>
<front id="SdFatUtilH-33">/** Store and print a string in flash memory followed by a CR/LF.*/</front>
<front id="SdFatUtilH-34">#define PgmPrintln(x) SerialPrintln_P(PSTR(x))</front>
<front id="SdFatUtilH-35"></front>
<front id="SdFatUtilH-36">namespace SdFatUtil {</front>
<front id="SdFatUtilH-37">  int FreeRam();</front>
<front id="SdFatUtilH-38">  void print_P( PGM_P str);</front>
<front id="SdFatUtilH-39">  void println_P( PGM_P str);</front>
<front id="SdFatUtilH-40">  void SerialPrint_P(PGM_P str);</front>
<front id="SdFatUtilH-41">  void SerialPrintln_P(PGM_P str);</front>
<front id="SdFatUtilH-42">}</front>
<front id="SdFatUtilH-43"></front>
<front id="SdFatUtilH-44">using namespace SdFatUtil;  // NOLINT</front>
<front id="SdFatUtilH-45">#endif  // #define SdFatUtil_h</front>
<front id="SdFatUtilH-46"></front>
<front id="SdFatUtilH-47"></front>
<front id="SdFatUtilH-48">#endif</front>
 </pre>
<h1>SdFile.cpp</h1>
<pre  class="prettyprint linenums"><front id="SdFileCPP-1">/* Arduino SdFat Library</front>
<front id="SdFileCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFileCPP-3"> *</front>
<front id="SdFileCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFileCPP-5"> *</front>
<front id="SdFileCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFileCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFileCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFileCPP-9"> * (at your option) any later version.</front>
<front id="SdFileCPP-10"> *</front>
<front id="SdFileCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFileCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFileCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFileCPP-14"> * GNU General Public License for more details.</front>
<front id="SdFileCPP-15"> *</front>
<front id="SdFileCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFileCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFileCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFileCPP-19"> */</front>
<front id="SdFileCPP-20">#include "Marlin.h"</front>
<front id="SdFileCPP-21"></front>
<front id="SdFileCPP-22">#ifdef SDSUPPORT</front>
<front id="SdFileCPP-23">#include "SdFile.h"</front>
<front id="SdFileCPP-24">/**  Create a file object and open it in the current working directory.</front>
<front id="SdFileCPP-25"> *</front>
<front id="SdFileCPP-26"> * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdFileCPP-27"> *</front>
<front id="SdFileCPP-28"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdFileCPP-29"> * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).</front>
<front id="SdFileCPP-30"> */</front>
<front id="SdFileCPP-31">SdFile::SdFile(const char* path, uint8_t oflag) : SdBaseFile(path, oflag) {</front>
<front id="SdFileCPP-32">}</front>
<front id="SdFileCPP-33">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-34">/** Write data to an open file.</front>
<front id="SdFileCPP-35"> *</front>
<front id="SdFileCPP-36"> * \note Data is moved to the cache but may not be written to the</front>
<front id="SdFileCPP-37"> * storage device until sync() is called.</front>
<front id="SdFileCPP-38"> *</front>
<front id="SdFileCPP-39"> * \param[in] buf Pointer to the location of the data to be written.</front>
<front id="SdFileCPP-40"> *</front>
<front id="SdFileCPP-41"> * \param[in] nbyte Number of bytes to write.</front>
<front id="SdFileCPP-42"> *</front>
<front id="SdFileCPP-43"> * \return For success write() returns the number of bytes written, always</front>
<front id="SdFileCPP-44"> * \a nbyte.  If an error occurs, write() returns -1.  Possible errors</front>
<front id="SdFileCPP-45"> * include write() is called before a file has been opened, write is called</front>
<front id="SdFileCPP-46"> * for a read-only file, device is full, a corrupt file system or an I/O error.</front>
<front id="SdFileCPP-47"> *</front>
<front id="SdFileCPP-48"> */</front>
<front id="SdFileCPP-49">int16_t SdFile::write(const void* buf, uint16_t nbyte) {</front>
<front id="SdFileCPP-50">  return SdBaseFile::write(buf, nbyte);</front>
<front id="SdFileCPP-51">}</front>
<front id="SdFileCPP-52">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-53">/** Write a byte to a file. Required by the Arduino Print class.</front>
<front id="SdFileCPP-54"> * \param[in] b the byte to be written.</front>
<front id="SdFileCPP-55"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-56"> */</front>
<front id="SdFileCPP-57">#if ARDUINO &gt;= 100</front>
<front id="SdFileCPP-58">size_t SdFile::write(uint8_t b)</front>
<front id="SdFileCPP-59">{</front>
<front id="SdFileCPP-60">    return SdBaseFile::write(&b, 1);</front>
<front id="SdFileCPP-61">}</front>
<front id="SdFileCPP-62">#else</front>
<front id="SdFileCPP-63">void SdFile::write(uint8_t b)</front>
<front id="SdFileCPP-64">{</front>
<front id="SdFileCPP-65">    SdBaseFile::write(&b, 1);</front>
<front id="SdFileCPP-66">}</front>
<front id="SdFileCPP-67">#endif</front>
<front id="SdFileCPP-68">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-69">/** Write a string to a file. Used by the Arduino Print class.</front>
<front id="SdFileCPP-70"> * \param[in] str Pointer to the string.</front>
<front id="SdFileCPP-71"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-72"> */</front>
<front id="SdFileCPP-73">void SdFile::write(const char* str) {</front>
<front id="SdFileCPP-74">  SdBaseFile::write(str, strlen(str));</front>
<front id="SdFileCPP-75">}</front>
<front id="SdFileCPP-76">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-77">/** Write a PROGMEM string to a file.</front>
<front id="SdFileCPP-78"> * \param[in] str Pointer to the PROGMEM string.</front>
<front id="SdFileCPP-79"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-80"> */</front>
<front id="SdFileCPP-81">void SdFile::write_P(PGM_P str) {</front>
<front id="SdFileCPP-82">  for (uint8_t c; (c = pgm_read_byte(str)); str++) write(c);</front>
<front id="SdFileCPP-83">}</front>
<front id="SdFileCPP-84">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-85">/** Write a PROGMEM string followed by CR/LF to a file.</front>
<front id="SdFileCPP-86"> * \param[in] str Pointer to the PROGMEM string.</front>
<front id="SdFileCPP-87"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-88"> */</front>
<front id="SdFileCPP-89">void SdFile::writeln_P(PGM_P str) {</front>
<front id="SdFileCPP-90">  write_P(str);</front>
<front id="SdFileCPP-91">  write_P(PSTR("\r\n"));</front>
<front id="SdFileCPP-92">}</front>
<front id="SdFileCPP-93"></front>
<front id="SdFileCPP-94"></front>
<front id="SdFileCPP-95">#endif</front>
 </pre>
<h1>SdFile.h</h1>
<pre  class="prettyprint linenums"><front id="SdFileH-1">/* Arduino SdFat Library</front>
<front id="SdFileH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFileH-3"> *</front>
<front id="SdFileH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFileH-5"> *</front>
<front id="SdFileH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFileH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFileH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFileH-9"> * (at your option) any later version.</front>
<front id="SdFileH-10"> *</front>
<front id="SdFileH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFileH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFileH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFileH-14"> * GNU General Public License for more details.</front>
<front id="SdFileH-15"> *</front>
<front id="SdFileH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFileH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFileH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFileH-19"> */</front>
<front id="SdFileH-20">/**</front>
<front id="SdFileH-21"> * \file</front>
<front id="SdFileH-22"> * \brief SdFile class</front>
<front id="SdFileH-23"> */</front>
<front id="SdFileH-24">#include "Marlin.h"</front>
<front id="SdFileH-25"></front>
<front id="SdFileH-26">#ifdef SDSUPPORT</front>
<front id="SdFileH-27">#include "SdBaseFile.h"</front>
<front id="SdFileH-28">#include &lt;Print.h&gt;</front>
<front id="SdFileH-29">#ifndef SdFile_h</front>
<front id="SdFileH-30">#define SdFile_h</front>
<front id="SdFileH-31">//------------------------------------------------------------------------------</front>
<front id="SdFileH-32">/**</front>
<front id="SdFileH-33"> * \class SdFile</front>
<front id="SdFileH-34"> * \brief SdBaseFile with Print.</front>
<front id="SdFileH-35"> */</front>
<front id="SdFileH-36">class SdFile : public SdBaseFile, public Print {</front>
<front id="SdFileH-37"> public:</front>
<front id="SdFileH-38">  SdFile() {}</front>
<front id="SdFileH-39">  SdFile(const char* name, uint8_t oflag);</front>
<front id="SdFileH-40">  #if ARDUINO &gt;= 100</front>
<front id="SdFileH-41">      size_t write(uint8_t b);</front>
<front id="SdFileH-42">  #else</front>
<front id="SdFileH-43">   void write(uint8_t b);</front>
<front id="SdFileH-44">  #endif</front>
<front id="SdFileH-45">  </front>
<front id="SdFileH-46">  int16_t write(const void* buf, uint16_t nbyte);</front>
<front id="SdFileH-47">  void write(const char* str);</front>
<front id="SdFileH-48">  void write_P(PGM_P str);</front>
<front id="SdFileH-49">  void writeln_P(PGM_P str);</front>
<front id="SdFileH-50">};</front>
<front id="SdFileH-51">#endif  // SdFile_h</front>
<front id="SdFileH-52"></front>
<front id="SdFileH-53"></front>
<front id="SdFileH-54">#endif</front>
 </pre>
<h1>SdInfo.h</h1>
<pre  class="prettyprint linenums"><front id="SdInfoH-1">/* Arduino Sd2Card Library</front>
<front id="SdInfoH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdInfoH-3"> *</front>
<front id="SdInfoH-4"> * This file is part of the Arduino Sd2Card Library</front>
<front id="SdInfoH-5"> *</front>
<front id="SdInfoH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdInfoH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdInfoH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdInfoH-9"> * (at your option) any later version.</front>
<front id="SdInfoH-10"> *</front>
<front id="SdInfoH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdInfoH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdInfoH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdInfoH-14"> * GNU General Public License for more details.</front>
<front id="SdInfoH-15"> *</front>
<front id="SdInfoH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdInfoH-17"> * along with the Arduino Sd2Card Library.  If not, see</front>
<front id="SdInfoH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdInfoH-19"> */</front>
<front id="SdInfoH-20">#include "Marlin.h"</front>
<front id="SdInfoH-21">#ifdef SDSUPPORT</front>
<front id="SdInfoH-22"></front>
<front id="SdInfoH-23">#ifndef SdInfo_h</front>
<front id="SdInfoH-24">#define SdInfo_h</front>
<front id="SdInfoH-25">#include &lt;stdint.h&gt;</front>
<front id="SdInfoH-26">// Based on the document:</front>
<front id="SdInfoH-27">//</front>
<front id="SdInfoH-28">// SD Specifications</front>
<front id="SdInfoH-29">// Part 1</front>
<front id="SdInfoH-30">// Physical Layer</front>
<front id="SdInfoH-31">// Simplified Specification</front>
<front id="SdInfoH-32">// Version 3.01</front>
<front id="SdInfoH-33">// May 18, 2010</front>
<front id="SdInfoH-34">//</front>
<front id="SdInfoH-35">// http://www.sdcard.org/developers/tech/sdcard/pls/simplified_specs</front>
<front id="SdInfoH-36">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-37">// SD card commands</front>
<front id="SdInfoH-38">/** GO_IDLE_STATE - init card in spi mode if CS low */</front>
<front id="SdInfoH-39">uint8_t const CMD0 = 0X00;</front>
<front id="SdInfoH-40">/** SEND_IF_COND - verify SD Memory Card interface operating condition.*/</front>
<front id="SdInfoH-41">uint8_t const CMD8 = 0X08;</front>
<front id="SdInfoH-42">/** SEND_CSD - read the Card Specific Data (CSD register) */</front>
<front id="SdInfoH-43">uint8_t const CMD9 = 0X09;</front>
<front id="SdInfoH-44">/** SEND_CID - read the card identification information (CID register) */</front>
<front id="SdInfoH-45">uint8_t const CMD10 = 0X0A;</front>
<front id="SdInfoH-46">/** STOP_TRANSMISSION - end multiple block read sequence */</front>
<front id="SdInfoH-47">uint8_t const CMD12 = 0X0C;</front>
<front id="SdInfoH-48">/** SEND_STATUS - read the card status register */</front>
<front id="SdInfoH-49">uint8_t const CMD13 = 0X0D;</front>
<front id="SdInfoH-50">/** READ_SINGLE_BLOCK - read a single data block from the card */</front>
<front id="SdInfoH-51">uint8_t const CMD17 = 0X11;</front>
<front id="SdInfoH-52">/** READ_MULTIPLE_BLOCK - read a multiple data blocks from the card */</front>
<front id="SdInfoH-53">uint8_t const CMD18 = 0X12;</front>
<front id="SdInfoH-54">/** WRITE_BLOCK - write a single data block to the card */</front>
<front id="SdInfoH-55">uint8_t const CMD24 = 0X18;</front>
<front id="SdInfoH-56">/** WRITE_MULTIPLE_BLOCK - write blocks of data until a STOP_TRANSMISSION */</front>
<front id="SdInfoH-57">uint8_t const CMD25 = 0X19;</front>
<front id="SdInfoH-58">/** ERASE_WR_BLK_START - sets the address of the first block to be erased */</front>
<front id="SdInfoH-59">uint8_t const CMD32 = 0X20;</front>
<front id="SdInfoH-60">/** ERASE_WR_BLK_END - sets the address of the last block of the continuous</front>
<front id="SdInfoH-61">    range to be erased*/</front>
<front id="SdInfoH-62">uint8_t const CMD33 = 0X21;</front>
<front id="SdInfoH-63">/** ERASE - erase all previously selected blocks */</front>
<front id="SdInfoH-64">uint8_t const CMD38 = 0X26;</front>
<front id="SdInfoH-65">/** APP_CMD - escape for application specific command */</front>
<front id="SdInfoH-66">uint8_t const CMD55 = 0X37;</front>
<front id="SdInfoH-67">/** READ_OCR - read the OCR register of a card */</front>
<front id="SdInfoH-68">uint8_t const CMD58 = 0X3A;</front>
<front id="SdInfoH-69">/** SET_WR_BLK_ERASE_COUNT - Set the number of write blocks to be</front>
<front id="SdInfoH-70">     pre-erased before writing */</front>
<front id="SdInfoH-71">uint8_t const ACMD23 = 0X17;</front>
<front id="SdInfoH-72">/** SD_SEND_OP_COMD - Sends host capacity support information and</front>
<front id="SdInfoH-73">    activates the card's initialization process */</front>
<front id="SdInfoH-74">uint8_t const ACMD41 = 0X29;</front>
<front id="SdInfoH-75">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-76">/** status for card in the ready state */</front>
<front id="SdInfoH-77">uint8_t const R1_READY_STATE = 0X00;</front>
<front id="SdInfoH-78">/** status for card in the idle state */</front>
<front id="SdInfoH-79">uint8_t const R1_IDLE_STATE = 0X01;</front>
<front id="SdInfoH-80">/** status bit for illegal command */</front>
<front id="SdInfoH-81">uint8_t const R1_ILLEGAL_COMMAND = 0X04;</front>
<front id="SdInfoH-82">/** start data token for read or write single block*/</front>
<front id="SdInfoH-83">uint8_t const DATA_START_BLOCK = 0XFE;</front>
<front id="SdInfoH-84">/** stop token for write multiple blocks*/</front>
<front id="SdInfoH-85">uint8_t const STOP_TRAN_TOKEN = 0XFD;</front>
<front id="SdInfoH-86">/** start data token for write multiple blocks*/</front>
<front id="SdInfoH-87">uint8_t const WRITE_MULTIPLE_TOKEN = 0XFC;</front>
<front id="SdInfoH-88">/** mask for data response tokens after a write block operation */</front>
<front id="SdInfoH-89">uint8_t const DATA_RES_MASK = 0X1F;</front>
<front id="SdInfoH-90">/** write data accepted token */</front>
<front id="SdInfoH-91">uint8_t const DATA_RES_ACCEPTED = 0X05;</front>
<front id="SdInfoH-92">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-93">/** Card IDentification (CID) register */</front>
<front id="SdInfoH-94">typedef struct CID {</front>
<front id="SdInfoH-95">  // byte 0</front>
<front id="SdInfoH-96">  /** Manufacturer ID */</front>
<front id="SdInfoH-97">  unsigned char mid;</front>
<front id="SdInfoH-98">  // byte 1-2</front>
<front id="SdInfoH-99">  /** OEM/Application ID */</front>
<front id="SdInfoH-100">  char oid[2];</front>
<front id="SdInfoH-101">  // byte 3-7</front>
<front id="SdInfoH-102">  /** Product name */</front>
<front id="SdInfoH-103">  char pnm[5];</front>
<front id="SdInfoH-104">  // byte 8</front>
<front id="SdInfoH-105">  /** Product revision least significant digit */</front>
<front id="SdInfoH-106">  unsigned char prv_m : 4;</front>
<front id="SdInfoH-107">  /** Product revision most significant digit */</front>
<front id="SdInfoH-108">  unsigned char prv_n : 4;</front>
<front id="SdInfoH-109">  // byte 9-12</front>
<front id="SdInfoH-110">  /** Product serial number */</front>
<front id="SdInfoH-111">  uint32_t psn;</front>
<front id="SdInfoH-112">  // byte 13</front>
<front id="SdInfoH-113">  /** Manufacturing date year low digit */</front>
<front id="SdInfoH-114">  unsigned char mdt_year_high : 4;</front>
<front id="SdInfoH-115">  /** not used */</front>
<front id="SdInfoH-116">  unsigned char reserved : 4;</front>
<front id="SdInfoH-117">  // byte 14</front>
<front id="SdInfoH-118">  /** Manufacturing date month */</front>
<front id="SdInfoH-119">  unsigned char mdt_month : 4;</front>
<front id="SdInfoH-120">  /** Manufacturing date year low digit */</front>
<front id="SdInfoH-121">  unsigned char mdt_year_low :4;</front>
<front id="SdInfoH-122">  // byte 15</front>
<front id="SdInfoH-123">  /** not used always 1 */</front>
<front id="SdInfoH-124">  unsigned char always1 : 1;</front>
<front id="SdInfoH-125">  /** CRC7 checksum */</front>
<front id="SdInfoH-126">  unsigned char crc : 7;</front>
<front id="SdInfoH-127">}cid_t;</front>
<front id="SdInfoH-128">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-129">/** CSD for version 1.00 cards */</front>
<front id="SdInfoH-130">typedef struct CSDV1 {</front>
<front id="SdInfoH-131">  // byte 0</front>
<front id="SdInfoH-132">  unsigned char reserved1 : 6;</front>
<front id="SdInfoH-133">  unsigned char csd_ver : 2;</front>
<front id="SdInfoH-134">  // byte 1</front>
<front id="SdInfoH-135">  unsigned char taac;</front>
<front id="SdInfoH-136">  // byte 2</front>
<front id="SdInfoH-137">  unsigned char nsac;</front>
<front id="SdInfoH-138">  // byte 3</front>
<front id="SdInfoH-139">  unsigned char tran_speed;</front>
<front id="SdInfoH-140">  // byte 4</front>
<front id="SdInfoH-141">  unsigned char ccc_high;</front>
<front id="SdInfoH-142">  // byte 5</front>
<front id="SdInfoH-143">  unsigned char read_bl_len : 4;</front>
<front id="SdInfoH-144">  unsigned char ccc_low : 4;</front>
<front id="SdInfoH-145">  // byte 6</front>
<front id="SdInfoH-146">  unsigned char c_size_high : 2;</front>
<front id="SdInfoH-147">  unsigned char reserved2 : 2;</front>
<front id="SdInfoH-148">  unsigned char dsr_imp : 1;</front>
<front id="SdInfoH-149">  unsigned char read_blk_misalign :1;</front>
<front id="SdInfoH-150">  unsigned char write_blk_misalign : 1;</front>
<front id="SdInfoH-151">  unsigned char read_bl_partial : 1;</front>
<front id="SdInfoH-152">  // byte 7</front>
<front id="SdInfoH-153">  unsigned char c_size_mid;</front>
<front id="SdInfoH-154">  // byte 8</front>
<front id="SdInfoH-155">  unsigned char vdd_r_curr_max : 3;</front>
<front id="SdInfoH-156">  unsigned char vdd_r_curr_min : 3;</front>
<front id="SdInfoH-157">  unsigned char c_size_low :2;</front>
<front id="SdInfoH-158">  // byte 9</front>
<front id="SdInfoH-159">  unsigned char c_size_mult_high : 2;</front>
<front id="SdInfoH-160">  unsigned char vdd_w_cur_max : 3;</front>
<front id="SdInfoH-161">  unsigned char vdd_w_curr_min : 3;</front>
<front id="SdInfoH-162">  // byte 10</front>
<front id="SdInfoH-163">  unsigned char sector_size_high : 6;</front>
<front id="SdInfoH-164">  unsigned char erase_blk_en : 1;</front>
<front id="SdInfoH-165">  unsigned char c_size_mult_low : 1;</front>
<front id="SdInfoH-166">  // byte 11</front>
<front id="SdInfoH-167">  unsigned char wp_grp_size : 7;</front>
<front id="SdInfoH-168">  unsigned char sector_size_low : 1;</front>
<front id="SdInfoH-169">  // byte 12</front>
<front id="SdInfoH-170">  unsigned char write_bl_len_high : 2;</front>
<front id="SdInfoH-171">  unsigned char r2w_factor : 3;</front>
<front id="SdInfoH-172">  unsigned char reserved3 : 2;</front>
<front id="SdInfoH-173">  unsigned char wp_grp_enable : 1;</front>
<front id="SdInfoH-174">  // byte 13</front>
<front id="SdInfoH-175">  unsigned char reserved4 : 5;</front>
<front id="SdInfoH-176">  unsigned char write_partial : 1;</front>
<front id="SdInfoH-177">  unsigned char write_bl_len_low : 2;</front>
<front id="SdInfoH-178">  // byte 14</front>
<front id="SdInfoH-179">  unsigned char reserved5: 2;</front>
<front id="SdInfoH-180">  unsigned char file_format : 2;</front>
<front id="SdInfoH-181">  unsigned char tmp_write_protect : 1;</front>
<front id="SdInfoH-182">  unsigned char perm_write_protect : 1;</front>
<front id="SdInfoH-183">  unsigned char copy : 1;</front>
<front id="SdInfoH-184">  /** Indicates the file format on the card */</front>
<front id="SdInfoH-185">  unsigned char file_format_grp : 1;</front>
<front id="SdInfoH-186">  // byte 15</front>
<front id="SdInfoH-187">  unsigned char always1 : 1;</front>
<front id="SdInfoH-188">  unsigned char crc : 7;</front>
<front id="SdInfoH-189">}csd1_t;</front>
<front id="SdInfoH-190">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-191">/** CSD for version 2.00 cards */</front>
<front id="SdInfoH-192">typedef struct CSDV2 {</front>
<front id="SdInfoH-193">  // byte 0</front>
<front id="SdInfoH-194">  unsigned char reserved1 : 6;</front>
<front id="SdInfoH-195">  unsigned char csd_ver : 2;</front>
<front id="SdInfoH-196">  // byte 1</front>
<front id="SdInfoH-197">  /** fixed to 0X0E */</front>
<front id="SdInfoH-198">  unsigned char taac;</front>
<front id="SdInfoH-199">  // byte 2</front>
<front id="SdInfoH-200">  /** fixed to 0 */</front>
<front id="SdInfoH-201">  unsigned char nsac;</front>
<front id="SdInfoH-202">  // byte 3</front>
<front id="SdInfoH-203">  unsigned char tran_speed;</front>
<front id="SdInfoH-204">  // byte 4</front>
<front id="SdInfoH-205">  unsigned char ccc_high;</front>
<front id="SdInfoH-206">  // byte 5</front>
<front id="SdInfoH-207">  /** This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte */</front>
<front id="SdInfoH-208">  unsigned char read_bl_len : 4;</front>
<front id="SdInfoH-209">  unsigned char ccc_low : 4;</front>
<front id="SdInfoH-210">  // byte 6</front>
<front id="SdInfoH-211">  /** not used */</front>
<front id="SdInfoH-212">  unsigned char reserved2 : 4;</front>
<front id="SdInfoH-213">  unsigned char dsr_imp : 1;</front>
<front id="SdInfoH-214">  /** fixed to 0 */</front>
<front id="SdInfoH-215">  unsigned char read_blk_misalign :1;</front>
<front id="SdInfoH-216">  /** fixed to 0 */</front>
<front id="SdInfoH-217">  unsigned char write_blk_misalign : 1;</front>
<front id="SdInfoH-218">  /** fixed to 0 - no partial read */</front>
<front id="SdInfoH-219">  unsigned char read_bl_partial : 1;</front>
<front id="SdInfoH-220">  // byte 7</front>
<front id="SdInfoH-221">  /** not used */</front>
<front id="SdInfoH-222">  unsigned char reserved3 : 2;</front>
<front id="SdInfoH-223">  /** high part of card size */</front>
<front id="SdInfoH-224">  unsigned char c_size_high : 6;</front>
<front id="SdInfoH-225">  // byte 8</front>
<front id="SdInfoH-226">  /** middle part of card size */</front>
<front id="SdInfoH-227">  unsigned char c_size_mid;</front>
<front id="SdInfoH-228">  // byte 9</front>
<front id="SdInfoH-229">  /** low part of card size */</front>
<front id="SdInfoH-230">  unsigned char c_size_low;</front>
<front id="SdInfoH-231">  // byte 10</front>
<front id="SdInfoH-232">  /** sector size is fixed at 64 KB */</front>
<front id="SdInfoH-233">  unsigned char sector_size_high : 6;</front>
<front id="SdInfoH-234">  /** fixed to 1 - erase single is supported */</front>
<front id="SdInfoH-235">  unsigned char erase_blk_en : 1;</front>
<front id="SdInfoH-236">  /** not used */</front>
<front id="SdInfoH-237">  unsigned char reserved4 : 1;</front>
<front id="SdInfoH-238">  // byte 11</front>
<front id="SdInfoH-239">  unsigned char wp_grp_size : 7;</front>
<front id="SdInfoH-240">  /** sector size is fixed at 64 KB */</front>
<front id="SdInfoH-241">  unsigned char sector_size_low : 1;</front>
<front id="SdInfoH-242">  // byte 12</front>
<front id="SdInfoH-243">  /** write_bl_len fixed for 512 byte blocks */</front>
<front id="SdInfoH-244">  unsigned char write_bl_len_high : 2;</front>
<front id="SdInfoH-245">  /** fixed value of 2 */</front>
<front id="SdInfoH-246">  unsigned char r2w_factor : 3;</front>
<front id="SdInfoH-247">  /** not used */</front>
<front id="SdInfoH-248">  unsigned char reserved5 : 2;</front>
<front id="SdInfoH-249">  /** fixed value of 0 - no write protect groups */</front>
<front id="SdInfoH-250">  unsigned char wp_grp_enable : 1;</front>
<front id="SdInfoH-251">  // byte 13</front>
<front id="SdInfoH-252">  unsigned char reserved6 : 5;</front>
<front id="SdInfoH-253">  /** always zero - no partial block read*/</front>
<front id="SdInfoH-254">  unsigned char write_partial : 1;</front>
<front id="SdInfoH-255">  /** write_bl_len fixed for 512 byte blocks */</front>
<front id="SdInfoH-256">  unsigned char write_bl_len_low : 2;</front>
<front id="SdInfoH-257">  // byte 14</front>
<front id="SdInfoH-258">  unsigned char reserved7: 2;</front>
<front id="SdInfoH-259">  /** Do not use always 0 */</front>
<front id="SdInfoH-260">  unsigned char file_format : 2;</front>
<front id="SdInfoH-261">  unsigned char tmp_write_protect : 1;</front>
<front id="SdInfoH-262">  unsigned char perm_write_protect : 1;</front>
<front id="SdInfoH-263">  unsigned char copy : 1;</front>
<front id="SdInfoH-264">  /** Do not use always 0 */</front>
<front id="SdInfoH-265">  unsigned char file_format_grp : 1;</front>
<front id="SdInfoH-266">  // byte 15</front>
<front id="SdInfoH-267">  /** not used always 1 */</front>
<front id="SdInfoH-268">  unsigned char always1 : 1;</front>
<front id="SdInfoH-269">  /** checksum */</front>
<front id="SdInfoH-270">  unsigned char crc : 7;</front>
<front id="SdInfoH-271">}csd2_t;</front>
<front id="SdInfoH-272">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-273">/** union of old and new style CSD register */</front>
<front id="SdInfoH-274">union csd_t {</front>
<front id="SdInfoH-275">  csd1_t v1;</front>
<front id="SdInfoH-276">  csd2_t v2;</front>
<front id="SdInfoH-277">};</front>
<front id="SdInfoH-278">#endif  // SdInfo_h</front>
<front id="SdInfoH-279"></front>
<front id="SdInfoH-280">#endif</front>
 </pre>
<h1>SdVolume.cpp</h1>
<pre  class="prettyprint linenums"><front id="SdVolumeCPP-1">/* Arduino SdFat Library</front>
<front id="SdVolumeCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdVolumeCPP-3"> *</front>
<front id="SdVolumeCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdVolumeCPP-5"> *</front>
<front id="SdVolumeCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdVolumeCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdVolumeCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdVolumeCPP-9"> * (at your option) any later version.</front>
<front id="SdVolumeCPP-10"> *</front>
<front id="SdVolumeCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdVolumeCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdVolumeCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdVolumeCPP-14"> * GNU General Public License for more details.</front>
<front id="SdVolumeCPP-15"> *</front>
<front id="SdVolumeCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdVolumeCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdVolumeCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdVolumeCPP-19"> */</front>
<front id="SdVolumeCPP-20">#include "Marlin.h"</front>
<front id="SdVolumeCPP-21">#ifdef SDSUPPORT</front>
<front id="SdVolumeCPP-22"></front>
<front id="SdVolumeCPP-23">#include "SdVolume.h"</front>
<front id="SdVolumeCPP-24">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-25">#if !USE_MULTIPLE_CARDS</front>
<front id="SdVolumeCPP-26">// raw block cache</front>
<front id="SdVolumeCPP-27">uint32_t SdVolume::cacheBlockNumber_;  // current block number</front>
<front id="SdVolumeCPP-28">cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card</front>
<front id="SdVolumeCPP-29">Sd2Card* SdVolume::sdCard_;            // pointer to SD card object</front>
<front id="SdVolumeCPP-30">bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true</front>
<front id="SdVolumeCPP-31">uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT</front>
<front id="SdVolumeCPP-32">#endif  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeCPP-33">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-34">// find a contiguous group of clusters</front>
<front id="SdVolumeCPP-35">bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {</front>
<front id="SdVolumeCPP-36">  // start of group</front>
<front id="SdVolumeCPP-37">  uint32_t bgnCluster;</front>
<front id="SdVolumeCPP-38">  // end of group</front>
<front id="SdVolumeCPP-39">  uint32_t endCluster;</front>
<front id="SdVolumeCPP-40">  // last cluster of FAT</front>
<front id="SdVolumeCPP-41">  uint32_t fatEnd = clusterCount_ + 1;</front>
<front id="SdVolumeCPP-42"></front>
<front id="SdVolumeCPP-43">  // flag to save place to start next search</front>
<front id="SdVolumeCPP-44">  bool setStart;</front>
<front id="SdVolumeCPP-45"></front>
<front id="SdVolumeCPP-46">  // set search start cluster</front>
<front id="SdVolumeCPP-47">  if (*curCluster) {</front>
<front id="SdVolumeCPP-48">    // try to make file contiguous</front>
<front id="SdVolumeCPP-49">    bgnCluster = *curCluster + 1;</front>
<front id="SdVolumeCPP-50"></front>
<front id="SdVolumeCPP-51">    // don't save new start location</front>
<front id="SdVolumeCPP-52">    setStart = false;</front>
<front id="SdVolumeCPP-53">  } else {</front>
<front id="SdVolumeCPP-54">    // start at likely place for free cluster</front>
<front id="SdVolumeCPP-55">    bgnCluster = allocSearchStart_;</front>
<front id="SdVolumeCPP-56"></front>
<front id="SdVolumeCPP-57">    // save next search start if one cluster</front>
<front id="SdVolumeCPP-58">    setStart = count == 1;</front>
<front id="SdVolumeCPP-59">  }</front>
<front id="SdVolumeCPP-60">  // end of group</front>
<front id="SdVolumeCPP-61">  endCluster = bgnCluster;</front>
<front id="SdVolumeCPP-62"></front>
<front id="SdVolumeCPP-63">  // search the FAT for free clusters</front>
<front id="SdVolumeCPP-64">  for (uint32_t n = 0;; n++, endCluster++) {</front>
<front id="SdVolumeCPP-65">    // can't find space checked all clusters</front>
<front id="SdVolumeCPP-66">    if (n &gt;= clusterCount_) goto fail;</front>
<front id="SdVolumeCPP-67"></front>
<front id="SdVolumeCPP-68">    // past end - start from beginning of FAT</front>
<front id="SdVolumeCPP-69">    if (endCluster &gt; fatEnd) {</front>
<front id="SdVolumeCPP-70">      bgnCluster = endCluster = 2;</front>
<front id="SdVolumeCPP-71">    }</front>
<front id="SdVolumeCPP-72">    uint32_t f;</front>
<front id="SdVolumeCPP-73">    if (!fatGet(endCluster, &f)) goto fail;</front>
<front id="SdVolumeCPP-74"></front>
<front id="SdVolumeCPP-75">    if (f != 0) {</front>
<front id="SdVolumeCPP-76">      // cluster in use try next cluster as bgnCluster</front>
<front id="SdVolumeCPP-77">      bgnCluster = endCluster + 1;</front>
<front id="SdVolumeCPP-78">    } else if ((endCluster - bgnCluster + 1) == count) {</front>
<front id="SdVolumeCPP-79">      // done - found space</front>
<front id="SdVolumeCPP-80">      break;</front>
<front id="SdVolumeCPP-81">    }</front>
<front id="SdVolumeCPP-82">  }</front>
<front id="SdVolumeCPP-83">  // mark end of chain</front>
<front id="SdVolumeCPP-84">  if (!fatPutEOC(endCluster)) goto fail;</front>
<front id="SdVolumeCPP-85"></front>
<front id="SdVolumeCPP-86">  // link clusters</front>
<front id="SdVolumeCPP-87">  while (endCluster &gt; bgnCluster) {</front>
<front id="SdVolumeCPP-88">    if (!fatPut(endCluster - 1, endCluster)) goto fail;</front>
<front id="SdVolumeCPP-89">    endCluster--;</front>
<front id="SdVolumeCPP-90">  }</front>
<front id="SdVolumeCPP-91">  if (*curCluster != 0) {</front>
<front id="SdVolumeCPP-92">    // connect chains</front>
<front id="SdVolumeCPP-93">    if (!fatPut(*curCluster, bgnCluster)) goto fail;</front>
<front id="SdVolumeCPP-94">  }</front>
<front id="SdVolumeCPP-95">  // return first cluster number to caller</front>
<front id="SdVolumeCPP-96">  *curCluster = bgnCluster;</front>
<front id="SdVolumeCPP-97"></front>
<front id="SdVolumeCPP-98">  // remember possible next free cluster</front>
<front id="SdVolumeCPP-99">  if (setStart) allocSearchStart_ = bgnCluster + 1;</front>
<front id="SdVolumeCPP-100"></front>
<front id="SdVolumeCPP-101">  return true;</front>
<front id="SdVolumeCPP-102"></front>
<front id="SdVolumeCPP-103"> fail:</front>
<front id="SdVolumeCPP-104">  return false;</front>
<front id="SdVolumeCPP-105">}</front>
<front id="SdVolumeCPP-106">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-107">bool SdVolume::cacheFlush() {</front>
<front id="SdVolumeCPP-108">  if (cacheDirty_) {</front>
<front id="SdVolumeCPP-109">    if (!sdCard_-&gt;writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {</front>
<front id="SdVolumeCPP-110">      goto fail;</front>
<front id="SdVolumeCPP-111">    }</front>
<front id="SdVolumeCPP-112">    // mirror FAT tables</front>
<front id="SdVolumeCPP-113">    if (cacheMirrorBlock_) {</front>
<front id="SdVolumeCPP-114">      if (!sdCard_-&gt;writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {</front>
<front id="SdVolumeCPP-115">        goto fail;</front>
<front id="SdVolumeCPP-116">      }</front>
<front id="SdVolumeCPP-117">      cacheMirrorBlock_ = 0;</front>
<front id="SdVolumeCPP-118">    }</front>
<front id="SdVolumeCPP-119">    cacheDirty_ = 0;</front>
<front id="SdVolumeCPP-120">  }</front>
<front id="SdVolumeCPP-121">  return true;</front>
<front id="SdVolumeCPP-122"></front>
<front id="SdVolumeCPP-123"> fail:</front>
<front id="SdVolumeCPP-124">  return false;</front>
<front id="SdVolumeCPP-125">}</front>
<front id="SdVolumeCPP-126">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-127">bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {</front>
<front id="SdVolumeCPP-128">  if (cacheBlockNumber_ != blockNumber) {</front>
<front id="SdVolumeCPP-129">    if (!cacheFlush()) goto fail;</front>
<front id="SdVolumeCPP-130">    if (!sdCard_-&gt;readBlock(blockNumber, cacheBuffer_.data)) goto fail;</front>
<front id="SdVolumeCPP-131">    cacheBlockNumber_ = blockNumber;</front>
<front id="SdVolumeCPP-132">  }</front>
<front id="SdVolumeCPP-133">  if (dirty) cacheDirty_ = true;</front>
<front id="SdVolumeCPP-134">  return true;</front>
<front id="SdVolumeCPP-135"></front>
<front id="SdVolumeCPP-136"> fail:</front>
<front id="SdVolumeCPP-137">  return false;</front>
<front id="SdVolumeCPP-138">}</front>
<front id="SdVolumeCPP-139">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-140">// return the size in bytes of a cluster chain</front>
<front id="SdVolumeCPP-141">bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {</front>
<front id="SdVolumeCPP-142">  uint32_t s = 0;</front>
<front id="SdVolumeCPP-143">  do {</front>
<front id="SdVolumeCPP-144">    if (!fatGet(cluster, &cluster)) goto fail;</front>
<front id="SdVolumeCPP-145">    s += 512UL &lt;&lt; clusterSizeShift_;</front>
<front id="SdVolumeCPP-146">  } while (!isEOC(cluster));</front>
<front id="SdVolumeCPP-147">  *size = s;</front>
<front id="SdVolumeCPP-148">  return true;</front>
<front id="SdVolumeCPP-149"></front>
<front id="SdVolumeCPP-150"> fail:</front>
<front id="SdVolumeCPP-151">  return false;</front>
<front id="SdVolumeCPP-152">}</front>
<front id="SdVolumeCPP-153">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-154">// Fetch a FAT entry</front>
<front id="SdVolumeCPP-155">bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {</front>
<front id="SdVolumeCPP-156">  uint32_t lba;</front>
<front id="SdVolumeCPP-157">  if (cluster &gt; (clusterCount_ + 1)) goto fail;</front>
<front id="SdVolumeCPP-158">  if (FAT12_SUPPORT && fatType_ == 12) {</front>
<front id="SdVolumeCPP-159">    uint16_t index = cluster;</front>
<front id="SdVolumeCPP-160">    index += index &gt;&gt; 1;</front>
<front id="SdVolumeCPP-161">    lba = fatStartBlock_ + (index &gt;&gt; 9);</front>
<front id="SdVolumeCPP-162">    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-163">    index &= 0X1FF;</front>
<front id="SdVolumeCPP-164">    uint16_t tmp = cacheBuffer_.data[index];</front>
<front id="SdVolumeCPP-165">    index++;</front>
<front id="SdVolumeCPP-166">    if (index == 512) {</front>
<front id="SdVolumeCPP-167">      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-168">      index = 0;</front>
<front id="SdVolumeCPP-169">    }</front>
<front id="SdVolumeCPP-170">    tmp |= cacheBuffer_.data[index] &lt;&lt; 8;</front>
<front id="SdVolumeCPP-171">    *value = cluster & 1 ? tmp &gt;&gt; 4 : tmp & 0XFFF;</front>
<front id="SdVolumeCPP-172">    return true;</front>
<front id="SdVolumeCPP-173">  }</front>
<front id="SdVolumeCPP-174">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-175">    lba = fatStartBlock_ + (cluster &gt;&gt; 8);</front>
<front id="SdVolumeCPP-176">  } else if (fatType_ == 32) {</front>
<front id="SdVolumeCPP-177">    lba = fatStartBlock_ + (cluster &gt;&gt; 7);</front>
<front id="SdVolumeCPP-178">  } else {</front>
<front id="SdVolumeCPP-179">    goto fail;</front>
<front id="SdVolumeCPP-180">  }</front>
<front id="SdVolumeCPP-181">  if (lba != cacheBlockNumber_) {</front>
<front id="SdVolumeCPP-182">    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-183">  }</front>
<front id="SdVolumeCPP-184">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-185">    *value = cacheBuffer_.fat16[cluster & 0XFF];</front>
<front id="SdVolumeCPP-186">  } else {</front>
<front id="SdVolumeCPP-187">    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;</front>
<front id="SdVolumeCPP-188">  }</front>
<front id="SdVolumeCPP-189">  return true;</front>
<front id="SdVolumeCPP-190"></front>
<front id="SdVolumeCPP-191"> fail:</front>
<front id="SdVolumeCPP-192">  return false;</front>
<front id="SdVolumeCPP-193">}</front>
<front id="SdVolumeCPP-194">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-195">// Store a FAT entry</front>
<front id="SdVolumeCPP-196">bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {</front>
<front id="SdVolumeCPP-197">  uint32_t lba;</front>
<front id="SdVolumeCPP-198">  // error if reserved cluster</front>
<front id="SdVolumeCPP-199">  if (cluster &lt; 2) goto fail;</front>
<front id="SdVolumeCPP-200"></front>
<front id="SdVolumeCPP-201">  // error if not in FAT</front>
<front id="SdVolumeCPP-202">  if (cluster &gt; (clusterCount_ + 1)) goto fail;</front>
<front id="SdVolumeCPP-203"></front>
<front id="SdVolumeCPP-204">  if (FAT12_SUPPORT && fatType_ == 12) {</front>
<front id="SdVolumeCPP-205">    uint16_t index = cluster;</front>
<front id="SdVolumeCPP-206">    index += index &gt;&gt; 1;</front>
<front id="SdVolumeCPP-207">    lba = fatStartBlock_ + (index &gt;&gt; 9);</front>
<front id="SdVolumeCPP-208">    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdVolumeCPP-209">    // mirror second FAT</front>
<front id="SdVolumeCPP-210">    if (fatCount_ &gt; 1) cacheMirrorBlock_ = lba + blocksPerFat_;</front>
<front id="SdVolumeCPP-211">    index &= 0X1FF;</front>
<front id="SdVolumeCPP-212">    uint8_t tmp = value;</front>
<front id="SdVolumeCPP-213">    if (cluster & 1) {</front>
<front id="SdVolumeCPP-214">      tmp = (cacheBuffer_.data[index] & 0XF) | tmp &lt;&lt; 4;</front>
<front id="SdVolumeCPP-215">    }</front>
<front id="SdVolumeCPP-216">    cacheBuffer_.data[index] = tmp;</front>
<front id="SdVolumeCPP-217">    index++;</front>
<front id="SdVolumeCPP-218">    if (index == 512) {</front>
<front id="SdVolumeCPP-219">      lba++;</front>
<front id="SdVolumeCPP-220">      index = 0;</front>
<front id="SdVolumeCPP-221">      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdVolumeCPP-222">      // mirror second FAT</front>
<front id="SdVolumeCPP-223">      if (fatCount_ &gt; 1) cacheMirrorBlock_ = lba + blocksPerFat_;</front>
<front id="SdVolumeCPP-224">    }</front>
<front id="SdVolumeCPP-225">    tmp = value &gt;&gt; 4;</front>
<front id="SdVolumeCPP-226">    if (!(cluster & 1)) {</front>
<front id="SdVolumeCPP-227">      tmp = ((cacheBuffer_.data[index] & 0XF0)) | tmp &gt;&gt; 4;</front>
<front id="SdVolumeCPP-228">    }</front>
<front id="SdVolumeCPP-229">    cacheBuffer_.data[index] = tmp;</front>
<front id="SdVolumeCPP-230">    return true;</front>
<front id="SdVolumeCPP-231">  }</front>
<front id="SdVolumeCPP-232">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-233">    lba = fatStartBlock_ + (cluster &gt;&gt; 8);</front>
<front id="SdVolumeCPP-234">  } else if (fatType_ == 32) {</front>
<front id="SdVolumeCPP-235">    lba = fatStartBlock_ + (cluster &gt;&gt; 7);</front>
<front id="SdVolumeCPP-236">  } else {</front>
<front id="SdVolumeCPP-237">    goto fail;</front>
<front id="SdVolumeCPP-238">  }</front>
<front id="SdVolumeCPP-239">  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdVolumeCPP-240">  // store entry</front>
<front id="SdVolumeCPP-241">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-242">    cacheBuffer_.fat16[cluster & 0XFF] = value;</front>
<front id="SdVolumeCPP-243">  } else {</front>
<front id="SdVolumeCPP-244">    cacheBuffer_.fat32[cluster & 0X7F] = value;</front>
<front id="SdVolumeCPP-245">  }</front>
<front id="SdVolumeCPP-246">  // mirror second FAT</front>
<front id="SdVolumeCPP-247">  if (fatCount_ &gt; 1) cacheMirrorBlock_ = lba + blocksPerFat_;</front>
<front id="SdVolumeCPP-248">  return true;</front>
<front id="SdVolumeCPP-249"></front>
<front id="SdVolumeCPP-250"> fail:</front>
<front id="SdVolumeCPP-251">  return false;</front>
<front id="SdVolumeCPP-252">}</front>
<front id="SdVolumeCPP-253">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-254">// free a cluster chain</front>
<front id="SdVolumeCPP-255">bool SdVolume::freeChain(uint32_t cluster) {</front>
<front id="SdVolumeCPP-256">  uint32_t next;</front>
<front id="SdVolumeCPP-257"></front>
<front id="SdVolumeCPP-258">  // clear free cluster location</front>
<front id="SdVolumeCPP-259">  allocSearchStart_ = 2;</front>
<front id="SdVolumeCPP-260"></front>
<front id="SdVolumeCPP-261">  do {</front>
<front id="SdVolumeCPP-262">    if (!fatGet(cluster, &next)) goto fail;</front>
<front id="SdVolumeCPP-263"></front>
<front id="SdVolumeCPP-264">    // free cluster</front>
<front id="SdVolumeCPP-265">    if (!fatPut(cluster, 0)) goto fail;</front>
<front id="SdVolumeCPP-266"></front>
<front id="SdVolumeCPP-267">    cluster = next;</front>
<front id="SdVolumeCPP-268">  } while (!isEOC(cluster));</front>
<front id="SdVolumeCPP-269"></front>
<front id="SdVolumeCPP-270">  return true;</front>
<front id="SdVolumeCPP-271"></front>
<front id="SdVolumeCPP-272"> fail:</front>
<front id="SdVolumeCPP-273">  return false;</front>
<front id="SdVolumeCPP-274">}</front>
<front id="SdVolumeCPP-275">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-276">/** Volume free space in clusters.</front>
<front id="SdVolumeCPP-277"> *</front>
<front id="SdVolumeCPP-278"> * \return Count of free clusters for success or -1 if an error occurs.</front>
<front id="SdVolumeCPP-279"> */</front>
<front id="SdVolumeCPP-280">int32_t SdVolume::freeClusterCount() {</front>
<front id="SdVolumeCPP-281">  uint32_t free = 0;</front>
<front id="SdVolumeCPP-282">  uint16_t n;</front>
<front id="SdVolumeCPP-283">  uint32_t todo = clusterCount_ + 2;</front>
<front id="SdVolumeCPP-284"></front>
<front id="SdVolumeCPP-285">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-286">    n = 256;</front>
<front id="SdVolumeCPP-287">  } else if (fatType_ == 32) {</front>
<front id="SdVolumeCPP-288">    n = 128;</front>
<front id="SdVolumeCPP-289">  } else {</front>
<front id="SdVolumeCPP-290">    // put FAT12 here</front>
<front id="SdVolumeCPP-291">    return -1;</front>
<front id="SdVolumeCPP-292">  }</front>
<front id="SdVolumeCPP-293"></front>
<front id="SdVolumeCPP-294">  for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {</front>
<front id="SdVolumeCPP-295">    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;</front>
<front id="SdVolumeCPP-296">    if (todo &lt; n) n = todo;</front>
<front id="SdVolumeCPP-297">    if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-298">      for (uint16_t i = 0; i &lt; n; i++) {</front>
<front id="SdVolumeCPP-299">        if (cacheBuffer_.fat16[i] == 0) free++;</front>
<front id="SdVolumeCPP-300">      }</front>
<front id="SdVolumeCPP-301">    } else {</front>
<front id="SdVolumeCPP-302">      for (uint16_t i = 0; i &lt; n; i++) {</front>
<front id="SdVolumeCPP-303">        if (cacheBuffer_.fat32[i] == 0) free++;</front>
<front id="SdVolumeCPP-304">      }</front>
<front id="SdVolumeCPP-305">    }</front>
<front id="SdVolumeCPP-306">  }</front>
<front id="SdVolumeCPP-307">  return free;</front>
<front id="SdVolumeCPP-308">}</front>
<front id="SdVolumeCPP-309">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-310">/** Initialize a FAT volume.</front>
<front id="SdVolumeCPP-311"> *</front>
<front id="SdVolumeCPP-312"> * \param[in] dev The SD card where the volume is located.</front>
<front id="SdVolumeCPP-313"> *</front>
<front id="SdVolumeCPP-314"> * \param[in] part The partition to be used.  Legal values for \a part are</front>
<front id="SdVolumeCPP-315"> * 1-4 to use the corresponding partition on a device formatted with</front>
<front id="SdVolumeCPP-316"> * a MBR, Master Boot Record, or zero if the device is formatted as</front>
<front id="SdVolumeCPP-317"> * a super floppy with the FAT boot sector in block zero.</front>
<front id="SdVolumeCPP-318"> *</front>
<front id="SdVolumeCPP-319"> * \return The value one, true, is returned for success and</front>
<front id="SdVolumeCPP-320"> * the value zero, false, is returned for failure.  Reasons for</front>
<front id="SdVolumeCPP-321"> * failure include not finding a valid partition, not finding a valid</front>
<front id="SdVolumeCPP-322"> * FAT file system in the specified partition or an I/O error.</front>
<front id="SdVolumeCPP-323"> */</front>
<front id="SdVolumeCPP-324">bool SdVolume::init(Sd2Card* dev, uint8_t part) {</front>
<front id="SdVolumeCPP-325">  uint32_t totalBlocks;</front>
<front id="SdVolumeCPP-326">  uint32_t volumeStartBlock = 0;</front>
<front id="SdVolumeCPP-327">  fat32_boot_t* fbs;</front>
<front id="SdVolumeCPP-328"></front>
<front id="SdVolumeCPP-329">  sdCard_ = dev;</front>
<front id="SdVolumeCPP-330">  fatType_ = 0;</front>
<front id="SdVolumeCPP-331">  allocSearchStart_ = 2;</front>
<front id="SdVolumeCPP-332">  cacheDirty_ = 0;  // cacheFlush() will write block if true</front>
<front id="SdVolumeCPP-333">  cacheMirrorBlock_ = 0;</front>
<front id="SdVolumeCPP-334">  cacheBlockNumber_ = 0XFFFFFFFF;</front>
<front id="SdVolumeCPP-335"></front>
<front id="SdVolumeCPP-336">  // if part == 0 assume super floppy with FAT boot sector in block zero</front>
<front id="SdVolumeCPP-337">  // if part &gt; 0 assume mbr volume with partition table</front>
<front id="SdVolumeCPP-338">  if (part) {</front>
<front id="SdVolumeCPP-339">    if (part &gt; 4)goto fail;</front>
<front id="SdVolumeCPP-340">    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-341">    part_t* p = &cacheBuffer_.mbr.part[part-1];</front>
<front id="SdVolumeCPP-342">    if ((p-&gt;boot & 0X7F) !=0  ||</front>
<front id="SdVolumeCPP-343">      p-&gt;totalSectors &lt; 100 ||</front>
<front id="SdVolumeCPP-344">      p-&gt;firstSector == 0) {</front>
<front id="SdVolumeCPP-345">      // not a valid partition</front>
<front id="SdVolumeCPP-346">      goto fail;</front>
<front id="SdVolumeCPP-347">    }</front>
<front id="SdVolumeCPP-348">    volumeStartBlock = p-&gt;firstSector;</front>
<front id="SdVolumeCPP-349">  }</front>
<front id="SdVolumeCPP-350">  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-351">  fbs = &cacheBuffer_.fbs32;</front>
<front id="SdVolumeCPP-352">  if (fbs-&gt;bytesPerSector != 512 ||</front>
<front id="SdVolumeCPP-353">    fbs-&gt;fatCount == 0 ||</front>
<front id="SdVolumeCPP-354">    fbs-&gt;reservedSectorCount == 0 ||</front>
<front id="SdVolumeCPP-355">    fbs-&gt;sectorsPerCluster == 0) {</front>
<front id="SdVolumeCPP-356">       // not valid FAT volume</front>
<front id="SdVolumeCPP-357">      goto fail;</front>
<front id="SdVolumeCPP-358">  }</front>
<front id="SdVolumeCPP-359">  fatCount_ = fbs-&gt;fatCount;</front>
<front id="SdVolumeCPP-360">  blocksPerCluster_ = fbs-&gt;sectorsPerCluster;</front>
<front id="SdVolumeCPP-361">  // determine shift that is same as multiply by blocksPerCluster_</front>
<front id="SdVolumeCPP-362">  clusterSizeShift_ = 0;</front>
<front id="SdVolumeCPP-363">  while (blocksPerCluster_ != (1 &lt;&lt; clusterSizeShift_)) {</front>
<front id="SdVolumeCPP-364">    // error if not power of 2</front>
<front id="SdVolumeCPP-365">    if (clusterSizeShift_++ &gt; 7) goto fail;</front>
<front id="SdVolumeCPP-366">  }</front>
<front id="SdVolumeCPP-367">  blocksPerFat_ = fbs-&gt;sectorsPerFat16 ?</front>
<front id="SdVolumeCPP-368">                    fbs-&gt;sectorsPerFat16 : fbs-&gt;sectorsPerFat32;</front>
<front id="SdVolumeCPP-369"></front>
<front id="SdVolumeCPP-370">  fatStartBlock_ = volumeStartBlock + fbs-&gt;reservedSectorCount;</front>
<front id="SdVolumeCPP-371"></front>
<front id="SdVolumeCPP-372">  // count for FAT16 zero for FAT32</front>
<front id="SdVolumeCPP-373">  rootDirEntryCount_ = fbs-&gt;rootDirEntryCount;</front>
<front id="SdVolumeCPP-374"></front>
<front id="SdVolumeCPP-375">  // directory start for FAT16 dataStart for FAT32</front>
<front id="SdVolumeCPP-376">  rootDirStart_ = fatStartBlock_ + fbs-&gt;fatCount * blocksPerFat_;</front>
<front id="SdVolumeCPP-377"></front>
<front id="SdVolumeCPP-378">  // data start for FAT16 and FAT32</front>
<front id="SdVolumeCPP-379">  dataStartBlock_ = rootDirStart_ + ((32 * fbs-&gt;rootDirEntryCount + 511)/512);</front>
<front id="SdVolumeCPP-380"></front>
<front id="SdVolumeCPP-381">  // total blocks for FAT16 or FAT32</front>
<front id="SdVolumeCPP-382">  totalBlocks = fbs-&gt;totalSectors16 ?</front>
<front id="SdVolumeCPP-383">                           fbs-&gt;totalSectors16 : fbs-&gt;totalSectors32;</front>
<front id="SdVolumeCPP-384">  // total data blocks</front>
<front id="SdVolumeCPP-385">  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);</front>
<front id="SdVolumeCPP-386"></front>
<front id="SdVolumeCPP-387">  // divide by cluster size to get cluster count</front>
<front id="SdVolumeCPP-388">  clusterCount_ &gt;&gt;= clusterSizeShift_;</front>
<front id="SdVolumeCPP-389"></front>
<front id="SdVolumeCPP-390">  // FAT type is determined by cluster count</front>
<front id="SdVolumeCPP-391">  if (clusterCount_ &lt; 4085) {</front>
<front id="SdVolumeCPP-392">    fatType_ = 12;</front>
<front id="SdVolumeCPP-393">    if (!FAT12_SUPPORT) goto fail;</front>
<front id="SdVolumeCPP-394">  } else if (clusterCount_ &lt; 65525) {</front>
<front id="SdVolumeCPP-395">    fatType_ = 16;</front>
<front id="SdVolumeCPP-396">  } else {</front>
<front id="SdVolumeCPP-397">    rootDirStart_ = fbs-&gt;fat32RootCluster;</front>
<front id="SdVolumeCPP-398">    fatType_ = 32;</front>
<front id="SdVolumeCPP-399">  }</front>
<front id="SdVolumeCPP-400">  return true;</front>
<front id="SdVolumeCPP-401"></front>
<front id="SdVolumeCPP-402"> fail:</front>
<front id="SdVolumeCPP-403">  return false;</front>
<front id="SdVolumeCPP-404">}</front>
<front id="SdVolumeCPP-405">#endif</front>
 </pre>
<h1>SdVolume.h</h1>
<pre  class="prettyprint linenums"><front id="SdVolumeH-1">/* Arduino SdFat Library</front>
<front id="SdVolumeH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdVolumeH-3"> *</front>
<front id="SdVolumeH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdVolumeH-5"> *</front>
<front id="SdVolumeH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdVolumeH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdVolumeH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdVolumeH-9"> * (at your option) any later version.</front>
<front id="SdVolumeH-10"> *</front>
<front id="SdVolumeH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdVolumeH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdVolumeH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdVolumeH-14"> * GNU General Public License for more details.</front>
<front id="SdVolumeH-15"> *</front>
<front id="SdVolumeH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdVolumeH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdVolumeH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdVolumeH-19"> */</front>
<front id="SdVolumeH-20">#include "Marlin.h"</front>
<front id="SdVolumeH-21">#ifdef SDSUPPORT</front>
<front id="SdVolumeH-22">#ifndef SdVolume_h</front>
<front id="SdVolumeH-23">#define SdVolume_h</front>
<front id="SdVolumeH-24">/**</front>
<front id="SdVolumeH-25"> * \file</front>
<front id="SdVolumeH-26"> * \brief SdVolume class</front>
<front id="SdVolumeH-27"> */</front>
<front id="SdVolumeH-28">#include "SdFatConfig.h"</front>
<front id="SdVolumeH-29">#include "Sd2Card.h"</front>
<front id="SdVolumeH-30">#include "SdFatStructs.h"</front>
<front id="SdVolumeH-31"></front>
<front id="SdVolumeH-32">//==============================================================================</front>
<front id="SdVolumeH-33">// SdVolume class</front>
<front id="SdVolumeH-34">/**</front>
<front id="SdVolumeH-35"> * \brief Cache for an SD data block</front>
<front id="SdVolumeH-36"> */</front>
<front id="SdVolumeH-37">union cache_t {</front>
<front id="SdVolumeH-38">           /** Used to access cached file data blocks. */</front>
<front id="SdVolumeH-39">  uint8_t  data[512];</front>
<front id="SdVolumeH-40">           /** Used to access cached FAT16 entries. */</front>
<front id="SdVolumeH-41">  uint16_t fat16[256];</front>
<front id="SdVolumeH-42">           /** Used to access cached FAT32 entries. */</front>
<front id="SdVolumeH-43">  uint32_t fat32[128];</front>
<front id="SdVolumeH-44">           /** Used to access cached directory entries. */</front>
<front id="SdVolumeH-45">  dir_t    dir[16];</front>
<front id="SdVolumeH-46">           /** Used to access a cached Master Boot Record. */</front>
<front id="SdVolumeH-47">  mbr_t    mbr;</front>
<front id="SdVolumeH-48">           /** Used to access to a cached FAT boot sector. */</front>
<front id="SdVolumeH-49">  fat_boot_t fbs;</front>
<front id="SdVolumeH-50">           /** Used to access to a cached FAT32 boot sector. */</front>
<front id="SdVolumeH-51">  fat32_boot_t fbs32;</front>
<front id="SdVolumeH-52">           /** Used to access to a cached FAT32 FSINFO sector. */</front>
<front id="SdVolumeH-53">  fat32_fsinfo_t fsinfo;</front>
<front id="SdVolumeH-54">};</front>
<front id="SdVolumeH-55">//------------------------------------------------------------------------------</front>
<front id="SdVolumeH-56">/**</front>
<front id="SdVolumeH-57"> * \class SdVolume</front>
<front id="SdVolumeH-58"> * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.</front>
<front id="SdVolumeH-59"> */</front>
<front id="SdVolumeH-60">class SdVolume {</front>
<front id="SdVolumeH-61"> public:</front>
<front id="SdVolumeH-62">  /** Create an instance of SdVolume */</front>
<front id="SdVolumeH-63">  SdVolume() : fatType_(0) {}</front>
<front id="SdVolumeH-64">  /** Clear the cache and returns a pointer to the cache.  Used by the WaveRP</front>
<front id="SdVolumeH-65">   * recorder to do raw write to the SD card.  Not for normal apps.</front>
<front id="SdVolumeH-66">   * \return A pointer to the cache buffer or zero if an error occurs.</front>
<front id="SdVolumeH-67">   */</front>
<front id="SdVolumeH-68">  cache_t* cacheClear() {</front>
<front id="SdVolumeH-69">    if (!cacheFlush()) return 0;</front>
<front id="SdVolumeH-70">    cacheBlockNumber_ = 0XFFFFFFFF;</front>
<front id="SdVolumeH-71">    return &cacheBuffer_;</front>
<front id="SdVolumeH-72">  }</front>
<front id="SdVolumeH-73">  /** Initialize a FAT volume.  Try partition one first then try super</front>
<front id="SdVolumeH-74">   * floppy format.</front>
<front id="SdVolumeH-75">   *</front>
<front id="SdVolumeH-76">   * \param[in] dev The Sd2Card where the volume is located.</front>
<front id="SdVolumeH-77">   *</front>
<front id="SdVolumeH-78">   * \return The value one, true, is returned for success and</front>
<front id="SdVolumeH-79">   * the value zero, false, is returned for failure.  Reasons for</front>
<front id="SdVolumeH-80">   * failure include not finding a valid partition, not finding a valid</front>
<front id="SdVolumeH-81">   * FAT file system or an I/O error.</front>
<front id="SdVolumeH-82">   */</front>
<front id="SdVolumeH-83">  bool init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}</front>
<front id="SdVolumeH-84">  bool init(Sd2Card* dev, uint8_t part);</front>
<front id="SdVolumeH-85"></front>
<front id="SdVolumeH-86">  // inline functions that return volume info</front>
<front id="SdVolumeH-87">  /** \return The volume's cluster size in blocks. */</front>
<front id="SdVolumeH-88">  uint8_t blocksPerCluster() const {return blocksPerCluster_;}</front>
<front id="SdVolumeH-89">  /** \return The number of blocks in one FAT. */</front>
<front id="SdVolumeH-90">  uint32_t blocksPerFat()  const {return blocksPerFat_;}</front>
<front id="SdVolumeH-91">  /** \return The total number of clusters in the volume. */</front>
<front id="SdVolumeH-92">  uint32_t clusterCount() const {return clusterCount_;}</front>
<front id="SdVolumeH-93">  /** \return The shift count required to multiply by blocksPerCluster. */</front>
<front id="SdVolumeH-94">  uint8_t clusterSizeShift() const {return clusterSizeShift_;}</front>
<front id="SdVolumeH-95">  /** \return The logical block number for the start of file data. */</front>
<front id="SdVolumeH-96">  uint32_t dataStartBlock() const {return dataStartBlock_;}</front>
<front id="SdVolumeH-97">  /** \return The number of FAT structures on the volume. */</front>
<front id="SdVolumeH-98">  uint8_t fatCount() const {return fatCount_;}</front>
<front id="SdVolumeH-99">  /** \return The logical block number for the start of the first FAT. */</front>
<front id="SdVolumeH-100">  uint32_t fatStartBlock() const {return fatStartBlock_;}</front>
<front id="SdVolumeH-101">  /** \return The FAT type of the volume. Values are 12, 16 or 32. */</front>
<front id="SdVolumeH-102">  uint8_t fatType() const {return fatType_;}</front>
<front id="SdVolumeH-103">  int32_t freeClusterCount();</front>
<front id="SdVolumeH-104">  /** \return The number of entries in the root directory for FAT16 volumes. */</front>
<front id="SdVolumeH-105">  uint32_t rootDirEntryCount() const {return rootDirEntryCount_;}</front>
<front id="SdVolumeH-106">  /** \return The logical block number for the start of the root directory</front>
<front id="SdVolumeH-107">       on FAT16 volumes or the first cluster number on FAT32 volumes. */</front>
<front id="SdVolumeH-108">  uint32_t rootDirStart() const {return rootDirStart_;}</front>
<front id="SdVolumeH-109">  /** Sd2Card object for this volume</front>
<front id="SdVolumeH-110">   * \return pointer to Sd2Card object.</front>
<front id="SdVolumeH-111">   */</front>
<front id="SdVolumeH-112">  Sd2Card* sdCard() {return sdCard_;}</front>
<front id="SdVolumeH-113">  /** Debug access to FAT table</front>
<front id="SdVolumeH-114">   *</front>
<front id="SdVolumeH-115">   * \param[in] n cluster number.</front>
<front id="SdVolumeH-116">   * \param[out] v value of entry</front>
<front id="SdVolumeH-117">   * \return true for success or false for failure</front>
<front id="SdVolumeH-118">   */</front>
<front id="SdVolumeH-119">  bool dbgFat(uint32_t n, uint32_t* v) {return fatGet(n, v);}</front>
<front id="SdVolumeH-120">//------------------------------------------------------------------------------</front>
<front id="SdVolumeH-121"> private:</front>
<front id="SdVolumeH-122">  // Allow SdBaseFile access to SdVolume private data.</front>
<front id="SdVolumeH-123">  friend class SdBaseFile;</front>
<front id="SdVolumeH-124"></front>
<front id="SdVolumeH-125">  // value for dirty argument in cacheRawBlock to indicate read from cache</front>
<front id="SdVolumeH-126">  static bool const CACHE_FOR_READ = false;</front>
<front id="SdVolumeH-127">  // value for dirty argument in cacheRawBlock to indicate write to cache</front>
<front id="SdVolumeH-128">  static bool const CACHE_FOR_WRITE = true;</front>
<front id="SdVolumeH-129"></front>
<front id="SdVolumeH-130">#if USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-131">  cache_t cacheBuffer_;        // 512 byte cache for device blocks</front>
<front id="SdVolumeH-132">  uint32_t cacheBlockNumber_;  // Logical number of block in the cache</front>
<front id="SdVolumeH-133">  Sd2Card* sdCard_;            // Sd2Card object for cache</front>
<front id="SdVolumeH-134">  bool cacheDirty_;            // cacheFlush() will write block if true</front>
<front id="SdVolumeH-135">  uint32_t cacheMirrorBlock_;  // block number for mirror FAT</front>
<front id="SdVolumeH-136">#else  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-137">  static cache_t cacheBuffer_;        // 512 byte cache for device blocks</front>
<front id="SdVolumeH-138">  static uint32_t cacheBlockNumber_;  // Logical number of block in the cache</front>
<front id="SdVolumeH-139">  static Sd2Card* sdCard_;            // Sd2Card object for cache</front>
<front id="SdVolumeH-140">  static bool cacheDirty_;            // cacheFlush() will write block if true</front>
<front id="SdVolumeH-141">  static uint32_t cacheMirrorBlock_;  // block number for mirror FAT</front>
<front id="SdVolumeH-142">#endif  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-143">  uint32_t allocSearchStart_;   // start cluster for alloc search</front>
<front id="SdVolumeH-144">  uint8_t blocksPerCluster_;    // cluster size in blocks</front>
<front id="SdVolumeH-145">  uint32_t blocksPerFat_;       // FAT size in blocks</front>
<front id="SdVolumeH-146">  uint32_t clusterCount_;       // clusters in one FAT</front>
<front id="SdVolumeH-147">  uint8_t clusterSizeShift_;    // shift to convert cluster count to block count</front>
<front id="SdVolumeH-148">  uint32_t dataStartBlock_;     // first data block number</front>
<front id="SdVolumeH-149">  uint8_t fatCount_;            // number of FATs on volume</front>
<front id="SdVolumeH-150">  uint32_t fatStartBlock_;      // start block for first FAT</front>
<front id="SdVolumeH-151">  uint8_t fatType_;             // volume type (12, 16, OR 32)</front>
<front id="SdVolumeH-152">  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir</front>
<front id="SdVolumeH-153">  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32</front>
<front id="SdVolumeH-154">  //----------------------------------------------------------------------------</front>
<front id="SdVolumeH-155">  bool allocContiguous(uint32_t count, uint32_t* curCluster);</front>
<front id="SdVolumeH-156">  uint8_t blockOfCluster(uint32_t position) const {</front>
<front id="SdVolumeH-157">          return (position &gt;&gt; 9) & (blocksPerCluster_ - 1);}</front>
<front id="SdVolumeH-158">  uint32_t clusterStartBlock(uint32_t cluster) const {</front>
<front id="SdVolumeH-159">           return dataStartBlock_ + ((cluster - 2) &lt;&lt; clusterSizeShift_);}</front>
<front id="SdVolumeH-160">  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {</front>
<front id="SdVolumeH-161">           return clusterStartBlock(cluster) + blockOfCluster(position);}</front>
<front id="SdVolumeH-162">  cache_t *cache() {return &cacheBuffer_;}</front>
<front id="SdVolumeH-163">  uint32_t cacheBlockNumber() {return cacheBlockNumber_;}</front>
<front id="SdVolumeH-164">#if USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-165">  bool cacheFlush();</front>
<front id="SdVolumeH-166">  bool cacheRawBlock(uint32_t blockNumber, bool dirty);</front>
<front id="SdVolumeH-167">#else  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-168">  static bool cacheFlush();</front>
<front id="SdVolumeH-169">  static bool cacheRawBlock(uint32_t blockNumber, bool dirty);</front>
<front id="SdVolumeH-170">#endif  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-171">  // used by SdBaseFile write to assign cache to SD location</front>
<front id="SdVolumeH-172">  void cacheSetBlockNumber(uint32_t blockNumber, bool dirty) {</front>
<front id="SdVolumeH-173">    cacheDirty_ = dirty;</front>
<front id="SdVolumeH-174">    cacheBlockNumber_  = blockNumber;</front>
<front id="SdVolumeH-175">  }</front>
<front id="SdVolumeH-176">  void cacheSetDirty() {cacheDirty_ |= CACHE_FOR_WRITE;}</front>
<front id="SdVolumeH-177">  bool chainSize(uint32_t beginCluster, uint32_t* size);</front>
<front id="SdVolumeH-178">  bool fatGet(uint32_t cluster, uint32_t* value);</front>
<front id="SdVolumeH-179">  bool fatPut(uint32_t cluster, uint32_t value);</front>
<front id="SdVolumeH-180">  bool fatPutEOC(uint32_t cluster) {</front>
<front id="SdVolumeH-181">    return fatPut(cluster, 0x0FFFFFFF);</front>
<front id="SdVolumeH-182">  }</front>
<front id="SdVolumeH-183">  bool freeChain(uint32_t cluster);</front>
<front id="SdVolumeH-184">  bool isEOC(uint32_t cluster) const {</front>
<front id="SdVolumeH-185">    if (FAT12_SUPPORT && fatType_ == 12) return  cluster &gt;= FAT12EOC_MIN;</front>
<front id="SdVolumeH-186">    if (fatType_ == 16) return cluster &gt;= FAT16EOC_MIN;</front>
<front id="SdVolumeH-187">    return  cluster &gt;= FAT32EOC_MIN;</front>
<front id="SdVolumeH-188">  }</front>
<front id="SdVolumeH-189">  bool readBlock(uint32_t block, uint8_t* dst) {</front>
<front id="SdVolumeH-190">    return sdCard_-&gt;readBlock(block, dst);}</front>
<front id="SdVolumeH-191">  bool writeBlock(uint32_t block, const uint8_t* dst) {</front>
<front id="SdVolumeH-192">    return sdCard_-&gt;writeBlock(block, dst);</front>
<front id="SdVolumeH-193">  }</front>
<front id="SdVolumeH-194">//------------------------------------------------------------------------------</front>
<front id="SdVolumeH-195">  // Deprecated functions  - suppress cpplint warnings with NOLINT comment</front>
<front id="SdVolumeH-196">#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)</front>
<front id="SdVolumeH-197"> public:</front>
<front id="SdVolumeH-198">  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev);</front>
<front id="SdVolumeH-199">   * \param[in] dev The SD card where the volume is located.</front>
<front id="SdVolumeH-200">   * \return true for success or false for failure.</front>
<front id="SdVolumeH-201">   */</front>
<front id="SdVolumeH-202">  bool init(Sd2Card& dev) {return init(&dev);}  // NOLINT</front>
<front id="SdVolumeH-203">  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev, uint8_t vol);</front>
<front id="SdVolumeH-204">   * \param[in] dev The SD card where the volume is located.</front>
<front id="SdVolumeH-205">   * \param[in] part The partition to be used.</front>
<front id="SdVolumeH-206">   * \return true for success or false for failure.</front>
<front id="SdVolumeH-207">   */</front>
<front id="SdVolumeH-208">  bool init(Sd2Card& dev, uint8_t part) {  // NOLINT</front>
<front id="SdVolumeH-209">    return init(&dev, part);</front>
<front id="SdVolumeH-210">  }</front>
<front id="SdVolumeH-211">#endif  // ALLOW_DEPRECATED_FUNCTIONS</front>
<front id="SdVolumeH-212">};</front>
<front id="SdVolumeH-213">#endif  // SdVolume</front>
<front id="SdVolumeH-214">#endif</front>
 </pre>
<h1>Servo.cpp</h1>
<pre  class="prettyprint linenums"><front id="ServoCPP-1">/*</front>
<front id="ServoCPP-2"> Servo.cpp - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2</front>
<front id="ServoCPP-3"> Copyright (c) 2009 Michael Margolis.  All right reserved.</front>
<front id="ServoCPP-4"></front>
<front id="ServoCPP-5"> This library is free software; you can redistribute it and/or</front>
<front id="ServoCPP-6"> modify it under the terms of the GNU Lesser General Public</front>
<front id="ServoCPP-7"> License as published by the Free Software Foundation; either</front>
<front id="ServoCPP-8"> version 2.1 of the License, or (at your option) any later version.</front>
<front id="ServoCPP-9"></front>
<front id="ServoCPP-10"> This library is distributed in the hope that it will be useful,</front>
<front id="ServoCPP-11"> but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="ServoCPP-12"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="ServoCPP-13"> Lesser General Public License for more details.</front>
<front id="ServoCPP-14"></front>
<front id="ServoCPP-15"> You should have received a copy of the GNU Lesser General Public</front>
<front id="ServoCPP-16"> License along with this library; if not, write to the Free Software</front>
<front id="ServoCPP-17"> Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="ServoCPP-18"> */</front>
<front id="ServoCPP-19"></front>
<front id="ServoCPP-20">/*</front>
<front id="ServoCPP-21"></front>
<front id="ServoCPP-22"> A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.</front>
<front id="ServoCPP-23"> The servos are pulsed in the background using the value most recently written using the write() method</front>
<front id="ServoCPP-24"></front>
<front id="ServoCPP-25"> Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.</front>
<front id="ServoCPP-26"> Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.</front>
<front id="ServoCPP-27"></front>
<front id="ServoCPP-28"> The methods are:</front>
<front id="ServoCPP-29"></front>
<front id="ServoCPP-30"> Servo - Class for manipulating servo motors connected to Arduino pins.</front>
<front id="ServoCPP-31"></front>
<front id="ServoCPP-32"> attach(pin )  - Attaches a servo motor to an i/o pin.</front>
<front id="ServoCPP-33"> attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds</front>
<front id="ServoCPP-34"> default min is 544, max is 2400</front>
<front id="ServoCPP-35"></front>
<front id="ServoCPP-36"> write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)</front>
<front id="ServoCPP-37"> writeMicroseconds() - Sets the servo pulse width in microseconds</front>
<front id="ServoCPP-38"> read()      - Gets the last written servo pulse width as an angle between 0 and 180.</front>
<front id="ServoCPP-39"> readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)</front>
<front id="ServoCPP-40"> attached()  - Returns true if there is a servo attached.</front>
<front id="ServoCPP-41"> detach()    - Stops an attached servos from pulsing its i/o pin.</front>
<front id="ServoCPP-42"></front>
<front id="ServoCPP-43">*/</front>
<front id="ServoCPP-44">#include "Configuration.h" </front>
<front id="ServoCPP-45"></front>
<front id="ServoCPP-46">#ifdef NUM_SERVOS</front>
<front id="ServoCPP-47">#include &lt;avr/interrupt.h&gt;</front>
<front id="ServoCPP-48">#include &lt;Arduino.h&gt;</front>
<front id="ServoCPP-49"></front>
<front id="ServoCPP-50">#include "Servo.h"</front>
<front id="ServoCPP-51"></front>
<front id="ServoCPP-52">#define usToTicks(_us)    (( clockCyclesPerMicrosecond()* _us) / 8)     // converts microseconds to tick (assumes prescale of 8)  // 12 Aug 2009</front>
<front id="ServoCPP-53">#define ticksToUs(_ticks) (( (unsigned)_ticks * 8)/ clockCyclesPerMicrosecond() ) // converts from ticks back to microseconds</front>
<front id="ServoCPP-54"></front>
<front id="ServoCPP-55"></front>
<front id="ServoCPP-56">#define TRIM_DURATION       2                               // compensation ticks to trim adjust for digitalWrite delays // 12 August 2009</front>
<front id="ServoCPP-57"></front>
<front id="ServoCPP-58">//#define NBR_TIMERS        (MAX_SERVOS / SERVOS_PER_TIMER)</front>
<front id="ServoCPP-59"></front>
<front id="ServoCPP-60">static servo_t servos[MAX_SERVOS];                          // static array of servo structures</front>
<front id="ServoCPP-61">static volatile int8_t Channel[_Nbr_16timers ];             // counter for the servo being pulsed for each timer (or -1 if refresh interval)</front>
<front id="ServoCPP-62"></front>
<front id="ServoCPP-63">uint8_t ServoCount = 0;                                     // the total number of attached servos</front>
<front id="ServoCPP-64"></front>
<front id="ServoCPP-65"></front>
<front id="ServoCPP-66">// convenience macros</front>
<front id="ServoCPP-67">#define SERVO_INDEX_TO_TIMER(_servo_nbr) ((timer16_Sequence_t)(_servo_nbr / SERVOS_PER_TIMER)) // returns the timer controlling this servo</front>
<front id="ServoCPP-68">#define SERVO_INDEX_TO_CHANNEL(_servo_nbr) (_servo_nbr % SERVOS_PER_TIMER)       // returns the index of the servo on this timer</front>
<front id="ServoCPP-69">#define SERVO_INDEX(_timer,_channel)  ((_timer*SERVOS_PER_TIMER) + _channel)     // macro to access servo index by timer and channel</front>
<front id="ServoCPP-70">#define SERVO(_timer,_channel)  (servos[SERVO_INDEX(_timer,_channel)])            // macro to access servo class by timer and channel</front>
<front id="ServoCPP-71"></front>
<front id="ServoCPP-72">#define SERVO_MIN() (MIN_PULSE_WIDTH - this-&gt;min * 4)  // minimum value in uS for this servo</front>
<front id="ServoCPP-73">#define SERVO_MAX() (MAX_PULSE_WIDTH - this-&gt;max * 4)  // maximum value in uS for this servo</front>
<front id="ServoCPP-74"></front>
<front id="ServoCPP-75">/************ static functions common to all instances ***********************/</front>
<front id="ServoCPP-76"></front>
<front id="ServoCPP-77">static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA)</front>
<front id="ServoCPP-78">{</front>
<front id="ServoCPP-79">  if( Channel[timer] &lt; 0 )</front>
<front id="ServoCPP-80">    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer</front>
<front id="ServoCPP-81">  else{</front>
<front id="ServoCPP-82">    if( SERVO_INDEX(timer,Channel[timer]) &lt; ServoCount && SERVO(timer,Channel[timer]).Pin.isActive == true )</front>
<front id="ServoCPP-83">      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated</front>
<front id="ServoCPP-84">  }</front>
<front id="ServoCPP-85"></front>
<front id="ServoCPP-86">  Channel[timer]++;    // increment to the next channel</front>
<front id="ServoCPP-87">  if( SERVO_INDEX(timer,Channel[timer]) &lt; ServoCount && Channel[timer] &lt; SERVOS_PER_TIMER) {</front>
<front id="ServoCPP-88">    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;</front>
<front id="ServoCPP-89">    if(SERVO(timer,Channel[timer]).Pin.isActive == true)     // check if activated</front>
<front id="ServoCPP-90">      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high</front>
<front id="ServoCPP-91">  }</front>
<front id="ServoCPP-92">  else {</front>
<front id="ServoCPP-93">    // finished all channels so wait for the refresh period to expire before starting over</front>
<front id="ServoCPP-94">    if( ((unsigned)*TCNTn) + 4 &lt; usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed</front>
<front id="ServoCPP-95">      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);</front>
<front id="ServoCPP-96">    else</front>
<front id="ServoCPP-97">      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed</front>
<front id="ServoCPP-98">    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel</front>
<front id="ServoCPP-99">  }</front>
<front id="ServoCPP-100">}</front>
<front id="ServoCPP-101"></front>
<front id="ServoCPP-102">#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform</front>
<front id="ServoCPP-103">// Interrupt handlers for Arduino</front>
<front id="ServoCPP-104">#if defined(_useTimer1)</front>
<front id="ServoCPP-105">SIGNAL (TIMER1_COMPA_vect)</front>
<front id="ServoCPP-106">{</front>
<front id="ServoCPP-107">  handle_interrupts(_timer1, &TCNT1, &OCR1A);</front>
<front id="ServoCPP-108">}</front>
<front id="ServoCPP-109">#endif</front>
<front id="ServoCPP-110"></front>
<front id="ServoCPP-111">#if defined(_useTimer3)</front>
<front id="ServoCPP-112">SIGNAL (TIMER3_COMPA_vect)</front>
<front id="ServoCPP-113">{</front>
<front id="ServoCPP-114">  handle_interrupts(_timer3, &TCNT3, &OCR3A);</front>
<front id="ServoCPP-115">}</front>
<front id="ServoCPP-116">#endif</front>
<front id="ServoCPP-117"></front>
<front id="ServoCPP-118">#if defined(_useTimer4)</front>
<front id="ServoCPP-119">SIGNAL (TIMER4_COMPA_vect)</front>
<front id="ServoCPP-120">{</front>
<front id="ServoCPP-121">  handle_interrupts(_timer4, &TCNT4, &OCR4A);</front>
<front id="ServoCPP-122">}</front>
<front id="ServoCPP-123">#endif</front>
<front id="ServoCPP-124"></front>
<front id="ServoCPP-125">#if defined(_useTimer5)</front>
<front id="ServoCPP-126">SIGNAL (TIMER5_COMPA_vect)</front>
<front id="ServoCPP-127">{</front>
<front id="ServoCPP-128">  handle_interrupts(_timer5, &TCNT5, &OCR5A);</front>
<front id="ServoCPP-129">}</front>
<front id="ServoCPP-130">#endif</front>
<front id="ServoCPP-131"></front>
<front id="ServoCPP-132">#elif defined WIRING</front>
<front id="ServoCPP-133">// Interrupt handlers for Wiring</front>
<front id="ServoCPP-134">#if defined(_useTimer1)</front>
<front id="ServoCPP-135">void Timer1Service()</front>
<front id="ServoCPP-136">{</front>
<front id="ServoCPP-137">  handle_interrupts(_timer1, &TCNT1, &OCR1A);</front>
<front id="ServoCPP-138">}</front>
<front id="ServoCPP-139">#endif</front>
<front id="ServoCPP-140">#if defined(_useTimer3)</front>
<front id="ServoCPP-141">void Timer3Service()</front>
<front id="ServoCPP-142">{</front>
<front id="ServoCPP-143">  handle_interrupts(_timer3, &TCNT3, &OCR3A);</front>
<front id="ServoCPP-144">}</front>
<front id="ServoCPP-145">#endif</front>
<front id="ServoCPP-146">#endif</front>
<front id="ServoCPP-147"></front>
<front id="ServoCPP-148"></front>
<front id="ServoCPP-149">static void initISR(timer16_Sequence_t timer)</front>
<front id="ServoCPP-150">{</front>
<front id="ServoCPP-151">#if defined (_useTimer1)</front>
<front id="ServoCPP-152">  if(timer == _timer1) {</front>
<front id="ServoCPP-153">    TCCR1A = 0;             // normal counting mode</front>
<front id="ServoCPP-154">    TCCR1B = _BV(CS11);     // set prescaler of 8</front>
<front id="ServoCPP-155">    TCNT1 = 0;              // clear the timer count</front>
<front id="ServoCPP-156">#if defined(__AVR_ATmega8__)|| defined(__AVR_ATmega128__)</front>
<front id="ServoCPP-157">    TIFR |= _BV(OCF1A);      // clear any pending interrupts;</front>
<front id="ServoCPP-158">    TIMSK |=  _BV(OCIE1A) ;  // enable the output compare interrupt</front>
<front id="ServoCPP-159">#else</front>
<front id="ServoCPP-160">    // here if not ATmega8 or ATmega128</front>
<front id="ServoCPP-161">    TIFR1 |= _BV(OCF1A);     // clear any pending interrupts;</front>
<front id="ServoCPP-162">    TIMSK1 |=  _BV(OCIE1A) ; // enable the output compare interrupt</front>
<front id="ServoCPP-163">#endif</front>
<front id="ServoCPP-164">#if defined(WIRING)</front>
<front id="ServoCPP-165">    timerAttach(TIMER1OUTCOMPAREA_INT, Timer1Service);</front>
<front id="ServoCPP-166">#endif</front>
<front id="ServoCPP-167">  }</front>
<front id="ServoCPP-168">#endif</front>
<front id="ServoCPP-169"></front>
<front id="ServoCPP-170">#if defined (_useTimer3)</front>
<front id="ServoCPP-171">  if(timer == _timer3) {</front>
<front id="ServoCPP-172">    TCCR3A = 0;             // normal counting mode</front>
<front id="ServoCPP-173">    TCCR3B = _BV(CS31);     // set prescaler of 8</front>
<front id="ServoCPP-174">    TCNT3 = 0;              // clear the timer count</front>
<front id="ServoCPP-175">#if defined(__AVR_ATmega128__)</front>
<front id="ServoCPP-176">    TIFR |= _BV(OCF3A);     // clear any pending interrupts;</front>
<front id="ServoCPP-177">	ETIMSK |= _BV(OCIE3A);  // enable the output compare interrupt</front>
<front id="ServoCPP-178">#else</front>
<front id="ServoCPP-179">    TIFR3 = _BV(OCF3A);     // clear any pending interrupts;</front>
<front id="ServoCPP-180">    TIMSK3 =  _BV(OCIE3A) ; // enable the output compare interrupt</front>
<front id="ServoCPP-181">#endif</front>
<front id="ServoCPP-182">#if defined(WIRING)</front>
<front id="ServoCPP-183">    timerAttach(TIMER3OUTCOMPAREA_INT, Timer3Service);  // for Wiring platform only</front>
<front id="ServoCPP-184">#endif</front>
<front id="ServoCPP-185">  }</front>
<front id="ServoCPP-186">#endif</front>
<front id="ServoCPP-187"></front>
<front id="ServoCPP-188">#if defined (_useTimer4)</front>
<front id="ServoCPP-189">  if(timer == _timer4) {</front>
<front id="ServoCPP-190">    TCCR4A = 0;             // normal counting mode</front>
<front id="ServoCPP-191">    TCCR4B = _BV(CS41);     // set prescaler of 8</front>
<front id="ServoCPP-192">    TCNT4 = 0;              // clear the timer count</front>
<front id="ServoCPP-193">    TIFR4 = _BV(OCF4A);     // clear any pending interrupts;</front>
<front id="ServoCPP-194">    TIMSK4 =  _BV(OCIE4A) ; // enable the output compare interrupt</front>
<front id="ServoCPP-195">  }</front>
<front id="ServoCPP-196">#endif</front>
<front id="ServoCPP-197"></front>
<front id="ServoCPP-198">#if defined (_useTimer5)</front>
<front id="ServoCPP-199">  if(timer == _timer5) {</front>
<front id="ServoCPP-200">    TCCR5A = 0;             // normal counting mode</front>
<front id="ServoCPP-201">    TCCR5B = _BV(CS51);     // set prescaler of 8</front>
<front id="ServoCPP-202">    TCNT5 = 0;              // clear the timer count</front>
<front id="ServoCPP-203">    TIFR5 = _BV(OCF5A);     // clear any pending interrupts;</front>
<front id="ServoCPP-204">    TIMSK5 =  _BV(OCIE5A) ; // enable the output compare interrupt</front>
<front id="ServoCPP-205">  }</front>
<front id="ServoCPP-206">#endif</front>
<front id="ServoCPP-207">}</front>
<front id="ServoCPP-208"></front>
<front id="ServoCPP-209">static void finISR(timer16_Sequence_t timer)</front>
<front id="ServoCPP-210">{</front>
<front id="ServoCPP-211">    //disable use of the given timer</front>
<front id="ServoCPP-212">#if defined WIRING   // Wiring</front>
<front id="ServoCPP-213">  if(timer == _timer1) {</front>
<front id="ServoCPP-214">    #if defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)</front>
<front id="ServoCPP-215">    TIMSK1 &=  ~_BV(OCIE1A) ;  // disable timer 1 output compare interrupt</front>
<front id="ServoCPP-216">    #else</front>
<front id="ServoCPP-217">    TIMSK &=  ~_BV(OCIE1A) ;  // disable timer 1 output compare interrupt</front>
<front id="ServoCPP-218">    #endif</front>
<front id="ServoCPP-219">    timerDetach(TIMER1OUTCOMPAREA_INT);</front>
<front id="ServoCPP-220">  }</front>
<front id="ServoCPP-221">  else if(timer == _timer3) {</front>
<front id="ServoCPP-222">    #if defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)</front>
<front id="ServoCPP-223">    TIMSK3 &= ~_BV(OCIE3A);    // disable the timer3 output compare A interrupt</front>
<front id="ServoCPP-224">    #else</front>
<front id="ServoCPP-225">    ETIMSK &= ~_BV(OCIE3A);    // disable the timer3 output compare A interrupt</front>
<front id="ServoCPP-226">    #endif</front>
<front id="ServoCPP-227">    timerDetach(TIMER3OUTCOMPAREA_INT);</front>
<front id="ServoCPP-228">  }</front>
<front id="ServoCPP-229">#else</front>
<front id="ServoCPP-230">    //For arduino - in future: call here to a currently undefined function to reset the timer</front>
<front id="ServoCPP-231">#endif</front>
<front id="ServoCPP-232">}</front>
<front id="ServoCPP-233"></front>
<front id="ServoCPP-234">static boolean isTimerActive(timer16_Sequence_t timer)</front>
<front id="ServoCPP-235">{</front>
<front id="ServoCPP-236">  // returns true if any servo is active on this timer</front>
<front id="ServoCPP-237">  for(uint8_t channel=0; channel &lt; SERVOS_PER_TIMER; channel++) {</front>
<front id="ServoCPP-238">    if(SERVO(timer,channel).Pin.isActive == true)</front>
<front id="ServoCPP-239">      return true;</front>
<front id="ServoCPP-240">  }</front>
<front id="ServoCPP-241">  return false;</front>
<front id="ServoCPP-242">}</front>
<front id="ServoCPP-243"></front>
<front id="ServoCPP-244"></front>
<front id="ServoCPP-245">/****************** end of static functions ******************************/</front>
<front id="ServoCPP-246"></front>
<front id="ServoCPP-247">Servo::Servo()</front>
<front id="ServoCPP-248">{</front>
<front id="ServoCPP-249">  if( ServoCount &lt; MAX_SERVOS) {</front>
<front id="ServoCPP-250">    this-&gt;servoIndex = ServoCount++;                    // assign a servo index to this instance</front>
<front id="ServoCPP-251">	servos[this-&gt;servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);   // store default values  - 12 Aug 2009</front>
<front id="ServoCPP-252">  }</front>
<front id="ServoCPP-253">  else</front>
<front id="ServoCPP-254">    this-&gt;servoIndex = INVALID_SERVO ;  // too many servos</front>
<front id="ServoCPP-255">}</front>
<front id="ServoCPP-256"></front>
<front id="ServoCPP-257">uint8_t Servo::attach(int pin)</front>
<front id="ServoCPP-258">{</front>
<front id="ServoCPP-259">  return this-&gt;attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);</front>
<front id="ServoCPP-260">}</front>
<front id="ServoCPP-261"></front>
<front id="ServoCPP-262">uint8_t Servo::attach(int pin, int min, int max)</front>
<front id="ServoCPP-263">{</front>
<front id="ServoCPP-264">  if(this-&gt;servoIndex &lt; MAX_SERVOS ) {</front>
<front id="ServoCPP-265">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="ServoCPP-266">    if (pin &gt; 0) this-&gt;pin = pin; else pin = this-&gt;pin;</front>
<front id="ServoCPP-267">#endif</front>
<front id="ServoCPP-268">    pinMode( pin, OUTPUT) ;                                   // set servo pin to output</front>
<front id="ServoCPP-269">    servos[this-&gt;servoIndex].Pin.nbr = pin;</front>
<front id="ServoCPP-270">    // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 &lt; 128</front>
<front id="ServoCPP-271">    this-&gt;min  = (MIN_PULSE_WIDTH - min)/4; //resolution of min/max is 4 uS</front>
<front id="ServoCPP-272">    this-&gt;max  = (MAX_PULSE_WIDTH - max)/4;</front>
<front id="ServoCPP-273">    // initialize the timer if it has not already been initialized</front>
<front id="ServoCPP-274">    timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);</front>
<front id="ServoCPP-275">    if(isTimerActive(timer) == false)</front>
<front id="ServoCPP-276">      initISR(timer);</front>
<front id="ServoCPP-277">    servos[this-&gt;servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive</front>
<front id="ServoCPP-278">  }</front>
<front id="ServoCPP-279">  return this-&gt;servoIndex ;</front>
<front id="ServoCPP-280">}</front>
<front id="ServoCPP-281"></front>
<front id="ServoCPP-282">void Servo::detach()</front>
<front id="ServoCPP-283">{</front>
<front id="ServoCPP-284">  servos[this-&gt;servoIndex].Pin.isActive = false;</front>
<front id="ServoCPP-285">  timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);</front>
<front id="ServoCPP-286">  if(isTimerActive(timer) == false) {</front>
<front id="ServoCPP-287">    finISR(timer);</front>
<front id="ServoCPP-288">  }</front>
<front id="ServoCPP-289">}</front>
<front id="ServoCPP-290"></front>
<front id="ServoCPP-291">void Servo::write(int value)</front>
<front id="ServoCPP-292">{</front>
<front id="ServoCPP-293">  if(value &lt; MIN_PULSE_WIDTH)</front>
<front id="ServoCPP-294">  {  // treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)</front>
<front id="ServoCPP-295">    if(value &lt; 0) value = 0;</front>
<front id="ServoCPP-296">    if(value &gt; 180) value = 180;</front>
<front id="ServoCPP-297">    value = map(value, 0, 180, SERVO_MIN(),  SERVO_MAX());</front>
<front id="ServoCPP-298">  }</front>
<front id="ServoCPP-299">  this-&gt;writeMicroseconds(value);</front>
<front id="ServoCPP-300">}</front>
<front id="ServoCPP-301"></front>
<front id="ServoCPP-302">void Servo::writeMicroseconds(int value)</front>
<front id="ServoCPP-303">{</front>
<front id="ServoCPP-304">  // calculate and store the values for the given channel</front>
<front id="ServoCPP-305">  byte channel = this-&gt;servoIndex;</front>
<front id="ServoCPP-306">  if( (channel &lt; MAX_SERVOS) )   // ensure channel is valid</front>
<front id="ServoCPP-307">  {</front>
<front id="ServoCPP-308">    if( value &lt; SERVO_MIN() )          // ensure pulse width is valid</front>
<front id="ServoCPP-309">      value = SERVO_MIN();</front>
<front id="ServoCPP-310">    else if( value &gt; SERVO_MAX() )</front>
<front id="ServoCPP-311">      value = SERVO_MAX();</front>
<front id="ServoCPP-312"></front>
<front id="ServoCPP-313">  	value = value - TRIM_DURATION;</front>
<front id="ServoCPP-314">    value = usToTicks(value);  // convert to ticks after compensating for interrupt overhead - 12 Aug 2009</front>
<front id="ServoCPP-315"></front>
<front id="ServoCPP-316">    uint8_t oldSREG = SREG;</front>
<front id="ServoCPP-317">    cli();</front>
<front id="ServoCPP-318">    servos[channel].ticks = value;</front>
<front id="ServoCPP-319">    SREG = oldSREG;</front>
<front id="ServoCPP-320">  }</front>
<front id="ServoCPP-321">}</front>
<front id="ServoCPP-322"></front>
<front id="ServoCPP-323">int Servo::read() // return the value as degrees</front>
<front id="ServoCPP-324">{</front>
<front id="ServoCPP-325">  return  map( this-&gt;readMicroseconds()+1, SERVO_MIN(), SERVO_MAX(), 0, 180);</front>
<front id="ServoCPP-326">}</front>
<front id="ServoCPP-327"></front>
<front id="ServoCPP-328">int Servo::readMicroseconds()</front>
<front id="ServoCPP-329">{</front>
<front id="ServoCPP-330">  unsigned int pulsewidth;</front>
<front id="ServoCPP-331">  if( this-&gt;servoIndex != INVALID_SERVO )</front>
<front id="ServoCPP-332">    pulsewidth = ticksToUs(servos[this-&gt;servoIndex].ticks)  + TRIM_DURATION ;   // 12 aug 2009</front>
<front id="ServoCPP-333">  else</front>
<front id="ServoCPP-334">    pulsewidth  = 0;</front>
<front id="ServoCPP-335"></front>
<front id="ServoCPP-336">  return pulsewidth;</front>
<front id="ServoCPP-337">}</front>
<front id="ServoCPP-338"></front>
<front id="ServoCPP-339">bool Servo::attached()</front>
<front id="ServoCPP-340">{</front>
<front id="ServoCPP-341">  return servos[this-&gt;servoIndex].Pin.isActive ;</front>
<front id="ServoCPP-342">}</front>
<front id="ServoCPP-343"></front>
<front id="ServoCPP-344">#endif</front>
 </pre>
<h1>Servo.h</h1>
<pre  class="prettyprint linenums"><front id="ServoH-1">/*</front>
<front id="ServoH-2">  Servo.h - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2</front>
<front id="ServoH-3">  Copyright (c) 2009 Michael Margolis.  All right reserved.</front>
<front id="ServoH-4"></front>
<front id="ServoH-5">  This library is free software; you can redistribute it and/or</front>
<front id="ServoH-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="ServoH-7">  License as published by the Free Software Foundation; either</front>
<front id="ServoH-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="ServoH-9"></front>
<front id="ServoH-10">  This library is distributed in the hope that it will be useful,</front>
<front id="ServoH-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="ServoH-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="ServoH-13">  Lesser General Public License for more details.</front>
<front id="ServoH-14"></front>
<front id="ServoH-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="ServoH-16">  License along with this library; if not, write to the Free Software</front>
<front id="ServoH-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="ServoH-18">*/</front>
<front id="ServoH-19"></front>
<front id="ServoH-20">/*</front>
<front id="ServoH-21"></front>
<front id="ServoH-22">  A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.</front>
<front id="ServoH-23">  The servos are pulsed in the background using the value most recently written using the write() method</front>
<front id="ServoH-24"></front>
<front id="ServoH-25">  Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.</front>
<front id="ServoH-26">  Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.</front>
<front id="ServoH-27">  The sequence used to sieze timers is defined in timers.h</front>
<front id="ServoH-28"></front>
<front id="ServoH-29">  The methods are:</front>
<front id="ServoH-30"></front>
<front id="ServoH-31">   Servo - Class for manipulating servo motors connected to Arduino pins.</front>
<front id="ServoH-32"></front>
<front id="ServoH-33">   attach(pin )  - Attaches a servo motor to an i/o pin.</front>
<front id="ServoH-34">   attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds</front>
<front id="ServoH-35">   default min is 544, max is 2400</front>
<front id="ServoH-36"></front>
<front id="ServoH-37">   write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)</front>
<front id="ServoH-38">   writeMicroseconds() - Sets the servo pulse width in microseconds</front>
<front id="ServoH-39">   read()      - Gets the last written servo pulse width as an angle between 0 and 180.</front>
<front id="ServoH-40">   readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)</front>
<front id="ServoH-41">   attached()  - Returns true if there is a servo attached.</front>
<front id="ServoH-42">   detach()    - Stops an attached servos from pulsing its i/o pin.</front>
<front id="ServoH-43"> */</front>
<front id="ServoH-44"></front>
<front id="ServoH-45">#ifndef Servo_h</front>
<front id="ServoH-46">#define Servo_h</front>
<front id="ServoH-47"></front>
<front id="ServoH-48">#include &lt;inttypes.h&gt;</front>
<front id="ServoH-49"></front>
<front id="ServoH-50">/*</front>
<front id="ServoH-51"> * Defines for 16 bit timers used with  Servo library</front>
<front id="ServoH-52"> *</front>
<front id="ServoH-53"> * If _useTimerX is defined then TimerX is a 16 bit timer on the curent board</front>
<front id="ServoH-54"> * timer16_Sequence_t enumerates the sequence that the timers should be allocated</front>
<front id="ServoH-55"> * _Nbr_16timers indicates how many 16 bit timers are available.</front>
<front id="ServoH-56"> *</front>
<front id="ServoH-57"> */</front>
<front id="ServoH-58"></front>
<front id="ServoH-59">// Say which 16 bit timers can be used and in what order</front>
<front id="ServoH-60">#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)</front>
<front id="ServoH-61">#define _useTimer5</front>
<front id="ServoH-62">//#define _useTimer1</front>
<front id="ServoH-63">#define _useTimer3</front>
<front id="ServoH-64">#define _useTimer4</front>
<front id="ServoH-65">//typedef enum { _timer5, _timer1, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-66">typedef enum { _timer5, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-67"></front>
<front id="ServoH-68">#elif defined(__AVR_ATmega32U4__)</front>
<front id="ServoH-69">//#define _useTimer1</front>
<front id="ServoH-70">#define _useTimer3</front>
<front id="ServoH-71">//typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-72">typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-73"></front>
<front id="ServoH-74">#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)</front>
<front id="ServoH-75">#define _useTimer3</front>
<front id="ServoH-76">//#define _useTimer1</front>
<front id="ServoH-77">//typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-78">typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-79"></front>
<front id="ServoH-80">#elif defined(__AVR_ATmega128__) ||defined(__AVR_ATmega1281__)||defined(__AVR_ATmega2561__)</front>
<front id="ServoH-81">#define _useTimer3</front>
<front id="ServoH-82">//#define _useTimer1</front>
<front id="ServoH-83">//typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-84">typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-85"></front>
<front id="ServoH-86">#else  // everything else</front>
<front id="ServoH-87">//#define _useTimer1</front>
<front id="ServoH-88">//typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-89">typedef enum { _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="ServoH-90">#endif</front>
<front id="ServoH-91"></front>
<front id="ServoH-92">#define Servo_VERSION           2      // software version of this library</front>
<front id="ServoH-93"></front>
<front id="ServoH-94">#define MIN_PULSE_WIDTH       544     // the shortest pulse sent to a servo</front>
<front id="ServoH-95">#define MAX_PULSE_WIDTH      2400     // the longest pulse sent to a servo</front>
<front id="ServoH-96">#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached</front>
<front id="ServoH-97">#define REFRESH_INTERVAL    20000     // minumim time to refresh servos in microseconds</front>
<front id="ServoH-98"></front>
<front id="ServoH-99">#define SERVOS_PER_TIMER       12     // the maximum number of servos controlled by one timer</front>
<front id="ServoH-100">#define MAX_SERVOS   (_Nbr_16timers  * SERVOS_PER_TIMER)</front>
<front id="ServoH-101"></front>
<front id="ServoH-102">#define INVALID_SERVO         255     // flag indicating an invalid servo index</front>
<front id="ServoH-103"></front>
<front id="ServoH-104">typedef struct  {</front>
<front id="ServoH-105">  uint8_t nbr        :6 ;             // a pin number from 0 to 63</front>
<front id="ServoH-106">  uint8_t isActive   :1 ;             // true if this channel is enabled, pin not pulsed if false</front>
<front id="ServoH-107">} ServoPin_t   ;</front>
<front id="ServoH-108"></front>
<front id="ServoH-109">typedef struct {</front>
<front id="ServoH-110">  ServoPin_t Pin;</front>
<front id="ServoH-111">  unsigned int ticks;</front>
<front id="ServoH-112">} servo_t;</front>
<front id="ServoH-113"></front>
<front id="ServoH-114">class Servo</front>
<front id="ServoH-115">{</front>
<front id="ServoH-116">public:</front>
<front id="ServoH-117">  Servo();</front>
<front id="ServoH-118">  uint8_t attach(int pin);           // attach the given pin to the next free channel, sets pinMode, returns channel number or 0 if failure</front>
<front id="ServoH-119">  uint8_t attach(int pin, int min, int max); // as above but also sets min and max values for writes.</front>
<front id="ServoH-120">  void detach();</front>
<front id="ServoH-121">  void write(int value);             // if value is &lt; 200 its treated as an angle, otherwise as pulse width in microseconds</front>
<front id="ServoH-122">  void writeMicroseconds(int value); // Write pulse width in microseconds</front>
<front id="ServoH-123">  int read();                        // returns current pulse width as an angle between 0 and 180 degrees</front>
<front id="ServoH-124">  int readMicroseconds();            // returns current pulse width in microseconds for this servo (was read_us() in first release)</front>
<front id="ServoH-125">  bool attached();                   // return true if this servo is attached, otherwise false</front>
<front id="ServoH-126">#if defined (ENABLE_AUTO_BED_LEVELING) && (PROBE_SERVO_DEACTIVATION_DELAY &gt; 0)</front>
<front id="ServoH-127">  int pin;                           // store the hw pin of the servo</front>
<front id="ServoH-128">#endif</front>
<front id="ServoH-129">private:</front>
<front id="ServoH-130">   uint8_t servoIndex;               // index into the channel data for this servo</front>
<front id="ServoH-131">   int8_t min;                       // minimum is this value times 4 added to MIN_PULSE_WIDTH</front>
<front id="ServoH-132">   int8_t max;                       // maximum is this value times 4 added to MAX_PULSE_WIDTH</front>
<front id="ServoH-133">};</front>
<front id="ServoH-134"></front>
<front id="ServoH-135">#endif</front>
 </pre>
<h1>speed_lookuptable.h</h1>
<pre  class="prettyprint linenums"><front id="speed_lookuptableH-1">#ifndef SPEED_LOOKUPTABLE_H</front>
<front id="speed_lookuptableH-2">#define SPEED_LOOKUPTABLE_H</front>
<front id="speed_lookuptableH-3"></front>
<front id="speed_lookuptableH-4">#include "Marlin.h"</front>
<front id="speed_lookuptableH-5"></front>
<front id="speed_lookuptableH-6">#if F_CPU == 16000000</front>
<front id="speed_lookuptableH-7"></front>
<front id="speed_lookuptableH-8">const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {\</front>
<front id="speed_lookuptableH-9">{ 62500, 55556}, { 6944, 3268}, { 3676, 1176}, { 2500, 607}, { 1893, 369}, { 1524, 249}, { 1275, 179}, { 1096, 135}, </front>
<front id="speed_lookuptableH-10">{ 961, 105}, { 856, 85}, { 771, 69}, { 702, 58}, { 644, 49}, { 595, 42}, { 553, 37}, { 516, 32}, </front>
<front id="speed_lookuptableH-11">{ 484, 28}, { 456, 25}, { 431, 23}, { 408, 20}, { 388, 19}, { 369, 16}, { 353, 16}, { 337, 14}, </front>
<front id="speed_lookuptableH-12">{ 323, 13}, { 310, 11}, { 299, 11}, { 288, 11}, { 277, 9}, { 268, 9}, { 259, 8}, { 251, 8}, </front>
<front id="speed_lookuptableH-13">{ 243, 8}, { 235, 7}, { 228, 6}, { 222, 6}, { 216, 6}, { 210, 6}, { 204, 5}, { 199, 5}, </front>
<front id="speed_lookuptableH-14">{ 194, 5}, { 189, 4}, { 185, 4}, { 181, 4}, { 177, 4}, { 173, 4}, { 169, 4}, { 165, 3}, </front>
<front id="speed_lookuptableH-15">{ 162, 3}, { 159, 4}, { 155, 3}, { 152, 3}, { 149, 2}, { 147, 3}, { 144, 3}, { 141, 2}, </front>
<front id="speed_lookuptableH-16">{ 139, 3}, { 136, 2}, { 134, 2}, { 132, 3}, { 129, 2}, { 127, 2}, { 125, 2}, { 123, 2}, </front>
<front id="speed_lookuptableH-17">{ 121, 2}, { 119, 1}, { 118, 2}, { 116, 2}, { 114, 1}, { 113, 2}, { 111, 2}, { 109, 1}, </front>
<front id="speed_lookuptableH-18">{ 108, 2}, { 106, 1}, { 105, 2}, { 103, 1}, { 102, 1}, { 101, 1}, { 100, 2}, { 98, 1}, </front>
<front id="speed_lookuptableH-19">{ 97, 1}, { 96, 1}, { 95, 2}, { 93, 1}, { 92, 1}, { 91, 1}, { 90, 1}, { 89, 1}, </front>
<front id="speed_lookuptableH-20">{ 88, 1}, { 87, 1}, { 86, 1}, { 85, 1}, { 84, 1}, { 83, 0}, { 83, 1}, { 82, 1}, </front>
<front id="speed_lookuptableH-21">{ 81, 1}, { 80, 1}, { 79, 1}, { 78, 0}, { 78, 1}, { 77, 1}, { 76, 1}, { 75, 0}, </front>
<front id="speed_lookuptableH-22">{ 75, 1}, { 74, 1}, { 73, 1}, { 72, 0}, { 72, 1}, { 71, 1}, { 70, 0}, { 70, 1}, </front>
<front id="speed_lookuptableH-23">{ 69, 0}, { 69, 1}, { 68, 1}, { 67, 0}, { 67, 1}, { 66, 0}, { 66, 1}, { 65, 0}, </front>
<front id="speed_lookuptableH-24">{ 65, 1}, { 64, 1}, { 63, 0}, { 63, 1}, { 62, 0}, { 62, 1}, { 61, 0}, { 61, 1}, </front>
<front id="speed_lookuptableH-25">{ 60, 0}, { 60, 0}, { 60, 1}, { 59, 0}, { 59, 1}, { 58, 0}, { 58, 1}, { 57, 0}, </front>
<front id="speed_lookuptableH-26">{ 57, 1}, { 56, 0}, { 56, 0}, { 56, 1}, { 55, 0}, { 55, 1}, { 54, 0}, { 54, 0}, </front>
<front id="speed_lookuptableH-27">{ 54, 1}, { 53, 0}, { 53, 0}, { 53, 1}, { 52, 0}, { 52, 0}, { 52, 1}, { 51, 0}, </front>
<front id="speed_lookuptableH-28">{ 51, 0}, { 51, 1}, { 50, 0}, { 50, 0}, { 50, 1}, { 49, 0}, { 49, 0}, { 49, 1}, </front>
<front id="speed_lookuptableH-29">{ 48, 0}, { 48, 0}, { 48, 1}, { 47, 0}, { 47, 0}, { 47, 0}, { 47, 1}, { 46, 0}, </front>
<front id="speed_lookuptableH-30">{ 46, 0}, { 46, 1}, { 45, 0}, { 45, 0}, { 45, 0}, { 45, 1}, { 44, 0}, { 44, 0}, </front>
<front id="speed_lookuptableH-31">{ 44, 0}, { 44, 1}, { 43, 0}, { 43, 0}, { 43, 0}, { 43, 1}, { 42, 0}, { 42, 0}, </front>
<front id="speed_lookuptableH-32">{ 42, 0}, { 42, 1}, { 41, 0}, { 41, 0}, { 41, 0}, { 41, 0}, { 41, 1}, { 40, 0}, </front>
<front id="speed_lookuptableH-33">{ 40, 0}, { 40, 0}, { 40, 0}, { 40, 1}, { 39, 0}, { 39, 0}, { 39, 0}, { 39, 0}, </front>
<front id="speed_lookuptableH-34">{ 39, 1}, { 38, 0}, { 38, 0}, { 38, 0}, { 38, 0}, { 38, 1}, { 37, 0}, { 37, 0}, </front>
<front id="speed_lookuptableH-35">{ 37, 0}, { 37, 0}, { 37, 0}, { 37, 1}, { 36, 0}, { 36, 0}, { 36, 0}, { 36, 0}, </front>
<front id="speed_lookuptableH-36">{ 36, 1}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 1}, </front>
<front id="speed_lookuptableH-37">{ 34, 0}, { 34, 0}, { 34, 0}, { 34, 0}, { 34, 0}, { 34, 1}, { 33, 0}, { 33, 0}, </front>
<front id="speed_lookuptableH-38">{ 33, 0}, { 33, 0}, { 33, 0}, { 33, 0}, { 33, 1}, { 32, 0}, { 32, 0}, { 32, 0}, </front>
<front id="speed_lookuptableH-39">{ 32, 0}, { 32, 0}, { 32, 0}, { 32, 0}, { 32, 1}, { 31, 0}, { 31, 0}, { 31, 0}, </front>
<front id="speed_lookuptableH-40">{ 31, 0}, { 31, 0}, { 31, 0}, { 31, 1}, { 30, 0}, { 30, 0}, { 30, 0}, { 30, 0}</front>
<front id="speed_lookuptableH-41">};</front>
<front id="speed_lookuptableH-42"></front>
<front id="speed_lookuptableH-43">const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {\</front>
<front id="speed_lookuptableH-44">{ 62500, 12500}, { 50000, 8334}, { 41666, 5952}, { 35714, 4464}, { 31250, 3473}, { 27777, 2777}, { 25000, 2273}, { 22727, 1894}, </front>
<front id="speed_lookuptableH-45">{ 20833, 1603}, { 19230, 1373}, { 17857, 1191}, { 16666, 1041}, { 15625, 920}, { 14705, 817}, { 13888, 731}, { 13157, 657}, </front>
<front id="speed_lookuptableH-46">{ 12500, 596}, { 11904, 541}, { 11363, 494}, { 10869, 453}, { 10416, 416}, { 10000, 385}, { 9615, 356}, { 9259, 331}, </front>
<front id="speed_lookuptableH-47">{ 8928, 308}, { 8620, 287}, { 8333, 269}, { 8064, 252}, { 7812, 237}, { 7575, 223}, { 7352, 210}, { 7142, 198}, </front>
<front id="speed_lookuptableH-48">{ 6944, 188}, { 6756, 178}, { 6578, 168}, { 6410, 160}, { 6250, 153}, { 6097, 145}, { 5952, 139}, { 5813, 132}, </front>
<front id="speed_lookuptableH-49">{ 5681, 126}, { 5555, 121}, { 5434, 115}, { 5319, 111}, { 5208, 106}, { 5102, 102}, { 5000, 99}, { 4901, 94}, </front>
<front id="speed_lookuptableH-50">{ 4807, 91}, { 4716, 87}, { 4629, 84}, { 4545, 81}, { 4464, 79}, { 4385, 75}, { 4310, 73}, { 4237, 71}, </front>
<front id="speed_lookuptableH-51">{ 4166, 68}, { 4098, 66}, { 4032, 64}, { 3968, 62}, { 3906, 60}, { 3846, 59}, { 3787, 56}, { 3731, 55}, </front>
<front id="speed_lookuptableH-52">{ 3676, 53}, { 3623, 52}, { 3571, 50}, { 3521, 49}, { 3472, 48}, { 3424, 46}, { 3378, 45}, { 3333, 44}, </front>
<front id="speed_lookuptableH-53">{ 3289, 43}, { 3246, 41}, { 3205, 41}, { 3164, 39}, { 3125, 39}, { 3086, 38}, { 3048, 36}, { 3012, 36}, </front>
<front id="speed_lookuptableH-54">{ 2976, 35}, { 2941, 35}, { 2906, 33}, { 2873, 33}, { 2840, 32}, { 2808, 31}, { 2777, 30}, { 2747, 30}, </front>
<front id="speed_lookuptableH-55">{ 2717, 29}, { 2688, 29}, { 2659, 28}, { 2631, 27}, { 2604, 27}, { 2577, 26}, { 2551, 26}, { 2525, 25}, </front>
<front id="speed_lookuptableH-56">{ 2500, 25}, { 2475, 25}, { 2450, 23}, { 2427, 24}, { 2403, 23}, { 2380, 22}, { 2358, 22}, { 2336, 22}, </front>
<front id="speed_lookuptableH-57">{ 2314, 21}, { 2293, 21}, { 2272, 20}, { 2252, 20}, { 2232, 20}, { 2212, 20}, { 2192, 19}, { 2173, 18}, </front>
<front id="speed_lookuptableH-58">{ 2155, 19}, { 2136, 18}, { 2118, 18}, { 2100, 17}, { 2083, 17}, { 2066, 17}, { 2049, 17}, { 2032, 16}, </front>
<front id="speed_lookuptableH-59">{ 2016, 16}, { 2000, 16}, { 1984, 16}, { 1968, 15}, { 1953, 16}, { 1937, 14}, { 1923, 15}, { 1908, 15}, </front>
<front id="speed_lookuptableH-60">{ 1893, 14}, { 1879, 14}, { 1865, 14}, { 1851, 13}, { 1838, 14}, { 1824, 13}, { 1811, 13}, { 1798, 13}, </front>
<front id="speed_lookuptableH-61">{ 1785, 12}, { 1773, 13}, { 1760, 12}, { 1748, 12}, { 1736, 12}, { 1724, 12}, { 1712, 12}, { 1700, 11}, </front>
<front id="speed_lookuptableH-62">{ 1689, 12}, { 1677, 11}, { 1666, 11}, { 1655, 11}, { 1644, 11}, { 1633, 10}, { 1623, 11}, { 1612, 10}, </front>
<front id="speed_lookuptableH-63">{ 1602, 10}, { 1592, 10}, { 1582, 10}, { 1572, 10}, { 1562, 10}, { 1552, 9}, { 1543, 10}, { 1533, 9}, </front>
<front id="speed_lookuptableH-64">{ 1524, 9}, { 1515, 9}, { 1506, 9}, { 1497, 9}, { 1488, 9}, { 1479, 9}, { 1470, 9}, { 1461, 8}, </front>
<front id="speed_lookuptableH-65">{ 1453, 8}, { 1445, 9}, { 1436, 8}, { 1428, 8}, { 1420, 8}, { 1412, 8}, { 1404, 8}, { 1396, 8}, </front>
<front id="speed_lookuptableH-66">{ 1388, 7}, { 1381, 8}, { 1373, 7}, { 1366, 8}, { 1358, 7}, { 1351, 7}, { 1344, 8}, { 1336, 7}, </front>
<front id="speed_lookuptableH-67">{ 1329, 7}, { 1322, 7}, { 1315, 7}, { 1308, 6}, { 1302, 7}, { 1295, 7}, { 1288, 6}, { 1282, 7}, </front>
<front id="speed_lookuptableH-68">{ 1275, 6}, { 1269, 7}, { 1262, 6}, { 1256, 6}, { 1250, 7}, { 1243, 6}, { 1237, 6}, { 1231, 6}, </front>
<front id="speed_lookuptableH-69">{ 1225, 6}, { 1219, 6}, { 1213, 6}, { 1207, 6}, { 1201, 5}, { 1196, 6}, { 1190, 6}, { 1184, 5}, </front>
<front id="speed_lookuptableH-70">{ 1179, 6}, { 1173, 5}, { 1168, 6}, { 1162, 5}, { 1157, 5}, { 1152, 6}, { 1146, 5}, { 1141, 5}, </front>
<front id="speed_lookuptableH-71">{ 1136, 5}, { 1131, 5}, { 1126, 5}, { 1121, 5}, { 1116, 5}, { 1111, 5}, { 1106, 5}, { 1101, 5}, </front>
<front id="speed_lookuptableH-72">{ 1096, 5}, { 1091, 5}, { 1086, 4}, { 1082, 5}, { 1077, 5}, { 1072, 4}, { 1068, 5}, { 1063, 4}, </front>
<front id="speed_lookuptableH-73">{ 1059, 5}, { 1054, 4}, { 1050, 4}, { 1046, 5}, { 1041, 4}, { 1037, 4}, { 1033, 5}, { 1028, 4}, </front>
<front id="speed_lookuptableH-74">{ 1024, 4}, { 1020, 4}, { 1016, 4}, { 1012, 4}, { 1008, 4}, { 1004, 4}, { 1000, 4}, { 996, 4}, </front>
<front id="speed_lookuptableH-75">{ 992, 4}, { 988, 4}, { 984, 4}, { 980, 4}, { 976, 4}, { 972, 4}, { 968, 3}, { 965, 3}</front>
<front id="speed_lookuptableH-76">};</front>
<front id="speed_lookuptableH-77"></front>
<front id="speed_lookuptableH-78">#elif F_CPU == 20000000</front>
<front id="speed_lookuptableH-79"></front>
<front id="speed_lookuptableH-80">const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {</front>
<front id="speed_lookuptableH-81">   {62500, 54055}, {8445, 3917}, {4528, 1434}, {3094, 745}, {2349, 456}, {1893, 307}, {1586, 222}, {1364, 167},</front>
<front id="speed_lookuptableH-82">   {1197, 131}, {1066, 105}, {961, 86}, {875, 72}, {803, 61}, {742, 53}, {689, 45}, {644, 40},</front>
<front id="speed_lookuptableH-83">   {604, 35}, {569, 32}, {537, 28}, {509, 25}, {484, 23}, {461, 21}, {440, 19}, {421, 17},</front>
<front id="speed_lookuptableH-84">   {404, 16}, {388, 15}, {373, 14}, {359, 13}, {346, 12}, {334, 11}, {323, 10}, {313, 10},</front>
<front id="speed_lookuptableH-85">   {303, 9}, {294, 9}, {285, 8}, {277, 7}, {270, 8}, {262, 7}, {255, 6}, {249, 6},</front>
<front id="speed_lookuptableH-86">   {243, 6}, {237, 6}, {231, 5}, {226, 5}, {221, 5}, {216, 5}, {211, 4}, {207, 5},</front>
<front id="speed_lookuptableH-87">   {202, 4}, {198, 4}, {194, 4}, {190, 3}, {187, 4}, {183, 3}, {180, 3}, {177, 4},</front>
<front id="speed_lookuptableH-88">   {173, 3}, {170, 3}, {167, 2}, {165, 3}, {162, 3}, {159, 2}, {157, 3}, {154, 2},</front>
<front id="speed_lookuptableH-89">   {152, 3}, {149, 2}, {147, 2}, {145, 2}, {143, 2}, {141, 2}, {139, 2}, {137, 2},</front>
<front id="speed_lookuptableH-90">   {135, 2}, {133, 2}, {131, 2}, {129, 1}, {128, 2}, {126, 2}, {124, 1}, {123, 2},</front>
<front id="speed_lookuptableH-91">   {121, 1}, {120, 2}, {118, 1}, {117, 1}, {116, 2}, {114, 1}, {113, 1}, {112, 2},</front>
<front id="speed_lookuptableH-92">   {110, 1}, {109, 1}, {108, 1}, {107, 2}, {105, 1}, {104, 1}, {103, 1}, {102, 1},</front>
<front id="speed_lookuptableH-93">   {101, 1}, {100, 1}, {99, 1}, {98, 1}, {97, 1}, {96, 1}, {95, 1}, {94, 1},</front>
<front id="speed_lookuptableH-94">   {93, 1}, {92, 1}, {91, 0}, {91, 1}, {90, 1}, {89, 1}, {88, 1}, {87, 0},</front>
<front id="speed_lookuptableH-95">   {87, 1}, {86, 1}, {85, 1}, {84, 0}, {84, 1}, {83, 1}, {82, 1}, {81, 0},</front>
<front id="speed_lookuptableH-96">   {81, 1}, {80, 1}, {79, 0}, {79, 1}, {78, 0}, {78, 1}, {77, 1}, {76, 0},</front>
<front id="speed_lookuptableH-97">   {76, 1}, {75, 0}, {75, 1}, {74, 1}, {73, 0}, {73, 1}, {72, 0}, {72, 1},</front>
<front id="speed_lookuptableH-98">   {71, 0}, {71, 1}, {70, 0}, {70, 1}, {69, 0}, {69, 1}, {68, 0}, {68, 1},</front>
<front id="speed_lookuptableH-99">   {67, 0}, {67, 1}, {66, 0}, {66, 1}, {65, 0}, {65, 0}, {65, 1}, {64, 0},</front>
<front id="speed_lookuptableH-100">   {64, 1}, {63, 0}, {63, 1}, {62, 0}, {62, 0}, {62, 1}, {61, 0}, {61, 1},</front>
<front id="speed_lookuptableH-101">   {60, 0}, {60, 0}, {60, 1}, {59, 0}, {59, 0}, {59, 1}, {58, 0}, {58, 0},</front>
<front id="speed_lookuptableH-102">   {58, 1}, {57, 0}, {57, 0}, {57, 1}, {56, 0}, {56, 0}, {56, 1}, {55, 0},</front>
<front id="speed_lookuptableH-103">   {55, 0}, {55, 1}, {54, 0}, {54, 0}, {54, 1}, {53, 0}, {53, 0}, {53, 0},</front>
<front id="speed_lookuptableH-104">   {53, 1}, {52, 0}, {52, 0}, {52, 1}, {51, 0}, {51, 0}, {51, 0}, {51, 1},</front>
<front id="speed_lookuptableH-105">   {50, 0}, {50, 0}, {50, 0}, {50, 1}, {49, 0}, {49, 0}, {49, 0}, {49, 1},</front>
<front id="speed_lookuptableH-106">   {48, 0}, {48, 0}, {48, 0}, {48, 1}, {47, 0}, {47, 0}, {47, 0}, {47, 1},</front>
<front id="speed_lookuptableH-107">   {46, 0}, {46, 0}, {46, 0}, {46, 0}, {46, 1}, {45, 0}, {45, 0}, {45, 0},</front>
<front id="speed_lookuptableH-108">   {45, 1}, {44, 0}, {44, 0}, {44, 0}, {44, 0}, {44, 1}, {43, 0}, {43, 0},</front>
<front id="speed_lookuptableH-109">   {43, 0}, {43, 0}, {43, 1}, {42, 0}, {42, 0}, {42, 0}, {42, 0}, {42, 0},</front>
<front id="speed_lookuptableH-110">   {42, 1}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 1}, {40, 0},</front>
<front id="speed_lookuptableH-111">   {40, 0}, {40, 0}, {40, 0}, {40, 1}, {39, 0}, {39, 0}, {39, 0}, {39, 0},</front>
<front id="speed_lookuptableH-112">   {39, 0}, {39, 0}, {39, 1}, {38, 0}, {38, 0}, {38, 0}, {38, 0}, {38, 0},</front>
<front id="speed_lookuptableH-113">};</front>
<front id="speed_lookuptableH-114"></front>
<front id="speed_lookuptableH-115">const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {</front>
<front id="speed_lookuptableH-116">   {62500, 10417}, {52083, 7441}, {44642, 5580}, {39062, 4340}, {34722, 3472}, {31250, 2841}, {28409, 2368}, {26041, 2003},</front>
<front id="speed_lookuptableH-117">   {24038, 1717}, {22321, 1488}, {20833, 1302}, {19531, 1149}, {18382, 1021}, {17361, 914}, {16447, 822}, {15625, 745},</front>
<front id="speed_lookuptableH-118">   {14880, 676}, {14204, 618}, {13586, 566}, {13020, 520}, {12500, 481}, {12019, 445}, {11574, 414}, {11160, 385},</front>
<front id="speed_lookuptableH-119">   {10775, 359}, {10416, 336}, {10080, 315}, {9765, 296}, {9469, 278}, {9191, 263}, {8928, 248}, {8680, 235},</front>
<front id="speed_lookuptableH-120">   {8445, 222}, {8223, 211}, {8012, 200}, {7812, 191}, {7621, 181}, {7440, 173}, {7267, 165}, {7102, 158},</front>
<front id="speed_lookuptableH-121">   {6944, 151}, {6793, 145}, {6648, 138}, {6510, 133}, {6377, 127}, {6250, 123}, {6127, 118}, {6009, 113},</front>
<front id="speed_lookuptableH-122">   {5896, 109}, {5787, 106}, {5681, 101}, {5580, 98}, {5482, 95}, {5387, 91}, {5296, 88}, {5208, 86},</front>
<front id="speed_lookuptableH-123">   {5122, 82}, {5040, 80}, {4960, 78}, {4882, 75}, {4807, 73}, {4734, 70}, {4664, 69}, {4595, 67},</front>
<front id="speed_lookuptableH-124">   {4528, 64}, {4464, 63}, {4401, 61}, {4340, 60}, {4280, 58}, {4222, 56}, {4166, 55}, {4111, 53},</front>
<front id="speed_lookuptableH-125">   {4058, 52}, {4006, 51}, {3955, 49}, {3906, 48}, {3858, 48}, {3810, 45}, {3765, 45}, {3720, 44},</front>
<front id="speed_lookuptableH-126">   {3676, 43}, {3633, 42}, {3591, 40}, {3551, 40}, {3511, 39}, {3472, 38}, {3434, 38}, {3396, 36},</front>
<front id="speed_lookuptableH-127">   {3360, 36}, {3324, 35}, {3289, 34}, {3255, 34}, {3221, 33}, {3188, 32}, {3156, 31}, {3125, 31},</front>
<front id="speed_lookuptableH-128">   {3094, 31}, {3063, 30}, {3033, 29}, {3004, 28}, {2976, 28}, {2948, 28}, {2920, 27}, {2893, 27},</front>
<front id="speed_lookuptableH-129">   {2866, 26}, {2840, 25}, {2815, 25}, {2790, 25}, {2765, 24}, {2741, 24}, {2717, 24}, {2693, 23},</front>
<front id="speed_lookuptableH-130">   {2670, 22}, {2648, 22}, {2626, 22}, {2604, 22}, {2582, 21}, {2561, 21}, {2540, 20}, {2520, 20},</front>
<front id="speed_lookuptableH-131">   {2500, 20}, {2480, 20}, {2460, 19}, {2441, 19}, {2422, 19}, {2403, 18}, {2385, 18}, {2367, 18},</front>
<front id="speed_lookuptableH-132">   {2349, 17}, {2332, 18}, {2314, 17}, {2297, 16}, {2281, 17}, {2264, 16}, {2248, 16}, {2232, 16},</front>
<front id="speed_lookuptableH-133">   {2216, 16}, {2200, 15}, {2185, 15}, {2170, 15}, {2155, 15}, {2140, 15}, {2125, 14}, {2111, 14},</front>
<front id="speed_lookuptableH-134">   {2097, 14}, {2083, 14}, {2069, 14}, {2055, 13}, {2042, 13}, {2029, 13}, {2016, 13}, {2003, 13},</front>
<front id="speed_lookuptableH-135">   {1990, 13}, {1977, 12}, {1965, 12}, {1953, 13}, {1940, 11}, {1929, 12}, {1917, 12}, {1905, 12},</front>
<front id="speed_lookuptableH-136">   {1893, 11}, {1882, 11}, {1871, 11}, {1860, 11}, {1849, 11}, {1838, 11}, {1827, 11}, {1816, 10},</front>
<front id="speed_lookuptableH-137">   {1806, 11}, {1795, 10}, {1785, 10}, {1775, 10}, {1765, 10}, {1755, 10}, {1745, 9}, {1736, 10},</front>
<front id="speed_lookuptableH-138">   {1726, 9}, {1717, 10}, {1707, 9}, {1698, 9}, {1689, 9}, {1680, 9}, {1671, 9}, {1662, 9},</front>
<front id="speed_lookuptableH-139">   {1653, 9}, {1644, 8}, {1636, 9}, {1627, 8}, {1619, 9}, {1610, 8}, {1602, 8}, {1594, 8},</front>
<front id="speed_lookuptableH-140">   {1586, 8}, {1578, 8}, {1570, 8}, {1562, 8}, {1554, 7}, {1547, 8}, {1539, 8}, {1531, 7},</front>
<front id="speed_lookuptableH-141">   {1524, 8}, {1516, 7}, {1509, 7}, {1502, 7}, {1495, 7}, {1488, 7}, {1481, 7}, {1474, 7},</front>
<front id="speed_lookuptableH-142">   {1467, 7}, {1460, 7}, {1453, 7}, {1446, 6}, {1440, 7}, {1433, 7}, {1426, 6}, {1420, 6},</front>
<front id="speed_lookuptableH-143">   {1414, 7}, {1407, 6}, {1401, 6}, {1395, 7}, {1388, 6}, {1382, 6}, {1376, 6}, {1370, 6},</front>
<front id="speed_lookuptableH-144">   {1364, 6}, {1358, 6}, {1352, 6}, {1346, 5}, {1341, 6}, {1335, 6}, {1329, 5}, {1324, 6},</front>
<front id="speed_lookuptableH-145">   {1318, 5}, {1313, 6}, {1307, 5}, {1302, 6}, {1296, 5}, {1291, 5}, {1286, 6}, {1280, 5},</front>
<front id="speed_lookuptableH-146">   {1275, 5}, {1270, 5}, {1265, 5}, {1260, 5}, {1255, 5}, {1250, 5}, {1245, 5}, {1240, 5},</front>
<front id="speed_lookuptableH-147">   {1235, 5}, {1230, 5}, {1225, 5}, {1220, 5}, {1215, 4}, {1211, 5}, {1206, 5}, {1201, 5},</front>
<front id="speed_lookuptableH-148">};</front>
<front id="speed_lookuptableH-149"></front>
<front id="speed_lookuptableH-150">#endif</front>
<front id="speed_lookuptableH-151"></front>
<front id="speed_lookuptableH-152">#endif</front>
 </pre>
<h1>stepper.cpp</h1>
<pre  class="prettyprint linenums"><front id="stepperCPP-1">/*</front>
<front id="stepperCPP-2">  stepper.c - stepper motor driver: executes motion plans using stepper motors</front>
<front id="stepperCPP-3">  Part of Grbl</front>
<front id="stepperCPP-4"></front>
<front id="stepperCPP-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="stepperCPP-6"></front>
<front id="stepperCPP-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="stepperCPP-8">  it under the terms of the GNU General Public License as published by</front>
<front id="stepperCPP-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="stepperCPP-10">  (at your option) any later version.</front>
<front id="stepperCPP-11"></front>
<front id="stepperCPP-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="stepperCPP-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="stepperCPP-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="stepperCPP-15">  GNU General Public License for more details.</front>
<front id="stepperCPP-16"></front>
<front id="stepperCPP-17">  You should have received a copy of the GNU General Public License</front>
<front id="stepperCPP-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="stepperCPP-19">*/</front>
<front id="stepperCPP-20"></front>
<front id="stepperCPP-21">/* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith</front>
<front id="stepperCPP-22">   and Philipp Tiefenbacher. */</front>
<front id="stepperCPP-23"></front>
<front id="stepperCPP-24">#include "Marlin.h"</front>
<front id="stepperCPP-25">#include "stepper.h"</front>
<front id="stepperCPP-26">#include "planner.h"</front>
<front id="stepperCPP-27">#include "temperature.h"</front>
<front id="stepperCPP-28">#include "ultralcd.h"</front>
<front id="stepperCPP-29">#include "language.h"</front>
<front id="stepperCPP-30">#include "cardreader.h"</front>
<front id="stepperCPP-31">#include "speed_lookuptable.h"</front>
<front id="stepperCPP-32">#if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="stepperCPP-33">#include &lt;SPI.h&gt;</front>
<front id="stepperCPP-34">#endif</front>
<front id="stepperCPP-35"></front>
<front id="stepperCPP-36"></front>
<front id="stepperCPP-37">//===========================================================================</front>
<front id="stepperCPP-38">//=============================public variables  ============================</front>
<front id="stepperCPP-39">//===========================================================================</front>
<front id="stepperCPP-40">block_t *current_block;  // A pointer to the block currently being traced</front>
<front id="stepperCPP-41"></front>
<front id="stepperCPP-42"></front>
<front id="stepperCPP-43">//===========================================================================</front>
<front id="stepperCPP-44">//=============================private variables ============================</front>
<front id="stepperCPP-45">//===========================================================================</front>
<front id="stepperCPP-46">//static makes it inpossible to be called from outside of this file by extern.!</front>
<front id="stepperCPP-47"></front>
<front id="stepperCPP-48">// Variables used by The Stepper Driver Interrupt</front>
<front id="stepperCPP-49">static unsigned char out_bits;        // The next stepping-bits to be output</front>
<front id="stepperCPP-50">static long counter_x,       // Counter variables for the bresenham line tracer</front>
<front id="stepperCPP-51">            counter_y,</front>
<front id="stepperCPP-52">            counter_z,</front>
<front id="stepperCPP-53">            counter_e;</front>
<front id="stepperCPP-54">volatile static unsigned long step_events_completed; // The number of step events executed in the current block</front>
<front id="stepperCPP-55">#ifdef ADVANCE</front>
<front id="stepperCPP-56">  static long advance_rate, advance, final_advance = 0;</front>
<front id="stepperCPP-57">  static long old_advance = 0;</front>
<front id="stepperCPP-58">  static long e_steps[3];</front>
<front id="stepperCPP-59">#endif</front>
<front id="stepperCPP-60">static long acceleration_time, deceleration_time;</front>
<front id="stepperCPP-61">//static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;</front>
<front id="stepperCPP-62">static unsigned short acc_step_rate; // needed for deccelaration start point</front>
<front id="stepperCPP-63">static char step_loops;</front>
<front id="stepperCPP-64">static unsigned short OCR1A_nominal;</front>
<front id="stepperCPP-65">static unsigned short step_loops_nominal;</front>
<front id="stepperCPP-66"></front>
<front id="stepperCPP-67">volatile long endstops_trigsteps[3]={0,0,0};</front>
<front id="stepperCPP-68">volatile long endstops_stepsTotal,endstops_stepsDone;</front>
<front id="stepperCPP-69">static volatile bool endstop_x_hit=false;</front>
<front id="stepperCPP-70">static volatile bool endstop_y_hit=false;</front>
<front id="stepperCPP-71">static volatile bool endstop_z_hit=false;</front>
<front id="stepperCPP-72">#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="stepperCPP-73">bool abort_on_endstop_hit = false;</front>
<front id="stepperCPP-74">#endif</front>
<front id="stepperCPP-75"></front>
<front id="stepperCPP-76">static bool old_x_min_endstop=false;</front>
<front id="stepperCPP-77">static bool old_x_max_endstop=false;</front>
<front id="stepperCPP-78">static bool old_y_min_endstop=false;</front>
<front id="stepperCPP-79">static bool old_y_max_endstop=false;</front>
<front id="stepperCPP-80">static bool old_z_min_endstop=false;</front>
<front id="stepperCPP-81">static bool old_z_max_endstop=false;</front>
<front id="stepperCPP-82"></front>
<front id="stepperCPP-83">static bool check_endstops = true;</front>
<front id="stepperCPP-84"></front>
<front id="stepperCPP-85">volatile long count_position[NUM_AXIS] = { 0, 0, 0, 0};</front>
<front id="stepperCPP-86">volatile signed char count_direction[NUM_AXIS] = { 1, 1, 1, 1};</front>
<front id="stepperCPP-87"></front>
<front id="stepperCPP-88">//===========================================================================</front>
<front id="stepperCPP-89">//=============================functions         ============================</front>
<front id="stepperCPP-90">//===========================================================================</front>
<front id="stepperCPP-91"></front>
<front id="stepperCPP-92">#define CHECK_ENDSTOPS  if(check_endstops)</front>
<front id="stepperCPP-93"></front>
<front id="stepperCPP-94">// intRes = intIn1 * intIn2 &gt;&gt; 16</front>
<front id="stepperCPP-95">// uses:</front>
<front id="stepperCPP-96">// r26 to store 0</front>
<front id="stepperCPP-97">// r27 to store the byte 1 of the 24 bit result</front>
<front id="stepperCPP-98">#define MultiU16X8toH16(intRes, charIn1, intIn2) \</front>
<front id="stepperCPP-99">asm volatile ( \</front>
<front id="stepperCPP-100">"clr r26 \n\t" \</front>
<front id="stepperCPP-101">"mul %A1, %B2 \n\t" \</front>
<front id="stepperCPP-102">"movw %A0, r0 \n\t" \</front>
<front id="stepperCPP-103">"mul %A1, %A2 \n\t" \</front>
<front id="stepperCPP-104">"add %A0, r1 \n\t" \</front>
<front id="stepperCPP-105">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-106">"lsr r0 \n\t" \</front>
<front id="stepperCPP-107">"adc %A0, r26 \n\t" \</front>
<front id="stepperCPP-108">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-109">"clr r1 \n\t" \</front>
<front id="stepperCPP-110">: \</front>
<front id="stepperCPP-111">"=&r" (intRes) \</front>
<front id="stepperCPP-112">: \</front>
<front id="stepperCPP-113">"d" (charIn1), \</front>
<front id="stepperCPP-114">"d" (intIn2) \</front>
<front id="stepperCPP-115">: \</front>
<front id="stepperCPP-116">"r26" \</front>
<front id="stepperCPP-117">)</front>
<front id="stepperCPP-118"></front>
<front id="stepperCPP-119">// intRes = longIn1 * longIn2 &gt;&gt; 24</front>
<front id="stepperCPP-120">// uses:</front>
<front id="stepperCPP-121">// r26 to store 0</front>
<front id="stepperCPP-122">// r27 to store the byte 1 of the 48bit result</front>
<front id="stepperCPP-123">#define MultiU24X24toH16(intRes, longIn1, longIn2) \</front>
<front id="stepperCPP-124">asm volatile ( \</front>
<front id="stepperCPP-125">"clr r26 \n\t" \</front>
<front id="stepperCPP-126">"mul %A1, %B2 \n\t" \</front>
<front id="stepperCPP-127">"mov r27, r1 \n\t" \</front>
<front id="stepperCPP-128">"mul %B1, %C2 \n\t" \</front>
<front id="stepperCPP-129">"movw %A0, r0 \n\t" \</front>
<front id="stepperCPP-130">"mul %C1, %C2 \n\t" \</front>
<front id="stepperCPP-131">"add %B0, r0 \n\t" \</front>
<front id="stepperCPP-132">"mul %C1, %B2 \n\t" \</front>
<front id="stepperCPP-133">"add %A0, r0 \n\t" \</front>
<front id="stepperCPP-134">"adc %B0, r1 \n\t" \</front>
<front id="stepperCPP-135">"mul %A1, %C2 \n\t" \</front>
<front id="stepperCPP-136">"add r27, r0 \n\t" \</front>
<front id="stepperCPP-137">"adc %A0, r1 \n\t" \</front>
<front id="stepperCPP-138">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-139">"mul %B1, %B2 \n\t" \</front>
<front id="stepperCPP-140">"add r27, r0 \n\t" \</front>
<front id="stepperCPP-141">"adc %A0, r1 \n\t" \</front>
<front id="stepperCPP-142">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-143">"mul %C1, %A2 \n\t" \</front>
<front id="stepperCPP-144">"add r27, r0 \n\t" \</front>
<front id="stepperCPP-145">"adc %A0, r1 \n\t" \</front>
<front id="stepperCPP-146">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-147">"mul %B1, %A2 \n\t" \</front>
<front id="stepperCPP-148">"add r27, r1 \n\t" \</front>
<front id="stepperCPP-149">"adc %A0, r26 \n\t" \</front>
<front id="stepperCPP-150">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-151">"lsr r27 \n\t" \</front>
<front id="stepperCPP-152">"adc %A0, r26 \n\t" \</front>
<front id="stepperCPP-153">"adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-154">"clr r1 \n\t" \</front>
<front id="stepperCPP-155">: \</front>
<front id="stepperCPP-156">"=&r" (intRes) \</front>
<front id="stepperCPP-157">: \</front>
<front id="stepperCPP-158">"d" (longIn1), \</front>
<front id="stepperCPP-159">"d" (longIn2) \</front>
<front id="stepperCPP-160">: \</front>
<front id="stepperCPP-161">"r26" , "r27" \</front>
<front id="stepperCPP-162">)</front>
<front id="stepperCPP-163"></front>
<front id="stepperCPP-164">// Some useful constants</front>
<front id="stepperCPP-165"></front>
<front id="stepperCPP-166">#define ENABLE_STEPPER_DRIVER_INTERRUPT()  TIMSK1 |= (1&lt;&lt;OCIE1A)</front>
<front id="stepperCPP-167">#define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~(1&lt;&lt;OCIE1A)</front>
<front id="stepperCPP-168"></front>
<front id="stepperCPP-169"></front>
<front id="stepperCPP-170">void checkHitEndstops()</front>
<front id="stepperCPP-171">{</front>
<front id="stepperCPP-172"> if( endstop_x_hit || endstop_y_hit || endstop_z_hit) {</front>
<front id="stepperCPP-173">   SERIAL_ECHO_START;</front>
<front id="stepperCPP-174">   SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);</front>
<front id="stepperCPP-175">   if(endstop_x_hit) {</front>
<front id="stepperCPP-176">     SERIAL_ECHOPAIR(" X:",(float)endstops_trigsteps[X_AXIS]/axis_steps_per_unit[X_AXIS]);</front>
<front id="stepperCPP-177">     LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "X");</front>
<front id="stepperCPP-178">   }</front>
<front id="stepperCPP-179">   if(endstop_y_hit) {</front>
<front id="stepperCPP-180">     SERIAL_ECHOPAIR(" Y:",(float)endstops_trigsteps[Y_AXIS]/axis_steps_per_unit[Y_AXIS]);</front>
<front id="stepperCPP-181">     LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Y");</front>
<front id="stepperCPP-182">   }</front>
<front id="stepperCPP-183">   if(endstop_z_hit) {</front>
<front id="stepperCPP-184">     SERIAL_ECHOPAIR(" Z:",(float)endstops_trigsteps[Z_AXIS]/axis_steps_per_unit[Z_AXIS]);</front>
<front id="stepperCPP-185">     LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Z");</front>
<front id="stepperCPP-186">   }</front>
<front id="stepperCPP-187">   SERIAL_ECHOLN("");</front>
<front id="stepperCPP-188">   endstop_x_hit=false;</front>
<front id="stepperCPP-189">   endstop_y_hit=false;</front>
<front id="stepperCPP-190">   endstop_z_hit=false;</front>
<front id="stepperCPP-191">#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="stepperCPP-192">   if (abort_on_endstop_hit)</front>
<front id="stepperCPP-193">   {</front>
<front id="stepperCPP-194">     card.sdprinting = false;</front>
<front id="stepperCPP-195">     card.closefile();</front>
<front id="stepperCPP-196">     quickStop();</front>
<front id="stepperCPP-197">     setTargetHotend0(0);</front>
<front id="stepperCPP-198">     setTargetHotend1(0);</front>
<front id="stepperCPP-199">     setTargetHotend2(0);</front>
<front id="stepperCPP-200">   }</front>
<front id="stepperCPP-201">#endif</front>
<front id="stepperCPP-202"> }</front>
<front id="stepperCPP-203">}</front>
<front id="stepperCPP-204"></front>
<front id="stepperCPP-205">void endstops_hit_on_purpose()</front>
<front id="stepperCPP-206">{</front>
<front id="stepperCPP-207">  endstop_x_hit=false;</front>
<front id="stepperCPP-208">  endstop_y_hit=false;</front>
<front id="stepperCPP-209">  endstop_z_hit=false;</front>
<front id="stepperCPP-210">}</front>
<front id="stepperCPP-211"></front>
<front id="stepperCPP-212">void enable_endstops(bool check)</front>
<front id="stepperCPP-213">{</front>
<front id="stepperCPP-214">  check_endstops = check;</front>
<front id="stepperCPP-215">}</front>
<front id="stepperCPP-216"></front>
<front id="stepperCPP-217">//         __________________________</front>
<front id="stepperCPP-218">//        /|                        |\     _________________         ^</front>
<front id="stepperCPP-219">//       / |                        | \   /|               |\        |</front>
<front id="stepperCPP-220">//      /  |                        |  \ / |               | \       s</front>
<front id="stepperCPP-221">//     /   |                        |   |  |               |  \      p</front>
<front id="stepperCPP-222">//    /    |                        |   |  |               |   \     e</front>
<front id="stepperCPP-223">//   +-----+------------------------+---+--+---------------+----+    e</front>
<front id="stepperCPP-224">//   |               BLOCK 1            |      BLOCK 2          |    d</front>
<front id="stepperCPP-225">//</front>
<front id="stepperCPP-226">//                           time -----&gt;</front>
<front id="stepperCPP-227">//</front>
<front id="stepperCPP-228">//  The trapezoid is the shape the speed curve over time. It starts at block-&gt;initial_rate, accelerates</front>
<front id="stepperCPP-229">//  first block-&gt;accelerate_until step_events_completed, then keeps going at constant speed until</front>
<front id="stepperCPP-230">//  step_events_completed reaches block-&gt;decelerate_after after which it decelerates until the trapezoid generator is reset.</front>
<front id="stepperCPP-231">//  The slope of acceleration is calculated with the leib ramp alghorithm.</front>
<front id="stepperCPP-232"></front>
<front id="stepperCPP-233">void st_wake_up() {</front>
<front id="stepperCPP-234">  //  TCNT1 = 0;</front>
<front id="stepperCPP-235">  ENABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-236">}</front>
<front id="stepperCPP-237"></front>
<front id="stepperCPP-238">void step_wait(){</front>
<front id="stepperCPP-239">    for(int8_t i=0; i &lt; 6; i++){</front>
<front id="stepperCPP-240">    }</front>
<front id="stepperCPP-241">}</front>
<front id="stepperCPP-242"></front>
<front id="stepperCPP-243"></front>
<front id="stepperCPP-244">FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {</front>
<front id="stepperCPP-245">  unsigned short timer;</front>
<front id="stepperCPP-246">  if(step_rate &gt; MAX_STEP_FREQUENCY) step_rate = MAX_STEP_FREQUENCY;</front>
<front id="stepperCPP-247"></front>
<front id="stepperCPP-248">  if(step_rate &gt; 20000) { // If steprate &gt; 20kHz &gt;&gt; step 4 times</front>
<front id="stepperCPP-249">    step_rate = (step_rate &gt;&gt; 2)&0x3fff;</front>
<front id="stepperCPP-250">    step_loops = 4;</front>
<front id="stepperCPP-251">  }</front>
<front id="stepperCPP-252">  else if(step_rate &gt; 10000) { // If steprate &gt; 10kHz &gt;&gt; step 2 times</front>
<front id="stepperCPP-253">    step_rate = (step_rate &gt;&gt; 1)&0x7fff;</front>
<front id="stepperCPP-254">    step_loops = 2;</front>
<front id="stepperCPP-255">  }</front>
<front id="stepperCPP-256">  else {</front>
<front id="stepperCPP-257">    step_loops = 1;</front>
<front id="stepperCPP-258">  }</front>
<front id="stepperCPP-259"></front>
<front id="stepperCPP-260">  if(step_rate &lt; (F_CPU/500000)) step_rate = (F_CPU/500000);</front>
<front id="stepperCPP-261">  step_rate -= (F_CPU/500000); // Correct for minimal speed</front>
<front id="stepperCPP-262">  if(step_rate &gt;= (8*256)){ // higher step rate</front>
<front id="stepperCPP-263">    unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate&gt;&gt;8)][0];</front>
<front id="stepperCPP-264">    unsigned char tmp_step_rate = (step_rate & 0x00ff);</front>
<front id="stepperCPP-265">    unsigned short gain = (unsigned short)pgm_read_word_near(table_address+2);</front>
<front id="stepperCPP-266">    MultiU16X8toH16(timer, tmp_step_rate, gain);</front>
<front id="stepperCPP-267">    timer = (unsigned short)pgm_read_word_near(table_address) - timer;</front>
<front id="stepperCPP-268">  }</front>
<front id="stepperCPP-269">  else { // lower step rates</front>
<front id="stepperCPP-270">    unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];</front>
<front id="stepperCPP-271">    table_address += ((step_rate)&gt;&gt;1) & 0xfffc;</front>
<front id="stepperCPP-272">    timer = (unsigned short)pgm_read_word_near(table_address);</front>
<front id="stepperCPP-273">    timer -= (((unsigned short)pgm_read_word_near(table_address+2) * (unsigned char)(step_rate & 0x0007))&gt;&gt;3);</front>
<front id="stepperCPP-274">  }</front>
<front id="stepperCPP-275">  if(timer &lt; 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TOO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)</front>
<front id="stepperCPP-276">  return timer;</front>
<front id="stepperCPP-277">}</front>
<front id="stepperCPP-278"></front>
<front id="stepperCPP-279">// Initializes the trapezoid generator from the current block. Called whenever a new</front>
<front id="stepperCPP-280">// block begins.</front>
<front id="stepperCPP-281">FORCE_INLINE void trapezoid_generator_reset() {</front>
<front id="stepperCPP-282">  #ifdef ADVANCE</front>
<front id="stepperCPP-283">    advance = current_block-&gt;initial_advance;</front>
<front id="stepperCPP-284">    final_advance = current_block-&gt;final_advance;</front>
<front id="stepperCPP-285">    // Do E steps + advance steps</front>
<front id="stepperCPP-286">    e_steps[current_block-&gt;active_extruder] += ((advance &gt;&gt;8) - old_advance);</front>
<front id="stepperCPP-287">    old_advance = advance &gt;&gt;8;</front>
<front id="stepperCPP-288">  #endif</front>
<front id="stepperCPP-289">  deceleration_time = 0;</front>
<front id="stepperCPP-290">  // step_rate to timer interval</front>
<front id="stepperCPP-291">  OCR1A_nominal = calc_timer(current_block-&gt;nominal_rate);</front>
<front id="stepperCPP-292">  // make a note of the number of step loops required at nominal speed</front>
<front id="stepperCPP-293">  step_loops_nominal = step_loops;</front>
<front id="stepperCPP-294">  acc_step_rate = current_block-&gt;initial_rate;</front>
<front id="stepperCPP-295">  acceleration_time = calc_timer(acc_step_rate);</front>
<front id="stepperCPP-296">  OCR1A = acceleration_time;</front>
<front id="stepperCPP-297"></front>
<front id="stepperCPP-298">//    SERIAL_ECHO_START;</front>
<front id="stepperCPP-299">//    SERIAL_ECHOPGM("advance :");</front>
<front id="stepperCPP-300">//    SERIAL_ECHO(current_block-&gt;advance/256.0);</front>
<front id="stepperCPP-301">//    SERIAL_ECHOPGM("advance rate :");</front>
<front id="stepperCPP-302">//    SERIAL_ECHO(current_block-&gt;advance_rate/256.0);</front>
<front id="stepperCPP-303">//    SERIAL_ECHOPGM("initial advance :");</front>
<front id="stepperCPP-304">//  SERIAL_ECHO(current_block-&gt;initial_advance/256.0);</front>
<front id="stepperCPP-305">//    SERIAL_ECHOPGM("final advance :");</front>
<front id="stepperCPP-306">//    SERIAL_ECHOLN(current_block-&gt;final_advance/256.0);</front>
<front id="stepperCPP-307"></front>
<front id="stepperCPP-308">}</front>
<front id="stepperCPP-309"></front>
<front id="stepperCPP-310">// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.</front>
<front id="stepperCPP-311">// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.</front>
<front id="stepperCPP-312">ISR(TIMER1_COMPA_vect)</front>
<front id="stepperCPP-313">{</front>
<front id="stepperCPP-314">  // If there is no current block, attempt to pop one from the buffer</front>
<front id="stepperCPP-315">  if (current_block == NULL) {</front>
<front id="stepperCPP-316">    // Anything in the buffer?</front>
<front id="stepperCPP-317">    current_block = plan_get_current_block();</front>
<front id="stepperCPP-318">    if (current_block != NULL) {</front>
<front id="stepperCPP-319">      current_block-&gt;busy = true;</front>
<front id="stepperCPP-320">      trapezoid_generator_reset();</front>
<front id="stepperCPP-321">      counter_x = -(current_block-&gt;step_event_count &gt;&gt; 1);</front>
<front id="stepperCPP-322">      counter_y = counter_x;</front>
<front id="stepperCPP-323">      counter_z = counter_x;</front>
<front id="stepperCPP-324">      counter_e = counter_x;</front>
<front id="stepperCPP-325">      step_events_completed = 0;</front>
<front id="stepperCPP-326"></front>
<front id="stepperCPP-327">      #ifdef Z_LATE_ENABLE</front>
<front id="stepperCPP-328">        if(current_block-&gt;steps_z &gt; 0) {</front>
<front id="stepperCPP-329">          enable_z();</front>
<front id="stepperCPP-330">          OCR1A = 2000; //1ms wait</front>
<front id="stepperCPP-331">          return;</front>
<front id="stepperCPP-332">        }</front>
<front id="stepperCPP-333">      #endif</front>
<front id="stepperCPP-334"></front>
<front id="stepperCPP-335">//      #ifdef ADVANCE</front>
<front id="stepperCPP-336">//      e_steps[current_block-&gt;active_extruder] = 0;</front>
<front id="stepperCPP-337">//      #endif</front>
<front id="stepperCPP-338">    }</front>
<front id="stepperCPP-339">    else {</front>
<front id="stepperCPP-340">        OCR1A=2000; // 1kHz.</front>
<front id="stepperCPP-341">    }</front>
<front id="stepperCPP-342">  }</front>
<front id="stepperCPP-343"></front>
<front id="stepperCPP-344">  if (current_block != NULL) {</front>
<front id="stepperCPP-345">    // Set directions TO DO This should be done once during init of trapezoid. Endstops -&gt; interrupt</front>
<front id="stepperCPP-346">    out_bits = current_block-&gt;direction_bits;</front>
<front id="stepperCPP-347"></front>
<front id="stepperCPP-348"></front>
<front id="stepperCPP-349">    // Set the direction bits (X_AXIS=A_AXIS and Y_AXIS=B_AXIS for COREXY)</front>
<front id="stepperCPP-350">    if((out_bits & (1&lt;&lt;X_AXIS))!=0){</front>
<front id="stepperCPP-351">      #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-352">        if (extruder_duplication_enabled){</front>
<front id="stepperCPP-353">          WRITE(X_DIR_PIN, INVERT_X_DIR);</front>
<front id="stepperCPP-354">          WRITE(X2_DIR_PIN, INVERT_X_DIR);</front>
<front id="stepperCPP-355">        }</front>
<front id="stepperCPP-356">        else{</front>
<front id="stepperCPP-357">          if (current_block-&gt;active_extruder != 0)</front>
<front id="stepperCPP-358">            WRITE(X2_DIR_PIN, INVERT_X_DIR);</front>
<front id="stepperCPP-359">          else</front>
<front id="stepperCPP-360">            WRITE(X_DIR_PIN, INVERT_X_DIR);</front>
<front id="stepperCPP-361">        }</front>
<front id="stepperCPP-362">      #else</front>
<front id="stepperCPP-363">        WRITE(X_DIR_PIN, INVERT_X_DIR);</front>
<front id="stepperCPP-364">      #endif        </front>
<front id="stepperCPP-365">      count_direction[X_AXIS]=-1;</front>
<front id="stepperCPP-366">    }</front>
<front id="stepperCPP-367">    else{</front>
<front id="stepperCPP-368">      #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-369">        if (extruder_duplication_enabled){</front>
<front id="stepperCPP-370">          WRITE(X_DIR_PIN, !INVERT_X_DIR);</front>
<front id="stepperCPP-371">          WRITE(X2_DIR_PIN, !INVERT_X_DIR);</front>
<front id="stepperCPP-372">        }</front>
<front id="stepperCPP-373">        else{</front>
<front id="stepperCPP-374">          if (current_block-&gt;active_extruder != 0)</front>
<front id="stepperCPP-375">            WRITE(X2_DIR_PIN, !INVERT_X_DIR);</front>
<front id="stepperCPP-376">          else</front>
<front id="stepperCPP-377">            WRITE(X_DIR_PIN, !INVERT_X_DIR);</front>
<front id="stepperCPP-378">        }</front>
<front id="stepperCPP-379">      #else</front>
<front id="stepperCPP-380">        WRITE(X_DIR_PIN, !INVERT_X_DIR);</front>
<front id="stepperCPP-381">      #endif        </front>
<front id="stepperCPP-382">      count_direction[X_AXIS]=1;</front>
<front id="stepperCPP-383">    }</front>
<front id="stepperCPP-384">    if((out_bits & (1&lt;&lt;Y_AXIS))!=0){</front>
<front id="stepperCPP-385">      WRITE(Y_DIR_PIN, INVERT_Y_DIR);</front>
<front id="stepperCPP-386">      count_direction[Y_AXIS]=-1;</front>
<front id="stepperCPP-387">    }</front>
<front id="stepperCPP-388">    else{</front>
<front id="stepperCPP-389">      WRITE(Y_DIR_PIN, !INVERT_Y_DIR);</front>
<front id="stepperCPP-390">      count_direction[Y_AXIS]=1;</front>
<front id="stepperCPP-391">    }</front>
<front id="stepperCPP-392"></front>
<front id="stepperCPP-393">    // Set direction en check limit switches</front>
<front id="stepperCPP-394">    #ifndef COREXY</front>
<front id="stepperCPP-395">    if ((out_bits & (1&lt;&lt;X_AXIS)) != 0) {   // stepping along -X axis</front>
<front id="stepperCPP-396">    #else</front>
<front id="stepperCPP-397">    if ((((out_bits & (1&lt;&lt;X_AXIS)) != 0)&&(out_bits & (1&lt;&lt;Y_AXIS)) != 0)) {   //-X occurs for -A and -B</front>
<front id="stepperCPP-398">    #endif</front>
<front id="stepperCPP-399">      CHECK_ENDSTOPS</front>
<front id="stepperCPP-400">      {</front>
<front id="stepperCPP-401">        #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-402">        // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder</front>
<front id="stepperCPP-403">        if ((current_block-&gt;active_extruder == 0 && X_HOME_DIR == -1) </front>
<front id="stepperCPP-404">            || (current_block-&gt;active_extruder != 0 && X2_HOME_DIR == -1))</front>
<front id="stepperCPP-405">        #endif          </front>
<front id="stepperCPP-406">        {</front>
<front id="stepperCPP-407">          #if defined(X_MIN_PIN) && X_MIN_PIN &gt; -1</front>
<front id="stepperCPP-408">            bool x_min_endstop=(READ(X_MIN_PIN) != X_MIN_ENDSTOP_INVERTING);</front>
<front id="stepperCPP-409">            if(x_min_endstop && old_x_min_endstop && (current_block-&gt;steps_x &gt; 0)) {</front>
<front id="stepperCPP-410">              endstops_trigsteps[X_AXIS] = count_position[X_AXIS];</front>
<front id="stepperCPP-411">              endstop_x_hit=true;</front>
<front id="stepperCPP-412">              step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-413">            }</front>
<front id="stepperCPP-414">            old_x_min_endstop = x_min_endstop;</front>
<front id="stepperCPP-415">          #endif</front>
<front id="stepperCPP-416">        }</front>
<front id="stepperCPP-417">      }</front>
<front id="stepperCPP-418">    }</front>
<front id="stepperCPP-419">    else { // +direction</front>
<front id="stepperCPP-420">      CHECK_ENDSTOPS</front>
<front id="stepperCPP-421">      {</front>
<front id="stepperCPP-422">        #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-423">        // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder</front>
<front id="stepperCPP-424">        if ((current_block-&gt;active_extruder == 0 && X_HOME_DIR == 1) </front>
<front id="stepperCPP-425">            || (current_block-&gt;active_extruder != 0 && X2_HOME_DIR == 1))</front>
<front id="stepperCPP-426">        #endif          </front>
<front id="stepperCPP-427">        {</front>
<front id="stepperCPP-428">          #if defined(X_MAX_PIN) && X_MAX_PIN &gt; -1</front>
<front id="stepperCPP-429">            bool x_max_endstop=(READ(X_MAX_PIN) != X_MAX_ENDSTOP_INVERTING);</front>
<front id="stepperCPP-430">            if(x_max_endstop && old_x_max_endstop && (current_block-&gt;steps_x &gt; 0)){</front>
<front id="stepperCPP-431">              endstops_trigsteps[X_AXIS] = count_position[X_AXIS];</front>
<front id="stepperCPP-432">              endstop_x_hit=true;</front>
<front id="stepperCPP-433">              step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-434">            }</front>
<front id="stepperCPP-435">            old_x_max_endstop = x_max_endstop;</front>
<front id="stepperCPP-436">          #endif</front>
<front id="stepperCPP-437">        }</front>
<front id="stepperCPP-438">      }</front>
<front id="stepperCPP-439">    }</front>
<front id="stepperCPP-440"></front>
<front id="stepperCPP-441">    #ifndef COREXY</front>
<front id="stepperCPP-442">    if ((out_bits & (1&lt;&lt;Y_AXIS)) != 0) {   // -direction</front>
<front id="stepperCPP-443">    #else</front>
<front id="stepperCPP-444">    if ((((out_bits & (1&lt;&lt;X_AXIS)) != 0)&&(out_bits & (1&lt;&lt;Y_AXIS)) == 0)) {   // -Y occurs for -A and +B</front>
<front id="stepperCPP-445">    #endif</front>
<front id="stepperCPP-446">      CHECK_ENDSTOPS</front>
<front id="stepperCPP-447">      {</front>
<front id="stepperCPP-448">        #if defined(Y_MIN_PIN) && Y_MIN_PIN &gt; -1</front>
<front id="stepperCPP-449">          bool y_min_endstop=(READ(Y_MIN_PIN) != Y_MIN_ENDSTOP_INVERTING);</front>
<front id="stepperCPP-450">          if(y_min_endstop && old_y_min_endstop && (current_block-&gt;steps_y &gt; 0)) {</front>
<front id="stepperCPP-451">            endstops_trigsteps[Y_AXIS] = count_position[Y_AXIS];</front>
<front id="stepperCPP-452">            endstop_y_hit=true;</front>
<front id="stepperCPP-453">            step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-454">          }</front>
<front id="stepperCPP-455">          old_y_min_endstop = y_min_endstop;</front>
<front id="stepperCPP-456">        #endif</front>
<front id="stepperCPP-457">      }</front>
<front id="stepperCPP-458">    }</front>
<front id="stepperCPP-459">    else { // +direction</front>
<front id="stepperCPP-460">      CHECK_ENDSTOPS</front>
<front id="stepperCPP-461">      {</front>
<front id="stepperCPP-462">        #if defined(Y_MAX_PIN) && Y_MAX_PIN &gt; -1</front>
<front id="stepperCPP-463">          bool y_max_endstop=(READ(Y_MAX_PIN) != Y_MAX_ENDSTOP_INVERTING);</front>
<front id="stepperCPP-464">          if(y_max_endstop && old_y_max_endstop && (current_block-&gt;steps_y &gt; 0)){</front>
<front id="stepperCPP-465">            endstops_trigsteps[Y_AXIS] = count_position[Y_AXIS];</front>
<front id="stepperCPP-466">            endstop_y_hit=true;</front>
<front id="stepperCPP-467">            step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-468">          }</front>
<front id="stepperCPP-469">          old_y_max_endstop = y_max_endstop;</front>
<front id="stepperCPP-470">        #endif</front>
<front id="stepperCPP-471">      }</front>
<front id="stepperCPP-472">    }</front>
<front id="stepperCPP-473"></front>
<front id="stepperCPP-474">    if ((out_bits & (1&lt;&lt;Z_AXIS)) != 0) {   // -direction</front>
<front id="stepperCPP-475">      WRITE(Z_DIR_PIN,INVERT_Z_DIR);</front>
<front id="stepperCPP-476">      </front>
<front id="stepperCPP-477">      #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-478">        WRITE(Z2_DIR_PIN,INVERT_Z_DIR);</front>
<front id="stepperCPP-479">      #endif</front>
<front id="stepperCPP-480"></front>
<front id="stepperCPP-481">      count_direction[Z_AXIS]=-1;</front>
<front id="stepperCPP-482">      CHECK_ENDSTOPS</front>
<front id="stepperCPP-483">      {</front>
<front id="stepperCPP-484">        #if defined(Z_MIN_PIN) && Z_MIN_PIN &gt; -1</front>
<front id="stepperCPP-485">          bool z_min_endstop=(READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="stepperCPP-486">          if(z_min_endstop && old_z_min_endstop && (current_block-&gt;steps_z &gt; 0)) {</front>
<front id="stepperCPP-487">            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];</front>
<front id="stepperCPP-488">            endstop_z_hit=true;</front>
<front id="stepperCPP-489">            step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-490">          }</front>
<front id="stepperCPP-491">          old_z_min_endstop = z_min_endstop;</front>
<front id="stepperCPP-492">        #endif</front>
<front id="stepperCPP-493">      }</front>
<front id="stepperCPP-494">    }</front>
<front id="stepperCPP-495">    else { // +direction</front>
<front id="stepperCPP-496">      WRITE(Z_DIR_PIN,!INVERT_Z_DIR);</front>
<front id="stepperCPP-497"></front>
<front id="stepperCPP-498">      #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-499">        WRITE(Z2_DIR_PIN,!INVERT_Z_DIR);</front>
<front id="stepperCPP-500">      #endif</front>
<front id="stepperCPP-501"></front>
<front id="stepperCPP-502">      count_direction[Z_AXIS]=1;</front>
<front id="stepperCPP-503">      CHECK_ENDSTOPS</front>
<front id="stepperCPP-504">      {</front>
<front id="stepperCPP-505">        #if defined(Z_MAX_PIN) && Z_MAX_PIN &gt; -1</front>
<front id="stepperCPP-506">          bool z_max_endstop=(READ(Z_MAX_PIN) != Z_MAX_ENDSTOP_INVERTING);</front>
<front id="stepperCPP-507">          if(z_max_endstop && old_z_max_endstop && (current_block-&gt;steps_z &gt; 0)) {</front>
<front id="stepperCPP-508">            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];</front>
<front id="stepperCPP-509">            endstop_z_hit=true;</front>
<front id="stepperCPP-510">            step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-511">          }</front>
<front id="stepperCPP-512">          old_z_max_endstop = z_max_endstop;</front>
<front id="stepperCPP-513">        #endif</front>
<front id="stepperCPP-514">      }</front>
<front id="stepperCPP-515">    }</front>
<front id="stepperCPP-516"></front>
<front id="stepperCPP-517">    #ifndef ADVANCE</front>
<front id="stepperCPP-518">      if ((out_bits & (1&lt;&lt;E_AXIS)) != 0) {  // -direction</front>
<front id="stepperCPP-519">        REV_E_DIR();</front>
<front id="stepperCPP-520">        count_direction[E_AXIS]=-1;</front>
<front id="stepperCPP-521">      }</front>
<front id="stepperCPP-522">      else { // +direction</front>
<front id="stepperCPP-523">        NORM_E_DIR();</front>
<front id="stepperCPP-524">        count_direction[E_AXIS]=1;</front>
<front id="stepperCPP-525">      }</front>
<front id="stepperCPP-526">    #endif //!ADVANCE</front>
<front id="stepperCPP-527"></front>
<front id="stepperCPP-528"></front>
<front id="stepperCPP-529"></front>
<front id="stepperCPP-530">    for(int8_t i=0; i &lt; step_loops; i++) { // Take multiple steps per interrupt (For high speed moves)</front>
<front id="stepperCPP-531">      #ifndef AT90USB</front>
<front id="stepperCPP-532">      MSerial.checkRx(); // Check for serial chars.</front>
<front id="stepperCPP-533">      #endif</front>
<front id="stepperCPP-534"></front>
<front id="stepperCPP-535">      #ifdef ADVANCE</front>
<front id="stepperCPP-536">      counter_e += current_block-&gt;steps_e;</front>
<front id="stepperCPP-537">      if (counter_e &gt; 0) {</front>
<front id="stepperCPP-538">        counter_e -= current_block-&gt;step_event_count;</front>
<front id="stepperCPP-539">        if ((out_bits & (1&lt;&lt;E_AXIS)) != 0) { // - direction</front>
<front id="stepperCPP-540">          e_steps[current_block-&gt;active_extruder]--;</front>
<front id="stepperCPP-541">        }</front>
<front id="stepperCPP-542">        else {</front>
<front id="stepperCPP-543">          e_steps[current_block-&gt;active_extruder]++;</front>
<front id="stepperCPP-544">        }</front>
<front id="stepperCPP-545">      }</front>
<front id="stepperCPP-546">      #endif //ADVANCE</front>
<front id="stepperCPP-547"></front>
<front id="stepperCPP-548">        counter_x += current_block-&gt;steps_x;</front>
<front id="stepperCPP-549">        if (counter_x &gt; 0) {</front>
<front id="stepperCPP-550">        #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-551">          if (extruder_duplication_enabled){</front>
<front id="stepperCPP-552">            WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-553">            WRITE(X2_STEP_PIN, !INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-554">          }</front>
<front id="stepperCPP-555">          else {</front>
<front id="stepperCPP-556">            if (current_block-&gt;active_extruder != 0)</front>
<front id="stepperCPP-557">              WRITE(X2_STEP_PIN, !INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-558">            else</front>
<front id="stepperCPP-559">              WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-560">          }</front>
<front id="stepperCPP-561">        #else</front>
<front id="stepperCPP-562">          WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-563">        #endif        </front>
<front id="stepperCPP-564">          counter_x -= current_block-&gt;step_event_count;</front>
<front id="stepperCPP-565">          count_position[X_AXIS]+=count_direction[X_AXIS];   </front>
<front id="stepperCPP-566">        #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-567">          if (extruder_duplication_enabled){</front>
<front id="stepperCPP-568">            WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-569">            WRITE(X2_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-570">          }</front>
<front id="stepperCPP-571">          else {</front>
<front id="stepperCPP-572">            if (current_block-&gt;active_extruder != 0)</front>
<front id="stepperCPP-573">              WRITE(X2_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-574">            else</front>
<front id="stepperCPP-575">              WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-576">          }</front>
<front id="stepperCPP-577">        #else</front>
<front id="stepperCPP-578">          WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-579">        #endif</front>
<front id="stepperCPP-580">        }</front>
<front id="stepperCPP-581"></front>
<front id="stepperCPP-582">        counter_y += current_block-&gt;steps_y;</front>
<front id="stepperCPP-583">        if (counter_y &gt; 0) {</front>
<front id="stepperCPP-584">          WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-585">          counter_y -= current_block-&gt;step_event_count;</front>
<front id="stepperCPP-586">          count_position[Y_AXIS]+=count_direction[Y_AXIS];</front>
<front id="stepperCPP-587">          WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-588">        }</front>
<front id="stepperCPP-589"></front>
<front id="stepperCPP-590">      counter_z += current_block-&gt;steps_z;</front>
<front id="stepperCPP-591">      if (counter_z &gt; 0) {</front>
<front id="stepperCPP-592">        WRITE(Z_STEP_PIN, !INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-593">        </front>
<front id="stepperCPP-594">        #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-595">          WRITE(Z2_STEP_PIN, !INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-596">        #endif</front>
<front id="stepperCPP-597"></front>
<front id="stepperCPP-598">        counter_z -= current_block-&gt;step_event_count;</front>
<front id="stepperCPP-599">        count_position[Z_AXIS]+=count_direction[Z_AXIS];</front>
<front id="stepperCPP-600">        WRITE(Z_STEP_PIN, INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-601">        </front>
<front id="stepperCPP-602">        #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-603">          WRITE(Z2_STEP_PIN, INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-604">        #endif</front>
<front id="stepperCPP-605">      }</front>
<front id="stepperCPP-606"></front>
<front id="stepperCPP-607">      #ifndef ADVANCE</front>
<front id="stepperCPP-608">        counter_e += current_block-&gt;steps_e;</front>
<front id="stepperCPP-609">        if (counter_e &gt; 0) {</front>
<front id="stepperCPP-610">          WRITE_E_STEP(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-611">          counter_e -= current_block-&gt;step_event_count;</front>
<front id="stepperCPP-612">          count_position[E_AXIS]+=count_direction[E_AXIS];</front>
<front id="stepperCPP-613">          WRITE_E_STEP(INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-614">        }</front>
<front id="stepperCPP-615">      #endif //!ADVANCE</front>
<front id="stepperCPP-616">      step_events_completed += 1;</front>
<front id="stepperCPP-617">      if(step_events_completed &gt;= current_block-&gt;step_event_count) break;</front>
<front id="stepperCPP-618">    }</front>
<front id="stepperCPP-619">    // Calculare new timer value</front>
<front id="stepperCPP-620">    unsigned short timer;</front>
<front id="stepperCPP-621">    unsigned short step_rate;</front>
<front id="stepperCPP-622">    if (step_events_completed &lt;= (unsigned long int)current_block-&gt;accelerate_until) {</front>
<front id="stepperCPP-623"></front>
<front id="stepperCPP-624">      MultiU24X24toH16(acc_step_rate, acceleration_time, current_block-&gt;acceleration_rate);</front>
<front id="stepperCPP-625">      acc_step_rate += current_block-&gt;initial_rate;</front>
<front id="stepperCPP-626"></front>
<front id="stepperCPP-627">      // upper limit</front>
<front id="stepperCPP-628">      if(acc_step_rate &gt; current_block-&gt;nominal_rate)</front>
<front id="stepperCPP-629">        acc_step_rate = current_block-&gt;nominal_rate;</front>
<front id="stepperCPP-630"></front>
<front id="stepperCPP-631">      // step_rate to timer interval</front>
<front id="stepperCPP-632">      timer = calc_timer(acc_step_rate);</front>
<front id="stepperCPP-633">      OCR1A = timer;</front>
<front id="stepperCPP-634">      acceleration_time += timer;</front>
<front id="stepperCPP-635">      #ifdef ADVANCE</front>
<front id="stepperCPP-636">        for(int8_t i=0; i &lt; step_loops; i++) {</front>
<front id="stepperCPP-637">          advance += advance_rate;</front>
<front id="stepperCPP-638">        }</front>
<front id="stepperCPP-639">        //if(advance &gt; current_block-&gt;advance) advance = current_block-&gt;advance;</front>
<front id="stepperCPP-640">        // Do E steps + advance steps</front>
<front id="stepperCPP-641">        e_steps[current_block-&gt;active_extruder] += ((advance &gt;&gt;8) - old_advance);</front>
<front id="stepperCPP-642">        old_advance = advance &gt;&gt;8;</front>
<front id="stepperCPP-643"></front>
<front id="stepperCPP-644">      #endif</front>
<front id="stepperCPP-645">    }</front>
<front id="stepperCPP-646">    else if (step_events_completed &gt; (unsigned long int)current_block-&gt;decelerate_after) {</front>
<front id="stepperCPP-647">      MultiU24X24toH16(step_rate, deceleration_time, current_block-&gt;acceleration_rate);</front>
<front id="stepperCPP-648"></front>
<front id="stepperCPP-649">      if(step_rate &gt; acc_step_rate) { // Check step_rate stays positive</front>
<front id="stepperCPP-650">        step_rate = current_block-&gt;final_rate;</front>
<front id="stepperCPP-651">      }</front>
<front id="stepperCPP-652">      else {</front>
<front id="stepperCPP-653">        step_rate = acc_step_rate - step_rate; // Decelerate from aceleration end point.</front>
<front id="stepperCPP-654">      }</front>
<front id="stepperCPP-655"></front>
<front id="stepperCPP-656">      // lower limit</front>
<front id="stepperCPP-657">      if(step_rate &lt; current_block-&gt;final_rate)</front>
<front id="stepperCPP-658">        step_rate = current_block-&gt;final_rate;</front>
<front id="stepperCPP-659"></front>
<front id="stepperCPP-660">      // step_rate to timer interval</front>
<front id="stepperCPP-661">      timer = calc_timer(step_rate);</front>
<front id="stepperCPP-662">      OCR1A = timer;</front>
<front id="stepperCPP-663">      deceleration_time += timer;</front>
<front id="stepperCPP-664">      #ifdef ADVANCE</front>
<front id="stepperCPP-665">        for(int8_t i=0; i &lt; step_loops; i++) {</front>
<front id="stepperCPP-666">          advance -= advance_rate;</front>
<front id="stepperCPP-667">        }</front>
<front id="stepperCPP-668">        if(advance &lt; final_advance) advance = final_advance;</front>
<front id="stepperCPP-669">        // Do E steps + advance steps</front>
<front id="stepperCPP-670">        e_steps[current_block-&gt;active_extruder] += ((advance &gt;&gt;8) - old_advance);</front>
<front id="stepperCPP-671">        old_advance = advance &gt;&gt;8;</front>
<front id="stepperCPP-672">      #endif //ADVANCE</front>
<front id="stepperCPP-673">    }</front>
<front id="stepperCPP-674">    else {</front>
<front id="stepperCPP-675">      OCR1A = OCR1A_nominal;</front>
<front id="stepperCPP-676">      // ensure we're running at the correct step rate, even if we just came off an acceleration</front>
<front id="stepperCPP-677">      step_loops = step_loops_nominal;</front>
<front id="stepperCPP-678">    }</front>
<front id="stepperCPP-679"></front>
<front id="stepperCPP-680">    // If current block is finished, reset pointer</front>
<front id="stepperCPP-681">    if (step_events_completed &gt;= current_block-&gt;step_event_count) {</front>
<front id="stepperCPP-682">      current_block = NULL;</front>
<front id="stepperCPP-683">      plan_discard_current_block();</front>
<front id="stepperCPP-684">    }</front>
<front id="stepperCPP-685">  }</front>
<front id="stepperCPP-686">}</front>
<front id="stepperCPP-687"></front>
<front id="stepperCPP-688">#ifdef ADVANCE</front>
<front id="stepperCPP-689">  unsigned char old_OCR0A;</front>
<front id="stepperCPP-690">  // Timer interrupt for E. e_steps is set in the main routine;</front>
<front id="stepperCPP-691">  // Timer 0 is shared with millies</front>
<front id="stepperCPP-692">  ISR(TIMER0_COMPA_vect)</front>
<front id="stepperCPP-693">  {</front>
<front id="stepperCPP-694">    old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)</front>
<front id="stepperCPP-695">    OCR0A = old_OCR0A;</front>
<front id="stepperCPP-696">    // Set E direction (Depends on E direction + advance)</front>
<front id="stepperCPP-697">    for(unsigned char i=0; i&lt;4;i++) {</front>
<front id="stepperCPP-698">      if (e_steps[0] != 0) {</front>
<front id="stepperCPP-699">        WRITE(E0_STEP_PIN, INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-700">        if (e_steps[0] &lt; 0) {</front>
<front id="stepperCPP-701">          WRITE(E0_DIR_PIN, INVERT_E0_DIR);</front>
<front id="stepperCPP-702">          e_steps[0]++;</front>
<front id="stepperCPP-703">          WRITE(E0_STEP_PIN, !INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-704">        }</front>
<front id="stepperCPP-705">        else if (e_steps[0] &gt; 0) {</front>
<front id="stepperCPP-706">          WRITE(E0_DIR_PIN, !INVERT_E0_DIR);</front>
<front id="stepperCPP-707">          e_steps[0]--;</front>
<front id="stepperCPP-708">          WRITE(E0_STEP_PIN, !INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-709">        }</front>
<front id="stepperCPP-710">      }</front>
<front id="stepperCPP-711"> #if EXTRUDERS &gt; 1</front>
<front id="stepperCPP-712">      if (e_steps[1] != 0) {</front>
<front id="stepperCPP-713">        WRITE(E1_STEP_PIN, INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-714">        if (e_steps[1] &lt; 0) {</front>
<front id="stepperCPP-715">          WRITE(E1_DIR_PIN, INVERT_E1_DIR);</front>
<front id="stepperCPP-716">          e_steps[1]++;</front>
<front id="stepperCPP-717">          WRITE(E1_STEP_PIN, !INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-718">        }</front>
<front id="stepperCPP-719">        else if (e_steps[1] &gt; 0) {</front>
<front id="stepperCPP-720">          WRITE(E1_DIR_PIN, !INVERT_E1_DIR);</front>
<front id="stepperCPP-721">          e_steps[1]--;</front>
<front id="stepperCPP-722">          WRITE(E1_STEP_PIN, !INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-723">        }</front>
<front id="stepperCPP-724">      }</front>
<front id="stepperCPP-725"> #endif</front>
<front id="stepperCPP-726"> #if EXTRUDERS &gt; 2</front>
<front id="stepperCPP-727">      if (e_steps[2] != 0) {</front>
<front id="stepperCPP-728">        WRITE(E2_STEP_PIN, INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-729">        if (e_steps[2] &lt; 0) {</front>
<front id="stepperCPP-730">          WRITE(E2_DIR_PIN, INVERT_E2_DIR);</front>
<front id="stepperCPP-731">          e_steps[2]++;</front>
<front id="stepperCPP-732">          WRITE(E2_STEP_PIN, !INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-733">        }</front>
<front id="stepperCPP-734">        else if (e_steps[2] &gt; 0) {</front>
<front id="stepperCPP-735">          WRITE(E2_DIR_PIN, !INVERT_E2_DIR);</front>
<front id="stepperCPP-736">          e_steps[2]--;</front>
<front id="stepperCPP-737">          WRITE(E2_STEP_PIN, !INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-738">        }</front>
<front id="stepperCPP-739">      }</front>
<front id="stepperCPP-740"> #endif</front>
<front id="stepperCPP-741">    }</front>
<front id="stepperCPP-742">  }</front>
<front id="stepperCPP-743">#endif // ADVANCE</front>
<front id="stepperCPP-744"></front>
<front id="stepperCPP-745">void st_init()</front>
<front id="stepperCPP-746">{</front>
<front id="stepperCPP-747">  digipot_init(); //Initialize Digipot Motor Current</front>
<front id="stepperCPP-748">  microstep_init(); //Initialize Microstepping Pins</front>
<front id="stepperCPP-749"></front>
<front id="stepperCPP-750">  //Initialize Dir Pins</front>
<front id="stepperCPP-751">  #if defined(X_DIR_PIN) && X_DIR_PIN &gt; -1</front>
<front id="stepperCPP-752">    SET_OUTPUT(X_DIR_PIN);</front>
<front id="stepperCPP-753">  #endif</front>
<front id="stepperCPP-754">  #if defined(X2_DIR_PIN) && X2_DIR_PIN &gt; -1</front>
<front id="stepperCPP-755">    SET_OUTPUT(X2_DIR_PIN);</front>
<front id="stepperCPP-756">  #endif</front>
<front id="stepperCPP-757">  #if defined(Y_DIR_PIN) && Y_DIR_PIN &gt; -1</front>
<front id="stepperCPP-758">    SET_OUTPUT(Y_DIR_PIN);</front>
<front id="stepperCPP-759">  #endif</front>
<front id="stepperCPP-760">  #if defined(Z_DIR_PIN) && Z_DIR_PIN &gt; -1</front>
<front id="stepperCPP-761">    SET_OUTPUT(Z_DIR_PIN);</front>
<front id="stepperCPP-762"></front>
<front id="stepperCPP-763">    #if defined(Z_DUAL_STEPPER_DRIVERS) && defined(Z2_DIR_PIN) && (Z2_DIR_PIN &gt; -1)</front>
<front id="stepperCPP-764">      SET_OUTPUT(Z2_DIR_PIN);</front>
<front id="stepperCPP-765">    #endif</front>
<front id="stepperCPP-766">  #endif</front>
<front id="stepperCPP-767">  #if defined(E0_DIR_PIN) && E0_DIR_PIN &gt; -1</front>
<front id="stepperCPP-768">    SET_OUTPUT(E0_DIR_PIN);</front>
<front id="stepperCPP-769">  #endif</front>
<front id="stepperCPP-770">  #if defined(E1_DIR_PIN) && (E1_DIR_PIN &gt; -1)</front>
<front id="stepperCPP-771">    SET_OUTPUT(E1_DIR_PIN);</front>
<front id="stepperCPP-772">  #endif</front>
<front id="stepperCPP-773">  #if defined(E2_DIR_PIN) && (E2_DIR_PIN &gt; -1)</front>
<front id="stepperCPP-774">    SET_OUTPUT(E2_DIR_PIN);</front>
<front id="stepperCPP-775">  #endif</front>
<front id="stepperCPP-776"></front>
<front id="stepperCPP-777">  //Initialize Enable Pins - steppers default to disabled.</front>
<front id="stepperCPP-778"></front>
<front id="stepperCPP-779">  #if defined(X_ENABLE_PIN) && X_ENABLE_PIN &gt; -1</front>
<front id="stepperCPP-780">    SET_OUTPUT(X_ENABLE_PIN);</front>
<front id="stepperCPP-781">    if(!X_ENABLE_ON) WRITE(X_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-782">  #endif</front>
<front id="stepperCPP-783">  #if defined(X2_ENABLE_PIN) && X2_ENABLE_PIN &gt; -1</front>
<front id="stepperCPP-784">    SET_OUTPUT(X2_ENABLE_PIN);</front>
<front id="stepperCPP-785">    if(!X_ENABLE_ON) WRITE(X2_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-786">  #endif</front>
<front id="stepperCPP-787">  #if defined(Y_ENABLE_PIN) && Y_ENABLE_PIN &gt; -1</front>
<front id="stepperCPP-788">    SET_OUTPUT(Y_ENABLE_PIN);</front>
<front id="stepperCPP-789">    if(!Y_ENABLE_ON) WRITE(Y_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-790">  #endif</front>
<front id="stepperCPP-791">  #if defined(Z_ENABLE_PIN) && Z_ENABLE_PIN &gt; -1</front>
<front id="stepperCPP-792">    SET_OUTPUT(Z_ENABLE_PIN);</front>
<front id="stepperCPP-793">    if(!Z_ENABLE_ON) WRITE(Z_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-794"></front>
<front id="stepperCPP-795">    #if defined(Z_DUAL_STEPPER_DRIVERS) && defined(Z2_ENABLE_PIN) && (Z2_ENABLE_PIN &gt; -1)</front>
<front id="stepperCPP-796">      SET_OUTPUT(Z2_ENABLE_PIN);</front>
<front id="stepperCPP-797">      if(!Z_ENABLE_ON) WRITE(Z2_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-798">    #endif</front>
<front id="stepperCPP-799">  #endif</front>
<front id="stepperCPP-800">  #if defined(E0_ENABLE_PIN) && (E0_ENABLE_PIN &gt; -1)</front>
<front id="stepperCPP-801">    SET_OUTPUT(E0_ENABLE_PIN);</front>
<front id="stepperCPP-802">    if(!E_ENABLE_ON) WRITE(E0_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-803">  #endif</front>
<front id="stepperCPP-804">  #if defined(E1_ENABLE_PIN) && (E1_ENABLE_PIN &gt; -1)</front>
<front id="stepperCPP-805">    SET_OUTPUT(E1_ENABLE_PIN);</front>
<front id="stepperCPP-806">    if(!E_ENABLE_ON) WRITE(E1_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-807">  #endif</front>
<front id="stepperCPP-808">  #if defined(E2_ENABLE_PIN) && (E2_ENABLE_PIN &gt; -1)</front>
<front id="stepperCPP-809">    SET_OUTPUT(E2_ENABLE_PIN);</front>
<front id="stepperCPP-810">    if(!E_ENABLE_ON) WRITE(E2_ENABLE_PIN,HIGH);</front>
<front id="stepperCPP-811">  #endif</front>
<front id="stepperCPP-812"></front>
<front id="stepperCPP-813">  //endstops and pullups</front>
<front id="stepperCPP-814"></front>
<front id="stepperCPP-815">  #if defined(X_MIN_PIN) && X_MIN_PIN &gt; -1</front>
<front id="stepperCPP-816">    SET_INPUT(X_MIN_PIN);</front>
<front id="stepperCPP-817">    #ifdef ENDSTOPPULLUP_XMIN</front>
<front id="stepperCPP-818">      WRITE(X_MIN_PIN,HIGH);</front>
<front id="stepperCPP-819">    #endif</front>
<front id="stepperCPP-820">  #endif</front>
<front id="stepperCPP-821"></front>
<front id="stepperCPP-822">  #if defined(Y_MIN_PIN) && Y_MIN_PIN &gt; -1</front>
<front id="stepperCPP-823">    SET_INPUT(Y_MIN_PIN);</front>
<front id="stepperCPP-824">    #ifdef ENDSTOPPULLUP_YMIN</front>
<front id="stepperCPP-825">      WRITE(Y_MIN_PIN,HIGH);</front>
<front id="stepperCPP-826">    #endif</front>
<front id="stepperCPP-827">  #endif</front>
<front id="stepperCPP-828"></front>
<front id="stepperCPP-829">  #if defined(Z_MIN_PIN) && Z_MIN_PIN &gt; -1</front>
<front id="stepperCPP-830">    SET_INPUT(Z_MIN_PIN);</front>
<front id="stepperCPP-831">    #ifdef ENDSTOPPULLUP_ZMIN</front>
<front id="stepperCPP-832">      WRITE(Z_MIN_PIN,HIGH);</front>
<front id="stepperCPP-833">    #endif</front>
<front id="stepperCPP-834">  #endif</front>
<front id="stepperCPP-835"></front>
<front id="stepperCPP-836">  #if defined(X_MAX_PIN) && X_MAX_PIN &gt; -1</front>
<front id="stepperCPP-837">    SET_INPUT(X_MAX_PIN);</front>
<front id="stepperCPP-838">    #ifdef ENDSTOPPULLUP_XMAX</front>
<front id="stepperCPP-839">      WRITE(X_MAX_PIN,HIGH);</front>
<front id="stepperCPP-840">    #endif</front>
<front id="stepperCPP-841">  #endif</front>
<front id="stepperCPP-842"></front>
<front id="stepperCPP-843">  #if defined(Y_MAX_PIN) && Y_MAX_PIN &gt; -1</front>
<front id="stepperCPP-844">    SET_INPUT(Y_MAX_PIN);</front>
<front id="stepperCPP-845">    #ifdef ENDSTOPPULLUP_YMAX</front>
<front id="stepperCPP-846">      WRITE(Y_MAX_PIN,HIGH);</front>
<front id="stepperCPP-847">    #endif</front>
<front id="stepperCPP-848">  #endif</front>
<front id="stepperCPP-849"></front>
<front id="stepperCPP-850">  #if defined(Z_MAX_PIN) && Z_MAX_PIN &gt; -1</front>
<front id="stepperCPP-851">    SET_INPUT(Z_MAX_PIN);</front>
<front id="stepperCPP-852">    #ifdef ENDSTOPPULLUP_ZMAX</front>
<front id="stepperCPP-853">      WRITE(Z_MAX_PIN,HIGH);</front>
<front id="stepperCPP-854">    #endif</front>
<front id="stepperCPP-855">  #endif</front>
<front id="stepperCPP-856"></front>
<front id="stepperCPP-857"></front>
<front id="stepperCPP-858">  //Initialize Step Pins</front>
<front id="stepperCPP-859">  #if defined(X_STEP_PIN) && (X_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-860">    SET_OUTPUT(X_STEP_PIN);</front>
<front id="stepperCPP-861">    WRITE(X_STEP_PIN,INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-862">    disable_x();</front>
<front id="stepperCPP-863">  #endif</front>
<front id="stepperCPP-864">  #if defined(X2_STEP_PIN) && (X2_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-865">    SET_OUTPUT(X2_STEP_PIN);</front>
<front id="stepperCPP-866">    WRITE(X2_STEP_PIN,INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-867">    disable_x();</front>
<front id="stepperCPP-868">  #endif</front>
<front id="stepperCPP-869">  #if defined(Y_STEP_PIN) && (Y_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-870">    SET_OUTPUT(Y_STEP_PIN);</front>
<front id="stepperCPP-871">    WRITE(Y_STEP_PIN,INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-872">    disable_y();</front>
<front id="stepperCPP-873">  #endif</front>
<front id="stepperCPP-874">  #if defined(Z_STEP_PIN) && (Z_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-875">    SET_OUTPUT(Z_STEP_PIN);</front>
<front id="stepperCPP-876">    WRITE(Z_STEP_PIN,INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-877">    #if defined(Z_DUAL_STEPPER_DRIVERS) && defined(Z2_STEP_PIN) && (Z2_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-878">      SET_OUTPUT(Z2_STEP_PIN);</front>
<front id="stepperCPP-879">      WRITE(Z2_STEP_PIN,INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-880">    #endif</front>
<front id="stepperCPP-881">    disable_z();</front>
<front id="stepperCPP-882">  #endif</front>
<front id="stepperCPP-883">  #if defined(E0_STEP_PIN) && (E0_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-884">    SET_OUTPUT(E0_STEP_PIN);</front>
<front id="stepperCPP-885">    WRITE(E0_STEP_PIN,INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-886">    disable_e0();</front>
<front id="stepperCPP-887">  #endif</front>
<front id="stepperCPP-888">  #if defined(E1_STEP_PIN) && (E1_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-889">    SET_OUTPUT(E1_STEP_PIN);</front>
<front id="stepperCPP-890">    WRITE(E1_STEP_PIN,INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-891">    disable_e1();</front>
<front id="stepperCPP-892">  #endif</front>
<front id="stepperCPP-893">  #if defined(E2_STEP_PIN) && (E2_STEP_PIN &gt; -1)</front>
<front id="stepperCPP-894">    SET_OUTPUT(E2_STEP_PIN);</front>
<front id="stepperCPP-895">    WRITE(E2_STEP_PIN,INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-896">    disable_e2();</front>
<front id="stepperCPP-897">  #endif</front>
<front id="stepperCPP-898"></front>
<front id="stepperCPP-899">  // waveform generation = 0100 = CTC</front>
<front id="stepperCPP-900">  TCCR1B &= ~(1&lt;&lt;WGM13);</front>
<front id="stepperCPP-901">  TCCR1B |=  (1&lt;&lt;WGM12);</front>
<front id="stepperCPP-902">  TCCR1A &= ~(1&lt;&lt;WGM11);</front>
<front id="stepperCPP-903">  TCCR1A &= ~(1&lt;&lt;WGM10);</front>
<front id="stepperCPP-904"></front>
<front id="stepperCPP-905">  // output mode = 00 (disconnected)</front>
<front id="stepperCPP-906">  TCCR1A &= ~(3&lt;&lt;COM1A0);</front>
<front id="stepperCPP-907">  TCCR1A &= ~(3&lt;&lt;COM1B0);</front>
<front id="stepperCPP-908"></front>
<front id="stepperCPP-909">  // Set the timer pre-scaler</front>
<front id="stepperCPP-910">  // Generally we use a divider of 8, resulting in a 2MHz timer</front>
<front id="stepperCPP-911">  // frequency on a 16MHz MCU. If you are going to change this, be</front>
<front id="stepperCPP-912">  // sure to regenerate speed_lookuptable.h with</front>
<front id="stepperCPP-913">  // create_speed_lookuptable.py</front>
<front id="stepperCPP-914">  TCCR1B = (TCCR1B & ~(0x07&lt;&lt;CS10)) | (2&lt;&lt;CS10);</front>
<front id="stepperCPP-915"></front>
<front id="stepperCPP-916">  OCR1A = 0x4000;</front>
<front id="stepperCPP-917">  TCNT1 = 0;</front>
<front id="stepperCPP-918">  ENABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-919"></front>
<front id="stepperCPP-920">  #ifdef ADVANCE</front>
<front id="stepperCPP-921">  #if defined(TCCR0A) && defined(WGM01)</front>
<front id="stepperCPP-922">    TCCR0A &= ~(1&lt;&lt;WGM01);</front>
<front id="stepperCPP-923">    TCCR0A &= ~(1&lt;&lt;WGM00);</front>
<front id="stepperCPP-924">  #endif</front>
<front id="stepperCPP-925">    e_steps[0] = 0;</front>
<front id="stepperCPP-926">    e_steps[1] = 0;</front>
<front id="stepperCPP-927">    e_steps[2] = 0;</front>
<front id="stepperCPP-928">    TIMSK0 |= (1&lt;&lt;OCIE0A);</front>
<front id="stepperCPP-929">  #endif //ADVANCE</front>
<front id="stepperCPP-930"></front>
<front id="stepperCPP-931">  enable_endstops(true); // Start with endstops active. After homing they can be disabled</front>
<front id="stepperCPP-932">  sei();</front>
<front id="stepperCPP-933">}</front>
<front id="stepperCPP-934"></front>
<front id="stepperCPP-935"></front>
<front id="stepperCPP-936">// Block until all buffered steps are executed</front>
<front id="stepperCPP-937">void st_synchronize()</front>
<front id="stepperCPP-938">{</front>
<front id="stepperCPP-939">    while( blocks_queued()) {</front>
<front id="stepperCPP-940">    manage_heater();</front>
<front id="stepperCPP-941">    manage_inactivity();</front>
<front id="stepperCPP-942">    lcd_update();</front>
<front id="stepperCPP-943">  }</front>
<front id="stepperCPP-944">}</front>
<front id="stepperCPP-945"></front>
<front id="stepperCPP-946">void st_set_position(const long &x, const long &y, const long &z, const long &e)</front>
<front id="stepperCPP-947">{</front>
<front id="stepperCPP-948">  CRITICAL_SECTION_START;</front>
<front id="stepperCPP-949">  count_position[X_AXIS] = x;</front>
<front id="stepperCPP-950">  count_position[Y_AXIS] = y;</front>
<front id="stepperCPP-951">  count_position[Z_AXIS] = z;</front>
<front id="stepperCPP-952">  count_position[E_AXIS] = e;</front>
<front id="stepperCPP-953">  CRITICAL_SECTION_END;</front>
<front id="stepperCPP-954">}</front>
<front id="stepperCPP-955"></front>
<front id="stepperCPP-956">void st_set_e_position(const long &e)</front>
<front id="stepperCPP-957">{</front>
<front id="stepperCPP-958">  CRITICAL_SECTION_START;</front>
<front id="stepperCPP-959">  count_position[E_AXIS] = e;</front>
<front id="stepperCPP-960">  CRITICAL_SECTION_END;</front>
<front id="stepperCPP-961">}</front>
<front id="stepperCPP-962"></front>
<front id="stepperCPP-963">long st_get_position(uint8_t axis)</front>
<front id="stepperCPP-964">{</front>
<front id="stepperCPP-965">  long count_pos;</front>
<front id="stepperCPP-966">  CRITICAL_SECTION_START;</front>
<front id="stepperCPP-967">  count_pos = count_position[axis];</front>
<front id="stepperCPP-968">  CRITICAL_SECTION_END;</front>
<front id="stepperCPP-969">  return count_pos;</front>
<front id="stepperCPP-970">}</front>
<front id="stepperCPP-971"></front>
<front id="stepperCPP-972">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="stepperCPP-973">float st_get_position_mm(uint8_t axis)</front>
<front id="stepperCPP-974">{</front>
<front id="stepperCPP-975">  float steper_position_in_steps = st_get_position(axis);</front>
<front id="stepperCPP-976">  return steper_position_in_steps / axis_steps_per_unit[axis];</front>
<front id="stepperCPP-977">}</front>
<front id="stepperCPP-978">#endif  // ENABLE_AUTO_BED_LEVELING</front>
<front id="stepperCPP-979"></front>
<front id="stepperCPP-980">void finishAndDisableSteppers()</front>
<front id="stepperCPP-981">{</front>
<front id="stepperCPP-982">  st_synchronize();</front>
<front id="stepperCPP-983">  disable_x();</front>
<front id="stepperCPP-984">  disable_y();</front>
<front id="stepperCPP-985">  disable_z();</front>
<front id="stepperCPP-986">  disable_e0();</front>
<front id="stepperCPP-987">  disable_e1();</front>
<front id="stepperCPP-988">  disable_e2();</front>
<front id="stepperCPP-989">}</front>
<front id="stepperCPP-990"></front>
<front id="stepperCPP-991">void quickStop()</front>
<front id="stepperCPP-992">{</front>
<front id="stepperCPP-993">  DISABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-994">  while(blocks_queued())</front>
<front id="stepperCPP-995">    plan_discard_current_block();</front>
<front id="stepperCPP-996">  current_block = NULL;</front>
<front id="stepperCPP-997">  ENABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-998">}</front>
<front id="stepperCPP-999"></front>
<front id="stepperCPP-1000">#ifdef BABYSTEPPING</front>
<front id="stepperCPP-1001"></front>
<front id="stepperCPP-1002"></front>
<front id="stepperCPP-1003">void babystep(const uint8_t axis,const bool direction)</front>
<front id="stepperCPP-1004">{</front>
<front id="stepperCPP-1005">  //MUST ONLY BE CALLED BY A ISR, it depends on that no other ISR interrupts this</front>
<front id="stepperCPP-1006">    //store initial pin states</front>
<front id="stepperCPP-1007">  switch(axis)</front>
<front id="stepperCPP-1008">  {</front>
<front id="stepperCPP-1009">  case X_AXIS:</front>
<front id="stepperCPP-1010">  {</front>
<front id="stepperCPP-1011">    enable_x();   </front>
<front id="stepperCPP-1012">    uint8_t old_x_dir_pin= READ(X_DIR_PIN);  //if dualzstepper, both point to same direction.</front>
<front id="stepperCPP-1013">   </front>
<front id="stepperCPP-1014">    //setup new step</front>
<front id="stepperCPP-1015">    WRITE(X_DIR_PIN,(INVERT_X_DIR)^direction);</front>
<front id="stepperCPP-1016">    #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-1017">      WRITE(X2_DIR_PIN,(INVERT_X_DIR)^direction);</front>
<front id="stepperCPP-1018">    #endif</front>
<front id="stepperCPP-1019">    </front>
<front id="stepperCPP-1020">    //perform step </front>
<front id="stepperCPP-1021">    WRITE(X_STEP_PIN, !INVERT_X_STEP_PIN); </front>
<front id="stepperCPP-1022">    #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-1023">      WRITE(X2_STEP_PIN, !INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-1024">    #endif</front>
<front id="stepperCPP-1025">    {</front>
<front id="stepperCPP-1026">    float x=1./float(axis+1)/float(axis+2); //wait a tiny bit</front>
<front id="stepperCPP-1027">    }</front>
<front id="stepperCPP-1028">    WRITE(X_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-1029">    #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-1030">      WRITE(X2_STEP_PIN, INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-1031">    #endif</front>
<front id="stepperCPP-1032"></front>
<front id="stepperCPP-1033">    //get old pin state back.</front>
<front id="stepperCPP-1034">    WRITE(X_DIR_PIN,old_x_dir_pin);</front>
<front id="stepperCPP-1035">    #ifdef DUAL_X_CARRIAGE</front>
<front id="stepperCPP-1036">      WRITE(X2_DIR_PIN,old_x_dir_pin);</front>
<front id="stepperCPP-1037">    #endif</front>
<front id="stepperCPP-1038"></front>
<front id="stepperCPP-1039">  }</front>
<front id="stepperCPP-1040">  break;</front>
<front id="stepperCPP-1041">  case Y_AXIS:</front>
<front id="stepperCPP-1042">  {</front>
<front id="stepperCPP-1043">    enable_y();   </front>
<front id="stepperCPP-1044">    uint8_t old_y_dir_pin= READ(Y_DIR_PIN);  //if dualzstepper, both point to same direction.</front>
<front id="stepperCPP-1045">   </front>
<front id="stepperCPP-1046">    //setup new step</front>
<front id="stepperCPP-1047">    WRITE(Y_DIR_PIN,(INVERT_Y_DIR)^direction);</front>
<front id="stepperCPP-1048">    #ifdef DUAL_Y_CARRIAGE</front>
<front id="stepperCPP-1049">      WRITE(Y2_DIR_PIN,(INVERT_Y_DIR)^direction);</front>
<front id="stepperCPP-1050">    #endif</front>
<front id="stepperCPP-1051">    </front>
<front id="stepperCPP-1052">    //perform step </front>
<front id="stepperCPP-1053">    WRITE(Y_STEP_PIN, !INVERT_Y_STEP_PIN); </front>
<front id="stepperCPP-1054">    #ifdef DUAL_Y_CARRIAGE</front>
<front id="stepperCPP-1055">      WRITE(Y2_STEP_PIN, !INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-1056">    #endif</front>
<front id="stepperCPP-1057">    {</front>
<front id="stepperCPP-1058">    float x=1./float(axis+1)/float(axis+2); //wait a tiny bit</front>
<front id="stepperCPP-1059">    }</front>
<front id="stepperCPP-1060">    WRITE(Y_STEP_PIN, INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-1061">    #ifdef DUAL_Y_CARRIAGE</front>
<front id="stepperCPP-1062">      WRITE(Y2_STEP_PIN, INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-1063">    #endif</front>
<front id="stepperCPP-1064"></front>
<front id="stepperCPP-1065">    //get old pin state back.</front>
<front id="stepperCPP-1066">    WRITE(Y_DIR_PIN,old_y_dir_pin);</front>
<front id="stepperCPP-1067">    #ifdef DUAL_Y_CARRIAGE</front>
<front id="stepperCPP-1068">      WRITE(Y2_DIR_PIN,old_y_dir_pin);</front>
<front id="stepperCPP-1069">    #endif</front>
<front id="stepperCPP-1070"></front>
<front id="stepperCPP-1071">  }</front>
<front id="stepperCPP-1072">  break; </front>
<front id="stepperCPP-1073">  case Z_AXIS:</front>
<front id="stepperCPP-1074">  {</front>
<front id="stepperCPP-1075">    enable_z();</front>
<front id="stepperCPP-1076">    uint8_t old_z_dir_pin= READ(Z_DIR_PIN);  //if dualzstepper, both point to same direction.</front>
<front id="stepperCPP-1077">    //setup new step</front>
<front id="stepperCPP-1078">    WRITE(Z_DIR_PIN,(INVERT_Z_DIR)^direction);</front>
<front id="stepperCPP-1079">    #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-1080">      WRITE(Z2_DIR_PIN,(INVERT_Z_DIR)^direction);</front>
<front id="stepperCPP-1081">    #endif</front>
<front id="stepperCPP-1082">    //perform step </front>
<front id="stepperCPP-1083">    WRITE(Z_STEP_PIN, !INVERT_Z_STEP_PIN); </front>
<front id="stepperCPP-1084">    #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-1085">      WRITE(Z2_STEP_PIN, !INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-1086">    #endif</front>
<front id="stepperCPP-1087">    //wait a tiny bit</front>
<front id="stepperCPP-1088">    {</front>
<front id="stepperCPP-1089">    float x=1./float(axis+1); //absolutely useless</front>
<front id="stepperCPP-1090">    }</front>
<front id="stepperCPP-1091">    WRITE(Z_STEP_PIN, INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-1092">    #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-1093">      WRITE(Z2_STEP_PIN, INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-1094">    #endif</front>
<front id="stepperCPP-1095"></front>
<front id="stepperCPP-1096">    //get old pin state back.</front>
<front id="stepperCPP-1097">    WRITE(Z_DIR_PIN,old_z_dir_pin);</front>
<front id="stepperCPP-1098">    #ifdef Z_DUAL_STEPPER_DRIVERS</front>
<front id="stepperCPP-1099">      WRITE(Z2_DIR_PIN,old_z_dir_pin);</front>
<front id="stepperCPP-1100">    #endif</front>
<front id="stepperCPP-1101"></front>
<front id="stepperCPP-1102">  }</front>
<front id="stepperCPP-1103">  break;</front>
<front id="stepperCPP-1104"> </front>
<front id="stepperCPP-1105">  default:    break;</front>
<front id="stepperCPP-1106">  }</front>
<front id="stepperCPP-1107">}</front>
<front id="stepperCPP-1108">#endif //BABYSTEPPING</front>
<front id="stepperCPP-1109"></front>
<front id="stepperCPP-1110">void digitalPotWrite(int address, int value) // From Arduino DigitalPotControl example</front>
<front id="stepperCPP-1111">{</front>
<front id="stepperCPP-1112">  #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="stepperCPP-1113">    digitalWrite(DIGIPOTSS_PIN,LOW); // take the SS pin low to select the chip</front>
<front id="stepperCPP-1114">    SPI.transfer(address); //  send in the address and value via SPI:</front>
<front id="stepperCPP-1115">    SPI.transfer(value);</front>
<front id="stepperCPP-1116">    digitalWrite(DIGIPOTSS_PIN,HIGH); // take the SS pin high to de-select the chip:</front>
<front id="stepperCPP-1117">    //delay(10);</front>
<front id="stepperCPP-1118">  #endif</front>
<front id="stepperCPP-1119">}</front>
<front id="stepperCPP-1120"></front>
<front id="stepperCPP-1121">void digipot_init() //Initialize Digipot Motor Current</front>
<front id="stepperCPP-1122">{</front>
<front id="stepperCPP-1123">  #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="stepperCPP-1124">    const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;</front>
<front id="stepperCPP-1125"></front>
<front id="stepperCPP-1126">    SPI.begin();</front>
<front id="stepperCPP-1127">    pinMode(DIGIPOTSS_PIN, OUTPUT);</front>
<front id="stepperCPP-1128">    for(int i=0;i&lt;=4;i++)</front>
<front id="stepperCPP-1129">      //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);</front>
<front id="stepperCPP-1130">      digipot_current(i,digipot_motor_current[i]);</front>
<front id="stepperCPP-1131">  #endif</front>
<front id="stepperCPP-1132">}</front>
<front id="stepperCPP-1133"></front>
<front id="stepperCPP-1134">void digipot_current(uint8_t driver, int current)</front>
<front id="stepperCPP-1135">{</front>
<front id="stepperCPP-1136">  #if defined(DIGIPOTSS_PIN) && DIGIPOTSS_PIN &gt; -1</front>
<front id="stepperCPP-1137">    const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;</front>
<front id="stepperCPP-1138">    digitalPotWrite(digipot_ch[driver], current);</front>
<front id="stepperCPP-1139">  #endif</front>
<front id="stepperCPP-1140">}</front>
<front id="stepperCPP-1141"></front>
<front id="stepperCPP-1142">void microstep_init()</front>
<front id="stepperCPP-1143">{</front>
<front id="stepperCPP-1144">  #if defined(X_MS1_PIN) && X_MS1_PIN &gt; -1</front>
<front id="stepperCPP-1145">  const uint8_t microstep_modes[] = MICROSTEP_MODES;</front>
<front id="stepperCPP-1146">  pinMode(X_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1147">  pinMode(Y_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1148">  pinMode(Z_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1149">  pinMode(E0_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1150">  pinMode(E1_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1151">  for(int i=0;i&lt;=4;i++) microstep_mode(i,microstep_modes[i]);</front>
<front id="stepperCPP-1152">  #endif</front>
<front id="stepperCPP-1153">}</front>
<front id="stepperCPP-1154"></front>
<front id="stepperCPP-1155">void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2)</front>
<front id="stepperCPP-1156">{</front>
<front id="stepperCPP-1157">  if(ms1 &gt; -1) switch(driver)</front>
<front id="stepperCPP-1158">  {</front>
<front id="stepperCPP-1159">    case 0: digitalWrite( X_MS1_PIN,ms1); break;</front>
<front id="stepperCPP-1160">    case 1: digitalWrite( Y_MS1_PIN,ms1); break;</front>
<front id="stepperCPP-1161">    case 2: digitalWrite( Z_MS1_PIN,ms1); break;</front>
<front id="stepperCPP-1162">    case 3: digitalWrite(E0_MS1_PIN,ms1); break;</front>
<front id="stepperCPP-1163">    case 4: digitalWrite(E1_MS1_PIN,ms1); break;</front>
<front id="stepperCPP-1164">  }</front>
<front id="stepperCPP-1165">  if(ms2 &gt; -1) switch(driver)</front>
<front id="stepperCPP-1166">  {</front>
<front id="stepperCPP-1167">    case 0: digitalWrite( X_MS2_PIN,ms2); break;</front>
<front id="stepperCPP-1168">    case 1: digitalWrite( Y_MS2_PIN,ms2); break;</front>
<front id="stepperCPP-1169">    case 2: digitalWrite( Z_MS2_PIN,ms2); break;</front>
<front id="stepperCPP-1170">    case 3: digitalWrite(E0_MS2_PIN,ms2); break;</front>
<front id="stepperCPP-1171">    case 4: digitalWrite(E1_MS2_PIN,ms2); break;</front>
<front id="stepperCPP-1172">  }</front>
<front id="stepperCPP-1173">}</front>
<front id="stepperCPP-1174"></front>
<front id="stepperCPP-1175">void microstep_mode(uint8_t driver, uint8_t stepping_mode)</front>
<front id="stepperCPP-1176">{</front>
<front id="stepperCPP-1177">  switch(stepping_mode)</front>
<front id="stepperCPP-1178">  {</front>
<front id="stepperCPP-1179">    case 1: microstep_ms(driver,MICROSTEP1); break;</front>
<front id="stepperCPP-1180">    case 2: microstep_ms(driver,MICROSTEP2); break;</front>
<front id="stepperCPP-1181">    case 4: microstep_ms(driver,MICROSTEP4); break;</front>
<front id="stepperCPP-1182">    case 8: microstep_ms(driver,MICROSTEP8); break;</front>
<front id="stepperCPP-1183">    case 16: microstep_ms(driver,MICROSTEP16); break;</front>
<front id="stepperCPP-1184">  }</front>
<front id="stepperCPP-1185">}</front>
<front id="stepperCPP-1186"></front>
<front id="stepperCPP-1187">void microstep_readings()</front>
<front id="stepperCPP-1188">{</front>
<front id="stepperCPP-1189">      SERIAL_PROTOCOLPGM("MS1,MS2 Pins\n");</front>
<front id="stepperCPP-1190">      SERIAL_PROTOCOLPGM("X: ");</front>
<front id="stepperCPP-1191">      SERIAL_PROTOCOL(   digitalRead(X_MS1_PIN));</front>
<front id="stepperCPP-1192">      SERIAL_PROTOCOLLN( digitalRead(X_MS2_PIN));</front>
<front id="stepperCPP-1193">      SERIAL_PROTOCOLPGM("Y: ");</front>
<front id="stepperCPP-1194">      SERIAL_PROTOCOL(   digitalRead(Y_MS1_PIN));</front>
<front id="stepperCPP-1195">      SERIAL_PROTOCOLLN( digitalRead(Y_MS2_PIN));</front>
<front id="stepperCPP-1196">      SERIAL_PROTOCOLPGM("Z: ");</front>
<front id="stepperCPP-1197">      SERIAL_PROTOCOL(   digitalRead(Z_MS1_PIN));</front>
<front id="stepperCPP-1198">      SERIAL_PROTOCOLLN( digitalRead(Z_MS2_PIN));</front>
<front id="stepperCPP-1199">      SERIAL_PROTOCOLPGM("E0: ");</front>
<front id="stepperCPP-1200">      SERIAL_PROTOCOL(   digitalRead(E0_MS1_PIN));</front>
<front id="stepperCPP-1201">      SERIAL_PROTOCOLLN( digitalRead(E0_MS2_PIN));</front>
<front id="stepperCPP-1202">      SERIAL_PROTOCOLPGM("E1: ");</front>
<front id="stepperCPP-1203">      SERIAL_PROTOCOL(   digitalRead(E1_MS1_PIN));</front>
<front id="stepperCPP-1204">      SERIAL_PROTOCOLLN( digitalRead(E1_MS2_PIN));</front>
<front id="stepperCPP-1205">}</front>
<front id="stepperCPP-1206"></front>
 </pre>
<h1>stepper.h</h1>
<pre  class="prettyprint linenums"><front id="stepperH-1">/*</front>
<front id="stepperH-2">  stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors</front>
<front id="stepperH-3">  Part of Grbl</front>
<front id="stepperH-4"></front>
<front id="stepperH-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="stepperH-6"></front>
<front id="stepperH-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="stepperH-8">  it under the terms of the GNU General Public License as published by</front>
<front id="stepperH-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="stepperH-10">  (at your option) any later version.</front>
<front id="stepperH-11"></front>
<front id="stepperH-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="stepperH-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="stepperH-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="stepperH-15">  GNU General Public License for more details.</front>
<front id="stepperH-16"></front>
<front id="stepperH-17">  You should have received a copy of the GNU General Public License</front>
<front id="stepperH-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="stepperH-19">*/</front>
<front id="stepperH-20"></front>
<front id="stepperH-21">#ifndef stepper_h</front>
<front id="stepperH-22">#define stepper_h </front>
<front id="stepperH-23"></front>
<front id="stepperH-24">#include "planner.h"</front>
<front id="stepperH-25"></front>
<front id="stepperH-26">#if EXTRUDERS &gt; 2</front>
<front id="stepperH-27">  #define WRITE_E_STEP(v) { if(current_block-&gt;active_extruder == 2) { WRITE(E2_STEP_PIN, v); } else { if(current_block-&gt;active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}}</front>
<front id="stepperH-28">  #define NORM_E_DIR() { if(current_block-&gt;active_extruder == 2) { WRITE(E2_DIR_PIN, !INVERT_E2_DIR); } else { if(current_block-&gt;active_extruder == 1) { WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}}</front>
<front id="stepperH-29">  #define REV_E_DIR() { if(current_block-&gt;active_extruder == 2) { WRITE(E2_DIR_PIN, INVERT_E2_DIR); } else { if(current_block-&gt;active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}}</front>
<front id="stepperH-30">#elif EXTRUDERS &gt; 1</front>
<front id="stepperH-31">  #ifndef DUAL_X_CARRIAGE</front>
<front id="stepperH-32">    #define WRITE_E_STEP(v) { if(current_block-&gt;active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}</front>
<front id="stepperH-33">    #define NORM_E_DIR() { if(current_block-&gt;active_extruder == 1) { WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}</front>
<front id="stepperH-34">    #define REV_E_DIR() { if(current_block-&gt;active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}</front>
<front id="stepperH-35">  #else</front>
<front id="stepperH-36">    extern bool extruder_duplication_enabled;</front>
<front id="stepperH-37">    #define WRITE_E_STEP(v) { if(extruder_duplication_enabled) { WRITE(E0_STEP_PIN, v); WRITE(E1_STEP_PIN, v); } else if(current_block-&gt;active_extruder == 1) { WRITE(E1_STEP_PIN, v); } else { WRITE(E0_STEP_PIN, v); }}</front>
<front id="stepperH-38">    #define NORM_E_DIR() { if(extruder_duplication_enabled) { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else if(current_block-&gt;active_extruder == 1) { WRITE(E1_DIR_PIN, !INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, !INVERT_E0_DIR); }}</front>
<front id="stepperH-39">    #define REV_E_DIR() { if(extruder_duplication_enabled) { WRITE(E0_DIR_PIN, INVERT_E0_DIR); WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else if(current_block-&gt;active_extruder == 1) { WRITE(E1_DIR_PIN, INVERT_E1_DIR); } else { WRITE(E0_DIR_PIN, INVERT_E0_DIR); }}</front>
<front id="stepperH-40">  #endif  </front>
<front id="stepperH-41">#else</front>
<front id="stepperH-42">  #define WRITE_E_STEP(v) WRITE(E0_STEP_PIN, v)</front>
<front id="stepperH-43">  #define NORM_E_DIR() WRITE(E0_DIR_PIN, !INVERT_E0_DIR)</front>
<front id="stepperH-44">  #define REV_E_DIR() WRITE(E0_DIR_PIN, INVERT_E0_DIR)</front>
<front id="stepperH-45">#endif</front>
<front id="stepperH-46"></front>
<front id="stepperH-47">#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="stepperH-48">extern bool abort_on_endstop_hit;</front>
<front id="stepperH-49">#endif</front>
<front id="stepperH-50"></front>
<front id="stepperH-51">// Initialize and start the stepper motor subsystem</front>
<front id="stepperH-52">void st_init();</front>
<front id="stepperH-53"></front>
<front id="stepperH-54">// Block until all buffered steps are executed</front>
<front id="stepperH-55">void st_synchronize();</front>
<front id="stepperH-56"></front>
<front id="stepperH-57">// Set current position in steps</front>
<front id="stepperH-58">void st_set_position(const long &x, const long &y, const long &z, const long &e);</front>
<front id="stepperH-59">void st_set_e_position(const long &e);</front>
<front id="stepperH-60"></front>
<front id="stepperH-61">// Get current position in steps</front>
<front id="stepperH-62">long st_get_position(uint8_t axis);</front>
<front id="stepperH-63"></front>
<front id="stepperH-64">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="stepperH-65">// Get current position in mm</front>
<front id="stepperH-66">float st_get_position_mm(uint8_t axis);</front>
<front id="stepperH-67">#endif  //ENABLE_AUTO_BED_LEVELING</front>
<front id="stepperH-68"></front>
<front id="stepperH-69">// The stepper subsystem goes to sleep when it runs out of things to execute. Call this</front>
<front id="stepperH-70">// to notify the subsystem that it is time to go to work.</front>
<front id="stepperH-71">void st_wake_up();</front>
<front id="stepperH-72"></front>
<front id="stepperH-73">  </front>
<front id="stepperH-74">void checkHitEndstops(); //call from somwhere to create an serial error message with the locations the endstops where hit, in case they were triggered</front>
<front id="stepperH-75">void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homeing and before a routine call of checkHitEndstops();</front>
<front id="stepperH-76"></front>
<front id="stepperH-77">void enable_endstops(bool check); // Enable/disable endstop checking</front>
<front id="stepperH-78"></front>
<front id="stepperH-79">void checkStepperErrors(); //Print errors detected by the stepper</front>
<front id="stepperH-80"></front>
<front id="stepperH-81">void finishAndDisableSteppers();</front>
<front id="stepperH-82"></front>
<front id="stepperH-83">extern block_t *current_block;  // A pointer to the block currently being traced</front>
<front id="stepperH-84"></front>
<front id="stepperH-85">void quickStop();</front>
<front id="stepperH-86"></front>
<front id="stepperH-87">void digitalPotWrite(int address, int value);</front>
<front id="stepperH-88">void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);</front>
<front id="stepperH-89">void microstep_mode(uint8_t driver, uint8_t stepping);</front>
<front id="stepperH-90">void digipot_init();</front>
<front id="stepperH-91">void digipot_current(uint8_t driver, int current);</front>
<front id="stepperH-92">void microstep_init();</front>
<front id="stepperH-93">void microstep_readings();</front>
<front id="stepperH-94"></front>
<front id="stepperH-95">#ifdef BABYSTEPPING</front>
<front id="stepperH-96">  void babystep(const uint8_t axis,const bool direction); // perform a short step with a single stepper motor, outside of any convention</front>
<front id="stepperH-97">#endif</front>
<front id="stepperH-98">     </front>
<front id="stepperH-99"></front>
<front id="stepperH-100"></front>
<front id="stepperH-101">#endif</front>
 </pre>
<h1>temperature.cpp</h1>
<pre  class="prettyprint linenums"><front id="temperatureCPP-1">/*</front>
<front id="temperatureCPP-2">  temperature.c - temperature control</front>
<front id="temperatureCPP-3">  Part of Marlin</front>
<front id="temperatureCPP-4">  </front>
<front id="temperatureCPP-5"> Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm</front>
<front id="temperatureCPP-6"> </front>
<front id="temperatureCPP-7"> This program is free software: you can redistribute it and/or modify</front>
<front id="temperatureCPP-8"> it under the terms of the GNU General Public License as published by</front>
<front id="temperatureCPP-9"> the Free Software Foundation, either version 3 of the License, or</front>
<front id="temperatureCPP-10"> (at your option) any later version.</front>
<front id="temperatureCPP-11"> </front>
<front id="temperatureCPP-12"> This program is distributed in the hope that it will be useful,</front>
<front id="temperatureCPP-13"> but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="temperatureCPP-14"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="temperatureCPP-15"> GNU General Public License for more details.</front>
<front id="temperatureCPP-16"> </front>
<front id="temperatureCPP-17"> You should have received a copy of the GNU General Public License</front>
<front id="temperatureCPP-18"> along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="temperatureCPP-19"> */</front>
<front id="temperatureCPP-20"></front>
<front id="temperatureCPP-21">/*</front>
<front id="temperatureCPP-22"> This firmware is a mashup between Sprinter and grbl.</front>
<front id="temperatureCPP-23">  (https://github.com/kliment/Sprinter)</front>
<front id="temperatureCPP-24">  (https://github.com/simen/grbl/tree)</front>
<front id="temperatureCPP-25"> </front>
<front id="temperatureCPP-26"> It has preliminary support for Matthew Roberts advance algorithm </front>
<front id="temperatureCPP-27">    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html</front>
<front id="temperatureCPP-28"></front>
<front id="temperatureCPP-29"> */</front>
<front id="temperatureCPP-30"></front>
<front id="temperatureCPP-31"></front>
<front id="temperatureCPP-32">#include "Marlin.h"</front>
<front id="temperatureCPP-33">#include "ultralcd.h"</front>
<front id="temperatureCPP-34">#include "temperature.h"</front>
<front id="temperatureCPP-35">#include "watchdog.h"</front>
<front id="temperatureCPP-36"></front>
<front id="temperatureCPP-37">//===========================================================================</front>
<front id="temperatureCPP-38">//=============================public variables============================</front>
<front id="temperatureCPP-39">//===========================================================================</front>
<front id="temperatureCPP-40">int target_temperature[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-41">int target_temperature_bed = 0;</front>
<front id="temperatureCPP-42">int current_temperature_raw[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-43">float current_temperature[EXTRUDERS] = { 0.0 };</front>
<front id="temperatureCPP-44">int current_temperature_bed_raw = 0;</front>
<front id="temperatureCPP-45">float current_temperature_bed = 0.0;</front>
<front id="temperatureCPP-46">#ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureCPP-47">  int redundant_temperature_raw = 0;</front>
<front id="temperatureCPP-48">  float redundant_temperature = 0.0;</front>
<front id="temperatureCPP-49">#endif</front>
<front id="temperatureCPP-50">#ifdef PIDTEMP</front>
<front id="temperatureCPP-51">  float Kp=DEFAULT_Kp;</front>
<front id="temperatureCPP-52">  float Ki=(DEFAULT_Ki*PID_dT);</front>
<front id="temperatureCPP-53">  float Kd=(DEFAULT_Kd/PID_dT);</front>
<front id="temperatureCPP-54">  #ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="temperatureCPP-55">    float Kc=DEFAULT_Kc;</front>
<front id="temperatureCPP-56">  #endif</front>
<front id="temperatureCPP-57">#endif //PIDTEMP</front>
<front id="temperatureCPP-58"></front>
<front id="temperatureCPP-59">#ifdef PIDTEMPBED</front>
<front id="temperatureCPP-60">  float bedKp=DEFAULT_bedKp;</front>
<front id="temperatureCPP-61">  float bedKi=(DEFAULT_bedKi*PID_dT);</front>
<front id="temperatureCPP-62">  float bedKd=(DEFAULT_bedKd/PID_dT);</front>
<front id="temperatureCPP-63">#endif //PIDTEMPBED</front>
<front id="temperatureCPP-64">  </front>
<front id="temperatureCPP-65">#ifdef FAN_SOFT_PWM</front>
<front id="temperatureCPP-66">  unsigned char fanSpeedSoftPwm;</front>
<front id="temperatureCPP-67">#endif</front>
<front id="temperatureCPP-68">  </front>
<front id="temperatureCPP-69">#ifdef BABYSTEPPING</front>
<front id="temperatureCPP-70">  volatile int babystepsTodo[3]={0,0,0};</front>
<front id="temperatureCPP-71">#endif</front>
<front id="temperatureCPP-72">  </front>
<front id="temperatureCPP-73">//===========================================================================</front>
<front id="temperatureCPP-74">//=============================private variables============================</front>
<front id="temperatureCPP-75">//===========================================================================</front>
<front id="temperatureCPP-76">static volatile bool temp_meas_ready = false;</front>
<front id="temperatureCPP-77"></front>
<front id="temperatureCPP-78">#ifdef PIDTEMP</front>
<front id="temperatureCPP-79">  //static cannot be external:</front>
<front id="temperatureCPP-80">  static float temp_iState[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-81">  static float temp_dState[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-82">  static float pTerm[EXTRUDERS];</front>
<front id="temperatureCPP-83">  static float iTerm[EXTRUDERS];</front>
<front id="temperatureCPP-84">  static float dTerm[EXTRUDERS];</front>
<front id="temperatureCPP-85">  //int output;</front>
<front id="temperatureCPP-86">  static float pid_error[EXTRUDERS];</front>
<front id="temperatureCPP-87">  static float temp_iState_min[EXTRUDERS];</front>
<front id="temperatureCPP-88">  static float temp_iState_max[EXTRUDERS];</front>
<front id="temperatureCPP-89">  // static float pid_input[EXTRUDERS];</front>
<front id="temperatureCPP-90">  // static float pid_output[EXTRUDERS];</front>
<front id="temperatureCPP-91">  static bool pid_reset[EXTRUDERS];</front>
<front id="temperatureCPP-92">#endif //PIDTEMP</front>
<front id="temperatureCPP-93">#ifdef PIDTEMPBED</front>
<front id="temperatureCPP-94">  //static cannot be external:</front>
<front id="temperatureCPP-95">  static float temp_iState_bed = { 0 };</front>
<front id="temperatureCPP-96">  static float temp_dState_bed = { 0 };</front>
<front id="temperatureCPP-97">  static float pTerm_bed;</front>
<front id="temperatureCPP-98">  static float iTerm_bed;</front>
<front id="temperatureCPP-99">  static float dTerm_bed;</front>
<front id="temperatureCPP-100">  //int output;</front>
<front id="temperatureCPP-101">  static float pid_error_bed;</front>
<front id="temperatureCPP-102">  static float temp_iState_min_bed;</front>
<front id="temperatureCPP-103">  static float temp_iState_max_bed;</front>
<front id="temperatureCPP-104">#else //PIDTEMPBED</front>
<front id="temperatureCPP-105">	static unsigned long  previous_millis_bed_heater;</front>
<front id="temperatureCPP-106">#endif //PIDTEMPBED</front>
<front id="temperatureCPP-107">  static unsigned char soft_pwm[EXTRUDERS];</front>
<front id="temperatureCPP-108">  static unsigned char soft_pwm_bed;</front>
<front id="temperatureCPP-109">#ifdef FAN_SOFT_PWM</front>
<front id="temperatureCPP-110">  static unsigned char soft_pwm_fan;</front>
<front id="temperatureCPP-111">#endif</front>
<front id="temperatureCPP-112">#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN &gt; -1) || \</front>
<front id="temperatureCPP-113">    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN &gt; -1) || \</front>
<front id="temperatureCPP-114">    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN &gt; -1)</front>
<front id="temperatureCPP-115">  static unsigned long extruder_autofan_last_check;</front>
<front id="temperatureCPP-116">#endif  </front>
<front id="temperatureCPP-117"></front>
<front id="temperatureCPP-118">#if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-119">  # error Unsupported number of extruders</front>
<front id="temperatureCPP-120">#elif EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-121">  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2, v3 }</front>
<front id="temperatureCPP-122">#elif EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-123">  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1, v2 }</front>
<front id="temperatureCPP-124">#else</front>
<front id="temperatureCPP-125">  # define ARRAY_BY_EXTRUDERS(v1, v2, v3) { v1 }</front>
<front id="temperatureCPP-126">#endif</front>
<front id="temperatureCPP-127"></front>
<front id="temperatureCPP-128">// Init min and max temp with extreme values to prevent false errors during startup</front>
<front id="temperatureCPP-129">static int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP );</front>
<front id="temperatureCPP-130">static int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP );</front>
<front id="temperatureCPP-131">static int minttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 0, 0, 0 );</front>
<front id="temperatureCPP-132">static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS( 16383, 16383, 16383 );</front>
<front id="temperatureCPP-133">//static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP; /* No bed mintemp error implemented?!? */</front>
<front id="temperatureCPP-134">#ifdef BED_MAXTEMP</front>
<front id="temperatureCPP-135">static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;</front>
<front id="temperatureCPP-136">#endif</front>
<front id="temperatureCPP-137"></front>
<front id="temperatureCPP-138">#ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureCPP-139">  static void *heater_ttbl_map[2] = {(void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE };</front>
<front id="temperatureCPP-140">  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };</front>
<front id="temperatureCPP-141">#else</front>
<front id="temperatureCPP-142">  static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE );</front>
<front id="temperatureCPP-143">  static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN );</front>
<front id="temperatureCPP-144">#endif</front>
<front id="temperatureCPP-145"></front>
<front id="temperatureCPP-146">static float analog2temp(int raw, uint8_t e);</front>
<front id="temperatureCPP-147">static float analog2tempBed(int raw);</front>
<front id="temperatureCPP-148">static void updateTemperaturesFromRawValues();</front>
<front id="temperatureCPP-149"></front>
<front id="temperatureCPP-150">#ifdef WATCH_TEMP_PERIOD</front>
<front id="temperatureCPP-151">int watch_start_temp[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);</front>
<front id="temperatureCPP-152">unsigned long watchmillis[EXTRUDERS] = ARRAY_BY_EXTRUDERS(0,0,0);</front>
<front id="temperatureCPP-153">#endif //WATCH_TEMP_PERIOD</front>
<front id="temperatureCPP-154"></front>
<front id="temperatureCPP-155">#ifndef SOFT_PWM_SCALE</front>
<front id="temperatureCPP-156">#define SOFT_PWM_SCALE 0</front>
<front id="temperatureCPP-157">#endif</front>
<front id="temperatureCPP-158"></front>
<front id="temperatureCPP-159">//===========================================================================</front>
<front id="temperatureCPP-160">//=============================   functions      ============================</front>
<front id="temperatureCPP-161">//===========================================================================</front>
<front id="temperatureCPP-162"></front>
<front id="temperatureCPP-163">void PID_autotune(float temp, int extruder, int ncycles)</front>
<front id="temperatureCPP-164">{</front>
<front id="temperatureCPP-165">  float input = 0.0;</front>
<front id="temperatureCPP-166">  int cycles=0;</front>
<front id="temperatureCPP-167">  bool heating = true;</front>
<front id="temperatureCPP-168"></front>
<front id="temperatureCPP-169">  unsigned long temp_millis = millis();</front>
<front id="temperatureCPP-170">  unsigned long t1=temp_millis;</front>
<front id="temperatureCPP-171">  unsigned long t2=temp_millis;</front>
<front id="temperatureCPP-172">  long t_high = 0;</front>
<front id="temperatureCPP-173">  long t_low = 0;</front>
<front id="temperatureCPP-174"></front>
<front id="temperatureCPP-175">  long bias, d;</front>
<front id="temperatureCPP-176">  float Ku, Tu;</front>
<front id="temperatureCPP-177">  float Kp, Ki, Kd;</front>
<front id="temperatureCPP-178">  float max = 0, min = 10000;</front>
<front id="temperatureCPP-179"></front>
<front id="temperatureCPP-180">  if ((extruder &gt; EXTRUDERS)</front>
<front id="temperatureCPP-181">  #if (TEMP_BED_PIN &lt;= -1)</front>
<front id="temperatureCPP-182">       ||(extruder &lt; 0)</front>
<front id="temperatureCPP-183">  #endif</front>
<front id="temperatureCPP-184">       ){</front>
<front id="temperatureCPP-185">          SERIAL_ECHOLN("PID Autotune failed. Bad extruder number.");</front>
<front id="temperatureCPP-186">          return;</front>
<front id="temperatureCPP-187">        }</front>
<front id="temperatureCPP-188">	</front>
<front id="temperatureCPP-189">  SERIAL_ECHOLN("PID Autotune start");</front>
<front id="temperatureCPP-190">  </front>
<front id="temperatureCPP-191">  disable_heater(); // switch off all heaters.</front>
<front id="temperatureCPP-192"></front>
<front id="temperatureCPP-193">  if (extruder&lt;0)</front>
<front id="temperatureCPP-194">  {</front>
<front id="temperatureCPP-195">     soft_pwm_bed = (MAX_BED_POWER)/2;</front>
<front id="temperatureCPP-196">     bias = d = (MAX_BED_POWER)/2;</front>
<front id="temperatureCPP-197">   }</front>
<front id="temperatureCPP-198">   else</front>
<front id="temperatureCPP-199">   {</front>
<front id="temperatureCPP-200">     soft_pwm[extruder] = (PID_MAX)/2;</front>
<front id="temperatureCPP-201">     bias = d = (PID_MAX)/2;</front>
<front id="temperatureCPP-202">  }</front>
<front id="temperatureCPP-203"></front>
<front id="temperatureCPP-204"></front>
<front id="temperatureCPP-205"></front>
<front id="temperatureCPP-206"></front>
<front id="temperatureCPP-207"> for(;;) {</front>
<front id="temperatureCPP-208"></front>
<front id="temperatureCPP-209">    if(temp_meas_ready == true) { // temp sample ready</front>
<front id="temperatureCPP-210">      updateTemperaturesFromRawValues();</front>
<front id="temperatureCPP-211"></front>
<front id="temperatureCPP-212">      input = (extruder&lt;0)?current_temperature_bed:current_temperature[extruder];</front>
<front id="temperatureCPP-213"></front>
<front id="temperatureCPP-214">      max=max(max,input);</front>
<front id="temperatureCPP-215">      min=min(min,input);</front>
<front id="temperatureCPP-216">      if(heating == true && input &gt; temp) {</front>
<front id="temperatureCPP-217">        if(millis() - t2 &gt; 5000) { </front>
<front id="temperatureCPP-218">          heating=false;</front>
<front id="temperatureCPP-219">          if (extruder&lt;0)</front>
<front id="temperatureCPP-220">            soft_pwm_bed = (bias - d) &gt;&gt; 1;</front>
<front id="temperatureCPP-221">          else</front>
<front id="temperatureCPP-222">            soft_pwm[extruder] = (bias - d) &gt;&gt; 1;</front>
<front id="temperatureCPP-223">          t1=millis();</front>
<front id="temperatureCPP-224">          t_high=t1 - t2;</front>
<front id="temperatureCPP-225">          max=temp;</front>
<front id="temperatureCPP-226">        }</front>
<front id="temperatureCPP-227">      }</front>
<front id="temperatureCPP-228">      if(heating == false && input &lt; temp) {</front>
<front id="temperatureCPP-229">        if(millis() - t1 &gt; 5000) {</front>
<front id="temperatureCPP-230">          heating=true;</front>
<front id="temperatureCPP-231">          t2=millis();</front>
<front id="temperatureCPP-232">          t_low=t2 - t1;</front>
<front id="temperatureCPP-233">          if(cycles &gt; 0) {</front>
<front id="temperatureCPP-234">            bias += (d*(t_high - t_low))/(t_low + t_high);</front>
<front id="temperatureCPP-235">            bias = constrain(bias, 20 ,(extruder&lt;0?(MAX_BED_POWER):(PID_MAX))-20);</front>
<front id="temperatureCPP-236">            if(bias &gt; (extruder&lt;0?(MAX_BED_POWER):(PID_MAX))/2) d = (extruder&lt;0?(MAX_BED_POWER):(PID_MAX)) - 1 - bias;</front>
<front id="temperatureCPP-237">            else d = bias;</front>
<front id="temperatureCPP-238"></front>
<front id="temperatureCPP-239">            SERIAL_PROTOCOLPGM(" bias: "); SERIAL_PROTOCOL(bias);</front>
<front id="temperatureCPP-240">            SERIAL_PROTOCOLPGM(" d: "); SERIAL_PROTOCOL(d);</front>
<front id="temperatureCPP-241">            SERIAL_PROTOCOLPGM(" min: "); SERIAL_PROTOCOL(min);</front>
<front id="temperatureCPP-242">            SERIAL_PROTOCOLPGM(" max: "); SERIAL_PROTOCOLLN(max);</front>
<front id="temperatureCPP-243">            if(cycles &gt; 2) {</front>
<front id="temperatureCPP-244">              Ku = (4.0*d)/(3.14159*(max-min)/2.0);</front>
<front id="temperatureCPP-245">              Tu = ((float)(t_low + t_high)/1000.0);</front>
<front id="temperatureCPP-246">              SERIAL_PROTOCOLPGM(" Ku: "); SERIAL_PROTOCOL(Ku);</front>
<front id="temperatureCPP-247">              SERIAL_PROTOCOLPGM(" Tu: "); SERIAL_PROTOCOLLN(Tu);</front>
<front id="temperatureCPP-248">              Kp = 0.6*Ku;</front>
<front id="temperatureCPP-249">              Ki = 2*Kp/Tu;</front>
<front id="temperatureCPP-250">              Kd = Kp*Tu/8;</front>
<front id="temperatureCPP-251">              SERIAL_PROTOCOLLNPGM(" Clasic PID ");</front>
<front id="temperatureCPP-252">              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-253">              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-254">              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-255">              /*</front>
<front id="temperatureCPP-256">              Kp = 0.33*Ku;</front>
<front id="temperatureCPP-257">              Ki = Kp/Tu;</front>
<front id="temperatureCPP-258">              Kd = Kp*Tu/3;</front>
<front id="temperatureCPP-259">              SERIAL_PROTOCOLLNPGM(" Some overshoot ")</front>
<front id="temperatureCPP-260">              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-261">              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-262">              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-263">              Kp = 0.2*Ku;</front>
<front id="temperatureCPP-264">              Ki = 2*Kp/Tu;</front>
<front id="temperatureCPP-265">              Kd = Kp*Tu/3;</front>
<front id="temperatureCPP-266">              SERIAL_PROTOCOLLNPGM(" No overshoot ")</front>
<front id="temperatureCPP-267">              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-268">              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-269">              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-270">              */</front>
<front id="temperatureCPP-271">            }</front>
<front id="temperatureCPP-272">          }</front>
<front id="temperatureCPP-273">          if (extruder&lt;0)</front>
<front id="temperatureCPP-274">            soft_pwm_bed = (bias + d) &gt;&gt; 1;</front>
<front id="temperatureCPP-275">          else</front>
<front id="temperatureCPP-276">            soft_pwm[extruder] = (bias + d) &gt;&gt; 1;</front>
<front id="temperatureCPP-277">          cycles++;</front>
<front id="temperatureCPP-278">          min=temp;</front>
<front id="temperatureCPP-279">        }</front>
<front id="temperatureCPP-280">      } </front>
<front id="temperatureCPP-281">    }</front>
<front id="temperatureCPP-282">    if(input &gt; (temp + 20)) {</front>
<front id="temperatureCPP-283">      SERIAL_PROTOCOLLNPGM("PID Autotune failed! Temperature too high");</front>
<front id="temperatureCPP-284">      return;</front>
<front id="temperatureCPP-285">    }</front>
<front id="temperatureCPP-286">    if(millis() - temp_millis &gt; 2000) {</front>
<front id="temperatureCPP-287">      int p;</front>
<front id="temperatureCPP-288">      if (extruder&lt;0){</front>
<front id="temperatureCPP-289">        p=soft_pwm_bed;       </front>
<front id="temperatureCPP-290">        SERIAL_PROTOCOLPGM("ok B:");</front>
<front id="temperatureCPP-291">      }else{</front>
<front id="temperatureCPP-292">        p=soft_pwm[extruder];       </front>
<front id="temperatureCPP-293">        SERIAL_PROTOCOLPGM("ok T:");</front>
<front id="temperatureCPP-294">      }</front>
<front id="temperatureCPP-295">			</front>
<front id="temperatureCPP-296">      SERIAL_PROTOCOL(input);   </front>
<front id="temperatureCPP-297">      SERIAL_PROTOCOLPGM(" @:");</front>
<front id="temperatureCPP-298">      SERIAL_PROTOCOLLN(p);       </front>
<front id="temperatureCPP-299"></front>
<front id="temperatureCPP-300">      temp_millis = millis();</front>
<front id="temperatureCPP-301">    }</front>
<front id="temperatureCPP-302">    if(((millis() - t1) + (millis() - t2)) &gt; (10L*60L*1000L*2L)) {</front>
<front id="temperatureCPP-303">      SERIAL_PROTOCOLLNPGM("PID Autotune failed! timeout");</front>
<front id="temperatureCPP-304">      return;</front>
<front id="temperatureCPP-305">    }</front>
<front id="temperatureCPP-306">    if(cycles &gt; ncycles) {</front>
<front id="temperatureCPP-307">      SERIAL_PROTOCOLLNPGM("PID Autotune finished! Put the Kp, Ki and Kd constants into Configuration.h");</front>
<front id="temperatureCPP-308">      return;</front>
<front id="temperatureCPP-309">    }</front>
<front id="temperatureCPP-310">    lcd_update();</front>
<front id="temperatureCPP-311">  }</front>
<front id="temperatureCPP-312">}</front>
<front id="temperatureCPP-313"></front>
<front id="temperatureCPP-314">void updatePID()</front>
<front id="temperatureCPP-315">{</front>
<front id="temperatureCPP-316">#ifdef PIDTEMP</front>
<front id="temperatureCPP-317">  for(int e = 0; e &lt; EXTRUDERS; e++) { </front>
<front id="temperatureCPP-318">     temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;  </front>
<front id="temperatureCPP-319">  }</front>
<front id="temperatureCPP-320">#endif</front>
<front id="temperatureCPP-321">#ifdef PIDTEMPBED</front>
<front id="temperatureCPP-322">  temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;  </front>
<front id="temperatureCPP-323">#endif</front>
<front id="temperatureCPP-324">}</front>
<front id="temperatureCPP-325">  </front>
<front id="temperatureCPP-326">int getHeaterPower(int heater) {</front>
<front id="temperatureCPP-327">	if (heater&lt;0)</front>
<front id="temperatureCPP-328">		return soft_pwm_bed;</front>
<front id="temperatureCPP-329">  return soft_pwm[heater];</front>
<front id="temperatureCPP-330">}</front>
<front id="temperatureCPP-331"></front>
<front id="temperatureCPP-332">#if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN &gt; -1) || \</front>
<front id="temperatureCPP-333">    (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN &gt; -1) || \</front>
<front id="temperatureCPP-334">    (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN &gt; -1)</front>
<front id="temperatureCPP-335"></front>
<front id="temperatureCPP-336">  #if defined(FAN_PIN) && FAN_PIN &gt; -1</front>
<front id="temperatureCPP-337">    #if EXTRUDER_0_AUTO_FAN_PIN == FAN_PIN </front>
<front id="temperatureCPP-338">       #error "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN"</front>
<front id="temperatureCPP-339">    #endif</front>
<front id="temperatureCPP-340">    #if EXTRUDER_1_AUTO_FAN_PIN == FAN_PIN </front>
<front id="temperatureCPP-341">       #error "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN"</front>
<front id="temperatureCPP-342">    #endif</front>
<front id="temperatureCPP-343">    #if EXTRUDER_2_AUTO_FAN_PIN == FAN_PIN </front>
<front id="temperatureCPP-344">       #error "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN"</front>
<front id="temperatureCPP-345">    #endif</front>
<front id="temperatureCPP-346">  #endif </front>
<front id="temperatureCPP-347"></front>
<front id="temperatureCPP-348">void setExtruderAutoFanState(int pin, bool state)</front>
<front id="temperatureCPP-349">{</front>
<front id="temperatureCPP-350">  unsigned char newFanSpeed = (state != 0) ? EXTRUDER_AUTO_FAN_SPEED : 0;</front>
<front id="temperatureCPP-351">  // this idiom allows both digital and PWM fan outputs (see M42 handling).</front>
<front id="temperatureCPP-352">  pinMode(pin, OUTPUT);</front>
<front id="temperatureCPP-353">  digitalWrite(pin, newFanSpeed);</front>
<front id="temperatureCPP-354">  analogWrite(pin, newFanSpeed);</front>
<front id="temperatureCPP-355">}</front>
<front id="temperatureCPP-356"></front>
<front id="temperatureCPP-357">void checkExtruderAutoFans()</front>
<front id="temperatureCPP-358">{</front>
<front id="temperatureCPP-359">  uint8_t fanState = 0;</front>
<front id="temperatureCPP-360"></front>
<front id="temperatureCPP-361">  // which fan pins need to be turned on?      </front>
<front id="temperatureCPP-362">  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN &gt; -1</front>
<front id="temperatureCPP-363">    if (current_temperature[0] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-364">      fanState |= 1;</front>
<front id="temperatureCPP-365">  #endif</front>
<front id="temperatureCPP-366">  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN &gt; -1</front>
<front id="temperatureCPP-367">    if (current_temperature[1] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-368">    {</front>
<front id="temperatureCPP-369">      if (EXTRUDER_1_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-370">        fanState |= 1;</front>
<front id="temperatureCPP-371">      else</front>
<front id="temperatureCPP-372">        fanState |= 2;</front>
<front id="temperatureCPP-373">    }</front>
<front id="temperatureCPP-374">  #endif</front>
<front id="temperatureCPP-375">  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN &gt; -1</front>
<front id="temperatureCPP-376">    if (current_temperature[2] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-377">    {</front>
<front id="temperatureCPP-378">      if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-379">        fanState |= 1;</front>
<front id="temperatureCPP-380">      else if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-381">        fanState |= 2;</front>
<front id="temperatureCPP-382">      else</front>
<front id="temperatureCPP-383">        fanState |= 4;</front>
<front id="temperatureCPP-384">    }</front>
<front id="temperatureCPP-385">  #endif</front>
<front id="temperatureCPP-386">  </front>
<front id="temperatureCPP-387">  // update extruder auto fan states</front>
<front id="temperatureCPP-388">  #if defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN &gt; -1</front>
<front id="temperatureCPP-389">    setExtruderAutoFanState(EXTRUDER_0_AUTO_FAN_PIN, (fanState & 1) != 0);</front>
<front id="temperatureCPP-390">  #endif </front>
<front id="temperatureCPP-391">  #if defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN &gt; -1</front>
<front id="temperatureCPP-392">    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-393">      setExtruderAutoFanState(EXTRUDER_1_AUTO_FAN_PIN, (fanState & 2) != 0);</front>
<front id="temperatureCPP-394">  #endif </front>
<front id="temperatureCPP-395">  #if defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN &gt; -1</front>
<front id="temperatureCPP-396">    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN </front>
<front id="temperatureCPP-397">        && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-398">      setExtruderAutoFanState(EXTRUDER_2_AUTO_FAN_PIN, (fanState & 4) != 0);</front>
<front id="temperatureCPP-399">  #endif </front>
<front id="temperatureCPP-400">}</front>
<front id="temperatureCPP-401"></front>
<front id="temperatureCPP-402">#endif // any extruder auto fan pins set</front>
<front id="temperatureCPP-403"></front>
<front id="temperatureCPP-404">void manage_heater()</front>
<front id="temperatureCPP-405">{</front>
<front id="temperatureCPP-406">  float pid_input;</front>
<front id="temperatureCPP-407">  float pid_output;</front>
<front id="temperatureCPP-408"></front>
<front id="temperatureCPP-409">  if(temp_meas_ready != true)   //better readability</front>
<front id="temperatureCPP-410">    return; </front>
<front id="temperatureCPP-411"></front>
<front id="temperatureCPP-412">  updateTemperaturesFromRawValues();</front>
<front id="temperatureCPP-413"></front>
<front id="temperatureCPP-414">  for(int e = 0; e &lt; EXTRUDERS; e++) </front>
<front id="temperatureCPP-415">  {</front>
<front id="temperatureCPP-416"></front>
<front id="temperatureCPP-417">  #ifdef PIDTEMP</front>
<front id="temperatureCPP-418">    pid_input = current_temperature[e];</front>
<front id="temperatureCPP-419"></front>
<front id="temperatureCPP-420">    #ifndef PID_OPENLOOP</front>
<front id="temperatureCPP-421">        pid_error[e] = target_temperature[e] - pid_input;</front>
<front id="temperatureCPP-422">        if(pid_error[e] &gt; PID_FUNCTIONAL_RANGE) {</front>
<front id="temperatureCPP-423">          pid_output = BANG_MAX;</front>
<front id="temperatureCPP-424">          pid_reset[e] = true;</front>
<front id="temperatureCPP-425">        }</front>
<front id="temperatureCPP-426">        else if(pid_error[e] &lt; -PID_FUNCTIONAL_RANGE || target_temperature[e] == 0) {</front>
<front id="temperatureCPP-427">          pid_output = 0;</front>
<front id="temperatureCPP-428">          pid_reset[e] = true;</front>
<front id="temperatureCPP-429">        }</front>
<front id="temperatureCPP-430">        else {</front>
<front id="temperatureCPP-431">          if(pid_reset[e] == true) {</front>
<front id="temperatureCPP-432">            temp_iState[e] = 0.0;</front>
<front id="temperatureCPP-433">            pid_reset[e] = false;</front>
<front id="temperatureCPP-434">          }</front>
<front id="temperatureCPP-435">          pTerm[e] = Kp * pid_error[e];</front>
<front id="temperatureCPP-436">          temp_iState[e] += pid_error[e];</front>
<front id="temperatureCPP-437">          temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);</front>
<front id="temperatureCPP-438">          iTerm[e] = Ki * temp_iState[e];</front>
<front id="temperatureCPP-439"></front>
<front id="temperatureCPP-440">          //K1 defined in Configuration.h in the PID settings</front>
<front id="temperatureCPP-441">          #define K2 (1.0-K1)</front>
<front id="temperatureCPP-442">          dTerm[e] = (Kd * (pid_input - temp_dState[e]))*K2 + (K1 * dTerm[e]);</front>
<front id="temperatureCPP-443">          pid_output = constrain(pTerm[e] + iTerm[e] - dTerm[e], 0, PID_MAX);</front>
<front id="temperatureCPP-444">        }</front>
<front id="temperatureCPP-445">        temp_dState[e] = pid_input;</front>
<front id="temperatureCPP-446">    #else </front>
<front id="temperatureCPP-447">          pid_output = constrain(target_temperature[e], 0, PID_MAX);</front>
<front id="temperatureCPP-448">    #endif //PID_OPENLOOP</front>
<front id="temperatureCPP-449">    #ifdef PID_DEBUG</front>
<front id="temperatureCPP-450">    SERIAL_ECHO_START(" PIDDEBUG ");</front>
<front id="temperatureCPP-451">    SERIAL_ECHO(e);</front>
<front id="temperatureCPP-452">    SERIAL_ECHO(": Input ");</front>
<front id="temperatureCPP-453">    SERIAL_ECHO(pid_input);</front>
<front id="temperatureCPP-454">    SERIAL_ECHO(" Output ");</front>
<front id="temperatureCPP-455">    SERIAL_ECHO(pid_output);</front>
<front id="temperatureCPP-456">    SERIAL_ECHO(" pTerm ");</front>
<front id="temperatureCPP-457">    SERIAL_ECHO(pTerm[e]);</front>
<front id="temperatureCPP-458">    SERIAL_ECHO(" iTerm ");</front>
<front id="temperatureCPP-459">    SERIAL_ECHO(iTerm[e]);</front>
<front id="temperatureCPP-460">    SERIAL_ECHO(" dTerm ");</front>
<front id="temperatureCPP-461">    SERIAL_ECHOLN(dTerm[e]);  </front>
<front id="temperatureCPP-462">    #endif //PID_DEBUG</front>
<front id="temperatureCPP-463">  #else /* PID off */</front>
<front id="temperatureCPP-464">    pid_output = 0;</front>
<front id="temperatureCPP-465">    if(current_temperature[e] &lt; target_temperature[e]) {</front>
<front id="temperatureCPP-466">      pid_output = PID_MAX;</front>
<front id="temperatureCPP-467">    }</front>
<front id="temperatureCPP-468">  #endif</front>
<front id="temperatureCPP-469"></front>
<front id="temperatureCPP-470">    // Check if temperature is within the correct range</front>
<front id="temperatureCPP-471">    if((current_temperature[e] &gt; minttemp[e]) && (current_temperature[e] &lt; maxttemp[e])) </front>
<front id="temperatureCPP-472">    {</front>
<front id="temperatureCPP-473">      soft_pwm[e] = (int)pid_output &gt;&gt; 1;</front>
<front id="temperatureCPP-474">    }</front>
<front id="temperatureCPP-475">    else {</front>
<front id="temperatureCPP-476">      soft_pwm[e] = 0;</front>
<front id="temperatureCPP-477">    }</front>
<front id="temperatureCPP-478"></front>
<front id="temperatureCPP-479">    #ifdef WATCH_TEMP_PERIOD</front>
<front id="temperatureCPP-480">    if(watchmillis[e] && millis() - watchmillis[e] &gt; WATCH_TEMP_PERIOD)</front>
<front id="temperatureCPP-481">    {</front>
<front id="temperatureCPP-482">        if(degHotend(e) &lt; watch_start_temp[e] + WATCH_TEMP_INCREASE)</front>
<front id="temperatureCPP-483">        {</front>
<front id="temperatureCPP-484">            setTargetHotend(0, e);</front>
<front id="temperatureCPP-485">            LCD_MESSAGEPGM("Heating failed");</front>
<front id="temperatureCPP-486">            SERIAL_ECHO_START;</front>
<front id="temperatureCPP-487">            SERIAL_ECHOLN("Heating failed");</front>
<front id="temperatureCPP-488">        }else{</front>
<front id="temperatureCPP-489">            watchmillis[e] = 0;</front>
<front id="temperatureCPP-490">        }</front>
<front id="temperatureCPP-491">    }</front>
<front id="temperatureCPP-492">    #endif</front>
<front id="temperatureCPP-493">    #ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureCPP-494">      if(fabs(current_temperature[0] - redundant_temperature) &gt; MAX_REDUNDANT_TEMP_SENSOR_DIFF) {</front>
<front id="temperatureCPP-495">        disable_heater();</front>
<front id="temperatureCPP-496">        if(IsStopped() == false) {</front>
<front id="temperatureCPP-497">          SERIAL_ERROR_START;</front>
<front id="temperatureCPP-498">          SERIAL_ERRORLNPGM("Extruder switched off. Temperature difference between temp sensors is too high !");</front>
<front id="temperatureCPP-499">          LCD_ALERTMESSAGEPGM("Err: REDUNDANT TEMP ERROR");</front>
<front id="temperatureCPP-500">        }</front>
<front id="temperatureCPP-501">        #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="temperatureCPP-502">          Stop();</front>
<front id="temperatureCPP-503">        #endif</front>
<front id="temperatureCPP-504">      }</front>
<front id="temperatureCPP-505">    #endif</front>
<front id="temperatureCPP-506">  } // End extruder for loop</front>
<front id="temperatureCPP-507"></front>
<front id="temperatureCPP-508">  #if (defined(EXTRUDER_0_AUTO_FAN_PIN) && EXTRUDER_0_AUTO_FAN_PIN &gt; -1) || \</front>
<front id="temperatureCPP-509">      (defined(EXTRUDER_1_AUTO_FAN_PIN) && EXTRUDER_1_AUTO_FAN_PIN &gt; -1) || \</front>
<front id="temperatureCPP-510">      (defined(EXTRUDER_2_AUTO_FAN_PIN) && EXTRUDER_2_AUTO_FAN_PIN &gt; -1)</front>
<front id="temperatureCPP-511">  if(millis() - extruder_autofan_last_check &gt; 2500)  // only need to check fan state very infrequently</front>
<front id="temperatureCPP-512">  {</front>
<front id="temperatureCPP-513">    checkExtruderAutoFans();</front>
<front id="temperatureCPP-514">    extruder_autofan_last_check = millis();</front>
<front id="temperatureCPP-515">  }  </front>
<front id="temperatureCPP-516">  #endif       </front>
<front id="temperatureCPP-517">  </front>
<front id="temperatureCPP-518">  #ifndef PIDTEMPBED</front>
<front id="temperatureCPP-519">  if(millis() - previous_millis_bed_heater &lt; BED_CHECK_INTERVAL)</front>
<front id="temperatureCPP-520">    return;</front>
<front id="temperatureCPP-521">  previous_millis_bed_heater = millis();</front>
<front id="temperatureCPP-522">  #endif</front>
<front id="temperatureCPP-523"></front>
<front id="temperatureCPP-524">  #if TEMP_SENSOR_BED != 0</front>
<front id="temperatureCPP-525">  </front>
<front id="temperatureCPP-526">  #ifdef PIDTEMPBED</front>
<front id="temperatureCPP-527">    pid_input = current_temperature_bed;</front>
<front id="temperatureCPP-528"></front>
<front id="temperatureCPP-529">    #ifndef PID_OPENLOOP</front>
<front id="temperatureCPP-530">		  pid_error_bed = target_temperature_bed - pid_input;</front>
<front id="temperatureCPP-531">		  pTerm_bed = bedKp * pid_error_bed;</front>
<front id="temperatureCPP-532">		  temp_iState_bed += pid_error_bed;</front>
<front id="temperatureCPP-533">		  temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);</front>
<front id="temperatureCPP-534">		  iTerm_bed = bedKi * temp_iState_bed;</front>
<front id="temperatureCPP-535"></front>
<front id="temperatureCPP-536">		  //K1 defined in Configuration.h in the PID settings</front>
<front id="temperatureCPP-537">		  #define K2 (1.0-K1)</front>
<front id="temperatureCPP-538">		  dTerm_bed= (bedKd * (pid_input - temp_dState_bed))*K2 + (K1 * dTerm_bed);</front>
<front id="temperatureCPP-539">		  temp_dState_bed = pid_input;</front>
<front id="temperatureCPP-540"></front>
<front id="temperatureCPP-541">		  pid_output = constrain(pTerm_bed + iTerm_bed - dTerm_bed, 0, MAX_BED_POWER);</front>
<front id="temperatureCPP-542"></front>
<front id="temperatureCPP-543">    #else </front>
<front id="temperatureCPP-544">      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);</front>
<front id="temperatureCPP-545">    #endif //PID_OPENLOOP</front>
<front id="temperatureCPP-546"></front>
<front id="temperatureCPP-547">	  if((current_temperature_bed &gt; BED_MINTEMP) && (current_temperature_bed &lt; BED_MAXTEMP)) </front>
<front id="temperatureCPP-548">	  {</front>
<front id="temperatureCPP-549">	    soft_pwm_bed = (int)pid_output &gt;&gt; 1;</front>
<front id="temperatureCPP-550">	  }</front>
<front id="temperatureCPP-551">	  else {</front>
<front id="temperatureCPP-552">	    soft_pwm_bed = 0;</front>
<front id="temperatureCPP-553">	  }</front>
<front id="temperatureCPP-554"></front>
<front id="temperatureCPP-555">    #elif !defined(BED_LIMIT_SWITCHING)</front>
<front id="temperatureCPP-556">      // Check if temperature is within the correct range</front>
<front id="temperatureCPP-557">      if((current_temperature_bed &gt; BED_MINTEMP) && (current_temperature_bed &lt; BED_MAXTEMP))</front>
<front id="temperatureCPP-558">      {</front>
<front id="temperatureCPP-559">        if(current_temperature_bed &gt;= target_temperature_bed)</front>
<front id="temperatureCPP-560">        {</front>
<front id="temperatureCPP-561">          soft_pwm_bed = 0;</front>
<front id="temperatureCPP-562">        }</front>
<front id="temperatureCPP-563">        else </front>
<front id="temperatureCPP-564">        {</front>
<front id="temperatureCPP-565">          soft_pwm_bed = MAX_BED_POWER&gt;&gt;1;</front>
<front id="temperatureCPP-566">        }</front>
<front id="temperatureCPP-567">      }</front>
<front id="temperatureCPP-568">      else</front>
<front id="temperatureCPP-569">      {</front>
<front id="temperatureCPP-570">        soft_pwm_bed = 0;</front>
<front id="temperatureCPP-571">        WRITE(HEATER_BED_PIN,LOW);</front>
<front id="temperatureCPP-572">      }</front>
<front id="temperatureCPP-573">    #else //#ifdef BED_LIMIT_SWITCHING</front>
<front id="temperatureCPP-574">      // Check if temperature is within the correct band</front>
<front id="temperatureCPP-575">      if((current_temperature_bed &gt; BED_MINTEMP) && (current_temperature_bed &lt; BED_MAXTEMP))</front>
<front id="temperatureCPP-576">      {</front>
<front id="temperatureCPP-577">        if(current_temperature_bed &gt; target_temperature_bed + BED_HYSTERESIS)</front>
<front id="temperatureCPP-578">        {</front>
<front id="temperatureCPP-579">          soft_pwm_bed = 0;</front>
<front id="temperatureCPP-580">        }</front>
<front id="temperatureCPP-581">        else if(current_temperature_bed &lt;= target_temperature_bed - BED_HYSTERESIS)</front>
<front id="temperatureCPP-582">        {</front>
<front id="temperatureCPP-583">          soft_pwm_bed = MAX_BED_POWER&gt;&gt;1;</front>
<front id="temperatureCPP-584">        }</front>
<front id="temperatureCPP-585">      }</front>
<front id="temperatureCPP-586">      else</front>
<front id="temperatureCPP-587">      {</front>
<front id="temperatureCPP-588">        soft_pwm_bed = 0;</front>
<front id="temperatureCPP-589">        WRITE(HEATER_BED_PIN,LOW);</front>
<front id="temperatureCPP-590">      }</front>
<front id="temperatureCPP-591">    #endif</front>
<front id="temperatureCPP-592">  #endif</front>
<front id="temperatureCPP-593">}</front>
<front id="temperatureCPP-594"></front>
<front id="temperatureCPP-595">#define PGM_RD_W(x)   (short)pgm_read_word(&x)</front>
<front id="temperatureCPP-596">// Derived from RepRap FiveD extruder::getTemperature()</front>
<front id="temperatureCPP-597">// For hot end temperature measurement.</front>
<front id="temperatureCPP-598">static float analog2temp(int raw, uint8_t e) {</front>
<front id="temperatureCPP-599">#ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureCPP-600">  if(e &gt; EXTRUDERS)</front>
<front id="temperatureCPP-601">#else</front>
<front id="temperatureCPP-602">  if(e &gt;= EXTRUDERS)</front>
<front id="temperatureCPP-603">#endif</front>
<front id="temperatureCPP-604">  {</front>
<front id="temperatureCPP-605">      SERIAL_ERROR_START;</front>
<front id="temperatureCPP-606">      SERIAL_ERROR((int)e);</front>
<front id="temperatureCPP-607">      SERIAL_ERRORLNPGM(" - Invalid extruder number !");</front>
<front id="temperatureCPP-608">      kill();</front>
<front id="temperatureCPP-609">  } </front>
<front id="temperatureCPP-610">  #ifdef HEATER_0_USES_MAX6675</front>
<front id="temperatureCPP-611">    if (e == 0)</front>
<front id="temperatureCPP-612">    {</front>
<front id="temperatureCPP-613">      return 0.25 * raw;</front>
<front id="temperatureCPP-614">    }</front>
<front id="temperatureCPP-615">  #endif</front>
<front id="temperatureCPP-616"></front>
<front id="temperatureCPP-617">  if(heater_ttbl_map[e] != NULL)</front>
<front id="temperatureCPP-618">  {</front>
<front id="temperatureCPP-619">    float celsius = 0;</front>
<front id="temperatureCPP-620">    uint8_t i;</front>
<front id="temperatureCPP-621">    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);</front>
<front id="temperatureCPP-622"></front>
<front id="temperatureCPP-623">    for (i=1; i&lt;heater_ttbllen_map[e]; i++)</front>
<front id="temperatureCPP-624">    {</front>
<front id="temperatureCPP-625">      if (PGM_RD_W((*tt)[i][0]) &gt; raw)</front>
<front id="temperatureCPP-626">      {</front>
<front id="temperatureCPP-627">        celsius = PGM_RD_W((*tt)[i-1][1]) + </front>
<front id="temperatureCPP-628">          (raw - PGM_RD_W((*tt)[i-1][0])) * </front>
<front id="temperatureCPP-629">          (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1])) /</front>
<front id="temperatureCPP-630">          (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0]));</front>
<front id="temperatureCPP-631">        break;</front>
<front id="temperatureCPP-632">      }</front>
<front id="temperatureCPP-633">    }</front>
<front id="temperatureCPP-634"></front>
<front id="temperatureCPP-635">    // Overflow: Set to last value in the table</front>
<front id="temperatureCPP-636">    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i-1][1]);</front>
<front id="temperatureCPP-637"></front>
<front id="temperatureCPP-638">    return celsius;</front>
<front id="temperatureCPP-639">  }</front>
<front id="temperatureCPP-640">  return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;</front>
<front id="temperatureCPP-641">}</front>
<front id="temperatureCPP-642"></front>
<front id="temperatureCPP-643">// Derived from RepRap FiveD extruder::getTemperature()</front>
<front id="temperatureCPP-644">// For bed temperature measurement.</front>
<front id="temperatureCPP-645">static float analog2tempBed(int raw) {</front>
<front id="temperatureCPP-646">  #ifdef BED_USES_THERMISTOR</front>
<front id="temperatureCPP-647">    float celsius = 0;</front>
<front id="temperatureCPP-648">    byte i;</front>
<front id="temperatureCPP-649"></front>
<front id="temperatureCPP-650">    for (i=1; i&lt;BEDTEMPTABLE_LEN; i++)</front>
<front id="temperatureCPP-651">    {</front>
<front id="temperatureCPP-652">      if (PGM_RD_W(BEDTEMPTABLE[i][0]) &gt; raw)</front>
<front id="temperatureCPP-653">      {</front>
<front id="temperatureCPP-654">        celsius  = PGM_RD_W(BEDTEMPTABLE[i-1][1]) + </front>
<front id="temperatureCPP-655">          (raw - PGM_RD_W(BEDTEMPTABLE[i-1][0])) * </front>
<front id="temperatureCPP-656">          (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i-1][1])) /</front>
<front id="temperatureCPP-657">          (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i-1][0]));</front>
<front id="temperatureCPP-658">        break;</front>
<front id="temperatureCPP-659">      }</front>
<front id="temperatureCPP-660">    }</front>
<front id="temperatureCPP-661"></front>
<front id="temperatureCPP-662">    // Overflow: Set to last value in the table</front>
<front id="temperatureCPP-663">    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i-1][1]);</front>
<front id="temperatureCPP-664"></front>
<front id="temperatureCPP-665">    return celsius;</front>
<front id="temperatureCPP-666">  #elif defined BED_USES_AD595</front>
<front id="temperatureCPP-667">    return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;</front>
<front id="temperatureCPP-668">  #else</front>
<front id="temperatureCPP-669">    return 0;</front>
<front id="temperatureCPP-670">  #endif</front>
<front id="temperatureCPP-671">}</front>
<front id="temperatureCPP-672"></front>
<front id="temperatureCPP-673">/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,</front>
<front id="temperatureCPP-674">    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */</front>
<front id="temperatureCPP-675">static void updateTemperaturesFromRawValues()</front>
<front id="temperatureCPP-676">{</front>
<front id="temperatureCPP-677">    for(uint8_t e=0;e&lt;EXTRUDERS;e++)</front>
<front id="temperatureCPP-678">    {</front>
<front id="temperatureCPP-679">        current_temperature[e] = analog2temp(current_temperature_raw[e], e);</front>
<front id="temperatureCPP-680">    }</front>
<front id="temperatureCPP-681">    current_temperature_bed = analog2tempBed(current_temperature_bed_raw);</front>
<front id="temperatureCPP-682">    #ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureCPP-683">      redundant_temperature = analog2temp(redundant_temperature_raw, 1);</front>
<front id="temperatureCPP-684">    #endif</front>
<front id="temperatureCPP-685">    //Reset the watchdog after we know we have a temperature measurement.</front>
<front id="temperatureCPP-686">    watchdog_reset();</front>
<front id="temperatureCPP-687"></front>
<front id="temperatureCPP-688">    CRITICAL_SECTION_START;</front>
<front id="temperatureCPP-689">    temp_meas_ready = false;</front>
<front id="temperatureCPP-690">    CRITICAL_SECTION_END;</front>
<front id="temperatureCPP-691">}</front>
<front id="temperatureCPP-692"></front>
<front id="temperatureCPP-693">void tp_init()</front>
<front id="temperatureCPP-694">{</front>
<front id="temperatureCPP-695">#if (MOTHERBOARD == 80) && ((TEMP_SENSOR_0==-1)||(TEMP_SENSOR_1==-1)||(TEMP_SENSOR_2==-1)||(TEMP_SENSOR_BED==-1))</front>
<front id="temperatureCPP-696">  //disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector</front>
<front id="temperatureCPP-697">  MCUCR=(1&lt;&lt;JTD); </front>
<front id="temperatureCPP-698">  MCUCR=(1&lt;&lt;JTD);</front>
<front id="temperatureCPP-699">#endif</front>
<front id="temperatureCPP-700">  </front>
<front id="temperatureCPP-701">  // Finish init of mult extruder arrays </front>
<front id="temperatureCPP-702">  for(int e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="temperatureCPP-703">    // populate with the first value </front>
<front id="temperatureCPP-704">    maxttemp[e] = maxttemp[0];</front>
<front id="temperatureCPP-705">#ifdef PIDTEMP</front>
<front id="temperatureCPP-706">    temp_iState_min[e] = 0.0;</front>
<front id="temperatureCPP-707">    temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / Ki;</front>
<front id="temperatureCPP-708">#endif //PIDTEMP</front>
<front id="temperatureCPP-709">#ifdef PIDTEMPBED</front>
<front id="temperatureCPP-710">    temp_iState_min_bed = 0.0;</front>
<front id="temperatureCPP-711">    temp_iState_max_bed = PID_INTEGRAL_DRIVE_MAX / bedKi;</front>
<front id="temperatureCPP-712">#endif //PIDTEMPBED</front>
<front id="temperatureCPP-713">  }</front>
<front id="temperatureCPP-714"></front>
<front id="temperatureCPP-715">  #if defined(HEATER_0_PIN) && (HEATER_0_PIN &gt; -1) </front>
<front id="temperatureCPP-716">    SET_OUTPUT(HEATER_0_PIN);</front>
<front id="temperatureCPP-717">  #endif  </front>
<front id="temperatureCPP-718">  #if defined(HEATER_1_PIN) && (HEATER_1_PIN &gt; -1) </front>
<front id="temperatureCPP-719">    SET_OUTPUT(HEATER_1_PIN);</front>
<front id="temperatureCPP-720">  #endif  </front>
<front id="temperatureCPP-721">  #if defined(HEATER_2_PIN) && (HEATER_2_PIN &gt; -1) </front>
<front id="temperatureCPP-722">    SET_OUTPUT(HEATER_2_PIN);</front>
<front id="temperatureCPP-723">  #endif  </front>
<front id="temperatureCPP-724">  #if defined(HEATER_BED_PIN) && (HEATER_BED_PIN &gt; -1) </front>
<front id="temperatureCPP-725">    SET_OUTPUT(HEATER_BED_PIN);</front>
<front id="temperatureCPP-726">  #endif  </front>
<front id="temperatureCPP-727">  #if defined(FAN_PIN) && (FAN_PIN &gt; -1) </front>
<front id="temperatureCPP-728">    SET_OUTPUT(FAN_PIN);</front>
<front id="temperatureCPP-729">    #ifdef FAST_PWM_FAN</front>
<front id="temperatureCPP-730">    setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8</front>
<front id="temperatureCPP-731">    #endif</front>
<front id="temperatureCPP-732">    #ifdef FAN_SOFT_PWM</front>
<front id="temperatureCPP-733">    soft_pwm_fan = fanSpeedSoftPwm / 2;</front>
<front id="temperatureCPP-734">    #endif</front>
<front id="temperatureCPP-735">  #endif  </front>
<front id="temperatureCPP-736"></front>
<front id="temperatureCPP-737">  #ifdef HEATER_0_USES_MAX6675</front>
<front id="temperatureCPP-738">    #ifndef SDSUPPORT</front>
<front id="temperatureCPP-739">      SET_OUTPUT(MAX_SCK_PIN);</front>
<front id="temperatureCPP-740">      WRITE(MAX_SCK_PIN,0);</front>
<front id="temperatureCPP-741">    </front>
<front id="temperatureCPP-742">      SET_OUTPUT(MAX_MOSI_PIN);</front>
<front id="temperatureCPP-743">      WRITE(MAX_MOSI_PIN,1);</front>
<front id="temperatureCPP-744">    </front>
<front id="temperatureCPP-745">      SET_INPUT(MAX_MISO_PIN);</front>
<front id="temperatureCPP-746">      WRITE(MAX_MISO_PIN,1);</front>
<front id="temperatureCPP-747">    #endif</front>
<front id="temperatureCPP-748">    </front>
<front id="temperatureCPP-749">    SET_OUTPUT(MAX6675_SS);</front>
<front id="temperatureCPP-750">    WRITE(MAX6675_SS,1);</front>
<front id="temperatureCPP-751">  #endif</front>
<front id="temperatureCPP-752"></front>
<front id="temperatureCPP-753">  // Set analog inputs</front>
<front id="temperatureCPP-754">  ADCSRA = 1&lt;&lt;ADEN | 1&lt;&lt;ADSC | 1&lt;&lt;ADIF | 0x07;</front>
<front id="temperatureCPP-755">  DIDR0 = 0;</front>
<front id="temperatureCPP-756">  #ifdef DIDR2</front>
<front id="temperatureCPP-757">    DIDR2 = 0;</front>
<front id="temperatureCPP-758">  #endif</front>
<front id="temperatureCPP-759">  #if defined(TEMP_0_PIN) && (TEMP_0_PIN &gt; -1)</front>
<front id="temperatureCPP-760">    #if TEMP_0_PIN &lt; 8</front>
<front id="temperatureCPP-761">       DIDR0 |= 1 &lt;&lt; TEMP_0_PIN; </front>
<front id="temperatureCPP-762">    #else</front>
<front id="temperatureCPP-763">       DIDR2 |= 1&lt;&lt;(TEMP_0_PIN - 8); </front>
<front id="temperatureCPP-764">    #endif</front>
<front id="temperatureCPP-765">  #endif</front>
<front id="temperatureCPP-766">  #if defined(TEMP_1_PIN) && (TEMP_1_PIN &gt; -1)</front>
<front id="temperatureCPP-767">    #if TEMP_1_PIN &lt; 8</front>
<front id="temperatureCPP-768">       DIDR0 |= 1&lt;&lt;TEMP_1_PIN; </front>
<front id="temperatureCPP-769">    #else</front>
<front id="temperatureCPP-770">       DIDR2 |= 1&lt;&lt;(TEMP_1_PIN - 8); </front>
<front id="temperatureCPP-771">    #endif</front>
<front id="temperatureCPP-772">  #endif</front>
<front id="temperatureCPP-773">  #if defined(TEMP_2_PIN) && (TEMP_2_PIN &gt; -1)</front>
<front id="temperatureCPP-774">    #if TEMP_2_PIN &lt; 8</front>
<front id="temperatureCPP-775">       DIDR0 |= 1 &lt;&lt; TEMP_2_PIN; </front>
<front id="temperatureCPP-776">    #else</front>
<front id="temperatureCPP-777">       DIDR2 |= 1&lt;&lt;(TEMP_2_PIN - 8); </front>
<front id="temperatureCPP-778">    #endif</front>
<front id="temperatureCPP-779">  #endif</front>
<front id="temperatureCPP-780">  #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN &gt; -1)</front>
<front id="temperatureCPP-781">    #if TEMP_BED_PIN &lt; 8</front>
<front id="temperatureCPP-782">       DIDR0 |= 1&lt;&lt;TEMP_BED_PIN; </front>
<front id="temperatureCPP-783">    #else</front>
<front id="temperatureCPP-784">       DIDR2 |= 1&lt;&lt;(TEMP_BED_PIN - 8); </front>
<front id="temperatureCPP-785">    #endif</front>
<front id="temperatureCPP-786">  #endif</front>
<front id="temperatureCPP-787">  </front>
<front id="temperatureCPP-788">  // Use timer0 for temperature measurement</front>
<front id="temperatureCPP-789">  // Interleave temperature interrupt with millies interrupt</front>
<front id="temperatureCPP-790">  OCR0B = 128;</front>
<front id="temperatureCPP-791">  TIMSK0 |= (1&lt;&lt;OCIE0B);  </front>
<front id="temperatureCPP-792">  </front>
<front id="temperatureCPP-793">  // Wait for temperature measurement to settle</front>
<front id="temperatureCPP-794">  delay(250);</front>
<front id="temperatureCPP-795"></front>
<front id="temperatureCPP-796">#ifdef HEATER_0_MINTEMP</front>
<front id="temperatureCPP-797">  minttemp[0] = HEATER_0_MINTEMP;</front>
<front id="temperatureCPP-798">  while(analog2temp(minttemp_raw[0], 0) &lt; HEATER_0_MINTEMP) {</front>
<front id="temperatureCPP-799">#if HEATER_0_RAW_LO_TEMP &lt; HEATER_0_RAW_HI_TEMP</front>
<front id="temperatureCPP-800">    minttemp_raw[0] += OVERSAMPLENR;</front>
<front id="temperatureCPP-801">#else</front>
<front id="temperatureCPP-802">    minttemp_raw[0] -= OVERSAMPLENR;</front>
<front id="temperatureCPP-803">#endif</front>
<front id="temperatureCPP-804">  }</front>
<front id="temperatureCPP-805">#endif //MINTEMP</front>
<front id="temperatureCPP-806">#ifdef HEATER_0_MAXTEMP</front>
<front id="temperatureCPP-807">  maxttemp[0] = HEATER_0_MAXTEMP;</front>
<front id="temperatureCPP-808">  while(analog2temp(maxttemp_raw[0], 0) &gt; HEATER_0_MAXTEMP) {</front>
<front id="temperatureCPP-809">#if HEATER_0_RAW_LO_TEMP &lt; HEATER_0_RAW_HI_TEMP</front>
<front id="temperatureCPP-810">    maxttemp_raw[0] -= OVERSAMPLENR;</front>
<front id="temperatureCPP-811">#else</front>
<front id="temperatureCPP-812">    maxttemp_raw[0] += OVERSAMPLENR;</front>
<front id="temperatureCPP-813">#endif</front>
<front id="temperatureCPP-814">  }</front>
<front id="temperatureCPP-815">#endif //MAXTEMP</front>
<front id="temperatureCPP-816"></front>
<front id="temperatureCPP-817">#if (EXTRUDERS &gt; 1) && defined(HEATER_1_MINTEMP)</front>
<front id="temperatureCPP-818">  minttemp[1] = HEATER_1_MINTEMP;</front>
<front id="temperatureCPP-819">  while(analog2temp(minttemp_raw[1], 1) &lt; HEATER_1_MINTEMP) {</front>
<front id="temperatureCPP-820">#if HEATER_1_RAW_LO_TEMP &lt; HEATER_1_RAW_HI_TEMP</front>
<front id="temperatureCPP-821">    minttemp_raw[1] += OVERSAMPLENR;</front>
<front id="temperatureCPP-822">#else</front>
<front id="temperatureCPP-823">    minttemp_raw[1] -= OVERSAMPLENR;</front>
<front id="temperatureCPP-824">#endif</front>
<front id="temperatureCPP-825">  }</front>
<front id="temperatureCPP-826">#endif // MINTEMP 1</front>
<front id="temperatureCPP-827">#if (EXTRUDERS &gt; 1) && defined(HEATER_1_MAXTEMP)</front>
<front id="temperatureCPP-828">  maxttemp[1] = HEATER_1_MAXTEMP;</front>
<front id="temperatureCPP-829">  while(analog2temp(maxttemp_raw[1], 1) &gt; HEATER_1_MAXTEMP) {</front>
<front id="temperatureCPP-830">#if HEATER_1_RAW_LO_TEMP &lt; HEATER_1_RAW_HI_TEMP</front>
<front id="temperatureCPP-831">    maxttemp_raw[1] -= OVERSAMPLENR;</front>
<front id="temperatureCPP-832">#else</front>
<front id="temperatureCPP-833">    maxttemp_raw[1] += OVERSAMPLENR;</front>
<front id="temperatureCPP-834">#endif</front>
<front id="temperatureCPP-835">  }</front>
<front id="temperatureCPP-836">#endif //MAXTEMP 1</front>
<front id="temperatureCPP-837"></front>
<front id="temperatureCPP-838">#if (EXTRUDERS &gt; 2) && defined(HEATER_2_MINTEMP)</front>
<front id="temperatureCPP-839">  minttemp[2] = HEATER_2_MINTEMP;</front>
<front id="temperatureCPP-840">  while(analog2temp(minttemp_raw[2], 2) &lt; HEATER_2_MINTEMP) {</front>
<front id="temperatureCPP-841">#if HEATER_2_RAW_LO_TEMP &lt; HEATER_2_RAW_HI_TEMP</front>
<front id="temperatureCPP-842">    minttemp_raw[2] += OVERSAMPLENR;</front>
<front id="temperatureCPP-843">#else</front>
<front id="temperatureCPP-844">    minttemp_raw[2] -= OVERSAMPLENR;</front>
<front id="temperatureCPP-845">#endif</front>
<front id="temperatureCPP-846">  }</front>
<front id="temperatureCPP-847">#endif //MINTEMP 2</front>
<front id="temperatureCPP-848">#if (EXTRUDERS &gt; 2) && defined(HEATER_2_MAXTEMP)</front>
<front id="temperatureCPP-849">  maxttemp[2] = HEATER_2_MAXTEMP;</front>
<front id="temperatureCPP-850">  while(analog2temp(maxttemp_raw[2], 2) &gt; HEATER_2_MAXTEMP) {</front>
<front id="temperatureCPP-851">#if HEATER_2_RAW_LO_TEMP &lt; HEATER_2_RAW_HI_TEMP</front>
<front id="temperatureCPP-852">    maxttemp_raw[2] -= OVERSAMPLENR;</front>
<front id="temperatureCPP-853">#else</front>
<front id="temperatureCPP-854">    maxttemp_raw[2] += OVERSAMPLENR;</front>
<front id="temperatureCPP-855">#endif</front>
<front id="temperatureCPP-856">  }</front>
<front id="temperatureCPP-857">#endif //MAXTEMP 2</front>
<front id="temperatureCPP-858"></front>
<front id="temperatureCPP-859">#ifdef BED_MINTEMP</front>
<front id="temperatureCPP-860">  /* No bed MINTEMP error implemented?!? */ /*</front>
<front id="temperatureCPP-861">  while(analog2tempBed(bed_minttemp_raw) &lt; BED_MINTEMP) {</front>
<front id="temperatureCPP-862">#if HEATER_BED_RAW_LO_TEMP &lt; HEATER_BED_RAW_HI_TEMP</front>
<front id="temperatureCPP-863">    bed_minttemp_raw += OVERSAMPLENR;</front>
<front id="temperatureCPP-864">#else</front>
<front id="temperatureCPP-865">    bed_minttemp_raw -= OVERSAMPLENR;</front>
<front id="temperatureCPP-866">#endif</front>
<front id="temperatureCPP-867">  }</front>
<front id="temperatureCPP-868">  */</front>
<front id="temperatureCPP-869">#endif //BED_MINTEMP</front>
<front id="temperatureCPP-870">#ifdef BED_MAXTEMP</front>
<front id="temperatureCPP-871">  while(analog2tempBed(bed_maxttemp_raw) &gt; BED_MAXTEMP) {</front>
<front id="temperatureCPP-872">#if HEATER_BED_RAW_LO_TEMP &lt; HEATER_BED_RAW_HI_TEMP</front>
<front id="temperatureCPP-873">    bed_maxttemp_raw -= OVERSAMPLENR;</front>
<front id="temperatureCPP-874">#else</front>
<front id="temperatureCPP-875">    bed_maxttemp_raw += OVERSAMPLENR;</front>
<front id="temperatureCPP-876">#endif</front>
<front id="temperatureCPP-877">  }</front>
<front id="temperatureCPP-878">#endif //BED_MAXTEMP</front>
<front id="temperatureCPP-879">}</front>
<front id="temperatureCPP-880"></front>
<front id="temperatureCPP-881">void setWatch() </front>
<front id="temperatureCPP-882">{  </front>
<front id="temperatureCPP-883">#ifdef WATCH_TEMP_PERIOD</front>
<front id="temperatureCPP-884">  for (int e = 0; e &lt; EXTRUDERS; e++)</front>
<front id="temperatureCPP-885">  {</front>
<front id="temperatureCPP-886">    if(degHotend(e) &lt; degTargetHotend(e) - (WATCH_TEMP_INCREASE * 2))</front>
<front id="temperatureCPP-887">    {</front>
<front id="temperatureCPP-888">      watch_start_temp[e] = degHotend(e);</front>
<front id="temperatureCPP-889">      watchmillis[e] = millis();</front>
<front id="temperatureCPP-890">    } </front>
<front id="temperatureCPP-891">  }</front>
<front id="temperatureCPP-892">#endif </front>
<front id="temperatureCPP-893">}</front>
<front id="temperatureCPP-894"></front>
<front id="temperatureCPP-895"></front>
<front id="temperatureCPP-896">void disable_heater()</front>
<front id="temperatureCPP-897">{</front>
<front id="temperatureCPP-898">  for(int i=0;i&lt;EXTRUDERS;i++)</front>
<front id="temperatureCPP-899">    setTargetHotend(0,i);</front>
<front id="temperatureCPP-900">  setTargetBed(0);</front>
<front id="temperatureCPP-901">  #if defined(TEMP_0_PIN) && TEMP_0_PIN &gt; -1</front>
<front id="temperatureCPP-902">  target_temperature[0]=0;</front>
<front id="temperatureCPP-903">  soft_pwm[0]=0;</front>
<front id="temperatureCPP-904">   #if defined(HEATER_0_PIN) && HEATER_0_PIN &gt; -1  </front>
<front id="temperatureCPP-905">     WRITE(HEATER_0_PIN,LOW);</front>
<front id="temperatureCPP-906">   #endif</front>
<front id="temperatureCPP-907">  #endif</front>
<front id="temperatureCPP-908">     </front>
<front id="temperatureCPP-909">  #if defined(TEMP_1_PIN) && TEMP_1_PIN &gt; -1</front>
<front id="temperatureCPP-910">    target_temperature[1]=0;</front>
<front id="temperatureCPP-911">    soft_pwm[1]=0;</front>
<front id="temperatureCPP-912">    #if defined(HEATER_1_PIN) && HEATER_1_PIN &gt; -1 </front>
<front id="temperatureCPP-913">      WRITE(HEATER_1_PIN,LOW);</front>
<front id="temperatureCPP-914">    #endif</front>
<front id="temperatureCPP-915">  #endif</front>
<front id="temperatureCPP-916">      </front>
<front id="temperatureCPP-917">  #if defined(TEMP_2_PIN) && TEMP_2_PIN &gt; -1</front>
<front id="temperatureCPP-918">    target_temperature[2]=0;</front>
<front id="temperatureCPP-919">    soft_pwm[2]=0;</front>
<front id="temperatureCPP-920">    #if defined(HEATER_2_PIN) && HEATER_2_PIN &gt; -1  </front>
<front id="temperatureCPP-921">      WRITE(HEATER_2_PIN,LOW);</front>
<front id="temperatureCPP-922">    #endif</front>
<front id="temperatureCPP-923">  #endif </front>
<front id="temperatureCPP-924"></front>
<front id="temperatureCPP-925">  #if defined(TEMP_BED_PIN) && TEMP_BED_PIN &gt; -1</front>
<front id="temperatureCPP-926">    target_temperature_bed=0;</front>
<front id="temperatureCPP-927">    soft_pwm_bed=0;</front>
<front id="temperatureCPP-928">    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN &gt; -1  </front>
<front id="temperatureCPP-929">      WRITE(HEATER_BED_PIN,LOW);</front>
<front id="temperatureCPP-930">    #endif</front>
<front id="temperatureCPP-931">  #endif </front>
<front id="temperatureCPP-932">}</front>
<front id="temperatureCPP-933"></front>
<front id="temperatureCPP-934">void max_temp_error(uint8_t e) {</front>
<front id="temperatureCPP-935">  disable_heater();</front>
<front id="temperatureCPP-936">  if(IsStopped() == false) {</front>
<front id="temperatureCPP-937">    SERIAL_ERROR_START;</front>
<front id="temperatureCPP-938">    SERIAL_ERRORLN((int)e);</front>
<front id="temperatureCPP-939">    SERIAL_ERRORLNPGM(": Extruder switched off. MAXTEMP triggered !");</front>
<front id="temperatureCPP-940">    LCD_ALERTMESSAGEPGM("Err: MAXTEMP");</front>
<front id="temperatureCPP-941">  }</front>
<front id="temperatureCPP-942">  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="temperatureCPP-943">  Stop();</front>
<front id="temperatureCPP-944">  #endif</front>
<front id="temperatureCPP-945">}</front>
<front id="temperatureCPP-946"></front>
<front id="temperatureCPP-947">void min_temp_error(uint8_t e) {</front>
<front id="temperatureCPP-948">  disable_heater();</front>
<front id="temperatureCPP-949">  if(IsStopped() == false) {</front>
<front id="temperatureCPP-950">    SERIAL_ERROR_START;</front>
<front id="temperatureCPP-951">    SERIAL_ERRORLN((int)e);</front>
<front id="temperatureCPP-952">    SERIAL_ERRORLNPGM(": Extruder switched off. MINTEMP triggered !");</front>
<front id="temperatureCPP-953">    LCD_ALERTMESSAGEPGM("Err: MINTEMP");</front>
<front id="temperatureCPP-954">  }</front>
<front id="temperatureCPP-955">  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="temperatureCPP-956">  Stop();</front>
<front id="temperatureCPP-957">  #endif</front>
<front id="temperatureCPP-958">}</front>
<front id="temperatureCPP-959"></front>
<front id="temperatureCPP-960">void bed_max_temp_error(void) {</front>
<front id="temperatureCPP-961">#if HEATER_BED_PIN &gt; -1</front>
<front id="temperatureCPP-962">  WRITE(HEATER_BED_PIN, 0);</front>
<front id="temperatureCPP-963">#endif</front>
<front id="temperatureCPP-964">  if(IsStopped() == false) {</front>
<front id="temperatureCPP-965">    SERIAL_ERROR_START;</front>
<front id="temperatureCPP-966">    SERIAL_ERRORLNPGM("Temperature heated bed switched off. MAXTEMP triggered !!");</front>
<front id="temperatureCPP-967">    LCD_ALERTMESSAGEPGM("Err: MAXTEMP BED");</front>
<front id="temperatureCPP-968">  }</front>
<front id="temperatureCPP-969">  #ifndef BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="temperatureCPP-970">  Stop();</front>
<front id="temperatureCPP-971">  #endif</front>
<front id="temperatureCPP-972">}</front>
<front id="temperatureCPP-973"></front>
<front id="temperatureCPP-974">#ifdef HEATER_0_USES_MAX6675</front>
<front id="temperatureCPP-975">#define MAX6675_HEAT_INTERVAL 250</front>
<front id="temperatureCPP-976">long max6675_previous_millis = -HEAT_INTERVAL;</front>
<front id="temperatureCPP-977">int max6675_temp = 2000;</front>
<front id="temperatureCPP-978"></front>
<front id="temperatureCPP-979">int read_max6675()</front>
<front id="temperatureCPP-980">{</front>
<front id="temperatureCPP-981">  if (millis() - max6675_previous_millis &lt; MAX6675_HEAT_INTERVAL) </front>
<front id="temperatureCPP-982">    return max6675_temp;</front>
<front id="temperatureCPP-983">  </front>
<front id="temperatureCPP-984">  max6675_previous_millis = millis();</front>
<front id="temperatureCPP-985">  max6675_temp = 0;</front>
<front id="temperatureCPP-986">    </front>
<front id="temperatureCPP-987">  #ifdef	PRR</front>
<front id="temperatureCPP-988">    PRR &= ~(1&lt;&lt;PRSPI);</front>
<front id="temperatureCPP-989">  #elif defined PRR0</front>
<front id="temperatureCPP-990">    PRR0 &= ~(1&lt;&lt;PRSPI);</front>
<front id="temperatureCPP-991">  #endif</front>
<front id="temperatureCPP-992">  </front>
<front id="temperatureCPP-993">  SPCR = (1&lt;&lt;MSTR) | (1&lt;&lt;SPE) | (1&lt;&lt;SPR0);</front>
<front id="temperatureCPP-994">  </front>
<front id="temperatureCPP-995">  // enable TT_MAX6675</front>
<front id="temperatureCPP-996">  WRITE(MAX6675_SS, 0);</front>
<front id="temperatureCPP-997">  </front>
<front id="temperatureCPP-998">  // ensure 100ns delay - a bit extra is fine</front>
<front id="temperatureCPP-999">  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz</front>
<front id="temperatureCPP-1000">  asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz</front>
<front id="temperatureCPP-1001">  </front>
<front id="temperatureCPP-1002">  // read MSB</front>
<front id="temperatureCPP-1003">  SPDR = 0;</front>
<front id="temperatureCPP-1004">  for (;(SPSR & (1&lt;&lt;SPIF)) == 0;);</front>
<front id="temperatureCPP-1005">  max6675_temp = SPDR;</front>
<front id="temperatureCPP-1006">  max6675_temp &lt;&lt;= 8;</front>
<front id="temperatureCPP-1007">  </front>
<front id="temperatureCPP-1008">  // read LSB</front>
<front id="temperatureCPP-1009">  SPDR = 0;</front>
<front id="temperatureCPP-1010">  for (;(SPSR & (1&lt;&lt;SPIF)) == 0;);</front>
<front id="temperatureCPP-1011">  max6675_temp |= SPDR;</front>
<front id="temperatureCPP-1012">  </front>
<front id="temperatureCPP-1013">  // disable TT_MAX6675</front>
<front id="temperatureCPP-1014">  WRITE(MAX6675_SS, 1);</front>
<front id="temperatureCPP-1015"></front>
<front id="temperatureCPP-1016">  if (max6675_temp & 4) </front>
<front id="temperatureCPP-1017">  {</front>
<front id="temperatureCPP-1018">    // thermocouple open</front>
<front id="temperatureCPP-1019">    max6675_temp = 2000;</front>
<front id="temperatureCPP-1020">  }</front>
<front id="temperatureCPP-1021">  else </front>
<front id="temperatureCPP-1022">  {</front>
<front id="temperatureCPP-1023">    max6675_temp = max6675_temp &gt;&gt; 3;</front>
<front id="temperatureCPP-1024">  }</front>
<front id="temperatureCPP-1025"></front>
<front id="temperatureCPP-1026">  return max6675_temp;</front>
<front id="temperatureCPP-1027">}</front>
<front id="temperatureCPP-1028">#endif</front>
<front id="temperatureCPP-1029"></front>
<front id="temperatureCPP-1030"></front>
<front id="temperatureCPP-1031">// Timer 0 is shared with millies</front>
<front id="temperatureCPP-1032">ISR(TIMER0_COMPB_vect)</front>
<front id="temperatureCPP-1033">{</front>
<front id="temperatureCPP-1034">  //these variables are only accesible from the ISR, but static, so they don't lose their value</front>
<front id="temperatureCPP-1035">  static unsigned char temp_count = 0;</front>
<front id="temperatureCPP-1036">  static unsigned long raw_temp_0_value = 0;</front>
<front id="temperatureCPP-1037">  static unsigned long raw_temp_1_value = 0;</front>
<front id="temperatureCPP-1038">  static unsigned long raw_temp_2_value = 0;</front>
<front id="temperatureCPP-1039">  static unsigned long raw_temp_bed_value = 0;</front>
<front id="temperatureCPP-1040">  static unsigned char temp_state = 0;</front>
<front id="temperatureCPP-1041">  static unsigned char pwm_count = (1 &lt;&lt; SOFT_PWM_SCALE);</front>
<front id="temperatureCPP-1042">  static unsigned char soft_pwm_0;</front>
<front id="temperatureCPP-1043">  #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1044">  static unsigned char soft_pwm_1;</front>
<front id="temperatureCPP-1045">  #endif</front>
<front id="temperatureCPP-1046">  #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1047">  static unsigned char soft_pwm_2;</front>
<front id="temperatureCPP-1048">  #endif</front>
<front id="temperatureCPP-1049">  #if HEATER_BED_PIN &gt; -1</front>
<front id="temperatureCPP-1050">  static unsigned char soft_pwm_b;</front>
<front id="temperatureCPP-1051">  #endif</front>
<front id="temperatureCPP-1052">  </front>
<front id="temperatureCPP-1053">  if(pwm_count == 0){</front>
<front id="temperatureCPP-1054">    soft_pwm_0 = soft_pwm[0];</front>
<front id="temperatureCPP-1055">    if(soft_pwm_0 &gt; 0) WRITE(HEATER_0_PIN,1);</front>
<front id="temperatureCPP-1056">    #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1057">    soft_pwm_1 = soft_pwm[1];</front>
<front id="temperatureCPP-1058">    if(soft_pwm_1 &gt; 0) WRITE(HEATER_1_PIN,1);</front>
<front id="temperatureCPP-1059">    #endif</front>
<front id="temperatureCPP-1060">    #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1061">    soft_pwm_2 = soft_pwm[2];</front>
<front id="temperatureCPP-1062">    if(soft_pwm_2 &gt; 0) WRITE(HEATER_2_PIN,1);</front>
<front id="temperatureCPP-1063">    #endif</front>
<front id="temperatureCPP-1064">    #if defined(HEATER_BED_PIN) && HEATER_BED_PIN &gt; -1</front>
<front id="temperatureCPP-1065">    soft_pwm_b = soft_pwm_bed;</front>
<front id="temperatureCPP-1066">    if(soft_pwm_b &gt; 0) WRITE(HEATER_BED_PIN,1);</front>
<front id="temperatureCPP-1067">    #endif</front>
<front id="temperatureCPP-1068">    #ifdef FAN_SOFT_PWM</front>
<front id="temperatureCPP-1069">    soft_pwm_fan = fanSpeedSoftPwm / 2;</front>
<front id="temperatureCPP-1070">    if(soft_pwm_fan &gt; 0) WRITE(FAN_PIN,1);</front>
<front id="temperatureCPP-1071">    #endif</front>
<front id="temperatureCPP-1072">  }</front>
<front id="temperatureCPP-1073">  if(soft_pwm_0 &lt;= pwm_count) WRITE(HEATER_0_PIN,0);</front>
<front id="temperatureCPP-1074">  #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1075">  if(soft_pwm_1 &lt;= pwm_count) WRITE(HEATER_1_PIN,0);</front>
<front id="temperatureCPP-1076">  #endif</front>
<front id="temperatureCPP-1077">  #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1078">  if(soft_pwm_2 &lt;= pwm_count) WRITE(HEATER_2_PIN,0);</front>
<front id="temperatureCPP-1079">  #endif</front>
<front id="temperatureCPP-1080">  #if defined(HEATER_BED_PIN) && HEATER_BED_PIN &gt; -1</front>
<front id="temperatureCPP-1081">  if(soft_pwm_b &lt;= pwm_count) WRITE(HEATER_BED_PIN,0);</front>
<front id="temperatureCPP-1082">  #endif</front>
<front id="temperatureCPP-1083">  #ifdef FAN_SOFT_PWM</front>
<front id="temperatureCPP-1084">  if(soft_pwm_fan &lt;= pwm_count) WRITE(FAN_PIN,0);</front>
<front id="temperatureCPP-1085">  #endif</front>
<front id="temperatureCPP-1086">  </front>
<front id="temperatureCPP-1087">  pwm_count += (1 &lt;&lt; SOFT_PWM_SCALE);</front>
<front id="temperatureCPP-1088">  pwm_count &= 0x7f;</front>
<front id="temperatureCPP-1089">  </front>
<front id="temperatureCPP-1090">  switch(temp_state) {</front>
<front id="temperatureCPP-1091">    case 0: // Prepare TEMP_0</front>
<front id="temperatureCPP-1092">      #if defined(TEMP_0_PIN) && (TEMP_0_PIN &gt; -1)</front>
<front id="temperatureCPP-1093">        #if TEMP_0_PIN &gt; 7</front>
<front id="temperatureCPP-1094">          ADCSRB = 1&lt;&lt;MUX5;</front>
<front id="temperatureCPP-1095">        #else</front>
<front id="temperatureCPP-1096">          ADCSRB = 0;</front>
<front id="temperatureCPP-1097">        #endif</front>
<front id="temperatureCPP-1098">        ADMUX = ((1 &lt;&lt; REFS0) | (TEMP_0_PIN & 0x07));</front>
<front id="temperatureCPP-1099">        ADCSRA |= 1&lt;&lt;ADSC; // Start conversion</front>
<front id="temperatureCPP-1100">      #endif</front>
<front id="temperatureCPP-1101">      lcd_buttons_update();</front>
<front id="temperatureCPP-1102">      temp_state = 1;</front>
<front id="temperatureCPP-1103">      break;</front>
<front id="temperatureCPP-1104">    case 1: // Measure TEMP_0</front>
<front id="temperatureCPP-1105">      #if defined(TEMP_0_PIN) && (TEMP_0_PIN &gt; -1)</front>
<front id="temperatureCPP-1106">        raw_temp_0_value += ADC;</front>
<front id="temperatureCPP-1107">      #endif</front>
<front id="temperatureCPP-1108">      #ifdef HEATER_0_USES_MAX6675 // TODO remove the blocking</front>
<front id="temperatureCPP-1109">        raw_temp_0_value = read_max6675();</front>
<front id="temperatureCPP-1110">      #endif</front>
<front id="temperatureCPP-1111">      temp_state = 2;</front>
<front id="temperatureCPP-1112">      break;</front>
<front id="temperatureCPP-1113">    case 2: // Prepare TEMP_BED</front>
<front id="temperatureCPP-1114">      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN &gt; -1)</front>
<front id="temperatureCPP-1115">        #if TEMP_BED_PIN &gt; 7</front>
<front id="temperatureCPP-1116">          ADCSRB = 1&lt;&lt;MUX5;</front>
<front id="temperatureCPP-1117">        #else</front>
<front id="temperatureCPP-1118">          ADCSRB = 0;</front>
<front id="temperatureCPP-1119">        #endif</front>
<front id="temperatureCPP-1120">        ADMUX = ((1 &lt;&lt; REFS0) | (TEMP_BED_PIN & 0x07));</front>
<front id="temperatureCPP-1121">        ADCSRA |= 1&lt;&lt;ADSC; // Start conversion</front>
<front id="temperatureCPP-1122">      #endif</front>
<front id="temperatureCPP-1123">      lcd_buttons_update();</front>
<front id="temperatureCPP-1124">      temp_state = 3;</front>
<front id="temperatureCPP-1125">      break;</front>
<front id="temperatureCPP-1126">    case 3: // Measure TEMP_BED</front>
<front id="temperatureCPP-1127">      #if defined(TEMP_BED_PIN) && (TEMP_BED_PIN &gt; -1)</front>
<front id="temperatureCPP-1128">        raw_temp_bed_value += ADC;</front>
<front id="temperatureCPP-1129">      #endif</front>
<front id="temperatureCPP-1130">      temp_state = 4;</front>
<front id="temperatureCPP-1131">      break;</front>
<front id="temperatureCPP-1132">    case 4: // Prepare TEMP_1</front>
<front id="temperatureCPP-1133">      #if defined(TEMP_1_PIN) && (TEMP_1_PIN &gt; -1)</front>
<front id="temperatureCPP-1134">        #if TEMP_1_PIN &gt; 7</front>
<front id="temperatureCPP-1135">          ADCSRB = 1&lt;&lt;MUX5;</front>
<front id="temperatureCPP-1136">        #else</front>
<front id="temperatureCPP-1137">          ADCSRB = 0;</front>
<front id="temperatureCPP-1138">        #endif</front>
<front id="temperatureCPP-1139">        ADMUX = ((1 &lt;&lt; REFS0) | (TEMP_1_PIN & 0x07));</front>
<front id="temperatureCPP-1140">        ADCSRA |= 1&lt;&lt;ADSC; // Start conversion</front>
<front id="temperatureCPP-1141">      #endif</front>
<front id="temperatureCPP-1142">      lcd_buttons_update();</front>
<front id="temperatureCPP-1143">      temp_state = 5;</front>
<front id="temperatureCPP-1144">      break;</front>
<front id="temperatureCPP-1145">    case 5: // Measure TEMP_1</front>
<front id="temperatureCPP-1146">      #if defined(TEMP_1_PIN) && (TEMP_1_PIN &gt; -1)</front>
<front id="temperatureCPP-1147">        raw_temp_1_value += ADC;</front>
<front id="temperatureCPP-1148">      #endif</front>
<front id="temperatureCPP-1149">      temp_state = 6;</front>
<front id="temperatureCPP-1150">      break;</front>
<front id="temperatureCPP-1151">    case 6: // Prepare TEMP_2</front>
<front id="temperatureCPP-1152">      #if defined(TEMP_2_PIN) && (TEMP_2_PIN &gt; -1)</front>
<front id="temperatureCPP-1153">        #if TEMP_2_PIN &gt; 7</front>
<front id="temperatureCPP-1154">          ADCSRB = 1&lt;&lt;MUX5;</front>
<front id="temperatureCPP-1155">        #else</front>
<front id="temperatureCPP-1156">          ADCSRB = 0;</front>
<front id="temperatureCPP-1157">        #endif</front>
<front id="temperatureCPP-1158">        ADMUX = ((1 &lt;&lt; REFS0) | (TEMP_2_PIN & 0x07));</front>
<front id="temperatureCPP-1159">        ADCSRA |= 1&lt;&lt;ADSC; // Start conversion</front>
<front id="temperatureCPP-1160">      #endif</front>
<front id="temperatureCPP-1161">      lcd_buttons_update();</front>
<front id="temperatureCPP-1162">      temp_state = 7;</front>
<front id="temperatureCPP-1163">      break;</front>
<front id="temperatureCPP-1164">    case 7: // Measure TEMP_2</front>
<front id="temperatureCPP-1165">      #if defined(TEMP_2_PIN) && (TEMP_2_PIN &gt; -1)</front>
<front id="temperatureCPP-1166">        raw_temp_2_value += ADC;</front>
<front id="temperatureCPP-1167">      #endif</front>
<front id="temperatureCPP-1168">      temp_state = 0;</front>
<front id="temperatureCPP-1169">      temp_count++;</front>
<front id="temperatureCPP-1170">      break;</front>
<front id="temperatureCPP-1171">//    default:</front>
<front id="temperatureCPP-1172">//      SERIAL_ERROR_START;</front>
<front id="temperatureCPP-1173">//      SERIAL_ERRORLNPGM("Temp measurement error!");</front>
<front id="temperatureCPP-1174">//      break;</front>
<front id="temperatureCPP-1175">  }</front>
<front id="temperatureCPP-1176">    </front>
<front id="temperatureCPP-1177">  if(temp_count &gt;= 16) // 8 ms * 16 = 128ms.</front>
<front id="temperatureCPP-1178">  {</front>
<front id="temperatureCPP-1179">    if (!temp_meas_ready) //Only update the raw values if they have been read. Else we could be updating them during reading.</front>
<front id="temperatureCPP-1180">    {</front>
<front id="temperatureCPP-1181">      current_temperature_raw[0] = raw_temp_0_value;</front>
<front id="temperatureCPP-1182">#if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1183">      current_temperature_raw[1] = raw_temp_1_value;</front>
<front id="temperatureCPP-1184">#endif</front>
<front id="temperatureCPP-1185">#ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureCPP-1186">      redundant_temperature_raw = raw_temp_1_value;</front>
<front id="temperatureCPP-1187">#endif</front>
<front id="temperatureCPP-1188">#if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1189">      current_temperature_raw[2] = raw_temp_2_value;</front>
<front id="temperatureCPP-1190">#endif</front>
<front id="temperatureCPP-1191">      current_temperature_bed_raw = raw_temp_bed_value;</front>
<front id="temperatureCPP-1192">    }</front>
<front id="temperatureCPP-1193">    </front>
<front id="temperatureCPP-1194">    temp_meas_ready = true;</front>
<front id="temperatureCPP-1195">    temp_count = 0;</front>
<front id="temperatureCPP-1196">    raw_temp_0_value = 0;</front>
<front id="temperatureCPP-1197">    raw_temp_1_value = 0;</front>
<front id="temperatureCPP-1198">    raw_temp_2_value = 0;</front>
<front id="temperatureCPP-1199">    raw_temp_bed_value = 0;</front>
<front id="temperatureCPP-1200"></front>
<front id="temperatureCPP-1201">#if HEATER_0_RAW_LO_TEMP &gt; HEATER_0_RAW_HI_TEMP</front>
<front id="temperatureCPP-1202">    if(current_temperature_raw[0] &lt;= maxttemp_raw[0]) {</front>
<front id="temperatureCPP-1203">#else</front>
<front id="temperatureCPP-1204">    if(current_temperature_raw[0] &gt;= maxttemp_raw[0]) {</front>
<front id="temperatureCPP-1205">#endif</front>
<front id="temperatureCPP-1206">        max_temp_error(0);</front>
<front id="temperatureCPP-1207">    }</front>
<front id="temperatureCPP-1208">#if HEATER_0_RAW_LO_TEMP &gt; HEATER_0_RAW_HI_TEMP</front>
<front id="temperatureCPP-1209">    if(current_temperature_raw[0] &gt;= minttemp_raw[0]) {</front>
<front id="temperatureCPP-1210">#else</front>
<front id="temperatureCPP-1211">    if(current_temperature_raw[0] &lt;= minttemp_raw[0]) {</front>
<front id="temperatureCPP-1212">#endif</front>
<front id="temperatureCPP-1213">        min_temp_error(0);</front>
<front id="temperatureCPP-1214">    }</front>
<front id="temperatureCPP-1215">#if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1216">#if HEATER_1_RAW_LO_TEMP &gt; HEATER_1_RAW_HI_TEMP</front>
<front id="temperatureCPP-1217">    if(current_temperature_raw[1] &lt;= maxttemp_raw[1]) {</front>
<front id="temperatureCPP-1218">#else</front>
<front id="temperatureCPP-1219">    if(current_temperature_raw[1] &gt;= maxttemp_raw[1]) {</front>
<front id="temperatureCPP-1220">#endif</front>
<front id="temperatureCPP-1221">        max_temp_error(1);</front>
<front id="temperatureCPP-1222">    }</front>
<front id="temperatureCPP-1223">#if HEATER_1_RAW_LO_TEMP &gt; HEATER_1_RAW_HI_TEMP</front>
<front id="temperatureCPP-1224">    if(current_temperature_raw[1] &gt;= minttemp_raw[1]) {</front>
<front id="temperatureCPP-1225">#else</front>
<front id="temperatureCPP-1226">    if(current_temperature_raw[1] &lt;= minttemp_raw[1]) {</front>
<front id="temperatureCPP-1227">#endif</front>
<front id="temperatureCPP-1228">        min_temp_error(1);</front>
<front id="temperatureCPP-1229">    }</front>
<front id="temperatureCPP-1230">#endif</front>
<front id="temperatureCPP-1231">#if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1232">#if HEATER_2_RAW_LO_TEMP &gt; HEATER_2_RAW_HI_TEMP</front>
<front id="temperatureCPP-1233">    if(current_temperature_raw[2] &lt;= maxttemp_raw[2]) {</front>
<front id="temperatureCPP-1234">#else</front>
<front id="temperatureCPP-1235">    if(current_temperature_raw[2] &gt;= maxttemp_raw[2]) {</front>
<front id="temperatureCPP-1236">#endif</front>
<front id="temperatureCPP-1237">        max_temp_error(2);</front>
<front id="temperatureCPP-1238">    }</front>
<front id="temperatureCPP-1239">#if HEATER_2_RAW_LO_TEMP &gt; HEATER_2_RAW_HI_TEMP</front>
<front id="temperatureCPP-1240">    if(current_temperature_raw[2] &gt;= minttemp_raw[2]) {</front>
<front id="temperatureCPP-1241">#else</front>
<front id="temperatureCPP-1242">    if(current_temperature_raw[2] &lt;= minttemp_raw[2]) {</front>
<front id="temperatureCPP-1243">#endif</front>
<front id="temperatureCPP-1244">        min_temp_error(2);</front>
<front id="temperatureCPP-1245">    }</front>
<front id="temperatureCPP-1246">#endif</front>
<front id="temperatureCPP-1247">  </front>
<front id="temperatureCPP-1248">  /* No bed MINTEMP error? */</front>
<front id="temperatureCPP-1249">#if defined(BED_MAXTEMP) && (TEMP_SENSOR_BED != 0)</front>
<front id="temperatureCPP-1250"># if HEATER_BED_RAW_LO_TEMP &gt; HEATER_BED_RAW_HI_TEMP</front>
<front id="temperatureCPP-1251">    if(current_temperature_bed_raw &lt;= bed_maxttemp_raw) {</front>
<front id="temperatureCPP-1252">#else</front>
<front id="temperatureCPP-1253">    if(current_temperature_bed_raw &gt;= bed_maxttemp_raw) {</front>
<front id="temperatureCPP-1254">#endif</front>
<front id="temperatureCPP-1255">       target_temperature_bed = 0;</front>
<front id="temperatureCPP-1256">       bed_max_temp_error();</front>
<front id="temperatureCPP-1257">    }</front>
<front id="temperatureCPP-1258">#endif</front>
<front id="temperatureCPP-1259">  }</front>
<front id="temperatureCPP-1260">  </front>
<front id="temperatureCPP-1261">#ifdef BABYSTEPPING</front>
<front id="temperatureCPP-1262">  for(uint8_t axis=0;axis&lt;3;axis++)</front>
<front id="temperatureCPP-1263">  {</front>
<front id="temperatureCPP-1264">    int curTodo=babystepsTodo[axis]; //get rid of volatile for performance</front>
<front id="temperatureCPP-1265">   </front>
<front id="temperatureCPP-1266">    if(curTodo&gt;0)</front>
<front id="temperatureCPP-1267">    {</front>
<front id="temperatureCPP-1268">      babystep(axis,/*fwd*/true);</front>
<front id="temperatureCPP-1269">      babystepsTodo[axis]--; //less to do next time</front>
<front id="temperatureCPP-1270">    }</front>
<front id="temperatureCPP-1271">    else</front>
<front id="temperatureCPP-1272">    if(curTodo&lt;0)</front>
<front id="temperatureCPP-1273">    {</front>
<front id="temperatureCPP-1274">      babystep(axis,/*fwd*/false);</front>
<front id="temperatureCPP-1275">      babystepsTodo[axis]++; //less to do next time</front>
<front id="temperatureCPP-1276">    }</front>
<front id="temperatureCPP-1277">  }</front>
<front id="temperatureCPP-1278">#endif //BABYSTEPPING</front>
<front id="temperatureCPP-1279">}</front>
<front id="temperatureCPP-1280"></front>
<front id="temperatureCPP-1281">#ifdef PIDTEMP</front>
<front id="temperatureCPP-1282">// Apply the scale factors to the PID values</front>
<front id="temperatureCPP-1283"></front>
<front id="temperatureCPP-1284"></front>
<front id="temperatureCPP-1285">float scalePID_i(float i)</front>
<front id="temperatureCPP-1286">{</front>
<front id="temperatureCPP-1287">	return i*PID_dT;</front>
<front id="temperatureCPP-1288">}</front>
<front id="temperatureCPP-1289"></front>
<front id="temperatureCPP-1290">float unscalePID_i(float i)</front>
<front id="temperatureCPP-1291">{</front>
<front id="temperatureCPP-1292">	return i/PID_dT;</front>
<front id="temperatureCPP-1293">}</front>
<front id="temperatureCPP-1294"></front>
<front id="temperatureCPP-1295">float scalePID_d(float d)</front>
<front id="temperatureCPP-1296">{</front>
<front id="temperatureCPP-1297">    return d/PID_dT;</front>
<front id="temperatureCPP-1298">}</front>
<front id="temperatureCPP-1299"></front>
<front id="temperatureCPP-1300">float unscalePID_d(float d)</front>
<front id="temperatureCPP-1301">{</front>
<front id="temperatureCPP-1302">	return d*PID_dT;</front>
<front id="temperatureCPP-1303">}</front>
<front id="temperatureCPP-1304"></front>
<front id="temperatureCPP-1305">#endif //PIDTEMP</front>
<front id="temperatureCPP-1306"></front>
<front id="temperatureCPP-1307"></front>
 </pre>
<h1>temperature.h</h1>
<pre  class="prettyprint linenums"><front id="temperatureH-1">/*</front>
<front id="temperatureH-2">  temperature.h - temperature controller</front>
<front id="temperatureH-3">  Part of Marlin</front>
<front id="temperatureH-4"></front>
<front id="temperatureH-5">  Copyright (c) 2011 Erik van der Zalm</front>
<front id="temperatureH-6"></front>
<front id="temperatureH-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="temperatureH-8">  it under the terms of the GNU General Public License as published by</front>
<front id="temperatureH-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="temperatureH-10">  (at your option) any later version.</front>
<front id="temperatureH-11"></front>
<front id="temperatureH-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="temperatureH-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="temperatureH-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="temperatureH-15">  GNU General Public License for more details.</front>
<front id="temperatureH-16"></front>
<front id="temperatureH-17">  You should have received a copy of the GNU General Public License</front>
<front id="temperatureH-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="temperatureH-19">*/</front>
<front id="temperatureH-20"></front>
<front id="temperatureH-21">#ifndef temperature_h</front>
<front id="temperatureH-22">#define temperature_h </front>
<front id="temperatureH-23"></front>
<front id="temperatureH-24">#include "Marlin.h"</front>
<front id="temperatureH-25">#include "planner.h"</front>
<front id="temperatureH-26">#ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="temperatureH-27">  #include "stepper.h"</front>
<front id="temperatureH-28">#endif</front>
<front id="temperatureH-29"></front>
<front id="temperatureH-30">// public functions</front>
<front id="temperatureH-31">void tp_init();  //initialise the heating</front>
<front id="temperatureH-32">void manage_heater(); //it is critical that this is called periodically.</front>
<front id="temperatureH-33"></front>
<front id="temperatureH-34">// low level conversion routines</front>
<front id="temperatureH-35">// do not use these routines and variables outside of temperature.cpp</front>
<front id="temperatureH-36">extern int target_temperature[EXTRUDERS];  </front>
<front id="temperatureH-37">extern float current_temperature[EXTRUDERS];</front>
<front id="temperatureH-38">extern int target_temperature_bed;</front>
<front id="temperatureH-39">extern float current_temperature_bed;</front>
<front id="temperatureH-40">#ifdef TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="temperatureH-41">  extern float redundant_temperature;</front>
<front id="temperatureH-42">#endif</front>
<front id="temperatureH-43"></front>
<front id="temperatureH-44">#ifdef PIDTEMP</front>
<front id="temperatureH-45">  extern float Kp,Ki,Kd,Kc;</front>
<front id="temperatureH-46">  float scalePID_i(float i);</front>
<front id="temperatureH-47">  float scalePID_d(float d);</front>
<front id="temperatureH-48">  float unscalePID_i(float i);</front>
<front id="temperatureH-49">  float unscalePID_d(float d);</front>
<front id="temperatureH-50"></front>
<front id="temperatureH-51">#endif</front>
<front id="temperatureH-52">#ifdef PIDTEMPBED</front>
<front id="temperatureH-53">  extern float bedKp,bedKi,bedKd;</front>
<front id="temperatureH-54">#endif</front>
<front id="temperatureH-55">  </front>
<front id="temperatureH-56">  </front>
<front id="temperatureH-57">#ifdef BABYSTEPPING</front>
<front id="temperatureH-58">  extern volatile int babystepsTodo[3];</front>
<front id="temperatureH-59">#endif</front>
<front id="temperatureH-60">  </front>
<front id="temperatureH-61">//high level conversion routines, for use outside of temperature.cpp</front>
<front id="temperatureH-62">//inline so that there is no performance decrease.</front>
<front id="temperatureH-63">//deg=degreeCelsius</front>
<front id="temperatureH-64"></front>
<front id="temperatureH-65">FORCE_INLINE float degHotend(uint8_t extruder) {  </front>
<front id="temperatureH-66">  return current_temperature[extruder];</front>
<front id="temperatureH-67">};</front>
<front id="temperatureH-68"></front>
<front id="temperatureH-69">FORCE_INLINE float degBed() {</front>
<front id="temperatureH-70">  return current_temperature_bed;</front>
<front id="temperatureH-71">};</front>
<front id="temperatureH-72"></front>
<front id="temperatureH-73">FORCE_INLINE float degTargetHotend(uint8_t extruder) {  </front>
<front id="temperatureH-74">  return target_temperature[extruder];</front>
<front id="temperatureH-75">};</front>
<front id="temperatureH-76"></front>
<front id="temperatureH-77">FORCE_INLINE float degTargetBed() {   </front>
<front id="temperatureH-78">  return target_temperature_bed;</front>
<front id="temperatureH-79">};</front>
<front id="temperatureH-80"></front>
<front id="temperatureH-81">FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {  </front>
<front id="temperatureH-82">  target_temperature[extruder] = celsius;</front>
<front id="temperatureH-83">};</front>
<front id="temperatureH-84"></front>
<front id="temperatureH-85">FORCE_INLINE void setTargetBed(const float &celsius) {  </front>
<front id="temperatureH-86">  target_temperature_bed = celsius;</front>
<front id="temperatureH-87">};</front>
<front id="temperatureH-88"></front>
<front id="temperatureH-89">FORCE_INLINE bool isHeatingHotend(uint8_t extruder){  </front>
<front id="temperatureH-90">  return target_temperature[extruder] &gt; current_temperature[extruder];</front>
<front id="temperatureH-91">};</front>
<front id="temperatureH-92"></front>
<front id="temperatureH-93">FORCE_INLINE bool isHeatingBed() {</front>
<front id="temperatureH-94">  return target_temperature_bed &gt; current_temperature_bed;</front>
<front id="temperatureH-95">};</front>
<front id="temperatureH-96"></front>
<front id="temperatureH-97">FORCE_INLINE bool isCoolingHotend(uint8_t extruder) {  </front>
<front id="temperatureH-98">  return target_temperature[extruder] &lt; current_temperature[extruder];</front>
<front id="temperatureH-99">};</front>
<front id="temperatureH-100"></front>
<front id="temperatureH-101">FORCE_INLINE bool isCoolingBed() {</front>
<front id="temperatureH-102">  return target_temperature_bed &lt; current_temperature_bed;</front>
<front id="temperatureH-103">};</front>
<front id="temperatureH-104"></front>
<front id="temperatureH-105">#define degHotend0() degHotend(0)</front>
<front id="temperatureH-106">#define degTargetHotend0() degTargetHotend(0)</front>
<front id="temperatureH-107">#define setTargetHotend0(_celsius) setTargetHotend((_celsius), 0)</front>
<front id="temperatureH-108">#define isHeatingHotend0() isHeatingHotend(0)</front>
<front id="temperatureH-109">#define isCoolingHotend0() isCoolingHotend(0)</front>
<front id="temperatureH-110">#if EXTRUDERS &gt; 1</front>
<front id="temperatureH-111">#define degHotend1() degHotend(1)</front>
<front id="temperatureH-112">#define degTargetHotend1() degTargetHotend(1)</front>
<front id="temperatureH-113">#define setTargetHotend1(_celsius) setTargetHotend((_celsius), 1)</front>
<front id="temperatureH-114">#define isHeatingHotend1() isHeatingHotend(1)</front>
<front id="temperatureH-115">#define isCoolingHotend1() isCoolingHotend(1)</front>
<front id="temperatureH-116">#else</front>
<front id="temperatureH-117">#define setTargetHotend1(_celsius) do{}while(0)</front>
<front id="temperatureH-118">#endif</front>
<front id="temperatureH-119">#if EXTRUDERS &gt; 2</front>
<front id="temperatureH-120">#define degHotend2() degHotend(2)</front>
<front id="temperatureH-121">#define degTargetHotend2() degTargetHotend(2)</front>
<front id="temperatureH-122">#define setTargetHotend2(_celsius) setTargetHotend((_celsius), 2)</front>
<front id="temperatureH-123">#define isHeatingHotend2() isHeatingHotend(2)</front>
<front id="temperatureH-124">#define isCoolingHotend2() isCoolingHotend(2)</front>
<front id="temperatureH-125">#else</front>
<front id="temperatureH-126">#define setTargetHotend2(_celsius) do{}while(0)</front>
<front id="temperatureH-127">#endif</front>
<front id="temperatureH-128">#if EXTRUDERS &gt; 3</front>
<front id="temperatureH-129">#error Invalid number of extruders</front>
<front id="temperatureH-130">#endif</front>
<front id="temperatureH-131"></front>
<front id="temperatureH-132"></front>
<front id="temperatureH-133"></front>
<front id="temperatureH-134">int getHeaterPower(int heater);</front>
<front id="temperatureH-135">void disable_heater();</front>
<front id="temperatureH-136">void setWatch();</front>
<front id="temperatureH-137">void updatePID();</front>
<front id="temperatureH-138"></front>
<front id="temperatureH-139">FORCE_INLINE void autotempShutdown(){</front>
<front id="temperatureH-140"> #ifdef AUTOTEMP</front>
<front id="temperatureH-141"> if(autotemp_enabled)</front>
<front id="temperatureH-142"> {</front>
<front id="temperatureH-143">  autotemp_enabled=false;</front>
<front id="temperatureH-144">  if(degTargetHotend(active_extruder)&gt;autotemp_min)</front>
<front id="temperatureH-145">    setTargetHotend(0,active_extruder);</front>
<front id="temperatureH-146"> }</front>
<front id="temperatureH-147"> #endif</front>
<front id="temperatureH-148">}</front>
<front id="temperatureH-149"></front>
<front id="temperatureH-150">void PID_autotune(float temp, int extruder, int ncycles);</front>
<front id="temperatureH-151"></front>
<front id="temperatureH-152">#endif</front>
<front id="temperatureH-153"></front>
 </pre>
<h1>thermistortables.h</h1>
<pre  class="prettyprint linenums"><front id="thermistortablesH-1">#ifndef THERMISTORTABLES_H_</front>
<front id="thermistortablesH-2">#define THERMISTORTABLES_H_</front>
<front id="thermistortablesH-3"></front>
<front id="thermistortablesH-4">#include "Marlin.h"</front>
<front id="thermistortablesH-5"></front>
<front id="thermistortablesH-6">#define OVERSAMPLENR 16</front>
<front id="thermistortablesH-7"></front>
<front id="thermistortablesH-8">#if (THERMISTORHEATER_0 == 1) || (THERMISTORHEATER_1 == 1)  || (THERMISTORHEATER_2 == 1) || (THERMISTORBED == 1) //100k bed thermistor</front>
<front id="thermistortablesH-9"></front>
<front id="thermistortablesH-10">const short temptable_1[][2] PROGMEM = {</front>
<front id="thermistortablesH-11">{       23*OVERSAMPLENR ,       300     },</front>
<front id="thermistortablesH-12">{       25*OVERSAMPLENR ,       295     },</front>
<front id="thermistortablesH-13">{       27*OVERSAMPLENR ,       290     },</front>
<front id="thermistortablesH-14">{       28*OVERSAMPLENR ,       285     },</front>
<front id="thermistortablesH-15">{       31*OVERSAMPLENR ,       280     },</front>
<front id="thermistortablesH-16">{       33*OVERSAMPLENR ,       275     },</front>
<front id="thermistortablesH-17">{       35*OVERSAMPLENR ,       270     },</front>
<front id="thermistortablesH-18">{       38*OVERSAMPLENR ,       265     },</front>
<front id="thermistortablesH-19">{       41*OVERSAMPLENR ,       260     },</front>
<front id="thermistortablesH-20">{       44*OVERSAMPLENR ,       255     },</front>
<front id="thermistortablesH-21">{       48*OVERSAMPLENR ,       250     },</front>
<front id="thermistortablesH-22">{       52*OVERSAMPLENR ,       245     },</front>
<front id="thermistortablesH-23">{       56*OVERSAMPLENR ,       240     },</front>
<front id="thermistortablesH-24">{       61*OVERSAMPLENR ,       235     },</front>
<front id="thermistortablesH-25">{       66*OVERSAMPLENR ,       230     },</front>
<front id="thermistortablesH-26">{       71*OVERSAMPLENR ,       225     },</front>
<front id="thermistortablesH-27">{       78*OVERSAMPLENR ,       220     },</front>
<front id="thermistortablesH-28">{       84*OVERSAMPLENR ,       215     },</front>
<front id="thermistortablesH-29">{       92*OVERSAMPLENR ,       210     },</front>
<front id="thermistortablesH-30">{       100*OVERSAMPLENR        ,       205     },</front>
<front id="thermistortablesH-31">{       109*OVERSAMPLENR        ,       200     },</front>
<front id="thermistortablesH-32">{       120*OVERSAMPLENR        ,       195     },</front>
<front id="thermistortablesH-33">{       131*OVERSAMPLENR        ,       190     },</front>
<front id="thermistortablesH-34">{       143*OVERSAMPLENR        ,       185     },</front>
<front id="thermistortablesH-35">{       156*OVERSAMPLENR        ,       180     },</front>
<front id="thermistortablesH-36">{       171*OVERSAMPLENR        ,       175     },</front>
<front id="thermistortablesH-37">{       187*OVERSAMPLENR        ,       170     },</front>
<front id="thermistortablesH-38">{       205*OVERSAMPLENR        ,       165     },</front>
<front id="thermistortablesH-39">{       224*OVERSAMPLENR        ,       160     },</front>
<front id="thermistortablesH-40">{       245*OVERSAMPLENR        ,       155     },</front>
<front id="thermistortablesH-41">{       268*OVERSAMPLENR        ,       150     },</front>
<front id="thermistortablesH-42">{       293*OVERSAMPLENR        ,       145     },</front>
<front id="thermistortablesH-43">{       320*OVERSAMPLENR        ,       140     },</front>
<front id="thermistortablesH-44">{       348*OVERSAMPLENR        ,       135     },</front>
<front id="thermistortablesH-45">{       379*OVERSAMPLENR        ,       130     },</front>
<front id="thermistortablesH-46">{       411*OVERSAMPLENR        ,       125     },</front>
<front id="thermistortablesH-47">{       445*OVERSAMPLENR        ,       120     },</front>
<front id="thermistortablesH-48">{       480*OVERSAMPLENR        ,       115     },</front>
<front id="thermistortablesH-49">{       516*OVERSAMPLENR        ,       110     },</front>
<front id="thermistortablesH-50">{       553*OVERSAMPLENR        ,       105     },</front>
<front id="thermistortablesH-51">{       591*OVERSAMPLENR        ,       100     },</front>
<front id="thermistortablesH-52">{       628*OVERSAMPLENR        ,       95      },</front>
<front id="thermistortablesH-53">{       665*OVERSAMPLENR        ,       90      },</front>
<front id="thermistortablesH-54">{       702*OVERSAMPLENR        ,       85      },</front>
<front id="thermistortablesH-55">{       737*OVERSAMPLENR        ,       80      },</front>
<front id="thermistortablesH-56">{       770*OVERSAMPLENR        ,       75      },</front>
<front id="thermistortablesH-57">{       801*OVERSAMPLENR        ,       70      },</front>
<front id="thermistortablesH-58">{       830*OVERSAMPLENR        ,       65      },</front>
<front id="thermistortablesH-59">{       857*OVERSAMPLENR        ,       60      },</front>
<front id="thermistortablesH-60">{       881*OVERSAMPLENR        ,       55      },</front>
<front id="thermistortablesH-61">{       903*OVERSAMPLENR        ,       50      },</front>
<front id="thermistortablesH-62">{       922*OVERSAMPLENR        ,       45      },</front>
<front id="thermistortablesH-63">{       939*OVERSAMPLENR        ,       40      },</front>
<front id="thermistortablesH-64">{       954*OVERSAMPLENR        ,       35      },</front>
<front id="thermistortablesH-65">{       966*OVERSAMPLENR        ,       30      },</front>
<front id="thermistortablesH-66">{       977*OVERSAMPLENR        ,       25      },</front>
<front id="thermistortablesH-67">{       985*OVERSAMPLENR        ,       20      },</front>
<front id="thermistortablesH-68">{       993*OVERSAMPLENR        ,       15      },</front>
<front id="thermistortablesH-69">{       999*OVERSAMPLENR        ,       10      },</front>
<front id="thermistortablesH-70">{       1004*OVERSAMPLENR       ,       5       },</front>
<front id="thermistortablesH-71">{       1008*OVERSAMPLENR       ,       0       } //safety</front>
<front id="thermistortablesH-72">};</front>
<front id="thermistortablesH-73">#endif</front>
<front id="thermistortablesH-74">#if (THERMISTORHEATER_0 == 2) || (THERMISTORHEATER_1 == 2) || (THERMISTORHEATER_2 == 2) || (THERMISTORBED == 2) //200k bed thermistor</front>
<front id="thermistortablesH-75">const short temptable_2[][2] PROGMEM = {</front>
<front id="thermistortablesH-76">//200k ATC Semitec 204GT-2</front>
<front id="thermistortablesH-77">//Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-78">// Calculated using 4.7kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-79">   {1*OVERSAMPLENR, 848},</front>
<front id="thermistortablesH-80">   {30*OVERSAMPLENR, 300}, //top rating 300C</front>
<front id="thermistortablesH-81">   {34*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-82">   {39*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-83">   {46*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-84">   {53*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-85">   {63*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-86">   {74*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-87">   {87*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-88">   {104*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-89">   {124*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-90">   {148*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-91">   {176*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-92">   {211*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-93">   {252*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-94">   {301*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-95">   {357*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-96">   {420*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-97">   {489*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-98">   {562*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-99">   {636*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-100">   {708*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-101">   {775*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-102">   {835*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-103">   {884*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-104">   {924*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-105">   {955*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-106">   {977*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-107">   {993*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-108">   {1004*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-109">   {1012*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-110">   {1016*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-111">};</front>
<front id="thermistortablesH-112"></front>
<front id="thermistortablesH-113">#endif</front>
<front id="thermistortablesH-114">#if (THERMISTORHEATER_0 == 3) || (THERMISTORHEATER_1 == 3) || (THERMISTORHEATER_2 == 3) || (THERMISTORBED == 3) //mendel-parts</front>
<front id="thermistortablesH-115">const short temptable_3[][2] PROGMEM = {</front>
<front id="thermistortablesH-116">                {1*OVERSAMPLENR,864},</front>
<front id="thermistortablesH-117">                {21*OVERSAMPLENR,300},</front>
<front id="thermistortablesH-118">                {25*OVERSAMPLENR,290},</front>
<front id="thermistortablesH-119">                {29*OVERSAMPLENR,280},</front>
<front id="thermistortablesH-120">                {33*OVERSAMPLENR,270},</front>
<front id="thermistortablesH-121">                {39*OVERSAMPLENR,260},</front>
<front id="thermistortablesH-122">                {46*OVERSAMPLENR,250},</front>
<front id="thermistortablesH-123">                {54*OVERSAMPLENR,240},</front>
<front id="thermistortablesH-124">                {64*OVERSAMPLENR,230},</front>
<front id="thermistortablesH-125">                {75*OVERSAMPLENR,220},</front>
<front id="thermistortablesH-126">                {90*OVERSAMPLENR,210},</front>
<front id="thermistortablesH-127">                {107*OVERSAMPLENR,200},</front>
<front id="thermistortablesH-128">                {128*OVERSAMPLENR,190},</front>
<front id="thermistortablesH-129">                {154*OVERSAMPLENR,180},</front>
<front id="thermistortablesH-130">                {184*OVERSAMPLENR,170},</front>
<front id="thermistortablesH-131">                {221*OVERSAMPLENR,160},</front>
<front id="thermistortablesH-132">                {265*OVERSAMPLENR,150},</front>
<front id="thermistortablesH-133">                {316*OVERSAMPLENR,140},</front>
<front id="thermistortablesH-134">                {375*OVERSAMPLENR,130},</front>
<front id="thermistortablesH-135">                {441*OVERSAMPLENR,120},</front>
<front id="thermistortablesH-136">                {513*OVERSAMPLENR,110},</front>
<front id="thermistortablesH-137">                {588*OVERSAMPLENR,100},</front>
<front id="thermistortablesH-138">                {734*OVERSAMPLENR,80},</front>
<front id="thermistortablesH-139">                {856*OVERSAMPLENR,60},</front>
<front id="thermistortablesH-140">                {938*OVERSAMPLENR,40},</front>
<front id="thermistortablesH-141">                {986*OVERSAMPLENR,20},</front>
<front id="thermistortablesH-142">                {1008*OVERSAMPLENR,0},</front>
<front id="thermistortablesH-143">                {1018*OVERSAMPLENR,-20}</front>
<front id="thermistortablesH-144">        };</front>
<front id="thermistortablesH-145"></front>
<front id="thermistortablesH-146">#endif</front>
<front id="thermistortablesH-147">#if (THERMISTORHEATER_0 == 4) || (THERMISTORHEATER_1 == 4) || (THERMISTORHEATER_2 == 4) || (THERMISTORBED == 4) //10k thermistor</front>
<front id="thermistortablesH-148">const short temptable_4[][2] PROGMEM = {</front>
<front id="thermistortablesH-149">   {1*OVERSAMPLENR, 430},</front>
<front id="thermistortablesH-150">   {54*OVERSAMPLENR, 137},</front>
<front id="thermistortablesH-151">   {107*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-152">   {160*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-153">   {213*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-154">   {266*OVERSAMPLENR, 71},</front>
<front id="thermistortablesH-155">   {319*OVERSAMPLENR, 64},</front>
<front id="thermistortablesH-156">   {372*OVERSAMPLENR, 57},</front>
<front id="thermistortablesH-157">   {425*OVERSAMPLENR, 51},</front>
<front id="thermistortablesH-158">   {478*OVERSAMPLENR, 46},</front>
<front id="thermistortablesH-159">   {531*OVERSAMPLENR, 41},</front>
<front id="thermistortablesH-160">   {584*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-161">   {637*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-162">   {690*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-163">   {743*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-164">   {796*OVERSAMPLENR, 14},</front>
<front id="thermistortablesH-165">   {849*OVERSAMPLENR, 7},</front>
<front id="thermistortablesH-166">   {902*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-167">   {955*OVERSAMPLENR, -11},</front>
<front id="thermistortablesH-168">   {1008*OVERSAMPLENR, -35}</front>
<front id="thermistortablesH-169">};</front>
<front id="thermistortablesH-170">#endif</front>
<front id="thermistortablesH-171"></front>
<front id="thermistortablesH-172">#if (THERMISTORHEATER_0 == 5) || (THERMISTORHEATER_1 == 5) || (THERMISTORHEATER_2 == 5) || (THERMISTORBED == 5) //100k ParCan thermistor (104GT-2)</front>
<front id="thermistortablesH-173">const short temptable_5[][2] PROGMEM = {</front>
<front id="thermistortablesH-174">// ATC Semitec 104GT-2 (Used in ParCan)</front>
<front id="thermistortablesH-175">// Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-176">// Calculated using 4.7kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-177">   {1*OVERSAMPLENR, 713},</front>
<front id="thermistortablesH-178">   {17*OVERSAMPLENR, 300}, //top rating 300C</front>
<front id="thermistortablesH-179">   {20*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-180">   {23*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-181">   {27*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-182">   {31*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-183">   {37*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-184">   {43*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-185">   {51*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-186">   {61*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-187">   {73*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-188">   {87*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-189">   {106*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-190">   {128*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-191">   {155*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-192">   {189*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-193">   {230*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-194">   {278*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-195">   {336*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-196">   {402*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-197">   {476*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-198">   {554*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-199">   {635*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-200">   {713*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-201">   {784*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-202">   {846*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-203">   {897*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-204">   {937*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-205">   {966*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-206">   {986*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-207">   {1000*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-208">   {1010*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-209">};</front>
<front id="thermistortablesH-210">#endif</front>
<front id="thermistortablesH-211"></front>
<front id="thermistortablesH-212">#if (THERMISTORHEATER_0 == 6) || (THERMISTORHEATER_1 == 6) || (THERMISTORHEATER_2 == 6) || (THERMISTORBED == 6) // 100k Epcos thermistor</front>
<front id="thermistortablesH-213">const short temptable_6[][2] PROGMEM = {</front>
<front id="thermistortablesH-214">   {1*OVERSAMPLENR, 350},</front>
<front id="thermistortablesH-215">   {28*OVERSAMPLENR, 250}, //top rating 250C</front>
<front id="thermistortablesH-216">   {31*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-217">   {35*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-218">   {39*OVERSAMPLENR, 235},</front>
<front id="thermistortablesH-219">   {42*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-220">   {44*OVERSAMPLENR, 225},</front>
<front id="thermistortablesH-221">   {49*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-222">   {53*OVERSAMPLENR, 215},</front>
<front id="thermistortablesH-223">   {62*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-224">   {71*OVERSAMPLENR, 205}, //fitted graphically</front>
<front id="thermistortablesH-225">   {78*OVERSAMPLENR, 200}, //fitted graphically</front>
<front id="thermistortablesH-226">   {94*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-227">   {102*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-228">   {116*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-229">   {143*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-230">   {183*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-231">   {223*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-232">   {270*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-233">   {318*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-234">   {383*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-235">   {413*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-236">   {439*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-237">   {484*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-238">   {513*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-239">   {607*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-240">   {664*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-241">   {781*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-242">   {810*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-243">   {849*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-244">   {914*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-245">   {914*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-246">   {935*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-247">   {954*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-248">   {970*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-249">   {978*OVERSAMPLENR, 22},</front>
<front id="thermistortablesH-250">   {1008*OVERSAMPLENR, 3},</front>
<front id="thermistortablesH-251">   {1023*OVERSAMPLENR, 0}  //to allow internal 0 degrees C</front>
<front id="thermistortablesH-252">};</front>
<front id="thermistortablesH-253">#endif</front>
<front id="thermistortablesH-254"></front>
<front id="thermistortablesH-255">#if (THERMISTORHEATER_0 == 7) || (THERMISTORHEATER_1 == 7) || (THERMISTORHEATER_2 == 7) || (THERMISTORBED == 7) // 100k Honeywell 135-104LAG-J01</front>
<front id="thermistortablesH-256">const short temptable_7[][2] PROGMEM = {</front>
<front id="thermistortablesH-257">   {1*OVERSAMPLENR, 941},</front>
<front id="thermistortablesH-258">   {19*OVERSAMPLENR, 362},</front>
<front id="thermistortablesH-259">   {37*OVERSAMPLENR, 299}, //top rating 300C</front>
<front id="thermistortablesH-260">   {55*OVERSAMPLENR, 266},</front>
<front id="thermistortablesH-261">   {73*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-262">   {91*OVERSAMPLENR, 229},</front>
<front id="thermistortablesH-263">   {109*OVERSAMPLENR, 216},</front>
<front id="thermistortablesH-264">   {127*OVERSAMPLENR, 206},</front>
<front id="thermistortablesH-265">   {145*OVERSAMPLENR, 197},</front>
<front id="thermistortablesH-266">   {163*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-267">   {181*OVERSAMPLENR, 183},</front>
<front id="thermistortablesH-268">   {199*OVERSAMPLENR, 177},</front>
<front id="thermistortablesH-269">   {217*OVERSAMPLENR, 171},</front>
<front id="thermistortablesH-270">   {235*OVERSAMPLENR, 166},</front>
<front id="thermistortablesH-271">   {253*OVERSAMPLENR, 162},</front>
<front id="thermistortablesH-272">   {271*OVERSAMPLENR, 157},</front>
<front id="thermistortablesH-273">   {289*OVERSAMPLENR, 153},</front>
<front id="thermistortablesH-274">   {307*OVERSAMPLENR, 149},</front>
<front id="thermistortablesH-275">   {325*OVERSAMPLENR, 146},</front>
<front id="thermistortablesH-276">   {343*OVERSAMPLENR, 142},</front>
<front id="thermistortablesH-277">   {361*OVERSAMPLENR, 139},</front>
<front id="thermistortablesH-278">   {379*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-279">   {397*OVERSAMPLENR, 132},</front>
<front id="thermistortablesH-280">   {415*OVERSAMPLENR, 129},</front>
<front id="thermistortablesH-281">   {433*OVERSAMPLENR, 126},</front>
<front id="thermistortablesH-282">   {451*OVERSAMPLENR, 123},</front>
<front id="thermistortablesH-283">   {469*OVERSAMPLENR, 121},</front>
<front id="thermistortablesH-284">   {487*OVERSAMPLENR, 118},</front>
<front id="thermistortablesH-285">   {505*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-286">   {523*OVERSAMPLENR, 112},</front>
<front id="thermistortablesH-287">   {541*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-288">   {559*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-289">   {577*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-290">   {595*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-291">   {613*OVERSAMPLENR, 99},</front>
<front id="thermistortablesH-292">   {631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-293">   {649*OVERSAMPLENR, 94},</front>
<front id="thermistortablesH-294">   {667*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-295">   {685*OVERSAMPLENR, 89},</front>
<front id="thermistortablesH-296">   {703*OVERSAMPLENR, 86},</front>
<front id="thermistortablesH-297">   {721*OVERSAMPLENR, 84},</front>
<front id="thermistortablesH-298">   {739*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-299">   {757*OVERSAMPLENR, 78},</front>
<front id="thermistortablesH-300">   {775*OVERSAMPLENR, 75},</front>
<front id="thermistortablesH-301">   {793*OVERSAMPLENR, 72},</front>
<front id="thermistortablesH-302">   {811*OVERSAMPLENR, 69},</front>
<front id="thermistortablesH-303">   {829*OVERSAMPLENR, 66},</front>
<front id="thermistortablesH-304">   {847*OVERSAMPLENR, 62},</front>
<front id="thermistortablesH-305">   {865*OVERSAMPLENR, 59},</front>
<front id="thermistortablesH-306">   {883*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-307">   {901*OVERSAMPLENR, 51},</front>
<front id="thermistortablesH-308">   {919*OVERSAMPLENR, 46},</front>
<front id="thermistortablesH-309">   {937*OVERSAMPLENR, 41},</front>
<front id="thermistortablesH-310">   {955*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-311">   {973*OVERSAMPLENR, 27},</front>
<front id="thermistortablesH-312">   {991*OVERSAMPLENR, 17},</front>
<front id="thermistortablesH-313">   {1009*OVERSAMPLENR, 1},</front>
<front id="thermistortablesH-314">   {1023*OVERSAMPLENR, 0}  //to allow internal 0 degrees C</front>
<front id="thermistortablesH-315">};</front>
<front id="thermistortablesH-316">#endif</front>
<front id="thermistortablesH-317"></front>
<front id="thermistortablesH-318">#if (THERMISTORHEATER_0 == 71) || (THERMISTORHEATER_1 == 71) || (THERMISTORHEATER_2 == 71) || (THERMISTORBED == 71) // 100k Honeywell 135-104LAF-J01</front>
<front id="thermistortablesH-319">// R0 = 100000 Ohm</front>
<front id="thermistortablesH-320">// T0 = 25 C</front>
<front id="thermistortablesH-321">// Beta = 3974</front>
<front id="thermistortablesH-322">// R1 = 0 Ohm</front>
<front id="thermistortablesH-323">// R2 = 4700 Ohm</front>
<front id="thermistortablesH-324">const short temptable_71[][2] PROGMEM = {</front>
<front id="thermistortablesH-325">   {35*OVERSAMPLENR, 300},</front>
<front id="thermistortablesH-326">   {51*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-327">   {54*OVERSAMPLENR, 265},</front>
<front id="thermistortablesH-328">   {58*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-329">   {59*OVERSAMPLENR, 258},</front>
<front id="thermistortablesH-330">   {61*OVERSAMPLENR, 256},</front>
<front id="thermistortablesH-331">   {63*OVERSAMPLENR, 254},</front>
<front id="thermistortablesH-332">   {64*OVERSAMPLENR, 252},</front>
<front id="thermistortablesH-333">   {66*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-334">   {67*OVERSAMPLENR, 249},</front>
<front id="thermistortablesH-335">   {68*OVERSAMPLENR, 248},</front>
<front id="thermistortablesH-336">   {69*OVERSAMPLENR, 247},</front>
<front id="thermistortablesH-337">   {70*OVERSAMPLENR, 246},</front>
<front id="thermistortablesH-338">   {71*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-339">   {72*OVERSAMPLENR, 244},</front>
<front id="thermistortablesH-340">   {73*OVERSAMPLENR, 243},</front>
<front id="thermistortablesH-341">   {74*OVERSAMPLENR, 242},</front>
<front id="thermistortablesH-342">   {75*OVERSAMPLENR, 241},</front>
<front id="thermistortablesH-343">   {76*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-344">   {77*OVERSAMPLENR, 239},</front>
<front id="thermistortablesH-345">   {78*OVERSAMPLENR, 238},</front>
<front id="thermistortablesH-346">   {79*OVERSAMPLENR, 237},</front>
<front id="thermistortablesH-347">   {80*OVERSAMPLENR, 236},</front>
<front id="thermistortablesH-348">   {81*OVERSAMPLENR, 235},</front>
<front id="thermistortablesH-349">   {82*OVERSAMPLENR, 234},</front>
<front id="thermistortablesH-350">   {84*OVERSAMPLENR, 233},</front>
<front id="thermistortablesH-351">   {85*OVERSAMPLENR, 232},</front>
<front id="thermistortablesH-352">   {86*OVERSAMPLENR, 231},</front>
<front id="thermistortablesH-353">   {87*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-354">   {89*OVERSAMPLENR, 229},</front>
<front id="thermistortablesH-355">   {90*OVERSAMPLENR, 228},</front>
<front id="thermistortablesH-356">   {91*OVERSAMPLENR, 227},</front>
<front id="thermistortablesH-357">   {92*OVERSAMPLENR, 226},</front>
<front id="thermistortablesH-358">   {94*OVERSAMPLENR, 225},</front>
<front id="thermistortablesH-359">   {95*OVERSAMPLENR, 224},</front>
<front id="thermistortablesH-360">   {97*OVERSAMPLENR, 223},</front>
<front id="thermistortablesH-361">   {98*OVERSAMPLENR, 222},</front>
<front id="thermistortablesH-362">   {99*OVERSAMPLENR, 221},</front>
<front id="thermistortablesH-363">   {101*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-364">   {102*OVERSAMPLENR, 219},</front>
<front id="thermistortablesH-365">   {104*OVERSAMPLENR, 218},</front>
<front id="thermistortablesH-366">   {106*OVERSAMPLENR, 217},</front>
<front id="thermistortablesH-367">   {107*OVERSAMPLENR, 216},</front>
<front id="thermistortablesH-368">   {109*OVERSAMPLENR, 215},</front>
<front id="thermistortablesH-369">   {110*OVERSAMPLENR, 214},</front>
<front id="thermistortablesH-370">   {112*OVERSAMPLENR, 213},</front>
<front id="thermistortablesH-371">   {114*OVERSAMPLENR, 212},</front>
<front id="thermistortablesH-372">   {115*OVERSAMPLENR, 211},</front>
<front id="thermistortablesH-373">   {117*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-374">   {119*OVERSAMPLENR, 209},</front>
<front id="thermistortablesH-375">   {121*OVERSAMPLENR, 208},</front>
<front id="thermistortablesH-376">   {123*OVERSAMPLENR, 207},</front>
<front id="thermistortablesH-377">   {125*OVERSAMPLENR, 206},</front>
<front id="thermistortablesH-378">   {126*OVERSAMPLENR, 205},</front>
<front id="thermistortablesH-379">   {128*OVERSAMPLENR, 204},</front>
<front id="thermistortablesH-380">   {130*OVERSAMPLENR, 203},</front>
<front id="thermistortablesH-381">   {132*OVERSAMPLENR, 202},</front>
<front id="thermistortablesH-382">   {134*OVERSAMPLENR, 201},</front>
<front id="thermistortablesH-383">   {136*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-384">   {139*OVERSAMPLENR, 199},</front>
<front id="thermistortablesH-385">   {141*OVERSAMPLENR, 198},</front>
<front id="thermistortablesH-386">   {143*OVERSAMPLENR, 197},</front>
<front id="thermistortablesH-387">   {145*OVERSAMPLENR, 196},</front>
<front id="thermistortablesH-388">   {147*OVERSAMPLENR, 195},</front>
<front id="thermistortablesH-389">   {150*OVERSAMPLENR, 194},</front>
<front id="thermistortablesH-390">   {152*OVERSAMPLENR, 193},</front>
<front id="thermistortablesH-391">   {154*OVERSAMPLENR, 192},</front>
<front id="thermistortablesH-392">   {157*OVERSAMPLENR, 191},</front>
<front id="thermistortablesH-393">   {159*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-394">   {162*OVERSAMPLENR, 189},</front>
<front id="thermistortablesH-395">   {164*OVERSAMPLENR, 188},</front>
<front id="thermistortablesH-396">   {167*OVERSAMPLENR, 187},</front>
<front id="thermistortablesH-397">   {170*OVERSAMPLENR, 186},</front>
<front id="thermistortablesH-398">   {172*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-399">   {175*OVERSAMPLENR, 184},</front>
<front id="thermistortablesH-400">   {178*OVERSAMPLENR, 183},</front>
<front id="thermistortablesH-401">   {181*OVERSAMPLENR, 182},</front>
<front id="thermistortablesH-402">   {184*OVERSAMPLENR, 181},</front>
<front id="thermistortablesH-403">   {187*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-404">   {190*OVERSAMPLENR, 179},</front>
<front id="thermistortablesH-405">   {193*OVERSAMPLENR, 178},</front>
<front id="thermistortablesH-406">   {196*OVERSAMPLENR, 177},</front>
<front id="thermistortablesH-407">   {199*OVERSAMPLENR, 176},</front>
<front id="thermistortablesH-408">   {202*OVERSAMPLENR, 175},</front>
<front id="thermistortablesH-409">   {205*OVERSAMPLENR, 174},</front>
<front id="thermistortablesH-410">   {208*OVERSAMPLENR, 173},</front>
<front id="thermistortablesH-411">   {212*OVERSAMPLENR, 172},</front>
<front id="thermistortablesH-412">   {215*OVERSAMPLENR, 171},</front>
<front id="thermistortablesH-413">   {219*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-414">   {237*OVERSAMPLENR, 165},</front>
<front id="thermistortablesH-415">   {256*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-416">   {300*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-417">   {351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-418">   {470*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-419">   {504*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-420">   {538*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-421">   {552*OVERSAMPLENR, 108},</front>
<front id="thermistortablesH-422">   {566*OVERSAMPLENR, 106},</front>
<front id="thermistortablesH-423">   {580*OVERSAMPLENR, 104},</front>
<front id="thermistortablesH-424">   {594*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-425">   {608*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-426">   {622*OVERSAMPLENR, 98},</front>
<front id="thermistortablesH-427">   {636*OVERSAMPLENR, 96},</front>
<front id="thermistortablesH-428">   {650*OVERSAMPLENR, 94},</front>
<front id="thermistortablesH-429">   {664*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-430">   {678*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-431">   {712*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-432">   {745*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-433">   {758*OVERSAMPLENR, 78},</front>
<front id="thermistortablesH-434">   {770*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-435">   {783*OVERSAMPLENR, 74},</front>
<front id="thermistortablesH-436">   {795*OVERSAMPLENR, 72},</front>
<front id="thermistortablesH-437">   {806*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-438">   {818*OVERSAMPLENR, 68},</front>
<front id="thermistortablesH-439">   {829*OVERSAMPLENR, 66},</front>
<front id="thermistortablesH-440">   {840*OVERSAMPLENR, 64},</front>
<front id="thermistortablesH-441">   {850*OVERSAMPLENR, 62},</front>
<front id="thermistortablesH-442">   {860*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-443">   {870*OVERSAMPLENR, 58},</front>
<front id="thermistortablesH-444">   {879*OVERSAMPLENR, 56},</front>
<front id="thermistortablesH-445">   {888*OVERSAMPLENR, 54},</front>
<front id="thermistortablesH-446">   {897*OVERSAMPLENR, 52},</front>
<front id="thermistortablesH-447">   {905*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-448">   {924*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-449">   {940*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-450">   {955*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-451">   {967*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-452">   {970*OVERSAMPLENR, 29},</front>
<front id="thermistortablesH-453">   {972*OVERSAMPLENR, 28},</front>
<front id="thermistortablesH-454">   {974*OVERSAMPLENR, 27},</front>
<front id="thermistortablesH-455">   {976*OVERSAMPLENR, 26},</front>
<front id="thermistortablesH-456">   {978*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-457">   {980*OVERSAMPLENR, 24},</front>
<front id="thermistortablesH-458">   {982*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-459">   {984*OVERSAMPLENR, 22},</front>
<front id="thermistortablesH-460">   {985*OVERSAMPLENR, 21},</front>
<front id="thermistortablesH-461">   {987*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-462">   {995*OVERSAMPLENR, 15},</front>
<front id="thermistortablesH-463">   {1001*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-464">   {1006*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-465">   {1010*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-466">};</front>
<front id="thermistortablesH-467">#endif</front>
<front id="thermistortablesH-468"></front>
<front id="thermistortablesH-469">#if (THERMISTORHEATER_0 == 8) || (THERMISTORHEATER_1 == 8) || (THERMISTORHEATER_2 == 8) || (THERMISTORBED == 8)</front>
<front id="thermistortablesH-470">// 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)</front>
<front id="thermistortablesH-471">const short temptable_8[][2] PROGMEM = {</front>
<front id="thermistortablesH-472">   {1*OVERSAMPLENR, 704},</front>
<front id="thermistortablesH-473">   {54*OVERSAMPLENR, 216},</front>
<front id="thermistortablesH-474">   {107*OVERSAMPLENR, 175},</front>
<front id="thermistortablesH-475">   {160*OVERSAMPLENR, 152},</front>
<front id="thermistortablesH-476">   {213*OVERSAMPLENR, 137},</front>
<front id="thermistortablesH-477">   {266*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-478">   {319*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-479">   {372*OVERSAMPLENR, 106},</front>
<front id="thermistortablesH-480">   {425*OVERSAMPLENR, 99},</front>
<front id="thermistortablesH-481">   {478*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-482">   {531*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-483">   {584*OVERSAMPLENR, 78},</front>
<front id="thermistortablesH-484">   {637*OVERSAMPLENR, 71},</front>
<front id="thermistortablesH-485">   {690*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-486">   {743*OVERSAMPLENR, 58},</front>
<front id="thermistortablesH-487">   {796*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-488">   {849*OVERSAMPLENR, 42},</front>
<front id="thermistortablesH-489">   {902*OVERSAMPLENR, 31},</front>
<front id="thermistortablesH-490">   {955*OVERSAMPLENR, 17},</front>
<front id="thermistortablesH-491">   {1008*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-492">};</front>
<front id="thermistortablesH-493">#endif</front>
<front id="thermistortablesH-494">#if (THERMISTORHEATER_0 == 9) || (THERMISTORHEATER_1 == 9) || (THERMISTORHEATER_2 == 9) || (THERMISTORBED == 9)</front>
<front id="thermistortablesH-495">// 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)</front>
<front id="thermistortablesH-496">const short temptable_9[][2] PROGMEM = {</front>
<front id="thermistortablesH-497">	{1*OVERSAMPLENR, 936},</front>
<front id="thermistortablesH-498">	{36*OVERSAMPLENR, 300},</front>
<front id="thermistortablesH-499">	{71*OVERSAMPLENR, 246},</front>
<front id="thermistortablesH-500">	{106*OVERSAMPLENR, 218},</front>
<front id="thermistortablesH-501">	{141*OVERSAMPLENR, 199},</front>
<front id="thermistortablesH-502">	{176*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-503">	{211*OVERSAMPLENR, 173},</front>
<front id="thermistortablesH-504">	{246*OVERSAMPLENR, 163},</front>
<front id="thermistortablesH-505">	{281*OVERSAMPLENR, 155},</front>
<front id="thermistortablesH-506">	{316*OVERSAMPLENR, 147},</front>
<front id="thermistortablesH-507">	{351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-508">	{386*OVERSAMPLENR, 134},</front>
<front id="thermistortablesH-509">	{421*OVERSAMPLENR, 128},</front>
<front id="thermistortablesH-510">	{456*OVERSAMPLENR, 122},</front>
<front id="thermistortablesH-511">	{491*OVERSAMPLENR, 117},</front>
<front id="thermistortablesH-512">	{526*OVERSAMPLENR, 112},</front>
<front id="thermistortablesH-513">	{561*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-514">	{596*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-515">	{631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-516">	{666*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-517">	{701*OVERSAMPLENR, 87},</front>
<front id="thermistortablesH-518">	{736*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-519">	{771*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-520">	{806*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-521">	{841*OVERSAMPLENR, 63},</front>
<front id="thermistortablesH-522">	{876*OVERSAMPLENR, 56},</front>
<front id="thermistortablesH-523">	{911*OVERSAMPLENR, 48},</front>
<front id="thermistortablesH-524">	{946*OVERSAMPLENR, 38},</front>
<front id="thermistortablesH-525">	{981*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-526">	{1005*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-527">	{1016*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-528">};</front>
<front id="thermistortablesH-529">#endif</front>
<front id="thermistortablesH-530">#if (THERMISTORHEATER_0 == 10) || (THERMISTORHEATER_1 == 10) || (THERMISTORHEATER_2 == 10) || (THERMISTORBED == 10)</front>
<front id="thermistortablesH-531">// 100k RS thermistor 198-961 (4.7k pullup)</front>
<front id="thermistortablesH-532">const short temptable_10[][2] PROGMEM = {</front>
<front id="thermistortablesH-533">   {1*OVERSAMPLENR, 929},</front>
<front id="thermistortablesH-534">   {36*OVERSAMPLENR, 299},</front>
<front id="thermistortablesH-535">   {71*OVERSAMPLENR, 246},</front>
<front id="thermistortablesH-536">   {106*OVERSAMPLENR, 217},</front>
<front id="thermistortablesH-537">   {141*OVERSAMPLENR, 198},</front>
<front id="thermistortablesH-538">   {176*OVERSAMPLENR, 184},</front>
<front id="thermistortablesH-539">   {211*OVERSAMPLENR, 173},</front>
<front id="thermistortablesH-540">   {246*OVERSAMPLENR, 163},</front>
<front id="thermistortablesH-541">   {281*OVERSAMPLENR, 154},</front>
<front id="thermistortablesH-542">   {316*OVERSAMPLENR, 147},</front>
<front id="thermistortablesH-543">   {351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-544">   {386*OVERSAMPLENR, 134},</front>
<front id="thermistortablesH-545">   {421*OVERSAMPLENR, 128},</front>
<front id="thermistortablesH-546">   {456*OVERSAMPLENR, 122},</front>
<front id="thermistortablesH-547">   {491*OVERSAMPLENR, 117},</front>
<front id="thermistortablesH-548">   {526*OVERSAMPLENR, 112},</front>
<front id="thermistortablesH-549">   {561*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-550">   {596*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-551">   {631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-552">   {666*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-553">   {701*OVERSAMPLENR, 86},</front>
<front id="thermistortablesH-554">   {736*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-555">   {771*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-556">   {806*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-557">   {841*OVERSAMPLENR, 63},</front>
<front id="thermistortablesH-558">   {876*OVERSAMPLENR, 56},</front>
<front id="thermistortablesH-559">   {911*OVERSAMPLENR, 48},</front>
<front id="thermistortablesH-560">   {946*OVERSAMPLENR, 38},</front>
<front id="thermistortablesH-561">   {981*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-562">   {1005*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-563">   {1016*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-564">};</front>
<front id="thermistortablesH-565">#endif</front>
<front id="thermistortablesH-566"></front>
<front id="thermistortablesH-567">#if (THERMISTORHEATER_0 == 51) || (THERMISTORHEATER_1 == 51) || (THERMISTORHEATER_2 == 51) || (THERMISTORBED == 51)</front>
<front id="thermistortablesH-568">// 100k EPCOS (WITH 1kohm RESISTOR FOR PULLUP, R9 ON SANGUINOLOLU! NOT FOR 4.7kohm PULLUP! THIS IS NOT NORMAL!)</front>
<front id="thermistortablesH-569">// Verified by linagee.</front>
<front id="thermistortablesH-570">// Calculated using 1kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-571">// Advantage: Twice the resolution and better linearity from 150C to 200C</front>
<front id="thermistortablesH-572">const short temptable_51[][2] PROGMEM = {</front>
<front id="thermistortablesH-573">   {1*OVERSAMPLENR, 350},</front>
<front id="thermistortablesH-574">   {190*OVERSAMPLENR, 250}, //top rating 250C</front>
<front id="thermistortablesH-575">   {203*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-576">   {217*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-577">   {232*OVERSAMPLENR, 235},</front>
<front id="thermistortablesH-578">   {248*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-579">   {265*OVERSAMPLENR, 225},</front>
<front id="thermistortablesH-580">   {283*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-581">   {302*OVERSAMPLENR, 215},</front>
<front id="thermistortablesH-582">   {322*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-583">   {344*OVERSAMPLENR, 205},</front>
<front id="thermistortablesH-584">   {366*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-585">   {390*OVERSAMPLENR, 195},</front>
<front id="thermistortablesH-586">   {415*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-587">   {440*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-588">   {467*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-589">   {494*OVERSAMPLENR, 175},</front>
<front id="thermistortablesH-590">   {522*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-591">   {551*OVERSAMPLENR, 165},</front>
<front id="thermistortablesH-592">   {580*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-593">   {609*OVERSAMPLENR, 155},</front>
<front id="thermistortablesH-594">   {638*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-595">   {666*OVERSAMPLENR, 145},</front>
<front id="thermistortablesH-596">   {695*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-597">   {722*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-598">   {749*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-599">   {775*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-600">   {800*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-601">   {823*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-602">   {845*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-603">   {865*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-604">   {884*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-605">   {901*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-606">   {917*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-607">   {932*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-608">   {944*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-609">   {956*OVERSAMPLENR, 75},</front>
<front id="thermistortablesH-610">   {966*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-611">   {975*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-612">   {982*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-613">   {989*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-614">   {995*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-615">   {1000*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-616">   {1004*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-617">   {1007*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-618">   {1010*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-619">   {1013*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-620">   {1015*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-621">   {1017*OVERSAMPLENR, 15},</front>
<front id="thermistortablesH-622">   {1018*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-623">   {1019*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-624">   {1020*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-625">   {1021*OVERSAMPLENR, -5}</front>
<front id="thermistortablesH-626">};</front>
<front id="thermistortablesH-627">#endif</front>
<front id="thermistortablesH-628"></front>
<front id="thermistortablesH-629">#if (THERMISTORHEATER_0 == 52) || (THERMISTORHEATER_1 == 52) || (THERMISTORHEATER_2 == 52) || (THERMISTORBED == 52) </front>
<front id="thermistortablesH-630">// 200k ATC Semitec 204GT-2 (WITH 1kohm RESISTOR FOR PULLUP, R9 ON SANGUINOLOLU! NOT FOR 4.7kohm PULLUP! THIS IS NOT NORMAL!)</front>
<front id="thermistortablesH-631">// Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-632">// Calculated using 1kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-633">// Advantage: More resolution and better linearity from 150C to 200C</front>
<front id="thermistortablesH-634">const short temptable_52[][2] PROGMEM = {</front>
<front id="thermistortablesH-635">   {1*OVERSAMPLENR, 500},</front>
<front id="thermistortablesH-636">   {125*OVERSAMPLENR, 300}, //top rating 300C</front>
<front id="thermistortablesH-637">   {142*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-638">   {162*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-639">   {185*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-640">   {211*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-641">   {240*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-642">   {274*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-643">   {312*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-644">   {355*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-645">   {401*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-646">   {452*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-647">   {506*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-648">   {563*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-649">   {620*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-650">   {677*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-651">   {732*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-652">   {783*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-653">   {830*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-654">   {871*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-655">   {906*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-656">   {935*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-657">   {958*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-658">   {976*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-659">   {990*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-660">   {1000*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-661">   {1008*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-662">   {1013*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-663">   {1017*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-664">   {1019*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-665">   {1021*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-666">   {1022*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-667">};</front>
<front id="thermistortablesH-668">#endif</front>
<front id="thermistortablesH-669"></front>
<front id="thermistortablesH-670">#if (THERMISTORHEATER_0 == 55) || (THERMISTORHEATER_1 == 55) || (THERMISTORHEATER_2 == 55) || (THERMISTORBED == 55) </front>
<front id="thermistortablesH-671">// 100k ATC Semitec 104GT-2 (Used on ParCan) (WITH 1kohm RESISTOR FOR PULLUP, R9 ON SANGUINOLOLU! NOT FOR 4.7kohm PULLUP! THIS IS NOT NORMAL!)</front>
<front id="thermistortablesH-672">// Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-673">// Calculated using 1kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-674">// Advantage: More resolution and better linearity from 150C to 200C</front>
<front id="thermistortablesH-675">const short temptable_55[][2] PROGMEM = {</front>
<front id="thermistortablesH-676">   {1*OVERSAMPLENR, 500},</front>
<front id="thermistortablesH-677">   {76*OVERSAMPLENR, 300},</front>
<front id="thermistortablesH-678">   {87*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-679">   {100*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-680">   {114*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-681">   {131*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-682">   {152*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-683">   {175*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-684">   {202*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-685">   {234*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-686">   {271*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-687">   {312*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-688">   {359*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-689">   {411*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-690">   {467*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-691">   {527*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-692">   {590*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-693">   {652*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-694">   {713*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-695">   {770*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-696">   {822*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-697">   {867*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-698">   {905*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-699">   {936*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-700">   {961*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-701">   {979*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-702">   {993*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-703">   {1003*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-704">   {1010*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-705">   {1015*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-706">   {1018*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-707">   {1020*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-708">};</front>
<front id="thermistortablesH-709">#endif</front>
<front id="thermistortablesH-710"></front>
<front id="thermistortablesH-711">#if (THERMISTORHEATER_0 == 60) || (THERMISTORHEATER_1 == 60) || (THERMISTORHEATER_2 == 60) || (THERMISTORBED == 60) // Maker's Tool Works Kapton Bed Thermister</front>
<front id="thermistortablesH-712">const short temptable_60[][2] PROGMEM = {</front>
<front id="thermistortablesH-713">   {51*OVERSAMPLENR, 272},</front>
<front id="thermistortablesH-714">   {61*OVERSAMPLENR, 258},</front>
<front id="thermistortablesH-715">   {71*OVERSAMPLENR, 247},</front>
<front id="thermistortablesH-716">   {81*OVERSAMPLENR, 237},</front>
<front id="thermistortablesH-717">   {91*OVERSAMPLENR, 229},</front>
<front id="thermistortablesH-718">   {101*OVERSAMPLENR, 221},</front>
<front id="thermistortablesH-719">   {131*OVERSAMPLENR, 204},</front>
<front id="thermistortablesH-720">   {161*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-721">   {191*OVERSAMPLENR, 179},</front>
<front id="thermistortablesH-722">   {231*OVERSAMPLENR, 167},</front>
<front id="thermistortablesH-723">   {271*OVERSAMPLENR, 157},</front>
<front id="thermistortablesH-724">   {311*OVERSAMPLENR, 148},</front>
<front id="thermistortablesH-725">   {351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-726">   {381*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-727">   {411*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-728">   {441*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-729">   {451*OVERSAMPLENR, 123},</front>
<front id="thermistortablesH-730">   {461*OVERSAMPLENR, 122},</front>
<front id="thermistortablesH-731">   {471*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-732">   {481*OVERSAMPLENR, 119},</front>
<front id="thermistortablesH-733">   {491*OVERSAMPLENR, 117},</front>
<front id="thermistortablesH-734">   {501*OVERSAMPLENR, 116},</front>
<front id="thermistortablesH-735">   {511*OVERSAMPLENR, 114},</front>
<front id="thermistortablesH-736">   {521*OVERSAMPLENR, 113},</front>
<front id="thermistortablesH-737">   {531*OVERSAMPLENR, 111},</front>
<front id="thermistortablesH-738">   {541*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-739">   {551*OVERSAMPLENR, 108},</front>
<front id="thermistortablesH-740">   {561*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-741">   {571*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-742">   {581*OVERSAMPLENR, 104},</front>
<front id="thermistortablesH-743">   {591*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-744">   {601*OVERSAMPLENR, 101},</front>
<front id="thermistortablesH-745">   {611*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-746">   {621*OVERSAMPLENR, 98},</front>
<front id="thermistortablesH-747">   {631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-748">   {641*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-749">   {651*OVERSAMPLENR, 94},</front>
<front id="thermistortablesH-750">   {661*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-751">   {671*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-752">   {681*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-753">   {691*OVERSAMPLENR, 88},</front>
<front id="thermistortablesH-754">   {701*OVERSAMPLENR, 87},</front>
<front id="thermistortablesH-755">   {711*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-756">   {721*OVERSAMPLENR, 84},</front>
<front id="thermistortablesH-757">   {731*OVERSAMPLENR, 82},</front>
<front id="thermistortablesH-758">   {741*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-759">   {751*OVERSAMPLENR, 79},</front>
<front id="thermistortablesH-760">   {761*OVERSAMPLENR, 77},</front>
<front id="thermistortablesH-761">   {771*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-762">   {781*OVERSAMPLENR, 74},</front>
<front id="thermistortablesH-763">   {791*OVERSAMPLENR, 72},</front>
<front id="thermistortablesH-764">   {801*OVERSAMPLENR, 71},</front>
<front id="thermistortablesH-765">   {811*OVERSAMPLENR, 69},</front>
<front id="thermistortablesH-766">   {821*OVERSAMPLENR, 67},</front>
<front id="thermistortablesH-767">   {831*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-768">   {841*OVERSAMPLENR, 63},</front>
<front id="thermistortablesH-769">   {851*OVERSAMPLENR, 62},</front>
<front id="thermistortablesH-770">   {861*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-771">   {871*OVERSAMPLENR, 57},</front>
<front id="thermistortablesH-772">   {881*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-773">   {891*OVERSAMPLENR, 53},</front>
<front id="thermistortablesH-774">   {901*OVERSAMPLENR, 51},</front>
<front id="thermistortablesH-775">   {911*OVERSAMPLENR, 48},</front>
<front id="thermistortablesH-776">   {921*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-777">   {931*OVERSAMPLENR, 42},</front>
<front id="thermistortablesH-778">   {941*OVERSAMPLENR, 39},</front>
<front id="thermistortablesH-779">   {951*OVERSAMPLENR, 36},</front>
<front id="thermistortablesH-780">   {961*OVERSAMPLENR, 32},</front>
<front id="thermistortablesH-781">   {981*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-782">   {991*OVERSAMPLENR, 17},</front>
<front id="thermistortablesH-783">   {1001*OVERSAMPLENR, 9},</front>
<front id="thermistortablesH-784">   {1008*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-785">};</front>
<front id="thermistortablesH-786">#endif</front>
<front id="thermistortablesH-787"></front>
<front id="thermistortablesH-788"></front>
<front id="thermistortablesH-789">#define _TT_NAME(_N) temptable_ ## _N</front>
<front id="thermistortablesH-790">#define TT_NAME(_N) _TT_NAME(_N)</front>
<front id="thermistortablesH-791"></front>
<front id="thermistortablesH-792">#ifdef THERMISTORHEATER_0</front>
<front id="thermistortablesH-793"># define HEATER_0_TEMPTABLE TT_NAME(THERMISTORHEATER_0)</front>
<front id="thermistortablesH-794"># define HEATER_0_TEMPTABLE_LEN (sizeof(HEATER_0_TEMPTABLE)/sizeof(*HEATER_0_TEMPTABLE))</front>
<front id="thermistortablesH-795">#else</front>
<front id="thermistortablesH-796"># ifdef HEATER_0_USES_THERMISTOR</front>
<front id="thermistortablesH-797">#  error No heater 0 thermistor table specified</front>
<front id="thermistortablesH-798"># else  // HEATER_0_USES_THERMISTOR</front>
<front id="thermistortablesH-799">#  define HEATER_0_TEMPTABLE NULL</front>
<front id="thermistortablesH-800">#  define HEATER_0_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-801"># endif // HEATER_0_USES_THERMISTOR</front>
<front id="thermistortablesH-802">#endif</front>
<front id="thermistortablesH-803"></front>
<front id="thermistortablesH-804">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-805">#ifndef HEATER_0_RAW_HI_TEMP</front>
<front id="thermistortablesH-806"># ifdef HEATER_0_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-807">#  define HEATER_0_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-808">#  define HEATER_0_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-809"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-810">#  define HEATER_0_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-811">#  define HEATER_0_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-812"># endif</front>
<front id="thermistortablesH-813">#endif</front>
<front id="thermistortablesH-814"></front>
<front id="thermistortablesH-815">#ifdef THERMISTORHEATER_1</front>
<front id="thermistortablesH-816"># define HEATER_1_TEMPTABLE TT_NAME(THERMISTORHEATER_1)</front>
<front id="thermistortablesH-817"># define HEATER_1_TEMPTABLE_LEN (sizeof(HEATER_1_TEMPTABLE)/sizeof(*HEATER_1_TEMPTABLE))</front>
<front id="thermistortablesH-818">#else</front>
<front id="thermistortablesH-819"># ifdef HEATER_1_USES_THERMISTOR</front>
<front id="thermistortablesH-820">#  error No heater 1 thermistor table specified</front>
<front id="thermistortablesH-821"># else  // HEATER_1_USES_THERMISTOR</front>
<front id="thermistortablesH-822">#  define HEATER_1_TEMPTABLE NULL</front>
<front id="thermistortablesH-823">#  define HEATER_1_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-824"># endif // HEATER_1_USES_THERMISTOR</front>
<front id="thermistortablesH-825">#endif</front>
<front id="thermistortablesH-826"></front>
<front id="thermistortablesH-827">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-828">#ifndef HEATER_1_RAW_HI_TEMP</front>
<front id="thermistortablesH-829"># ifdef HEATER_1_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-830">#  define HEATER_1_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-831">#  define HEATER_1_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-832"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-833">#  define HEATER_1_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-834">#  define HEATER_1_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-835"># endif</front>
<front id="thermistortablesH-836">#endif</front>
<front id="thermistortablesH-837"></front>
<front id="thermistortablesH-838">#ifdef THERMISTORHEATER_2</front>
<front id="thermistortablesH-839"># define HEATER_2_TEMPTABLE TT_NAME(THERMISTORHEATER_2)</front>
<front id="thermistortablesH-840"># define HEATER_2_TEMPTABLE_LEN (sizeof(HEATER_2_TEMPTABLE)/sizeof(*HEATER_2_TEMPTABLE))</front>
<front id="thermistortablesH-841">#else</front>
<front id="thermistortablesH-842"># ifdef HEATER_2_USES_THERMISTOR</front>
<front id="thermistortablesH-843">#  error No heater 2 thermistor table specified</front>
<front id="thermistortablesH-844"># else  // HEATER_2_USES_THERMISTOR</front>
<front id="thermistortablesH-845">#  define HEATER_2_TEMPTABLE NULL</front>
<front id="thermistortablesH-846">#  define HEATER_2_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-847"># endif // HEATER_2_USES_THERMISTOR</front>
<front id="thermistortablesH-848">#endif</front>
<front id="thermistortablesH-849"></front>
<front id="thermistortablesH-850">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-851">#ifndef HEATER_2_RAW_HI_TEMP</front>
<front id="thermistortablesH-852"># ifdef HEATER_2_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-853">#  define HEATER_2_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-854">#  define HEATER_2_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-855"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-856">#  define HEATER_2_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-857">#  define HEATER_2_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-858"># endif</front>
<front id="thermistortablesH-859">#endif</front>
<front id="thermistortablesH-860"></front>
<front id="thermistortablesH-861">#ifdef THERMISTORBED</front>
<front id="thermistortablesH-862"># define BEDTEMPTABLE TT_NAME(THERMISTORBED)</front>
<front id="thermistortablesH-863"># define BEDTEMPTABLE_LEN (sizeof(BEDTEMPTABLE)/sizeof(*BEDTEMPTABLE))</front>
<front id="thermistortablesH-864">#else</front>
<front id="thermistortablesH-865"># ifdef BED_USES_THERMISTOR</front>
<front id="thermistortablesH-866">#  error No bed thermistor table specified</front>
<front id="thermistortablesH-867"># endif // BED_USES_THERMISTOR</front>
<front id="thermistortablesH-868">#endif</front>
<front id="thermistortablesH-869"></front>
<front id="thermistortablesH-870">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-871">#ifndef HEATER_BED_RAW_HI_TEMP</front>
<front id="thermistortablesH-872"># ifdef BED_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-873">#  define HEATER_BED_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-874">#  define HEATER_BED_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-875"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-876">#  define HEATER_BED_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-877">#  define HEATER_BED_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-878"># endif</front>
<front id="thermistortablesH-879">#endif</front>
<front id="thermistortablesH-880"></front>
<front id="thermistortablesH-881">#endif //THERMISTORTABLES_H_</front>
 </pre>
<h1>ultralcd.cpp</h1>
<pre  class="prettyprint linenums"><front id="ultralcdCPP-1">#include "temperature.h"</front>
<front id="ultralcdCPP-2">#include "ultralcd.h"</front>
<front id="ultralcdCPP-3">#ifdef ULTRA_LCD</front>
<front id="ultralcdCPP-4">#include "Marlin.h"</front>
<front id="ultralcdCPP-5">#include "language.h"</front>
<front id="ultralcdCPP-6">#include "cardreader.h"</front>
<front id="ultralcdCPP-7">#include "temperature.h"</front>
<front id="ultralcdCPP-8">#include "stepper.h"</front>
<front id="ultralcdCPP-9">#include "ConfigurationStore.h"</front>
<front id="ultralcdCPP-10"></front>
<front id="ultralcdCPP-11">int8_t encoderDiff; /* encoderDiff is updated from interrupt context and added to encoderPosition every LCD update */</front>
<front id="ultralcdCPP-12"></front>
<front id="ultralcdCPP-13">/* Configuration settings */</front>
<front id="ultralcdCPP-14">int plaPreheatHotendTemp;</front>
<front id="ultralcdCPP-15">int plaPreheatHPBTemp;</front>
<front id="ultralcdCPP-16">int plaPreheatFanSpeed;</front>
<front id="ultralcdCPP-17"></front>
<front id="ultralcdCPP-18">int absPreheatHotendTemp;</front>
<front id="ultralcdCPP-19">int absPreheatHPBTemp;</front>
<front id="ultralcdCPP-20">int absPreheatFanSpeed;</front>
<front id="ultralcdCPP-21"></front>
<front id="ultralcdCPP-22">static float manual_feedrate[] = MANUAL_FEEDRATE;</front>
<front id="ultralcdCPP-23">/* !Configuration settings */</front>
<front id="ultralcdCPP-24"></front>
<front id="ultralcdCPP-25">//Function pointer to menu functions.</front>
<front id="ultralcdCPP-26">typedef void (*menuFunc_t)();</front>
<front id="ultralcdCPP-27"></front>
<front id="ultralcdCPP-28">uint8_t lcd_status_message_level;</front>
<front id="ultralcdCPP-29">char lcd_status_message[LCD_WIDTH+1] = WELCOME_MSG;</front>
<front id="ultralcdCPP-30"></front>
<front id="ultralcdCPP-31">#ifdef DOGLCD</front>
<front id="ultralcdCPP-32">#include "dogm_lcd_implementation.h"</front>
<front id="ultralcdCPP-33">#else</front>
<front id="ultralcdCPP-34">#include "ultralcd_implementation_hitachi_HD44780.h"</front>
<front id="ultralcdCPP-35">#endif</front>
<front id="ultralcdCPP-36"></front>
<front id="ultralcdCPP-37">/** forward declerations **/</front>
<front id="ultralcdCPP-38"></front>
<front id="ultralcdCPP-39">void copy_and_scalePID_i();</front>
<front id="ultralcdCPP-40">void copy_and_scalePID_d();</front>
<front id="ultralcdCPP-41"></front>
<front id="ultralcdCPP-42">/* Different menus */</front>
<front id="ultralcdCPP-43">static void lcd_status_screen();</front>
<front id="ultralcdCPP-44">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-45">extern bool powersupply;</front>
<front id="ultralcdCPP-46">static void lcd_main_menu();</front>
<front id="ultralcdCPP-47">static void lcd_tune_menu();</front>
<front id="ultralcdCPP-48">static void lcd_prepare_menu();</front>
<front id="ultralcdCPP-49">static void lcd_move_menu();</front>
<front id="ultralcdCPP-50">static void lcd_control_menu();</front>
<front id="ultralcdCPP-51">static void lcd_control_temperature_menu();</front>
<front id="ultralcdCPP-52">static void lcd_control_temperature_preheat_pla_settings_menu();</front>
<front id="ultralcdCPP-53">static void lcd_control_temperature_preheat_abs_settings_menu();</front>
<front id="ultralcdCPP-54">static void lcd_control_motion_menu();</front>
<front id="ultralcdCPP-55">#ifdef DOGLCD</front>
<front id="ultralcdCPP-56">static void lcd_set_contrast();</front>
<front id="ultralcdCPP-57">#endif</front>
<front id="ultralcdCPP-58">static void lcd_control_retract_menu();</front>
<front id="ultralcdCPP-59">static void lcd_sdcard_menu();</front>
<front id="ultralcdCPP-60"></front>
<front id="ultralcdCPP-61">static void lcd_quick_feedback();//Cause an LCD refresh, and give the user visual or audiable feedback that something has happend</front>
<front id="ultralcdCPP-62"></front>
<front id="ultralcdCPP-63">/* Different types of actions that can be used in menuitems. */</front>
<front id="ultralcdCPP-64">static void menu_action_back(menuFunc_t data);</front>
<front id="ultralcdCPP-65">static void menu_action_submenu(menuFunc_t data);</front>
<front id="ultralcdCPP-66">static void menu_action_gcode(const char* pgcode);</front>
<front id="ultralcdCPP-67">static void menu_action_function(menuFunc_t data);</front>
<front id="ultralcdCPP-68">static void menu_action_sdfile(const char* filename, char* longFilename);</front>
<front id="ultralcdCPP-69">static void menu_action_sddirectory(const char* filename, char* longFilename);</front>
<front id="ultralcdCPP-70">static void menu_action_setting_edit_bool(const char* pstr, bool* ptr);</front>
<front id="ultralcdCPP-71">static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);</front>
<front id="ultralcdCPP-72">static void menu_action_setting_edit_float3(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-73">static void menu_action_setting_edit_float32(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-74">static void menu_action_setting_edit_float5(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-75">static void menu_action_setting_edit_float51(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-76">static void menu_action_setting_edit_float52(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-77">static void menu_action_setting_edit_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue);</front>
<front id="ultralcdCPP-78">static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-79">static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-80">static void menu_action_setting_edit_callback_float3(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-81">static void menu_action_setting_edit_callback_float32(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-82">static void menu_action_setting_edit_callback_float5(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-83">static void menu_action_setting_edit_callback_float51(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-84">static void menu_action_setting_edit_callback_float52(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-85">static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-86"></front>
<front id="ultralcdCPP-87">#define ENCODER_FEEDRATE_DEADZONE 10</front>
<front id="ultralcdCPP-88"></front>
<front id="ultralcdCPP-89">#if !defined(LCD_I2C_VIKI)</front>
<front id="ultralcdCPP-90">  #define ENCODER_STEPS_PER_MENU_ITEM 5</front>
<front id="ultralcdCPP-91">  #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ultralcdCPP-92">    #define ENCODER_PULSES_PER_STEP 1</front>
<front id="ultralcdCPP-93">  #endif</front>
<front id="ultralcdCPP-94">#else</front>
<front id="ultralcdCPP-95">  #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation</front>
<front id="ultralcdCPP-96">  #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ultralcdCPP-97">    #define ENCODER_PULSES_PER_STEP 1</front>
<front id="ultralcdCPP-98">  #endif</front>
<front id="ultralcdCPP-99">#endif</front>
<front id="ultralcdCPP-100"></front>
<front id="ultralcdCPP-101"></front>
<front id="ultralcdCPP-102">/* Helper macros for menus */</front>
<front id="ultralcdCPP-103">#define START_MENU() do { \</front>
<front id="ultralcdCPP-104">    if (encoderPosition &gt; 0x8000) encoderPosition = 0; \</front>
<front id="ultralcdCPP-105">    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM &lt; currentMenuViewOffset) currentMenuViewOffset = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM;\</front>
<front id="ultralcdCPP-106">    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \</front>
<front id="ultralcdCPP-107">    for(uint8_t _drawLineNr = 0; _drawLineNr &lt; LCD_HEIGHT; _drawLineNr++, _lineNr++) { \</front>
<front id="ultralcdCPP-108">        _menuItemNr = 0;</front>
<front id="ultralcdCPP-109">#define MENU_ITEM(type, label, args...) do { \</front>
<front id="ultralcdCPP-110">    if (_menuItemNr == _lineNr) { \</front>
<front id="ultralcdCPP-111">        if (lcdDrawUpdate) { \</front>
<front id="ultralcdCPP-112">            const char* _label_pstr = PSTR(label); \</front>
<front id="ultralcdCPP-113">            if ((encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) { \</front>
<front id="ultralcdCPP-114">                lcd_implementation_drawmenu_ ## type ## _selected (_drawLineNr, _label_pstr , ## args ); \</front>
<front id="ultralcdCPP-115">            }else{\</front>
<front id="ultralcdCPP-116">                lcd_implementation_drawmenu_ ## type (_drawLineNr, _label_pstr , ## args ); \</front>
<front id="ultralcdCPP-117">            }\</front>
<front id="ultralcdCPP-118">        }\</front>
<front id="ultralcdCPP-119">        if (wasClicked && (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) == _menuItemNr) {\</front>
<front id="ultralcdCPP-120">            lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-121">            menu_action_ ## type ( args ); \</front>
<front id="ultralcdCPP-122">            return;\</front>
<front id="ultralcdCPP-123">        }\</front>
<front id="ultralcdCPP-124">    }\</front>
<front id="ultralcdCPP-125">    _menuItemNr++;\</front>
<front id="ultralcdCPP-126">} while(0)</front>
<front id="ultralcdCPP-127">#define MENU_ITEM_DUMMY() do { _menuItemNr++; } while(0)</front>
<front id="ultralcdCPP-128">#define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label) , ## args )</front>
<front id="ultralcdCPP-129">#define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label) , ## args )</front>
<front id="ultralcdCPP-130">#define END_MENU() \</front>
<front id="ultralcdCPP-131">    if (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM &gt;= _menuItemNr) encoderPosition = _menuItemNr * ENCODER_STEPS_PER_MENU_ITEM - 1; \</front>
<front id="ultralcdCPP-132">    if ((uint8_t)(encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) &gt;= currentMenuViewOffset + LCD_HEIGHT) { currentMenuViewOffset = (encoderPosition / ENCODER_STEPS_PER_MENU_ITEM) - LCD_HEIGHT + 1; lcdDrawUpdate = 1; _lineNr = currentMenuViewOffset - 1; _drawLineNr = -1; } \</front>
<front id="ultralcdCPP-133">    } } while(0)</front>
<front id="ultralcdCPP-134"></front>
<front id="ultralcdCPP-135">/** Used variables to keep track of the menu */</front>
<front id="ultralcdCPP-136">#ifndef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-137">volatile uint8_t buttons;//Contains the bits of the currently pressed buttons.</front>
<front id="ultralcdCPP-138">#else</front>
<front id="ultralcdCPP-139">volatile uint8_t buttons_reprapworld_keypad; // to store the reprapworld_keypad shiftregister values</front>
<front id="ultralcdCPP-140">#endif</front>
<front id="ultralcdCPP-141">uint8_t currentMenuViewOffset;              /* scroll offset in the current menu */</front>
<front id="ultralcdCPP-142">uint32_t blocking_enc;</front>
<front id="ultralcdCPP-143">uint8_t lastEncoderBits;</front>
<front id="ultralcdCPP-144">uint32_t encoderPosition;</front>
<front id="ultralcdCPP-145">bool wasClicked;</front>
<front id="ultralcdCPP-146">#if (SDCARDDETECT &gt; 0)</front>
<front id="ultralcdCPP-147">bool lcd_oldcardstatus;</front>
<front id="ultralcdCPP-148">#endif</front>
<front id="ultralcdCPP-149">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-150"></front>
<front id="ultralcdCPP-151">menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */</front>
<front id="ultralcdCPP-152">uint32_t lcd_next_update_millis;</front>
<front id="ultralcdCPP-153">uint8_t lcd_status_update_delay;</front>
<front id="ultralcdCPP-154">uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets atleast 1 full redraw (first redraw is partial) */</front>
<front id="ultralcdCPP-155"></front>
<front id="ultralcdCPP-156">//prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.</front>
<front id="ultralcdCPP-157">menuFunc_t prevMenu = NULL;</front>
<front id="ultralcdCPP-158">uint16_t prevEncoderPosition;</front>
<front id="ultralcdCPP-159">//Variables used when editing values.</front>
<front id="ultralcdCPP-160">const char* editLabel;</front>
<front id="ultralcdCPP-161">void* editValue;</front>
<front id="ultralcdCPP-162">int32_t minEditValue, maxEditValue;</front>
<front id="ultralcdCPP-163">menuFunc_t callbackFunc;</front>
<front id="ultralcdCPP-164"></front>
<front id="ultralcdCPP-165">// placeholders for Ki and Kd edits</front>
<front id="ultralcdCPP-166">float raw_Ki, raw_Kd;</front>
<front id="ultralcdCPP-167"></front>
<front id="ultralcdCPP-168">/* Main status screen. It's up to the implementation specific part to show what is needed. As this is very display dependend */</front>
<front id="ultralcdCPP-169">static void lcd_status_screen()</front>
<front id="ultralcdCPP-170">{</front>
<front id="ultralcdCPP-171">    if (lcd_status_update_delay)</front>
<front id="ultralcdCPP-172">        lcd_status_update_delay--;</front>
<front id="ultralcdCPP-173">    else</front>
<front id="ultralcdCPP-174">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-175">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-176">    {</front>
<front id="ultralcdCPP-177">        lcd_implementation_status_screen();</front>
<front id="ultralcdCPP-178">        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */</front>
<front id="ultralcdCPP-179">    }</front>
<front id="ultralcdCPP-180">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-181">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-182">    {</front>
<front id="ultralcdCPP-183">        currentMenu = lcd_main_menu;</front>
<front id="ultralcdCPP-184">        encoderPosition = 0;</front>
<front id="ultralcdCPP-185">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-186">    }</front>
<front id="ultralcdCPP-187"></front>
<front id="ultralcdCPP-188">    // Dead zone at 100% feedrate</front>
<front id="ultralcdCPP-189">    if ((feedmultiply &lt; 100 && (feedmultiply + int(encoderPosition)) &gt; 100) ||</front>
<front id="ultralcdCPP-190">            (feedmultiply &gt; 100 && (feedmultiply + int(encoderPosition)) &lt; 100))</front>
<front id="ultralcdCPP-191">    {</front>
<front id="ultralcdCPP-192">        encoderPosition = 0;</front>
<front id="ultralcdCPP-193">        feedmultiply = 100;</front>
<front id="ultralcdCPP-194">    }</front>
<front id="ultralcdCPP-195"></front>
<front id="ultralcdCPP-196">    if (feedmultiply == 100 && int(encoderPosition) &gt; ENCODER_FEEDRATE_DEADZONE)</front>
<front id="ultralcdCPP-197">    {</front>
<front id="ultralcdCPP-198">        feedmultiply += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;</front>
<front id="ultralcdCPP-199">        encoderPosition = 0;</front>
<front id="ultralcdCPP-200">    }</front>
<front id="ultralcdCPP-201">    else if (feedmultiply == 100 && int(encoderPosition) &lt; -ENCODER_FEEDRATE_DEADZONE)</front>
<front id="ultralcdCPP-202">    {</front>
<front id="ultralcdCPP-203">        feedmultiply += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;</front>
<front id="ultralcdCPP-204">        encoderPosition = 0;	</front>
<front id="ultralcdCPP-205">    }</front>
<front id="ultralcdCPP-206">    else if (feedmultiply != 100)</front>
<front id="ultralcdCPP-207">    {</front>
<front id="ultralcdCPP-208">        feedmultiply += int(encoderPosition);</front>
<front id="ultralcdCPP-209">        encoderPosition = 0;</front>
<front id="ultralcdCPP-210">    }</front>
<front id="ultralcdCPP-211"></front>
<front id="ultralcdCPP-212">    if (feedmultiply &lt; 10)</front>
<front id="ultralcdCPP-213">        feedmultiply = 10;</front>
<front id="ultralcdCPP-214">    if (feedmultiply &gt; 999)</front>
<front id="ultralcdCPP-215">        feedmultiply = 999;</front>
<front id="ultralcdCPP-216">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-217">}</front>
<front id="ultralcdCPP-218"></front>
<front id="ultralcdCPP-219">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-220">static void lcd_return_to_status()</front>
<front id="ultralcdCPP-221">{</front>
<front id="ultralcdCPP-222">    encoderPosition = 0;</front>
<front id="ultralcdCPP-223">    currentMenu = lcd_status_screen;</front>
<front id="ultralcdCPP-224">}</front>
<front id="ultralcdCPP-225"></front>
<front id="ultralcdCPP-226">static void lcd_sdcard_pause()</front>
<front id="ultralcdCPP-227">{</front>
<front id="ultralcdCPP-228">    card.pauseSDPrint();</front>
<front id="ultralcdCPP-229">}</front>
<front id="ultralcdCPP-230">static void lcd_sdcard_resume()</front>
<front id="ultralcdCPP-231">{</front>
<front id="ultralcdCPP-232">    card.startFileprint();</front>
<front id="ultralcdCPP-233">}</front>
<front id="ultralcdCPP-234"></front>
<front id="ultralcdCPP-235">static void lcd_sdcard_stop()</front>
<front id="ultralcdCPP-236">{</front>
<front id="ultralcdCPP-237">    card.sdprinting = false;</front>
<front id="ultralcdCPP-238">    card.closefile();</front>
<front id="ultralcdCPP-239">    quickStop();</front>
<front id="ultralcdCPP-240">    if(SD_FINISHED_STEPPERRELEASE)</front>
<front id="ultralcdCPP-241">    {</front>
<front id="ultralcdCPP-242">        enquecommand_P(PSTR(SD_FINISHED_RELEASECOMMAND));</front>
<front id="ultralcdCPP-243">    }</front>
<front id="ultralcdCPP-244">    autotempShutdown();</front>
<front id="ultralcdCPP-245">}</front>
<front id="ultralcdCPP-246"></front>
<front id="ultralcdCPP-247">/* Menu implementation */</front>
<front id="ultralcdCPP-248">static void lcd_main_menu()</front>
<front id="ultralcdCPP-249">{</front>
<front id="ultralcdCPP-250">    START_MENU();</front>
<front id="ultralcdCPP-251">    MENU_ITEM(back, MSG_WATCH, lcd_status_screen);</front>
<front id="ultralcdCPP-252">    if (movesplanned() || IS_SD_PRINTING)</front>
<front id="ultralcdCPP-253">    {</front>
<front id="ultralcdCPP-254">        MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);</front>
<front id="ultralcdCPP-255">    }else{</front>
<front id="ultralcdCPP-256">        MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-257">    }</front>
<front id="ultralcdCPP-258">    MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-259">#ifdef SDSUPPORT</front>
<front id="ultralcdCPP-260">    if (card.cardOK)</front>
<front id="ultralcdCPP-261">    {</front>
<front id="ultralcdCPP-262">        if (card.isFileOpen())</front>
<front id="ultralcdCPP-263">        {</front>
<front id="ultralcdCPP-264">            if (card.sdprinting)</front>
<front id="ultralcdCPP-265">                MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);</front>
<front id="ultralcdCPP-266">            else</front>
<front id="ultralcdCPP-267">                MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);</front>
<front id="ultralcdCPP-268">            MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);</front>
<front id="ultralcdCPP-269">        }else{</front>
<front id="ultralcdCPP-270">            MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_menu);</front>
<front id="ultralcdCPP-271">#if SDCARDDETECT &lt; 1</front>
<front id="ultralcdCPP-272">            MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user</front>
<front id="ultralcdCPP-273">#endif</front>
<front id="ultralcdCPP-274">        }</front>
<front id="ultralcdCPP-275">    }else{</front>
<front id="ultralcdCPP-276">        MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);</front>
<front id="ultralcdCPP-277">#if SDCARDDETECT &lt; 1</front>
<front id="ultralcdCPP-278">        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface</front>
<front id="ultralcdCPP-279">#endif</front>
<front id="ultralcdCPP-280">    }</front>
<front id="ultralcdCPP-281">#endif</front>
<front id="ultralcdCPP-282">    END_MENU();</front>
<front id="ultralcdCPP-283">}</front>
<front id="ultralcdCPP-284"></front>
<front id="ultralcdCPP-285">#ifdef SDSUPPORT</front>
<front id="ultralcdCPP-286">static void lcd_autostart_sd()</front>
<front id="ultralcdCPP-287">{</front>
<front id="ultralcdCPP-288">    card.lastnr=0;</front>
<front id="ultralcdCPP-289">    card.setroot();</front>
<front id="ultralcdCPP-290">    card.checkautostart(true);</front>
<front id="ultralcdCPP-291">}</front>
<front id="ultralcdCPP-292">#endif</front>
<front id="ultralcdCPP-293"></front>
<front id="ultralcdCPP-294">void lcd_preheat_pla()</front>
<front id="ultralcdCPP-295">{</front>
<front id="ultralcdCPP-296">    setTargetHotend0(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-297">    setTargetHotend1(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-298">    setTargetHotend2(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-299">    setTargetBed(plaPreheatHPBTemp);</front>
<front id="ultralcdCPP-300">    fanSpeed = plaPreheatFanSpeed;</front>
<front id="ultralcdCPP-301">    lcd_return_to_status();</front>
<front id="ultralcdCPP-302">    setWatch(); // heater sanity check timer</front>
<front id="ultralcdCPP-303">}</front>
<front id="ultralcdCPP-304"></front>
<front id="ultralcdCPP-305">void lcd_preheat_abs()</front>
<front id="ultralcdCPP-306">{</front>
<front id="ultralcdCPP-307">    setTargetHotend0(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-308">    setTargetHotend1(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-309">    setTargetHotend2(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-310">    setTargetBed(absPreheatHPBTemp);</front>
<front id="ultralcdCPP-311">    fanSpeed = absPreheatFanSpeed;</front>
<front id="ultralcdCPP-312">    lcd_return_to_status();</front>
<front id="ultralcdCPP-313">    setWatch(); // heater sanity check timer</front>
<front id="ultralcdCPP-314">}</front>
<front id="ultralcdCPP-315"></front>
<front id="ultralcdCPP-316">static void lcd_cooldown()</front>
<front id="ultralcdCPP-317">{</front>
<front id="ultralcdCPP-318">    setTargetHotend0(0);</front>
<front id="ultralcdCPP-319">    setTargetHotend1(0);</front>
<front id="ultralcdCPP-320">    setTargetHotend2(0);</front>
<front id="ultralcdCPP-321">    setTargetBed(0);</front>
<front id="ultralcdCPP-322">    lcd_return_to_status();</front>
<front id="ultralcdCPP-323">}</front>
<front id="ultralcdCPP-324"></front>
<front id="ultralcdCPP-325">#ifdef BABYSTEPPING</front>
<front id="ultralcdCPP-326">static void lcd_babystep_x()</front>
<front id="ultralcdCPP-327">{</front>
<front id="ultralcdCPP-328">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-329">    {</front>
<front id="ultralcdCPP-330">        babystepsTodo[X_AXIS]+=(int)encoderPosition;</front>
<front id="ultralcdCPP-331">        encoderPosition=0;</front>
<front id="ultralcdCPP-332">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-333">    }</front>
<front id="ultralcdCPP-334">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-335">    {</front>
<front id="ultralcdCPP-336">        lcd_implementation_drawedit(PSTR("Babystepping X"),"");</front>
<front id="ultralcdCPP-337">    }</front>
<front id="ultralcdCPP-338">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-339">    {</front>
<front id="ultralcdCPP-340">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-341">        currentMenu = lcd_tune_menu;</front>
<front id="ultralcdCPP-342">        encoderPosition = 0;</front>
<front id="ultralcdCPP-343">    }</front>
<front id="ultralcdCPP-344">}</front>
<front id="ultralcdCPP-345"></front>
<front id="ultralcdCPP-346">static void lcd_babystep_y()</front>
<front id="ultralcdCPP-347">{</front>
<front id="ultralcdCPP-348">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-349">    {</front>
<front id="ultralcdCPP-350">        babystepsTodo[Y_AXIS]+=(int)encoderPosition;</front>
<front id="ultralcdCPP-351">        encoderPosition=0;</front>
<front id="ultralcdCPP-352">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-353">    }</front>
<front id="ultralcdCPP-354">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-355">    {</front>
<front id="ultralcdCPP-356">        lcd_implementation_drawedit(PSTR("Babystepping Y"),"");</front>
<front id="ultralcdCPP-357">    }</front>
<front id="ultralcdCPP-358">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-359">    {</front>
<front id="ultralcdCPP-360">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-361">        currentMenu = lcd_tune_menu;</front>
<front id="ultralcdCPP-362">        encoderPosition = 0;</front>
<front id="ultralcdCPP-363">    }</front>
<front id="ultralcdCPP-364">}</front>
<front id="ultralcdCPP-365"></front>
<front id="ultralcdCPP-366">static void lcd_babystep_z()</front>
<front id="ultralcdCPP-367">{</front>
<front id="ultralcdCPP-368">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-369">    {</front>
<front id="ultralcdCPP-370">        babystepsTodo[Z_AXIS]+=(int)encoderPosition;</front>
<front id="ultralcdCPP-371">        encoderPosition=0;</front>
<front id="ultralcdCPP-372">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-373">    }</front>
<front id="ultralcdCPP-374">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-375">    {</front>
<front id="ultralcdCPP-376">        lcd_implementation_drawedit(PSTR("Babystepping Z"),"");</front>
<front id="ultralcdCPP-377">    }</front>
<front id="ultralcdCPP-378">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-379">    {</front>
<front id="ultralcdCPP-380">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-381">        currentMenu = lcd_tune_menu;</front>
<front id="ultralcdCPP-382">        encoderPosition = 0;</front>
<front id="ultralcdCPP-383">    }</front>
<front id="ultralcdCPP-384">}</front>
<front id="ultralcdCPP-385">#endif //BABYSTEPPING</front>
<front id="ultralcdCPP-386"></front>
<front id="ultralcdCPP-387">static void lcd_tune_menu()</front>
<front id="ultralcdCPP-388">{</front>
<front id="ultralcdCPP-389">    START_MENU();</front>
<front id="ultralcdCPP-390">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-391">    MENU_ITEM_EDIT(int3, MSG_SPEED, &feedmultiply, 10, 999);</front>
<front id="ultralcdCPP-392">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-393">#if TEMP_SENSOR_1 != 0</front>
<front id="ultralcdCPP-394">    MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);</front>
<front id="ultralcdCPP-395">#endif</front>
<front id="ultralcdCPP-396">#if TEMP_SENSOR_2 != 0</front>
<front id="ultralcdCPP-397">    MENU_ITEM_EDIT(int3, MSG_NOZZLE2, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);</front>
<front id="ultralcdCPP-398">#endif</front>
<front id="ultralcdCPP-399">#if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-400">    MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-401">#endif</front>
<front id="ultralcdCPP-402">    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);</front>
<front id="ultralcdCPP-403">    MENU_ITEM_EDIT(int3, MSG_FLOW, &extrudemultiply, 10, 999);</front>
<front id="ultralcdCPP-404">    </front>
<front id="ultralcdCPP-405">#ifdef BABYSTEPPING</front>
<front id="ultralcdCPP-406">    #ifdef BABYSTEP_XY</front>
<front id="ultralcdCPP-407">      MENU_ITEM(submenu, "Babystep X", lcd_babystep_x);</front>
<front id="ultralcdCPP-408">      MENU_ITEM(submenu, "Babystep Y", lcd_babystep_y);</front>
<front id="ultralcdCPP-409">    #endif //BABYSTEP_XY</front>
<front id="ultralcdCPP-410">    MENU_ITEM(submenu, "Babystep Z", lcd_babystep_z);</front>
<front id="ultralcdCPP-411">#endif</front>
<front id="ultralcdCPP-412">#ifdef FILAMENTCHANGEENABLE</front>
<front id="ultralcdCPP-413">     MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));</front>
<front id="ultralcdCPP-414">#endif</front>
<front id="ultralcdCPP-415">    END_MENU();</front>
<front id="ultralcdCPP-416">}</front>
<front id="ultralcdCPP-417"></front>
<front id="ultralcdCPP-418">static void lcd_prepare_menu()</front>
<front id="ultralcdCPP-419">{</front>
<front id="ultralcdCPP-420">    START_MENU();</front>
<front id="ultralcdCPP-421">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-422">#ifdef SDSUPPORT</front>
<front id="ultralcdCPP-423">    //MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);</front>
<front id="ultralcdCPP-424">#endif</front>
<front id="ultralcdCPP-425">    MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));</front>
<front id="ultralcdCPP-426">    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));</front>
<front id="ultralcdCPP-427">    //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));</front>
<front id="ultralcdCPP-428">    MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla);</front>
<front id="ultralcdCPP-429">    MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs);</front>
<front id="ultralcdCPP-430">    MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);</front>
<front id="ultralcdCPP-431">#if PS_ON_PIN &gt; -1</front>
<front id="ultralcdCPP-432">    if (powersupply)</front>
<front id="ultralcdCPP-433">    {</front>
<front id="ultralcdCPP-434">        MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));</front>
<front id="ultralcdCPP-435">    }else{</front>
<front id="ultralcdCPP-436">        MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));</front>
<front id="ultralcdCPP-437">    }</front>
<front id="ultralcdCPP-438">#endif</front>
<front id="ultralcdCPP-439">    MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);</front>
<front id="ultralcdCPP-440">    END_MENU();</front>
<front id="ultralcdCPP-441">}</front>
<front id="ultralcdCPP-442"></front>
<front id="ultralcdCPP-443">float move_menu_scale;</front>
<front id="ultralcdCPP-444">static void lcd_move_menu_axis();</front>
<front id="ultralcdCPP-445"></front>
<front id="ultralcdCPP-446">static void lcd_move_x()</front>
<front id="ultralcdCPP-447">{</front>
<front id="ultralcdCPP-448">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-449">    {</front>
<front id="ultralcdCPP-450">        current_position[X_AXIS] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-451">        if (min_software_endstops && current_position[X_AXIS] &lt; X_MIN_POS)</front>
<front id="ultralcdCPP-452">            current_position[X_AXIS] = X_MIN_POS;</front>
<front id="ultralcdCPP-453">        if (max_software_endstops && current_position[X_AXIS] &gt; X_MAX_POS)</front>
<front id="ultralcdCPP-454">            current_position[X_AXIS] = X_MAX_POS;</front>
<front id="ultralcdCPP-455">        encoderPosition = 0;</front>
<front id="ultralcdCPP-456">        #ifdef DELTA</front>
<front id="ultralcdCPP-457">        calculate_delta(current_position);</front>
<front id="ultralcdCPP-458">        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[X_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-459">        #else</front>
<front id="ultralcdCPP-460">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[X_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-461">        #endif</front>
<front id="ultralcdCPP-462">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-463">    }</front>
<front id="ultralcdCPP-464">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-465">    {</front>
<front id="ultralcdCPP-466">        lcd_implementation_drawedit(PSTR("X"), ftostr31(current_position[X_AXIS]));</front>
<front id="ultralcdCPP-467">    }</front>
<front id="ultralcdCPP-468">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-469">    {</front>
<front id="ultralcdCPP-470">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-471">        currentMenu = lcd_move_menu_axis;</front>
<front id="ultralcdCPP-472">        encoderPosition = 0;</front>
<front id="ultralcdCPP-473">    }</front>
<front id="ultralcdCPP-474">}</front>
<front id="ultralcdCPP-475">static void lcd_move_y()</front>
<front id="ultralcdCPP-476">{</front>
<front id="ultralcdCPP-477">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-478">    {</front>
<front id="ultralcdCPP-479">        current_position[Y_AXIS] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-480">        if (min_software_endstops && current_position[Y_AXIS] &lt; Y_MIN_POS)</front>
<front id="ultralcdCPP-481">            current_position[Y_AXIS] = Y_MIN_POS;</front>
<front id="ultralcdCPP-482">        if (max_software_endstops && current_position[Y_AXIS] &gt; Y_MAX_POS)</front>
<front id="ultralcdCPP-483">            current_position[Y_AXIS] = Y_MAX_POS;</front>
<front id="ultralcdCPP-484">        encoderPosition = 0;</front>
<front id="ultralcdCPP-485">        #ifdef DELTA</front>
<front id="ultralcdCPP-486">        calculate_delta(current_position);</front>
<front id="ultralcdCPP-487">        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[Y_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-488">        #else</front>
<front id="ultralcdCPP-489">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[Y_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-490">        #endif</front>
<front id="ultralcdCPP-491">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-492">    }</front>
<front id="ultralcdCPP-493">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-494">    {</front>
<front id="ultralcdCPP-495">        lcd_implementation_drawedit(PSTR("Y"), ftostr31(current_position[Y_AXIS]));</front>
<front id="ultralcdCPP-496">    }</front>
<front id="ultralcdCPP-497">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-498">    {</front>
<front id="ultralcdCPP-499">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-500">        currentMenu = lcd_move_menu_axis;</front>
<front id="ultralcdCPP-501">        encoderPosition = 0;</front>
<front id="ultralcdCPP-502">    }</front>
<front id="ultralcdCPP-503">}</front>
<front id="ultralcdCPP-504">static void lcd_move_z()</front>
<front id="ultralcdCPP-505">{</front>
<front id="ultralcdCPP-506">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-507">    {</front>
<front id="ultralcdCPP-508">        current_position[Z_AXIS] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-509">        if (min_software_endstops && current_position[Z_AXIS] &lt; Z_MIN_POS)</front>
<front id="ultralcdCPP-510">            current_position[Z_AXIS] = Z_MIN_POS;</front>
<front id="ultralcdCPP-511">        if (max_software_endstops && current_position[Z_AXIS] &gt; Z_MAX_POS)</front>
<front id="ultralcdCPP-512">            current_position[Z_AXIS] = Z_MAX_POS;</front>
<front id="ultralcdCPP-513">        encoderPosition = 0;</front>
<front id="ultralcdCPP-514">        #ifdef DELTA</front>
<front id="ultralcdCPP-515">        calculate_delta(current_position);</front>
<front id="ultralcdCPP-516">        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[Z_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-517">        #else</front>
<front id="ultralcdCPP-518">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[Z_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-519">        #endif</front>
<front id="ultralcdCPP-520">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-521">    }</front>
<front id="ultralcdCPP-522">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-523">    {</front>
<front id="ultralcdCPP-524">        lcd_implementation_drawedit(PSTR("Z"), ftostr31(current_position[Z_AXIS]));</front>
<front id="ultralcdCPP-525">    }</front>
<front id="ultralcdCPP-526">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-527">    {</front>
<front id="ultralcdCPP-528">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-529">        currentMenu = lcd_move_menu_axis;</front>
<front id="ultralcdCPP-530">        encoderPosition = 0;</front>
<front id="ultralcdCPP-531">    }</front>
<front id="ultralcdCPP-532">}</front>
<front id="ultralcdCPP-533">static void lcd_move_e()</front>
<front id="ultralcdCPP-534">{</front>
<front id="ultralcdCPP-535">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-536">    {</front>
<front id="ultralcdCPP-537">        current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-538">        encoderPosition = 0;</front>
<front id="ultralcdCPP-539">        #ifdef DELTA</front>
<front id="ultralcdCPP-540">        calculate_delta(current_position);</front>
<front id="ultralcdCPP-541">        plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-542">        #else</front>
<front id="ultralcdCPP-543">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[E_AXIS]/60, active_extruder);</front>
<front id="ultralcdCPP-544">        #endif</front>
<front id="ultralcdCPP-545">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-546">    }</front>
<front id="ultralcdCPP-547">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-548">    {</front>
<front id="ultralcdCPP-549">        lcd_implementation_drawedit(PSTR("Extruder"), ftostr31(current_position[E_AXIS]));</front>
<front id="ultralcdCPP-550">    }</front>
<front id="ultralcdCPP-551">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-552">    {</front>
<front id="ultralcdCPP-553">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-554">        currentMenu = lcd_move_menu_axis;</front>
<front id="ultralcdCPP-555">        encoderPosition = 0;</front>
<front id="ultralcdCPP-556">    }</front>
<front id="ultralcdCPP-557">}</front>
<front id="ultralcdCPP-558"></front>
<front id="ultralcdCPP-559">static void lcd_move_menu_axis()</front>
<front id="ultralcdCPP-560">{</front>
<front id="ultralcdCPP-561">    START_MENU();</front>
<front id="ultralcdCPP-562">    MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);</front>
<front id="ultralcdCPP-563">    MENU_ITEM(submenu, "Move X", lcd_move_x);</front>
<front id="ultralcdCPP-564">    MENU_ITEM(submenu, "Move Y", lcd_move_y);</front>
<front id="ultralcdCPP-565">    if (move_menu_scale &lt; 10.0)</front>
<front id="ultralcdCPP-566">    {</front>
<front id="ultralcdCPP-567">        MENU_ITEM(submenu, "Move Z", lcd_move_z);</front>
<front id="ultralcdCPP-568">        MENU_ITEM(submenu, "Extruder", lcd_move_e);</front>
<front id="ultralcdCPP-569">    }</front>
<front id="ultralcdCPP-570">    END_MENU();</front>
<front id="ultralcdCPP-571">}</front>
<front id="ultralcdCPP-572"></front>
<front id="ultralcdCPP-573">static void lcd_move_menu_10mm()</front>
<front id="ultralcdCPP-574">{</front>
<front id="ultralcdCPP-575">    move_menu_scale = 10.0;</front>
<front id="ultralcdCPP-576">    lcd_move_menu_axis();</front>
<front id="ultralcdCPP-577">}</front>
<front id="ultralcdCPP-578">static void lcd_move_menu_1mm()</front>
<front id="ultralcdCPP-579">{</front>
<front id="ultralcdCPP-580">    move_menu_scale = 1.0;</front>
<front id="ultralcdCPP-581">    lcd_move_menu_axis();</front>
<front id="ultralcdCPP-582">}</front>
<front id="ultralcdCPP-583">static void lcd_move_menu_01mm()</front>
<front id="ultralcdCPP-584">{</front>
<front id="ultralcdCPP-585">    move_menu_scale = 0.1;</front>
<front id="ultralcdCPP-586">    lcd_move_menu_axis();</front>
<front id="ultralcdCPP-587">}</front>
<front id="ultralcdCPP-588"></front>
<front id="ultralcdCPP-589">static void lcd_move_menu()</front>
<front id="ultralcdCPP-590">{</front>
<front id="ultralcdCPP-591">    START_MENU();</front>
<front id="ultralcdCPP-592">    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-593">    MENU_ITEM(submenu, "Move 10mm", lcd_move_menu_10mm);</front>
<front id="ultralcdCPP-594">    MENU_ITEM(submenu, "Move 1mm", lcd_move_menu_1mm);</front>
<front id="ultralcdCPP-595">    MENU_ITEM(submenu, "Move 0.1mm", lcd_move_menu_01mm);</front>
<front id="ultralcdCPP-596">    //TODO:X,Y,Z,E</front>
<front id="ultralcdCPP-597">    END_MENU();</front>
<front id="ultralcdCPP-598">}</front>
<front id="ultralcdCPP-599"></front>
<front id="ultralcdCPP-600">static void lcd_control_menu()</front>
<front id="ultralcdCPP-601">{</front>
<front id="ultralcdCPP-602">    START_MENU();</front>
<front id="ultralcdCPP-603">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-604">    MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-605">    MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);</front>
<front id="ultralcdCPP-606">#ifdef DOGLCD</front>
<front id="ultralcdCPP-607">//    MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);</front>
<front id="ultralcdCPP-608">    MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);</front>
<front id="ultralcdCPP-609">#endif</front>
<front id="ultralcdCPP-610">#ifdef FWRETRACT</front>
<front id="ultralcdCPP-611">    MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);</front>
<front id="ultralcdCPP-612">#endif</front>
<front id="ultralcdCPP-613">#ifdef EEPROM_SETTINGS</front>
<front id="ultralcdCPP-614">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-615">    MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);</front>
<front id="ultralcdCPP-616">#endif</front>
<front id="ultralcdCPP-617">    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);</front>
<front id="ultralcdCPP-618">    END_MENU();</front>
<front id="ultralcdCPP-619">}</front>
<front id="ultralcdCPP-620"></front>
<front id="ultralcdCPP-621">static void lcd_control_temperature_menu()</front>
<front id="ultralcdCPP-622">{</front>
<front id="ultralcdCPP-623">#ifdef PIDTEMP</front>
<front id="ultralcdCPP-624">    // set up temp variables - undo the default scaling</front>
<front id="ultralcdCPP-625">    raw_Ki = unscalePID_i(Ki);</front>
<front id="ultralcdCPP-626">    raw_Kd = unscalePID_d(Kd);</front>
<front id="ultralcdCPP-627">#endif</front>
<front id="ultralcdCPP-628"></front>
<front id="ultralcdCPP-629">    START_MENU();</front>
<front id="ultralcdCPP-630">    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-631">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-632">#if TEMP_SENSOR_1 != 0</front>
<front id="ultralcdCPP-633">    MENU_ITEM_EDIT(int3, MSG_NOZZLE1, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);</front>
<front id="ultralcdCPP-634">#endif</front>
<front id="ultralcdCPP-635">#if TEMP_SENSOR_2 != 0</front>
<front id="ultralcdCPP-636">    MENU_ITEM_EDIT(int3, MSG_NOZZLE2, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);</front>
<front id="ultralcdCPP-637">#endif</front>
<front id="ultralcdCPP-638">#if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-639">    MENU_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-640">#endif</front>
<front id="ultralcdCPP-641">    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);</front>
<front id="ultralcdCPP-642">#ifdef AUTOTEMP</front>
<front id="ultralcdCPP-643">    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);</front>
<front id="ultralcdCPP-644">    MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-645">    MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-646">    MENU_ITEM_EDIT(float32, MSG_FACTOR, &autotemp_factor, 0.0, 1.0);</front>
<front id="ultralcdCPP-647">#endif</front>
<front id="ultralcdCPP-648">#ifdef PIDTEMP</front>
<front id="ultralcdCPP-649">    MENU_ITEM_EDIT(float52, MSG_PID_P, &Kp, 1, 9990);</front>
<front id="ultralcdCPP-650">    // i is typically a small value so allows values below 1</front>
<front id="ultralcdCPP-651">    MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I, &raw_Ki, 0.01, 9990, copy_and_scalePID_i);</front>
<front id="ultralcdCPP-652">    MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D, &raw_Kd, 1, 9990, copy_and_scalePID_d);</front>
<front id="ultralcdCPP-653"># ifdef PID_ADD_EXTRUSION_RATE</front>
<front id="ultralcdCPP-654">    MENU_ITEM_EDIT(float3, MSG_PID_C, &Kc, 1, 9990);</front>
<front id="ultralcdCPP-655"># endif//PID_ADD_EXTRUSION_RATE</front>
<front id="ultralcdCPP-656">#endif//PIDTEMP</front>
<front id="ultralcdCPP-657">    MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);</front>
<front id="ultralcdCPP-658">    MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);</front>
<front id="ultralcdCPP-659">    END_MENU();</front>
<front id="ultralcdCPP-660">}</front>
<front id="ultralcdCPP-661"></front>
<front id="ultralcdCPP-662">static void lcd_control_temperature_preheat_pla_settings_menu()</front>
<front id="ultralcdCPP-663">{</front>
<front id="ultralcdCPP-664">    START_MENU();</front>
<front id="ultralcdCPP-665">    MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-666">    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);</front>
<front id="ultralcdCPP-667">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-668">#if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-669">    MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-670">#endif</front>
<front id="ultralcdCPP-671">#ifdef EEPROM_SETTINGS</front>
<front id="ultralcdCPP-672">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-673">#endif</front>
<front id="ultralcdCPP-674">    END_MENU();</front>
<front id="ultralcdCPP-675">}</front>
<front id="ultralcdCPP-676"></front>
<front id="ultralcdCPP-677">static void lcd_control_temperature_preheat_abs_settings_menu()</front>
<front id="ultralcdCPP-678">{</front>
<front id="ultralcdCPP-679">    START_MENU();</front>
<front id="ultralcdCPP-680">    MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-681">    MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);</front>
<front id="ultralcdCPP-682">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-683">#if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-684">    MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-685">#endif</front>
<front id="ultralcdCPP-686">#ifdef EEPROM_SETTINGS</front>
<front id="ultralcdCPP-687">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-688">#endif</front>
<front id="ultralcdCPP-689">    END_MENU();</front>
<front id="ultralcdCPP-690">}</front>
<front id="ultralcdCPP-691"></front>
<front id="ultralcdCPP-692">static void lcd_control_motion_menu()</front>
<front id="ultralcdCPP-693">{</front>
<front id="ultralcdCPP-694">    START_MENU();</front>
<front id="ultralcdCPP-695">    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-696">    MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 500, 99000);</front>
<front id="ultralcdCPP-697">    MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);</front>
<front id="ultralcdCPP-698">    MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);</front>
<front id="ultralcdCPP-699">    MENU_ITEM_EDIT(float3, MSG_VE_JERK, &max_e_jerk, 1, 990);</front>
<front id="ultralcdCPP-700">    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &max_feedrate[X_AXIS], 1, 999);</front>
<front id="ultralcdCPP-701">    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &max_feedrate[Y_AXIS], 1, 999);</front>
<front id="ultralcdCPP-702">    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &max_feedrate[Z_AXIS], 1, 999);</front>
<front id="ultralcdCPP-703">    MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &max_feedrate[E_AXIS], 1, 999);</front>
<front id="ultralcdCPP-704">    MENU_ITEM_EDIT(float3, MSG_VMIN, &minimumfeedrate, 0, 999);</front>
<front id="ultralcdCPP-705">    MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &mintravelfeedrate, 0, 999);</front>
<front id="ultralcdCPP-706">    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-707">    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-708">    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-709">    MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-710">    MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &retract_acceleration, 100, 99000);</front>
<front id="ultralcdCPP-711">    MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-712">    MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-713">    MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-714">    MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);    </front>
<front id="ultralcdCPP-715">#ifdef ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="ultralcdCPP-716">    MENU_ITEM_EDIT(bool, "Endstop abort", &abort_on_endstop_hit);</front>
<front id="ultralcdCPP-717">#endif</front>
<front id="ultralcdCPP-718">    END_MENU();</front>
<front id="ultralcdCPP-719">}</front>
<front id="ultralcdCPP-720"></front>
<front id="ultralcdCPP-721">#ifdef DOGLCD</front>
<front id="ultralcdCPP-722">static void lcd_set_contrast()</front>
<front id="ultralcdCPP-723">{</front>
<front id="ultralcdCPP-724">    if (encoderPosition != 0)</front>
<front id="ultralcdCPP-725">    {</front>
<front id="ultralcdCPP-726">        lcd_contrast -= encoderPosition;</front>
<front id="ultralcdCPP-727">        if (lcd_contrast &lt; 0) lcd_contrast = 0;</front>
<front id="ultralcdCPP-728">        else if (lcd_contrast &gt; 63) lcd_contrast = 63;</front>
<front id="ultralcdCPP-729">        encoderPosition = 0;</front>
<front id="ultralcdCPP-730">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-731">        u8g.setContrast(lcd_contrast);</front>
<front id="ultralcdCPP-732">    }</front>
<front id="ultralcdCPP-733">    if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-734">    {</front>
<front id="ultralcdCPP-735">        lcd_implementation_drawedit(PSTR("Contrast"), itostr2(lcd_contrast));</front>
<front id="ultralcdCPP-736">    }</front>
<front id="ultralcdCPP-737">    if (LCD_CLICKED)</front>
<front id="ultralcdCPP-738">    {</front>
<front id="ultralcdCPP-739">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-740">        currentMenu = lcd_control_menu;</front>
<front id="ultralcdCPP-741">        encoderPosition = 0;</front>
<front id="ultralcdCPP-742">    }</front>
<front id="ultralcdCPP-743">}</front>
<front id="ultralcdCPP-744">#endif</front>
<front id="ultralcdCPP-745"></front>
<front id="ultralcdCPP-746">#ifdef FWRETRACT</front>
<front id="ultralcdCPP-747">static void lcd_control_retract_menu()</front>
<front id="ultralcdCPP-748">{</front>
<front id="ultralcdCPP-749">    START_MENU();</front>
<front id="ultralcdCPP-750">    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-751">    MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);</front>
<front id="ultralcdCPP-752">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);</front>
<front id="ultralcdCPP-753">    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);</front>
<front id="ultralcdCPP-754">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);</front>
<front id="ultralcdCPP-755">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);</front>
<front id="ultralcdCPP-756">    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);</front>
<front id="ultralcdCPP-757">    END_MENU();</front>
<front id="ultralcdCPP-758">}</front>
<front id="ultralcdCPP-759">#endif</front>
<front id="ultralcdCPP-760"></front>
<front id="ultralcdCPP-761">#if SDCARDDETECT == -1</front>
<front id="ultralcdCPP-762">static void lcd_sd_refresh()</front>
<front id="ultralcdCPP-763">{</front>
<front id="ultralcdCPP-764">    card.initsd();</front>
<front id="ultralcdCPP-765">    currentMenuViewOffset = 0;</front>
<front id="ultralcdCPP-766">}</front>
<front id="ultralcdCPP-767">#endif</front>
<front id="ultralcdCPP-768">static void lcd_sd_updir()</front>
<front id="ultralcdCPP-769">{</front>
<front id="ultralcdCPP-770">    card.updir();</front>
<front id="ultralcdCPP-771">    currentMenuViewOffset = 0;</front>
<front id="ultralcdCPP-772">}</front>
<front id="ultralcdCPP-773"></front>
<front id="ultralcdCPP-774">void lcd_sdcard_menu()</front>
<front id="ultralcdCPP-775">{</front>
<front id="ultralcdCPP-776">    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) </front>
<front id="ultralcdCPP-777">        return;	// nothing to do (so don't thrash the SD card)</front>
<front id="ultralcdCPP-778">    uint16_t fileCnt = card.getnrfilenames();</front>
<front id="ultralcdCPP-779">    START_MENU();</front>
<front id="ultralcdCPP-780">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-781">    card.getWorkDirName();</front>
<front id="ultralcdCPP-782">    if(card.filename[0]=='/')</front>
<front id="ultralcdCPP-783">    {</front>
<front id="ultralcdCPP-784">#if SDCARDDETECT == -1</front>
<front id="ultralcdCPP-785">        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);</front>
<front id="ultralcdCPP-786">#endif</front>
<front id="ultralcdCPP-787">    }else{</front>
<front id="ultralcdCPP-788">        MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);</front>
<front id="ultralcdCPP-789">    }</front>
<front id="ultralcdCPP-790">    </front>
<front id="ultralcdCPP-791">    for(uint16_t i=0;i&lt;fileCnt;i++)</front>
<front id="ultralcdCPP-792">    {</front>
<front id="ultralcdCPP-793">        if (_menuItemNr == _lineNr)</front>
<front id="ultralcdCPP-794">        {</front>
<front id="ultralcdCPP-795">            card.getfilename(i);</front>
<front id="ultralcdCPP-796">            if (card.filenameIsDir)</front>
<front id="ultralcdCPP-797">            {</front>
<front id="ultralcdCPP-798">                MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);</front>
<front id="ultralcdCPP-799">            }else{</front>
<front id="ultralcdCPP-800">                MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);</front>
<front id="ultralcdCPP-801">            }</front>
<front id="ultralcdCPP-802">        }else{</front>
<front id="ultralcdCPP-803">            MENU_ITEM_DUMMY();</front>
<front id="ultralcdCPP-804">        }</front>
<front id="ultralcdCPP-805">    }</front>
<front id="ultralcdCPP-806">    END_MENU();</front>
<front id="ultralcdCPP-807">}</front>
<front id="ultralcdCPP-808"></front>
<front id="ultralcdCPP-809">#define menu_edit_type(_type, _name, _strFunc, scale) \</front>
<front id="ultralcdCPP-810">    void menu_edit_ ## _name () \</front>
<front id="ultralcdCPP-811">    { \</front>
<front id="ultralcdCPP-812">        if ((int32_t)encoderPosition &lt; minEditValue) \</front>
<front id="ultralcdCPP-813">            encoderPosition = minEditValue; \</front>
<front id="ultralcdCPP-814">        if ((int32_t)encoderPosition &gt; maxEditValue) \</front>
<front id="ultralcdCPP-815">            encoderPosition = maxEditValue; \</front>
<front id="ultralcdCPP-816">        if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-817">            lcd_implementation_drawedit(editLabel, _strFunc(((_type)encoderPosition) / scale)); \</front>
<front id="ultralcdCPP-818">        if (LCD_CLICKED) \</front>
<front id="ultralcdCPP-819">        { \</front>
<front id="ultralcdCPP-820">            *((_type*)editValue) = ((_type)encoderPosition) / scale; \</front>
<front id="ultralcdCPP-821">            lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-822">            currentMenu = prevMenu; \</front>
<front id="ultralcdCPP-823">            encoderPosition = prevEncoderPosition; \</front>
<front id="ultralcdCPP-824">        } \</front>
<front id="ultralcdCPP-825">    } \</front>
<front id="ultralcdCPP-826">    void menu_edit_callback_ ## _name () \</front>
<front id="ultralcdCPP-827">    { \</front>
<front id="ultralcdCPP-828">        if ((int32_t)encoderPosition &lt; minEditValue) \</front>
<front id="ultralcdCPP-829">            encoderPosition = minEditValue; \</front>
<front id="ultralcdCPP-830">        if ((int32_t)encoderPosition &gt; maxEditValue) \</front>
<front id="ultralcdCPP-831">            encoderPosition = maxEditValue; \</front>
<front id="ultralcdCPP-832">        if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-833">            lcd_implementation_drawedit(editLabel, _strFunc(((_type)encoderPosition) / scale)); \</front>
<front id="ultralcdCPP-834">        if (LCD_CLICKED) \</front>
<front id="ultralcdCPP-835">        { \</front>
<front id="ultralcdCPP-836">            *((_type*)editValue) = ((_type)encoderPosition) / scale; \</front>
<front id="ultralcdCPP-837">            lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-838">            currentMenu = prevMenu; \</front>
<front id="ultralcdCPP-839">            encoderPosition = prevEncoderPosition; \</front>
<front id="ultralcdCPP-840">            (*callbackFunc)();\</front>
<front id="ultralcdCPP-841">        } \</front>
<front id="ultralcdCPP-842">    } \</front>
<front id="ultralcdCPP-843">    static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) \</front>
<front id="ultralcdCPP-844">    { \</front>
<front id="ultralcdCPP-845">        prevMenu = currentMenu; \</front>
<front id="ultralcdCPP-846">        prevEncoderPosition = encoderPosition; \</front>
<front id="ultralcdCPP-847">         \</front>
<front id="ultralcdCPP-848">        lcdDrawUpdate = 2; \</front>
<front id="ultralcdCPP-849">        currentMenu = menu_edit_ ## _name; \</front>
<front id="ultralcdCPP-850">         \</front>
<front id="ultralcdCPP-851">        editLabel = pstr; \</front>
<front id="ultralcdCPP-852">        editValue = ptr; \</front>
<front id="ultralcdCPP-853">        minEditValue = minValue * scale; \</front>
<front id="ultralcdCPP-854">        maxEditValue = maxValue * scale; \</front>
<front id="ultralcdCPP-855">        encoderPosition = (*ptr) * scale; \</front>
<front id="ultralcdCPP-856">    }\</front>
<front id="ultralcdCPP-857">    static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) \</front>
<front id="ultralcdCPP-858">    { \</front>
<front id="ultralcdCPP-859">        prevMenu = currentMenu; \</front>
<front id="ultralcdCPP-860">        prevEncoderPosition = encoderPosition; \</front>
<front id="ultralcdCPP-861">         \</front>
<front id="ultralcdCPP-862">        lcdDrawUpdate = 2; \</front>
<front id="ultralcdCPP-863">        currentMenu = menu_edit_callback_ ## _name; \</front>
<front id="ultralcdCPP-864">         \</front>
<front id="ultralcdCPP-865">        editLabel = pstr; \</front>
<front id="ultralcdCPP-866">        editValue = ptr; \</front>
<front id="ultralcdCPP-867">        minEditValue = minValue * scale; \</front>
<front id="ultralcdCPP-868">        maxEditValue = maxValue * scale; \</front>
<front id="ultralcdCPP-869">        encoderPosition = (*ptr) * scale; \</front>
<front id="ultralcdCPP-870">        callbackFunc = callback;\</front>
<front id="ultralcdCPP-871">    }</front>
<front id="ultralcdCPP-872">menu_edit_type(int, int3, itostr3, 1)</front>
<front id="ultralcdCPP-873">menu_edit_type(float, float3, ftostr3, 1)</front>
<front id="ultralcdCPP-874">menu_edit_type(float, float32, ftostr32, 100)</front>
<front id="ultralcdCPP-875">menu_edit_type(float, float5, ftostr5, 0.01)</front>
<front id="ultralcdCPP-876">menu_edit_type(float, float51, ftostr51, 10)</front>
<front id="ultralcdCPP-877">menu_edit_type(float, float52, ftostr52, 100)</front>
<front id="ultralcdCPP-878">menu_edit_type(unsigned long, long5, ftostr5, 0.01)</front>
<front id="ultralcdCPP-879"></front>
<front id="ultralcdCPP-880">#ifdef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-881">	static void reprapworld_keypad_move_z_up() {</front>
<front id="ultralcdCPP-882">    encoderPosition = 1;</front>
<front id="ultralcdCPP-883">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-884">		lcd_move_z();</front>
<front id="ultralcdCPP-885">  }</front>
<front id="ultralcdCPP-886">	static void reprapworld_keypad_move_z_down() {</front>
<front id="ultralcdCPP-887">    encoderPosition = -1;</front>
<front id="ultralcdCPP-888">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-889">		lcd_move_z();</front>
<front id="ultralcdCPP-890">  }</front>
<front id="ultralcdCPP-891">	static void reprapworld_keypad_move_x_left() {</front>
<front id="ultralcdCPP-892">    encoderPosition = -1;</front>
<front id="ultralcdCPP-893">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-894">		lcd_move_x();</front>
<front id="ultralcdCPP-895">  }</front>
<front id="ultralcdCPP-896">	static void reprapworld_keypad_move_x_right() {</front>
<front id="ultralcdCPP-897">    encoderPosition = 1;</front>
<front id="ultralcdCPP-898">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-899">		lcd_move_x();</front>
<front id="ultralcdCPP-900">	}</front>
<front id="ultralcdCPP-901">	static void reprapworld_keypad_move_y_down() {</front>
<front id="ultralcdCPP-902">    encoderPosition = 1;</front>
<front id="ultralcdCPP-903">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-904">		lcd_move_y();</front>
<front id="ultralcdCPP-905">	}</front>
<front id="ultralcdCPP-906">	static void reprapworld_keypad_move_y_up() {</front>
<front id="ultralcdCPP-907">		encoderPosition = -1;</front>
<front id="ultralcdCPP-908">		move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-909">    lcd_move_y();</front>
<front id="ultralcdCPP-910">	}</front>
<front id="ultralcdCPP-911">	static void reprapworld_keypad_move_home() {</front>
<front id="ultralcdCPP-912">		enquecommand_P((PSTR("G28"))); // move all axis home</front>
<front id="ultralcdCPP-913">	}</front>
<front id="ultralcdCPP-914">#endif</front>
<front id="ultralcdCPP-915"></front>
<front id="ultralcdCPP-916">/** End of menus **/</front>
<front id="ultralcdCPP-917"></front>
<front id="ultralcdCPP-918">static void lcd_quick_feedback()</front>
<front id="ultralcdCPP-919">{</front>
<front id="ultralcdCPP-920">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-921">    blocking_enc = millis() + 500;</front>
<front id="ultralcdCPP-922">    lcd_implementation_quick_feedback();</front>
<front id="ultralcdCPP-923">}</front>
<front id="ultralcdCPP-924"></front>
<front id="ultralcdCPP-925">/** Menu action functions **/</front>
<front id="ultralcdCPP-926">static void menu_action_back(menuFunc_t data)</front>
<front id="ultralcdCPP-927">{</front>
<front id="ultralcdCPP-928">    currentMenu = data;</front>
<front id="ultralcdCPP-929">    encoderPosition = 0;</front>
<front id="ultralcdCPP-930">}</front>
<front id="ultralcdCPP-931">static void menu_action_submenu(menuFunc_t data)</front>
<front id="ultralcdCPP-932">{</front>
<front id="ultralcdCPP-933">    currentMenu = data;</front>
<front id="ultralcdCPP-934">    encoderPosition = 0;</front>
<front id="ultralcdCPP-935">}</front>
<front id="ultralcdCPP-936">static void menu_action_gcode(const char* pgcode)</front>
<front id="ultralcdCPP-937">{</front>
<front id="ultralcdCPP-938">    enquecommand_P(pgcode);</front>
<front id="ultralcdCPP-939">}</front>
<front id="ultralcdCPP-940">static void menu_action_function(menuFunc_t data)</front>
<front id="ultralcdCPP-941">{</front>
<front id="ultralcdCPP-942">    (*data)();</front>
<front id="ultralcdCPP-943">}</front>
<front id="ultralcdCPP-944">static void menu_action_sdfile(const char* filename, char* longFilename)</front>
<front id="ultralcdCPP-945">{</front>
<front id="ultralcdCPP-946">    char cmd[30];</front>
<front id="ultralcdCPP-947">    char* c;</front>
<front id="ultralcdCPP-948">    sprintf_P(cmd, PSTR("M23 %s"), filename);</front>
<front id="ultralcdCPP-949">    for(c = &cmd[4]; *c; c++)</front>
<front id="ultralcdCPP-950">        *c = tolower(*c);</front>
<front id="ultralcdCPP-951">    enquecommand(cmd);</front>
<front id="ultralcdCPP-952">    enquecommand_P(PSTR("M24"));</front>
<front id="ultralcdCPP-953">    lcd_return_to_status();</front>
<front id="ultralcdCPP-954">}</front>
<front id="ultralcdCPP-955">static void menu_action_sddirectory(const char* filename, char* longFilename)</front>
<front id="ultralcdCPP-956">{</front>
<front id="ultralcdCPP-957">    card.chdir(filename);</front>
<front id="ultralcdCPP-958">    encoderPosition = 0;</front>
<front id="ultralcdCPP-959">}</front>
<front id="ultralcdCPP-960">static void menu_action_setting_edit_bool(const char* pstr, bool* ptr)</front>
<front id="ultralcdCPP-961">{</front>
<front id="ultralcdCPP-962">    *ptr = !(*ptr);</front>
<front id="ultralcdCPP-963">}</front>
<front id="ultralcdCPP-964">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-965"></front>
<front id="ultralcdCPP-966">/** LCD API **/</front>
<front id="ultralcdCPP-967">void lcd_init()</front>
<front id="ultralcdCPP-968">{</front>
<front id="ultralcdCPP-969">    lcd_implementation_init();</front>
<front id="ultralcdCPP-970"></front>
<front id="ultralcdCPP-971">#ifdef NEWPANEL</front>
<front id="ultralcdCPP-972">    pinMode(BTN_EN1,INPUT);</front>
<front id="ultralcdCPP-973">    pinMode(BTN_EN2,INPUT); </front>
<front id="ultralcdCPP-974">    pinMode(SDCARDDETECT,INPUT);</front>
<front id="ultralcdCPP-975">    WRITE(BTN_EN1,HIGH);</front>
<front id="ultralcdCPP-976">    WRITE(BTN_EN2,HIGH);</front>
<front id="ultralcdCPP-977">  #if BTN_ENC &gt; 0</front>
<front id="ultralcdCPP-978">    pinMode(BTN_ENC,INPUT); </front>
<front id="ultralcdCPP-979">    WRITE(BTN_ENC,HIGH);</front>
<front id="ultralcdCPP-980">  #endif    </front>
<front id="ultralcdCPP-981">  #ifdef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-982">    pinMode(SHIFT_CLK,OUTPUT);</front>
<front id="ultralcdCPP-983">    pinMode(SHIFT_LD,OUTPUT);</front>
<front id="ultralcdCPP-984">    pinMode(SHIFT_OUT,INPUT);</front>
<front id="ultralcdCPP-985">    WRITE(SHIFT_OUT,HIGH);</front>
<front id="ultralcdCPP-986">    WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-987">  #endif</front>
<front id="ultralcdCPP-988">#else</front>
<front id="ultralcdCPP-989">    pinMode(SHIFT_CLK,OUTPUT);</front>
<front id="ultralcdCPP-990">    pinMode(SHIFT_LD,OUTPUT);</front>
<front id="ultralcdCPP-991">    pinMode(SHIFT_EN,OUTPUT);</front>
<front id="ultralcdCPP-992">    pinMode(SHIFT_OUT,INPUT);</front>
<front id="ultralcdCPP-993">    WRITE(SHIFT_OUT,HIGH);</front>
<front id="ultralcdCPP-994">    WRITE(SHIFT_LD,HIGH); </front>
<front id="ultralcdCPP-995">    WRITE(SHIFT_EN,LOW);</front>
<front id="ultralcdCPP-996">#endif//!NEWPANEL</front>
<front id="ultralcdCPP-997">#if (SDCARDDETECT &gt; 0)</front>
<front id="ultralcdCPP-998">    WRITE(SDCARDDETECT, HIGH);</front>
<front id="ultralcdCPP-999">    lcd_oldcardstatus = IS_SD_INSERTED;</front>
<front id="ultralcdCPP-1000">#endif//(SDCARDDETECT &gt; 0)</front>
<front id="ultralcdCPP-1001">    lcd_buttons_update();</front>
<front id="ultralcdCPP-1002">#ifdef ULTIPANEL    </front>
<front id="ultralcdCPP-1003">    encoderDiff = 0;</front>
<front id="ultralcdCPP-1004">#endif    </front>
<front id="ultralcdCPP-1005">}</front>
<front id="ultralcdCPP-1006"></front>
<front id="ultralcdCPP-1007">void lcd_update()</front>
<front id="ultralcdCPP-1008">{</front>
<front id="ultralcdCPP-1009">    static unsigned long timeoutToStatus = 0;</front>
<front id="ultralcdCPP-1010">    </front>
<front id="ultralcdCPP-1011">    lcd_buttons_update();</front>
<front id="ultralcdCPP-1012">    </front>
<front id="ultralcdCPP-1013">    #ifdef LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcdCPP-1014">    buttons |= lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context</front>
<front id="ultralcdCPP-1015">    #endif</front>
<front id="ultralcdCPP-1016">    </front>
<front id="ultralcdCPP-1017">    #if (SDCARDDETECT &gt; 0)</front>
<front id="ultralcdCPP-1018">    if((IS_SD_INSERTED != lcd_oldcardstatus))</front>
<front id="ultralcdCPP-1019">    {</front>
<front id="ultralcdCPP-1020">        lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1021">        lcd_oldcardstatus = IS_SD_INSERTED;</front>
<front id="ultralcdCPP-1022">        lcd_implementation_init(); // to maybe revive the lcd if static electricty killed it.</front>
<front id="ultralcdCPP-1023">        </front>
<front id="ultralcdCPP-1024">        if(lcd_oldcardstatus)</front>
<front id="ultralcdCPP-1025">        {</front>
<front id="ultralcdCPP-1026">            card.initsd();</front>
<front id="ultralcdCPP-1027">            LCD_MESSAGEPGM(MSG_SD_INSERTED);</front>
<front id="ultralcdCPP-1028">        }</front>
<front id="ultralcdCPP-1029">        else</front>
<front id="ultralcdCPP-1030">        {</front>
<front id="ultralcdCPP-1031">            card.release();</front>
<front id="ultralcdCPP-1032">            LCD_MESSAGEPGM(MSG_SD_REMOVED);</front>
<front id="ultralcdCPP-1033">        }</front>
<front id="ultralcdCPP-1034">    }</front>
<front id="ultralcdCPP-1035">    #endif//CARDINSERTED</front>
<front id="ultralcdCPP-1036">    </front>
<front id="ultralcdCPP-1037">    if (lcd_next_update_millis &lt; millis())</front>
<front id="ultralcdCPP-1038">    {</front>
<front id="ultralcdCPP-1039">      wasClicked = LCD_CLICKED;</front>
<front id="ultralcdCPP-1040">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-1041">		#ifdef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-1042">        	if (REPRAPWORLD_KEYPAD_MOVE_Z_UP) {</front>
<front id="ultralcdCPP-1043">        		reprapworld_keypad_move_z_up();</front>
<front id="ultralcdCPP-1044">        	}</front>
<front id="ultralcdCPP-1045">        	if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN) {</front>
<front id="ultralcdCPP-1046">        		reprapworld_keypad_move_z_down();</front>
<front id="ultralcdCPP-1047">        	}</front>
<front id="ultralcdCPP-1048">        	if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT) {</front>
<front id="ultralcdCPP-1049">        		reprapworld_keypad_move_x_left();</front>
<front id="ultralcdCPP-1050">        	}</front>
<front id="ultralcdCPP-1051">        	if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT) {</front>
<front id="ultralcdCPP-1052">        		reprapworld_keypad_move_x_right();</front>
<front id="ultralcdCPP-1053">        	}</front>
<front id="ultralcdCPP-1054">        	if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN) {</front>
<front id="ultralcdCPP-1055">        		reprapworld_keypad_move_y_down();</front>
<front id="ultralcdCPP-1056">        	}</front>
<front id="ultralcdCPP-1057">        	if (REPRAPWORLD_KEYPAD_MOVE_Y_UP) {</front>
<front id="ultralcdCPP-1058">        		reprapworld_keypad_move_y_up();</front>
<front id="ultralcdCPP-1059">        	}</front>
<front id="ultralcdCPP-1060">        	if (REPRAPWORLD_KEYPAD_MOVE_HOME) {</front>
<front id="ultralcdCPP-1061">        		reprapworld_keypad_move_home();</front>
<front id="ultralcdCPP-1062">        	}</front>
<front id="ultralcdCPP-1063">		#endif</front>
<front id="ultralcdCPP-1064">        if (abs(encoderDiff) &gt;= ENCODER_PULSES_PER_STEP)</front>
<front id="ultralcdCPP-1065">        {</front>
<front id="ultralcdCPP-1066">            lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1067">            encoderPosition += encoderDiff / ENCODER_PULSES_PER_STEP;</front>
<front id="ultralcdCPP-1068">            encoderDiff = 0;</front>
<front id="ultralcdCPP-1069">            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;</front>
<front id="ultralcdCPP-1070">        }</front>
<front id="ultralcdCPP-1071">        if (LCD_CLICKED)</front>
<front id="ultralcdCPP-1072">            timeoutToStatus = millis() + LCD_TIMEOUT_TO_STATUS;</front>
<front id="ultralcdCPP-1073">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-1074"></front>
<front id="ultralcdCPP-1075">#ifdef DOGLCD        // Changes due to different driver architecture of the DOGM display</front>
<front id="ultralcdCPP-1076">        blink++;     // Variable for fan animation and alive dot</front>
<front id="ultralcdCPP-1077">        u8g.firstPage();</front>
<front id="ultralcdCPP-1078">        do </front>
<front id="ultralcdCPP-1079">        {</front>
<front id="ultralcdCPP-1080">            u8g.setFont(u8g_font_6x10_marlin);</front>
<front id="ultralcdCPP-1081">            u8g.setPrintPos(125,0);</front>
<front id="ultralcdCPP-1082">            if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot</front>
<front id="ultralcdCPP-1083">            u8g.drawPixel(127,63); // draw alive dot</front>
<front id="ultralcdCPP-1084">            u8g.setColorIndex(1); // black on white</front>
<front id="ultralcdCPP-1085">            (*currentMenu)();</front>
<front id="ultralcdCPP-1086">            if (!lcdDrawUpdate)  break; // Terminate display update, when nothing new to draw. This must be done before the last dogm.next()</front>
<front id="ultralcdCPP-1087">        } while( u8g.nextPage() );</front>
<front id="ultralcdCPP-1088">#else        </front>
<front id="ultralcdCPP-1089">        (*currentMenu)();</front>
<front id="ultralcdCPP-1090">#endif</front>
<front id="ultralcdCPP-1091"></front>
<front id="ultralcdCPP-1092">#ifdef LCD_HAS_STATUS_INDICATORS</front>
<front id="ultralcdCPP-1093">        lcd_implementation_update_indicators();</front>
<front id="ultralcdCPP-1094">#endif</front>
<front id="ultralcdCPP-1095"></front>
<front id="ultralcdCPP-1096">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-1097">        if(timeoutToStatus &lt; millis() && currentMenu != lcd_status_screen)</front>
<front id="ultralcdCPP-1098">        {</front>
<front id="ultralcdCPP-1099">            lcd_return_to_status();</front>
<front id="ultralcdCPP-1100">            lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1101">        }</front>
<front id="ultralcdCPP-1102">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-1103">        if (lcdDrawUpdate == 2)</front>
<front id="ultralcdCPP-1104">            lcd_implementation_clear();</front>
<front id="ultralcdCPP-1105">        if (lcdDrawUpdate)</front>
<front id="ultralcdCPP-1106">            lcdDrawUpdate--;</front>
<front id="ultralcdCPP-1107">        lcd_next_update_millis = millis() + 100;</front>
<front id="ultralcdCPP-1108">    }</front>
<front id="ultralcdCPP-1109">}</front>
<front id="ultralcdCPP-1110"></front>
<front id="ultralcdCPP-1111">void lcd_setstatus(const char* message)</front>
<front id="ultralcdCPP-1112">{</front>
<front id="ultralcdCPP-1113">    if (lcd_status_message_level &gt; 0)</front>
<front id="ultralcdCPP-1114">        return;</front>
<front id="ultralcdCPP-1115">    strncpy(lcd_status_message, message, LCD_WIDTH);</front>
<front id="ultralcdCPP-1116">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1117">}</front>
<front id="ultralcdCPP-1118">void lcd_setstatuspgm(const char* message)</front>
<front id="ultralcdCPP-1119">{</front>
<front id="ultralcdCPP-1120">    if (lcd_status_message_level &gt; 0)</front>
<front id="ultralcdCPP-1121">        return;</front>
<front id="ultralcdCPP-1122">    strncpy_P(lcd_status_message, message, LCD_WIDTH);</front>
<front id="ultralcdCPP-1123">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1124">}</front>
<front id="ultralcdCPP-1125">void lcd_setalertstatuspgm(const char* message)</front>
<front id="ultralcdCPP-1126">{</front>
<front id="ultralcdCPP-1127">    lcd_setstatuspgm(message);</front>
<front id="ultralcdCPP-1128">    lcd_status_message_level = 1;</front>
<front id="ultralcdCPP-1129">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-1130">    lcd_return_to_status();</front>
<front id="ultralcdCPP-1131">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-1132">}</front>
<front id="ultralcdCPP-1133">void lcd_reset_alert_level()</front>
<front id="ultralcdCPP-1134">{</front>
<front id="ultralcdCPP-1135">    lcd_status_message_level = 0;</front>
<front id="ultralcdCPP-1136">}</front>
<front id="ultralcdCPP-1137"></front>
<front id="ultralcdCPP-1138">#ifdef DOGLCD</front>
<front id="ultralcdCPP-1139">void lcd_setcontrast(uint8_t value)</front>
<front id="ultralcdCPP-1140">{</front>
<front id="ultralcdCPP-1141">    lcd_contrast = value & 63;</front>
<front id="ultralcdCPP-1142">    u8g.setContrast(lcd_contrast);	</front>
<front id="ultralcdCPP-1143">}</front>
<front id="ultralcdCPP-1144">#endif</front>
<front id="ultralcdCPP-1145"></front>
<front id="ultralcdCPP-1146">#ifdef ULTIPANEL</front>
<front id="ultralcdCPP-1147">/* Warning: This function is called from interrupt context */</front>
<front id="ultralcdCPP-1148">void lcd_buttons_update()</front>
<front id="ultralcdCPP-1149">{</front>
<front id="ultralcdCPP-1150">#ifdef NEWPANEL</front>
<front id="ultralcdCPP-1151">    uint8_t newbutton=0;</front>
<front id="ultralcdCPP-1152">    if(READ(BTN_EN1)==0)  newbutton|=EN_A;</front>
<front id="ultralcdCPP-1153">    if(READ(BTN_EN2)==0)  newbutton|=EN_B;</front>
<front id="ultralcdCPP-1154">  #if BTN_ENC &gt; 0</front>
<front id="ultralcdCPP-1155">    if((blocking_enc&lt;millis()) && (READ(BTN_ENC)==0))</front>
<front id="ultralcdCPP-1156">        newbutton |= EN_C;</front>
<front id="ultralcdCPP-1157">  #endif</front>
<front id="ultralcdCPP-1158">    buttons = newbutton;</front>
<front id="ultralcdCPP-1159">    #ifdef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-1160">      // for the reprapworld_keypad</front>
<front id="ultralcdCPP-1161">      uint8_t newbutton_reprapworld_keypad=0;</front>
<front id="ultralcdCPP-1162">      WRITE(SHIFT_LD,LOW);</front>
<front id="ultralcdCPP-1163">      WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-1164">      for(int8_t i=0;i&lt;8;i++) {</front>
<front id="ultralcdCPP-1165">          newbutton_reprapworld_keypad = newbutton_reprapworld_keypad&gt;&gt;1;</front>
<front id="ultralcdCPP-1166">          if(READ(SHIFT_OUT))</front>
<front id="ultralcdCPP-1167">              newbutton_reprapworld_keypad|=(1&lt;&lt;7);</front>
<front id="ultralcdCPP-1168">          WRITE(SHIFT_CLK,HIGH);</front>
<front id="ultralcdCPP-1169">          WRITE(SHIFT_CLK,LOW);</front>
<front id="ultralcdCPP-1170">      }</front>
<front id="ultralcdCPP-1171">      buttons_reprapworld_keypad=~newbutton_reprapworld_keypad; //invert it, because a pressed switch produces a logical 0</front>
<front id="ultralcdCPP-1172">	#endif</front>
<front id="ultralcdCPP-1173">#else   //read it from the shift register</front>
<front id="ultralcdCPP-1174">    uint8_t newbutton=0;</front>
<front id="ultralcdCPP-1175">    WRITE(SHIFT_LD,LOW);</front>
<front id="ultralcdCPP-1176">    WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-1177">    unsigned char tmp_buttons=0;</front>
<front id="ultralcdCPP-1178">    for(int8_t i=0;i&lt;8;i++)</front>
<front id="ultralcdCPP-1179">    { </front>
<front id="ultralcdCPP-1180">        newbutton = newbutton&gt;&gt;1;</front>
<front id="ultralcdCPP-1181">        if(READ(SHIFT_OUT))</front>
<front id="ultralcdCPP-1182">            newbutton|=(1&lt;&lt;7);</front>
<front id="ultralcdCPP-1183">        WRITE(SHIFT_CLK,HIGH);</front>
<front id="ultralcdCPP-1184">        WRITE(SHIFT_CLK,LOW);</front>
<front id="ultralcdCPP-1185">    }</front>
<front id="ultralcdCPP-1186">    buttons=~newbutton; //invert it, because a pressed switch produces a logical 0</front>
<front id="ultralcdCPP-1187">#endif//!NEWPANEL</front>
<front id="ultralcdCPP-1188"></front>
<front id="ultralcdCPP-1189">    //manage encoder rotation</front>
<front id="ultralcdCPP-1190">    uint8_t enc=0;</front>
<front id="ultralcdCPP-1191">    if(buttons&EN_A)</front>
<front id="ultralcdCPP-1192">        enc|=(1&lt;&lt;0);</front>
<front id="ultralcdCPP-1193">    if(buttons&EN_B)</front>
<front id="ultralcdCPP-1194">        enc|=(1&lt;&lt;1);</front>
<front id="ultralcdCPP-1195">    if(enc != lastEncoderBits)</front>
<front id="ultralcdCPP-1196">    {</front>
<front id="ultralcdCPP-1197">        switch(enc)</front>
<front id="ultralcdCPP-1198">        {</front>
<front id="ultralcdCPP-1199">        case encrot0:</front>
<front id="ultralcdCPP-1200">            if(lastEncoderBits==encrot3)</front>
<front id="ultralcdCPP-1201">                encoderDiff++;</front>
<front id="ultralcdCPP-1202">            else if(lastEncoderBits==encrot1)</front>
<front id="ultralcdCPP-1203">                encoderDiff--;</front>
<front id="ultralcdCPP-1204">            break;</front>
<front id="ultralcdCPP-1205">        case encrot1:</front>
<front id="ultralcdCPP-1206">            if(lastEncoderBits==encrot0)</front>
<front id="ultralcdCPP-1207">                encoderDiff++;</front>
<front id="ultralcdCPP-1208">            else if(lastEncoderBits==encrot2)</front>
<front id="ultralcdCPP-1209">                encoderDiff--;</front>
<front id="ultralcdCPP-1210">            break;</front>
<front id="ultralcdCPP-1211">        case encrot2:</front>
<front id="ultralcdCPP-1212">            if(lastEncoderBits==encrot1)</front>
<front id="ultralcdCPP-1213">                encoderDiff++;</front>
<front id="ultralcdCPP-1214">            else if(lastEncoderBits==encrot3)</front>
<front id="ultralcdCPP-1215">                encoderDiff--;</front>
<front id="ultralcdCPP-1216">            break;</front>
<front id="ultralcdCPP-1217">        case encrot3:</front>
<front id="ultralcdCPP-1218">            if(lastEncoderBits==encrot2)</front>
<front id="ultralcdCPP-1219">                encoderDiff++;</front>
<front id="ultralcdCPP-1220">            else if(lastEncoderBits==encrot0)</front>
<front id="ultralcdCPP-1221">                encoderDiff--;</front>
<front id="ultralcdCPP-1222">            break;</front>
<front id="ultralcdCPP-1223">        }</front>
<front id="ultralcdCPP-1224">    }</front>
<front id="ultralcdCPP-1225">    lastEncoderBits = enc;</front>
<front id="ultralcdCPP-1226">}</front>
<front id="ultralcdCPP-1227"></front>
<front id="ultralcdCPP-1228">void lcd_buzz(long duration, uint16_t freq)</front>
<front id="ultralcdCPP-1229">{ </front>
<front id="ultralcdCPP-1230">#ifdef LCD_USE_I2C_BUZZER</front>
<front id="ultralcdCPP-1231">  lcd.buzz(duration,freq);</front>
<front id="ultralcdCPP-1232">#endif   </front>
<front id="ultralcdCPP-1233">}</front>
<front id="ultralcdCPP-1234"></front>
<front id="ultralcdCPP-1235">bool lcd_clicked() </front>
<front id="ultralcdCPP-1236">{ </front>
<front id="ultralcdCPP-1237">  return LCD_CLICKED;</front>
<front id="ultralcdCPP-1238">}</front>
<front id="ultralcdCPP-1239">#endif//ULTIPANEL</front>
<front id="ultralcdCPP-1240"></front>
<front id="ultralcdCPP-1241">/********************************/</front>
<front id="ultralcdCPP-1242">/** Float conversion utilities **/</front>
<front id="ultralcdCPP-1243">/********************************/</front>
<front id="ultralcdCPP-1244">//  convert float to string with +123.4 format</front>
<front id="ultralcdCPP-1245">char conv[8];</front>
<front id="ultralcdCPP-1246">char *ftostr3(const float &x)</front>
<front id="ultralcdCPP-1247">{</front>
<front id="ultralcdCPP-1248">  return itostr3((int)x);</front>
<front id="ultralcdCPP-1249">}</front>
<front id="ultralcdCPP-1250"></front>
<front id="ultralcdCPP-1251">char *itostr2(const uint8_t &x)</front>
<front id="ultralcdCPP-1252">{</front>
<front id="ultralcdCPP-1253">  //sprintf(conv,"%5.1f",x);</front>
<front id="ultralcdCPP-1254">  int xx=x;</front>
<front id="ultralcdCPP-1255">  conv[0]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1256">  conv[1]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1257">  conv[2]=0;</front>
<front id="ultralcdCPP-1258">  return conv;</front>
<front id="ultralcdCPP-1259">}</front>
<front id="ultralcdCPP-1260"></front>
<front id="ultralcdCPP-1261">//  convert float to string with +123.4 format</front>
<front id="ultralcdCPP-1262">char *ftostr31(const float &x)</front>
<front id="ultralcdCPP-1263">{</front>
<front id="ultralcdCPP-1264">  int xx=x*10;</front>
<front id="ultralcdCPP-1265">  conv[0]=(xx&gt;=0)?'+':'-';</front>
<front id="ultralcdCPP-1266">  xx=abs(xx);</front>
<front id="ultralcdCPP-1267">  conv[1]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1268">  conv[2]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1269">  conv[3]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1270">  conv[4]='.';</front>
<front id="ultralcdCPP-1271">  conv[5]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1272">  conv[6]=0;</front>
<front id="ultralcdCPP-1273">  return conv;</front>
<front id="ultralcdCPP-1274">}</front>
<front id="ultralcdCPP-1275"></front>
<front id="ultralcdCPP-1276">//  convert float to string with 123.4 format</front>
<front id="ultralcdCPP-1277">char *ftostr31ns(const float &x)</front>
<front id="ultralcdCPP-1278">{</front>
<front id="ultralcdCPP-1279">  int xx=x*10;</front>
<front id="ultralcdCPP-1280">  //conv[0]=(xx&gt;=0)?'+':'-';</front>
<front id="ultralcdCPP-1281">  xx=abs(xx);</front>
<front id="ultralcdCPP-1282">  conv[0]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1283">  conv[1]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1284">  conv[2]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1285">  conv[3]='.';</front>
<front id="ultralcdCPP-1286">  conv[4]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1287">  conv[5]=0;</front>
<front id="ultralcdCPP-1288">  return conv;</front>
<front id="ultralcdCPP-1289">}</front>
<front id="ultralcdCPP-1290"></front>
<front id="ultralcdCPP-1291">char *ftostr32(const float &x)</front>
<front id="ultralcdCPP-1292">{</front>
<front id="ultralcdCPP-1293">  long xx=x*100;</front>
<front id="ultralcdCPP-1294">  if (xx &gt;= 0)</front>
<front id="ultralcdCPP-1295">    conv[0]=(xx/10000)%10+'0';</front>
<front id="ultralcdCPP-1296">  else</front>
<front id="ultralcdCPP-1297">    conv[0]='-';</front>
<front id="ultralcdCPP-1298">  xx=abs(xx);</front>
<front id="ultralcdCPP-1299">  conv[1]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1300">  conv[2]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1301">  conv[3]='.';</front>
<front id="ultralcdCPP-1302">  conv[4]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1303">  conv[5]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1304">  conv[6]=0;</front>
<front id="ultralcdCPP-1305">  return conv;</front>
<front id="ultralcdCPP-1306">}</front>
<front id="ultralcdCPP-1307"></front>
<front id="ultralcdCPP-1308">char *itostr31(const int &xx)</front>
<front id="ultralcdCPP-1309">{</front>
<front id="ultralcdCPP-1310">  conv[0]=(xx&gt;=0)?'+':'-';</front>
<front id="ultralcdCPP-1311">  conv[1]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1312">  conv[2]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1313">  conv[3]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1314">  conv[4]='.';</front>
<front id="ultralcdCPP-1315">  conv[5]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1316">  conv[6]=0;</front>
<front id="ultralcdCPP-1317">  return conv;</front>
<front id="ultralcdCPP-1318">}</front>
<front id="ultralcdCPP-1319"></front>
<front id="ultralcdCPP-1320">char *itostr3(const int &xx)</front>
<front id="ultralcdCPP-1321">{</front>
<front id="ultralcdCPP-1322">  if (xx &gt;= 100)</front>
<front id="ultralcdCPP-1323">    conv[0]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1324">  else</front>
<front id="ultralcdCPP-1325">    conv[0]=' ';</front>
<front id="ultralcdCPP-1326">  if (xx &gt;= 10)</front>
<front id="ultralcdCPP-1327">    conv[1]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1328">  else</front>
<front id="ultralcdCPP-1329">    conv[1]=' ';</front>
<front id="ultralcdCPP-1330">  conv[2]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1331">  conv[3]=0;</front>
<front id="ultralcdCPP-1332">  return conv;</front>
<front id="ultralcdCPP-1333">}</front>
<front id="ultralcdCPP-1334"></front>
<front id="ultralcdCPP-1335">char *itostr3left(const int &xx)</front>
<front id="ultralcdCPP-1336">{</front>
<front id="ultralcdCPP-1337">  if (xx &gt;= 100)</front>
<front id="ultralcdCPP-1338">  {</front>
<front id="ultralcdCPP-1339">    conv[0]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1340">    conv[1]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1341">    conv[2]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1342">    conv[3]=0;</front>
<front id="ultralcdCPP-1343">  }</front>
<front id="ultralcdCPP-1344">  else if (xx &gt;= 10)</front>
<front id="ultralcdCPP-1345">  {</front>
<front id="ultralcdCPP-1346">    conv[0]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1347">    conv[1]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1348">    conv[2]=0;</front>
<front id="ultralcdCPP-1349">  }</front>
<front id="ultralcdCPP-1350">  else</front>
<front id="ultralcdCPP-1351">  {</front>
<front id="ultralcdCPP-1352">    conv[0]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1353">    conv[1]=0;</front>
<front id="ultralcdCPP-1354">  }</front>
<front id="ultralcdCPP-1355">  return conv;</front>
<front id="ultralcdCPP-1356">}</front>
<front id="ultralcdCPP-1357"></front>
<front id="ultralcdCPP-1358">char *itostr4(const int &xx)</front>
<front id="ultralcdCPP-1359">{</front>
<front id="ultralcdCPP-1360">  if (xx &gt;= 1000)</front>
<front id="ultralcdCPP-1361">    conv[0]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1362">  else</front>
<front id="ultralcdCPP-1363">    conv[0]=' ';</front>
<front id="ultralcdCPP-1364">  if (xx &gt;= 100)</front>
<front id="ultralcdCPP-1365">    conv[1]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1366">  else</front>
<front id="ultralcdCPP-1367">    conv[1]=' ';</front>
<front id="ultralcdCPP-1368">  if (xx &gt;= 10)</front>
<front id="ultralcdCPP-1369">    conv[2]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1370">  else</front>
<front id="ultralcdCPP-1371">    conv[2]=' ';</front>
<front id="ultralcdCPP-1372">  conv[3]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1373">  conv[4]=0;</front>
<front id="ultralcdCPP-1374">  return conv;</front>
<front id="ultralcdCPP-1375">}</front>
<front id="ultralcdCPP-1376"></front>
<front id="ultralcdCPP-1377">//  convert float to string with 12345 format</front>
<front id="ultralcdCPP-1378">char *ftostr5(const float &x)</front>
<front id="ultralcdCPP-1379">{</front>
<front id="ultralcdCPP-1380">  long xx=abs(x);</front>
<front id="ultralcdCPP-1381">  if (xx &gt;= 10000)</front>
<front id="ultralcdCPP-1382">    conv[0]=(xx/10000)%10+'0';</front>
<front id="ultralcdCPP-1383">  else</front>
<front id="ultralcdCPP-1384">    conv[0]=' ';</front>
<front id="ultralcdCPP-1385">  if (xx &gt;= 1000)</front>
<front id="ultralcdCPP-1386">    conv[1]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1387">  else</front>
<front id="ultralcdCPP-1388">    conv[1]=' ';</front>
<front id="ultralcdCPP-1389">  if (xx &gt;= 100)</front>
<front id="ultralcdCPP-1390">    conv[2]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1391">  else</front>
<front id="ultralcdCPP-1392">    conv[2]=' ';</front>
<front id="ultralcdCPP-1393">  if (xx &gt;= 10)</front>
<front id="ultralcdCPP-1394">    conv[3]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1395">  else</front>
<front id="ultralcdCPP-1396">    conv[3]=' ';</front>
<front id="ultralcdCPP-1397">  conv[4]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1398">  conv[5]=0;</front>
<front id="ultralcdCPP-1399">  return conv;</front>
<front id="ultralcdCPP-1400">}</front>
<front id="ultralcdCPP-1401"></front>
<front id="ultralcdCPP-1402">//  convert float to string with +1234.5 format</front>
<front id="ultralcdCPP-1403">char *ftostr51(const float &x)</front>
<front id="ultralcdCPP-1404">{</front>
<front id="ultralcdCPP-1405">  long xx=x*10;</front>
<front id="ultralcdCPP-1406">  conv[0]=(xx&gt;=0)?'+':'-';</front>
<front id="ultralcdCPP-1407">  xx=abs(xx);</front>
<front id="ultralcdCPP-1408">  conv[1]=(xx/10000)%10+'0';</front>
<front id="ultralcdCPP-1409">  conv[2]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1410">  conv[3]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1411">  conv[4]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1412">  conv[5]='.';</front>
<front id="ultralcdCPP-1413">  conv[6]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1414">  conv[7]=0;</front>
<front id="ultralcdCPP-1415">  return conv;</front>
<front id="ultralcdCPP-1416">}</front>
<front id="ultralcdCPP-1417"></front>
<front id="ultralcdCPP-1418">//  convert float to string with +123.45 format</front>
<front id="ultralcdCPP-1419">char *ftostr52(const float &x)</front>
<front id="ultralcdCPP-1420">{</front>
<front id="ultralcdCPP-1421">  long xx=x*100;</front>
<front id="ultralcdCPP-1422">  conv[0]=(xx&gt;=0)?'+':'-';</front>
<front id="ultralcdCPP-1423">  xx=abs(xx);</front>
<front id="ultralcdCPP-1424">  conv[1]=(xx/10000)%10+'0';</front>
<front id="ultralcdCPP-1425">  conv[2]=(xx/1000)%10+'0';</front>
<front id="ultralcdCPP-1426">  conv[3]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-1427">  conv[4]='.';</front>
<front id="ultralcdCPP-1428">  conv[5]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-1429">  conv[6]=(xx)%10+'0';</front>
<front id="ultralcdCPP-1430">  conv[7]=0;</front>
<front id="ultralcdCPP-1431">  return conv;</front>
<front id="ultralcdCPP-1432">}</front>
<front id="ultralcdCPP-1433"></front>
<front id="ultralcdCPP-1434">// Callback for after editing PID i value</front>
<front id="ultralcdCPP-1435">// grab the pid i value out of the temp variable; scale it; then update the PID driver</front>
<front id="ultralcdCPP-1436">void copy_and_scalePID_i()</front>
<front id="ultralcdCPP-1437">{</front>
<front id="ultralcdCPP-1438">#ifdef PIDTEMP</front>
<front id="ultralcdCPP-1439">  Ki = scalePID_i(raw_Ki);</front>
<front id="ultralcdCPP-1440">  updatePID();</front>
<front id="ultralcdCPP-1441">#endif</front>
<front id="ultralcdCPP-1442">}</front>
<front id="ultralcdCPP-1443"></front>
<front id="ultralcdCPP-1444">// Callback for after editing PID d value</front>
<front id="ultralcdCPP-1445">// grab the pid d value out of the temp variable; scale it; then update the PID driver</front>
<front id="ultralcdCPP-1446">void copy_and_scalePID_d()</front>
<front id="ultralcdCPP-1447">{</front>
<front id="ultralcdCPP-1448">#ifdef PIDTEMP</front>
<front id="ultralcdCPP-1449">  Kd = scalePID_d(raw_Kd);</front>
<front id="ultralcdCPP-1450">  updatePID();</front>
<front id="ultralcdCPP-1451">#endif</front>
<front id="ultralcdCPP-1452">}</front>
<front id="ultralcdCPP-1453"></front>
<front id="ultralcdCPP-1454">#endif //ULTRA_LCD</front>
 </pre>
<h1>ultralcd.h</h1>
<pre  class="prettyprint linenums"><front id="ultralcdH-1">#ifndef ULTRALCD_H</front>
<front id="ultralcdH-2">#define ULTRALCD_H</front>
<front id="ultralcdH-3"></front>
<front id="ultralcdH-4">#include "Marlin.h"</front>
<front id="ultralcdH-5"></front>
<front id="ultralcdH-6">#ifdef ULTRA_LCD</front>
<front id="ultralcdH-7"></front>
<front id="ultralcdH-8">  void lcd_update();</front>
<front id="ultralcdH-9">  void lcd_init();</front>
<front id="ultralcdH-10">  void lcd_setstatus(const char* message);</front>
<front id="ultralcdH-11">  void lcd_setstatuspgm(const char* message);</front>
<front id="ultralcdH-12">  void lcd_setalertstatuspgm(const char* message);</front>
<front id="ultralcdH-13">  void lcd_reset_alert_level();</front>
<front id="ultralcdH-14"></front>
<front id="ultralcdH-15">#ifdef DOGLCD</front>
<front id="ultralcdH-16">  extern int lcd_contrast;</front>
<front id="ultralcdH-17">  void lcd_setcontrast(uint8_t value);</front>
<front id="ultralcdH-18">#endif</front>
<front id="ultralcdH-19"></front>
<front id="ultralcdH-20">  static unsigned char blink = 0;	// Variable for visualisation of fan rotation in GLCD</front>
<front id="ultralcdH-21"></front>
<front id="ultralcdH-22">  #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))</front>
<front id="ultralcdH-23">  #define LCD_ALERTMESSAGEPGM(x) lcd_setalertstatuspgm(PSTR(x))</front>
<front id="ultralcdH-24"></front>
<front id="ultralcdH-25">  #define LCD_UPDATE_INTERVAL 100</front>
<front id="ultralcdH-26">  #define LCD_TIMEOUT_TO_STATUS 15000</front>
<front id="ultralcdH-27"></front>
<front id="ultralcdH-28">  #ifdef ULTIPANEL</front>
<front id="ultralcdH-29">  void lcd_buttons_update();</front>
<front id="ultralcdH-30">  extern volatile uint8_t buttons;  //the last checked buttons in a bit array.</front>
<front id="ultralcdH-31">  #ifdef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdH-32">    extern volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shiftregister values</front>
<front id="ultralcdH-33">  #endif</front>
<front id="ultralcdH-34">  #else</front>
<front id="ultralcdH-35">  FORCE_INLINE void lcd_buttons_update() {}</front>
<front id="ultralcdH-36">  #endif</front>
<front id="ultralcdH-37"></front>
<front id="ultralcdH-38">  extern int plaPreheatHotendTemp;</front>
<front id="ultralcdH-39">  extern int plaPreheatHPBTemp;</front>
<front id="ultralcdH-40">  extern int plaPreheatFanSpeed;</front>
<front id="ultralcdH-41"></front>
<front id="ultralcdH-42">  extern int absPreheatHotendTemp;</front>
<front id="ultralcdH-43">  extern int absPreheatHPBTemp;</front>
<front id="ultralcdH-44">  extern int absPreheatFanSpeed;</front>
<front id="ultralcdH-45">    </front>
<front id="ultralcdH-46">  void lcd_buzz(long duration,uint16_t freq);</front>
<front id="ultralcdH-47">  bool lcd_clicked();</front>
<front id="ultralcdH-48"></front>
<front id="ultralcdH-49">  #ifdef NEWPANEL</front>
<front id="ultralcdH-50">    #define EN_C (1&lt;&lt;BLEN_C)</front>
<front id="ultralcdH-51">    #define EN_B (1&lt;&lt;BLEN_B)</front>
<front id="ultralcdH-52">    #define EN_A (1&lt;&lt;BLEN_A)</front>
<front id="ultralcdH-53"></front>
<front id="ultralcdH-54">    #define LCD_CLICKED (buttons&EN_C)</front>
<front id="ultralcdH-55">    #ifdef REPRAPWORLD_KEYPAD</front>
<front id="ultralcdH-56">  	  #define EN_REPRAPWORLD_KEYPAD_F3 (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_F3)</front>
<front id="ultralcdH-57">  	  #define EN_REPRAPWORLD_KEYPAD_F2 (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_F2)</front>
<front id="ultralcdH-58">  	  #define EN_REPRAPWORLD_KEYPAD_F1 (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_F1)</front>
<front id="ultralcdH-59">  	  #define EN_REPRAPWORLD_KEYPAD_UP (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_UP)</front>
<front id="ultralcdH-60">  	  #define EN_REPRAPWORLD_KEYPAD_RIGHT (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_RIGHT)</front>
<front id="ultralcdH-61">  	  #define EN_REPRAPWORLD_KEYPAD_MIDDLE (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_MIDDLE)</front>
<front id="ultralcdH-62">  	  #define EN_REPRAPWORLD_KEYPAD_DOWN (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_DOWN)</front>
<front id="ultralcdH-63">  	  #define EN_REPRAPWORLD_KEYPAD_LEFT (1&lt;&lt;BLEN_REPRAPWORLD_KEYPAD_LEFT)</front>
<front id="ultralcdH-64"></front>
<front id="ultralcdH-65">  	  #define LCD_CLICKED ((buttons&EN_C) || (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F1))</front>
<front id="ultralcdH-66">  	  #define REPRAPWORLD_KEYPAD_MOVE_Z_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F2)</front>
<front id="ultralcdH-67">  	  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F3)</front>
<front id="ultralcdH-68">  	  #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_LEFT)</front>
<front id="ultralcdH-69">  	  #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_RIGHT)</front>
<front id="ultralcdH-70">  	  #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_DOWN)</front>
<front id="ultralcdH-71">  	  #define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_UP)</front>
<front id="ultralcdH-72">  	  #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_MIDDLE)</front>
<front id="ultralcdH-73">    #endif //REPRAPWORLD_KEYPAD</front>
<front id="ultralcdH-74">  #else</front>
<front id="ultralcdH-75">    //atomatic, do not change</front>
<front id="ultralcdH-76">    #define B_LE (1&lt;&lt;BL_LE)</front>
<front id="ultralcdH-77">    #define B_UP (1&lt;&lt;BL_UP)</front>
<front id="ultralcdH-78">    #define B_MI (1&lt;&lt;BL_MI)</front>
<front id="ultralcdH-79">    #define B_DW (1&lt;&lt;BL_DW)</front>
<front id="ultralcdH-80">    #define B_RI (1&lt;&lt;BL_RI)</front>
<front id="ultralcdH-81">    #define B_ST (1&lt;&lt;BL_ST)</front>
<front id="ultralcdH-82">    #define EN_B (1&lt;&lt;BLEN_B)</front>
<front id="ultralcdH-83">    #define EN_A (1&lt;&lt;BLEN_A)</front>
<front id="ultralcdH-84">    </front>
<front id="ultralcdH-85">    #define LCD_CLICKED ((buttons&B_MI)||(buttons&B_ST))</front>
<front id="ultralcdH-86">  #endif//NEWPANEL</front>
<front id="ultralcdH-87"></front>
<front id="ultralcdH-88">#else //no lcd</front>
<front id="ultralcdH-89">  FORCE_INLINE void lcd_update() {}</front>
<front id="ultralcdH-90">  FORCE_INLINE void lcd_init() {}</front>
<front id="ultralcdH-91">  FORCE_INLINE void lcd_setstatus(const char* message) {}</front>
<front id="ultralcdH-92">  FORCE_INLINE void lcd_buttons_update() {}</front>
<front id="ultralcdH-93">  FORCE_INLINE void lcd_reset_alert_level() {}</front>
<front id="ultralcdH-94">  FORCE_INLINE void lcd_buzz(long duration,uint16_t freq) {}</front>
<front id="ultralcdH-95"></front>
<front id="ultralcdH-96">  #define LCD_MESSAGEPGM(x) </front>
<front id="ultralcdH-97">  #define LCD_ALERTMESSAGEPGM(x) </front>
<front id="ultralcdH-98">#endif </front>
<front id="ultralcdH-99"></front>
<front id="ultralcdH-100">char *itostr2(const uint8_t &x);</front>
<front id="ultralcdH-101">char *itostr31(const int &xx);</front>
<front id="ultralcdH-102">char *itostr3(const int &xx);</front>
<front id="ultralcdH-103">char *itostr3left(const int &xx);</front>
<front id="ultralcdH-104">char *itostr4(const int &xx);</front>
<front id="ultralcdH-105"></front>
<front id="ultralcdH-106">char *ftostr3(const float &x);</front>
<front id="ultralcdH-107">char *ftostr31ns(const float &x); // float to string without sign character</front>
<front id="ultralcdH-108">char *ftostr31(const float &x);</front>
<front id="ultralcdH-109">char *ftostr32(const float &x);</front>
<front id="ultralcdH-110">char *ftostr5(const float &x);</front>
<front id="ultralcdH-111">char *ftostr51(const float &x);</front>
<front id="ultralcdH-112">char *ftostr52(const float &x);</front>
<front id="ultralcdH-113"></front>
<front id="ultralcdH-114">#endif //ULTRALCD</front>
 </pre>
<h1>ultralcd_implementation_hitachi_HD44780.h</h1>
<pre  class="prettyprint linenums"><front id="ultralcd_implementation_hitachi_HD44780H-1">#ifndef ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H</front>
<front id="ultralcd_implementation_hitachi_HD44780H-2">#define ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H</front>
<front id="ultralcd_implementation_hitachi_HD44780H-3"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-4">/**</front>
<front id="ultralcd_implementation_hitachi_HD44780H-5">* Implementation of the LCD display routines for a hitachi HD44780 display. These are common LCD character displays.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-6">* When selecting the rusian language, a slightly different LCD implementation is used to handle UTF8 characters.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-7">**/</front>
<front id="ultralcd_implementation_hitachi_HD44780H-8"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-9">#ifndef REPRAPWORLD_KEYPAD</front>
<front id="ultralcd_implementation_hitachi_HD44780H-10">extern volatile uint8_t buttons;  //the last checked buttons in a bit array.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-11">#else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-12">extern volatile uint16_t buttons;  //an extended version of the last checked buttons in a bit array.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-13">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-14"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-15">////////////////////////////////////</front>
<front id="ultralcd_implementation_hitachi_HD44780H-16">// Setup button and encode mappings for each panel (into 'buttons' variable</front>
<front id="ultralcd_implementation_hitachi_HD44780H-17">//</front>
<front id="ultralcd_implementation_hitachi_HD44780H-18">// This is just to map common functions (across different panels) onto the same </front>
<front id="ultralcd_implementation_hitachi_HD44780H-19">// macro name. The mapping is independent of whether the button is directly connected or </front>
<front id="ultralcd_implementation_hitachi_HD44780H-20">// via a shift/i2c register.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-21"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-22">#ifdef ULTIPANEL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-23">// All Ultipanels might have an encoder - so this is always be mapped onto first two bits</front>
<front id="ultralcd_implementation_hitachi_HD44780H-24">#define BLEN_B 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-25">#define BLEN_A 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-26"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-27">#define EN_B (1&lt;&lt;BLEN_B) // The two encoder pins are connected through BTN_EN1 and BTN_EN2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-28">#define EN_A (1&lt;&lt;BLEN_A)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-29"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-30">#if defined(BTN_ENC) && BTN_ENC &gt; -1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-31">  // encoder click is directly connected</front>
<front id="ultralcd_implementation_hitachi_HD44780H-32">  #define BLEN_C 2 </front>
<front id="ultralcd_implementation_hitachi_HD44780H-33">  #define EN_C (1&lt;&lt;BLEN_C) </front>
<front id="ultralcd_implementation_hitachi_HD44780H-34">#endif </front>
<front id="ultralcd_implementation_hitachi_HD44780H-35">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-36">//</front>
<front id="ultralcd_implementation_hitachi_HD44780H-37">// Setup other button mappings of each panel</front>
<front id="ultralcd_implementation_hitachi_HD44780H-38">//</front>
<front id="ultralcd_implementation_hitachi_HD44780H-39">#if defined(LCD_I2C_VIKI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-40">  #define B_I2C_BTN_OFFSET 3 // (the first three bit positions reserved for EN_A, EN_B, EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-41">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-42">  // button and encoder bit positions within 'buttons'</front>
<front id="ultralcd_implementation_hitachi_HD44780H-43">  #define B_LE (BUTTON_LEFT&lt;&lt;B_I2C_BTN_OFFSET)    // The remaining normalized buttons are all read via I2C</front>
<front id="ultralcd_implementation_hitachi_HD44780H-44">  #define B_UP (BUTTON_UP&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-45">  #define B_MI (BUTTON_SELECT&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-46">  #define B_DW (BUTTON_DOWN&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-47">  #define B_RI (BUTTON_RIGHT&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-48"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-49">  #if defined(BTN_ENC) && BTN_ENC &gt; -1 </front>
<front id="ultralcd_implementation_hitachi_HD44780H-50">    // the pause/stop/restart button is connected to BTN_ENC when used</front>
<front id="ultralcd_implementation_hitachi_HD44780H-51">    #define B_ST (EN_C)                            // Map the pause/stop/resume button into its normalized functional name </front>
<front id="ultralcd_implementation_hitachi_HD44780H-52">    #define LCD_CLICKED (buttons&(B_MI|B_RI|B_ST)) // pause/stop button also acts as click until we implement proper pause/stop.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-53">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-54">    #define LCD_CLICKED (buttons&(B_MI|B_RI))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-55">  #endif  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-56"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-57">  // I2C buttons take too long to read inside an interrupt context and so we read them during lcd_update</front>
<front id="ultralcd_implementation_hitachi_HD44780H-58">  #define LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-59"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-60">#elif defined(LCD_I2C_PANELOLU2)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-61">  // encoder click can be read through I2C if not directly connected</front>
<front id="ultralcd_implementation_hitachi_HD44780H-62">  #if BTN_ENC &lt;= 0 </front>
<front id="ultralcd_implementation_hitachi_HD44780H-63">    #define B_I2C_BTN_OFFSET 3 // (the first three bit positions reserved for EN_A, EN_B, EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-64">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-65">    #define B_MI (PANELOLU2_ENCODER_C&lt;&lt;B_I2C_BTN_OFFSET) // requires LiquidTWI2 library v1.2.3 or later</front>
<front id="ultralcd_implementation_hitachi_HD44780H-66"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-67">    #define LCD_CLICKED (buttons&B_MI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-68"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-69">    // I2C buttons take too long to read inside an interrupt context and so we read them during lcd_update</front>
<front id="ultralcd_implementation_hitachi_HD44780H-70">    #define LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-71">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-72">    #define LCD_CLICKED (buttons&EN_C)  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-73">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-74"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-75">#elif defined(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-76">    // define register bit values, don't change it</front>
<front id="ultralcd_implementation_hitachi_HD44780H-77">    #define BLEN_REPRAPWORLD_KEYPAD_F3 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-78">    #define BLEN_REPRAPWORLD_KEYPAD_F2 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-79">    #define BLEN_REPRAPWORLD_KEYPAD_F1 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-80">    #define BLEN_REPRAPWORLD_KEYPAD_UP 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-81">    #define BLEN_REPRAPWORLD_KEYPAD_RIGHT 4</front>
<front id="ultralcd_implementation_hitachi_HD44780H-82">    #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5</front>
<front id="ultralcd_implementation_hitachi_HD44780H-83">    #define BLEN_REPRAPWORLD_KEYPAD_DOWN 6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-84">    #define BLEN_REPRAPWORLD_KEYPAD_LEFT 7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-85">    </front>
<front id="ultralcd_implementation_hitachi_HD44780H-86">    #define REPRAPWORLD_BTN_OFFSET 3 // bit offset into buttons for shift register values</front>
<front id="ultralcd_implementation_hitachi_HD44780H-87"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-88">    #define EN_REPRAPWORLD_KEYPAD_F3 (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_F3+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-89">    #define EN_REPRAPWORLD_KEYPAD_F2 (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_F2+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-90">    #define EN_REPRAPWORLD_KEYPAD_F1 (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_F1+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-91">    #define EN_REPRAPWORLD_KEYPAD_UP (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_UP+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-92">    #define EN_REPRAPWORLD_KEYPAD_RIGHT (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_RIGHT+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-93">    #define EN_REPRAPWORLD_KEYPAD_MIDDLE (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_MIDDLE+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-94">    #define EN_REPRAPWORLD_KEYPAD_DOWN (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_DOWN+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-95">    #define EN_REPRAPWORLD_KEYPAD_LEFT (1&lt;&lt;(BLEN_REPRAPWORLD_KEYPAD_LEFT+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-96"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-97">    #define LCD_CLICKED ((buttons&EN_C) || (buttons&EN_REPRAPWORLD_KEYPAD_F1))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-98">    #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons&EN_REPRAPWORLD_KEYPAD_DOWN)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-99">    #define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons&EN_REPRAPWORLD_KEYPAD_UP)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-100">    #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons&EN_REPRAPWORLD_KEYPAD_MIDDLE)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-101"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-102">#elif defined(NEWPANEL)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-103">  #define LCD_CLICKED (buttons&EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-104">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-105">#else // old style ULTIPANEL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-106">  //bits in the shift register that carry the buttons for:</front>
<front id="ultralcd_implementation_hitachi_HD44780H-107">  // left up center down right red(stop)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-108">  #define BL_LE 7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-109">  #define BL_UP 6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-110">  #define BL_MI 5</front>
<front id="ultralcd_implementation_hitachi_HD44780H-111">  #define BL_DW 4</front>
<front id="ultralcd_implementation_hitachi_HD44780H-112">  #define BL_RI 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-113">  #define BL_ST 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-114"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-115">  //automatic, do not change</front>
<front id="ultralcd_implementation_hitachi_HD44780H-116">  #define B_LE (1&lt;&lt;BL_LE)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-117">  #define B_UP (1&lt;&lt;BL_UP)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-118">  #define B_MI (1&lt;&lt;BL_MI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-119">  #define B_DW (1&lt;&lt;BL_DW)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-120">  #define B_RI (1&lt;&lt;BL_RI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-121">  #define B_ST (1&lt;&lt;BL_ST)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-122">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-123">  #define LCD_CLICKED (buttons&(B_MI|B_ST))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-124">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-125"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-126">////////////////////////</front>
<front id="ultralcd_implementation_hitachi_HD44780H-127">// Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-128">// These values are independent of which pins are used for EN_A and EN_B indications</front>
<front id="ultralcd_implementation_hitachi_HD44780H-129">// The rotary encoder part is also independent to the chipset used for the LCD</front>
<front id="ultralcd_implementation_hitachi_HD44780H-130">#if defined(EN_A) && defined(EN_B)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-131">    #define encrot0 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-132">    #define encrot1 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-133">    #define encrot2 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-134">    #define encrot3 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-135">#endif </front>
<front id="ultralcd_implementation_hitachi_HD44780H-136"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-137">#endif //ULTIPANEL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-138"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-139">////////////////////////////////////</front>
<front id="ultralcd_implementation_hitachi_HD44780H-140">// Create LCD class instance and chipset-specific information</front>
<front id="ultralcd_implementation_hitachi_HD44780H-141">#if defined(LCD_I2C_TYPE_PCF8575)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-142">  // note: these are register mapped pins on the PCF8575 controller not Arduino pins</front>
<front id="ultralcd_implementation_hitachi_HD44780H-143">  #define LCD_I2C_PIN_BL  3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-144">  #define LCD_I2C_PIN_EN  2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-145">  #define LCD_I2C_PIN_RW  1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-146">  #define LCD_I2C_PIN_RS  0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-147">  #define LCD_I2C_PIN_D4  4</front>
<front id="ultralcd_implementation_hitachi_HD44780H-148">  #define LCD_I2C_PIN_D5  5</front>
<front id="ultralcd_implementation_hitachi_HD44780H-149">  #define LCD_I2C_PIN_D6  6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-150">  #define LCD_I2C_PIN_D7  7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-151"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-152">  #include &lt;Wire.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-153">  #include &lt;LCD.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-154">  #include &lt;LiquidCrystal_I2C.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-155">  #define LCD_CLASS LiquidCrystal_I2C</front>
<front id="ultralcd_implementation_hitachi_HD44780H-156">  LCD_CLASS lcd(LCD_I2C_ADDRESS,LCD_I2C_PIN_EN,LCD_I2C_PIN_RW,LCD_I2C_PIN_RS,LCD_I2C_PIN_D4,LCD_I2C_PIN_D5,LCD_I2C_PIN_D6,LCD_I2C_PIN_D7);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-157">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-158">#elif defined(LCD_I2C_TYPE_MCP23017)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-159">  //for the LED indicators (which maybe mapped to different things in lcd_implementation_update_indicators())</front>
<front id="ultralcd_implementation_hitachi_HD44780H-160">  #define LED_A 0x04 //100</front>
<front id="ultralcd_implementation_hitachi_HD44780H-161">  #define LED_B 0x02 //010</front>
<front id="ultralcd_implementation_hitachi_HD44780H-162">  #define LED_C 0x01 //001</front>
<front id="ultralcd_implementation_hitachi_HD44780H-163"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-164">  #define LCD_HAS_STATUS_INDICATORS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-165"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-166">  #include &lt;Wire.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-167">  #include &lt;LiquidTWI2.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-168">  #define LCD_CLASS LiquidTWI2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-169">  LCD_CLASS lcd(LCD_I2C_ADDRESS);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-170">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-171">#elif defined(LCD_I2C_TYPE_MCP23008)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-172">  #include &lt;Wire.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-173">  #include &lt;LiquidTWI2.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-174">  #define LCD_CLASS LiquidTWI2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-175">  LCD_CLASS lcd(LCD_I2C_ADDRESS);  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-176"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-177">#elif defined(LCD_I2C_TYPE_PCA8574)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-178">    #include &lt;LiquidCrystal_I2C.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-179">    #define LCD_CLASS LiquidCrystal_I2C</front>
<front id="ultralcd_implementation_hitachi_HD44780H-180">    LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-181">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-182">#else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-183">  // Standard directly connected LCD implementations</front>
<front id="ultralcd_implementation_hitachi_HD44780H-184">  #if LANGUAGE_CHOICE == 6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-185">    #include "LiquidCrystalRus.h"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-186">    #define LCD_CLASS LiquidCrystalRus</front>
<front id="ultralcd_implementation_hitachi_HD44780H-187">  #else </front>
<front id="ultralcd_implementation_hitachi_HD44780H-188">    #include &lt;LiquidCrystal.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-189">    #define LCD_CLASS LiquidCrystal</front>
<front id="ultralcd_implementation_hitachi_HD44780H-190">  #endif  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-191">  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-192">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-193"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-194">/* Custom characters defined in the first 8 characters of the LCD */</front>
<front id="ultralcd_implementation_hitachi_HD44780H-195">#define LCD_STR_BEDTEMP     "\x00"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-196">#define LCD_STR_DEGREE      "\x01"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-197">#define LCD_STR_THERMOMETER "\x02"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-198">#define LCD_STR_UPLEVEL     "\x03"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-199">#define LCD_STR_REFRESH     "\x04"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-200">#define LCD_STR_FOLDER      "\x05"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-201">#define LCD_STR_FEEDRATE    "\x06"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-202">#define LCD_STR_CLOCK       "\x07"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-203">#define LCD_STR_ARROW_RIGHT "\x7E"  /* from the default character set */</front>
<front id="ultralcd_implementation_hitachi_HD44780H-204"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-205">static void lcd_implementation_init()</front>
<front id="ultralcd_implementation_hitachi_HD44780H-206">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-207">    byte bedTemp[8] =</front>
<front id="ultralcd_implementation_hitachi_HD44780H-208">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-209">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-210">        B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-211">        B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-212">        B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-213">        B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-214">        B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-215">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-216">        B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-217">    }; //thanks Sonny Mounicou</front>
<front id="ultralcd_implementation_hitachi_HD44780H-218">    byte degree[8] =</front>
<front id="ultralcd_implementation_hitachi_HD44780H-219">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-220">        B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-221">        B10010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-222">        B10010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-223">        B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-224">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-225">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-226">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-227">        B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-228">    };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-229">    byte thermometer[8] =</front>
<front id="ultralcd_implementation_hitachi_HD44780H-230">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-231">        B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-232">        B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-233">        B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-234">        B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-235">        B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-236">        B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-237">        B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-238">        B01110</front>
<front id="ultralcd_implementation_hitachi_HD44780H-239">    };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-240">    byte uplevel[8]={</front>
<front id="ultralcd_implementation_hitachi_HD44780H-241">        B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-242">        B01110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-243">        B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-244">        B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-245">        B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-246">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-247">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-248">        B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-249">    }; //thanks joris</front>
<front id="ultralcd_implementation_hitachi_HD44780H-250">    byte refresh[8]={</front>
<front id="ultralcd_implementation_hitachi_HD44780H-251">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-252">        B00110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-253">        B11001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-254">        B11000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-255">        B00011,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-256">        B10011,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-257">        B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-258">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-259">    }; //thanks joris</front>
<front id="ultralcd_implementation_hitachi_HD44780H-260">    byte folder [8]={</front>
<front id="ultralcd_implementation_hitachi_HD44780H-261">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-262">        B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-263">        B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-264">        B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-265">        B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-266">        B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-267">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-268">        B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-269">    }; //thanks joris</front>
<front id="ultralcd_implementation_hitachi_HD44780H-270">    byte feedrate [8]={</front>
<front id="ultralcd_implementation_hitachi_HD44780H-271">        B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-272">        B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-273">        B11000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-274">        B10111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-275">        B00101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-276">        B00110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-277">        B00101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-278">        B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-279">    }; //thanks Sonny Mounicou</front>
<front id="ultralcd_implementation_hitachi_HD44780H-280">    byte clock [8]={</front>
<front id="ultralcd_implementation_hitachi_HD44780H-281">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-282">        B01110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-283">        B10011,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-284">        B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-285">        B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-286">        B01110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-287">        B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-288">        B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-289">    }; //thanks Sonny Mounicou</front>
<front id="ultralcd_implementation_hitachi_HD44780H-290"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-291">#if defined(LCDI2C_TYPE_PCF8575)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-292">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-293">  #ifdef LCD_I2C_PIN_BL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-294">    lcd.setBacklightPin(LCD_I2C_PIN_BL,POSITIVE);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-295">    lcd.setBacklight(HIGH);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-296">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-297">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-298">#elif defined(LCD_I2C_TYPE_MCP23017)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-299">    lcd.setMCPType(LTI_TYPE_MCP23017);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-300">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-301">    lcd.setBacklight(0); //set all the LEDs off to begin with</front>
<front id="ultralcd_implementation_hitachi_HD44780H-302">    </front>
<front id="ultralcd_implementation_hitachi_HD44780H-303">#elif defined(LCD_I2C_TYPE_MCP23008)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-304">    lcd.setMCPType(LTI_TYPE_MCP23008);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-305">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-306"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-307">#elif defined(LCD_I2C_TYPE_PCA8574)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-308">      lcd.init();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-309">      lcd.backlight();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-310">    </front>
<front id="ultralcd_implementation_hitachi_HD44780H-311">#else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-312">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-313">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-314"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-315">    lcd.createChar(LCD_STR_BEDTEMP[0], bedTemp);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-316">    lcd.createChar(LCD_STR_DEGREE[0], degree);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-317">    lcd.createChar(LCD_STR_THERMOMETER[0], thermometer);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-318">    lcd.createChar(LCD_STR_UPLEVEL[0], uplevel);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-319">    lcd.createChar(LCD_STR_REFRESH[0], refresh);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-320">    lcd.createChar(LCD_STR_FOLDER[0], folder);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-321">    lcd.createChar(LCD_STR_FEEDRATE[0], feedrate);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-322">    lcd.createChar(LCD_STR_CLOCK[0], clock);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-323">    lcd.clear();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-324">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-325">static void lcd_implementation_clear()</front>
<front id="ultralcd_implementation_hitachi_HD44780H-326">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-327">    lcd.clear();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-328">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-329">/* Arduino &lt; 1.0.0 is missing a function to print PROGMEM strings, so we need to implement our own */</front>
<front id="ultralcd_implementation_hitachi_HD44780H-330">static void lcd_printPGM(const char* str)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-331">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-332">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-333">    while((c = pgm_read_byte(str++)) != '\0')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-334">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-335">        lcd.write(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-336">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-337">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-338">/*</front>
<front id="ultralcd_implementation_hitachi_HD44780H-339">Possible status screens:</front>
<front id="ultralcd_implementation_hitachi_HD44780H-340">16x2   |0123456789012345|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-341">       |000/000 B000/000|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-342">       |Status line.....|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-343"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-344">16x4   |0123456789012345|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-345">       |000/000 B000/000|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-346">       |SD100%    Z000.0|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-347">       |F100%     T--:--|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-348">       |Status line.....|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-349"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-350">20x2   |01234567890123456789|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-351">       |T000/000D B000/000D |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-352">       |Status line.........|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-353"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-354">20x4   |01234567890123456789|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-355">       |T000/000D B000/000D |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-356">       |X+000.0 Y+000.0 Z+000.0|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-357">       |F100%  SD100% T--:--|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-358">       |Status line.........|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-359"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-360">20x4   |01234567890123456789|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-361">       |T000/000D B000/000D |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-362">       |T000/000D     Z000.0|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-363">       |F100%  SD100% T--:--|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-364">       |Status line.........|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-365">*/</front>
<front id="ultralcd_implementation_hitachi_HD44780H-366">static void lcd_implementation_status_screen()</front>
<front id="ultralcd_implementation_hitachi_HD44780H-367">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-368">    int tHotend=int(degHotend(0) + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-369">    int tTarget=int(degTargetHotend(0) + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-370"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-371">#if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-372">    lcd.setCursor(0, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-373">    lcd.print(itostr3(tHotend));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-374">    lcd.print('/');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-375">    lcd.print(itostr3left(tTarget));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-376"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-377"># if EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-378">    //If we have an 2nd extruder or heated bed, show that in the top right corner</front>
<front id="ultralcd_implementation_hitachi_HD44780H-379">    lcd.setCursor(8, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-380">#  if EXTRUDERS &gt; 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-381">    tHotend = int(degHotend(1) + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-382">    tTarget = int(degTargetHotend(1) + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-383">    lcd.print(LCD_STR_THERMOMETER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-384">#  else//Heated bed</front>
<front id="ultralcd_implementation_hitachi_HD44780H-385">    tHotend=int(degBed() + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-386">    tTarget=int(degTargetBed() + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-387">    lcd.print(LCD_STR_BEDTEMP[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-388">#  endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-389">    lcd.print(itostr3(tHotend));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-390">    lcd.print('/');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-391">    lcd.print(itostr3left(tTarget));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-392"># endif//EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-393"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-394">#else//LCD_WIDTH &gt; 19</front>
<front id="ultralcd_implementation_hitachi_HD44780H-395">    lcd.setCursor(0, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-396">    lcd.print(LCD_STR_THERMOMETER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-397">    lcd.print(itostr3(tHotend));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-398">    lcd.print('/');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-399">    lcd.print(itostr3left(tTarget));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-400">    lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-401">    if (tTarget &lt; 10)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-402">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-403"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-404"># if EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-405">    //If we have an 2nd extruder or heated bed, show that in the top right corner</front>
<front id="ultralcd_implementation_hitachi_HD44780H-406">    lcd.setCursor(10, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-407">#  if EXTRUDERS &gt; 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-408">    tHotend = int(degHotend(1) + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-409">    tTarget = int(degTargetHotend(1) + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-410">    lcd.print(LCD_STR_THERMOMETER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-411">#  else//Heated bed</front>
<front id="ultralcd_implementation_hitachi_HD44780H-412">    tHotend=int(degBed() + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-413">    tTarget=int(degTargetBed() + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-414">    lcd.print(LCD_STR_BEDTEMP[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-415">#  endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-416">    lcd.print(itostr3(tHotend));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-417">    lcd.print('/');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-418">    lcd.print(itostr3left(tTarget));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-419">    lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-420">    if (tTarget &lt; 10)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-421">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-422"># endif//EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-423">#endif//LCD_WIDTH &gt; 19</front>
<front id="ultralcd_implementation_hitachi_HD44780H-424"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-425">#if LCD_HEIGHT &gt; 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-426">//Lines 2 for 4 line LCD</front>
<front id="ultralcd_implementation_hitachi_HD44780H-427"># if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-428">#  ifdef SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-429">    lcd.setCursor(0, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-430">    lcd_printPGM(PSTR("SD"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-431">    if (IS_SD_PRINTING)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-432">        lcd.print(itostr3(card.percentDone()));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-433">    else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-434">        lcd_printPGM(PSTR("---"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-435">    lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-436">#  endif//SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-437"># else//LCD_WIDTH &gt; 19</front>
<front id="ultralcd_implementation_hitachi_HD44780H-438">#  if EXTRUDERS &gt; 1 && TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-439">    //If we both have a 2nd extruder and a heated bed, show the heated bed temp on the 2nd line on the left, as the first line is filled with extruder temps</front>
<front id="ultralcd_implementation_hitachi_HD44780H-440">    tHotend=int(degBed() + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-441">    tTarget=int(degTargetBed() + 0.5);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-442"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-443">    lcd.setCursor(0, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-444">    lcd.print(LCD_STR_BEDTEMP[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-445">    lcd.print(itostr3(tHotend));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-446">    lcd.print('/');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-447">    lcd.print(itostr3left(tTarget));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-448">    lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-449">    if (tTarget &lt; 10)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-450">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-451">#  else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-452">    lcd.setCursor(0,1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-453">    lcd.print('X');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-454">    lcd.print(ftostr3(current_position[X_AXIS]));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-455">    lcd_printPGM(PSTR(" Y"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-456">    lcd.print(ftostr3(current_position[Y_AXIS]));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-457">#  endif//EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-458"># endif//LCD_WIDTH &gt; 19</front>
<front id="ultralcd_implementation_hitachi_HD44780H-459">    lcd.setCursor(LCD_WIDTH - 8, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-460">    lcd.print('Z');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-461">    lcd.print(ftostr32(current_position[Z_AXIS]));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-462">#endif//LCD_HEIGHT &gt; 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-463"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-464">#if LCD_HEIGHT &gt; 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-465">    lcd.setCursor(0, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-466">    lcd.print(LCD_STR_FEEDRATE[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-467">    lcd.print(itostr3(feedmultiply));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-468">    lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-469"># if LCD_WIDTH &gt; 19</front>
<front id="ultralcd_implementation_hitachi_HD44780H-470">#  ifdef SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-471">    lcd.setCursor(7, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-472">    lcd_printPGM(PSTR("SD"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-473">    if (IS_SD_PRINTING)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-474">        lcd.print(itostr3(card.percentDone()));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-475">    else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-476">        lcd_printPGM(PSTR("---"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-477">    lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-478">#  endif//SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-479"># endif//LCD_WIDTH &gt; 19</front>
<front id="ultralcd_implementation_hitachi_HD44780H-480">    lcd.setCursor(LCD_WIDTH - 6, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-481">    lcd.print(LCD_STR_CLOCK[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-482">    if(starttime != 0)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-483">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-484">        uint16_t time = millis()/60000 - starttime/60000;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-485">        lcd.print(itostr2(time/60));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-486">        lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-487">        lcd.print(itostr2(time%60));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-488">    }else{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-489">        lcd_printPGM(PSTR("--:--"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-490">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-491">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-492"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-493">    //Status message line on the last line</front>
<front id="ultralcd_implementation_hitachi_HD44780H-494">    lcd.setCursor(0, LCD_HEIGHT - 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-495">    lcd.print(lcd_status_message);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-496">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-497">static void lcd_implementation_drawmenu_generic(uint8_t row, const char* pstr, char pre_char, char post_char)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-498">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-499">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-500">    //Use all characters in narrow LCDs</front>
<front id="ultralcd_implementation_hitachi_HD44780H-501">  #if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-502">      uint8_t n = LCD_WIDTH - 1 - 1;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-503">    #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-504">      uint8_t n = LCD_WIDTH - 1 - 2;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-505">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-506">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-507">    lcd.print(pre_char);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-508">    while( ((c = pgm_read_byte(pstr)) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-509">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-510">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-511">        pstr++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-512">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-513">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-514">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-515">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-516">    lcd.print(post_char);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-517">    lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-518">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-519">static void lcd_implementation_drawmenu_setting_edit_generic(uint8_t row, const char* pstr, char pre_char, char* data)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-520">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-521">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-522">    //Use all characters in narrow LCDs</front>
<front id="ultralcd_implementation_hitachi_HD44780H-523">  #if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-524">      uint8_t n = LCD_WIDTH - 1 - 1 - strlen(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-525">    #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-526">      uint8_t n = LCD_WIDTH - 1 - 2 - strlen(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-527">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-528">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-529">    lcd.print(pre_char);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-530">    while( ((c = pgm_read_byte(pstr)) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-531">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-532">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-533">        pstr++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-534">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-535">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-536">    lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-537">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-538">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-539">    lcd.print(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-540">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-541">static void lcd_implementation_drawmenu_setting_edit_generic_P(uint8_t row, const char* pstr, char pre_char, const char* data)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-542">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-543">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-544">    //Use all characters in narrow LCDs</front>
<front id="ultralcd_implementation_hitachi_HD44780H-545">  #if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-546">      uint8_t n = LCD_WIDTH - 1 - 1 - strlen_P(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-547">    #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-548">      uint8_t n = LCD_WIDTH - 1 - 2 - strlen_P(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-549">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-550">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-551">    lcd.print(pre_char);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-552">    while( ((c = pgm_read_byte(pstr)) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-553">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-554">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-555">        pstr++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-556">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-557">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-558">    lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-559">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-560">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-561">    lcd_printPGM(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-562">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-563">#define lcd_implementation_drawmenu_setting_edit_int3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', itostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-564">#define lcd_implementation_drawmenu_setting_edit_int3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', itostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-565">#define lcd_implementation_drawmenu_setting_edit_float3_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-566">#define lcd_implementation_drawmenu_setting_edit_float3(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-567">#define lcd_implementation_drawmenu_setting_edit_float32_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr32(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-568">#define lcd_implementation_drawmenu_setting_edit_float32(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr32(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-569">#define lcd_implementation_drawmenu_setting_edit_float5_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-570">#define lcd_implementation_drawmenu_setting_edit_float5(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-571">#define lcd_implementation_drawmenu_setting_edit_float52_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr52(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-572">#define lcd_implementation_drawmenu_setting_edit_float52(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr52(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-573">#define lcd_implementation_drawmenu_setting_edit_float51_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr51(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-574">#define lcd_implementation_drawmenu_setting_edit_float51(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr51(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-575">#define lcd_implementation_drawmenu_setting_edit_long5_selected(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-576">#define lcd_implementation_drawmenu_setting_edit_long5(row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-577">#define lcd_implementation_drawmenu_setting_edit_bool_selected(row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, '&gt;', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-578">#define lcd_implementation_drawmenu_setting_edit_bool(row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, ' ', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-579"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-580">//Add version for callback functions</front>
<front id="ultralcd_implementation_hitachi_HD44780H-581">#define lcd_implementation_drawmenu_setting_edit_callback_int3_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', itostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-582">#define lcd_implementation_drawmenu_setting_edit_callback_int3(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', itostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-583">#define lcd_implementation_drawmenu_setting_edit_callback_float3_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-584">#define lcd_implementation_drawmenu_setting_edit_callback_float3(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-585">#define lcd_implementation_drawmenu_setting_edit_callback_float32_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr32(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-586">#define lcd_implementation_drawmenu_setting_edit_callback_float32(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr32(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-587">#define lcd_implementation_drawmenu_setting_edit_callback_float5_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-588">#define lcd_implementation_drawmenu_setting_edit_callback_float5(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-589">#define lcd_implementation_drawmenu_setting_edit_callback_float52_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr52(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-590">#define lcd_implementation_drawmenu_setting_edit_callback_float52(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr52(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-591">#define lcd_implementation_drawmenu_setting_edit_callback_float51_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr51(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-592">#define lcd_implementation_drawmenu_setting_edit_callback_float51(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr51(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-593">#define lcd_implementation_drawmenu_setting_edit_callback_long5_selected(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-594">#define lcd_implementation_drawmenu_setting_edit_callback_long5(row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(row, pstr, ' ', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-595">#define lcd_implementation_drawmenu_setting_edit_callback_bool_selected(row, pstr, pstr2, data, callback) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, '&gt;', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-596">#define lcd_implementation_drawmenu_setting_edit_callback_bool(row, pstr, pstr2, data, callback) lcd_implementation_drawmenu_setting_edit_generic_P(row, pstr, ' ', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-597"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-598"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-599">void lcd_implementation_drawedit(const char* pstr, char* value)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-600">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-601">    lcd.setCursor(1, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-602">    lcd_printPGM(pstr);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-603">    lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-604">   #if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-605">      lcd.setCursor(LCD_WIDTH - strlen(value), 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-606">    #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-607">      lcd.setCursor(LCD_WIDTH -1 - strlen(value), 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-608">   #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-609">    lcd.print(value);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-610">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-611">static void lcd_implementation_drawmenu_sdfile_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-612">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-613">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-614">    uint8_t n = LCD_WIDTH - 1;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-615">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-616">    lcd.print('&gt;');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-617">    if (longFilename[0] != '\0')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-618">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-619">        filename = longFilename;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-620">        longFilename[LCD_WIDTH-1] = '\0';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-621">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-622">    while( ((c = *filename) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-623">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-624">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-625">        filename++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-626">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-627">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-628">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-629">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-630">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-631">static void lcd_implementation_drawmenu_sdfile(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-632">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-633">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-634">    uint8_t n = LCD_WIDTH - 1;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-635">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-636">    lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-637">    if (longFilename[0] != '\0')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-638">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-639">        filename = longFilename;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-640">        longFilename[LCD_WIDTH-1] = '\0';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-641">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-642">    while( ((c = *filename) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-643">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-644">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-645">        filename++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-646">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-647">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-648">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-649">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-650">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-651">static void lcd_implementation_drawmenu_sddirectory_selected(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-652">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-653">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-654">    uint8_t n = LCD_WIDTH - 2;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-655">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-656">    lcd.print('&gt;');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-657">    lcd.print(LCD_STR_FOLDER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-658">    if (longFilename[0] != '\0')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-659">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-660">        filename = longFilename;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-661">        longFilename[LCD_WIDTH-2] = '\0';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-662">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-663">    while( ((c = *filename) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-664">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-665">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-666">        filename++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-667">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-668">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-669">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-670">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-671">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-672">static void lcd_implementation_drawmenu_sddirectory(uint8_t row, const char* pstr, const char* filename, char* longFilename)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-673">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-674">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-675">    uint8_t n = LCD_WIDTH - 2;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-676">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-677">    lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-678">    lcd.print(LCD_STR_FOLDER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-679">    if (longFilename[0] != '\0')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-680">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-681">        filename = longFilename;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-682">        longFilename[LCD_WIDTH-2] = '\0';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-683">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-684">    while( ((c = *filename) != '\0') && (n&gt;0) )</front>
<front id="ultralcd_implementation_hitachi_HD44780H-685">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-686">        lcd.print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-687">        filename++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-688">        n--;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-689">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-690">    while(n--)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-691">        lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-692">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-693">#define lcd_implementation_drawmenu_back_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-694">#define lcd_implementation_drawmenu_back(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_UPLEVEL[0])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-695">#define lcd_implementation_drawmenu_submenu_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, '&gt;', LCD_STR_ARROW_RIGHT[0])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-696">#define lcd_implementation_drawmenu_submenu(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', LCD_STR_ARROW_RIGHT[0])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-697">#define lcd_implementation_drawmenu_gcode_selected(row, pstr, gcode) lcd_implementation_drawmenu_generic(row, pstr, '&gt;', ' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-698">#define lcd_implementation_drawmenu_gcode(row, pstr, gcode) lcd_implementation_drawmenu_generic(row, pstr, ' ', ' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-699">#define lcd_implementation_drawmenu_function_selected(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, '&gt;', ' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-700">#define lcd_implementation_drawmenu_function(row, pstr, data) lcd_implementation_drawmenu_generic(row, pstr, ' ', ' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-701"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-702">static void lcd_implementation_quick_feedback()</front>
<front id="ultralcd_implementation_hitachi_HD44780H-703">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-704">#ifdef LCD_USE_I2C_BUZZER</front>
<front id="ultralcd_implementation_hitachi_HD44780H-705">    lcd.buzz(60,1000/6);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-706">#elif defined(BEEPER) && BEEPER &gt; -1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-707">    SET_OUTPUT(BEEPER);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-708">    for(int8_t i=0;i&lt;10;i++)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-709">    {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-710">      WRITE(BEEPER,HIGH);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-711">      delayMicroseconds(100);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-712">      WRITE(BEEPER,LOW);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-713">      delayMicroseconds(100);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-714">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-715">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-716">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-717"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-718">#ifdef LCD_HAS_STATUS_INDICATORS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-719">static void lcd_implementation_update_indicators()</front>
<front id="ultralcd_implementation_hitachi_HD44780H-720">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-721">  #if defined(LCD_I2C_PANELOLU2) || defined(LCD_I2C_VIKI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-722">    //set the LEDS - referred to as backlights by the LiquidTWI2 library </front>
<front id="ultralcd_implementation_hitachi_HD44780H-723">    static uint8_t ledsprev = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-724">    uint8_t leds = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-725">    if (target_temperature_bed &gt; 0) leds |= LED_A;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-726">    if (target_temperature[0] &gt; 0) leds |= LED_B;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-727">    if (fanSpeed) leds |= LED_C;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-728">    #if EXTRUDERS &gt; 1  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-729">      if (target_temperature[1] &gt; 0) leds |= LED_C;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-730">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-731">    if (leds != ledsprev) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-732">      lcd.setBacklight(leds);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-733">      ledsprev = leds;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-734">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-735">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-736">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-737">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-738"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-739">#ifdef LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-740">static uint8_t lcd_implementation_read_slow_buttons()</front>
<front id="ultralcd_implementation_hitachi_HD44780H-741">{</front>
<front id="ultralcd_implementation_hitachi_HD44780H-742">  #ifdef LCD_I2C_TYPE_MCP23017</front>
<front id="ultralcd_implementation_hitachi_HD44780H-743">    // Reading these buttons this is likely to be too slow to call inside interrupt context</front>
<front id="ultralcd_implementation_hitachi_HD44780H-744">    // so they are called during normal lcd_update</front>
<front id="ultralcd_implementation_hitachi_HD44780H-745">    return lcd.readButtons() &lt;&lt; B_I2C_BTN_OFFSET; </front>
<front id="ultralcd_implementation_hitachi_HD44780H-746">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-747">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-748">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-749"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-750">#endif//ULTRA_LCD_IMPLEMENTATION_HITACHI_HD44780_H</front>
 </pre>
<h1>ultralcd_st7920_u8glib_rrd.h</h1>
<pre  class="prettyprint linenums"><front id="ultralcd_st7920_u8glib_rrdH-1">#ifndef ULCDST7920_H</front>
<front id="ultralcd_st7920_u8glib_rrdH-2">#define ULCDST7920_H</front>
<front id="ultralcd_st7920_u8glib_rrdH-3"></front>
<front id="ultralcd_st7920_u8glib_rrdH-4">#include "Marlin.h"</front>
<front id="ultralcd_st7920_u8glib_rrdH-5"></front>
<front id="ultralcd_st7920_u8glib_rrdH-6">#ifdef U8GLIB_ST7920</front>
<front id="ultralcd_st7920_u8glib_rrdH-7"></front>
<front id="ultralcd_st7920_u8glib_rrdH-8">//set optimization so ARDUINO optimizes this file</front>
<front id="ultralcd_st7920_u8glib_rrdH-9">#pragma GCC optimize (3)</front>
<front id="ultralcd_st7920_u8glib_rrdH-10"></front>
<front id="ultralcd_st7920_u8glib_rrdH-11">#define ST7920_CLK_PIN  LCD_PINS_D4</front>
<front id="ultralcd_st7920_u8glib_rrdH-12">#define ST7920_DAT_PIN  LCD_PINS_ENABLE</front>
<front id="ultralcd_st7920_u8glib_rrdH-13">#define ST7920_CS_PIN   LCD_PINS_RS</front>
<front id="ultralcd_st7920_u8glib_rrdH-14"></front>
<front id="ultralcd_st7920_u8glib_rrdH-15">//#define PAGE_HEIGHT 8   //128 byte frambuffer</front>
<front id="ultralcd_st7920_u8glib_rrdH-16">//#define PAGE_HEIGHT 16  //256 byte frambuffer</front>
<front id="ultralcd_st7920_u8glib_rrdH-17">#define PAGE_HEIGHT 32  //512 byte framebuffer</front>
<front id="ultralcd_st7920_u8glib_rrdH-18"></front>
<front id="ultralcd_st7920_u8glib_rrdH-19">#define WIDTH 128</front>
<front id="ultralcd_st7920_u8glib_rrdH-20">#define HEIGHT 64</front>
<front id="ultralcd_st7920_u8glib_rrdH-21"></front>
<front id="ultralcd_st7920_u8glib_rrdH-22">#include &lt;U8glib.h&gt;</front>
<front id="ultralcd_st7920_u8glib_rrdH-23"></front>
<front id="ultralcd_st7920_u8glib_rrdH-24">static void ST7920_SWSPI_SND_8BIT(uint8_t val)</front>
<front id="ultralcd_st7920_u8glib_rrdH-25">{</front>
<front id="ultralcd_st7920_u8glib_rrdH-26">  uint8_t i;</front>
<front id="ultralcd_st7920_u8glib_rrdH-27">  for( i=0; i&lt;8; i++ )</front>
<front id="ultralcd_st7920_u8glib_rrdH-28">  {</front>
<front id="ultralcd_st7920_u8glib_rrdH-29">    WRITE(ST7920_CLK_PIN,0);</front>
<front id="ultralcd_st7920_u8glib_rrdH-30">    WRITE(ST7920_DAT_PIN,val&0x80); </front>
<front id="ultralcd_st7920_u8glib_rrdH-31">    val&lt;&lt;=1;</front>
<front id="ultralcd_st7920_u8glib_rrdH-32">    WRITE(ST7920_CLK_PIN,1);</front>
<front id="ultralcd_st7920_u8glib_rrdH-33">  }</front>
<front id="ultralcd_st7920_u8glib_rrdH-34">}</front>
<front id="ultralcd_st7920_u8glib_rrdH-35"></front>
<front id="ultralcd_st7920_u8glib_rrdH-36">#define ST7920_CS()              {WRITE(ST7920_CS_PIN,1);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-37">#define ST7920_NCS()             {WRITE(ST7920_CS_PIN,0);}</front>
<front id="ultralcd_st7920_u8glib_rrdH-38">#define ST7920_SET_CMD()         {ST7920_SWSPI_SND_8BIT(0xf8);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-39">#define ST7920_SET_DAT()         {ST7920_SWSPI_SND_8BIT(0xfa);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-40">#define ST7920_WRITE_BYTE(a)     {ST7920_SWSPI_SND_8BIT((a)&0xf0);ST7920_SWSPI_SND_8BIT((a)&lt;&lt;4);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-41">#define ST7920_WRITE_BYTES(p,l)  {uint8_t i;for(i=0;i&lt;l;i++){ST7920_SWSPI_SND_8BIT(*p&0xf0);ST7920_SWSPI_SND_8BIT(*p&lt;&lt;4);p++;}u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-42"></front>
<front id="ultralcd_st7920_u8glib_rrdH-43">uint8_t u8g_dev_rrd_st7920_128x64_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)</front>
<front id="ultralcd_st7920_u8glib_rrdH-44">{</front>
<front id="ultralcd_st7920_u8glib_rrdH-45">  uint8_t i,y;</front>
<front id="ultralcd_st7920_u8glib_rrdH-46">  switch(msg)</front>
<front id="ultralcd_st7920_u8glib_rrdH-47">  {</front>
<front id="ultralcd_st7920_u8glib_rrdH-48">    case U8G_DEV_MSG_INIT:</front>
<front id="ultralcd_st7920_u8glib_rrdH-49">      {</front>
<front id="ultralcd_st7920_u8glib_rrdH-50">        SET_OUTPUT(ST7920_CS_PIN);</front>
<front id="ultralcd_st7920_u8glib_rrdH-51">        WRITE(ST7920_CS_PIN,0);</front>
<front id="ultralcd_st7920_u8glib_rrdH-52">        SET_OUTPUT(ST7920_DAT_PIN);</front>
<front id="ultralcd_st7920_u8glib_rrdH-53">        WRITE(ST7920_DAT_PIN,0);</front>
<front id="ultralcd_st7920_u8glib_rrdH-54">        SET_OUTPUT(ST7920_CLK_PIN);</front>
<front id="ultralcd_st7920_u8glib_rrdH-55">        WRITE(ST7920_CLK_PIN,1);</front>
<front id="ultralcd_st7920_u8glib_rrdH-56"></front>
<front id="ultralcd_st7920_u8glib_rrdH-57">        ST7920_CS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-58">        u8g_Delay(90);                 //initial delay for boot up</front>
<front id="ultralcd_st7920_u8glib_rrdH-59">        ST7920_SET_CMD();</front>
<front id="ultralcd_st7920_u8glib_rrdH-60">        ST7920_WRITE_BYTE(0x08);       //display off, cursor+blink off</front>
<front id="ultralcd_st7920_u8glib_rrdH-61">        ST7920_WRITE_BYTE(0x01);       //clear CGRAM ram</front>
<front id="ultralcd_st7920_u8glib_rrdH-62">        u8g_Delay(10);                 //delay for cgram clear</front>
<front id="ultralcd_st7920_u8glib_rrdH-63">        ST7920_WRITE_BYTE(0x3E);       //extended mode + gdram active</front>
<front id="ultralcd_st7920_u8glib_rrdH-64">        for(y=0;y&lt;HEIGHT/2;y++)        //clear GDRAM</front>
<front id="ultralcd_st7920_u8glib_rrdH-65">        {</front>
<front id="ultralcd_st7920_u8glib_rrdH-66">          ST7920_WRITE_BYTE(0x80|y);   //set y</front>
<front id="ultralcd_st7920_u8glib_rrdH-67">          ST7920_WRITE_BYTE(0x80);     //set x = 0</front>
<front id="ultralcd_st7920_u8glib_rrdH-68">          ST7920_SET_DAT();</front>
<front id="ultralcd_st7920_u8glib_rrdH-69">          for(i=0;i&lt;2*WIDTH/8;i++)     //2x width clears both segments</front>
<front id="ultralcd_st7920_u8glib_rrdH-70">            ST7920_WRITE_BYTE(0);</front>
<front id="ultralcd_st7920_u8glib_rrdH-71">          ST7920_SET_CMD();</front>
<front id="ultralcd_st7920_u8glib_rrdH-72">        }</front>
<front id="ultralcd_st7920_u8glib_rrdH-73">        ST7920_WRITE_BYTE(0x0C); //display on, cursor+blink off</front>
<front id="ultralcd_st7920_u8glib_rrdH-74">        ST7920_NCS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-75">      }</front>
<front id="ultralcd_st7920_u8glib_rrdH-76">      break;</front>
<front id="ultralcd_st7920_u8glib_rrdH-77"></front>
<front id="ultralcd_st7920_u8glib_rrdH-78">    case U8G_DEV_MSG_STOP:</front>
<front id="ultralcd_st7920_u8glib_rrdH-79">      break;</front>
<front id="ultralcd_st7920_u8glib_rrdH-80">    case U8G_DEV_MSG_PAGE_NEXT:</front>
<front id="ultralcd_st7920_u8glib_rrdH-81">      {</front>
<front id="ultralcd_st7920_u8glib_rrdH-82">        uint8_t *ptr;</front>
<front id="ultralcd_st7920_u8glib_rrdH-83">        u8g_pb_t *pb = (u8g_pb_t *)(dev-&gt;dev_mem);</front>
<front id="ultralcd_st7920_u8glib_rrdH-84">        y = pb-&gt;p.page_y0;</front>
<front id="ultralcd_st7920_u8glib_rrdH-85">        ptr = (uint8_t*)pb-&gt;buf;</front>
<front id="ultralcd_st7920_u8glib_rrdH-86"></front>
<front id="ultralcd_st7920_u8glib_rrdH-87">        ST7920_CS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-88">        for( i = 0; i &lt; PAGE_HEIGHT; i ++ )</front>
<front id="ultralcd_st7920_u8glib_rrdH-89">        {</front>
<front id="ultralcd_st7920_u8glib_rrdH-90">          ST7920_SET_CMD();</front>
<front id="ultralcd_st7920_u8glib_rrdH-91">          if ( y &lt; 32 )</front>
<front id="ultralcd_st7920_u8glib_rrdH-92">          {</front>
<front id="ultralcd_st7920_u8glib_rrdH-93">            ST7920_WRITE_BYTE(0x80 | y);       //y</front>
<front id="ultralcd_st7920_u8glib_rrdH-94">            ST7920_WRITE_BYTE(0x80);           //x=0</front>
<front id="ultralcd_st7920_u8glib_rrdH-95">          }</front>
<front id="ultralcd_st7920_u8glib_rrdH-96">          else</front>
<front id="ultralcd_st7920_u8glib_rrdH-97">          {</front>
<front id="ultralcd_st7920_u8glib_rrdH-98">            ST7920_WRITE_BYTE(0x80 | (y-32));  //y</front>
<front id="ultralcd_st7920_u8glib_rrdH-99">            ST7920_WRITE_BYTE(0x80 | 8);       //x=64</front>
<front id="ultralcd_st7920_u8glib_rrdH-100">          }</front>
<front id="ultralcd_st7920_u8glib_rrdH-101"></front>
<front id="ultralcd_st7920_u8glib_rrdH-102">          ST7920_SET_DAT();</front>
<front id="ultralcd_st7920_u8glib_rrdH-103">          ST7920_WRITE_BYTES(ptr,WIDTH/8); //ptr is incremented inside of macro</front>
<front id="ultralcd_st7920_u8glib_rrdH-104">          y++;</front>
<front id="ultralcd_st7920_u8glib_rrdH-105">        }</front>
<front id="ultralcd_st7920_u8glib_rrdH-106">        ST7920_NCS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-107">      }</front>
<front id="ultralcd_st7920_u8glib_rrdH-108">      break;</front>
<front id="ultralcd_st7920_u8glib_rrdH-109">  }</front>
<front id="ultralcd_st7920_u8glib_rrdH-110">#if PAGE_HEIGHT == 8</front>
<front id="ultralcd_st7920_u8glib_rrdH-111">  return u8g_dev_pb8h1_base_fn(u8g, dev, msg, arg);</front>
<front id="ultralcd_st7920_u8glib_rrdH-112">#elif PAGE_HEIGHT == 16</front>
<front id="ultralcd_st7920_u8glib_rrdH-113">  return u8g_dev_pb16h1_base_fn(u8g, dev, msg, arg);</front>
<front id="ultralcd_st7920_u8glib_rrdH-114">#else</front>
<front id="ultralcd_st7920_u8glib_rrdH-115">  return u8g_dev_pb32h1_base_fn(u8g, dev, msg, arg);</front>
<front id="ultralcd_st7920_u8glib_rrdH-116">#endif</front>
<front id="ultralcd_st7920_u8glib_rrdH-117">}</front>
<front id="ultralcd_st7920_u8glib_rrdH-118"></front>
<front id="ultralcd_st7920_u8glib_rrdH-119">uint8_t   u8g_dev_st7920_128x64_rrd_buf[WIDTH*(PAGE_HEIGHT/8)] U8G_NOCOMMON;</front>
<front id="ultralcd_st7920_u8glib_rrdH-120">u8g_pb_t  u8g_dev_st7920_128x64_rrd_pb = {{PAGE_HEIGHT,HEIGHT,0,0,0},WIDTH,u8g_dev_st7920_128x64_rrd_buf};</front>
<front id="ultralcd_st7920_u8glib_rrdH-121">u8g_dev_t u8g_dev_st7920_128x64_rrd_sw_spi = {u8g_dev_rrd_st7920_128x64_fn,&u8g_dev_st7920_128x64_rrd_pb,&u8g_com_null_fn};</front>
<front id="ultralcd_st7920_u8glib_rrdH-122"></front>
<front id="ultralcd_st7920_u8glib_rrdH-123">class U8GLIB_ST7920_128X64_RRD : public U8GLIB</front>
<front id="ultralcd_st7920_u8glib_rrdH-124">{</front>
<front id="ultralcd_st7920_u8glib_rrdH-125">  public:</front>
<front id="ultralcd_st7920_u8glib_rrdH-126">    U8GLIB_ST7920_128X64_RRD(uint8_t dummy) : U8GLIB(&u8g_dev_st7920_128x64_rrd_sw_spi) {}</front>
<front id="ultralcd_st7920_u8glib_rrdH-127">};</front>
<front id="ultralcd_st7920_u8glib_rrdH-128"></front>
<front id="ultralcd_st7920_u8glib_rrdH-129"></front>
<front id="ultralcd_st7920_u8glib_rrdH-130">#endif //U8GLIB_ST7920</front>
<front id="ultralcd_st7920_u8glib_rrdH-131">#endif //ULCDST7920_H</front>
 </pre>
<h1>vector_3.cpp</h1>
<pre  class="prettyprint linenums"><front id="vector_3CPP-1">/*</front>
<front id="vector_3CPP-2">  vector_3.cpp - Vector library for bed leveling</front>
<front id="vector_3CPP-3">  Copyright (c) 2012 Lars Brubaker.  All right reserved.</front>
<front id="vector_3CPP-4"></front>
<front id="vector_3CPP-5">  This library is free software; you can redistribute it and/or</front>
<front id="vector_3CPP-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="vector_3CPP-7">  License as published by the Free Software Foundation; either</front>
<front id="vector_3CPP-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="vector_3CPP-9"></front>
<front id="vector_3CPP-10">  This library is distributed in the hope that it will be useful,</front>
<front id="vector_3CPP-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="vector_3CPP-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="vector_3CPP-13">  Lesser General Public License for more details.</front>
<front id="vector_3CPP-14"></front>
<front id="vector_3CPP-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="vector_3CPP-16">  License along with this library; if not, write to the Free Software</front>
<front id="vector_3CPP-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="vector_3CPP-18">*/</front>
<front id="vector_3CPP-19">#include &lt;math.h&gt;</front>
<front id="vector_3CPP-20">#include "Marlin.h"</front>
<front id="vector_3CPP-21"></front>
<front id="vector_3CPP-22">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="vector_3CPP-23">#include "vector_3.h"</front>
<front id="vector_3CPP-24"></front>
<front id="vector_3CPP-25">vector_3::vector_3()</front>
<front id="vector_3CPP-26">{</front>
<front id="vector_3CPP-27">  this-&gt;x = 0;</front>
<front id="vector_3CPP-28">  this-&gt;y = 0;</front>
<front id="vector_3CPP-29">  this-&gt;z = 0;</front>
<front id="vector_3CPP-30">}</front>
<front id="vector_3CPP-31"></front>
<front id="vector_3CPP-32">vector_3::vector_3(float x, float y, float z)</front>
<front id="vector_3CPP-33">{</front>
<front id="vector_3CPP-34">	this-&gt;x = x;</front>
<front id="vector_3CPP-35">	this-&gt;y = y;</front>
<front id="vector_3CPP-36">	this-&gt;z = z;</front>
<front id="vector_3CPP-37">}</front>
<front id="vector_3CPP-38"></front>
<front id="vector_3CPP-39">vector_3 vector_3::cross(vector_3 left, vector_3 right)</front>
<front id="vector_3CPP-40">{</front>
<front id="vector_3CPP-41">	return vector_3(left.y * right.z - left.z * right.y,</front>
<front id="vector_3CPP-42">		left.z * right.x - left.x * right.z,</front>
<front id="vector_3CPP-43">		left.x * right.y - left.y * right.x);</front>
<front id="vector_3CPP-44">}</front>
<front id="vector_3CPP-45"></front>
<front id="vector_3CPP-46">vector_3 vector_3::operator+(vector_3 v) </front>
<front id="vector_3CPP-47">{</front>
<front id="vector_3CPP-48">	return vector_3((x + v.x), (y + v.y), (z + v.z));</front>
<front id="vector_3CPP-49">}</front>
<front id="vector_3CPP-50"></front>
<front id="vector_3CPP-51">vector_3 vector_3::operator-(vector_3 v) </front>
<front id="vector_3CPP-52">{</front>
<front id="vector_3CPP-53">	return vector_3((x - v.x), (y - v.y), (z - v.z));</front>
<front id="vector_3CPP-54">}</front>
<front id="vector_3CPP-55"></front>
<front id="vector_3CPP-56">vector_3 vector_3::get_normal() </front>
<front id="vector_3CPP-57">{</front>
<front id="vector_3CPP-58">	vector_3 normalized = vector_3(x, y, z);</front>
<front id="vector_3CPP-59">	normalized.normalize();</front>
<front id="vector_3CPP-60">	return normalized;</front>
<front id="vector_3CPP-61">}</front>
<front id="vector_3CPP-62"></front>
<front id="vector_3CPP-63">float vector_3::get_length() </front>
<front id="vector_3CPP-64">{</front>
<front id="vector_3CPP-65">        float length = sqrt((x * x) + (y * y) + (z * z));</front>
<front id="vector_3CPP-66">	return length;</front>
<front id="vector_3CPP-67">}</front>
<front id="vector_3CPP-68"> </front>
<front id="vector_3CPP-69">void vector_3::normalize()</front>
<front id="vector_3CPP-70">{</front>
<front id="vector_3CPP-71">	float length = get_length();</front>
<front id="vector_3CPP-72">	x /= length;</front>
<front id="vector_3CPP-73">	y /= length;</front>
<front id="vector_3CPP-74">	z /= length;</front>
<front id="vector_3CPP-75">}</front>
<front id="vector_3CPP-76"></front>
<front id="vector_3CPP-77">void vector_3::apply_rotation(matrix_3x3 matrix)</front>
<front id="vector_3CPP-78">{</front>
<front id="vector_3CPP-79">	float resultX = x * matrix.matrix[3*0+0] + y * matrix.matrix[3*1+0] + z * matrix.matrix[3*2+0];</front>
<front id="vector_3CPP-80">	float resultY = x * matrix.matrix[3*0+1] + y * matrix.matrix[3*1+1] + z * matrix.matrix[3*2+1];</front>
<front id="vector_3CPP-81">	float resultZ = x * matrix.matrix[3*0+2] + y * matrix.matrix[3*1+2] + z * matrix.matrix[3*2+2];</front>
<front id="vector_3CPP-82"></front>
<front id="vector_3CPP-83">	x = resultX;</front>
<front id="vector_3CPP-84">	y = resultY;</front>
<front id="vector_3CPP-85">	z = resultZ;</front>
<front id="vector_3CPP-86">}</front>
<front id="vector_3CPP-87"></front>
<front id="vector_3CPP-88">void vector_3::debug(char* title)</front>
<front id="vector_3CPP-89">{</front>
<front id="vector_3CPP-90">	SERIAL_PROTOCOL(title);</front>
<front id="vector_3CPP-91">	SERIAL_PROTOCOLPGM(" x: ");</front>
<front id="vector_3CPP-92">	SERIAL_PROTOCOL(x);</front>
<front id="vector_3CPP-93">	SERIAL_PROTOCOLPGM(" y: ");</front>
<front id="vector_3CPP-94">	SERIAL_PROTOCOL(y);</front>
<front id="vector_3CPP-95">	SERIAL_PROTOCOLPGM(" z: ");</front>
<front id="vector_3CPP-96">	SERIAL_PROTOCOL(z);</front>
<front id="vector_3CPP-97">	SERIAL_PROTOCOLPGM("\n");</front>
<front id="vector_3CPP-98">}</front>
<front id="vector_3CPP-99"></front>
<front id="vector_3CPP-100">void apply_rotation_xyz(matrix_3x3 matrix, float &x, float& y, float& z)</front>
<front id="vector_3CPP-101">{</front>
<front id="vector_3CPP-102">	vector_3 vector = vector_3(x, y, z);</front>
<front id="vector_3CPP-103">	vector.apply_rotation(matrix);</front>
<front id="vector_3CPP-104">	x = vector.x;</front>
<front id="vector_3CPP-105">	y = vector.y;</front>
<front id="vector_3CPP-106">	z = vector.z;</front>
<front id="vector_3CPP-107">}</front>
<front id="vector_3CPP-108"></front>
<front id="vector_3CPP-109">matrix_3x3 matrix_3x3::create_from_rows(vector_3 row_0, vector_3 row_1, vector_3 row_2)</front>
<front id="vector_3CPP-110">{</front>
<front id="vector_3CPP-111">        //row_0.debug("row_0");</front>
<front id="vector_3CPP-112">        //row_1.debug("row_1");</front>
<front id="vector_3CPP-113">        //row_2.debug("row_2");</front>
<front id="vector_3CPP-114">	matrix_3x3 new_matrix;</front>
<front id="vector_3CPP-115">	new_matrix.matrix[0] = row_0.x; new_matrix.matrix[1] = row_0.y; new_matrix.matrix[2] = row_0.z; </front>
<front id="vector_3CPP-116">	new_matrix.matrix[3] = row_1.x; new_matrix.matrix[4] = row_1.y; new_matrix.matrix[5] = row_1.z; </front>
<front id="vector_3CPP-117">	new_matrix.matrix[6] = row_2.x; new_matrix.matrix[7] = row_2.y; new_matrix.matrix[8] = row_2.z; </front>
<front id="vector_3CPP-118">        //new_matrix.debug("new_matrix");</front>
<front id="vector_3CPP-119">        </front>
<front id="vector_3CPP-120">	return new_matrix;</front>
<front id="vector_3CPP-121">}</front>
<front id="vector_3CPP-122"></front>
<front id="vector_3CPP-123">void matrix_3x3::set_to_identity()</front>
<front id="vector_3CPP-124">{</front>
<front id="vector_3CPP-125">	matrix[0] = 1; matrix[1] = 0; matrix[2] = 0;</front>
<front id="vector_3CPP-126">	matrix[3] = 0; matrix[4] = 1; matrix[5] = 0;</front>
<front id="vector_3CPP-127">	matrix[6] = 0; matrix[7] = 0; matrix[8] = 1;</front>
<front id="vector_3CPP-128">}</front>
<front id="vector_3CPP-129"></front>
<front id="vector_3CPP-130">matrix_3x3 matrix_3x3::create_look_at(vector_3 target, vector_3 up)</front>
<front id="vector_3CPP-131">{</front>
<front id="vector_3CPP-132">    // There are lots of examples of look at code on the internet that don't do all these noramize and also find the position</front>
<front id="vector_3CPP-133">    // through several dot products.  The problem with them is that they have a bit of error in that all the vectors arn't normal and need to be.</front>
<front id="vector_3CPP-134">    vector_3 z_row = vector_3(-target.x, -target.y, -target.z).get_normal();</front>
<front id="vector_3CPP-135">    vector_3 x_row = vector_3::cross(up, z_row).get_normal();</front>
<front id="vector_3CPP-136">    vector_3 y_row = vector_3::cross(z_row, x_row).get_normal();</front>
<front id="vector_3CPP-137"></front>
<front id="vector_3CPP-138">    //x_row.debug("x_row");</front>
<front id="vector_3CPP-139">    //y_row.debug("y_row");</front>
<front id="vector_3CPP-140">    //z_row.debug("z_row");</front>
<front id="vector_3CPP-141">    </front>
<front id="vector_3CPP-142">    matrix_3x3 rot = matrix_3x3::create_from_rows(vector_3(x_row.x, y_row.x, z_row.x),</front>
<front id="vector_3CPP-143">                                vector_3(x_row.y, y_row.y, z_row.y),</front>
<front id="vector_3CPP-144">                                vector_3(x_row.z, y_row.z, z_row.z));</front>
<front id="vector_3CPP-145"></front>
<front id="vector_3CPP-146">    //rot.debug("rot");</front>
<front id="vector_3CPP-147">    return rot;</front>
<front id="vector_3CPP-148">}</front>
<front id="vector_3CPP-149"></front>
<front id="vector_3CPP-150">matrix_3x3 matrix_3x3::create_inverse(matrix_3x3 original)</front>
<front id="vector_3CPP-151">{</front>
<front id="vector_3CPP-152">	//original.debug("original");</front>
<front id="vector_3CPP-153">	float* A = original.matrix;</front>
<front id="vector_3CPP-154">	float determinant = </front>
<front id="vector_3CPP-155">		+ A[0 * 3 + 0] * (A[1 * 3 + 1] * A[2 * 3 + 2] - A[2 * 3 + 1] * A[1 * 3 + 2])</front>
<front id="vector_3CPP-156">		- A[0 * 3 + 1] * (A[1 * 3 + 0] * A[2 * 3 + 2] - A[1 * 3 + 2] * A[2 * 3 + 0])</front>
<front id="vector_3CPP-157">		+ A[0 * 3 + 2] * (A[1 * 3 + 0] * A[2 * 3 + 1] - A[1 * 3 + 1] * A[2 * 3 + 0]);</front>
<front id="vector_3CPP-158">	matrix_3x3 inverse;</front>
<front id="vector_3CPP-159">	inverse.matrix[0 * 3 + 0] = +(A[1 * 3 + 1] * A[2 * 3 + 2] - A[2 * 3 + 1] * A[1 * 3 + 2]) / determinant;</front>
<front id="vector_3CPP-160">	inverse.matrix[0 * 3 + 1] = -(A[0 * 3 + 1] * A[2 * 3 + 2] - A[0 * 3 + 2] * A[2 * 3 + 1]) / determinant;</front>
<front id="vector_3CPP-161">	inverse.matrix[0 * 3 + 2] = +(A[0 * 3 + 1] * A[1 * 3 + 2] - A[0 * 3 + 2] * A[1 * 3 + 1]) / determinant;</front>
<front id="vector_3CPP-162">	inverse.matrix[1 * 3 + 0] = -(A[1 * 3 + 0] * A[2 * 3 + 2] - A[1 * 3 + 2] * A[2 * 3 + 0]) / determinant;</front>
<front id="vector_3CPP-163">	inverse.matrix[1 * 3 + 1] = +(A[0 * 3 + 0] * A[2 * 3 + 2] - A[0 * 3 + 2] * A[2 * 3 + 0]) / determinant;</front>
<front id="vector_3CPP-164">	inverse.matrix[1 * 3 + 2] = -(A[0 * 3 + 0] * A[1 * 3 + 2] - A[1 * 3 + 0] * A[0 * 3 + 2]) / determinant;</front>
<front id="vector_3CPP-165">	inverse.matrix[2 * 3 + 0] = +(A[1 * 3 + 0] * A[2 * 3 + 1] - A[2 * 3 + 0] * A[1 * 3 + 1]) / determinant;</front>
<front id="vector_3CPP-166">	inverse.matrix[2 * 3 + 1] = -(A[0 * 3 + 0] * A[2 * 3 + 1] - A[2 * 3 + 0] * A[0 * 3 + 1]) / determinant;</front>
<front id="vector_3CPP-167">	inverse.matrix[2 * 3 + 2] = +(A[0 * 3 + 0] * A[1 * 3 + 1] - A[1 * 3 + 0] * A[0 * 3 + 1]) / determinant;</front>
<front id="vector_3CPP-168"></front>
<front id="vector_3CPP-169">	vector_3 row0 = vector_3(inverse.matrix[0 * 3 + 0], inverse.matrix[0 * 3 + 1], inverse.matrix[0 * 3 + 2]);</front>
<front id="vector_3CPP-170">	vector_3 row1 = vector_3(inverse.matrix[1 * 3 + 0], inverse.matrix[1 * 3 + 1], inverse.matrix[1 * 3 + 2]);</front>
<front id="vector_3CPP-171">	vector_3 row2 = vector_3(inverse.matrix[2 * 3 + 0], inverse.matrix[2 * 3 + 1], inverse.matrix[2 * 3 + 2]);</front>
<front id="vector_3CPP-172"></front>
<front id="vector_3CPP-173">    row0.normalize();</front>
<front id="vector_3CPP-174">    row1.normalize();</front>
<front id="vector_3CPP-175">    row2.normalize();</front>
<front id="vector_3CPP-176"></front>
<front id="vector_3CPP-177">	inverse = matrix_3x3::create_from_rows(row0, row1, row2);</front>
<front id="vector_3CPP-178"></front>
<front id="vector_3CPP-179">	//inverse.debug("inverse");</front>
<front id="vector_3CPP-180">	return inverse;</front>
<front id="vector_3CPP-181">}</front>
<front id="vector_3CPP-182"></front>
<front id="vector_3CPP-183">void matrix_3x3::debug(char* title)</front>
<front id="vector_3CPP-184">{</front>
<front id="vector_3CPP-185">	SERIAL_PROTOCOL(title);</front>
<front id="vector_3CPP-186">	SERIAL_PROTOCOL("\n");</front>
<front id="vector_3CPP-187">	int count = 0;</front>
<front id="vector_3CPP-188">	for(int i=0; i&lt;3; i++)</front>
<front id="vector_3CPP-189">	{</front>
<front id="vector_3CPP-190">		for(int j=0; j&lt;3; j++)</front>
<front id="vector_3CPP-191">		{</front>
<front id="vector_3CPP-192">			SERIAL_PROTOCOL(matrix[count]);</front>
<front id="vector_3CPP-193">			SERIAL_PROTOCOLPGM(" ");</front>
<front id="vector_3CPP-194">		        count++;</front>
<front id="vector_3CPP-195">		}</front>
<front id="vector_3CPP-196"></front>
<front id="vector_3CPP-197">		SERIAL_PROTOCOLPGM("\n");</front>
<front id="vector_3CPP-198">	}</front>
<front id="vector_3CPP-199">}</front>
<front id="vector_3CPP-200"></front>
<front id="vector_3CPP-201">#endif // #ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="vector_3CPP-202"></front>
 </pre>
<h1>vector_3.h</h1>
<pre  class="prettyprint linenums"><front id="vector_3H-1">/*</front>
<front id="vector_3H-2">  vector_3.cpp - Vector library for bed leveling</front>
<front id="vector_3H-3">  Copyright (c) 2012 Lars Brubaker.  All right reserved.</front>
<front id="vector_3H-4"></front>
<front id="vector_3H-5">  This library is free software; you can redistribute it and/or</front>
<front id="vector_3H-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="vector_3H-7">  License as published by the Free Software Foundation; either</front>
<front id="vector_3H-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="vector_3H-9"></front>
<front id="vector_3H-10">  This library is distributed in the hope that it will be useful,</front>
<front id="vector_3H-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="vector_3H-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="vector_3H-13">  Lesser General Public License for more details.</front>
<front id="vector_3H-14"></front>
<front id="vector_3H-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="vector_3H-16">  License along with this library; if not, write to the Free Software</front>
<front id="vector_3H-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="vector_3H-18">*/</front>
<front id="vector_3H-19">#ifndef VECTOR_3_H</front>
<front id="vector_3H-20">#define VECTOR_3_H</front>
<front id="vector_3H-21"></front>
<front id="vector_3H-22">#ifdef ENABLE_AUTO_BED_LEVELING</front>
<front id="vector_3H-23">class matrix_3x3;</front>
<front id="vector_3H-24"></front>
<front id="vector_3H-25">struct vector_3</front>
<front id="vector_3H-26">{</front>
<front id="vector_3H-27">	float x, y, z;</front>
<front id="vector_3H-28"></front>
<front id="vector_3H-29">        vector_3();</front>
<front id="vector_3H-30">	vector_3(float x, float y, float z);</front>
<front id="vector_3H-31"></front>
<front id="vector_3H-32">	static vector_3 cross(vector_3 a, vector_3 b);</front>
<front id="vector_3H-33"></front>
<front id="vector_3H-34">	vector_3 operator+(vector_3 v);</front>
<front id="vector_3H-35">	vector_3 operator-(vector_3 v);</front>
<front id="vector_3H-36">	void normalize();</front>
<front id="vector_3H-37">	float get_length();</front>
<front id="vector_3H-38">	vector_3 get_normal();</front>
<front id="vector_3H-39"></front>
<front id="vector_3H-40">	void debug(char* title);</front>
<front id="vector_3H-41">	</front>
<front id="vector_3H-42">	void apply_rotation(matrix_3x3 matrix);</front>
<front id="vector_3H-43">};</front>
<front id="vector_3H-44"></front>
<front id="vector_3H-45">struct matrix_3x3</front>
<front id="vector_3H-46">{</front>
<front id="vector_3H-47">	float matrix[9];</front>
<front id="vector_3H-48"></front>
<front id="vector_3H-49">	static matrix_3x3 create_from_rows(vector_3 row_0, vector_3 row_1, vector_3 row_2);</front>
<front id="vector_3H-50">	static matrix_3x3 create_look_at(vector_3 target, vector_3 up);</front>
<front id="vector_3H-51">	static matrix_3x3 create_inverse(matrix_3x3 original);</front>
<front id="vector_3H-52"></front>
<front id="vector_3H-53">	void set_to_identity();</front>
<front id="vector_3H-54"></front>
<front id="vector_3H-55">	void debug(char* title);</front>
<front id="vector_3H-56">};</front>
<front id="vector_3H-57"></front>
<front id="vector_3H-58"></front>
<front id="vector_3H-59">void apply_rotation_xyz(matrix_3x3 rotationMatrix, float &x, float& y, float& z);</front>
<front id="vector_3H-60">#endif // ENABLE_AUTO_BED_LEVELING</front>
<front id="vector_3H-61"></front>
<front id="vector_3H-62">#endif // VECTOR_3_H</front>
 </pre>
<h1>watchdog.cpp</h1>
<pre  class="prettyprint linenums"><front id="watchdogCPP-1">#include "Marlin.h"</front>
<front id="watchdogCPP-2"></front>
<front id="watchdogCPP-3">#ifdef USE_WATCHDOG</front>
<front id="watchdogCPP-4">#include &lt;avr/wdt.h&gt;</front>
<front id="watchdogCPP-5"></front>
<front id="watchdogCPP-6">#include "watchdog.h"</front>
<front id="watchdogCPP-7">#include "ultralcd.h"</front>
<front id="watchdogCPP-8"></front>
<front id="watchdogCPP-9">//===========================================================================</front>
<front id="watchdogCPP-10">//=============================private variables  ============================</front>
<front id="watchdogCPP-11">//===========================================================================</front>
<front id="watchdogCPP-12"></front>
<front id="watchdogCPP-13">//===========================================================================</front>
<front id="watchdogCPP-14">//=============================functinos         ============================</front>
<front id="watchdogCPP-15">//===========================================================================</front>
<front id="watchdogCPP-16"></front>
<front id="watchdogCPP-17"></front>
<front id="watchdogCPP-18">/// intialise watch dog with a 4 sec interrupt time</front>
<front id="watchdogCPP-19">void watchdog_init()</front>
<front id="watchdogCPP-20">{</front>
<front id="watchdogCPP-21">#ifdef WATCHDOG_RESET_MANUAL</front>
<front id="watchdogCPP-22">    //We enable the watchdog timer, but only for the interrupt.</front>
<front id="watchdogCPP-23">    //Take care, as this requires the correct order of operation, with interrupts disabled. See the datasheet of any AVR chip for details.</front>
<front id="watchdogCPP-24">    wdt_reset();</front>
<front id="watchdogCPP-25">    _WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);</front>
<front id="watchdogCPP-26">    _WD_CONTROL_REG = _BV(WDIE) | WDTO_4S;</front>
<front id="watchdogCPP-27">#else</front>
<front id="watchdogCPP-28">    wdt_enable(WDTO_4S);</front>
<front id="watchdogCPP-29">#endif</front>
<front id="watchdogCPP-30">}</front>
<front id="watchdogCPP-31"></front>
<front id="watchdogCPP-32">/// reset watchdog. MUST be called every 1s after init or avr will reset.</front>
<front id="watchdogCPP-33">void watchdog_reset() </front>
<front id="watchdogCPP-34">{</front>
<front id="watchdogCPP-35">    wdt_reset();</front>
<front id="watchdogCPP-36">}</front>
<front id="watchdogCPP-37"></front>
<front id="watchdogCPP-38">//===========================================================================</front>
<front id="watchdogCPP-39">//=============================ISR               ============================</front>
<front id="watchdogCPP-40">//===========================================================================</front>
<front id="watchdogCPP-41"></front>
<front id="watchdogCPP-42">//Watchdog timer interrupt, called if main program blocks &gt;1sec and manual reset is enabled.</front>
<front id="watchdogCPP-43">#ifdef WATCHDOG_RESET_MANUAL</front>
<front id="watchdogCPP-44">ISR(WDT_vect)</front>
<front id="watchdogCPP-45">{ </front>
<front id="watchdogCPP-46">    //TODO: This message gets overwritten by the kill() call</front>
<front id="watchdogCPP-47">    LCD_ALERTMESSAGEPGM("ERR:Please Reset");//16 characters so it fits on a 16x2 display</front>
<front id="watchdogCPP-48">    lcd_update();</front>
<front id="watchdogCPP-49">    SERIAL_ERROR_START;</front>
<front id="watchdogCPP-50">    SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");</front>
<front id="watchdogCPP-51">    kill(); //kill blocks</front>
<front id="watchdogCPP-52">    while(1); //wait for user or serial reset</front>
<front id="watchdogCPP-53">}</front>
<front id="watchdogCPP-54">#endif//RESET_MANUAL</front>
<front id="watchdogCPP-55"></front>
<front id="watchdogCPP-56">#endif//USE_WATCHDOG</front>
 </pre>
<h1>watchdog.h</h1>
<pre  class="prettyprint linenums"><front id="watchdogH-1">#ifndef WATCHDOG_H</front>
<front id="watchdogH-2">#define WATCHDOG_H</front>
<front id="watchdogH-3"></front>
<front id="watchdogH-4">#include "Marlin.h"</front>
<front id="watchdogH-5"></front>
<front id="watchdogH-6">#ifdef USE_WATCHDOG</front>
<front id="watchdogH-7">  // intialise watch dog with a 1 sec interrupt time</front>
<front id="watchdogH-8">  void watchdog_init();</front>
<front id="watchdogH-9">  // pad the dog/reset watchdog. MUST be called at least every second after the first watchdog_init or avr will go into emergency procedures..</front>
<front id="watchdogH-10">  void watchdog_reset();</front>
<front id="watchdogH-11">#else</front>
<front id="watchdogH-12">  //If we do not have a watchdog, then we can have empty functions which are optimized away.</front>
<front id="watchdogH-13">  FORCE_INLINE void watchdog_init() {};</front>
<front id="watchdogH-14">  FORCE_INLINE void watchdog_reset() {};</front>
<front id="watchdogH-15">#endif</front>
<front id="watchdogH-16"></front>
<front id="watchdogH-17">#endif</front>
 </pre>
<script src="svgDraw.js"></script>
</body>
</html>
