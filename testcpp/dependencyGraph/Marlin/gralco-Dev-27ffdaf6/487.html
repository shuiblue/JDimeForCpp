<html>
<head>
	<title></title>
<link rel="stylesheet" type="text/css" href="487.css">
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
 <script src="http://code.jquery.com/jquery-1.10.2.js"></script>
  <script src="http://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
</head>
<body ginger_software_stylesheet="true" ginger_software_doc="true">
	  <IMG id= "expectIMG"SRC="expect.png" style="float: right;width:300px;height:250px;" />
        <IMG id= "resultIMG"SRC="result.png" style="float: right;width:300px;height:250px;" />
       
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
	 <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
<button>toggle the div</button>
<script src="toggle.js"></script>
<h1 id="MarlinHtitle" >Marlin.h</h1>
<pre id="MarlinH"  class="prettyprint linenums"><front id="MarlinH-1">// Tonokip RepRap firmware rewrite based off of Hydra-mmm firmware.</front>
<front id="MarlinH-2">// License: GPL</front>
<front id="MarlinH-3"></front>
<front id="MarlinH-4">#ifndef MARLIN_H</front>
<front id="MarlinH-5">#define MARLIN_H</front>
<front id="MarlinH-6"></front>
<front id="MarlinH-7">#define  FORCE_INLINE __attribute__((always_inline)) inline</front>
<front id="MarlinH-8">/**</front>
<front id="MarlinH-9"> * Compiler warning on unused varable.</front>
<front id="MarlinH-10"> */</front>
<front id="MarlinH-11">#define UNUSED(x) (void) (x)</front>
<front id="MarlinH-12"></front>
<front id="MarlinH-13">#include &lt;math.h&gt;</front>
<front id="MarlinH-14">#include &lt;stdio.h&gt;</front>
<front id="MarlinH-15">#include &lt;stdlib.h&gt;</front>
<front id="MarlinH-16">#include &lt;string.h&gt;</front>
<front id="MarlinH-17">#include &lt;inttypes.h&gt;</front>
<front id="MarlinH-18"></front>
<front id="MarlinH-19">#include &lt;util/delay.h&gt;</front>
<front id="MarlinH-20">#include &lt;avr/pgmspace.h&gt;</front>
<front id="MarlinH-21">#include &lt;avr/eeprom.h&gt;</front>
<front id="MarlinH-22">#include &lt;avr/interrupt.h&gt;</front>
<front id="MarlinH-23"></front>
<front id="MarlinH-24"></front>
<front id="MarlinH-25">#include "fastio.h"</front>
<front id="MarlinH-26">#include "Configuration.h"</front>
<front id="MarlinH-27">#include "pins.h"</front>
<front id="MarlinH-28"></front>
<front id="MarlinH-29">#ifndef SANITYCHECK_H</front>
<front id="MarlinH-30">  #error Your Configuration.h and Configuration_adv.h files are outdated!</front>
<front id="MarlinH-31">#endif</front>
<front id="MarlinH-32"></front>
<front id="MarlinH-33">#include "Arduino.h"</front>
<front id="MarlinH-34"></front>
<front id="MarlinH-35">typedef unsigned long millis_t;</front>
<front id="MarlinH-36"></front>
<front id="MarlinH-37">// Arduino &lt; 1.0.0 does not define this, so we need to do it ourselves</front>
<front id="MarlinH-38">#ifndef analogInputToDigitalPin</front>
<front id="MarlinH-39">  #define analogInputToDigitalPin(p) ((p) + 0xA0)</front>
<front id="MarlinH-40">#endif</front>
<front id="MarlinH-41"></front>
<front id="MarlinH-42">#ifdef USBCON</front>
<front id="MarlinH-43">  #include "HardwareSerial.h"</front>
<front id="MarlinH-44">#endif</front>
<front id="MarlinH-45"></front>
<front id="MarlinH-46">#include "MarlinSerial.h"</front>
<front id="MarlinH-47"></front>
<front id="MarlinH-48">#ifndef cbi</front>
<front id="MarlinH-49">  #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))</front>
<front id="MarlinH-50">#endif</front>
<front id="MarlinH-51">#ifndef sbi</front>
<front id="MarlinH-52">  #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))</front>
<front id="MarlinH-53">#endif</front>
<front id="MarlinH-54"></front>
<front id="MarlinH-55">#include "WString.h"</front>
<front id="MarlinH-56"></front>
<front id="MarlinH-57">#ifdef USBCON</front>
<front id="MarlinH-58">  #if ENABLED(BLUETOOTH)</front>
<front id="MarlinH-59">    #define MYSERIAL bluetoothSerial</front>
<front id="MarlinH-60">  #else</front>
<front id="MarlinH-61">    #define MYSERIAL Serial</front>
<front id="MarlinH-62">  #endif // BLUETOOTH</front>
<front id="MarlinH-63">#else</front>
<front id="MarlinH-64">  #define MYSERIAL customizedSerial</front>
<front id="MarlinH-65">#endif</front>
<front id="MarlinH-66"></front>
<front id="MarlinH-67">#define SERIAL_CHAR(x) MYSERIAL.write(x)</front>
<front id="MarlinH-68">#define SERIAL_EOL SERIAL_CHAR('\n')</front>
<front id="MarlinH-69"></front>
<front id="MarlinH-70">#define SERIAL_PROTOCOLCHAR(x) SERIAL_CHAR(x)</front>
<front id="MarlinH-71">#define SERIAL_PROTOCOL(x) MYSERIAL.print(x)</front>
<front id="MarlinH-72">#define SERIAL_PROTOCOL_F(x,y) MYSERIAL.print(x,y)</front>
<front id="MarlinH-73">#define SERIAL_PROTOCOLPGM(x) serialprintPGM(PSTR(x))</front>
<front id="MarlinH-74">#define SERIAL_PROTOCOLLN(x) do{ MYSERIAL.print(x); SERIAL_EOL; }while(0)</front>
<front id="MarlinH-75">#define SERIAL_PROTOCOLLNPGM(x) do{ serialprintPGM(PSTR(x)); SERIAL_EOL; }while(0)</front>
<front id="MarlinH-76"></front>
<front id="MarlinH-77"></front>
<front id="MarlinH-78">extern const char errormagic[] PROGMEM;</front>
<front id="MarlinH-79">extern const char echomagic[] PROGMEM;</front>
<front id="MarlinH-80"></front>
<front id="MarlinH-81">#define SERIAL_ERROR_START serialprintPGM(errormagic)</front>
<front id="MarlinH-82">#define SERIAL_ERROR(x) SERIAL_PROTOCOL(x)</front>
<front id="MarlinH-83">#define SERIAL_ERRORPGM(x) SERIAL_PROTOCOLPGM(x)</front>
<front id="MarlinH-84">#define SERIAL_ERRORLN(x) SERIAL_PROTOCOLLN(x)</front>
<front id="MarlinH-85">#define SERIAL_ERRORLNPGM(x) SERIAL_PROTOCOLLNPGM(x)</front>
<front id="MarlinH-86"></front>
<front id="MarlinH-87">#define SERIAL_ECHO_START serialprintPGM(echomagic)</front>
<front id="MarlinH-88">#define SERIAL_ECHO(x) SERIAL_PROTOCOL(x)</front>
<front id="MarlinH-89">#define SERIAL_ECHOPGM(x) SERIAL_PROTOCOLPGM(x)</front>
<front id="MarlinH-90">#define SERIAL_ECHOLN(x) SERIAL_PROTOCOLLN(x)</front>
<front id="MarlinH-91">#define SERIAL_ECHOLNPGM(x) SERIAL_PROTOCOLLNPGM(x)</front>
<front id="MarlinH-92"></front>
<front id="MarlinH-93">#define SERIAL_ECHOPAIR(name,value) do{ serial_echopair_P(PSTR(name),(value)); }while(0)</front>
<front id="MarlinH-94"></front>
<front id="MarlinH-95">void serial_echopair_P(const char *s_P, int v);</front>
<front id="MarlinH-96">void serial_echopair_P(const char *s_P, long v);</front>
<front id="MarlinH-97">void serial_echopair_P(const char *s_P, float v);</front>
<front id="MarlinH-98">void serial_echopair_P(const char *s_P, double v);</front>
<front id="MarlinH-99">void serial_echopair_P(const char *s_P, unsigned long v);</front>
<front id="MarlinH-100"></front>
<front id="MarlinH-101"></front>
<front id="MarlinH-102">// Things to write to serial from Program memory. Saves 400 to 2k of RAM.</front>
<front id="MarlinH-103">FORCE_INLINE void serialprintPGM(const char *str) {</front>
<front id="MarlinH-104">  char ch;</front>
<front id="MarlinH-105">  while ((ch = pgm_read_byte(str))) {</front>
<front id="MarlinH-106">    MYSERIAL.write(ch);</front>
<front id="MarlinH-107">    str++;</front>
<front id="MarlinH-108">  }</front>
<front id="MarlinH-109">}</front>
<front id="MarlinH-110"></front>
<front id="MarlinH-111">void get_command();</front>
<front id="MarlinH-112"></front>
<front id="MarlinH-113">void idle(); // the standard idle routine calls manage_inactivity(false)</front>
<front id="MarlinH-114"></front>
<front id="MarlinH-115">void manage_inactivity(bool ignore_stepper_queue=false);</front>
<front id="MarlinH-116"></front>
<front id="MarlinH-117">#if ENABLED(DUAL_X_CARRIAGE) && HAS_X_ENABLE && HAS_X2_ENABLE</front>
<front id="MarlinH-118">  #define  enable_x() do { X_ENABLE_WRITE( X_ENABLE_ON); X2_ENABLE_WRITE( X_ENABLE_ON); } while (0)</front>
<front id="MarlinH-119">  #define disable_x() do { X_ENABLE_WRITE(!X_ENABLE_ON); X2_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; } while (0)</front>
<front id="MarlinH-120">#elif HAS_X_ENABLE</front>
<front id="MarlinH-121">  #define  enable_x() X_ENABLE_WRITE( X_ENABLE_ON)</front>
<front id="MarlinH-122">  #define disable_x() { X_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; }</front>
<front id="MarlinH-123">#else</front>
<front id="MarlinH-124">  #define enable_x() ;</front>
<front id="MarlinH-125">  #define disable_x() ;</front>
<front id="MarlinH-126">#endif</front>
<front id="MarlinH-127"></front>
<front id="MarlinH-128">#if HAS_Y_ENABLE</front>
<front id="MarlinH-129">  #if ENABLED(Y_DUAL_STEPPER_DRIVERS)</front>
<front id="MarlinH-130">    #define  enable_y() { Y_ENABLE_WRITE( Y_ENABLE_ON); Y2_ENABLE_WRITE(Y_ENABLE_ON); }</front>
<front id="MarlinH-131">    #define disable_y() { Y_ENABLE_WRITE(!Y_ENABLE_ON); Y2_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }</front>
<front id="MarlinH-132">  #else</front>
<front id="MarlinH-133">    #define  enable_y() Y_ENABLE_WRITE( Y_ENABLE_ON)</front>
<front id="MarlinH-134">    #define disable_y() { Y_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }</front>
<front id="MarlinH-135">  #endif</front>
<front id="MarlinH-136">#else</front>
<front id="MarlinH-137">  #define enable_y() ;</front>
<front id="MarlinH-138">  #define disable_y() ;</front>
<front id="MarlinH-139">#endif</front>
<front id="MarlinH-140"></front>
<front id="MarlinH-141">#if HAS_Z_ENABLE</front>
<front id="MarlinH-142">  #if ENABLED(Z_DUAL_STEPPER_DRIVERS)</front>
<front id="MarlinH-143">    #define  enable_z() { Z_ENABLE_WRITE( Z_ENABLE_ON); Z2_ENABLE_WRITE(Z_ENABLE_ON); }</front>
<front id="MarlinH-144">    #define disable_z() { Z_ENABLE_WRITE(!Z_ENABLE_ON); Z2_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }</front>
<front id="MarlinH-145">  #else</front>
<front id="MarlinH-146">    #define  enable_z() Z_ENABLE_WRITE( Z_ENABLE_ON)</front>
<front id="MarlinH-147">    #define disable_z() { Z_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }</front>
<front id="MarlinH-148">  #endif</front>
<front id="MarlinH-149">#else</front>
<front id="MarlinH-150">  #define enable_z() ;</front>
<front id="MarlinH-151">  #define disable_z() ;</front>
<front id="MarlinH-152">#endif</front>
<front id="MarlinH-153"></front>
<front id="MarlinH-154">#if HAS_E0_ENABLE</front>
<front id="MarlinH-155">  #define enable_e0()  E0_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-156">  #define disable_e0() E0_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-157">#else</front>
<front id="MarlinH-158">  #define enable_e0()  /* nothing */</front>
<front id="MarlinH-159">  #define disable_e0() /* nothing */</front>
<front id="MarlinH-160">#endif</front>
<front id="MarlinH-161"></front>
<front id="MarlinH-162">#if (EXTRUDERS &gt; 1) && HAS_E1_ENABLE</front>
<front id="MarlinH-163">  #define enable_e1()  E1_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-164">  #define disable_e1() E1_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-165">#else</front>
<front id="MarlinH-166">  #define enable_e1()  /* nothing */</front>
<front id="MarlinH-167">  #define disable_e1() /* nothing */</front>
<front id="MarlinH-168">#endif</front>
<front id="MarlinH-169"></front>
<front id="MarlinH-170">#if (EXTRUDERS &gt; 2) && HAS_E2_ENABLE</front>
<front id="MarlinH-171">  #define enable_e2()  E2_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-172">  #define disable_e2() E2_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-173">#else</front>
<front id="MarlinH-174">  #define enable_e2()  /* nothing */</front>
<front id="MarlinH-175">  #define disable_e2() /* nothing */</front>
<front id="MarlinH-176">#endif</front>
<front id="MarlinH-177"></front>
<front id="MarlinH-178">#if (EXTRUDERS &gt; 3) && HAS_E3_ENABLE</front>
<front id="MarlinH-179">  #define enable_e3()  E3_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-180">  #define disable_e3() E3_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-181">#else</front>
<front id="MarlinH-182">  #define enable_e3()  /* nothing */</front>
<front id="MarlinH-183">  #define disable_e3() /* nothing */</front>
<front id="MarlinH-184">#endif</front>
<front id="MarlinH-185"></front>
<front id="MarlinH-186">/**</front>
<front id="MarlinH-187"> * The axis order in all axis related arrays is X, Y, Z, E</front>
<front id="MarlinH-188"> */</front>
<front id="MarlinH-189">#define NUM_AXIS 4</front>
<front id="MarlinH-190"></front>
<front id="MarlinH-191">/**</front>
<front id="MarlinH-192"> * Axis indices as enumerated constants</front>
<front id="MarlinH-193"> *</front>
<front id="MarlinH-194"> * A_AXIS and B_AXIS are used by COREXY printers</front>
<front id="MarlinH-195"> * X_HEAD and Y_HEAD is used for systems that don't have a 1:1 relationship between X_AXIS and X Head movement, like CoreXY bots.</front>
<front id="MarlinH-196"> */</front>
<front id="MarlinH-197">enum AxisEnum {X_AXIS=0, A_AXIS=0, Y_AXIS=1, B_AXIS=1, Z_AXIS=2, C_AXIS=2, E_AXIS=3, X_HEAD=4, Y_HEAD=5, Z_HEAD=5};</front>
<front id="MarlinH-198"></front>
<front id="MarlinH-199">enum EndstopEnum {X_MIN=0, Y_MIN=1, Z_MIN=2, Z_MIN_PROBE=3, X_MAX=4, Y_MAX=5, Z_MAX=6, Z2_MIN=7, Z2_MAX=8};</front>
<front id="MarlinH-200"></front>
<front id="MarlinH-201">void enable_all_steppers();</front>
<front id="MarlinH-202">void disable_all_steppers();</front>
<front id="MarlinH-203"></front>
<front id="MarlinH-204">void FlushSerialRequestResend();</front>
<front id="MarlinH-205">void ok_to_send();</front>
<front id="MarlinH-206"></front>
<front id="MarlinH-207">void reset_bed_level();</front>
<front id="MarlinH-208">void prepare_move();</front>
<front id="MarlinH-209">void kill(const char *);</front>
<front id="MarlinH-210">void Stop();</front>
<front id="MarlinH-211"></front>
<front id="MarlinH-212">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="MarlinH-213">  void filrunout();</front>
<front id="MarlinH-214">#endif</front>
<front id="MarlinH-215"></front>
<front id="MarlinH-216">/**</front>
<front id="MarlinH-217"> * Debug flags - not yet widely applied</front>
<front id="MarlinH-218"> */</front>
<front id="MarlinH-219">enum DebugFlags {</front>
<front id="MarlinH-220">  DEBUG_ECHO          = BIT(0),</front>
<front id="MarlinH-221">  DEBUG_INFO          = BIT(1),</front>
<front id="MarlinH-222">  DEBUG_ERRORS        = BIT(2),</front>
<front id="MarlinH-223">  DEBUG_DRYRUN        = BIT(3),</front>
<front id="MarlinH-224">  DEBUG_COMMUNICATION = BIT(4),</front>
<front id="MarlinH-225">  DEBUG_LEVELING      = BIT(5)</front>
<front id="MarlinH-226">};</front>
<front id="MarlinH-227">extern uint8_t marlin_debug_flags;</front>
<front id="MarlinH-228"></front>
<front id="MarlinH-229">extern bool Running;</front>
<front id="MarlinH-230">inline bool IsRunning() { return  Running; }</front>
<front id="MarlinH-231">inline bool IsStopped() { return !Running; }</front>
<front id="MarlinH-232"></front>
<front id="MarlinH-233">bool enqueuecommand(const char *cmd); //put a single ASCII command at the end of the current buffer or return false when it is full</front>
<front id="MarlinH-234">void enqueuecommands_P(const char *cmd); //put one or many ASCII commands at the end of the current buffer, read from flash</front>
<front id="MarlinH-235"></front>
<front id="MarlinH-236">void prepare_arc_move(char isclockwise);</front>
<front id="MarlinH-237">void clamp_to_software_endstops(float target[3]);</front>
<front id="MarlinH-238"></front>
<front id="MarlinH-239">extern millis_t previous_cmd_ms;</front>
<front id="MarlinH-240">inline void refresh_cmd_timeout() { previous_cmd_ms = millis(); }</front>
<front id="MarlinH-241"></front>
<front id="MarlinH-242">#if ENABLED(FAST_PWM_FAN)</front>
<front id="MarlinH-243">  void setPwmFrequency(uint8_t pin, int val);</front>
<front id="MarlinH-244">#endif</front>
<front id="MarlinH-245"></front>
<front id="MarlinH-246">#ifndef CRITICAL_SECTION_START</front>
<front id="MarlinH-247">  #define CRITICAL_SECTION_START  unsigned char _sreg = SREG; cli();</front>
<front id="MarlinH-248">  #define CRITICAL_SECTION_END    SREG = _sreg;</front>
<front id="MarlinH-249">#endif</front>
<front id="MarlinH-250"></front>
<front id="MarlinH-251">extern bool axis_relative_modes[];</front>
<front id="MarlinH-252">extern int feedrate_multiplier;</front>
<front id="MarlinH-253">extern bool volumetric_enabled;</front>
<front id="MarlinH-254">extern int extruder_multiplier[EXTRUDERS]; // sets extrude multiply factor (in percent) for each extruder individually</front>
<front id="MarlinH-255">extern float filament_size[EXTRUDERS]; // cross-sectional area of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder.</front>
<front id="MarlinH-256">extern float volumetric_multiplier[EXTRUDERS]; // reciprocal of cross-sectional area of filament (in square millimeters), stored this way to reduce computational burden in planner</front>
<front id="MarlinH-257">extern float current_position[NUM_AXIS];</front>
<front id="MarlinH-258">extern float home_offset[3]; // axis[n].home_offset</front>
<front id="MarlinH-259">extern float min_pos[3]; // axis[n].min_pos</front>
<front id="MarlinH-260">extern float max_pos[3]; // axis[n].max_pos</front>
<front id="MarlinH-261">extern bool axis_known_position[3]; // axis[n].is_known</front>
<front id="MarlinH-262">#ifdef RESUME_FEATURE</front>
<front id="MarlinH-263">  extern float planner_disabled_below_z;</front>
<front id="MarlinH-264">#endif</front>
<front id="MarlinH-265">#ifdef TRACK_LAYER</front>
<front id="MarlinH-266">  extern float last_layer_z;</front>
<front id="MarlinH-267">  extern unsigned short current_layer; // estimated current layer number</front>
<front id="MarlinH-268">#endif //TRACK_LAYER</front>
<front id="MarlinH-269"></front>
<front id="MarlinH-270">#if ENABLED(DELTA)</front>
<front id="MarlinH-271">  extern float delta[3];</front>
<front id="MarlinH-272">  extern float endstop_adj[3]; // axis[n].endstop_adj</front>
<front id="MarlinH-273">  extern float delta_radius;</front>
<front id="MarlinH-274">  #ifndef DELTA_RADIUS_TRIM_TOWER_1</front>
<front id="MarlinH-275">    #define DELTA_RADIUS_TRIM_TOWER_1 0.0</front>
<front id="MarlinH-276">  #endif</front>
<front id="MarlinH-277">  #ifndef DELTA_RADIUS_TRIM_TOWER_2</front>
<front id="MarlinH-278">    #define DELTA_RADIUS_TRIM_TOWER_2 0.0</front>
<front id="MarlinH-279">  #endif</front>
<front id="MarlinH-280">  #ifndef DELTA_RADIUS_TRIM_TOWER_3</front>
<front id="MarlinH-281">    #define DELTA_RADIUS_TRIM_TOWER_3 0.0</front>
<front id="MarlinH-282">  #endif</front>
<front id="MarlinH-283">  extern float delta_diagonal_rod;</front>
<front id="MarlinH-284">  #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_1</front>
<front id="MarlinH-285">    #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0</front>
<front id="MarlinH-286">  #endif</front>
<front id="MarlinH-287">  #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_2</front>
<front id="MarlinH-288">    #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0</front>
<front id="MarlinH-289">  #endif</front>
<front id="MarlinH-290">  #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_3</front>
<front id="MarlinH-291">    #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0</front>
<front id="MarlinH-292">  #endif</front>
<front id="MarlinH-293">  extern float delta_segments_per_second;</front>
<front id="MarlinH-294">  void calculate_delta(float cartesian[3]);</front>
<front id="MarlinH-295">  void recalc_delta_settings(float radius, float diagonal_rod);</front>
<front id="MarlinH-296">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="MarlinH-297">    extern int delta_grid_spacing[2];</front>
<front id="MarlinH-298">    void adjust_delta(float cartesian[3]);</front>
<front id="MarlinH-299">  #endif</front>
<front id="MarlinH-300">#elif ENABLED(SCARA)</front>
<front id="MarlinH-301">  extern float axis_scaling[3];  // Build size scaling</front>
<front id="MarlinH-302">  void calculate_delta(float cartesian[3]);</front>
<front id="MarlinH-303">  void calculate_SCARA_forward_Transform(float f_scara[3]);</front>
<front id="MarlinH-304">#endif</front>
<front id="MarlinH-305"></front>
<front id="MarlinH-306">#if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="MarlinH-307">  extern float z_endstop_adj;</front>
<front id="MarlinH-308">#endif</front>
<front id="MarlinH-309"></front>
<front id="MarlinH-310">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="MarlinH-311">  extern float zprobe_zoffset;</front>
<front id="MarlinH-312">#endif</front>
<front id="MarlinH-313"></front>
<front id="MarlinH-314">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="MarlinH-315">  extern float extrude_min_temp;</front>
<front id="MarlinH-316">#endif</front>
<front id="MarlinH-317"></front>
<front id="MarlinH-318">extern int fanSpeed;</front>
<front id="MarlinH-319"></front>
<front id="MarlinH-320">#if ENABLED(BARICUDA)</front>
<front id="MarlinH-321">  extern int ValvePressure;</front>
<front id="MarlinH-322">  extern int EtoPPressure;</front>
<front id="MarlinH-323">#endif</front>
<front id="MarlinH-324"></front>
<front id="MarlinH-325">#if ENABLED(FAN_SOFT_PWM)</front>
<front id="MarlinH-326">  extern unsigned char fanSpeedSoftPwm;</front>
<front id="MarlinH-327">#endif</front>
<front id="MarlinH-328"></front>
<front id="MarlinH-329">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="MarlinH-330">  extern float filament_width_nominal;  //holds the theoretical filament diameter ie., 3.00 or 1.75</front>
<front id="MarlinH-331">  extern bool filament_sensor;  //indicates that filament sensor readings should control extrusion</front>
<front id="MarlinH-332">  extern float filament_width_meas; //holds the filament diameter as accurately measured</front>
<front id="MarlinH-333">  extern signed char measurement_delay[];  //ring buffer to delay measurement</front>
<front id="MarlinH-334">  extern int delay_index1, delay_index2;  //ring buffer index. used by planner, temperature, and main code</front>
<front id="MarlinH-335">  extern float delay_dist; //delay distance counter</front>
<front id="MarlinH-336">  extern int meas_delay_cm; //delay distance</front>
<front id="MarlinH-337">#endif</front>
<front id="MarlinH-338"></front>
<front id="MarlinH-339">#if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="MarlinH-340">  extern int lpq_len;</front>
<front id="MarlinH-341">#endif</front>
<front id="MarlinH-342"></front>
<front id="MarlinH-343">#if ENABLED(FWRETRACT)</front>
<front id="MarlinH-344">  extern bool autoretract_enabled;</front>
<front id="MarlinH-345">  extern bool retracted[EXTRUDERS]; // extruder[n].retracted</front>
<front id="MarlinH-346">  extern float retract_length, retract_length_swap, retract_feedrate, retract_zlift;</front>
<front id="MarlinH-347">  extern float retract_recover_length, retract_recover_length_swap, retract_recover_feedrate;</front>
<front id="MarlinH-348">#endif</front>
<front id="MarlinH-349"></front>
<front id="MarlinH-350">extern millis_t print_job_start_ms;</front>
<front id="MarlinH-351">extern millis_t print_job_stop_ms;</front>
<front id="MarlinH-352"></front>
<front id="MarlinH-353">// Handling multiple extruders pins</front>
<front id="MarlinH-354">extern uint8_t active_extruder;</front>
<front id="MarlinH-355"></front>
<front id="MarlinH-356">#if ENABLED(DIGIPOT_I2C)</front>
<front id="MarlinH-357">  extern void digipot_i2c_set_current( int channel, float current );</front>
<front id="MarlinH-358">  extern void digipot_i2c_init();</front>
<front id="MarlinH-359">#endif</front>
<front id="MarlinH-360"></front>
<front id="MarlinH-361">extern void calculate_volumetric_multipliers();</front>
<front id="MarlinH-362"></front>
<front id="MarlinH-363">#endif //MARLIN_H</front>
 </pre>
<h1 id="Marlin_mainCPPtitle" >Marlin_main.cpp</h1>
<pre id="Marlin_mainCPP"  class="prettyprint linenums"><front id="Marlin_mainCPP-1">/**</front>
<front id="Marlin_mainCPP-2"> * Marlin Firmware</front>
<front id="Marlin_mainCPP-3"> *</front>
<front id="Marlin_mainCPP-4"> * Based on Sprinter and grbl.</front>
<front id="Marlin_mainCPP-5"> * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm</front>
<front id="Marlin_mainCPP-6"> *</front>
<front id="Marlin_mainCPP-7"> * This program is free software: you can redistribute it and/or modify</front>
<front id="Marlin_mainCPP-8"> * it under the terms of the GNU General Public License as published by</front>
<front id="Marlin_mainCPP-9"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Marlin_mainCPP-10"> * (at your option) any later version.</front>
<front id="Marlin_mainCPP-11"> *</front>
<front id="Marlin_mainCPP-12"> * This program is distributed in the hope that it will be useful,</front>
<front id="Marlin_mainCPP-13"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Marlin_mainCPP-14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Marlin_mainCPP-15"> * GNU General Public License for more details.</front>
<front id="Marlin_mainCPP-16"> *</front>
<front id="Marlin_mainCPP-17"> * You should have received a copy of the GNU General Public License</front>
<front id="Marlin_mainCPP-18"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Marlin_mainCPP-19"> *</front>
<front id="Marlin_mainCPP-20"> * About Marlin</front>
<front id="Marlin_mainCPP-21"> *</front>
<front id="Marlin_mainCPP-22"> * This firmware is a mashup between Sprinter and grbl.</front>
<front id="Marlin_mainCPP-23"> *  - https://github.com/kliment/Sprinter</front>
<front id="Marlin_mainCPP-24"> *  - https://github.com/simen/grbl/tree</front>
<front id="Marlin_mainCPP-25"> *</front>
<front id="Marlin_mainCPP-26"> * It has preliminary support for Matthew Roberts advance algorithm</front>
<front id="Marlin_mainCPP-27"> *  - http://reprap.org/pipermail/reprap-dev/2011-May/003323.html</front>
<front id="Marlin_mainCPP-28"> */</front>
<front id="Marlin_mainCPP-29"></front>
<front id="Marlin_mainCPP-30">#include "Marlin.h"</front>
<front id="Marlin_mainCPP-31"></front>
<front id="Marlin_mainCPP-32">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-33">  #include "vector_3.h"</front>
<front id="Marlin_mainCPP-34">  #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-35">    #include "qr_solve.h"</front>
<front id="Marlin_mainCPP-36">  #endif</front>
<front id="Marlin_mainCPP-37">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-38"></front>
<front id="Marlin_mainCPP-39">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-40">  #include "mesh_bed_leveling.h"</front>
<front id="Marlin_mainCPP-41">#endif</front>
<front id="Marlin_mainCPP-42"></front>
<front id="Marlin_mainCPP-43">#include "ultralcd.h"</front>
<front id="Marlin_mainCPP-44">#include "planner.h"</front>
<front id="Marlin_mainCPP-45">#include "stepper.h"</front>
<front id="Marlin_mainCPP-46">#include "temperature.h"</front>
<front id="Marlin_mainCPP-47">#include "cardreader.h"</front>
<front id="Marlin_mainCPP-48">#include "watchdog.h"</front>
<front id="Marlin_mainCPP-49">#include "configuration_store.h"</front>
<front id="Marlin_mainCPP-50">#include "language.h"</front>
<front id="Marlin_mainCPP-51">#include "pins_arduino.h"</front>
<front id="Marlin_mainCPP-52">#include "math.h"</front>
<front id="Marlin_mainCPP-53">#include "buzzer.h"</front>
<front id="Marlin_mainCPP-54"></front>
<front id="Marlin_mainCPP-55">#if ENABLED(BLINKM)</front>
<front id="Marlin_mainCPP-56">  #include "blinkm.h"</front>
<front id="Marlin_mainCPP-57">  #include "Wire.h"</front>
<front id="Marlin_mainCPP-58">#endif</front>
<front id="Marlin_mainCPP-59"></front>
<front id="Marlin_mainCPP-60">#if HAS_SERVOS</front>
<front id="Marlin_mainCPP-61">  #include "servo.h"</front>
<front id="Marlin_mainCPP-62">#endif</front>
<front id="Marlin_mainCPP-63"></front>
<front id="Marlin_mainCPP-64">#if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-65">  #include &lt;SPI.h&gt;</front>
<front id="Marlin_mainCPP-66">#endif</front>
<front id="Marlin_mainCPP-67"></front>
<front id="Marlin_mainCPP-68">/**</front>
<front id="Marlin_mainCPP-69"> * Look here for descriptions of G-codes:</front>
<front id="Marlin_mainCPP-70"> *  - http://linuxcnc.org/handbook/gcode/g-code.html</front>
<front id="Marlin_mainCPP-71"> *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes</front>
<front id="Marlin_mainCPP-72"> *</front>
<front id="Marlin_mainCPP-73"> * Help us document these G-codes online:</front>
<front id="Marlin_mainCPP-74"> *  - http://marlinfirmware.org/index.php/G-Code</front>
<front id="Marlin_mainCPP-75"> *  - http://reprap.org/wiki/G-code</front>
<front id="Marlin_mainCPP-76"> *</front>
<front id="Marlin_mainCPP-77"> * -----------------</front>
<front id="Marlin_mainCPP-78"> * Implemented Codes</front>
<front id="Marlin_mainCPP-79"> * -----------------</front>
<front id="Marlin_mainCPP-80"> *</front>
<front id="Marlin_mainCPP-81"> * "G" Codes</front>
<front id="Marlin_mainCPP-82"> *</front>
<front id="Marlin_mainCPP-83"> * G0  -&gt; G1</front>
<front id="Marlin_mainCPP-84"> * G1  - Coordinated Movement X Y Z E</front>
<front id="Marlin_mainCPP-85"> * G2  - CW ARC</front>
<front id="Marlin_mainCPP-86"> * G3  - CCW ARC</front>
<front id="Marlin_mainCPP-87"> * G4  - Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</front>
<front id="Marlin_mainCPP-88"> * G10 - retract filament according to settings of M207</front>
<front id="Marlin_mainCPP-89"> * G11 - retract recover filament according to settings of M208</front>
<front id="Marlin_mainCPP-90"> * G28 - Home one or more axes</front>
<front id="Marlin_mainCPP-91"> * G29 - Detailed Z probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.</front>
<front id="Marlin_mainCPP-92"> * G30 - Single Z probe, probes bed at current XY location.</front>
<front id="Marlin_mainCPP-93"> * G31 - Dock sled (Z_PROBE_SLED only)</front>
<front id="Marlin_mainCPP-94"> * G32 - Undock sled (Z_PROBE_SLED only)</front>
<front id="Marlin_mainCPP-95"> * G90 - Use Absolute Coordinates</front>
<front id="Marlin_mainCPP-96"> * G91 - Use Relative Coordinates</front>
<front id="Marlin_mainCPP-97"> * G92 - Set current position to coordinates given</front>
<front id="Marlin_mainCPP-98"> *</front>
<front id="Marlin_mainCPP-99"> * "M" Codes</front>
<front id="Marlin_mainCPP-100"> *</front>
<front id="Marlin_mainCPP-101"> * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)</front>
<front id="Marlin_mainCPP-102"> * M1   - Same as M0</front>
<front id="Marlin_mainCPP-103"> * M17  - Enable/Power all stepper motors</front>
<front id="Marlin_mainCPP-104"> * M18  - Disable all stepper motors; same as M84</front>
<front id="Marlin_mainCPP-105"> * M19  - Resume print from current (or given) Z height (disables all movements below the current Z position, a file must be selected to print after executing this M code)</front>
<front id="Marlin_mainCPP-106"> * M20  - List SD card</front>
<front id="Marlin_mainCPP-107"> * M21  - Init SD card</front>
<front id="Marlin_mainCPP-108"> * M22  - Release SD card</front>
<front id="Marlin_mainCPP-109"> * M23  - Select SD file (M23 filename.g)</front>
<front id="Marlin_mainCPP-110"> * M24  - Start/resume SD print</front>
<front id="Marlin_mainCPP-111"> * M25  - Pause SD print</front>
<front id="Marlin_mainCPP-112"> * M26  - Set SD position in bytes (M26 S12345)</front>
<front id="Marlin_mainCPP-113"> * M27  - Report SD print status</front>
<front id="Marlin_mainCPP-114"> * M28  - Start SD write (M28 filename.g)</front>
<front id="Marlin_mainCPP-115"> * M29  - Stop SD write</front>
<front id="Marlin_mainCPP-116"> * M30  - Delete file from SD (M30 filename.g)</front>
<front id="Marlin_mainCPP-117"> * M31  - Output time since last M109 or SD card start to serial</front>
<front id="Marlin_mainCPP-118"> * M32  - Select file and start SD print (Can be used _while_ printing from SD card files):</front>
<front id="Marlin_mainCPP-119"> *        syntax "M32 /path/filename#", or "M32 S&lt;startpos bytes&gt; !filename#"</front>
<front id="Marlin_mainCPP-120"> *        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).</front>
<front id="Marlin_mainCPP-121"> *        The '#' is necessary when calling from within sd files, as it stops buffer prereading</front>
<front id="Marlin_mainCPP-122"> * M33  - Get the longname version of a path</front>
<front id="Marlin_mainCPP-123"> * M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.</front>
<front id="Marlin_mainCPP-124"> * M48  - Measure Z_Probe repeatability. M48 [P # of points] [X position] [Y position] [V_erboseness #] [E_ngage Probe] [L # of legs of travel]</front>
<front id="Marlin_mainCPP-125"> * M80  - Turn on Power Supply</front>
<front id="Marlin_mainCPP-126"> * M81  - Turn off Power Supply</front>
<front id="Marlin_mainCPP-127"> * M82  - Set E codes absolute (default)</front>
<front id="Marlin_mainCPP-128"> * M83  - Set E codes relative while in Absolute Coordinates (G90) mode</front>
<front id="Marlin_mainCPP-129"> * M84  - Disable steppers until next move,</front>
<front id="Marlin_mainCPP-130"> *        or use S&lt;seconds&gt; to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.</front>
<front id="Marlin_mainCPP-131"> * M85  - Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</front>
<front id="Marlin_mainCPP-132"> * M92  - Set axis_steps_per_unit - same syntax as G92</front>
<front id="Marlin_mainCPP-133"> * M104 - Set extruder target temp</front>
<front id="Marlin_mainCPP-134"> * M105 - Read current temp</front>
<front id="Marlin_mainCPP-135"> * M106 - Fan on</front>
<front id="Marlin_mainCPP-136"> * M107 - Fan off</front>
<front id="Marlin_mainCPP-137"> * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-138"> *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-139"> *        IF AUTOTEMP is enabled, S&lt;mintemp&gt; B&lt;maxtemp&gt; F&lt;factor&gt;. Exit autotemp by any M109 without F</front>
<front id="Marlin_mainCPP-140"> * M110 - Set the current line number</front>
<front id="Marlin_mainCPP-141"> * M111 - Set debug flags with S&lt;mask&gt;. See flag bits defined in Marlin.h.</front>
<front id="Marlin_mainCPP-142"> * M112 - Emergency stop</front>
<front id="Marlin_mainCPP-143"> * M114 - Output current position to serial port</front>
<front id="Marlin_mainCPP-144"> * M115 - Capabilities string</front>
<front id="Marlin_mainCPP-145"> * M117 - Display a message on the controller screen</front>
<front id="Marlin_mainCPP-146"> * M119 - Output Endstop status to serial port</front>
<front id="Marlin_mainCPP-147"> * M120 - Enable endstop detection</front>
<front id="Marlin_mainCPP-148"> * M121 - Disable endstop detection</front>
<front id="Marlin_mainCPP-149"> * M126 - Solenoid Air Valve Open (BariCUDA support by jmil)</front>
<front id="Marlin_mainCPP-150"> * M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)</front>
<front id="Marlin_mainCPP-151"> * M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)</front>
<front id="Marlin_mainCPP-152"> * M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)</front>
<front id="Marlin_mainCPP-153"> * M140 - Set bed target temp</front>
<front id="Marlin_mainCPP-154"> * M145 - Set the heatup state H&lt;hotend&gt; B&lt;bed&gt; F&lt;fan speed&gt; for S&lt;material&gt; (0=PLA, 1=ABS)</front>
<front id="Marlin_mainCPP-155"> * M150 - Set BlinkM Color Output R: Red&lt;0-255&gt; U(!): Green&lt;0-255&gt; B: Blue&lt;0-255&gt; over i2c, G for green does not work.</front>
<front id="Marlin_mainCPP-156"> * M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-157"> *        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-158"> * M200 - set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).:D&lt;millimeters&gt;-</front>
<front id="Marlin_mainCPP-159"> * M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</front>
<front id="Marlin_mainCPP-160"> * M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!</front>
<front id="Marlin_mainCPP-161"> * M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</front>
<front id="Marlin_mainCPP-162"> * M204 - Set default acceleration: P for Printing moves, R for Retract only (no X, Y, Z) moves and T for Travel (non printing) moves (ex. M204 P800 T3000 R9000) in mm/sec^2</front>
<front id="Marlin_mainCPP-163"> * M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk</front>
<front id="Marlin_mainCPP-164"> * M206 - Set additional homing offset</front>
<front id="Marlin_mainCPP-165"> * M207 - Set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting</front>
<front id="Marlin_mainCPP-166"> * M208 - Set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]</front>
<front id="Marlin_mainCPP-167"> * M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-168"> * M218 - Set hotend offset (in mm): T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-169"> * M220 - Set speed factor override percentage: S&lt;factor in percent&gt;</front>
<front id="Marlin_mainCPP-170"> * M221 - Set extrude factor override percentage: S&lt;factor in percent&gt;</front>
<front id="Marlin_mainCPP-171"> * M226 - Wait until the specified pin reaches the state required: P&lt;pin number&gt; S&lt;pin state&gt;</front>
<front id="Marlin_mainCPP-172"> * M240 - Trigger a camera to take a photograph</front>
<front id="Marlin_mainCPP-173"> * M250 - Set LCD contrast C&lt;contrast value&gt; (value 0..63)</front>
<front id="Marlin_mainCPP-174"> * M280 - Set servo position absolute. P: servo index, S: angle or microseconds</front>
<front id="Marlin_mainCPP-175"> * M300 - Play beep sound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</front>
<front id="Marlin_mainCPP-176"> * M301 - Set PID parameters P I and D</front>
<front id="Marlin_mainCPP-177"> * M302 - Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</front>
<front id="Marlin_mainCPP-178"> * M303 - PID relay autotune S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</front>
<front id="Marlin_mainCPP-179"> * M304 - Set bed PID parameters P I and D</front>
<front id="Marlin_mainCPP-180"> * M380 - Activate solenoid on active extruder</front>
<front id="Marlin_mainCPP-181"> * M381 - Disable all solenoids</front>
<front id="Marlin_mainCPP-182"> * M400 - Finish all moves</front>
<front id="Marlin_mainCPP-183"> * M401 - Lower Z probe if present</front>
<front id="Marlin_mainCPP-184"> * M402 - Raise Z probe if present</front>
<front id="Marlin_mainCPP-185"> * M404 - N&lt;dia in mm&gt; Enter the nominal filament width (3mm, 1.75mm ) or will display nominal filament width without parameters</front>
<front id="Marlin_mainCPP-186"> * M405 - Turn on Filament Sensor extrusion control.  Optional D&lt;delay in cm&gt; to set delay in centimeters between sensor and extruder</front>
<front id="Marlin_mainCPP-187"> * M406 - Turn off Filament Sensor extrusion control</front>
<front id="Marlin_mainCPP-188"> * M407 - Display measured filament diameter</front>
<front id="Marlin_mainCPP-189"> * M410 - Quickstop. Abort all the planned moves</front>
<front id="Marlin_mainCPP-190"> * M420 - Enable/Disable Mesh Leveling (with current values) S1=enable S0=disable</front>
<front id="Marlin_mainCPP-191"> * M421 - Set a single Z coordinate in the Mesh Leveling grid. X&lt;mm&gt; Y&lt;mm&gt; Z&lt;mm&gt;</front>
<front id="Marlin_mainCPP-192"> * M428 - Set the home_offset logically based on the current_position</front>
<front id="Marlin_mainCPP-193"> * M500 - Store parameters in EEPROM</front>
<front id="Marlin_mainCPP-194"> * M501 - Read parameters from EEPROM (if you need reset them after you changed them temporarily).</front>
<front id="Marlin_mainCPP-195"> * M502 - Revert to the default "factory settings". You still need to store them in EEPROM afterwards if you want to.</front>
<front id="Marlin_mainCPP-196"> * M503 - Print the current settings (from memory not from EEPROM). Use S0 to leave off headings.</front>
<front id="Marlin_mainCPP-197"> * M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-198"> * M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</front>
<front id="Marlin_mainCPP-199"> * M665 - Set delta configurations: L&lt;diagonal rod&gt; R&lt;delta radius&gt; S&lt;segments/s&gt;</front>
<front id="Marlin_mainCPP-200"> * M666 - Set delta endstop adjustment</front>
<front id="Marlin_mainCPP-201"> * M605 - Set dual x-carriage movement mode: S&lt;mode&gt; [ X&lt;duplication x-offset&gt; R&lt;duplication temp offset&gt; ]</front>
<front id="Marlin_mainCPP-202"> * M907 - Set digital trimpot motor current using axis codes.</front>
<front id="Marlin_mainCPP-203"> * M908 - Control digital trimpot directly.</front>
<front id="Marlin_mainCPP-204"> * M350 - Set microstepping mode.</front>
<front id="Marlin_mainCPP-205"> * M351 - Toggle MS1 MS2 pins directly.</front>
<front id="Marlin_mainCPP-206"> *</front>
<front id="Marlin_mainCPP-207"> * ************ SCARA Specific - This can change to suit future G-code regulations</front>
<front id="Marlin_mainCPP-208"> * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)</front>
<front id="Marlin_mainCPP-209"> * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-210"> * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)</front>
<front id="Marlin_mainCPP-211"> * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-212"> * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)</front>
<front id="Marlin_mainCPP-213"> * M365 - SCARA calibration: Scaling factor, X, Y, Z axis</front>
<front id="Marlin_mainCPP-214"> * ************* SCARA End ***************</front>
<front id="Marlin_mainCPP-215"> *</front>
<front id="Marlin_mainCPP-216"> * ************ Custom codes - This can change to suit future G-code regulations</front>
<front id="Marlin_mainCPP-217"> * M100 - Watch Free Memory (For Debugging Only)</front>
<front id="Marlin_mainCPP-218"> * M851 - Set Z probe's Z offset (mm above extruder -- The value will always be negative)</front>
<front id="Marlin_mainCPP-219"></front>
<front id="Marlin_mainCPP-220"></front>
<front id="Marlin_mainCPP-221"> * M928 - Start SD logging (M928 filename.g) - ended by M29</front>
<front id="Marlin_mainCPP-222"> * M999 - Restart after being stopped by error</front>
<front id="Marlin_mainCPP-223"> *</front>
<front id="Marlin_mainCPP-224"> * "T" Codes</front>
<front id="Marlin_mainCPP-225"> *</front>
<front id="Marlin_mainCPP-226"> * T0-T3 - Select a tool by index (usually an extruder) [ F&lt;mm/min&gt; ]</front>
<front id="Marlin_mainCPP-227"> *</front>
<front id="Marlin_mainCPP-228"> */</front>
<front id="Marlin_mainCPP-229"></front>
<front id="Marlin_mainCPP-230">#if ENABLED(M100_FREE_MEMORY_WATCHER)</front>
<front id="Marlin_mainCPP-231">  void gcode_M100();</front>
<front id="Marlin_mainCPP-232">#endif</front>
<front id="Marlin_mainCPP-233"></front>
<front id="Marlin_mainCPP-234">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-235">  CardReader card;</front>
<front id="Marlin_mainCPP-236">#endif</front>
<front id="Marlin_mainCPP-237"></front>
<front id="Marlin_mainCPP-238">bool Running = true;</front>
<front id="Marlin_mainCPP-239"></front>
<front id="Marlin_mainCPP-240">uint8_t marlin_debug_flags = DEBUG_INFO|DEBUG_ERRORS;</front>
<front id="Marlin_mainCPP-241"></front>
<front id="Marlin_mainCPP-242">static float feedrate = 1500.0, saved_feedrate;</front>
<front id="Marlin_mainCPP-243">float current_position[NUM_AXIS] = { 0.0 };</front>
<front id="Marlin_mainCPP-244">static float destination[NUM_AXIS] = { 0.0 };</front>
<front id="Marlin_mainCPP-245">bool axis_known_position[3] = { false };</front>
<front id="Marlin_mainCPP-246"></front>
<front id="Marlin_mainCPP-247">static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;</front>
<front id="Marlin_mainCPP-248"></front>
<front id="Marlin_mainCPP-249">static char *current_command, *current_command_args;</front>
<front id="Marlin_mainCPP-250">static int cmd_queue_index_r = 0;</front>
<front id="Marlin_mainCPP-251">static int cmd_queue_index_w = 0;</front>
<front id="Marlin_mainCPP-252">static int commands_in_queue = 0;</front>
<front id="Marlin_mainCPP-253">static char command_queue[BUFSIZE][MAX_CMD_SIZE];</front>
<front id="Marlin_mainCPP-254"></front>
<front id="Marlin_mainCPP-255">const float homing_feedrate[] = HOMING_FEEDRATE;</front>
<front id="Marlin_mainCPP-256">bool axis_relative_modes[] = AXIS_RELATIVE_MODES;</front>
<front id="Marlin_mainCPP-257">int feedrate_multiplier = 100; //100-&gt;1 200-&gt;2</front>
<front id="Marlin_mainCPP-258">int saved_feedrate_multiplier;</front>
<front id="Marlin_mainCPP-259">int extruder_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);</front>
<front id="Marlin_mainCPP-260">bool volumetric_enabled = false;</front>
<front id="Marlin_mainCPP-261">float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA);</front>
<front id="Marlin_mainCPP-262">float volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);</front>
<front id="Marlin_mainCPP-263">float home_offset[3] = { 0 };</front>
<front id="Marlin_mainCPP-264">float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };</front>
<front id="Marlin_mainCPP-265">float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };</front>
<front id="Marlin_mainCPP-266"></front>
<front id="Marlin_mainCPP-267">uint8_t active_extruder = 0;</front>
<front id="Marlin_mainCPP-268">int fanSpeed = 0;</front>
<front id="Marlin_mainCPP-269">bool cancel_heatup = false;</front>
<front id="Marlin_mainCPP-270"></front>
<front id="Marlin_mainCPP-271">const char errormagic[] PROGMEM = "Error:";</front>
<front id="Marlin_mainCPP-272">const char echomagic[] PROGMEM = "echo:";</front>
<front id="Marlin_mainCPP-273">const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};</front>
<front id="Marlin_mainCPP-274"></front>
<front id="Marlin_mainCPP-275">static bool relative_mode = false;  //Determines Absolute or Relative Coordinates</front>
<front id="Marlin_mainCPP-276">static char serial_char;</front>
<front id="Marlin_mainCPP-277">static int serial_count = 0;</front>
<front id="Marlin_mainCPP-278">static boolean comment_mode = false;</front>
<front id="Marlin_mainCPP-279">static char *seen_pointer; ///&lt; A pointer to find chars in the command string (X, Y, Z, E, etc.)</front>
<front id="Marlin_mainCPP-280">const char* queued_commands_P= NULL; /* pointer to the current line in the active sequence of commands, or NULL when none */</front>
<front id="Marlin_mainCPP-281">const int sensitive_pins[] = SENSITIVE_PINS; ///&lt; Sensitive pin list for M42</front>
<front id="Marlin_mainCPP-282">// Inactivity shutdown</front>
<front id="Marlin_mainCPP-283">millis_t previous_cmd_ms = 0;</front>
<front id="Marlin_mainCPP-284">static millis_t max_inactive_time = 0;</front>
<front id="Marlin_mainCPP-285">static millis_t stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME * 1000L;</front>
<front id="Marlin_mainCPP-286">millis_t print_job_start_ms = 0; ///&lt; Print job start time</front>
<front id="Marlin_mainCPP-287">millis_t print_job_stop_ms = 0;  ///&lt; Print job stop time</front>
<front id="Marlin_mainCPP-288">static uint8_t target_extruder;</front>
<front id="Marlin_mainCPP-289">bool no_wait_for_cooling = true;</front>
<front id="Marlin_mainCPP-290">bool target_direction;</front>
<front id="Marlin_mainCPP-291"></front>
<front id="Marlin_mainCPP-292">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-293">  int xy_travel_speed = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-294">  float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-295">#endif</front>
<front id="Marlin_mainCPP-296"></front>
<front id="Marlin_mainCPP-297">#if ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-298">  float z_endstop_adj = 0;</front>
<front id="Marlin_mainCPP-299">#endif</front>
<front id="Marlin_mainCPP-300"></front>
<front id="Marlin_mainCPP-301">// Extruder offsets</front>
<front id="Marlin_mainCPP-302">#if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-303">  #ifndef EXTRUDER_OFFSET_X</front>
<front id="Marlin_mainCPP-304">    #define EXTRUDER_OFFSET_X { 0 }</front>
<front id="Marlin_mainCPP-305">  #endif</front>
<front id="Marlin_mainCPP-306">  #ifndef EXTRUDER_OFFSET_Y</front>
<front id="Marlin_mainCPP-307">    #define EXTRUDER_OFFSET_Y { 0 }</front>
<front id="Marlin_mainCPP-308">  #endif</front>
<front id="Marlin_mainCPP-309">  float extruder_offset[][EXTRUDERS] = {</front>
<front id="Marlin_mainCPP-310">    EXTRUDER_OFFSET_X,</front>
<front id="Marlin_mainCPP-311">    EXTRUDER_OFFSET_Y</front>
<front id="Marlin_mainCPP-312">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-313">      , { 0 } // supports offsets in XYZ plane</front>
<front id="Marlin_mainCPP-314">    #endif</front>
<front id="Marlin_mainCPP-315">  };</front>
<front id="Marlin_mainCPP-316">#endif</front>
<front id="Marlin_mainCPP-317"></front>
<front id="Marlin_mainCPP-318">#if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-319">  const int servo_endstop_id[] = SERVO_ENDSTOP_IDS;</front>
<front id="Marlin_mainCPP-320">  const int servo_endstop_angle[][2] = SERVO_ENDSTOP_ANGLES;</front>
<front id="Marlin_mainCPP-321">#endif</front>
<front id="Marlin_mainCPP-322"></front>
<front id="Marlin_mainCPP-323">#if ENABLED(BARICUDA)</front>
<front id="Marlin_mainCPP-324">  int ValvePressure = 0;</front>
<front id="Marlin_mainCPP-325">  int EtoPPressure = 0;</front>
<front id="Marlin_mainCPP-326">#endif</front>
<front id="Marlin_mainCPP-327"></front>
<front id="Marlin_mainCPP-328">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-329"></front>
<front id="Marlin_mainCPP-330">  bool autoretract_enabled = false;</front>
<front id="Marlin_mainCPP-331">  bool retracted[EXTRUDERS] = { false };</front>
<front id="Marlin_mainCPP-332">  bool retracted_swap[EXTRUDERS] = { false };</front>
<front id="Marlin_mainCPP-333"></front>
<front id="Marlin_mainCPP-334">  float retract_length = RETRACT_LENGTH;</front>
<front id="Marlin_mainCPP-335">  float retract_length_swap = RETRACT_LENGTH_SWAP;</front>
<front id="Marlin_mainCPP-336">  float retract_feedrate = RETRACT_FEEDRATE;</front>
<front id="Marlin_mainCPP-337">  float retract_zlift = RETRACT_ZLIFT;</front>
<front id="Marlin_mainCPP-338">  float retract_recover_length = RETRACT_RECOVER_LENGTH;</front>
<front id="Marlin_mainCPP-339">  float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;</front>
<front id="Marlin_mainCPP-340">  float retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;</front>
<front id="Marlin_mainCPP-341"></front>
<front id="Marlin_mainCPP-342">#endif // FWRETRACT</front>
<front id="Marlin_mainCPP-343"></front>
<front id="Marlin_mainCPP-344">#if ENABLED(ULTIPANEL) && HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-345">  bool powersupply =</front>
<front id="Marlin_mainCPP-346">    #if ENABLED(PS_DEFAULT_OFF)</front>
<front id="Marlin_mainCPP-347">      false</front>
<front id="Marlin_mainCPP-348">    #else</front>
<front id="Marlin_mainCPP-349">      true</front>
<front id="Marlin_mainCPP-350">    #endif</front>
<front id="Marlin_mainCPP-351">  ;</front>
<front id="Marlin_mainCPP-352">#endif</front>
<front id="Marlin_mainCPP-353"></front>
<front id="Marlin_mainCPP-354">#if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-355"></front>
<front id="Marlin_mainCPP-356">  #define TOWER_1 X_AXIS</front>
<front id="Marlin_mainCPP-357">  #define TOWER_2 Y_AXIS</front>
<front id="Marlin_mainCPP-358">  #define TOWER_3 Z_AXIS</front>
<front id="Marlin_mainCPP-359"></front>
<front id="Marlin_mainCPP-360">  float delta[3] = { 0 };</front>
<front id="Marlin_mainCPP-361">  #define SIN_60 0.8660254037844386</front>
<front id="Marlin_mainCPP-362">  #define COS_60 0.5</front>
<front id="Marlin_mainCPP-363">  float endstop_adj[3] = { 0 };</front>
<front id="Marlin_mainCPP-364">  // these are the default values, can be overriden with M665</front>
<front id="Marlin_mainCPP-365">  float delta_radius = DELTA_RADIUS;</front>
<front id="Marlin_mainCPP-366">  float delta_tower1_x = -SIN_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_1); // front left tower</front>
<front id="Marlin_mainCPP-367">  float delta_tower1_y = -COS_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_1);</front>
<front id="Marlin_mainCPP-368">  float delta_tower2_x =  SIN_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_2); // front right tower</front>
<front id="Marlin_mainCPP-369">  float delta_tower2_y = -COS_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_2);</front>
<front id="Marlin_mainCPP-370">  float delta_tower3_x = 0;                                                    // back middle tower</front>
<front id="Marlin_mainCPP-371">  float delta_tower3_y = (delta_radius + DELTA_RADIUS_TRIM_TOWER_3);</front>
<front id="Marlin_mainCPP-372">  float delta_diagonal_rod = DELTA_DIAGONAL_ROD;</front>
<front id="Marlin_mainCPP-373">  float delta_diagonal_rod_trim_tower_1 = DELTA_DIAGONAL_ROD_TRIM_TOWER_1;</front>
<front id="Marlin_mainCPP-374">  float delta_diagonal_rod_trim_tower_2 = DELTA_DIAGONAL_ROD_TRIM_TOWER_2;</front>
<front id="Marlin_mainCPP-375">  float delta_diagonal_rod_trim_tower_3 = DELTA_DIAGONAL_ROD_TRIM_TOWER_3;</front>
<front id="Marlin_mainCPP-376">  float delta_diagonal_rod_2_tower_1 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_1);</front>
<front id="Marlin_mainCPP-377">  float delta_diagonal_rod_2_tower_2 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_2);</front>
<front id="Marlin_mainCPP-378">  float delta_diagonal_rod_2_tower_3 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_3);</front>
<front id="Marlin_mainCPP-379">  //float delta_diagonal_rod_2 = sq(delta_diagonal_rod);</front>
<front id="Marlin_mainCPP-380">  float delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;</front>
<front id="Marlin_mainCPP-381">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-382">    int delta_grid_spacing[2] = { 0, 0 };</front>
<front id="Marlin_mainCPP-383">    float bed_level[AUTO_BED_LEVELING_GRID_POINTS][AUTO_BED_LEVELING_GRID_POINTS];</front>
<front id="Marlin_mainCPP-384">  #endif</front>
<front id="Marlin_mainCPP-385">#else</front>
<front id="Marlin_mainCPP-386">  static bool home_all_axis = true;</front>
<front id="Marlin_mainCPP-387">#endif</front>
<front id="Marlin_mainCPP-388"></front>
<front id="Marlin_mainCPP-389">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-390">  float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;</front>
<front id="Marlin_mainCPP-391">  static float delta[3] = { 0 };</front>
<front id="Marlin_mainCPP-392">  float axis_scaling[3] = { 1, 1, 1 };    // Build size scaling, default to 1</front>
<front id="Marlin_mainCPP-393">#endif</front>
<front id="Marlin_mainCPP-394"></front>
<front id="Marlin_mainCPP-395">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="Marlin_mainCPP-396">  //Variables for Filament Sensor input</front>
<front id="Marlin_mainCPP-397">  float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA;  //Set nominal filament width, can be changed with M404</front>
<front id="Marlin_mainCPP-398">  bool filament_sensor = false;  //M405 turns on filament_sensor control, M406 turns it off</front>
<front id="Marlin_mainCPP-399">  float filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA; //Stores the measured filament diameter</front>
<front id="Marlin_mainCPP-400">  signed char measurement_delay[MAX_MEASUREMENT_DELAY+1];  //ring buffer to delay measurement  store extruder factor after subtracting 100</front>
<front id="Marlin_mainCPP-401">  int delay_index1 = 0;  //index into ring buffer</front>
<front id="Marlin_mainCPP-402">  int delay_index2 = -1;  //index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized</front>
<front id="Marlin_mainCPP-403">  float delay_dist = 0; //delay distance counter</front>
<front id="Marlin_mainCPP-404">  int meas_delay_cm = MEASUREMENT_DELAY_CM;  //distance delay setting</front>
<front id="Marlin_mainCPP-405">#endif</front>
<front id="Marlin_mainCPP-406"></front>
<front id="Marlin_mainCPP-407">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="Marlin_mainCPP-408">   static bool filrunoutEnqueued = false;</front>
<front id="Marlin_mainCPP-409">#endif</front>
<front id="Marlin_mainCPP-410"></front>
<front id="Marlin_mainCPP-411">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-412">  static bool fromsd[BUFSIZE];</front>
<front id="Marlin_mainCPP-413">#endif</front>
<front id="Marlin_mainCPP-414"></front>
<front id="Marlin_mainCPP-415">#if HAS_SERVOS</front>
<front id="Marlin_mainCPP-416">  Servo servo[NUM_SERVOS];</front>
<front id="Marlin_mainCPP-417">#endif</front>
<front id="Marlin_mainCPP-418"></front>
<front id="Marlin_mainCPP-419">#ifdef CHDK</front>
<front id="Marlin_mainCPP-420">  unsigned long chdkHigh = 0;</front>
<front id="Marlin_mainCPP-421">  boolean chdkActive = false;</front>
<front id="Marlin_mainCPP-422">#endif</front>
<front id="Marlin_mainCPP-423"></front>
<front id="Marlin_mainCPP-424">#if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Marlin_mainCPP-425">  int lpq_len = 20;</front>
<front id="Marlin_mainCPP-426">#endif</front>
<front id="Marlin_mainCPP-427"></front>
<front id="Marlin_mainCPP-428">#if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-429">  extern float planner_disabled_below_z;</front>
<front id="Marlin_mainCPP-430">  extern bool layer_reached;</front>
<front id="Marlin_mainCPP-431">#endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-432"></front>
<front id="Marlin_mainCPP-433">//===========================================================================</front>
<front id="Marlin_mainCPP-434">//================================ Functions ================================</front>
<front id="Marlin_mainCPP-435">//===========================================================================</front>
<front id="Marlin_mainCPP-436"></front>
<front id="Marlin_mainCPP-437">void process_next_command();</front>
<front id="Marlin_mainCPP-438"></front>
<front id="Marlin_mainCPP-439">void plan_arc(float target[NUM_AXIS], float *offset, uint8_t clockwise);</front>
<front id="Marlin_mainCPP-440"></front>
<front id="Marlin_mainCPP-441">bool setTargetedHotend(int code);</front>
<front id="Marlin_mainCPP-442"></front>
<front id="Marlin_mainCPP-443">void serial_echopair_P(const char *s_P, int v)           { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-444">void serial_echopair_P(const char *s_P, long v)          { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-445">void serial_echopair_P(const char *s_P, float v)         { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-446">void serial_echopair_P(const char *s_P, double v)        { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-447">void serial_echopair_P(const char *s_P, unsigned long v) { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-448"></front>
<front id="Marlin_mainCPP-449">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-450">  float extrude_min_temp = EXTRUDE_MINTEMP;</front>
<front id="Marlin_mainCPP-451">#endif</front>
<front id="Marlin_mainCPP-452"></front>
<front id="Marlin_mainCPP-453">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-454">  #include "SdFatUtil.h"</front>
<front id="Marlin_mainCPP-455">  int freeMemory() { return SdFatUtil::FreeRam(); }</front>
<front id="Marlin_mainCPP-456">#else</front>
<front id="Marlin_mainCPP-457">  extern "C" {</front>
<front id="Marlin_mainCPP-458">    extern unsigned int __bss_end;</front>
<front id="Marlin_mainCPP-459">    extern unsigned int __heap_start;</front>
<front id="Marlin_mainCPP-460">    extern void *__brkval;</front>
<front id="Marlin_mainCPP-461"></front>
<front id="Marlin_mainCPP-462">    int freeMemory() {</front>
<front id="Marlin_mainCPP-463">      int free_memory;</front>
<front id="Marlin_mainCPP-464"></front>
<front id="Marlin_mainCPP-465">      if ((int)__brkval == 0)</front>
<front id="Marlin_mainCPP-466">        free_memory = ((int)&free_memory) - ((int)&__bss_end);</front>
<front id="Marlin_mainCPP-467">      else</front>
<front id="Marlin_mainCPP-468">        free_memory = ((int)&free_memory) - ((int)__brkval);</front>
<front id="Marlin_mainCPP-469"></front>
<front id="Marlin_mainCPP-470">      return free_memory;</front>
<front id="Marlin_mainCPP-471">    }</front>
<front id="Marlin_mainCPP-472">  }</front>
<front id="Marlin_mainCPP-473">#endif //!SDSUPPORT</front>
<front id="Marlin_mainCPP-474"></front>
<front id="Marlin_mainCPP-475">/**</front>
<front id="Marlin_mainCPP-476"> * Inject the next command from the command queue, when possible</front>
<front id="Marlin_mainCPP-477"> * Return false only if no command was pending</front>
<front id="Marlin_mainCPP-478"> */</front>
<front id="Marlin_mainCPP-479">static bool drain_queued_commands_P() {</front>
<front id="Marlin_mainCPP-480">  if (!queued_commands_P) return false;</front>
<front id="Marlin_mainCPP-481"></front>
<front id="Marlin_mainCPP-482">  // Get the next 30 chars from the sequence of gcodes to run</front>
<front id="Marlin_mainCPP-483">  char cmd[30];</front>
<front id="Marlin_mainCPP-484">  strncpy_P(cmd, queued_commands_P, sizeof(cmd) - 1);</front>
<front id="Marlin_mainCPP-485">  cmd[sizeof(cmd) - 1] = '\0';</front>
<front id="Marlin_mainCPP-486"></front>
<front id="Marlin_mainCPP-487">  // Look for the end of line, or the end of sequence</front>
<front id="Marlin_mainCPP-488">  size_t i = 0;</front>
<front id="Marlin_mainCPP-489">  char c;</front>
<front id="Marlin_mainCPP-490">  while((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command</front>
<front id="Marlin_mainCPP-491">  cmd[i] = '\0';</front>
<front id="Marlin_mainCPP-492">  if (enqueuecommand(cmd)) {      // buffer was not full (else we will retry later)</front>
<front id="Marlin_mainCPP-493">    if (c)</front>
<front id="Marlin_mainCPP-494">      queued_commands_P += i + 1; // move to next command</front>
<front id="Marlin_mainCPP-495">    else</front>
<front id="Marlin_mainCPP-496">      queued_commands_P = NULL;   // will have no more commands in the sequence</front>
<front id="Marlin_mainCPP-497">  }</front>
<front id="Marlin_mainCPP-498">  return true;</front>
<front id="Marlin_mainCPP-499">}</front>
<front id="Marlin_mainCPP-500"></front>
<front id="Marlin_mainCPP-501">/**</front>
<front id="Marlin_mainCPP-502"> * Record one or many commands to run from program memory.</front>
<front id="Marlin_mainCPP-503"> * Aborts the current queue, if any.</front>
<front id="Marlin_mainCPP-504"> * Note: drain_queued_commands_P() must be called repeatedly to drain the commands afterwards</front>
<front id="Marlin_mainCPP-505"> */</front>
<front id="Marlin_mainCPP-506">void enqueuecommands_P(const char* pgcode) {</front>
<front id="Marlin_mainCPP-507">  queued_commands_P = pgcode;</front>
<front id="Marlin_mainCPP-508">  drain_queued_commands_P(); // first command executed asap (when possible)</front>
<front id="Marlin_mainCPP-509">}</front>
<front id="Marlin_mainCPP-510"></front>
<front id="Marlin_mainCPP-511">/**</front>
<front id="Marlin_mainCPP-512"> * Copy a command directly into the main command buffer, from RAM.</front>
<front id="Marlin_mainCPP-513"> *</front>
<front id="Marlin_mainCPP-514"> * This is done in a non-safe way and needs a rework someday.</front>
<front id="Marlin_mainCPP-515"> * Returns false if it doesn't add any command</front>
<front id="Marlin_mainCPP-516"> */</front>
<front id="Marlin_mainCPP-517">bool enqueuecommand(const char *cmd) {</front>
<front id="Marlin_mainCPP-518"></front>
<front id="Marlin_mainCPP-519">  if (*cmd == ';' || commands_in_queue &gt;= BUFSIZE) return false;</front>
<front id="Marlin_mainCPP-520"></front>
<front id="Marlin_mainCPP-521">  // This is dangerous if a mixing of serial and this happens</front>
<front id="Marlin_mainCPP-522">  char *command = command_queue[cmd_queue_index_w];</front>
<front id="Marlin_mainCPP-523">  strcpy(command, cmd);</front>
<front id="Marlin_mainCPP-524">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-525">  SERIAL_ECHOPGM(MSG_Enqueueing);</front>
<front id="Marlin_mainCPP-526">  SERIAL_ECHO(command);</front>
<front id="Marlin_mainCPP-527">  SERIAL_ECHOLNPGM("\"");</front>
<front id="Marlin_mainCPP-528">  cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-529">  commands_in_queue++;</front>
<front id="Marlin_mainCPP-530">  return true;</front>
<front id="Marlin_mainCPP-531">}</front>
<front id="Marlin_mainCPP-532"></front>
<front id="Marlin_mainCPP-533">void setup_killpin() {</front>
<front id="Marlin_mainCPP-534">  #if HAS_KILL</front>
<front id="Marlin_mainCPP-535">    SET_INPUT(KILL_PIN);</front>
<front id="Marlin_mainCPP-536">    WRITE(KILL_PIN, HIGH);</front>
<front id="Marlin_mainCPP-537">  #endif</front>
<front id="Marlin_mainCPP-538">}</front>
<front id="Marlin_mainCPP-539"></front>
<front id="Marlin_mainCPP-540">void setup_filrunoutpin() {</front>
<front id="Marlin_mainCPP-541">  #if HAS_FILRUNOUT</front>
<front id="Marlin_mainCPP-542">    pinMode(FILRUNOUT_PIN, INPUT);</front>
<front id="Marlin_mainCPP-543">    #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)</front>
<front id="Marlin_mainCPP-544">      WRITE(FILRUNOUT_PIN, HIGH);</front>
<front id="Marlin_mainCPP-545">    #endif</front>
<front id="Marlin_mainCPP-546">  #endif</front>
<front id="Marlin_mainCPP-547">}</front>
<front id="Marlin_mainCPP-548"></front>
<front id="Marlin_mainCPP-549">// Set home pin</front>
<front id="Marlin_mainCPP-550">void setup_homepin(void) {</front>
<front id="Marlin_mainCPP-551">  #if HAS_HOME</front>
<front id="Marlin_mainCPP-552">    SET_INPUT(HOME_PIN);</front>
<front id="Marlin_mainCPP-553">    WRITE(HOME_PIN, HIGH);</front>
<front id="Marlin_mainCPP-554">  #endif</front>
<front id="Marlin_mainCPP-555">}</front>
<front id="Marlin_mainCPP-556"></front>
<front id="Marlin_mainCPP-557"></front>
<front id="Marlin_mainCPP-558">void setup_photpin() {</front>
<front id="Marlin_mainCPP-559">  #if HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-560">    OUT_WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-561">  #endif</front>
<front id="Marlin_mainCPP-562">}</front>
<front id="Marlin_mainCPP-563"></front>
<front id="Marlin_mainCPP-564">void setup_powerhold() {</front>
<front id="Marlin_mainCPP-565">  #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-566">    OUT_WRITE(SUICIDE_PIN, HIGH);</front>
<front id="Marlin_mainCPP-567">  #endif</front>
<front id="Marlin_mainCPP-568">  #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-569">    #if ENABLED(PS_DEFAULT_OFF)</front>
<front id="Marlin_mainCPP-570">      OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);</front>
<front id="Marlin_mainCPP-571">    #else</front>
<front id="Marlin_mainCPP-572">      OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);</front>
<front id="Marlin_mainCPP-573">    #endif</front>
<front id="Marlin_mainCPP-574">  #endif</front>
<front id="Marlin_mainCPP-575">}</front>
<front id="Marlin_mainCPP-576"></front>
<front id="Marlin_mainCPP-577">void suicide() {</front>
<front id="Marlin_mainCPP-578">  #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-579">    OUT_WRITE(SUICIDE_PIN, LOW);</front>
<front id="Marlin_mainCPP-580">  #endif</front>
<front id="Marlin_mainCPP-581">}</front>
<front id="Marlin_mainCPP-582"></front>
<front id="Marlin_mainCPP-583">void servo_init() {</front>
<front id="Marlin_mainCPP-584">  #if NUM_SERVOS &gt;= 1 && HAS_SERVO_0</front>
<front id="Marlin_mainCPP-585">    servo[0].attach(SERVO0_PIN);</front>
<front id="Marlin_mainCPP-586">    servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.</front>
<front id="Marlin_mainCPP-587">  #endif</front>
<front id="Marlin_mainCPP-588">  #if NUM_SERVOS &gt;= 2 && HAS_SERVO_1</front>
<front id="Marlin_mainCPP-589">    servo[1].attach(SERVO1_PIN);</front>
<front id="Marlin_mainCPP-590">    servo[1].detach();</front>
<front id="Marlin_mainCPP-591">  #endif</front>
<front id="Marlin_mainCPP-592">  #if NUM_SERVOS &gt;= 3 && HAS_SERVO_2</front>
<front id="Marlin_mainCPP-593">    servo[2].attach(SERVO2_PIN);</front>
<front id="Marlin_mainCPP-594">    servo[2].detach();</front>
<front id="Marlin_mainCPP-595">  #endif</front>
<front id="Marlin_mainCPP-596">  #if NUM_SERVOS &gt;= 4 && HAS_SERVO_3</front>
<front id="Marlin_mainCPP-597">    servo[3].attach(SERVO3_PIN);</front>
<front id="Marlin_mainCPP-598">    servo[3].detach();</front>
<front id="Marlin_mainCPP-599">  #endif</front>
<front id="Marlin_mainCPP-600"></front>
<front id="Marlin_mainCPP-601">  // Set position of Servo Endstops that are defined</front>
<front id="Marlin_mainCPP-602">  #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-603">    for (int i = 0; i &lt; 3; i++)</front>
<front id="Marlin_mainCPP-604">      if (servo_endstop_id[i] &gt;= 0)</front>
<front id="Marlin_mainCPP-605">        servo[servo_endstop_id[i]].move(servo_endstop_angle[i][1]);</front>
<front id="Marlin_mainCPP-606">  #endif</front>
<front id="Marlin_mainCPP-607"></front>
<front id="Marlin_mainCPP-608">}</front>
<front id="Marlin_mainCPP-609"></front>
<front id="Marlin_mainCPP-610">/**</front>
<front id="Marlin_mainCPP-611"> * Stepper Reset (RigidBoard, et.al.)</front>
<front id="Marlin_mainCPP-612"> */</front>
<front id="Marlin_mainCPP-613">#if HAS_STEPPER_RESET</front>
<front id="Marlin_mainCPP-614">  void disableStepperDrivers() {</front>
<front id="Marlin_mainCPP-615">    pinMode(STEPPER_RESET_PIN, OUTPUT);</front>
<front id="Marlin_mainCPP-616">    digitalWrite(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips</front>
<front id="Marlin_mainCPP-617">  }</front>
<front id="Marlin_mainCPP-618">  void enableStepperDrivers() { pinMode(STEPPER_RESET_PIN, INPUT); }  // set to input, which allows it to be pulled high by pullups</front>
<front id="Marlin_mainCPP-619">#endif</front>
<front id="Marlin_mainCPP-620"></front>
<front id="Marlin_mainCPP-621">/**</front>
<front id="Marlin_mainCPP-622"> * Marlin entry-point: Set up before the program loop</front>
<front id="Marlin_mainCPP-623"> *  - Set up the kill pin, filament runout, power hold</front>
<front id="Marlin_mainCPP-624"> *  - Start the serial port</front>
<front id="Marlin_mainCPP-625"> *  - Print startup messages and diagnostics</front>
<front id="Marlin_mainCPP-626"> *  - Get EEPROM or default settings</front>
<front id="Marlin_mainCPP-627"> *  - Initialize managers for:</front>
<front id="Marlin_mainCPP-628"> *     temperature</front>
<front id="Marlin_mainCPP-629"> *     planner</front>
<front id="Marlin_mainCPP-630"> *     watchdog</front>
<front id="Marlin_mainCPP-631"> *     stepper</front>
<front id="Marlin_mainCPP-632"> *     photo pin</front>
<front id="Marlin_mainCPP-633"> *     servos</front>
<front id="Marlin_mainCPP-634"> *     LCD controller</front>
<front id="Marlin_mainCPP-635"> *     Digipot I2C</front>
<front id="Marlin_mainCPP-636"> *     Z probe sled</front>
<front id="Marlin_mainCPP-637"> *     status LEDs</front>
<front id="Marlin_mainCPP-638"> */</front>
<front id="Marlin_mainCPP-639">void setup() {</front>
<front id="Marlin_mainCPP-640">  setup_killpin();</front>
<front id="Marlin_mainCPP-641">  setup_filrunoutpin();</front>
<front id="Marlin_mainCPP-642">  setup_powerhold();</front>
<front id="Marlin_mainCPP-643"></front>
<front id="Marlin_mainCPP-644">  #if HAS_STEPPER_RESET</front>
<front id="Marlin_mainCPP-645">    disableStepperDrivers();</front>
<front id="Marlin_mainCPP-646">  #endif</front>
<front id="Marlin_mainCPP-647"></front>
<front id="Marlin_mainCPP-648">  MYSERIAL.begin(BAUDRATE);</front>
<front id="Marlin_mainCPP-649">  SERIAL_PROTOCOLLNPGM("start");</front>
<front id="Marlin_mainCPP-650">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-651"></front>
<front id="Marlin_mainCPP-652">  // Check startup - does nothing if bootloader sets MCUSR to 0</front>
<front id="Marlin_mainCPP-653">  byte mcu = MCUSR;</front>
<front id="Marlin_mainCPP-654">  if (mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);</front>
<front id="Marlin_mainCPP-655">  if (mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);</front>
<front id="Marlin_mainCPP-656">  if (mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);</front>
<front id="Marlin_mainCPP-657">  if (mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);</front>
<front id="Marlin_mainCPP-658">  if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);</front>
<front id="Marlin_mainCPP-659">  MCUSR = 0;</front>
<front id="Marlin_mainCPP-660"></front>
<front id="Marlin_mainCPP-661">  SERIAL_ECHOPGM(MSG_MARLIN);</front>
<front id="Marlin_mainCPP-662">  SERIAL_ECHOLNPGM(" " SHORT_BUILD_VERSION);</front>
<front id="Marlin_mainCPP-663"></front>
<front id="Marlin_mainCPP-664">  #ifdef STRING_DISTRIBUTION_DATE</front>
<front id="Marlin_mainCPP-665">    #ifdef STRING_CONFIG_H_AUTHOR</front>
<front id="Marlin_mainCPP-666">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-667">      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);</front>
<front id="Marlin_mainCPP-668">      SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);</front>
<front id="Marlin_mainCPP-669">      SERIAL_ECHOPGM(MSG_AUTHOR);</front>
<front id="Marlin_mainCPP-670">      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);</front>
<front id="Marlin_mainCPP-671">      SERIAL_ECHOPGM("Compiled: ");</front>
<front id="Marlin_mainCPP-672">      SERIAL_ECHOLNPGM(__DATE__);</front>
<front id="Marlin_mainCPP-673">    #endif // STRING_CONFIG_H_AUTHOR</front>
<front id="Marlin_mainCPP-674">  #endif // STRING_DISTRIBUTION_DATE</front>
<front id="Marlin_mainCPP-675"></front>
<front id="Marlin_mainCPP-676">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-677">  SERIAL_ECHOPGM(MSG_FREE_MEMORY);</front>
<front id="Marlin_mainCPP-678">  SERIAL_ECHO(freeMemory());</front>
<front id="Marlin_mainCPP-679">  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);</front>
<front id="Marlin_mainCPP-680">  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);</front>
<front id="Marlin_mainCPP-681"></front>
<front id="Marlin_mainCPP-682">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-683">    for (int8_t i = 0; i &lt; BUFSIZE; i++) fromsd[i] = false;</front>
<front id="Marlin_mainCPP-684">  #endif</front>
<front id="Marlin_mainCPP-685"></front>
<front id="Marlin_mainCPP-686">  // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)</front>
<front id="Marlin_mainCPP-687">  Config_RetrieveSettings();</front>
<front id="Marlin_mainCPP-688"></front>
<front id="Marlin_mainCPP-689">  lcd_init();</front>
<front id="Marlin_mainCPP-690"></front>
<front id="Marlin_mainCPP-691">  tp_init();    // Initialize temperature loop</front>
<front id="Marlin_mainCPP-692">  plan_init();  // Initialize planner;</front>
<front id="Marlin_mainCPP-693">  watchdog_init();</front>
<front id="Marlin_mainCPP-694">  st_init();    // Initialize stepper, this enables interrupts!</front>
<front id="Marlin_mainCPP-695">  setup_photpin();</front>
<front id="Marlin_mainCPP-696">  servo_init();</front>
<front id="Marlin_mainCPP-697"></front>
<front id="Marlin_mainCPP-698">  #if HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-699">    SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan</front>
<front id="Marlin_mainCPP-700">  #endif</front>
<front id="Marlin_mainCPP-701"></front>
<front id="Marlin_mainCPP-702">  #if HAS_STEPPER_RESET</front>
<front id="Marlin_mainCPP-703">    enableStepperDrivers();</front>
<front id="Marlin_mainCPP-704">  #endif</front>
<front id="Marlin_mainCPP-705"></front>
<front id="Marlin_mainCPP-706">  #if ENABLED(DIGIPOT_I2C)</front>
<front id="Marlin_mainCPP-707">    digipot_i2c_init();</front>
<front id="Marlin_mainCPP-708">  #endif</front>
<front id="Marlin_mainCPP-709"></front>
<front id="Marlin_mainCPP-710">  #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-711">    pinMode(SLED_PIN, OUTPUT);</front>
<front id="Marlin_mainCPP-712">    digitalWrite(SLED_PIN, LOW); // turn it off</front>
<front id="Marlin_mainCPP-713">  #endif // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-714"></front>
<front id="Marlin_mainCPP-715">  setup_homepin();</front>
<front id="Marlin_mainCPP-716"></front>
<front id="Marlin_mainCPP-717">  #ifdef STAT_LED_RED</front>
<front id="Marlin_mainCPP-718">    pinMode(STAT_LED_RED, OUTPUT);</front>
<front id="Marlin_mainCPP-719">    digitalWrite(STAT_LED_RED, LOW); // turn it off</front>
<front id="Marlin_mainCPP-720">  #endif</front>
<front id="Marlin_mainCPP-721"></front>
<front id="Marlin_mainCPP-722">  #ifdef STAT_LED_BLUE</front>
<front id="Marlin_mainCPP-723">    pinMode(STAT_LED_BLUE, OUTPUT);</front>
<front id="Marlin_mainCPP-724">    digitalWrite(STAT_LED_BLUE, LOW); // turn it off</front>
<front id="Marlin_mainCPP-725">  #endif</front>
<front id="Marlin_mainCPP-726">}</front>
<front id="Marlin_mainCPP-727"></front>
<front id="Marlin_mainCPP-728">/**</front>
<front id="Marlin_mainCPP-729"> * The main Marlin program loop</front>
<front id="Marlin_mainCPP-730"> *</front>
<front id="Marlin_mainCPP-731"> *  - Save or log commands to SD</front>
<front id="Marlin_mainCPP-732"> *  - Process available commands (if not saving)</front>
<front id="Marlin_mainCPP-733"> *  - Call heater manager</front>
<front id="Marlin_mainCPP-734"> *  - Call inactivity manager</front>
<front id="Marlin_mainCPP-735"> *  - Call endstop manager</front>
<front id="Marlin_mainCPP-736"> *  - Call LCD update</front>
<front id="Marlin_mainCPP-737"> */</front>
<front id="Marlin_mainCPP-738">void loop() {</front>
<front id="Marlin_mainCPP-739">  if (commands_in_queue &lt; BUFSIZE - 1) get_command();</front>
<front id="Marlin_mainCPP-740"></front>
<front id="Marlin_mainCPP-741">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-742">    card.checkautostart(false);</front>
<front id="Marlin_mainCPP-743">  #endif</front>
<front id="Marlin_mainCPP-744"></front>
<front id="Marlin_mainCPP-745">  if (commands_in_queue) {</front>
<front id="Marlin_mainCPP-746"></front>
<front id="Marlin_mainCPP-747">    #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-748"></front>
<front id="Marlin_mainCPP-749">      if (card.saving) {</front>
<front id="Marlin_mainCPP-750">        char *command = command_queue[cmd_queue_index_r];</front>
<front id="Marlin_mainCPP-751">        if (strstr_P(command, PSTR("M29"))) {</front>
<front id="Marlin_mainCPP-752">          // M29 closes the file</front>
<front id="Marlin_mainCPP-753">          card.closefile();</front>
<front id="Marlin_mainCPP-754">          SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);</front>
<front id="Marlin_mainCPP-755">        }</front>
<front id="Marlin_mainCPP-756">        else {</front>
<front id="Marlin_mainCPP-757">          // Write the string from the read buffer to SD</front>
<front id="Marlin_mainCPP-758">          card.write_command(command);</front>
<front id="Marlin_mainCPP-759">          if (card.logging)</front>
<front id="Marlin_mainCPP-760">            process_next_command(); // The card is saving because it's logging</front>
<front id="Marlin_mainCPP-761">          else</front>
<front id="Marlin_mainCPP-762">            SERIAL_PROTOCOLLNPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-763">        }</front>
<front id="Marlin_mainCPP-764">      }</front>
<front id="Marlin_mainCPP-765">      else</front>
<front id="Marlin_mainCPP-766">        process_next_command();</front>
<front id="Marlin_mainCPP-767"></front>
<front id="Marlin_mainCPP-768">    #else</front>
<front id="Marlin_mainCPP-769"></front>
<front id="Marlin_mainCPP-770">      process_next_command();</front>
<front id="Marlin_mainCPP-771"></front>
<front id="Marlin_mainCPP-772">    #endif // SDSUPPORT</front>
<front id="Marlin_mainCPP-773"></front>
<front id="Marlin_mainCPP-774">    commands_in_queue--;</front>
<front id="Marlin_mainCPP-775">    cmd_queue_index_r = (cmd_queue_index_r + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-776">  }</front>
<front id="Marlin_mainCPP-777">  checkHitEndstops();</front>
<front id="Marlin_mainCPP-778">  idle();</front>
<front id="Marlin_mainCPP-779">}</front>
<front id="Marlin_mainCPP-780"></front>
<front id="Marlin_mainCPP-781">void gcode_line_error(const char *err, bool doFlush=true) {</front>
<front id="Marlin_mainCPP-782">  SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-783">  serialprintPGM(err);</front>
<front id="Marlin_mainCPP-784">  SERIAL_ERRORLN(gcode_LastN);</front>
<front id="Marlin_mainCPP-785">  //Serial.println(gcode_N);</front>
<front id="Marlin_mainCPP-786">  if (doFlush) FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-787">  serial_count = 0;</front>
<front id="Marlin_mainCPP-788">}</front>
<front id="Marlin_mainCPP-789"></front>
<front id="Marlin_mainCPP-790">/**</front>
<front id="Marlin_mainCPP-791"> * Add to the circular command queue the next command from:</front>
<front id="Marlin_mainCPP-792"> *  - The command-injection queue (queued_commands_P)</front>
<front id="Marlin_mainCPP-793"> *  - The active serial input (usually USB)</front>
<front id="Marlin_mainCPP-794"> *  - The SD card file being actively printed</front>
<front id="Marlin_mainCPP-795"> */</front>
<front id="Marlin_mainCPP-796">void get_command() {</front>
<front id="Marlin_mainCPP-797"></front>
<front id="Marlin_mainCPP-798">  if (drain_queued_commands_P()) return; // priority is given to non-serial commands</front>
<front id="Marlin_mainCPP-799"></front>
<front id="Marlin_mainCPP-800">  #if ENABLED(NO_TIMEOUTS)</front>
<front id="Marlin_mainCPP-801">    static millis_t last_command_time = 0;</front>
<front id="Marlin_mainCPP-802">    millis_t ms = millis();</front>
<front id="Marlin_mainCPP-803"></front>
<front id="Marlin_mainCPP-804">    if (!MYSERIAL.available() && commands_in_queue == 0 && ms - last_command_time &gt; NO_TIMEOUTS) {</front>
<front id="Marlin_mainCPP-805">      SERIAL_ECHOLNPGM(MSG_WAIT);</front>
<front id="Marlin_mainCPP-806">      last_command_time = ms;</front>
<front id="Marlin_mainCPP-807">    }</front>
<front id="Marlin_mainCPP-808">  #endif</front>
<front id="Marlin_mainCPP-809"></front>
<front id="Marlin_mainCPP-810">  //</front>
<front id="Marlin_mainCPP-811">  // Loop while serial characters are incoming and the queue is not full</front>
<front id="Marlin_mainCPP-812">  //</front>
<front id="Marlin_mainCPP-813">  while (commands_in_queue &lt; BUFSIZE && MYSERIAL.available() &gt; 0) {</front>
<front id="Marlin_mainCPP-814"></front>
<front id="Marlin_mainCPP-815">    #if ENABLED(NO_TIMEOUTS)</front>
<front id="Marlin_mainCPP-816">      last_command_time = ms;</front>
<front id="Marlin_mainCPP-817">    #endif</front>
<front id="Marlin_mainCPP-818"></front>
<front id="Marlin_mainCPP-819">    serial_char = MYSERIAL.read();</front>
<front id="Marlin_mainCPP-820"></front>
<front id="Marlin_mainCPP-821">    //</front>
<front id="Marlin_mainCPP-822">    // If the character ends the line, or the line is full...</front>
<front id="Marlin_mainCPP-823">    //</front>
<front id="Marlin_mainCPP-824">    if (serial_char == '\n' || serial_char == '\r' || serial_count &gt;= MAX_CMD_SIZE-1) {</front>
<front id="Marlin_mainCPP-825"></front>
<front id="Marlin_mainCPP-826">      // end of line == end of comment</front>
<front id="Marlin_mainCPP-827">      comment_mode = false;</front>
<front id="Marlin_mainCPP-828"></front>
<front id="Marlin_mainCPP-829">      if (!serial_count) return; // empty lines just exit</front>
<front id="Marlin_mainCPP-830"></front>
<front id="Marlin_mainCPP-831">      char *command = command_queue[cmd_queue_index_w];</front>
<front id="Marlin_mainCPP-832">      command[serial_count] = 0; // terminate string</front>
<front id="Marlin_mainCPP-833"></front>
<front id="Marlin_mainCPP-834">      // this item in the queue is not from sd</front>
<front id="Marlin_mainCPP-835">      #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-836">        fromsd[cmd_queue_index_w] = false;</front>
<front id="Marlin_mainCPP-837">      #endif</front>
<front id="Marlin_mainCPP-838"></front>
<front id="Marlin_mainCPP-839">      char *npos = strchr(command, 'N');</front>
<front id="Marlin_mainCPP-840">      char *apos = strchr(command, '*');</front>
<front id="Marlin_mainCPP-841">      if (npos) {</front>
<front id="Marlin_mainCPP-842"></front>
<front id="Marlin_mainCPP-843">        boolean M110 = strstr_P(command, PSTR("M110")) != NULL;</front>
<front id="Marlin_mainCPP-844"></front>
<front id="Marlin_mainCPP-845">        if (M110) {</front>
<front id="Marlin_mainCPP-846">          char *n2pos = strchr(command + 4, 'N');</front>
<front id="Marlin_mainCPP-847">          if (n2pos) npos = n2pos;</front>
<front id="Marlin_mainCPP-848">        }</front>
<front id="Marlin_mainCPP-849"></front>
<front id="Marlin_mainCPP-850">        gcode_N = strtol(npos + 1, NULL, 10);</front>
<front id="Marlin_mainCPP-851"></front>
<front id="Marlin_mainCPP-852">        if (gcode_N != gcode_LastN + 1 && !M110) {</front>
<front id="Marlin_mainCPP-853">          gcode_line_error(PSTR(MSG_ERR_LINE_NO));</front>
<front id="Marlin_mainCPP-854">          return;</front>
<front id="Marlin_mainCPP-855">        }</front>
<front id="Marlin_mainCPP-856"></front>
<front id="Marlin_mainCPP-857">        if (apos) {</front>
<front id="Marlin_mainCPP-858">          byte checksum = 0, count = 0;</front>
<front id="Marlin_mainCPP-859">          while (command[count] != '*') checksum ^= command[count++];</front>
<front id="Marlin_mainCPP-860"></front>
<front id="Marlin_mainCPP-861">          if (strtol(apos + 1, NULL, 10) != checksum) {</front>
<front id="Marlin_mainCPP-862">            gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));</front>
<front id="Marlin_mainCPP-863">            return;</front>
<front id="Marlin_mainCPP-864">          }</front>
<front id="Marlin_mainCPP-865">          // if no errors, continue parsing</front>
<front id="Marlin_mainCPP-866">        }</front>
<front id="Marlin_mainCPP-867">        else if (npos == command) {</front>
<front id="Marlin_mainCPP-868">          gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));</front>
<front id="Marlin_mainCPP-869">          return;</front>
<front id="Marlin_mainCPP-870">        }</front>
<front id="Marlin_mainCPP-871"></front>
<front id="Marlin_mainCPP-872">        gcode_LastN = gcode_N;</front>
<front id="Marlin_mainCPP-873">        // if no errors, continue parsing</front>
<front id="Marlin_mainCPP-874">      }</front>
<front id="Marlin_mainCPP-875">      else if (apos) { // No '*' without 'N'</front>
<front id="Marlin_mainCPP-876">        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);</front>
<front id="Marlin_mainCPP-877">        return;</front>
<front id="Marlin_mainCPP-878">      }</front>
<front id="Marlin_mainCPP-879"></front>
<front id="Marlin_mainCPP-880">      // Movement commands alert when stopped</front>
<front id="Marlin_mainCPP-881">      if (IsStopped()) {</front>
<front id="Marlin_mainCPP-882">        char *gpos = strchr(command, 'G');</front>
<front id="Marlin_mainCPP-883">        if (gpos) {</front>
<front id="Marlin_mainCPP-884">          int codenum = strtol(gpos + 1, NULL, 10);</front>
<front id="Marlin_mainCPP-885">          switch (codenum) {</front>
<front id="Marlin_mainCPP-886">            case 0:</front>
<front id="Marlin_mainCPP-887">            case 1:</front>
<front id="Marlin_mainCPP-888">            case 2:</front>
<front id="Marlin_mainCPP-889">            case 3:</front>
<front id="Marlin_mainCPP-890">              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);</front>
<front id="Marlin_mainCPP-891">              LCD_MESSAGEPGM(MSG_STOPPED);</front>
<front id="Marlin_mainCPP-892">              break;</front>
<front id="Marlin_mainCPP-893">          }</front>
<front id="Marlin_mainCPP-894">        }</front>
<front id="Marlin_mainCPP-895">      }</front>
<front id="Marlin_mainCPP-896"></front>
<front id="Marlin_mainCPP-897">      // If command was e-stop process now</front>
<front id="Marlin_mainCPP-898">      if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));</front>
<front id="Marlin_mainCPP-899"></front>
<front id="Marlin_mainCPP-900">      cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-901">      commands_in_queue += 1;</front>
<front id="Marlin_mainCPP-902"></front>
<front id="Marlin_mainCPP-903">      serial_count = 0; //clear buffer</front>
<front id="Marlin_mainCPP-904">    }</front>
<front id="Marlin_mainCPP-905">    else if (serial_char == '\\') {  // Handle escapes</front>
<front id="Marlin_mainCPP-906">      if (MYSERIAL.available() &gt; 0 && commands_in_queue &lt; BUFSIZE) {</front>
<front id="Marlin_mainCPP-907">        // if we have one more character, copy it over</front>
<front id="Marlin_mainCPP-908">        serial_char = MYSERIAL.read();</front>
<front id="Marlin_mainCPP-909">        command_queue[cmd_queue_index_w][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-910">      }</front>
<front id="Marlin_mainCPP-911">      // otherwise do nothing</front>
<front id="Marlin_mainCPP-912">    }</front>
<front id="Marlin_mainCPP-913">    else { // its not a newline, carriage return or escape char</front>
<front id="Marlin_mainCPP-914">      if (serial_char == ';') comment_mode = true;</front>
<front id="Marlin_mainCPP-915">      if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-916">    }</front>
<front id="Marlin_mainCPP-917">  }</front>
<front id="Marlin_mainCPP-918"></front>
<front id="Marlin_mainCPP-919">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-920"></front>
<front id="Marlin_mainCPP-921">    if (!card.sdprinting || serial_count) return;</front>
<front id="Marlin_mainCPP-922"></front>
<front id="Marlin_mainCPP-923">    // '#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible</front>
<front id="Marlin_mainCPP-924">    // if it occurs, stop_buffering is triggered and the buffer is ran dry.</front>
<front id="Marlin_mainCPP-925">    // this character _can_ occur in serial com, due to checksums. however, no checksums are used in SD printing</front>
<front id="Marlin_mainCPP-926"></front>
<front id="Marlin_mainCPP-927">    static bool stop_buffering = false;</front>
<front id="Marlin_mainCPP-928">    if (commands_in_queue == 0) stop_buffering = false;</front>
<front id="Marlin_mainCPP-929"></front>
<front id="Marlin_mainCPP-930">    while (!card.eof() && commands_in_queue &lt; BUFSIZE && !stop_buffering) {</front>
<front id="Marlin_mainCPP-931">      int16_t n = card.get();</front>
<front id="Marlin_mainCPP-932">      serial_char = (char)n;</front>
<front id="Marlin_mainCPP-933">      if (serial_char == '\n' || serial_char == '\r' ||</front>
<front id="Marlin_mainCPP-934">          ((serial_char == '#' || serial_char == ':') && !comment_mode) ||</front>
<front id="Marlin_mainCPP-935">          serial_count &gt;= (MAX_CMD_SIZE - 1) || n == -1</front>
<front id="Marlin_mainCPP-936">      ) {</front>
<front id="Marlin_mainCPP-937">        if (card.eof()) {</front>
<front id="Marlin_mainCPP-938">          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);</front>
<front id="Marlin_mainCPP-939">          print_job_stop_ms = millis();</front>
<front id="Marlin_mainCPP-940">          char time[30];</front>
<front id="Marlin_mainCPP-941">          millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;</front>
<front id="Marlin_mainCPP-942">          int hours = t / 60 / 60, minutes = (t / 60) % 60;</front>
<front id="Marlin_mainCPP-943">          sprintf_P(time, PSTR("%i " MSG_END_HOUR " %i " MSG_END_MINUTE), hours, minutes);</front>
<front id="Marlin_mainCPP-944">          SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-945">          SERIAL_ECHOLN(time);</front>
<front id="Marlin_mainCPP-946">          lcd_setstatus(time, true);</front>
<front id="Marlin_mainCPP-947">          card.printingHasFinished();</front>
<front id="Marlin_mainCPP-948">          card.checkautostart(true);</front>
<front id="Marlin_mainCPP-949">          #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-950">            planner_disabled_below_z = 0;</front>
<front id="Marlin_mainCPP-951">          #endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-952">        }</front>
<front id="Marlin_mainCPP-953">        if (serial_char == '#') stop_buffering = true;</front>
<front id="Marlin_mainCPP-954"></front>
<front id="Marlin_mainCPP-955">        if (!serial_count) {</front>
<front id="Marlin_mainCPP-956">          comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-957">          return; //if empty line</front>
<front id="Marlin_mainCPP-958">        }</front>
<front id="Marlin_mainCPP-959">        command_queue[cmd_queue_index_w][serial_count] = 0; //terminate string</front>
<front id="Marlin_mainCPP-960">        // if (!comment_mode) {</front>
<front id="Marlin_mainCPP-961">        fromsd[cmd_queue_index_w] = true;</front>
<front id="Marlin_mainCPP-962">        commands_in_queue += 1;</front>
<front id="Marlin_mainCPP-963">        cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-964">        // }</front>
<front id="Marlin_mainCPP-965">        comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-966">        serial_count = 0; //clear buffer</front>
<front id="Marlin_mainCPP-967">      }</front>
<front id="Marlin_mainCPP-968">      else {</front>
<front id="Marlin_mainCPP-969">        if (serial_char == ';') comment_mode = true;</front>
<front id="Marlin_mainCPP-970">        if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-971">      }</front>
<front id="Marlin_mainCPP-972">    }</front>
<front id="Marlin_mainCPP-973"></front>
<front id="Marlin_mainCPP-974">  #endif // SDSUPPORT</front>
<front id="Marlin_mainCPP-975">}</front>
<front id="Marlin_mainCPP-976"></front>
<front id="Marlin_mainCPP-977">bool code_has_value() {</front>
<front id="Marlin_mainCPP-978">  int i = 1;</front>
<front id="Marlin_mainCPP-979">  char c = seen_pointer[i];</front>
<front id="Marlin_mainCPP-980">  if (c == '-' || c == '+') c = seen_pointer[++i];</front>
<front id="Marlin_mainCPP-981">  if (c == '.') c = seen_pointer[++i];</front>
<front id="Marlin_mainCPP-982">  return (c &gt;= '0' && c &lt;= '9');</front>
<front id="Marlin_mainCPP-983">}</front>
<front id="Marlin_mainCPP-984"></front>
<front id="Marlin_mainCPP-985">float code_value() {</front>
<front id="Marlin_mainCPP-986">  float ret;</front>
<front id="Marlin_mainCPP-987">  char *e = strchr(seen_pointer, 'E');</front>
<front id="Marlin_mainCPP-988">  if (e) {</front>
<front id="Marlin_mainCPP-989">    *e = 0;</front>
<front id="Marlin_mainCPP-990">    ret = strtod(seen_pointer+1, NULL);</front>
<front id="Marlin_mainCPP-991">    *e = 'E';</front>
<front id="Marlin_mainCPP-992">  }</front>
<front id="Marlin_mainCPP-993">  else</front>
<front id="Marlin_mainCPP-994">    ret = strtod(seen_pointer+1, NULL);</front>
<front id="Marlin_mainCPP-995">  return ret;</front>
<front id="Marlin_mainCPP-996">}</front>
<front id="Marlin_mainCPP-997"></front>
<front id="Marlin_mainCPP-998">long code_value_long() { return strtol(seen_pointer + 1, NULL, 10); }</front>
<front id="Marlin_mainCPP-999"></front>
<front id="Marlin_mainCPP-1000">int16_t code_value_short() { return (int16_t)strtol(seen_pointer + 1, NULL, 10); }</front>
<front id="Marlin_mainCPP-1001"></front>
<front id="Marlin_mainCPP-1002">bool code_seen(char code) {</front>
<front id="Marlin_mainCPP-1003">  seen_pointer = strchr(current_command_args, code);</front>
<front id="Marlin_mainCPP-1004">  return (seen_pointer != NULL); // Return TRUE if the code-letter was found</front>
<front id="Marlin_mainCPP-1005">}</front>
<front id="Marlin_mainCPP-1006"></front>
<front id="Marlin_mainCPP-1007">#define DEFINE_PGM_READ_ANY(type, reader)       \</front>
<front id="Marlin_mainCPP-1008">    static inline type pgm_read_any(const type *p)  \</front>
<front id="Marlin_mainCPP-1009">    { return pgm_read_##reader##_near(p); }</front>
<front id="Marlin_mainCPP-1010"></front>
<front id="Marlin_mainCPP-1011">DEFINE_PGM_READ_ANY(float,       float);</front>
<front id="Marlin_mainCPP-1012">DEFINE_PGM_READ_ANY(signed char, byte);</front>
<front id="Marlin_mainCPP-1013"></front>
<front id="Marlin_mainCPP-1014">#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \</front>
<front id="Marlin_mainCPP-1015">static const PROGMEM type array##_P[3] =        \</front>
<front id="Marlin_mainCPP-1016">    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \</front>
<front id="Marlin_mainCPP-1017">static inline type array(int axis)          \</front>
<front id="Marlin_mainCPP-1018">    { return pgm_read_any(&array##_P[axis]); }</front>
<front id="Marlin_mainCPP-1019"></front>
<front id="Marlin_mainCPP-1020">XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);</front>
<front id="Marlin_mainCPP-1021">XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);</front>
<front id="Marlin_mainCPP-1022">XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);</front>
<front id="Marlin_mainCPP-1023">XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);</front>
<front id="Marlin_mainCPP-1024">XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);</front>
<front id="Marlin_mainCPP-1025">XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);</front>
<front id="Marlin_mainCPP-1026"></front>
<front id="Marlin_mainCPP-1027">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-1028"></front>
<front id="Marlin_mainCPP-1029">  #define DXC_FULL_CONTROL_MODE 0</front>
<front id="Marlin_mainCPP-1030">  #define DXC_AUTO_PARK_MODE    1</front>
<front id="Marlin_mainCPP-1031">  #define DXC_DUPLICATION_MODE  2</front>
<front id="Marlin_mainCPP-1032"></front>
<front id="Marlin_mainCPP-1033">  static int dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;</front>
<front id="Marlin_mainCPP-1034"></front>
<front id="Marlin_mainCPP-1035">  static float x_home_pos(int extruder) {</front>
<front id="Marlin_mainCPP-1036">    if (extruder == 0)</front>
<front id="Marlin_mainCPP-1037">      return base_home_pos(X_AXIS) + home_offset[X_AXIS];</front>
<front id="Marlin_mainCPP-1038">    else</front>
<front id="Marlin_mainCPP-1039">      // In dual carriage mode the extruder offset provides an override of the</front>
<front id="Marlin_mainCPP-1040">      // second X-carriage offset when homed - otherwise X2_HOME_POS is used.</front>
<front id="Marlin_mainCPP-1041">      // This allow soft recalibration of the second extruder offset position without firmware reflash</front>
<front id="Marlin_mainCPP-1042">      // (through the M218 command).</front>
<front id="Marlin_mainCPP-1043">      return (extruder_offset[X_AXIS][1] &gt; 0) ? extruder_offset[X_AXIS][1] : X2_HOME_POS;</front>
<front id="Marlin_mainCPP-1044">  }</front>
<front id="Marlin_mainCPP-1045"></front>
<front id="Marlin_mainCPP-1046">  static int x_home_dir(int extruder) {</front>
<front id="Marlin_mainCPP-1047">    return (extruder == 0) ? X_HOME_DIR : X2_HOME_DIR;</front>
<front id="Marlin_mainCPP-1048">  }</front>
<front id="Marlin_mainCPP-1049"></front>
<front id="Marlin_mainCPP-1050">  static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1</front>
<front id="Marlin_mainCPP-1051">  static bool active_extruder_parked = false; // used in mode 1 & 2</front>
<front id="Marlin_mainCPP-1052">  static float raised_parked_position[NUM_AXIS]; // used in mode 1</front>
<front id="Marlin_mainCPP-1053">  static millis_t delayed_move_time = 0; // used in mode 1</front>
<front id="Marlin_mainCPP-1054">  static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2</front>
<front id="Marlin_mainCPP-1055">  static float duplicate_extruder_temp_offset = 0; // used in mode 2</front>
<front id="Marlin_mainCPP-1056">  bool extruder_duplication_enabled = false; // used in mode 2</front>
<front id="Marlin_mainCPP-1057"></front>
<front id="Marlin_mainCPP-1058">#endif //DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1059"></front>
<front id="Marlin_mainCPP-1060">#if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1061">  void print_xyz(const char *prefix, const float x, const float y, const float z) {</front>
<front id="Marlin_mainCPP-1062">    SERIAL_ECHO(prefix);</front>
<front id="Marlin_mainCPP-1063">    SERIAL_ECHOPAIR(": (", x);</front>
<front id="Marlin_mainCPP-1064">    SERIAL_ECHOPAIR(", ", y);</front>
<front id="Marlin_mainCPP-1065">    SERIAL_ECHOPAIR(", ", z);</front>
<front id="Marlin_mainCPP-1066">    SERIAL_ECHOLNPGM(")");</front>
<front id="Marlin_mainCPP-1067">  }</front>
<front id="Marlin_mainCPP-1068">  void print_xyz(const char *prefix, const float xyz[]) {</front>
<front id="Marlin_mainCPP-1069">    print_xyz(prefix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1070">  }</front>
<front id="Marlin_mainCPP-1071">#endif</front>
<front id="Marlin_mainCPP-1072"></front>
<front id="Marlin_mainCPP-1073">static void set_axis_is_at_home(AxisEnum axis) {</front>
<front id="Marlin_mainCPP-1074"></front>
<front id="Marlin_mainCPP-1075">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-1076">    if (axis == X_AXIS) {</front>
<front id="Marlin_mainCPP-1077">      if (active_extruder != 0) {</front>
<front id="Marlin_mainCPP-1078">        current_position[X_AXIS] = x_home_pos(active_extruder);</front>
<front id="Marlin_mainCPP-1079">                 min_pos[X_AXIS] = X2_MIN_POS;</front>
<front id="Marlin_mainCPP-1080">                 max_pos[X_AXIS] = max(extruder_offset[X_AXIS][1], X2_MAX_POS);</front>
<front id="Marlin_mainCPP-1081">        return;</front>
<front id="Marlin_mainCPP-1082">      }</front>
<front id="Marlin_mainCPP-1083">      else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {</front>
<front id="Marlin_mainCPP-1084">        float xoff = home_offset[X_AXIS];</front>
<front id="Marlin_mainCPP-1085">        current_position[X_AXIS] = base_home_pos(X_AXIS) + xoff;</front>
<front id="Marlin_mainCPP-1086">                 min_pos[X_AXIS] = base_min_pos(X_AXIS) + xoff;</front>
<front id="Marlin_mainCPP-1087">                 max_pos[X_AXIS] = min(base_max_pos(X_AXIS) + xoff, max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);</front>
<front id="Marlin_mainCPP-1088">        return;</front>
<front id="Marlin_mainCPP-1089">      }</front>
<front id="Marlin_mainCPP-1090">    }</front>
<front id="Marlin_mainCPP-1091">  #endif</front>
<front id="Marlin_mainCPP-1092"></front>
<front id="Marlin_mainCPP-1093">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-1094"></front>
<front id="Marlin_mainCPP-1095">    if (axis == X_AXIS || axis == Y_AXIS) {</front>
<front id="Marlin_mainCPP-1096"></front>
<front id="Marlin_mainCPP-1097">      float homeposition[3];</front>
<front id="Marlin_mainCPP-1098">      for (int i = 0; i &lt; 3; i++) homeposition[i] = base_home_pos(i);</front>
<front id="Marlin_mainCPP-1099"></front>
<front id="Marlin_mainCPP-1100">      // SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);</front>
<front id="Marlin_mainCPP-1101">      // SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);</front>
<front id="Marlin_mainCPP-1102">      // Works out real Homeposition angles using inverse kinematics,</front>
<front id="Marlin_mainCPP-1103">      // and calculates homing offset using forward kinematics</front>
<front id="Marlin_mainCPP-1104">      calculate_delta(homeposition);</front>
<front id="Marlin_mainCPP-1105"></front>
<front id="Marlin_mainCPP-1106">      // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-1107">      // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1108"></front>
<front id="Marlin_mainCPP-1109">      for (int i = 0; i &lt; 2; i++) delta[i] -= home_offset[i];</front>
<front id="Marlin_mainCPP-1110"></front>
<front id="Marlin_mainCPP-1111">      // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(home_offset[X_AXIS]);</front>
<front id="Marlin_mainCPP-1112">      // SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(home_offset[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1113">      // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-1114">      // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1115"></front>
<front id="Marlin_mainCPP-1116">      calculate_SCARA_forward_Transform(delta);</front>
<front id="Marlin_mainCPP-1117"></front>
<front id="Marlin_mainCPP-1118">      // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-1119">      // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1120"></front>
<front id="Marlin_mainCPP-1121">      current_position[axis] = delta[axis];</front>
<front id="Marlin_mainCPP-1122"></front>
<front id="Marlin_mainCPP-1123">      // SCARA home positions are based on configuration since the actual limits are determined by the</front>
<front id="Marlin_mainCPP-1124">      // inverse kinematic transform.</front>
<front id="Marlin_mainCPP-1125">      min_pos[axis] = base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));</front>
<front id="Marlin_mainCPP-1126">      max_pos[axis] = base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));</front>
<front id="Marlin_mainCPP-1127">    }</front>
<front id="Marlin_mainCPP-1128">    else</front>
<front id="Marlin_mainCPP-1129">  #endif</front>
<front id="Marlin_mainCPP-1130">  {</front>
<front id="Marlin_mainCPP-1131">    current_position[axis] = base_home_pos(axis) + home_offset[axis];</front>
<front id="Marlin_mainCPP-1132">    min_pos[axis] = base_min_pos(axis) + home_offset[axis];</front>
<front id="Marlin_mainCPP-1133">    max_pos[axis] = base_max_pos(axis) + home_offset[axis];</front>
<front id="Marlin_mainCPP-1134"></front>
<front id="Marlin_mainCPP-1135">    #if ENABLED(AUTO_BED_LEVELING_FEATURE) && Z_HOME_DIR &lt; 0</front>
<front id="Marlin_mainCPP-1136">      if (axis == Z_AXIS) current_position[Z_AXIS] -= zprobe_zoffset;</front>
<front id="Marlin_mainCPP-1137">    #endif</front>
<front id="Marlin_mainCPP-1138"></front>
<front id="Marlin_mainCPP-1139">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1140">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1141">        SERIAL_ECHOPAIR("set_axis_is_at_home ", (unsigned long)axis);</front>
<front id="Marlin_mainCPP-1142">        SERIAL_ECHOPAIR(" &gt; (home_offset[axis]==", home_offset[axis]);</front>
<front id="Marlin_mainCPP-1143">        print_xyz(") &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1144">      }</front>
<front id="Marlin_mainCPP-1145">    #endif</front>
<front id="Marlin_mainCPP-1146">  }</front>
<front id="Marlin_mainCPP-1147">}</front>
<front id="Marlin_mainCPP-1148"></front>
<front id="Marlin_mainCPP-1149">/**</front>
<front id="Marlin_mainCPP-1150"> * Some planner shorthand inline functions</front>
<front id="Marlin_mainCPP-1151"> */</front>
<front id="Marlin_mainCPP-1152">inline void set_homing_bump_feedrate(AxisEnum axis) {</front>
<front id="Marlin_mainCPP-1153">  const int homing_bump_divisor[] = HOMING_BUMP_DIVISOR;</front>
<front id="Marlin_mainCPP-1154">  int hbd = homing_bump_divisor[axis];</front>
<front id="Marlin_mainCPP-1155">  if (hbd &lt; 1) {</front>
<front id="Marlin_mainCPP-1156">    hbd = 10;</front>
<front id="Marlin_mainCPP-1157">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-1158">    SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor &lt; 1");</front>
<front id="Marlin_mainCPP-1159">  }</front>
<front id="Marlin_mainCPP-1160">  feedrate = homing_feedrate[axis] / hbd;</front>
<front id="Marlin_mainCPP-1161">}</front>
<front id="Marlin_mainCPP-1162">inline void line_to_current_position() {</front>
<front id="Marlin_mainCPP-1163">  plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1164">}</front>
<front id="Marlin_mainCPP-1165">inline void line_to_z(float zPosition) {</front>
<front id="Marlin_mainCPP-1166">  plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1167">}</front>
<front id="Marlin_mainCPP-1168">inline void line_to_destination(float mm_m) {</front>
<front id="Marlin_mainCPP-1169">  plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], mm_m/60, active_extruder);</front>
<front id="Marlin_mainCPP-1170">}</front>
<front id="Marlin_mainCPP-1171">inline void line_to_destination() {</front>
<front id="Marlin_mainCPP-1172">  line_to_destination(feedrate);</front>
<front id="Marlin_mainCPP-1173">}</front>
<front id="Marlin_mainCPP-1174">inline void sync_plan_position() {</front>
<front id="Marlin_mainCPP-1175">  plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1176">}</front>
<front id="Marlin_mainCPP-1177">#if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-1178">  inline void sync_plan_position_delta() {</front>
<front id="Marlin_mainCPP-1179">    calculate_delta(current_position);</front>
<front id="Marlin_mainCPP-1180">    plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1181">  }</front>
<front id="Marlin_mainCPP-1182">#endif</front>
<front id="Marlin_mainCPP-1183">inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }</front>
<front id="Marlin_mainCPP-1184">inline void set_destination_to_current() { memcpy(destination, current_position, sizeof(destination)); }</front>
<front id="Marlin_mainCPP-1185"></front>
<front id="Marlin_mainCPP-1186">static void setup_for_endstop_move() {</front>
<front id="Marlin_mainCPP-1187">  saved_feedrate = feedrate;</front>
<front id="Marlin_mainCPP-1188">  saved_feedrate_multiplier = feedrate_multiplier;</front>
<front id="Marlin_mainCPP-1189">  feedrate_multiplier = 100;</front>
<front id="Marlin_mainCPP-1190">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-1191">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1192">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1193">      SERIAL_ECHOLNPGM("setup_for_endstop_move &gt; enable_endstops(true)");</front>
<front id="Marlin_mainCPP-1194">    }</front>
<front id="Marlin_mainCPP-1195">  #endif</front>
<front id="Marlin_mainCPP-1196">  enable_endstops(true);</front>
<front id="Marlin_mainCPP-1197">}</front>
<front id="Marlin_mainCPP-1198"></front>
<front id="Marlin_mainCPP-1199">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1200"></front>
<front id="Marlin_mainCPP-1201">  #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1202">    /**</front>
<front id="Marlin_mainCPP-1203">     * Calculate delta, start a line, and set current_position to destination</front>
<front id="Marlin_mainCPP-1204">     */</front>
<front id="Marlin_mainCPP-1205">    void prepare_move_raw() {</front>
<front id="Marlin_mainCPP-1206">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1207">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1208">          print_xyz("prepare_move_raw &gt; destination", destination);</front>
<front id="Marlin_mainCPP-1209">        }</front>
<front id="Marlin_mainCPP-1210">      #endif</front>
<front id="Marlin_mainCPP-1211">      refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-1212">      calculate_delta(destination);</front>
<front id="Marlin_mainCPP-1213">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], (feedrate/60)*(feedrate_multiplier/100.0), active_extruder);</front>
<front id="Marlin_mainCPP-1214">      set_current_to_destination();</front>
<front id="Marlin_mainCPP-1215">    }</front>
<front id="Marlin_mainCPP-1216">  #endif</front>
<front id="Marlin_mainCPP-1217"></front>
<front id="Marlin_mainCPP-1218">  #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-1219"></front>
<front id="Marlin_mainCPP-1220">    #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-1221"></front>
<front id="Marlin_mainCPP-1222">      static void set_bed_level_equation_lsq(double *plane_equation_coefficients) {</front>
<front id="Marlin_mainCPP-1223">        vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);</front>
<front id="Marlin_mainCPP-1224">        planeNormal.debug("planeNormal");</front>
<front id="Marlin_mainCPP-1225">        plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);</front>
<front id="Marlin_mainCPP-1226">        //bedLevel.debug("bedLevel");</front>
<front id="Marlin_mainCPP-1227"></front>
<front id="Marlin_mainCPP-1228">        //plan_bed_level_matrix.debug("bed level before");</front>
<front id="Marlin_mainCPP-1229">        //vector_3 uncorrected_position = plan_get_position_mm();</front>
<front id="Marlin_mainCPP-1230">        //uncorrected_position.debug("position before");</front>
<front id="Marlin_mainCPP-1231"></front>
<front id="Marlin_mainCPP-1232">        vector_3 corrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-1233">        //corrected_position.debug("position after");</front>
<front id="Marlin_mainCPP-1234">        current_position[X_AXIS] = corrected_position.x;</front>
<front id="Marlin_mainCPP-1235">        current_position[Y_AXIS] = corrected_position.y;</front>
<front id="Marlin_mainCPP-1236">        current_position[Z_AXIS] = corrected_position.z;</front>
<front id="Marlin_mainCPP-1237"></front>
<front id="Marlin_mainCPP-1238">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1239">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1240">            print_xyz("set_bed_level_equation_lsq &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1241">          }</front>
<front id="Marlin_mainCPP-1242">        #endif</front>
<front id="Marlin_mainCPP-1243"></front>
<front id="Marlin_mainCPP-1244">        sync_plan_position();</front>
<front id="Marlin_mainCPP-1245">      }</front>
<front id="Marlin_mainCPP-1246"></front>
<front id="Marlin_mainCPP-1247">    #endif // !DELTA</front>
<front id="Marlin_mainCPP-1248"></front>
<front id="Marlin_mainCPP-1249">  #else // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-1250"></front>
<front id="Marlin_mainCPP-1251">    static void set_bed_level_equation_3pts(float z_at_pt_1, float z_at_pt_2, float z_at_pt_3) {</front>
<front id="Marlin_mainCPP-1252"></front>
<front id="Marlin_mainCPP-1253">      plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-1254"></front>
<front id="Marlin_mainCPP-1255">      vector_3 pt1 = vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, z_at_pt_1);</front>
<front id="Marlin_mainCPP-1256">      vector_3 pt2 = vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, z_at_pt_2);</front>
<front id="Marlin_mainCPP-1257">      vector_3 pt3 = vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, z_at_pt_3);</front>
<front id="Marlin_mainCPP-1258">      vector_3 planeNormal = vector_3::cross(pt1 - pt2, pt3 - pt2).get_normal();</front>
<front id="Marlin_mainCPP-1259"></front>
<front id="Marlin_mainCPP-1260">      if (planeNormal.z &lt; 0) {</front>
<front id="Marlin_mainCPP-1261">        planeNormal.x = -planeNormal.x;</front>
<front id="Marlin_mainCPP-1262">        planeNormal.y = -planeNormal.y;</front>
<front id="Marlin_mainCPP-1263">        planeNormal.z = -planeNormal.z;</front>
<front id="Marlin_mainCPP-1264">      }</front>
<front id="Marlin_mainCPP-1265"></front>
<front id="Marlin_mainCPP-1266">      plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);</front>
<front id="Marlin_mainCPP-1267"></front>
<front id="Marlin_mainCPP-1268">      vector_3 corrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-1269">      current_position[X_AXIS] = corrected_position.x;</front>
<front id="Marlin_mainCPP-1270">      current_position[Y_AXIS] = corrected_position.y;</front>
<front id="Marlin_mainCPP-1271">      current_position[Z_AXIS] = corrected_position.z;</front>
<front id="Marlin_mainCPP-1272"></front>
<front id="Marlin_mainCPP-1273">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1274">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1275">          print_xyz("set_bed_level_equation_3pts &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1276">        }</front>
<front id="Marlin_mainCPP-1277">      #endif</front>
<front id="Marlin_mainCPP-1278"></front>
<front id="Marlin_mainCPP-1279">      sync_plan_position();</front>
<front id="Marlin_mainCPP-1280">    }</front>
<front id="Marlin_mainCPP-1281"></front>
<front id="Marlin_mainCPP-1282">  #endif // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-1283"></front>
<front id="Marlin_mainCPP-1284">  static void run_z_probe() {</front>
<front id="Marlin_mainCPP-1285"></front>
<front id="Marlin_mainCPP-1286">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1287"></front>
<front id="Marlin_mainCPP-1288">      float start_z = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1289">      long start_steps = st_get_position(Z_AXIS);</front>
<front id="Marlin_mainCPP-1290"></front>
<front id="Marlin_mainCPP-1291">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1292">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1293">          SERIAL_ECHOLNPGM("run_z_probe (DELTA) 1");</front>
<front id="Marlin_mainCPP-1294">        }</front>
<front id="Marlin_mainCPP-1295">      #endif</front>
<front id="Marlin_mainCPP-1296"></front>
<front id="Marlin_mainCPP-1297">      // move down slowly until you find the bed</front>
<front id="Marlin_mainCPP-1298">      feedrate = homing_feedrate[Z_AXIS] / 4;</front>
<front id="Marlin_mainCPP-1299">      destination[Z_AXIS] = -10;</front>
<front id="Marlin_mainCPP-1300">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1301">      st_synchronize();</front>
<front id="Marlin_mainCPP-1302">      endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-1303"></front>
<front id="Marlin_mainCPP-1304">      // we have to let the planner know where we are right now as it is not where we said to go.</front>
<front id="Marlin_mainCPP-1305">      long stop_steps = st_get_position(Z_AXIS);</front>
<front id="Marlin_mainCPP-1306">      float mm = start_z - float(start_steps - stop_steps) / axis_steps_per_unit[Z_AXIS];</front>
<front id="Marlin_mainCPP-1307">      current_position[Z_AXIS] = mm;</front>
<front id="Marlin_mainCPP-1308"></front>
<front id="Marlin_mainCPP-1309">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1310">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1311">          print_xyz("run_z_probe (DELTA) 2 &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1312">        }</front>
<front id="Marlin_mainCPP-1313">      #endif</front>
<front id="Marlin_mainCPP-1314"></front>
<front id="Marlin_mainCPP-1315">      sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-1316"></front>
<front id="Marlin_mainCPP-1317">    #else // !DELTA</front>
<front id="Marlin_mainCPP-1318"></front>
<front id="Marlin_mainCPP-1319">      plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-1320">      feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-1321"></front>
<front id="Marlin_mainCPP-1322">      // Move down until the Z probe (or endstop?) is triggered</front>
<front id="Marlin_mainCPP-1323">      float zPosition = -(Z_MAX_LENGTH + 10);</front>
<front id="Marlin_mainCPP-1324">      line_to_z(zPosition);</front>
<front id="Marlin_mainCPP-1325">      st_synchronize();</front>
<front id="Marlin_mainCPP-1326"></front>
<front id="Marlin_mainCPP-1327">      // Tell the planner where we ended up - Get this from the stepper handler</front>
<front id="Marlin_mainCPP-1328">      zPosition = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-1329">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1330"></front>
<front id="Marlin_mainCPP-1331">      // move up the retract distance</front>
<front id="Marlin_mainCPP-1332">      zPosition += home_bump_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-1333">      line_to_z(zPosition);</front>
<front id="Marlin_mainCPP-1334">      st_synchronize();</front>
<front id="Marlin_mainCPP-1335">      endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-1336"></front>
<front id="Marlin_mainCPP-1337">      // move back down slowly to find bed</front>
<front id="Marlin_mainCPP-1338">      set_homing_bump_feedrate(Z_AXIS);</front>
<front id="Marlin_mainCPP-1339"></front>
<front id="Marlin_mainCPP-1340">      zPosition -= home_bump_mm(Z_AXIS) * 2;</front>
<front id="Marlin_mainCPP-1341">      line_to_z(zPosition);</front>
<front id="Marlin_mainCPP-1342">      st_synchronize();</front>
<front id="Marlin_mainCPP-1343">      endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-1344"></front>
<front id="Marlin_mainCPP-1345">      // Get the current stepper position after bumping an endstop</front>
<front id="Marlin_mainCPP-1346">      current_position[Z_AXIS] = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-1347">      sync_plan_position();</front>
<front id="Marlin_mainCPP-1348"></front>
<front id="Marlin_mainCPP-1349">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1350">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1351">          print_xyz("run_z_probe &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1352">        }</front>
<front id="Marlin_mainCPP-1353">      #endif</front>
<front id="Marlin_mainCPP-1354"></front>
<front id="Marlin_mainCPP-1355">    #endif // !DELTA</front>
<front id="Marlin_mainCPP-1356">  }</front>
<front id="Marlin_mainCPP-1357"></front>
<front id="Marlin_mainCPP-1358">  /**</front>
<front id="Marlin_mainCPP-1359">   *  Plan a move to (X, Y, Z) and set the current_position</front>
<front id="Marlin_mainCPP-1360">   *  The final current_position may not be the one that was requested</front>
<front id="Marlin_mainCPP-1361">   */</front>
<front id="Marlin_mainCPP-1362">  static void do_blocking_move_to(float x, float y, float z) {</front>
<front id="Marlin_mainCPP-1363">    float oldFeedRate = feedrate;</front>
<front id="Marlin_mainCPP-1364"></front>
<front id="Marlin_mainCPP-1365">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1366">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1367">        print_xyz("do_blocking_move_to", x, y, z);</front>
<front id="Marlin_mainCPP-1368">      }</front>
<front id="Marlin_mainCPP-1369">    #endif</front>
<front id="Marlin_mainCPP-1370"></front>
<front id="Marlin_mainCPP-1371">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1372"></front>
<front id="Marlin_mainCPP-1373">      feedrate = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-1374"></front>
<front id="Marlin_mainCPP-1375">      destination[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-1376">      destination[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-1377">      destination[Z_AXIS] = z;</front>
<front id="Marlin_mainCPP-1378">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1379">      st_synchronize();</front>
<front id="Marlin_mainCPP-1380"></front>
<front id="Marlin_mainCPP-1381">    #else</front>
<front id="Marlin_mainCPP-1382"></front>
<front id="Marlin_mainCPP-1383">      feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-1384"></front>
<front id="Marlin_mainCPP-1385">      current_position[Z_AXIS] = z;</front>
<front id="Marlin_mainCPP-1386">      line_to_current_position();</front>
<front id="Marlin_mainCPP-1387">      st_synchronize();</front>
<front id="Marlin_mainCPP-1388"></front>
<front id="Marlin_mainCPP-1389">      feedrate = xy_travel_speed;</front>
<front id="Marlin_mainCPP-1390"></front>
<front id="Marlin_mainCPP-1391">      current_position[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-1392">      current_position[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-1393">      line_to_current_position();</front>
<front id="Marlin_mainCPP-1394">      st_synchronize();</front>
<front id="Marlin_mainCPP-1395"></front>
<front id="Marlin_mainCPP-1396">    #endif</front>
<front id="Marlin_mainCPP-1397"></front>
<front id="Marlin_mainCPP-1398">    feedrate = oldFeedRate;</front>
<front id="Marlin_mainCPP-1399">  }</front>
<front id="Marlin_mainCPP-1400"></front>
<front id="Marlin_mainCPP-1401">  inline void do_blocking_move_to_xy(float x, float y) { do_blocking_move_to(x, y, current_position[Z_AXIS]); }</front>
<front id="Marlin_mainCPP-1402">  inline void do_blocking_move_to_x(float x) { do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS]); }</front>
<front id="Marlin_mainCPP-1403">  inline void do_blocking_move_to_z(float z) { do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z); }</front>
<front id="Marlin_mainCPP-1404">  inline void raise_z_after_probing() { do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING); }</front>
<front id="Marlin_mainCPP-1405"></front>
<front id="Marlin_mainCPP-1406">  static void clean_up_after_endstop_move() {</front>
<front id="Marlin_mainCPP-1407">    #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)</front>
<front id="Marlin_mainCPP-1408">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1409">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1410">          SERIAL_ECHOLNPGM("clean_up_after_endstop_move &gt; ENDSTOPS_ONLY_FOR_HOMING &gt; enable_endstops(false)");</front>
<front id="Marlin_mainCPP-1411">        }</front>
<front id="Marlin_mainCPP-1412">      #endif</front>
<front id="Marlin_mainCPP-1413">      enable_endstops(false);</front>
<front id="Marlin_mainCPP-1414">    #endif</front>
<front id="Marlin_mainCPP-1415">    feedrate = saved_feedrate;</front>
<front id="Marlin_mainCPP-1416">    feedrate_multiplier = saved_feedrate_multiplier;</front>
<front id="Marlin_mainCPP-1417">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-1418">  }</front>
<front id="Marlin_mainCPP-1419"></front>
<front id="Marlin_mainCPP-1420">  static void deploy_z_probe() {</front>
<front id="Marlin_mainCPP-1421"></front>
<front id="Marlin_mainCPP-1422">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1423">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1424">        print_xyz("deploy_z_probe &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1425">      }</front>
<front id="Marlin_mainCPP-1426">    #endif</front>
<front id="Marlin_mainCPP-1427"></front>
<front id="Marlin_mainCPP-1428">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-1429"></front>
<front id="Marlin_mainCPP-1430">      // Engage Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-1431">      if (servo_endstop_id[Z_AXIS] &gt;= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);</front>
<front id="Marlin_mainCPP-1432"></front>
<front id="Marlin_mainCPP-1433">    #elif ENABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1434">      feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE;</front>
<front id="Marlin_mainCPP-1435"></front>
<front id="Marlin_mainCPP-1436">      // If endstop is already false, the Z probe is deployed</front>
<front id="Marlin_mainCPP-1437">      #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-1438">        bool z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1439">        if (z_probe_endstop)</front>
<front id="Marlin_mainCPP-1440">      #else</front>
<front id="Marlin_mainCPP-1441">        bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1442">        if (z_min_endstop)</front>
<front id="Marlin_mainCPP-1443">      #endif</front>
<front id="Marlin_mainCPP-1444">        {</front>
<front id="Marlin_mainCPP-1445"></front>
<front id="Marlin_mainCPP-1446">          // Move to the start position to initiate deployment</front>
<front id="Marlin_mainCPP-1447">          destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_X;</front>
<front id="Marlin_mainCPP-1448">          destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Y;</front>
<front id="Marlin_mainCPP-1449">          destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Z;</front>
<front id="Marlin_mainCPP-1450">          prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1451"></front>
<front id="Marlin_mainCPP-1452">          // Move to engage deployment</front>
<front id="Marlin_mainCPP-1453">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1454">            feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE;</front>
<front id="Marlin_mainCPP-1455">          }</front>
<front id="Marlin_mainCPP-1456">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_X != Z_PROBE_ALLEN_KEY_DEPLOY_1_X) {</front>
<front id="Marlin_mainCPP-1457">            destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_X;</front>
<front id="Marlin_mainCPP-1458">          }</front>
<front id="Marlin_mainCPP-1459">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Y != Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) {</front>
<front id="Marlin_mainCPP-1460">            destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Y;</front>
<front id="Marlin_mainCPP-1461">          }</front>
<front id="Marlin_mainCPP-1462">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Z != Z_PROBE_ALLEN_KEY_DEPLOY_1_Z) {</front>
<front id="Marlin_mainCPP-1463">            destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Z;</front>
<front id="Marlin_mainCPP-1464">          }</front>
<front id="Marlin_mainCPP-1465">          prepare_move_raw();</front>
<front id="Marlin_mainCPP-1466"></front>
<front id="Marlin_mainCPP-1467">          #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3_X</front>
<front id="Marlin_mainCPP-1468">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1469">              feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;</front>
<front id="Marlin_mainCPP-1470">            }</front>
<front id="Marlin_mainCPP-1471"></front>
<front id="Marlin_mainCPP-1472">            // Move to trigger deployment</front>
<front id="Marlin_mainCPP-1473">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1474">              feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;</front>
<front id="Marlin_mainCPP-1475">            }</front>
<front id="Marlin_mainCPP-1476">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_X != Z_PROBE_ALLEN_KEY_DEPLOY_2_X) {</front>
<front id="Marlin_mainCPP-1477">              destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_X;</front>
<front id="Marlin_mainCPP-1478">            }</front>
<front id="Marlin_mainCPP-1479">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Y != Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) {</front>
<front id="Marlin_mainCPP-1480">              destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Y;</front>
<front id="Marlin_mainCPP-1481">            }</front>
<front id="Marlin_mainCPP-1482">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Z != Z_PROBE_ALLEN_KEY_DEPLOY_2_Z) {</front>
<front id="Marlin_mainCPP-1483">              destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Z;</front>
<front id="Marlin_mainCPP-1484">            }</front>
<front id="Marlin_mainCPP-1485">            prepare_move_raw();</front>
<front id="Marlin_mainCPP-1486">          #endif</front>
<front id="Marlin_mainCPP-1487">      }</front>
<front id="Marlin_mainCPP-1488"></front>
<front id="Marlin_mainCPP-1489">      // Partially Home X,Y for safety</front>
<front id="Marlin_mainCPP-1490">      destination[X_AXIS] = destination[X_AXIS]*0.75;</front>
<front id="Marlin_mainCPP-1491">      destination[Y_AXIS] = destination[Y_AXIS]*0.75;</front>
<front id="Marlin_mainCPP-1492">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1493"></front>
<front id="Marlin_mainCPP-1494">      st_synchronize();</front>
<front id="Marlin_mainCPP-1495"></front>
<front id="Marlin_mainCPP-1496">      #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-1497">        z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1498">        if (z_probe_endstop)</front>
<front id="Marlin_mainCPP-1499">      #else</front>
<front id="Marlin_mainCPP-1500">        z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1501">        if (z_min_endstop)</front>
<front id="Marlin_mainCPP-1502">      #endif</front>
<front id="Marlin_mainCPP-1503">        {</front>
<front id="Marlin_mainCPP-1504">          if (IsRunning()) {</front>
<front id="Marlin_mainCPP-1505">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-1506">            SERIAL_ERRORLNPGM("Z-Probe failed to engage!");</front>
<front id="Marlin_mainCPP-1507">            LCD_ALERTMESSAGEPGM("Err: ZPROBE");</front>
<front id="Marlin_mainCPP-1508">          }</front>
<front id="Marlin_mainCPP-1509">          Stop();</front>
<front id="Marlin_mainCPP-1510">        }</front>
<front id="Marlin_mainCPP-1511"></front>
<front id="Marlin_mainCPP-1512">    #endif // Z_PROBE_ALLEN_KEY</front>
<front id="Marlin_mainCPP-1513"></front>
<front id="Marlin_mainCPP-1514">  }</front>
<front id="Marlin_mainCPP-1515"></front>
<front id="Marlin_mainCPP-1516">  static void stow_z_probe(bool doRaise=true) {</front>
<front id="Marlin_mainCPP-1517"></front>
<front id="Marlin_mainCPP-1518">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1519">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1520">        print_xyz("stow_z_probe &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1521">      }</front>
<front id="Marlin_mainCPP-1522">    #endif</front>
<front id="Marlin_mainCPP-1523"></front>
<front id="Marlin_mainCPP-1524">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-1525"></front>
<front id="Marlin_mainCPP-1526">      // Retract Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-1527">      if (servo_endstop_id[Z_AXIS] &gt;= 0) {</front>
<front id="Marlin_mainCPP-1528"></front>
<front id="Marlin_mainCPP-1529">        #if Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-1530">          if (doRaise) {</front>
<front id="Marlin_mainCPP-1531">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1532">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1533">                SERIAL_ECHOPAIR("Raise Z (after) by ", (float)Z_RAISE_AFTER_PROBING);</front>
<front id="Marlin_mainCPP-1534">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1535">                SERIAL_ECHOPAIR("&gt; SERVO_ENDSTOPS &gt; raise_z_after_probing()");</front>
<front id="Marlin_mainCPP-1536">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1537">              }</front>
<front id="Marlin_mainCPP-1538">            #endif</front>
<front id="Marlin_mainCPP-1539">            raise_z_after_probing(); // this also updates current_position</front>
<front id="Marlin_mainCPP-1540">            st_synchronize();</front>
<front id="Marlin_mainCPP-1541">          }</front>
<front id="Marlin_mainCPP-1542">        #endif</front>
<front id="Marlin_mainCPP-1543"></front>
<front id="Marlin_mainCPP-1544">        // Change the Z servo angle</front>
<front id="Marlin_mainCPP-1545">        servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][1]);</front>
<front id="Marlin_mainCPP-1546">      }</front>
<front id="Marlin_mainCPP-1547"></front>
<front id="Marlin_mainCPP-1548">    #elif ENABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1549"></front>
<front id="Marlin_mainCPP-1550">      // Move up for safety</front>
<front id="Marlin_mainCPP-1551">      feedrate = Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE;</front>
<front id="Marlin_mainCPP-1552"></front>
<front id="Marlin_mainCPP-1553">      #if Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-1554">        destination[Z_AXIS] = current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING;</front>
<front id="Marlin_mainCPP-1555">        prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1556">      #endif</front>
<front id="Marlin_mainCPP-1557"></front>
<front id="Marlin_mainCPP-1558">      // Move to the start position to initiate retraction</front>
<front id="Marlin_mainCPP-1559">      destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_X;</front>
<front id="Marlin_mainCPP-1560">      destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Y;</front>
<front id="Marlin_mainCPP-1561">      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Z;</front>
<front id="Marlin_mainCPP-1562">      prepare_move_raw();</front>
<front id="Marlin_mainCPP-1563"></front>
<front id="Marlin_mainCPP-1564">      // Move the nozzle down to push the Z probe into retracted position</front>
<front id="Marlin_mainCPP-1565">      if (Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1566">        feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;</front>
<front id="Marlin_mainCPP-1567">      }</front>
<front id="Marlin_mainCPP-1568">      if (Z_PROBE_ALLEN_KEY_STOW_2_X != Z_PROBE_ALLEN_KEY_STOW_1_X) {</front>
<front id="Marlin_mainCPP-1569">        destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_X;</front>
<front id="Marlin_mainCPP-1570">      }</front>
<front id="Marlin_mainCPP-1571">      if (Z_PROBE_ALLEN_KEY_STOW_2_Y != Z_PROBE_ALLEN_KEY_STOW_1_Y) {</front>
<front id="Marlin_mainCPP-1572">        destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Y;</front>
<front id="Marlin_mainCPP-1573">      }</front>
<front id="Marlin_mainCPP-1574">      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Z;</front>
<front id="Marlin_mainCPP-1575">      prepare_move_raw();</front>
<front id="Marlin_mainCPP-1576"></front>
<front id="Marlin_mainCPP-1577">      // Move up for safety</front>
<front id="Marlin_mainCPP-1578">      if (Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1579">        feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;</front>
<front id="Marlin_mainCPP-1580">      }</front>
<front id="Marlin_mainCPP-1581">      if (Z_PROBE_ALLEN_KEY_STOW_3_X != Z_PROBE_ALLEN_KEY_STOW_2_X) {</front>
<front id="Marlin_mainCPP-1582">        destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_X;</front>
<front id="Marlin_mainCPP-1583">      }</front>
<front id="Marlin_mainCPP-1584">      if (Z_PROBE_ALLEN_KEY_STOW_3_Y != Z_PROBE_ALLEN_KEY_STOW_2_Y) {</front>
<front id="Marlin_mainCPP-1585">        destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Y;</front>
<front id="Marlin_mainCPP-1586">      }</front>
<front id="Marlin_mainCPP-1587">      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Z;</front>
<front id="Marlin_mainCPP-1588">      prepare_move_raw();</front>
<front id="Marlin_mainCPP-1589"></front>
<front id="Marlin_mainCPP-1590">      // Home XY for safety</front>
<front id="Marlin_mainCPP-1591">      feedrate = homing_feedrate[X_AXIS]/2;</front>
<front id="Marlin_mainCPP-1592">      destination[X_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1593">      destination[Y_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1594">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1595"></front>
<front id="Marlin_mainCPP-1596">      st_synchronize();</front>
<front id="Marlin_mainCPP-1597"></front>
<front id="Marlin_mainCPP-1598">      #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-1599">        bool z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1600">        if (!z_probe_endstop)</front>
<front id="Marlin_mainCPP-1601">      #else</front>
<front id="Marlin_mainCPP-1602">        bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1603">        if (!z_min_endstop)</front>
<front id="Marlin_mainCPP-1604">      #endif</front>
<front id="Marlin_mainCPP-1605">        {</front>
<front id="Marlin_mainCPP-1606">          if (IsRunning()) {</front>
<front id="Marlin_mainCPP-1607">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-1608">            SERIAL_ERRORLNPGM("Z-Probe failed to retract!");</front>
<front id="Marlin_mainCPP-1609">            LCD_ALERTMESSAGEPGM("Err: ZPROBE");</front>
<front id="Marlin_mainCPP-1610">          }</front>
<front id="Marlin_mainCPP-1611">          Stop();</front>
<front id="Marlin_mainCPP-1612">        }</front>
<front id="Marlin_mainCPP-1613"></front>
<front id="Marlin_mainCPP-1614">    #endif // Z_PROBE_ALLEN_KEY</front>
<front id="Marlin_mainCPP-1615"></front>
<front id="Marlin_mainCPP-1616">  }</front>
<front id="Marlin_mainCPP-1617"></front>
<front id="Marlin_mainCPP-1618">  enum ProbeAction {</front>
<front id="Marlin_mainCPP-1619">    ProbeStay          = 0,</front>
<front id="Marlin_mainCPP-1620">    ProbeDeploy        = BIT(0),</front>
<front id="Marlin_mainCPP-1621">    ProbeStow          = BIT(1),</front>
<front id="Marlin_mainCPP-1622">    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)</front>
<front id="Marlin_mainCPP-1623">  };</front>
<front id="Marlin_mainCPP-1624"></front>
<front id="Marlin_mainCPP-1625">  // Probe bed height at position (x,y), returns the measured z value</front>
<front id="Marlin_mainCPP-1626">  static float probe_pt(float x, float y, float z_before, ProbeAction probe_action=ProbeDeployAndStow, int verbose_level=1) {</front>
<front id="Marlin_mainCPP-1627"></front>
<front id="Marlin_mainCPP-1628">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1629">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1630">        SERIAL_ECHOLNPGM("probe_pt &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-1631">        SERIAL_ECHOPAIR("&gt; ProbeAction:", (unsigned long)probe_action);</front>
<front id="Marlin_mainCPP-1632">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1633">        print_xyz("&gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1634">      }</front>
<front id="Marlin_mainCPP-1635">    #endif</front>
<front id="Marlin_mainCPP-1636"></front>
<front id="Marlin_mainCPP-1637">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1638">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1639">        SERIAL_ECHOPAIR("Z Raise to z_before ", z_before);</front>
<front id="Marlin_mainCPP-1640">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1641">        SERIAL_ECHOPAIR("&gt; do_blocking_move_to_z ", z_before);</front>
<front id="Marlin_mainCPP-1642">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1643">      }</front>
<front id="Marlin_mainCPP-1644">    #endif</front>
<front id="Marlin_mainCPP-1645"></front>
<front id="Marlin_mainCPP-1646">    // Move Z up to the z_before height, then move the Z probe to the given XY</front>
<front id="Marlin_mainCPP-1647">    do_blocking_move_to_z(z_before); // this also updates current_position</front>
<front id="Marlin_mainCPP-1648"></front>
<front id="Marlin_mainCPP-1649">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1650">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1651">        SERIAL_ECHOPAIR("&gt; do_blocking_move_to_xy ", x - X_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-1652">        SERIAL_ECHOPAIR(", ", y - Y_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-1653">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1654">      }</front>
<front id="Marlin_mainCPP-1655">    #endif</front>
<front id="Marlin_mainCPP-1656"></front>
<front id="Marlin_mainCPP-1657">    do_blocking_move_to_xy(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER); // this also updates current_position</front>
<front id="Marlin_mainCPP-1658"></front>
<front id="Marlin_mainCPP-1659">    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1660">      if (probe_action & ProbeDeploy) {</front>
<front id="Marlin_mainCPP-1661">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1662">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1663">            SERIAL_ECHOLNPGM("&gt; ProbeDeploy");</front>
<front id="Marlin_mainCPP-1664">          }</front>
<front id="Marlin_mainCPP-1665">        #endif</front>
<front id="Marlin_mainCPP-1666">        deploy_z_probe();</front>
<front id="Marlin_mainCPP-1667">      }</front>
<front id="Marlin_mainCPP-1668">    #endif</front>
<front id="Marlin_mainCPP-1669"></front>
<front id="Marlin_mainCPP-1670">    run_z_probe();</front>
<front id="Marlin_mainCPP-1671">    float measured_z = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1672"></front>
<front id="Marlin_mainCPP-1673">    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1674">      if (probe_action & ProbeStow) {</front>
<front id="Marlin_mainCPP-1675">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1676">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1677">            SERIAL_ECHOLNPGM("&gt; ProbeStow (stow_z_probe will do Z Raise)");</front>
<front id="Marlin_mainCPP-1678">          }</front>
<front id="Marlin_mainCPP-1679">        #endif</front>
<front id="Marlin_mainCPP-1680">        stow_z_probe();</front>
<front id="Marlin_mainCPP-1681">      }</front>
<front id="Marlin_mainCPP-1682">    #endif</front>
<front id="Marlin_mainCPP-1683"></front>
<front id="Marlin_mainCPP-1684">    if (verbose_level &gt; 2) {</front>
<front id="Marlin_mainCPP-1685">      SERIAL_PROTOCOLPGM("Bed X: ");</front>
<front id="Marlin_mainCPP-1686">      SERIAL_PROTOCOL_F(x, 3);</front>
<front id="Marlin_mainCPP-1687">      SERIAL_PROTOCOLPGM(" Y: ");</front>
<front id="Marlin_mainCPP-1688">      SERIAL_PROTOCOL_F(y, 3);</front>
<front id="Marlin_mainCPP-1689">      SERIAL_PROTOCOLPGM(" Z: ");</front>
<front id="Marlin_mainCPP-1690">      SERIAL_PROTOCOL_F(measured_z, 3);</front>
<front id="Marlin_mainCPP-1691">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1692">    }</front>
<front id="Marlin_mainCPP-1693"></front>
<front id="Marlin_mainCPP-1694">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1695">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1696">        SERIAL_ECHOLNPGM("&lt;&lt;&lt; probe_pt");</front>
<front id="Marlin_mainCPP-1697">      }</front>
<front id="Marlin_mainCPP-1698">    #endif</front>
<front id="Marlin_mainCPP-1699"></front>
<front id="Marlin_mainCPP-1700">    return measured_z;</front>
<front id="Marlin_mainCPP-1701">  }</front>
<front id="Marlin_mainCPP-1702"></front>
<front id="Marlin_mainCPP-1703">  #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1704"></front>
<front id="Marlin_mainCPP-1705">    /**</front>
<front id="Marlin_mainCPP-1706">     * All DELTA leveling in the Marlin uses NONLINEAR_BED_LEVELING</front>
<front id="Marlin_mainCPP-1707">     */</front>
<front id="Marlin_mainCPP-1708"></front>
<front id="Marlin_mainCPP-1709">    static void extrapolate_one_point(int x, int y, int xdir, int ydir) {</front>
<front id="Marlin_mainCPP-1710">      if (bed_level[x][y] != 0.0) {</front>
<front id="Marlin_mainCPP-1711">        return;  // Don't overwrite good values.</front>
<front id="Marlin_mainCPP-1712">      }</front>
<front id="Marlin_mainCPP-1713">      float a = 2*bed_level[x+xdir][y] - bed_level[x+xdir*2][y];  // Left to right.</front>
<front id="Marlin_mainCPP-1714">      float b = 2*bed_level[x][y+ydir] - bed_level[x][y+ydir*2];  // Front to back.</front>
<front id="Marlin_mainCPP-1715">      float c = 2*bed_level[x+xdir][y+ydir] - bed_level[x+xdir*2][y+ydir*2];  // Diagonal.</front>
<front id="Marlin_mainCPP-1716">      float median = c;  // Median is robust (ignores outliers).</front>
<front id="Marlin_mainCPP-1717">      if (a &lt; b) {</front>
<front id="Marlin_mainCPP-1718">        if (b &lt; c) median = b;</front>
<front id="Marlin_mainCPP-1719">        if (c &lt; a) median = a;</front>
<front id="Marlin_mainCPP-1720">      } else {  // b &lt;= a</front>
<front id="Marlin_mainCPP-1721">        if (c &lt; b) median = b;</front>
<front id="Marlin_mainCPP-1722">        if (a &lt; c) median = a;</front>
<front id="Marlin_mainCPP-1723">      }</front>
<front id="Marlin_mainCPP-1724">      bed_level[x][y] = median;</front>
<front id="Marlin_mainCPP-1725">    }</front>
<front id="Marlin_mainCPP-1726"></front>
<front id="Marlin_mainCPP-1727">    // Fill in the unprobed points (corners of circular print surface)</front>
<front id="Marlin_mainCPP-1728">    // using linear extrapolation, away from the center.</front>
<front id="Marlin_mainCPP-1729">    static void extrapolate_unprobed_bed_level() {</front>
<front id="Marlin_mainCPP-1730">      int half = (AUTO_BED_LEVELING_GRID_POINTS-1)/2;</front>
<front id="Marlin_mainCPP-1731">      for (int y = 0; y &lt;= half; y++) {</front>
<front id="Marlin_mainCPP-1732">        for (int x = 0; x &lt;= half; x++) {</front>
<front id="Marlin_mainCPP-1733">          if (x + y &lt; 3) continue;</front>
<front id="Marlin_mainCPP-1734">          extrapolate_one_point(half-x, half-y, x&gt;1?+1:0, y&gt;1?+1:0);</front>
<front id="Marlin_mainCPP-1735">          extrapolate_one_point(half+x, half-y, x&gt;1?-1:0, y&gt;1?+1:0);</front>
<front id="Marlin_mainCPP-1736">          extrapolate_one_point(half-x, half+y, x&gt;1?+1:0, y&gt;1?-1:0);</front>
<front id="Marlin_mainCPP-1737">          extrapolate_one_point(half+x, half+y, x&gt;1?-1:0, y&gt;1?-1:0);</front>
<front id="Marlin_mainCPP-1738">        }</front>
<front id="Marlin_mainCPP-1739">      }</front>
<front id="Marlin_mainCPP-1740">    }</front>
<front id="Marlin_mainCPP-1741"></front>
<front id="Marlin_mainCPP-1742">    // Print calibration results for plotting or manual frame adjustment.</front>
<front id="Marlin_mainCPP-1743">    static void print_bed_level() {</front>
<front id="Marlin_mainCPP-1744">      for (int y = 0; y &lt; AUTO_BED_LEVELING_GRID_POINTS; y++) {</front>
<front id="Marlin_mainCPP-1745">        for (int x = 0; x &lt; AUTO_BED_LEVELING_GRID_POINTS; x++) {</front>
<front id="Marlin_mainCPP-1746">          SERIAL_PROTOCOL_F(bed_level[x][y], 2);</front>
<front id="Marlin_mainCPP-1747">          SERIAL_PROTOCOLCHAR(' ');</front>
<front id="Marlin_mainCPP-1748">        }</front>
<front id="Marlin_mainCPP-1749">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1750">      }</front>
<front id="Marlin_mainCPP-1751">    }</front>
<front id="Marlin_mainCPP-1752"></front>
<front id="Marlin_mainCPP-1753">    // Reset calibration results to zero.</front>
<front id="Marlin_mainCPP-1754">    void reset_bed_level() {</front>
<front id="Marlin_mainCPP-1755">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1756">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1757">          SERIAL_ECHOLNPGM("reset_bed_level");</front>
<front id="Marlin_mainCPP-1758">        }</front>
<front id="Marlin_mainCPP-1759">      #endif</front>
<front id="Marlin_mainCPP-1760">      for (int y = 0; y &lt; AUTO_BED_LEVELING_GRID_POINTS; y++) {</front>
<front id="Marlin_mainCPP-1761">        for (int x = 0; x &lt; AUTO_BED_LEVELING_GRID_POINTS; x++) {</front>
<front id="Marlin_mainCPP-1762">          bed_level[x][y] = 0.0;</front>
<front id="Marlin_mainCPP-1763">        }</front>
<front id="Marlin_mainCPP-1764">      }</front>
<front id="Marlin_mainCPP-1765">    }</front>
<front id="Marlin_mainCPP-1766"></front>
<front id="Marlin_mainCPP-1767">  #endif // DELTA</front>
<front id="Marlin_mainCPP-1768"></front>
<front id="Marlin_mainCPP-1769">  #if HAS_SERVO_ENDSTOPS && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1770"></front>
<front id="Marlin_mainCPP-1771">    void raise_z_for_servo() {</front>
<front id="Marlin_mainCPP-1772">      float zpos = current_position[Z_AXIS], z_dest = Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-1773">      z_dest += axis_known_position[Z_AXIS] ? zprobe_zoffset : zpos;</front>
<front id="Marlin_mainCPP-1774">      if (zpos &lt; z_dest) do_blocking_move_to_z(z_dest); // also updates current_position</front>
<front id="Marlin_mainCPP-1775">    }</front>
<front id="Marlin_mainCPP-1776"></front>
<front id="Marlin_mainCPP-1777">  #endif</front>
<front id="Marlin_mainCPP-1778"></front>
<front id="Marlin_mainCPP-1779">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-1780"></front>
<front id="Marlin_mainCPP-1781"></front>
<front id="Marlin_mainCPP-1782">#if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1783"></front>
<front id="Marlin_mainCPP-1784">  #ifndef SLED_DOCKING_OFFSET</front>
<front id="Marlin_mainCPP-1785">    #define SLED_DOCKING_OFFSET 0</front>
<front id="Marlin_mainCPP-1786">  #endif</front>
<front id="Marlin_mainCPP-1787"></front>
<front id="Marlin_mainCPP-1788">  /**</front>
<front id="Marlin_mainCPP-1789">   * Method to dock/undock a sled designed by Charles Bell.</front>
<front id="Marlin_mainCPP-1790">   *</front>
<front id="Marlin_mainCPP-1791">   * dock[in]     If true, move to MAX_X and engage the electromagnet</front>
<front id="Marlin_mainCPP-1792">   * offset[in]   The additional distance to move to adjust docking location</front>
<front id="Marlin_mainCPP-1793">   */</front>
<front id="Marlin_mainCPP-1794">  static void dock_sled(bool dock, int offset=0) {</front>
<front id="Marlin_mainCPP-1795">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1796">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1797">        SERIAL_ECHOPAIR("dock_sled", dock);</front>
<front id="Marlin_mainCPP-1798">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1799">      }</front>
<front id="Marlin_mainCPP-1800">    #endif</front>
<front id="Marlin_mainCPP-1801">    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-1802">      LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-1803">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-1804">      SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-1805">      return;</front>
<front id="Marlin_mainCPP-1806">    }</front>
<front id="Marlin_mainCPP-1807"></front>
<front id="Marlin_mainCPP-1808">    float oldXpos = current_position[X_AXIS]; // save x position</front>
<front id="Marlin_mainCPP-1809">    if (dock) {</front>
<front id="Marlin_mainCPP-1810">      #if Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-1811">        raise_z_after_probing(); // raise Z</front>
<front id="Marlin_mainCPP-1812">      #endif</front>
<front id="Marlin_mainCPP-1813">      do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);  // Dock sled a bit closer to ensure proper capturing</front>
<front id="Marlin_mainCPP-1814">      digitalWrite(SLED_PIN, LOW); // turn off magnet</front>
<front id="Marlin_mainCPP-1815">    } else {</front>
<front id="Marlin_mainCPP-1816">      float z_loc = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1817">      if (z_loc &lt; Z_RAISE_BEFORE_PROBING + 5) z_loc = Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-1818">      do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset, current_position[Y_AXIS], z_loc); // this also updates current_position</front>
<front id="Marlin_mainCPP-1819">      digitalWrite(SLED_PIN, HIGH); // turn on magnet</front>
<front id="Marlin_mainCPP-1820">    }</front>
<front id="Marlin_mainCPP-1821">    do_blocking_move_to_x(oldXpos); // return to position before docking</front>
<front id="Marlin_mainCPP-1822">  }</front>
<front id="Marlin_mainCPP-1823"></front>
<front id="Marlin_mainCPP-1824">#endif // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-1825"></front>
<front id="Marlin_mainCPP-1826"></front>
<front id="Marlin_mainCPP-1827"></front>
<front id="Marlin_mainCPP-1828">/**</front>
<front id="Marlin_mainCPP-1829"> * Home an individual axis</front>
<front id="Marlin_mainCPP-1830"> */</front>
<front id="Marlin_mainCPP-1831"></front>
<front id="Marlin_mainCPP-1832">#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)</front>
<front id="Marlin_mainCPP-1833"></front>
<front id="Marlin_mainCPP-1834">static void homeaxis(AxisEnum axis) {</front>
<front id="Marlin_mainCPP-1835">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1836">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1837">      SERIAL_ECHOPAIR("&gt;&gt;&gt; homeaxis(", (unsigned long)axis);</front>
<front id="Marlin_mainCPP-1838">      SERIAL_CHAR(')');</front>
<front id="Marlin_mainCPP-1839">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1840">    }</front>
<front id="Marlin_mainCPP-1841">  #endif</front>
<front id="Marlin_mainCPP-1842">  #define HOMEAXIS_DO(LETTER) \</front>
<front id="Marlin_mainCPP-1843">    ((LETTER##_MIN_PIN &gt; -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN &gt; -1 && LETTER##_HOME_DIR==1))</front>
<front id="Marlin_mainCPP-1844"></front>
<front id="Marlin_mainCPP-1845">  if (axis == X_AXIS ? HOMEAXIS_DO(X) : axis == Y_AXIS ? HOMEAXIS_DO(Y) : axis == Z_AXIS ? HOMEAXIS_DO(Z) : 0) {</front>
<front id="Marlin_mainCPP-1846"></front>
<front id="Marlin_mainCPP-1847">    int axis_home_dir =</front>
<front id="Marlin_mainCPP-1848">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-1849">        (axis == X_AXIS) ? x_home_dir(active_extruder) :</front>
<front id="Marlin_mainCPP-1850">      #endif</front>
<front id="Marlin_mainCPP-1851">      home_dir(axis);</front>
<front id="Marlin_mainCPP-1852"></front>
<front id="Marlin_mainCPP-1853">    // Set the axis position as setup for the move</front>
<front id="Marlin_mainCPP-1854">    current_position[axis] = 0;</front>
<front id="Marlin_mainCPP-1855">    sync_plan_position();</front>
<front id="Marlin_mainCPP-1856"></front>
<front id="Marlin_mainCPP-1857">    #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1858">      // Get Probe</front>
<front id="Marlin_mainCPP-1859">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-1860">        if (axis_home_dir &lt; 0) dock_sled(false);</front>
<front id="Marlin_mainCPP-1861">      }</front>
<front id="Marlin_mainCPP-1862">    #endif</front>
<front id="Marlin_mainCPP-1863"></front>
<front id="Marlin_mainCPP-1864">    #if SERVO_LEVELING && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1865"></front>
<front id="Marlin_mainCPP-1866">      // Deploy a Z probe if there is one, and homing towards the bed</front>
<front id="Marlin_mainCPP-1867">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-1868">        if (axis_home_dir &lt; 0) deploy_z_probe();</front>
<front id="Marlin_mainCPP-1869">      }</front>
<front id="Marlin_mainCPP-1870"></front>
<front id="Marlin_mainCPP-1871">    #endif</front>
<front id="Marlin_mainCPP-1872"></front>
<front id="Marlin_mainCPP-1873">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-1874">      // Engage Servo endstop if enabled</front>
<front id="Marlin_mainCPP-1875">      if (axis != Z_AXIS && servo_endstop_id[axis] &gt;= 0)</front>
<front id="Marlin_mainCPP-1876">        servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][0]);</front>
<front id="Marlin_mainCPP-1877">    #endif</front>
<front id="Marlin_mainCPP-1878"></front>
<front id="Marlin_mainCPP-1879">    // Set a flag for Z motor locking</front>
<front id="Marlin_mainCPP-1880">    #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-1881">      if (axis == Z_AXIS) In_Homing_Process(true);</front>
<front id="Marlin_mainCPP-1882">    #endif</front>
<front id="Marlin_mainCPP-1883"></front>
<front id="Marlin_mainCPP-1884">    // Move towards the endstop until an endstop is triggered</front>
<front id="Marlin_mainCPP-1885">    destination[axis] = 1.5 * max_length(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-1886">    feedrate = homing_feedrate[axis];</front>
<front id="Marlin_mainCPP-1887">    line_to_destination();</front>
<front id="Marlin_mainCPP-1888">    st_synchronize();</front>
<front id="Marlin_mainCPP-1889"></front>
<front id="Marlin_mainCPP-1890">    // Set the axis position as setup for the move</front>
<front id="Marlin_mainCPP-1891">    current_position[axis] = 0;</front>
<front id="Marlin_mainCPP-1892">    sync_plan_position();</front>
<front id="Marlin_mainCPP-1893"></front>
<front id="Marlin_mainCPP-1894">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1895">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1896">        SERIAL_ECHOLNPGM("&gt; enable_endstops(false)");</front>
<front id="Marlin_mainCPP-1897">      }</front>
<front id="Marlin_mainCPP-1898">    #endif</front>
<front id="Marlin_mainCPP-1899">    enable_endstops(false); // Disable endstops while moving away</front>
<front id="Marlin_mainCPP-1900"></front>
<front id="Marlin_mainCPP-1901">    // Move away from the endstop by the axis HOME_BUMP_MM</front>
<front id="Marlin_mainCPP-1902">    destination[axis] = -home_bump_mm(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-1903">    line_to_destination();</front>
<front id="Marlin_mainCPP-1904">    st_synchronize();</front>
<front id="Marlin_mainCPP-1905"></front>
<front id="Marlin_mainCPP-1906">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1907">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1908">        SERIAL_ECHOLNPGM("&gt; enable_endstops(true)");</front>
<front id="Marlin_mainCPP-1909">      }</front>
<front id="Marlin_mainCPP-1910">    #endif</front>
<front id="Marlin_mainCPP-1911">    enable_endstops(true); // Enable endstops for next homing move</front>
<front id="Marlin_mainCPP-1912"></front>
<front id="Marlin_mainCPP-1913">    // Slow down the feedrate for the next move</front>
<front id="Marlin_mainCPP-1914">    set_homing_bump_feedrate(axis);</front>
<front id="Marlin_mainCPP-1915"></front>
<front id="Marlin_mainCPP-1916">    // Move slowly towards the endstop until triggered</front>
<front id="Marlin_mainCPP-1917">    destination[axis] = 2 * home_bump_mm(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-1918">    line_to_destination();</front>
<front id="Marlin_mainCPP-1919">    st_synchronize();</front>
<front id="Marlin_mainCPP-1920"></front>
<front id="Marlin_mainCPP-1921">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1922">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1923">        print_xyz("&gt; TRIGGER ENDSTOP &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1924">      }</front>
<front id="Marlin_mainCPP-1925">    #endif</front>
<front id="Marlin_mainCPP-1926"></front>
<front id="Marlin_mainCPP-1927">    #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-1928">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-1929">        float adj = fabs(z_endstop_adj);</front>
<front id="Marlin_mainCPP-1930">        bool lockZ1;</front>
<front id="Marlin_mainCPP-1931">        if (axis_home_dir &gt; 0) {</front>
<front id="Marlin_mainCPP-1932">          adj = -adj;</front>
<front id="Marlin_mainCPP-1933">          lockZ1 = (z_endstop_adj &gt; 0);</front>
<front id="Marlin_mainCPP-1934">        }</front>
<front id="Marlin_mainCPP-1935">        else</front>
<front id="Marlin_mainCPP-1936">          lockZ1 = (z_endstop_adj &lt; 0);</front>
<front id="Marlin_mainCPP-1937"></front>
<front id="Marlin_mainCPP-1938">        if (lockZ1) Lock_z_motor(true); else Lock_z2_motor(true);</front>
<front id="Marlin_mainCPP-1939">        sync_plan_position();</front>
<front id="Marlin_mainCPP-1940"></front>
<front id="Marlin_mainCPP-1941">        // Move to the adjusted endstop height</front>
<front id="Marlin_mainCPP-1942">        feedrate = homing_feedrate[axis];</front>
<front id="Marlin_mainCPP-1943">        destination[Z_AXIS] = adj;</front>
<front id="Marlin_mainCPP-1944">        line_to_destination();</front>
<front id="Marlin_mainCPP-1945">        st_synchronize();</front>
<front id="Marlin_mainCPP-1946"></front>
<front id="Marlin_mainCPP-1947">        if (lockZ1) Lock_z_motor(false); else Lock_z2_motor(false);</front>
<front id="Marlin_mainCPP-1948">        In_Homing_Process(false);</front>
<front id="Marlin_mainCPP-1949">      } // Z_AXIS</front>
<front id="Marlin_mainCPP-1950">    #endif</front>
<front id="Marlin_mainCPP-1951"></front>
<front id="Marlin_mainCPP-1952">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1953">      // retrace by the amount specified in endstop_adj</front>
<front id="Marlin_mainCPP-1954">      if (endstop_adj[axis] * axis_home_dir &lt; 0) {</front>
<front id="Marlin_mainCPP-1955">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1956">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1957">            SERIAL_ECHOLNPGM("&gt; enable_endstops(false)");</front>
<front id="Marlin_mainCPP-1958">          }</front>
<front id="Marlin_mainCPP-1959">        #endif</front>
<front id="Marlin_mainCPP-1960">        enable_endstops(false); // Disable endstops while moving away</front>
<front id="Marlin_mainCPP-1961">        sync_plan_position();</front>
<front id="Marlin_mainCPP-1962">        destination[axis] = endstop_adj[axis];</front>
<front id="Marlin_mainCPP-1963">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1964">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1965">            SERIAL_ECHOPAIR("&gt; endstop_adj = ", endstop_adj[axis]);</front>
<front id="Marlin_mainCPP-1966">            print_xyz(" &gt; destination", destination);</front>
<front id="Marlin_mainCPP-1967">          }</front>
<front id="Marlin_mainCPP-1968">        #endif</front>
<front id="Marlin_mainCPP-1969">        line_to_destination();</front>
<front id="Marlin_mainCPP-1970">        st_synchronize();</front>
<front id="Marlin_mainCPP-1971">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1972">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1973">            SERIAL_ECHOLNPGM("&gt; enable_endstops(true)");</front>
<front id="Marlin_mainCPP-1974">          }</front>
<front id="Marlin_mainCPP-1975">        #endif</front>
<front id="Marlin_mainCPP-1976">        enable_endstops(true); // Enable endstops for next homing move</front>
<front id="Marlin_mainCPP-1977">      }</front>
<front id="Marlin_mainCPP-1978">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1979">        else {</front>
<front id="Marlin_mainCPP-1980">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1981">            SERIAL_ECHOPAIR("&gt; endstop_adj * axis_home_dir = ", endstop_adj[axis] * axis_home_dir);</front>
<front id="Marlin_mainCPP-1982">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1983">          }</front>
<front id="Marlin_mainCPP-1984">        }</front>
<front id="Marlin_mainCPP-1985">      #endif</front>
<front id="Marlin_mainCPP-1986">    #endif</front>
<front id="Marlin_mainCPP-1987"></front>
<front id="Marlin_mainCPP-1988">    // Set the axis position to its home position (plus home offsets)</front>
<front id="Marlin_mainCPP-1989">    set_axis_is_at_home(axis);</front>
<front id="Marlin_mainCPP-1990">    sync_plan_position();</front>
<front id="Marlin_mainCPP-1991"></front>
<front id="Marlin_mainCPP-1992">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1993">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1994">        print_xyz("&gt; AFTER set_axis_is_at_home &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1995">      }</front>
<front id="Marlin_mainCPP-1996">    #endif</front>
<front id="Marlin_mainCPP-1997"></front>
<front id="Marlin_mainCPP-1998">    destination[axis] = current_position[axis];</front>
<front id="Marlin_mainCPP-1999">    feedrate = 0.0;</front>
<front id="Marlin_mainCPP-2000">    endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2001">    axis_known_position[axis] = true;</front>
<front id="Marlin_mainCPP-2002"></front>
<front id="Marlin_mainCPP-2003">    #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-2004">    // bring Z probe back</front>
<front id="Marlin_mainCPP-2005">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-2006">        if (axis_home_dir &lt; 0) dock_sled(true);</front>
<front id="Marlin_mainCPP-2007">      }</front>
<front id="Marlin_mainCPP-2008">    #endif</front>
<front id="Marlin_mainCPP-2009"></front>
<front id="Marlin_mainCPP-2010">    #if SERVO_LEVELING && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-2011"></front>
<front id="Marlin_mainCPP-2012">      // Deploy a Z probe if there is one, and homing towards the bed</front>
<front id="Marlin_mainCPP-2013">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-2014">        if (axis_home_dir &lt; 0) {</front>
<front id="Marlin_mainCPP-2015">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2016">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2017">              SERIAL_ECHOLNPGM("&gt; SERVO_LEVELING &gt; stow_z_probe");</front>
<front id="Marlin_mainCPP-2018">            }</front>
<front id="Marlin_mainCPP-2019">          #endif</front>
<front id="Marlin_mainCPP-2020">          stow_z_probe();</front>
<front id="Marlin_mainCPP-2021">        }</front>
<front id="Marlin_mainCPP-2022">      }</front>
<front id="Marlin_mainCPP-2023">      else</front>
<front id="Marlin_mainCPP-2024"></front>
<front id="Marlin_mainCPP-2025">    #endif</front>
<front id="Marlin_mainCPP-2026"></front>
<front id="Marlin_mainCPP-2027">    {</front>
<front id="Marlin_mainCPP-2028">      #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-2029">        // Retract Servo endstop if enabled</front>
<front id="Marlin_mainCPP-2030">        if (servo_endstop_id[axis] &gt;= 0) {</front>
<front id="Marlin_mainCPP-2031">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2032">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2033">              SERIAL_ECHOLNPGM("&gt; SERVO_ENDSTOPS &gt; Stow with servo.move()");</front>
<front id="Marlin_mainCPP-2034">            }</front>
<front id="Marlin_mainCPP-2035">          #endif</front>
<front id="Marlin_mainCPP-2036">          servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);</front>
<front id="Marlin_mainCPP-2037">        }</front>
<front id="Marlin_mainCPP-2038">      #endif</front>
<front id="Marlin_mainCPP-2039">    }</front>
<front id="Marlin_mainCPP-2040"></front>
<front id="Marlin_mainCPP-2041">  }</front>
<front id="Marlin_mainCPP-2042"></front>
<front id="Marlin_mainCPP-2043">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2044">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2045">      SERIAL_ECHOPAIR("&lt;&lt;&lt; homeaxis(", (unsigned long)axis);</front>
<front id="Marlin_mainCPP-2046">      SERIAL_CHAR(')');</front>
<front id="Marlin_mainCPP-2047">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2048">    }</front>
<front id="Marlin_mainCPP-2049">  #endif</front>
<front id="Marlin_mainCPP-2050">}</front>
<front id="Marlin_mainCPP-2051"></front>
<front id="Marlin_mainCPP-2052">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-2053"></front>
<front id="Marlin_mainCPP-2054">  void retract(bool retracting, bool swapping=false) {</front>
<front id="Marlin_mainCPP-2055"></front>
<front id="Marlin_mainCPP-2056">    if (retracting == retracted[active_extruder]) return;</front>
<front id="Marlin_mainCPP-2057"></front>
<front id="Marlin_mainCPP-2058">    float oldFeedrate = feedrate;</front>
<front id="Marlin_mainCPP-2059"></front>
<front id="Marlin_mainCPP-2060">    set_destination_to_current();</front>
<front id="Marlin_mainCPP-2061"></front>
<front id="Marlin_mainCPP-2062">    if (retracting) {</front>
<front id="Marlin_mainCPP-2063"></front>
<front id="Marlin_mainCPP-2064">      feedrate = retract_feedrate * 60;</front>
<front id="Marlin_mainCPP-2065">      current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];</front>
<front id="Marlin_mainCPP-2066">      plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2067">      prepare_move();</front>
<front id="Marlin_mainCPP-2068"></front>
<front id="Marlin_mainCPP-2069">      if (retract_zlift &gt; 0.01) {</front>
<front id="Marlin_mainCPP-2070">        current_position[Z_AXIS] -= retract_zlift;</front>
<front id="Marlin_mainCPP-2071">        #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2072">          sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2073">        #else</front>
<front id="Marlin_mainCPP-2074">          sync_plan_position();</front>
<front id="Marlin_mainCPP-2075">        #endif</front>
<front id="Marlin_mainCPP-2076">        prepare_move();</front>
<front id="Marlin_mainCPP-2077">      }</front>
<front id="Marlin_mainCPP-2078">    }</front>
<front id="Marlin_mainCPP-2079">    else {</front>
<front id="Marlin_mainCPP-2080"></front>
<front id="Marlin_mainCPP-2081">      if (retract_zlift &gt; 0.01) {</front>
<front id="Marlin_mainCPP-2082">        current_position[Z_AXIS] += retract_zlift;</front>
<front id="Marlin_mainCPP-2083">        #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2084">          sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2085">        #else</front>
<front id="Marlin_mainCPP-2086">          sync_plan_position();</front>
<front id="Marlin_mainCPP-2087">        #endif</front>
<front id="Marlin_mainCPP-2088">        //prepare_move();</front>
<front id="Marlin_mainCPP-2089">      }</front>
<front id="Marlin_mainCPP-2090"></front>
<front id="Marlin_mainCPP-2091">      feedrate = retract_recover_feedrate * 60;</front>
<front id="Marlin_mainCPP-2092">      float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;</front>
<front id="Marlin_mainCPP-2093">      current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];</front>
<front id="Marlin_mainCPP-2094">      plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2095">      prepare_move();</front>
<front id="Marlin_mainCPP-2096">    }</front>
<front id="Marlin_mainCPP-2097"></front>
<front id="Marlin_mainCPP-2098">    feedrate = oldFeedrate;</front>
<front id="Marlin_mainCPP-2099">    retracted[active_extruder] = retracting;</front>
<front id="Marlin_mainCPP-2100"></front>
<front id="Marlin_mainCPP-2101">  } // retract()</front>
<front id="Marlin_mainCPP-2102"></front>
<front id="Marlin_mainCPP-2103">#endif // FWRETRACT</front>
<front id="Marlin_mainCPP-2104"></front>
<front id="Marlin_mainCPP-2105">/**</front>
<front id="Marlin_mainCPP-2106"> *</front>
<front id="Marlin_mainCPP-2107"> * G-Code Handler functions</front>
<front id="Marlin_mainCPP-2108"> *</front>
<front id="Marlin_mainCPP-2109"> */</front>
<front id="Marlin_mainCPP-2110"></front>
<front id="Marlin_mainCPP-2111">/**</front>
<front id="Marlin_mainCPP-2112"> * Set XYZE destination and feedrate from the current GCode command</front>
<front id="Marlin_mainCPP-2113"> *</front>
<front id="Marlin_mainCPP-2114"> *  - Set destination from included axis codes</front>
<front id="Marlin_mainCPP-2115"> *  - Set to current for missing axis codes</front>
<front id="Marlin_mainCPP-2116"> *  - Set the feedrate, if included</front>
<front id="Marlin_mainCPP-2117"> */</front>
<front id="Marlin_mainCPP-2118">void gcode_get_destination() {</front>
<front id="Marlin_mainCPP-2119">  for (int i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2120">    if (code_seen(axis_codes[i]))</front>
<front id="Marlin_mainCPP-2121">      destination[i] = code_value() + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);</front>
<front id="Marlin_mainCPP-2122">    else</front>
<front id="Marlin_mainCPP-2123">      destination[i] = current_position[i];</front>
<front id="Marlin_mainCPP-2124">  }</front>
<front id="Marlin_mainCPP-2125">  if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-2126">    float next_feedrate = code_value();</front>
<front id="Marlin_mainCPP-2127">    if (next_feedrate &gt; 0.0) feedrate = next_feedrate;</front>
<front id="Marlin_mainCPP-2128">  }</front>
<front id="Marlin_mainCPP-2129">}</front>
<front id="Marlin_mainCPP-2130"></front>
<front id="Marlin_mainCPP-2131">void unknown_command_error() {</front>
<front id="Marlin_mainCPP-2132">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2133">  SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);</front>
<front id="Marlin_mainCPP-2134">  SERIAL_ECHO(current_command);</front>
<front id="Marlin_mainCPP-2135">  SERIAL_ECHOPGM("\"\n");</front>
<front id="Marlin_mainCPP-2136">}</front>
<front id="Marlin_mainCPP-2137"></front>
<front id="Marlin_mainCPP-2138">/**</front>
<front id="Marlin_mainCPP-2139"> * G0, G1: Coordinated movement of X Y Z E axes</front>
<front id="Marlin_mainCPP-2140"> */</front>
<front id="Marlin_mainCPP-2141">inline void gcode_G0_G1() {</front>
<front id="Marlin_mainCPP-2142">  if (IsRunning()) {</front>
<front id="Marlin_mainCPP-2143">    gcode_get_destination(); // For X Y Z E F</front>
<front id="Marlin_mainCPP-2144"></front>
<front id="Marlin_mainCPP-2145">    #if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-2146"></front>
<front id="Marlin_mainCPP-2147">      if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {</front>
<front id="Marlin_mainCPP-2148">        float echange = destination[E_AXIS] - current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-2149">        // Is this move an attempt to retract or recover?</front>
<front id="Marlin_mainCPP-2150">        if ((echange &lt; -MIN_RETRACT && !retracted[active_extruder]) || (echange &gt; MIN_RETRACT && retracted[active_extruder])) {</front>
<front id="Marlin_mainCPP-2151">          current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations</front>
<front id="Marlin_mainCPP-2152">          plan_set_e_position(current_position[E_AXIS]);  // AND from the planner</front>
<front id="Marlin_mainCPP-2153">          retract(!retracted[active_extruder]);</front>
<front id="Marlin_mainCPP-2154">          return;</front>
<front id="Marlin_mainCPP-2155">        }</front>
<front id="Marlin_mainCPP-2156">      }</front>
<front id="Marlin_mainCPP-2157"></front>
<front id="Marlin_mainCPP-2158">    #endif //FWRETRACT</front>
<front id="Marlin_mainCPP-2159"></front>
<front id="Marlin_mainCPP-2160">    prepare_move();</front>
<front id="Marlin_mainCPP-2161">  }</front>
<front id="Marlin_mainCPP-2162">}</front>
<front id="Marlin_mainCPP-2163"></front>
<front id="Marlin_mainCPP-2164">/**</front>
<front id="Marlin_mainCPP-2165"> * G2: Clockwise Arc</front>
<front id="Marlin_mainCPP-2166"> * G3: Counterclockwise Arc</front>
<front id="Marlin_mainCPP-2167"> */</front>
<front id="Marlin_mainCPP-2168">inline void gcode_G2_G3(bool clockwise) {</front>
<front id="Marlin_mainCPP-2169">  if (IsRunning()) {</front>
<front id="Marlin_mainCPP-2170"></front>
<front id="Marlin_mainCPP-2171">    #if ENABLED(SF_ARC_FIX)</front>
<front id="Marlin_mainCPP-2172">      bool relative_mode_backup = relative_mode;</front>
<front id="Marlin_mainCPP-2173">      relative_mode = true;</front>
<front id="Marlin_mainCPP-2174">    #endif</front>
<front id="Marlin_mainCPP-2175"></front>
<front id="Marlin_mainCPP-2176">    gcode_get_destination();</front>
<front id="Marlin_mainCPP-2177"></front>
<front id="Marlin_mainCPP-2178">    #if ENABLED(SF_ARC_FIX)</front>
<front id="Marlin_mainCPP-2179">      relative_mode = relative_mode_backup;</front>
<front id="Marlin_mainCPP-2180">    #endif</front>
<front id="Marlin_mainCPP-2181"></front>
<front id="Marlin_mainCPP-2182">    // Center of arc as offset from current_position</front>
<front id="Marlin_mainCPP-2183">    float arc_offset[2] = {</front>
<front id="Marlin_mainCPP-2184">      code_seen('I') ? code_value() : 0,</front>
<front id="Marlin_mainCPP-2185">      code_seen('J') ? code_value() : 0</front>
<front id="Marlin_mainCPP-2186">    };</front>
<front id="Marlin_mainCPP-2187"></front>
<front id="Marlin_mainCPP-2188">    // Send an arc to the planner</front>
<front id="Marlin_mainCPP-2189">    plan_arc(destination, arc_offset, clockwise);</front>
<front id="Marlin_mainCPP-2190"></front>
<front id="Marlin_mainCPP-2191">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-2192">  }</front>
<front id="Marlin_mainCPP-2193">}</front>
<front id="Marlin_mainCPP-2194"></front>
<front id="Marlin_mainCPP-2195">/**</front>
<front id="Marlin_mainCPP-2196"> * G4: Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</front>
<front id="Marlin_mainCPP-2197"> */</front>
<front id="Marlin_mainCPP-2198">inline void gcode_G4() {</front>
<front id="Marlin_mainCPP-2199">  millis_t codenum = 0;</front>
<front id="Marlin_mainCPP-2200"></front>
<front id="Marlin_mainCPP-2201">  if (code_seen('P')) codenum = code_value_long(); // milliseconds to wait</front>
<front id="Marlin_mainCPP-2202">  if (code_seen('S')) codenum = code_value() * 1000; // seconds to wait</front>
<front id="Marlin_mainCPP-2203"></front>
<front id="Marlin_mainCPP-2204">  st_synchronize();</front>
<front id="Marlin_mainCPP-2205">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-2206">  codenum += previous_cmd_ms;  // keep track of when we started waiting</front>
<front id="Marlin_mainCPP-2207"></front>
<front id="Marlin_mainCPP-2208">  if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);</front>
<front id="Marlin_mainCPP-2209"></front>
<front id="Marlin_mainCPP-2210">  while (millis() &lt; codenum) idle();</front>
<front id="Marlin_mainCPP-2211">}</front>
<front id="Marlin_mainCPP-2212"></front>
<front id="Marlin_mainCPP-2213">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-2214"></front>
<front id="Marlin_mainCPP-2215">  /**</front>
<front id="Marlin_mainCPP-2216">   * G10 - Retract filament according to settings of M207</front>
<front id="Marlin_mainCPP-2217">   * G11 - Recover filament according to settings of M208</front>
<front id="Marlin_mainCPP-2218">   */</front>
<front id="Marlin_mainCPP-2219">  inline void gcode_G10_G11(bool doRetract=false) {</front>
<front id="Marlin_mainCPP-2220">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-2221">      if (doRetract) {</front>
<front id="Marlin_mainCPP-2222">        retracted_swap[active_extruder] = (code_seen('S') && code_value_short() == 1); // checks for swap retract argument</front>
<front id="Marlin_mainCPP-2223">      }</front>
<front id="Marlin_mainCPP-2224">    #endif</front>
<front id="Marlin_mainCPP-2225">    retract(doRetract</front>
<front id="Marlin_mainCPP-2226">     #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-2227">      , retracted_swap[active_extruder]</front>
<front id="Marlin_mainCPP-2228">     #endif</front>
<front id="Marlin_mainCPP-2229">    );</front>
<front id="Marlin_mainCPP-2230">  }</front>
<front id="Marlin_mainCPP-2231"></front>
<front id="Marlin_mainCPP-2232">#endif //FWRETRACT</front>
<front id="Marlin_mainCPP-2233"></front>
<front id="Marlin_mainCPP-2234">/**</front>
<front id="Marlin_mainCPP-2235"> * G28: Home all axes according to settings</front>
<front id="Marlin_mainCPP-2236"> *</front>
<front id="Marlin_mainCPP-2237"> * Parameters</front>
<front id="Marlin_mainCPP-2238"> *</front>
<front id="Marlin_mainCPP-2239"> *  None  Home to all axes with no parameters.</front>
<front id="Marlin_mainCPP-2240"> *        With QUICK_HOME enabled XY will home together, then Z.</front>
<front id="Marlin_mainCPP-2241"> *</front>
<front id="Marlin_mainCPP-2242"> * Cartesian parameters</front>
<front id="Marlin_mainCPP-2243"> *</front>
<front id="Marlin_mainCPP-2244"> *  X   Home to the X endstop</front>
<front id="Marlin_mainCPP-2245"> *  Y   Home to the Y endstop</front>
<front id="Marlin_mainCPP-2246"> *  Z   Home to the Z endstop</front>
<front id="Marlin_mainCPP-2247"> *</front>
<front id="Marlin_mainCPP-2248"> */</front>
<front id="Marlin_mainCPP-2249">inline void gcode_G28() {</front>
<front id="Marlin_mainCPP-2250"></front>
<front id="Marlin_mainCPP-2251">  #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-2252">    if (planner_disabled_below_z) return; // Disable homing if resuming print</front>
<front id="Marlin_mainCPP-2253">  #endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-2254"></front>
<front id="Marlin_mainCPP-2255">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2256">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2257">      SERIAL_ECHOLNPGM("gcode_G28 &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-2258">    }</front>
<front id="Marlin_mainCPP-2259">  #endif</front>
<front id="Marlin_mainCPP-2260"></front>
<front id="Marlin_mainCPP-2261">  // Wait for planner moves to finish!</front>
<front id="Marlin_mainCPP-2262">  st_synchronize();</front>
<front id="Marlin_mainCPP-2263"></front>
<front id="Marlin_mainCPP-2264">  // For auto bed leveling, clear the level matrix</front>
<front id="Marlin_mainCPP-2265">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2266">    plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-2267">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2268">      reset_bed_level();</front>
<front id="Marlin_mainCPP-2269">    #endif</front>
<front id="Marlin_mainCPP-2270">  #endif</front>
<front id="Marlin_mainCPP-2271"></front>
<front id="Marlin_mainCPP-2272">  // For manual bed leveling deactivate the matrix temporarily</front>
<front id="Marlin_mainCPP-2273">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-2274">    uint8_t mbl_was_active = mbl.active;</front>
<front id="Marlin_mainCPP-2275">    mbl.active = 0;</front>
<front id="Marlin_mainCPP-2276">  #endif</front>
<front id="Marlin_mainCPP-2277"></front>
<front id="Marlin_mainCPP-2278">  setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-2279"></front>
<front id="Marlin_mainCPP-2280">  set_destination_to_current();</front>
<front id="Marlin_mainCPP-2281"></front>
<front id="Marlin_mainCPP-2282">  feedrate = 0.0;</front>
<front id="Marlin_mainCPP-2283"></front>
<front id="Marlin_mainCPP-2284">  #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2285">    // A delta can only safely home all axis at the same time</front>
<front id="Marlin_mainCPP-2286">    // all axis have to home at the same time</front>
<front id="Marlin_mainCPP-2287"></front>
<front id="Marlin_mainCPP-2288">    // Pretend the current position is 0,0,0</front>
<front id="Marlin_mainCPP-2289">    for (int i = X_AXIS; i &lt;= Z_AXIS; i++) current_position[i] = 0;</front>
<front id="Marlin_mainCPP-2290">    sync_plan_position();</front>
<front id="Marlin_mainCPP-2291"></front>
<front id="Marlin_mainCPP-2292">    // Move all carriages up together until the first endstop is hit.</front>
<front id="Marlin_mainCPP-2293">    for (int i = X_AXIS; i &lt;= Z_AXIS; i++) destination[i] = 3 * Z_MAX_LENGTH;</front>
<front id="Marlin_mainCPP-2294">    feedrate = 1.732 * homing_feedrate[X_AXIS];</front>
<front id="Marlin_mainCPP-2295">    line_to_destination();</front>
<front id="Marlin_mainCPP-2296">    st_synchronize();</front>
<front id="Marlin_mainCPP-2297">    endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2298"></front>
<front id="Marlin_mainCPP-2299">    // Destination reached</front>
<front id="Marlin_mainCPP-2300">    for (int i = X_AXIS; i &lt;= Z_AXIS; i++) current_position[i] = destination[i];</front>
<front id="Marlin_mainCPP-2301"></front>
<front id="Marlin_mainCPP-2302">    // take care of back off and rehome now we are all at the top</front>
<front id="Marlin_mainCPP-2303">    HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2304">    HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-2305">    HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2306"></front>
<front id="Marlin_mainCPP-2307">    sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2308"></front>
<front id="Marlin_mainCPP-2309">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2310">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2311">        print_xyz("(DELTA) &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2312">      }</front>
<front id="Marlin_mainCPP-2313">    #endif</front>
<front id="Marlin_mainCPP-2314"></front>
<front id="Marlin_mainCPP-2315">  #else // NOT DELTA</front>
<front id="Marlin_mainCPP-2316"></front>
<front id="Marlin_mainCPP-2317">    bool  homeX = code_seen(axis_codes[X_AXIS]),</front>
<front id="Marlin_mainCPP-2318">          homeY = code_seen(axis_codes[Y_AXIS]),</front>
<front id="Marlin_mainCPP-2319">          homeZ = code_seen(axis_codes[Z_AXIS]);</front>
<front id="Marlin_mainCPP-2320"></front>
<front id="Marlin_mainCPP-2321">    home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);</front>
<front id="Marlin_mainCPP-2322"></front>
<front id="Marlin_mainCPP-2323">    if (home_all_axis || homeZ) {</front>
<front id="Marlin_mainCPP-2324"></front>
<front id="Marlin_mainCPP-2325">      #if Z_HOME_DIR &gt; 0  // If homing away from BED do Z first</front>
<front id="Marlin_mainCPP-2326"></front>
<front id="Marlin_mainCPP-2327">        HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2328">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2329">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2330">            print_xyz("&gt; HOMEAXIS(Z) &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2331">          }</front>
<front id="Marlin_mainCPP-2332">        #endif</front>
<front id="Marlin_mainCPP-2333"></front>
<front id="Marlin_mainCPP-2334">      #elif DISABLED(Z_SAFE_HOMING) && defined(Z_RAISE_BEFORE_HOMING) && Z_RAISE_BEFORE_HOMING &gt; 0</front>
<front id="Marlin_mainCPP-2335"></front>
<front id="Marlin_mainCPP-2336">        // Raise Z before homing any other axes</front>
<front id="Marlin_mainCPP-2337">        // (Does this need to be "negative home direction?" Why not just use Z_RAISE_BEFORE_HOMING?)</front>
<front id="Marlin_mainCPP-2338">        destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);</front>
<front id="Marlin_mainCPP-2339">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2340">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2341">            SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);</front>
<front id="Marlin_mainCPP-2342">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2343">            print_xyz("&gt; (home_all_axis || homeZ) &gt; destination", destination);</front>
<front id="Marlin_mainCPP-2344">          }</front>
<front id="Marlin_mainCPP-2345">        #endif</front>
<front id="Marlin_mainCPP-2346">        feedrate = max_feedrate[Z_AXIS] * 60;</front>
<front id="Marlin_mainCPP-2347">        line_to_destination();</front>
<front id="Marlin_mainCPP-2348">        st_synchronize();</front>
<front id="Marlin_mainCPP-2349"></front>
<front id="Marlin_mainCPP-2350">      #endif</front>
<front id="Marlin_mainCPP-2351"></front>
<front id="Marlin_mainCPP-2352">    } // home_all_axis || homeZ</front>
<front id="Marlin_mainCPP-2353"></front>
<front id="Marlin_mainCPP-2354">    #if ENABLED(QUICK_HOME)</front>
<front id="Marlin_mainCPP-2355"></front>
<front id="Marlin_mainCPP-2356">      if (home_all_axis || (homeX && homeY)) {  // First diagonal move</front>
<front id="Marlin_mainCPP-2357"></front>
<front id="Marlin_mainCPP-2358">        current_position[X_AXIS] = current_position[Y_AXIS] = 0;</front>
<front id="Marlin_mainCPP-2359"></front>
<front id="Marlin_mainCPP-2360">        #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-2361">          int x_axis_home_dir = x_home_dir(active_extruder);</front>
<front id="Marlin_mainCPP-2362">          extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-2363">        #else</front>
<front id="Marlin_mainCPP-2364">          int x_axis_home_dir = home_dir(X_AXIS);</front>
<front id="Marlin_mainCPP-2365">        #endif</front>
<front id="Marlin_mainCPP-2366"></front>
<front id="Marlin_mainCPP-2367">        sync_plan_position();</front>
<front id="Marlin_mainCPP-2368"></front>
<front id="Marlin_mainCPP-2369">        float mlx = max_length(X_AXIS), mly = max_length(Y_AXIS),</front>
<front id="Marlin_mainCPP-2370">              mlratio = mlx&gt;mly ? mly/mlx : mlx/mly;</front>
<front id="Marlin_mainCPP-2371"></front>
<front id="Marlin_mainCPP-2372">        destination[X_AXIS] = 1.5 * mlx * x_axis_home_dir;</front>
<front id="Marlin_mainCPP-2373">        destination[Y_AXIS] = 1.5 * mly * home_dir(Y_AXIS);</front>
<front id="Marlin_mainCPP-2374">        feedrate = min(homing_feedrate[X_AXIS], homing_feedrate[Y_AXIS]) * sqrt(mlratio * mlratio + 1);</front>
<front id="Marlin_mainCPP-2375">        line_to_destination();</front>
<front id="Marlin_mainCPP-2376">        st_synchronize();</front>
<front id="Marlin_mainCPP-2377"></front>
<front id="Marlin_mainCPP-2378">        set_axis_is_at_home(X_AXIS);</front>
<front id="Marlin_mainCPP-2379">        set_axis_is_at_home(Y_AXIS);</front>
<front id="Marlin_mainCPP-2380">        sync_plan_position();</front>
<front id="Marlin_mainCPP-2381"></front>
<front id="Marlin_mainCPP-2382">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2383">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2384">            print_xyz("&gt; QUICK_HOME &gt; current_position 1", current_position);</front>
<front id="Marlin_mainCPP-2385">          }</front>
<front id="Marlin_mainCPP-2386">        #endif</front>
<front id="Marlin_mainCPP-2387"></front>
<front id="Marlin_mainCPP-2388">        destination[X_AXIS] = current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-2389">        destination[Y_AXIS] = current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-2390">        line_to_destination();</front>
<front id="Marlin_mainCPP-2391">        feedrate = 0.0;</front>
<front id="Marlin_mainCPP-2392">        st_synchronize();</front>
<front id="Marlin_mainCPP-2393">        endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2394"></front>
<front id="Marlin_mainCPP-2395">        current_position[X_AXIS] = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-2396">        current_position[Y_AXIS] = destination[Y_AXIS];</front>
<front id="Marlin_mainCPP-2397">        #if DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-2398">          current_position[Z_AXIS] = destination[Z_AXIS];</front>
<front id="Marlin_mainCPP-2399">        #endif</front>
<front id="Marlin_mainCPP-2400"></front>
<front id="Marlin_mainCPP-2401">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2402">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2403">            print_xyz("&gt; QUICK_HOME &gt; current_position 2", current_position);</front>
<front id="Marlin_mainCPP-2404">          }</front>
<front id="Marlin_mainCPP-2405">        #endif</front>
<front id="Marlin_mainCPP-2406">      }</front>
<front id="Marlin_mainCPP-2407"></front>
<front id="Marlin_mainCPP-2408">    #endif // QUICK_HOME</front>
<front id="Marlin_mainCPP-2409"></front>
<front id="Marlin_mainCPP-2410">    #if ENABLED(HOME_Y_BEFORE_X)</front>
<front id="Marlin_mainCPP-2411">      // Home Y</front>
<front id="Marlin_mainCPP-2412">      if (home_all_axis || homeY) HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-2413">    #endif</front>
<front id="Marlin_mainCPP-2414"></front>
<front id="Marlin_mainCPP-2415">    // Home X</front>
<front id="Marlin_mainCPP-2416">    if (home_all_axis || homeX) {</front>
<front id="Marlin_mainCPP-2417">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-2418">        int tmp_extruder = active_extruder;</front>
<front id="Marlin_mainCPP-2419">        extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-2420">        active_extruder = !active_extruder;</front>
<front id="Marlin_mainCPP-2421">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2422">        inactive_extruder_x_pos = current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-2423">        active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-2424">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2425">        // reset state used by the different modes</front>
<front id="Marlin_mainCPP-2426">        memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));</front>
<front id="Marlin_mainCPP-2427">        delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-2428">        active_extruder_parked = true;</front>
<front id="Marlin_mainCPP-2429">      #else</front>
<front id="Marlin_mainCPP-2430">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2431">      #endif</front>
<front id="Marlin_mainCPP-2432">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2433">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2434">          print_xyz("&gt; homeX", current_position);</front>
<front id="Marlin_mainCPP-2435">        }</front>
<front id="Marlin_mainCPP-2436">      #endif</front>
<front id="Marlin_mainCPP-2437">    }</front>
<front id="Marlin_mainCPP-2438"></front>
<front id="Marlin_mainCPP-2439">    #if DISABLED(HOME_Y_BEFORE_X)</front>
<front id="Marlin_mainCPP-2440">      // Home Y</front>
<front id="Marlin_mainCPP-2441">      if (home_all_axis || homeY) {</front>
<front id="Marlin_mainCPP-2442">        HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-2443">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2444">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2445">            print_xyz("&gt; homeY", current_position);</front>
<front id="Marlin_mainCPP-2446">          }</front>
<front id="Marlin_mainCPP-2447">        #endif</front>
<front id="Marlin_mainCPP-2448">      }</front>
<front id="Marlin_mainCPP-2449">    #endif</front>
<front id="Marlin_mainCPP-2450"></front>
<front id="Marlin_mainCPP-2451">    // Home Z last if homing towards the bed</front>
<front id="Marlin_mainCPP-2452">    #if Z_HOME_DIR &lt; 0</front>
<front id="Marlin_mainCPP-2453"></front>
<front id="Marlin_mainCPP-2454">      if (home_all_axis || homeZ) {</front>
<front id="Marlin_mainCPP-2455"></front>
<front id="Marlin_mainCPP-2456">        #if ENABLED(Z_SAFE_HOMING)</front>
<front id="Marlin_mainCPP-2457"></front>
<front id="Marlin_mainCPP-2458">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2459">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2460">              SERIAL_ECHOLNPGM("&gt; Z_SAFE_HOMING &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-2461">            }</front>
<front id="Marlin_mainCPP-2462">          #endif</front>
<front id="Marlin_mainCPP-2463"></front>
<front id="Marlin_mainCPP-2464">          if (home_all_axis) {</front>
<front id="Marlin_mainCPP-2465"></front>
<front id="Marlin_mainCPP-2466">            current_position[Z_AXIS] = 0;</front>
<front id="Marlin_mainCPP-2467">            sync_plan_position();</front>
<front id="Marlin_mainCPP-2468"></front>
<front id="Marlin_mainCPP-2469">            //</front>
<front id="Marlin_mainCPP-2470">            // Set the Z probe (or just the nozzle) destination to the safe homing point</front>
<front id="Marlin_mainCPP-2471">            //</front>
<front id="Marlin_mainCPP-2472">            // NOTE: If current_position[X_AXIS] or current_position[Y_AXIS] were set above</front>
<front id="Marlin_mainCPP-2473">            // then this may not work as expected.</front>
<front id="Marlin_mainCPP-2474">            destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-2475">            destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-2476">            destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);    // Set destination away from bed</front>
<front id="Marlin_mainCPP-2477">            feedrate = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-2478"></front>
<front id="Marlin_mainCPP-2479">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2480">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2481">                SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);</front>
<front id="Marlin_mainCPP-2482">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2483">                print_xyz("&gt; home_all_axis &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2484">                print_xyz("&gt; home_all_axis &gt; destination", destination);</front>
<front id="Marlin_mainCPP-2485">              }</front>
<front id="Marlin_mainCPP-2486">            #endif</front>
<front id="Marlin_mainCPP-2487"></front>
<front id="Marlin_mainCPP-2488">            // This could potentially move X, Y, Z all together</front>
<front id="Marlin_mainCPP-2489">            line_to_destination();</front>
<front id="Marlin_mainCPP-2490">            st_synchronize();</front>
<front id="Marlin_mainCPP-2491"></front>
<front id="Marlin_mainCPP-2492">            // Set current X, Y is the Z_SAFE_HOMING_POINT minus PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2493">            current_position[X_AXIS] = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-2494">            current_position[Y_AXIS] = destination[Y_AXIS];</front>
<front id="Marlin_mainCPP-2495"></front>
<front id="Marlin_mainCPP-2496">            // Home the Z axis</front>
<front id="Marlin_mainCPP-2497">            HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2498">          }</front>
<front id="Marlin_mainCPP-2499"></front>
<front id="Marlin_mainCPP-2500">          else if (homeZ) { // Don't need to Home Z twice</front>
<front id="Marlin_mainCPP-2501"></front>
<front id="Marlin_mainCPP-2502">            // Let's see if X and Y are homed</front>
<front id="Marlin_mainCPP-2503">            if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-2504"></front>
<front id="Marlin_mainCPP-2505">              // Make sure the Z probe is within the physical limits</front>
<front id="Marlin_mainCPP-2506">              // NOTE: This doesn't necessarily ensure the Z probe is also within the bed!</front>
<front id="Marlin_mainCPP-2507">              float cpx = current_position[X_AXIS], cpy = current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-2508">              if (   cpx &gt;= X_MIN_POS - X_PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2509">                  && cpx &lt;= X_MAX_POS - X_PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2510">                  && cpy &gt;= Y_MIN_POS - Y_PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2511">                  && cpy &lt;= Y_MAX_POS - Y_PROBE_OFFSET_FROM_EXTRUDER) {</front>
<front id="Marlin_mainCPP-2512">                // Set the plan current position to X, Y, 0</front>
<front id="Marlin_mainCPP-2513">                current_position[Z_AXIS] = 0;</front>
<front id="Marlin_mainCPP-2514">                plan_set_position(cpx, cpy, 0, current_position[E_AXIS]); // = sync_plan_position</front>
<front id="Marlin_mainCPP-2515"></front>
<front id="Marlin_mainCPP-2516">                // Set Z destination away from bed and raise the axis</front>
<front id="Marlin_mainCPP-2517">                // NOTE: This should always just be Z_RAISE_BEFORE_HOMING unless...???</front>
<front id="Marlin_mainCPP-2518">                destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);</front>
<front id="Marlin_mainCPP-2519">                feedrate = max_feedrate[Z_AXIS] * 60;  // feedrate (mm/m) = max_feedrate (mm/s)</front>
<front id="Marlin_mainCPP-2520"></front>
<front id="Marlin_mainCPP-2521">                #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2522">                  if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2523">                    SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);</front>
<front id="Marlin_mainCPP-2524">                    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2525">                    print_xyz("&gt; homeZ &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2526">                    print_xyz("&gt; homeZ &gt; destination", destination);</front>
<front id="Marlin_mainCPP-2527">                  }</front>
<front id="Marlin_mainCPP-2528">                #endif</front>
<front id="Marlin_mainCPP-2529"></front>
<front id="Marlin_mainCPP-2530">                line_to_destination();</front>
<front id="Marlin_mainCPP-2531">                st_synchronize();</front>
<front id="Marlin_mainCPP-2532"></front>
<front id="Marlin_mainCPP-2533">                // Home the Z axis</front>
<front id="Marlin_mainCPP-2534">                HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2535">              }</front>
<front id="Marlin_mainCPP-2536">              else {</front>
<front id="Marlin_mainCPP-2537">                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);</front>
<front id="Marlin_mainCPP-2538">                SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2539">                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);</front>
<front id="Marlin_mainCPP-2540">              }</front>
<front id="Marlin_mainCPP-2541">            }</front>
<front id="Marlin_mainCPP-2542">            else {</front>
<front id="Marlin_mainCPP-2543">              LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2544">              SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2545">              SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2546">            }</front>
<front id="Marlin_mainCPP-2547"></front>
<front id="Marlin_mainCPP-2548">          } // !home_all_axes && homeZ</front>
<front id="Marlin_mainCPP-2549"></front>
<front id="Marlin_mainCPP-2550">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2551">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2552">              SERIAL_ECHOLNPGM("&lt;&lt;&lt; Z_SAFE_HOMING");</front>
<front id="Marlin_mainCPP-2553">            }</front>
<front id="Marlin_mainCPP-2554">          #endif</front>
<front id="Marlin_mainCPP-2555"></front>
<front id="Marlin_mainCPP-2556">        #else // !Z_SAFE_HOMING</front>
<front id="Marlin_mainCPP-2557"></front>
<front id="Marlin_mainCPP-2558">          HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2559"></front>
<front id="Marlin_mainCPP-2560">        #endif // !Z_SAFE_HOMING</front>
<front id="Marlin_mainCPP-2561"></front>
<front id="Marlin_mainCPP-2562">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2563">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2564">            print_xyz("&gt; (home_all_axis || homeZ) &gt; final", current_position);</front>
<front id="Marlin_mainCPP-2565">          }</front>
<front id="Marlin_mainCPP-2566">        #endif</front>
<front id="Marlin_mainCPP-2567"></front>
<front id="Marlin_mainCPP-2568">      } // home_all_axis || homeZ</front>
<front id="Marlin_mainCPP-2569"></front>
<front id="Marlin_mainCPP-2570">    #endif // Z_HOME_DIR &lt; 0</front>
<front id="Marlin_mainCPP-2571"></front>
<front id="Marlin_mainCPP-2572">    sync_plan_position();</front>
<front id="Marlin_mainCPP-2573"></front>
<front id="Marlin_mainCPP-2574">  #endif // else DELTA</front>
<front id="Marlin_mainCPP-2575"></front>
<front id="Marlin_mainCPP-2576">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-2577">    sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2578">  #endif</front>
<front id="Marlin_mainCPP-2579"></front>
<front id="Marlin_mainCPP-2580">  #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)</front>
<front id="Marlin_mainCPP-2581">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2582">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2583">        SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING enable_endstops(false)");</front>
<front id="Marlin_mainCPP-2584">      }</front>
<front id="Marlin_mainCPP-2585">    #endif</front>
<front id="Marlin_mainCPP-2586">    enable_endstops(false);</front>
<front id="Marlin_mainCPP-2587">  #endif</front>
<front id="Marlin_mainCPP-2588"></front>
<front id="Marlin_mainCPP-2589">  // For manual leveling move back to 0,0</front>
<front id="Marlin_mainCPP-2590">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-2591">    if (mbl_was_active) {</front>
<front id="Marlin_mainCPP-2592">      current_position[X_AXIS] = mbl.get_x(0);</front>
<front id="Marlin_mainCPP-2593">      current_position[Y_AXIS] = mbl.get_y(0);</front>
<front id="Marlin_mainCPP-2594">      set_destination_to_current();</front>
<front id="Marlin_mainCPP-2595">      feedrate = homing_feedrate[X_AXIS];</front>
<front id="Marlin_mainCPP-2596">      line_to_destination();</front>
<front id="Marlin_mainCPP-2597">      st_synchronize();</front>
<front id="Marlin_mainCPP-2598">      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="Marlin_mainCPP-2599">      sync_plan_position();</front>
<front id="Marlin_mainCPP-2600">      mbl.active = 1;</front>
<front id="Marlin_mainCPP-2601">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2602">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2603">          print_xyz("mbl_was_active &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2604">        }</front>
<front id="Marlin_mainCPP-2605">      #endif</front>
<front id="Marlin_mainCPP-2606">    }</front>
<front id="Marlin_mainCPP-2607">  #endif</front>
<front id="Marlin_mainCPP-2608"></front>
<front id="Marlin_mainCPP-2609">  #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-2610">    current_layer = 0;</front>
<front id="Marlin_mainCPP-2611">    last_layer_z = 0;</front>
<front id="Marlin_mainCPP-2612">  #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-2613">  feedrate = saved_feedrate;</front>
<front id="Marlin_mainCPP-2614">  feedrate_multiplier = saved_feedrate_multiplier;</front>
<front id="Marlin_mainCPP-2615">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-2616">  endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2617"></front>
<front id="Marlin_mainCPP-2618">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2619">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2620">      SERIAL_ECHOLNPGM("&lt;&lt;&lt; gcode_G28");</front>
<front id="Marlin_mainCPP-2621">    }</front>
<front id="Marlin_mainCPP-2622">  #endif</front>
<front id="Marlin_mainCPP-2623"></front>
<front id="Marlin_mainCPP-2624">}</front>
<front id="Marlin_mainCPP-2625"></front>
<front id="Marlin_mainCPP-2626">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-2627"></front>
<front id="Marlin_mainCPP-2628">  enum MeshLevelingState { MeshReport, MeshStart, MeshNext, MeshSet };</front>
<front id="Marlin_mainCPP-2629"></front>
<front id="Marlin_mainCPP-2630">  /**</front>
<front id="Marlin_mainCPP-2631">   * G29: Mesh-based Z probe, probes a grid and produces a</front>
<front id="Marlin_mainCPP-2632">   *      mesh to compensate for variable bed height</front>
<front id="Marlin_mainCPP-2633">   *</front>
<front id="Marlin_mainCPP-2634">   * Parameters With MESH_BED_LEVELING:</front>
<front id="Marlin_mainCPP-2635">   *</front>
<front id="Marlin_mainCPP-2636">   *  S0              Produce a mesh report</front>
<front id="Marlin_mainCPP-2637">   *  S1              Start probing mesh points</front>
<front id="Marlin_mainCPP-2638">   *  S2              Probe the next mesh point</front>
<front id="Marlin_mainCPP-2639">   *  S3 Xn Yn Zn.nn  Manually modify a single point</front>
<front id="Marlin_mainCPP-2640">   *</front>
<front id="Marlin_mainCPP-2641">   * The S0 report the points as below</front>
<front id="Marlin_mainCPP-2642">   *</front>
<front id="Marlin_mainCPP-2643">   *  +----&gt; X-axis</front>
<front id="Marlin_mainCPP-2644">   *  |</front>
<front id="Marlin_mainCPP-2645">   *  |</front>
<front id="Marlin_mainCPP-2646">   *  v Y-axis</front>
<front id="Marlin_mainCPP-2647">   *</front>
<front id="Marlin_mainCPP-2648">   */</front>
<front id="Marlin_mainCPP-2649">  inline void gcode_G29() {</front>
<front id="Marlin_mainCPP-2650"></front>
<front id="Marlin_mainCPP-2651">    #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-2652">      if (planner_disabled_below_z) return; // Disable probing if resuming print</front>
<front id="Marlin_mainCPP-2653">    #endif</front>
<front id="Marlin_mainCPP-2654">    static int probe_point = -1;</front>
<front id="Marlin_mainCPP-2655">    MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_short() : MeshReport;</front>
<front id="Marlin_mainCPP-2656">    if (state &lt; 0 || state &gt; 3) {</front>
<front id="Marlin_mainCPP-2657">      SERIAL_PROTOCOLLNPGM("S out of range (0-3).");</front>
<front id="Marlin_mainCPP-2658">      return;</front>
<front id="Marlin_mainCPP-2659">    }</front>
<front id="Marlin_mainCPP-2660"></front>
<front id="Marlin_mainCPP-2661">    int ix, iy;</front>
<front id="Marlin_mainCPP-2662">    float z;</front>
<front id="Marlin_mainCPP-2663"></front>
<front id="Marlin_mainCPP-2664">    switch(state) {</front>
<front id="Marlin_mainCPP-2665">      case MeshReport:</front>
<front id="Marlin_mainCPP-2666">        if (mbl.active) {</front>
<front id="Marlin_mainCPP-2667">          SERIAL_PROTOCOLPGM("Num X,Y: ");</front>
<front id="Marlin_mainCPP-2668">          SERIAL_PROTOCOL(MESH_NUM_X_POINTS);</front>
<front id="Marlin_mainCPP-2669">          SERIAL_PROTOCOLCHAR(',');</front>
<front id="Marlin_mainCPP-2670">          SERIAL_PROTOCOL(MESH_NUM_Y_POINTS);</front>
<front id="Marlin_mainCPP-2671">          SERIAL_PROTOCOLPGM("\nZ search height: ");</front>
<front id="Marlin_mainCPP-2672">          SERIAL_PROTOCOL(MESH_HOME_SEARCH_Z);</front>
<front id="Marlin_mainCPP-2673">          SERIAL_PROTOCOLLNPGM("\nMeasured points:");</front>
<front id="Marlin_mainCPP-2674">          for (int y = 0; y &lt; MESH_NUM_Y_POINTS; y++) {</front>
<front id="Marlin_mainCPP-2675">            for (int x = 0; x &lt; MESH_NUM_X_POINTS; x++) {</front>
<front id="Marlin_mainCPP-2676">              SERIAL_PROTOCOLPGM("  ");</front>
<front id="Marlin_mainCPP-2677">              SERIAL_PROTOCOL_F(mbl.z_values[y][x], 5);</front>
<front id="Marlin_mainCPP-2678">            }</front>
<front id="Marlin_mainCPP-2679">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2680">          }</front>
<front id="Marlin_mainCPP-2681">        }</front>
<front id="Marlin_mainCPP-2682">        else</front>
<front id="Marlin_mainCPP-2683">          SERIAL_PROTOCOLLNPGM("Mesh bed leveling not active.");</front>
<front id="Marlin_mainCPP-2684">        break;</front>
<front id="Marlin_mainCPP-2685"></front>
<front id="Marlin_mainCPP-2686">      case MeshStart:</front>
<front id="Marlin_mainCPP-2687">        mbl.reset();</front>
<front id="Marlin_mainCPP-2688">        probe_point = 0;</front>
<front id="Marlin_mainCPP-2689">        enqueuecommands_P(PSTR("G28\nG29 S2"));</front>
<front id="Marlin_mainCPP-2690">        break;</front>
<front id="Marlin_mainCPP-2691"></front>
<front id="Marlin_mainCPP-2692">      case MeshNext:</front>
<front id="Marlin_mainCPP-2693">        if (probe_point &lt; 0) {</front>
<front id="Marlin_mainCPP-2694">          SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");</front>
<front id="Marlin_mainCPP-2695">          return;</front>
<front id="Marlin_mainCPP-2696">        }</front>
<front id="Marlin_mainCPP-2697">        if (probe_point == 0) {</front>
<front id="Marlin_mainCPP-2698">          // Set Z to a positive value before recording the first Z.</front>
<front id="Marlin_mainCPP-2699">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="Marlin_mainCPP-2700">          sync_plan_position();</front>
<front id="Marlin_mainCPP-2701">        }</front>
<front id="Marlin_mainCPP-2702">        else {</front>
<front id="Marlin_mainCPP-2703">          // For others, save the Z of the previous point, then raise Z again.</front>
<front id="Marlin_mainCPP-2704">          ix = (probe_point - 1) % MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2705">          iy = (probe_point - 1) / MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2706">          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag</front>
<front id="Marlin_mainCPP-2707">          mbl.set_z(ix, iy, current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-2708">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="Marlin_mainCPP-2709">          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);</front>
<front id="Marlin_mainCPP-2710">          st_synchronize();</front>
<front id="Marlin_mainCPP-2711">        }</front>
<front id="Marlin_mainCPP-2712">        // Is there another point to sample? Move there.</front>
<front id="Marlin_mainCPP-2713">        if (probe_point &lt; MESH_NUM_X_POINTS * MESH_NUM_Y_POINTS) {</front>
<front id="Marlin_mainCPP-2714">          ix = probe_point % MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2715">          iy = probe_point / MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2716">          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag</front>
<front id="Marlin_mainCPP-2717">          current_position[X_AXIS] = mbl.get_x(ix);</front>
<front id="Marlin_mainCPP-2718">          current_position[Y_AXIS] = mbl.get_y(iy);</front>
<front id="Marlin_mainCPP-2719">          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);</front>
<front id="Marlin_mainCPP-2720">          st_synchronize();</front>
<front id="Marlin_mainCPP-2721">          probe_point++;</front>
<front id="Marlin_mainCPP-2722">        }</front>
<front id="Marlin_mainCPP-2723">        else {</front>
<front id="Marlin_mainCPP-2724">          // After recording the last point, activate the mbl and home</front>
<front id="Marlin_mainCPP-2725">          SERIAL_PROTOCOLLNPGM("Mesh probing done.");</front>
<front id="Marlin_mainCPP-2726">          probe_point = -1;</front>
<front id="Marlin_mainCPP-2727">          mbl.active = 1;</front>
<front id="Marlin_mainCPP-2728">          enqueuecommands_P(PSTR("G28"));</front>
<front id="Marlin_mainCPP-2729">        }</front>
<front id="Marlin_mainCPP-2730">        break;</front>
<front id="Marlin_mainCPP-2731"></front>
<front id="Marlin_mainCPP-2732">      case MeshSet:</front>
<front id="Marlin_mainCPP-2733">        if (code_seen('X')) {</front>
<front id="Marlin_mainCPP-2734">          ix = code_value_long()-1;</front>
<front id="Marlin_mainCPP-2735">          if (ix &lt; 0 || ix &gt;= MESH_NUM_X_POINTS) {</front>
<front id="Marlin_mainCPP-2736">            SERIAL_PROTOCOLPGM("X out of range (1-" STRINGIFY(MESH_NUM_X_POINTS) ").\n");</front>
<front id="Marlin_mainCPP-2737">            return;</front>
<front id="Marlin_mainCPP-2738">          }</front>
<front id="Marlin_mainCPP-2739">        } else {</front>
<front id="Marlin_mainCPP-2740">            SERIAL_PROTOCOLPGM("X not entered.\n");</front>
<front id="Marlin_mainCPP-2741">            return;</front>
<front id="Marlin_mainCPP-2742">        }</front>
<front id="Marlin_mainCPP-2743">        if (code_seen('Y')) {</front>
<front id="Marlin_mainCPP-2744">          iy = code_value_long()-1;</front>
<front id="Marlin_mainCPP-2745">          if (iy &lt; 0 || iy &gt;= MESH_NUM_Y_POINTS) {</front>
<front id="Marlin_mainCPP-2746">            SERIAL_PROTOCOLPGM("Y out of range (1-" STRINGIFY(MESH_NUM_Y_POINTS) ").\n");</front>
<front id="Marlin_mainCPP-2747">            return;</front>
<front id="Marlin_mainCPP-2748">          }</front>
<front id="Marlin_mainCPP-2749">        } else {</front>
<front id="Marlin_mainCPP-2750">            SERIAL_PROTOCOLPGM("Y not entered.\n");</front>
<front id="Marlin_mainCPP-2751">            return;</front>
<front id="Marlin_mainCPP-2752">        }</front>
<front id="Marlin_mainCPP-2753">        if (code_seen('Z')) {</front>
<front id="Marlin_mainCPP-2754">          z = code_value();</front>
<front id="Marlin_mainCPP-2755">        } else {</front>
<front id="Marlin_mainCPP-2756">          SERIAL_PROTOCOLPGM("Z not entered.\n");</front>
<front id="Marlin_mainCPP-2757">          return;</front>
<front id="Marlin_mainCPP-2758">        }</front>
<front id="Marlin_mainCPP-2759">        mbl.z_values[iy][ix] = z;</front>
<front id="Marlin_mainCPP-2760"></front>
<front id="Marlin_mainCPP-2761">    } // switch(state)</front>
<front id="Marlin_mainCPP-2762">    #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-2763">      current_layer = 0;</front>
<front id="Marlin_mainCPP-2764">      last_layer_z = 0;</front>
<front id="Marlin_mainCPP-2765">    #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-2766">  }</front>
<front id="Marlin_mainCPP-2767"></front>
<front id="Marlin_mainCPP-2768">#elif ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2769"></front>
<front id="Marlin_mainCPP-2770">  void out_of_range_error(const char *p_edge) {</front>
<front id="Marlin_mainCPP-2771">    SERIAL_PROTOCOLPGM("?Probe ");</front>
<front id="Marlin_mainCPP-2772">    serialprintPGM(p_edge);</front>
<front id="Marlin_mainCPP-2773">    SERIAL_PROTOCOLLNPGM(" position out of range.");</front>
<front id="Marlin_mainCPP-2774">  }</front>
<front id="Marlin_mainCPP-2775"></front>
<front id="Marlin_mainCPP-2776">  /**</front>
<front id="Marlin_mainCPP-2777">   * G29: Detailed Z probe, probes the bed at 3 or more points.</front>
<front id="Marlin_mainCPP-2778">   *      Will fail if the printer has not been homed with G28.</front>
<front id="Marlin_mainCPP-2779">   *</front>
<front id="Marlin_mainCPP-2780">   * Enhanced G29 Auto Bed Leveling Probe Routine</front>
<front id="Marlin_mainCPP-2781">   *</front>
<front id="Marlin_mainCPP-2782">   * Parameters With AUTO_BED_LEVELING_GRID:</front>
<front id="Marlin_mainCPP-2783">   *</front>
<front id="Marlin_mainCPP-2784">   *  P  Set the size of the grid that will be probed (P x P points).</front>
<front id="Marlin_mainCPP-2785">   *     Not supported by non-linear delta printer bed leveling.</front>
<front id="Marlin_mainCPP-2786">   *     Example: "G29 P4"</front>
<front id="Marlin_mainCPP-2787">   *</front>
<front id="Marlin_mainCPP-2788">   *  S  Set the XY travel speed between probe points (in mm/min)</front>
<front id="Marlin_mainCPP-2789">   *</front>
<front id="Marlin_mainCPP-2790">   *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply</front>
<front id="Marlin_mainCPP-2791">   *     or clean the rotation Matrix. Useful to check the topology</front>
<front id="Marlin_mainCPP-2792">   *     after a first run of G29.</front>
<front id="Marlin_mainCPP-2793">   *</front>
<front id="Marlin_mainCPP-2794">   *  V  Set the verbose level (0-4). Example: "G29 V3"</front>
<front id="Marlin_mainCPP-2795">   *</front>
<front id="Marlin_mainCPP-2796">   *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.</front>
<front id="Marlin_mainCPP-2797">   *     This is useful for manual bed leveling and finding flaws in the bed (to</front>
<front id="Marlin_mainCPP-2798">   *     assist with part placement).</front>
<front id="Marlin_mainCPP-2799">   *     Not supported by non-linear delta printer bed leveling.</front>
<front id="Marlin_mainCPP-2800">   *</front>
<front id="Marlin_mainCPP-2801">   *  F  Set the Front limit of the probing grid</front>
<front id="Marlin_mainCPP-2802">   *  B  Set the Back limit of the probing grid</front>
<front id="Marlin_mainCPP-2803">   *  L  Set the Left limit of the probing grid</front>
<front id="Marlin_mainCPP-2804">   *  R  Set the Right limit of the probing grid</front>
<front id="Marlin_mainCPP-2805">   *</front>
<front id="Marlin_mainCPP-2806">   * Global Parameters:</front>
<front id="Marlin_mainCPP-2807">   *</front>
<front id="Marlin_mainCPP-2808">   * E/e By default G29 will engage the Z probe, test the bed, then disengage.</front>
<front id="Marlin_mainCPP-2809">   *     Include "E" to engage/disengage the Z probe for each sample.</front>
<front id="Marlin_mainCPP-2810">   *     There's no extra effect if you have a fixed Z probe.</front>
<front id="Marlin_mainCPP-2811">   *     Usage: "G29 E" or "G29 e"</front>
<front id="Marlin_mainCPP-2812">   *</front>
<front id="Marlin_mainCPP-2813">   */</front>
<front id="Marlin_mainCPP-2814">  inline void gcode_G29() {</front>
<front id="Marlin_mainCPP-2815"></front>
<front id="Marlin_mainCPP-2816">    #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-2817">      if (planner_disabled_below_z) return; // Disable probing if resuming print</front>
<front id="Marlin_mainCPP-2818">    #endif</front>
<front id="Marlin_mainCPP-2819"></front>
<front id="Marlin_mainCPP-2820">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2821">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2822">        SERIAL_ECHOLNPGM("gcode_G29 &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-2823">      }</front>
<front id="Marlin_mainCPP-2824">    #endif</front>
<front id="Marlin_mainCPP-2825"></front>
<front id="Marlin_mainCPP-2826">    // Don't allow auto-leveling without homing first</front>
<front id="Marlin_mainCPP-2827">    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-2828">      LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2829">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2830">      SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2831">      return;</front>
<front id="Marlin_mainCPP-2832">    }</front>
<front id="Marlin_mainCPP-2833"></front>
<front id="Marlin_mainCPP-2834">    int verbose_level = code_seen('V') ? code_value_short() : 1;</front>
<front id="Marlin_mainCPP-2835">    if (verbose_level &lt; 0 || verbose_level &gt; 4) {</front>
<front id="Marlin_mainCPP-2836">      SERIAL_ECHOLNPGM("?(V)erbose Level is implausible (0-4).");</front>
<front id="Marlin_mainCPP-2837">      return;</front>
<front id="Marlin_mainCPP-2838">    }</front>
<front id="Marlin_mainCPP-2839"></front>
<front id="Marlin_mainCPP-2840">    bool dryrun = code_seen('D'),</front>
<front id="Marlin_mainCPP-2841">         deploy_probe_for_each_reading = code_seen('E');</front>
<front id="Marlin_mainCPP-2842"></front>
<front id="Marlin_mainCPP-2843">    #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-2844"></front>
<front id="Marlin_mainCPP-2845">      #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-2846">        bool do_topography_map = verbose_level &gt; 2 || code_seen('T');</front>
<front id="Marlin_mainCPP-2847">      #endif</front>
<front id="Marlin_mainCPP-2848"></front>
<front id="Marlin_mainCPP-2849">      if (verbose_level &gt; 0) {</front>
<front id="Marlin_mainCPP-2850">        SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling\n");</front>
<front id="Marlin_mainCPP-2851">        if (dryrun) SERIAL_ECHOLNPGM("Running in DRY-RUN mode");</front>
<front id="Marlin_mainCPP-2852">      }</front>
<front id="Marlin_mainCPP-2853"></front>
<front id="Marlin_mainCPP-2854">      int auto_bed_leveling_grid_points = AUTO_BED_LEVELING_GRID_POINTS;</front>
<front id="Marlin_mainCPP-2855">      #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-2856">        if (code_seen('P')) auto_bed_leveling_grid_points = code_value_short();</front>
<front id="Marlin_mainCPP-2857">        if (auto_bed_leveling_grid_points &lt; 2) {</front>
<front id="Marlin_mainCPP-2858">          SERIAL_PROTOCOLPGM("?Number of probed (P)oints is implausible (2 minimum).\n");</front>
<front id="Marlin_mainCPP-2859">          return;</front>
<front id="Marlin_mainCPP-2860">        }</front>
<front id="Marlin_mainCPP-2861">      #endif</front>
<front id="Marlin_mainCPP-2862"></front>
<front id="Marlin_mainCPP-2863">      xy_travel_speed = code_seen('S') ? code_value_short() : XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-2864"></front>
<front id="Marlin_mainCPP-2865">      int left_probe_bed_position = code_seen('L') ? code_value_short() : LEFT_PROBE_BED_POSITION,</front>
<front id="Marlin_mainCPP-2866">          right_probe_bed_position = code_seen('R') ? code_value_short() : RIGHT_PROBE_BED_POSITION,</front>
<front id="Marlin_mainCPP-2867">          front_probe_bed_position = code_seen('F') ? code_value_short() : FRONT_PROBE_BED_POSITION,</front>
<front id="Marlin_mainCPP-2868">          back_probe_bed_position = code_seen('B') ? code_value_short() : BACK_PROBE_BED_POSITION;</front>
<front id="Marlin_mainCPP-2869"></front>
<front id="Marlin_mainCPP-2870">      bool left_out_l = left_probe_bed_position &lt; MIN_PROBE_X,</front>
<front id="Marlin_mainCPP-2871">           left_out = left_out_l || left_probe_bed_position &gt; right_probe_bed_position - MIN_PROBE_EDGE,</front>
<front id="Marlin_mainCPP-2872">           right_out_r = right_probe_bed_position &gt; MAX_PROBE_X,</front>
<front id="Marlin_mainCPP-2873">           right_out = right_out_r || right_probe_bed_position &lt; left_probe_bed_position + MIN_PROBE_EDGE,</front>
<front id="Marlin_mainCPP-2874">           front_out_f = front_probe_bed_position &lt; MIN_PROBE_Y,</front>
<front id="Marlin_mainCPP-2875">           front_out = front_out_f || front_probe_bed_position &gt; back_probe_bed_position - MIN_PROBE_EDGE,</front>
<front id="Marlin_mainCPP-2876">           back_out_b = back_probe_bed_position &gt; MAX_PROBE_Y,</front>
<front id="Marlin_mainCPP-2877">           back_out = back_out_b || back_probe_bed_position &lt; front_probe_bed_position + MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2878"></front>
<front id="Marlin_mainCPP-2879">      if (left_out || right_out || front_out || back_out) {</front>
<front id="Marlin_mainCPP-2880">        if (left_out) {</front>
<front id="Marlin_mainCPP-2881">          out_of_range_error(PSTR("(L)eft"));</front>
<front id="Marlin_mainCPP-2882">          left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2883">        }</front>
<front id="Marlin_mainCPP-2884">        if (right_out) {</front>
<front id="Marlin_mainCPP-2885">          out_of_range_error(PSTR("(R)ight"));</front>
<front id="Marlin_mainCPP-2886">          right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2887">        }</front>
<front id="Marlin_mainCPP-2888">        if (front_out) {</front>
<front id="Marlin_mainCPP-2889">          out_of_range_error(PSTR("(F)ront"));</front>
<front id="Marlin_mainCPP-2890">          front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2891">        }</front>
<front id="Marlin_mainCPP-2892">        if (back_out) {</front>
<front id="Marlin_mainCPP-2893">          out_of_range_error(PSTR("(B)ack"));</front>
<front id="Marlin_mainCPP-2894">          back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2895">        }</front>
<front id="Marlin_mainCPP-2896">        return;</front>
<front id="Marlin_mainCPP-2897">      }</front>
<front id="Marlin_mainCPP-2898"></front>
<front id="Marlin_mainCPP-2899">    #endif // AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-2900"></front>
<front id="Marlin_mainCPP-2901">    #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-2902">      dock_sled(false); // engage (un-dock) the Z probe</front>
<front id="Marlin_mainCPP-2903">    #elif ENABLED(Z_PROBE_ALLEN_KEY) //|| SERVO_LEVELING</front>
<front id="Marlin_mainCPP-2904">      deploy_z_probe();</front>
<front id="Marlin_mainCPP-2905">    #endif</front>
<front id="Marlin_mainCPP-2906"></front>
<front id="Marlin_mainCPP-2907">    st_synchronize();</front>
<front id="Marlin_mainCPP-2908"></front>
<front id="Marlin_mainCPP-2909">    if (!dryrun) {</front>
<front id="Marlin_mainCPP-2910">      // make sure the bed_level_rotation_matrix is identity or the planner will get it wrong</front>
<front id="Marlin_mainCPP-2911">      plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-2912"></front>
<front id="Marlin_mainCPP-2913">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2914">        reset_bed_level();</front>
<front id="Marlin_mainCPP-2915">      #else //!DELTA</front>
<front id="Marlin_mainCPP-2916">        //vector_3 corrected_position = plan_get_position_mm();</front>
<front id="Marlin_mainCPP-2917">        //corrected_position.debug("position before G29");</front>
<front id="Marlin_mainCPP-2918">        vector_3 uncorrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-2919">        //uncorrected_position.debug("position during G29");</front>
<front id="Marlin_mainCPP-2920">        current_position[X_AXIS] = uncorrected_position.x;</front>
<front id="Marlin_mainCPP-2921">        current_position[Y_AXIS] = uncorrected_position.y;</front>
<front id="Marlin_mainCPP-2922">        current_position[Z_AXIS] = uncorrected_position.z;</front>
<front id="Marlin_mainCPP-2923">        sync_plan_position();</front>
<front id="Marlin_mainCPP-2924">      #endif // !DELTA</front>
<front id="Marlin_mainCPP-2925">    }</front>
<front id="Marlin_mainCPP-2926"></front>
<front id="Marlin_mainCPP-2927">    setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-2928"></front>
<front id="Marlin_mainCPP-2929">    feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-2930"></front>
<front id="Marlin_mainCPP-2931">    #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-2932"></front>
<front id="Marlin_mainCPP-2933">      // probe at the points of a lattice grid</front>
<front id="Marlin_mainCPP-2934">      const int xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (auto_bed_leveling_grid_points - 1),</front>
<front id="Marlin_mainCPP-2935">                yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (auto_bed_leveling_grid_points - 1);</front>
<front id="Marlin_mainCPP-2936"></front>
<front id="Marlin_mainCPP-2937">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2938">        delta_grid_spacing[0] = xGridSpacing;</front>
<front id="Marlin_mainCPP-2939">        delta_grid_spacing[1] = yGridSpacing;</front>
<front id="Marlin_mainCPP-2940">        float z_offset = zprobe_zoffset;</front>
<front id="Marlin_mainCPP-2941">        if (code_seen(axis_codes[Z_AXIS])) z_offset += code_value();</front>
<front id="Marlin_mainCPP-2942">      #else // !DELTA</front>
<front id="Marlin_mainCPP-2943">        // solve the plane equation ax + by + d = z</front>
<front id="Marlin_mainCPP-2944">        // A is the matrix with rows [x y 1] for all the probed points</front>
<front id="Marlin_mainCPP-2945">        // B is the vector of the Z positions</front>
<front id="Marlin_mainCPP-2946">        // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0</front>
<front id="Marlin_mainCPP-2947">        // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z</front>
<front id="Marlin_mainCPP-2948"></front>
<front id="Marlin_mainCPP-2949">        int abl2 = auto_bed_leveling_grid_points * auto_bed_leveling_grid_points;</front>
<front id="Marlin_mainCPP-2950"></front>
<front id="Marlin_mainCPP-2951">        double eqnAMatrix[abl2 * 3], // "A" matrix of the linear system of equations</front>
<front id="Marlin_mainCPP-2952">               eqnBVector[abl2],     // "B" vector of Z points</front>
<front id="Marlin_mainCPP-2953">               mean = 0.0;</front>
<front id="Marlin_mainCPP-2954">        int8_t indexIntoAB[auto_bed_leveling_grid_points][auto_bed_leveling_grid_points];</front>
<front id="Marlin_mainCPP-2955">      #endif // !DELTA</front>
<front id="Marlin_mainCPP-2956"></front>
<front id="Marlin_mainCPP-2957">      int probePointCounter = 0;</front>
<front id="Marlin_mainCPP-2958">      bool zig = (auto_bed_leveling_grid_points & 1) ? true : false; //always end at [RIGHT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION]</front>
<front id="Marlin_mainCPP-2959"></front>
<front id="Marlin_mainCPP-2960">      for (int yCount = 0; yCount &lt; auto_bed_leveling_grid_points; yCount++) {</front>
<front id="Marlin_mainCPP-2961">        double yProbe = front_probe_bed_position + yGridSpacing * yCount;</front>
<front id="Marlin_mainCPP-2962">        int xStart, xStop, xInc;</front>
<front id="Marlin_mainCPP-2963"></front>
<front id="Marlin_mainCPP-2964">        if (zig) {</front>
<front id="Marlin_mainCPP-2965">          xStart = 0;</front>
<front id="Marlin_mainCPP-2966">          xStop = auto_bed_leveling_grid_points;</front>
<front id="Marlin_mainCPP-2967">          xInc = 1;</front>
<front id="Marlin_mainCPP-2968">        }</front>
<front id="Marlin_mainCPP-2969">        else {</front>
<front id="Marlin_mainCPP-2970">          xStart = auto_bed_leveling_grid_points - 1;</front>
<front id="Marlin_mainCPP-2971">          xStop = -1;</front>
<front id="Marlin_mainCPP-2972">          xInc = -1;</front>
<front id="Marlin_mainCPP-2973">        }</front>
<front id="Marlin_mainCPP-2974"></front>
<front id="Marlin_mainCPP-2975">        zig = !zig;</front>
<front id="Marlin_mainCPP-2976"></front>
<front id="Marlin_mainCPP-2977">        for (int xCount = xStart; xCount != xStop; xCount += xInc) {</front>
<front id="Marlin_mainCPP-2978">          double xProbe = left_probe_bed_position + xGridSpacing * xCount;</front>
<front id="Marlin_mainCPP-2979"></front>
<front id="Marlin_mainCPP-2980">          // raise extruder</front>
<front id="Marlin_mainCPP-2981">          float measured_z,</front>
<front id="Marlin_mainCPP-2982">                z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-2983"></front>
<front id="Marlin_mainCPP-2984">          if (probePointCounter) {</front>
<front id="Marlin_mainCPP-2985">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2986">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2987">                SERIAL_ECHOPAIR("z_before = (between) ", (float)(Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS]));</front>
<front id="Marlin_mainCPP-2988">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2989">              }</front>
<front id="Marlin_mainCPP-2990">            #endif</front>
<front id="Marlin_mainCPP-2991">          }</front>
<front id="Marlin_mainCPP-2992">          else {</front>
<front id="Marlin_mainCPP-2993">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2994">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2995">                SERIAL_ECHOPAIR("z_before = (before) ", (float)Z_RAISE_BEFORE_PROBING);</front>
<front id="Marlin_mainCPP-2996">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2997">              }</front>
<front id="Marlin_mainCPP-2998">            #endif</front>
<front id="Marlin_mainCPP-2999">          }</front>
<front id="Marlin_mainCPP-3000"></front>
<front id="Marlin_mainCPP-3001">          #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-3002">            // Avoid probing the corners (outside the round or hexagon print surface) on a delta printer.</front>
<front id="Marlin_mainCPP-3003">            float distance_from_center = sqrt(xProbe*xProbe + yProbe*yProbe);</front>
<front id="Marlin_mainCPP-3004">            if (distance_from_center &gt; DELTA_PROBABLE_RADIUS) continue;</front>
<front id="Marlin_mainCPP-3005">          #endif //DELTA</front>
<front id="Marlin_mainCPP-3006"></front>
<front id="Marlin_mainCPP-3007">          ProbeAction act;</front>
<front id="Marlin_mainCPP-3008">          if (deploy_probe_for_each_reading) // G29 E - Stow between probes</front>
<front id="Marlin_mainCPP-3009">            act = ProbeDeployAndStow;</front>
<front id="Marlin_mainCPP-3010">          else if (yCount == 0 && xCount == xStart)</front>
<front id="Marlin_mainCPP-3011">            act = ProbeDeploy;</front>
<front id="Marlin_mainCPP-3012">          else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)</front>
<front id="Marlin_mainCPP-3013">            act = ProbeStow;</front>
<front id="Marlin_mainCPP-3014">          else</front>
<front id="Marlin_mainCPP-3015">            act = ProbeStay;</front>
<front id="Marlin_mainCPP-3016"></front>
<front id="Marlin_mainCPP-3017">          measured_z = probe_pt(xProbe, yProbe, z_before, act, verbose_level);</front>
<front id="Marlin_mainCPP-3018"></front>
<front id="Marlin_mainCPP-3019">          #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-3020">            mean += measured_z;</front>
<front id="Marlin_mainCPP-3021"></front>
<front id="Marlin_mainCPP-3022">            eqnBVector[probePointCounter] = measured_z;</front>
<front id="Marlin_mainCPP-3023">            eqnAMatrix[probePointCounter + 0 * abl2] = xProbe;</front>
<front id="Marlin_mainCPP-3024">            eqnAMatrix[probePointCounter + 1 * abl2] = yProbe;</front>
<front id="Marlin_mainCPP-3025">            eqnAMatrix[probePointCounter + 2 * abl2] = 1;</front>
<front id="Marlin_mainCPP-3026">            indexIntoAB[xCount][yCount] = probePointCounter;</front>
<front id="Marlin_mainCPP-3027">          #else</front>
<front id="Marlin_mainCPP-3028">            bed_level[xCount][yCount] = measured_z + z_offset;</front>
<front id="Marlin_mainCPP-3029">          #endif</front>
<front id="Marlin_mainCPP-3030"></front>
<front id="Marlin_mainCPP-3031">          probePointCounter++;</front>
<front id="Marlin_mainCPP-3032">  </front>
<front id="Marlin_mainCPP-3033">          idle();</front>
<front id="Marlin_mainCPP-3034"></front>
<front id="Marlin_mainCPP-3035">        } //xProbe</front>
<front id="Marlin_mainCPP-3036">      } //yProbe</front>
<front id="Marlin_mainCPP-3037"></front>
<front id="Marlin_mainCPP-3038">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3039">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3040">          print_xyz("&gt; probing complete &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-3041">        }</front>
<front id="Marlin_mainCPP-3042">      #endif</front>
<front id="Marlin_mainCPP-3043"></front>
<front id="Marlin_mainCPP-3044">      clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3045"></front>
<front id="Marlin_mainCPP-3046">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-3047"></front>
<front id="Marlin_mainCPP-3048">        if (!dryrun) extrapolate_unprobed_bed_level();</front>
<front id="Marlin_mainCPP-3049">        print_bed_level();</front>
<front id="Marlin_mainCPP-3050"></front>
<front id="Marlin_mainCPP-3051">      #else // !DELTA</front>
<front id="Marlin_mainCPP-3052"></front>
<front id="Marlin_mainCPP-3053">        // solve lsq problem</front>
<front id="Marlin_mainCPP-3054">        double plane_equation_coefficients[3];</front>
<front id="Marlin_mainCPP-3055">        qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);</front>
<front id="Marlin_mainCPP-3056"></front>
<front id="Marlin_mainCPP-3057">        mean /= abl2;</front>
<front id="Marlin_mainCPP-3058"></front>
<front id="Marlin_mainCPP-3059">        if (verbose_level) {</front>
<front id="Marlin_mainCPP-3060">          SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");</front>
<front id="Marlin_mainCPP-3061">          SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);</front>
<front id="Marlin_mainCPP-3062">          SERIAL_PROTOCOLPGM(" b: ");</front>
<front id="Marlin_mainCPP-3063">          SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);</front>
<front id="Marlin_mainCPP-3064">          SERIAL_PROTOCOLPGM(" d: ");</front>
<front id="Marlin_mainCPP-3065">          SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);</front>
<front id="Marlin_mainCPP-3066">          SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3067">          if (verbose_level &gt; 2) {</front>
<front id="Marlin_mainCPP-3068">            SERIAL_PROTOCOLPGM("Mean of sampled points: ");</front>
<front id="Marlin_mainCPP-3069">            SERIAL_PROTOCOL_F(mean, 8);</front>
<front id="Marlin_mainCPP-3070">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3071">          }</front>
<front id="Marlin_mainCPP-3072">        }</front>
<front id="Marlin_mainCPP-3073"></front>
<front id="Marlin_mainCPP-3074">        if (!dryrun) set_bed_level_equation_lsq(plane_equation_coefficients);</front>
<front id="Marlin_mainCPP-3075"></front>
<front id="Marlin_mainCPP-3076">        // Show the Topography map if enabled</front>
<front id="Marlin_mainCPP-3077">        if (do_topography_map) {</front>
<front id="Marlin_mainCPP-3078"></front>
<front id="Marlin_mainCPP-3079">          SERIAL_PROTOCOLPGM(" \nBed Height Topography: \n");</front>
<front id="Marlin_mainCPP-3080">          SERIAL_PROTOCOLPGM("+-----------+\n");</front>
<front id="Marlin_mainCPP-3081">          SERIAL_PROTOCOLPGM("|...Back....|\n");</front>
<front id="Marlin_mainCPP-3082">          SERIAL_PROTOCOLPGM("|Left..Right|\n");</front>
<front id="Marlin_mainCPP-3083">          SERIAL_PROTOCOLPGM("|...Front...|\n");</front>
<front id="Marlin_mainCPP-3084">          SERIAL_PROTOCOLPGM("+-----------+\n");</front>
<front id="Marlin_mainCPP-3085"></front>
<front id="Marlin_mainCPP-3086">          float min_diff = 999;</front>
<front id="Marlin_mainCPP-3087"></front>
<front id="Marlin_mainCPP-3088">          for (int yy = auto_bed_leveling_grid_points - 1; yy &gt;= 0; yy--) {</front>
<front id="Marlin_mainCPP-3089">            for (int xx = 0; xx &lt; auto_bed_leveling_grid_points; xx++) {</front>
<front id="Marlin_mainCPP-3090">              int ind = indexIntoAB[xx][yy];</front>
<front id="Marlin_mainCPP-3091">              float diff = eqnBVector[ind] - mean;</front>
<front id="Marlin_mainCPP-3092"></front>
<front id="Marlin_mainCPP-3093">              float x_tmp = eqnAMatrix[ind + 0 * abl2],</front>
<front id="Marlin_mainCPP-3094">                y_tmp = eqnAMatrix[ind + 1 * abl2],</front>
<front id="Marlin_mainCPP-3095">                z_tmp = 0;</front>
<front id="Marlin_mainCPP-3096"></front>
<front id="Marlin_mainCPP-3097">              apply_rotation_xyz(plan_bed_level_matrix,x_tmp,y_tmp,z_tmp);</front>
<front id="Marlin_mainCPP-3098"></front>
<front id="Marlin_mainCPP-3099">              if (eqnBVector[ind] - z_tmp &lt; min_diff)</front>
<front id="Marlin_mainCPP-3100">                min_diff = eqnBVector[ind] - z_tmp;</front>
<front id="Marlin_mainCPP-3101"></front>
<front id="Marlin_mainCPP-3102">              if (diff &gt;= 0.0)</front>
<front id="Marlin_mainCPP-3103">                SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment</front>
<front id="Marlin_mainCPP-3104">              else</front>
<front id="Marlin_mainCPP-3105">                SERIAL_PROTOCOLCHAR(' ');</front>
<front id="Marlin_mainCPP-3106">              SERIAL_PROTOCOL_F(diff, 5);</front>
<front id="Marlin_mainCPP-3107">            } // xx</front>
<front id="Marlin_mainCPP-3108">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3109">          } // yy</front>
<front id="Marlin_mainCPP-3110">          SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3111">          if (verbose_level &gt; 3) {</front>
<front id="Marlin_mainCPP-3112">            SERIAL_PROTOCOLPGM(" \nCorrected Bed Height vs. Bed Topology: \n");</front>
<front id="Marlin_mainCPP-3113"></front>
<front id="Marlin_mainCPP-3114">            for (int yy = auto_bed_leveling_grid_points - 1; yy &gt;= 0; yy--) {</front>
<front id="Marlin_mainCPP-3115">              for (int xx = 0; xx &lt; auto_bed_leveling_grid_points; xx++) {</front>
<front id="Marlin_mainCPP-3116">                int ind = indexIntoAB[xx][yy];</front>
<front id="Marlin_mainCPP-3117">                float x_tmp = eqnAMatrix[ind + 0 * abl2],</front>
<front id="Marlin_mainCPP-3118">                  y_tmp = eqnAMatrix[ind + 1 * abl2],</front>
<front id="Marlin_mainCPP-3119">                  z_tmp = 0;</front>
<front id="Marlin_mainCPP-3120"></front>
<front id="Marlin_mainCPP-3121">                apply_rotation_xyz(plan_bed_level_matrix,x_tmp,y_tmp,z_tmp);</front>
<front id="Marlin_mainCPP-3122"></front>
<front id="Marlin_mainCPP-3123">                float diff = eqnBVector[ind] - z_tmp - min_diff;</front>
<front id="Marlin_mainCPP-3124">                if (diff &gt;= 0.0)</front>
<front id="Marlin_mainCPP-3125">                  SERIAL_PROTOCOLPGM(" +");</front>
<front id="Marlin_mainCPP-3126">                // Include + for column alignment</front>
<front id="Marlin_mainCPP-3127">                else</front>
<front id="Marlin_mainCPP-3128">                  SERIAL_PROTOCOLCHAR(' ');</front>
<front id="Marlin_mainCPP-3129">                SERIAL_PROTOCOL_F(diff, 5);</front>
<front id="Marlin_mainCPP-3130">              } // xx</front>
<front id="Marlin_mainCPP-3131">              SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3132">            } // yy</front>
<front id="Marlin_mainCPP-3133">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3134">          }</front>
<front id="Marlin_mainCPP-3135">        } //do_topography_map</front>
<front id="Marlin_mainCPP-3136">      #endif //!DELTA</front>
<front id="Marlin_mainCPP-3137"></front>
<front id="Marlin_mainCPP-3138">    #else // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-3139"></front>
<front id="Marlin_mainCPP-3140">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3141">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3142">          SERIAL_ECHOLNPGM("&gt; 3-point Leveling");</front>
<front id="Marlin_mainCPP-3143">        }</front>
<front id="Marlin_mainCPP-3144">      #endif</front>
<front id="Marlin_mainCPP-3145"></front>
<front id="Marlin_mainCPP-3146">      // Actions for each probe</front>
<front id="Marlin_mainCPP-3147">      ProbeAction p1, p2, p3;</front>
<front id="Marlin_mainCPP-3148">      if (deploy_probe_for_each_reading)</front>
<front id="Marlin_mainCPP-3149">        p1 = p2 = p3 = ProbeDeployAndStow;</front>
<front id="Marlin_mainCPP-3150">      else</front>
<front id="Marlin_mainCPP-3151">        p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;</front>
<front id="Marlin_mainCPP-3152"></front>
<front id="Marlin_mainCPP-3153">      // Probe at 3 arbitrary points</front>
<front id="Marlin_mainCPP-3154">      float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING, p1, verbose_level),</front>
<front id="Marlin_mainCPP-3155">            z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p2, verbose_level),</front>
<front id="Marlin_mainCPP-3156">            z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p3, verbose_level);</front>
<front id="Marlin_mainCPP-3157">      clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3158">      if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);</front>
<front id="Marlin_mainCPP-3159"></front>
<front id="Marlin_mainCPP-3160">    #endif // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-3161"></front>
<front id="Marlin_mainCPP-3162">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-3163">      // Allen Key Probe for Delta</front>
<front id="Marlin_mainCPP-3164">      #if ENABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-3165">        stow_z_probe();</front>
<front id="Marlin_mainCPP-3166">      #elif Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-3167">        raise_z_after_probing();</front>
<front id="Marlin_mainCPP-3168">      #endif</front>
<front id="Marlin_mainCPP-3169">    #else // !DELTA</front>
<front id="Marlin_mainCPP-3170">      if (verbose_level &gt; 0)</front>
<front id="Marlin_mainCPP-3171">        plan_bed_level_matrix.debug(" \n\nBed Level Correction Matrix:");</front>
<front id="Marlin_mainCPP-3172"></front>
<front id="Marlin_mainCPP-3173">      if (!dryrun) {</front>
<front id="Marlin_mainCPP-3174">        // Correct the Z height difference from Z probe position and nozzle tip position.</front>
<front id="Marlin_mainCPP-3175">        // The Z height on homing is measured by Z probe, but the Z probe is quite far from the nozzle.</front>
<front id="Marlin_mainCPP-3176">        // When the bed is uneven, this height must be corrected.</front>
<front id="Marlin_mainCPP-3177">        float x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,</front>
<front id="Marlin_mainCPP-3178">              y_tmp = current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER,</front>
<front id="Marlin_mainCPP-3179">              z_tmp = current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-3180">              real_z = st_get_position_mm(Z_AXIS);  //get the real Z (since plan_get_position is now correcting the plane)</front>
<front id="Marlin_mainCPP-3181"></front>
<front id="Marlin_mainCPP-3182">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3183">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3184">            SERIAL_ECHOPAIR("&gt; BEFORE apply_rotation_xyz &gt; z_tmp  = ", z_tmp);</front>
<front id="Marlin_mainCPP-3185">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3186">            SERIAL_ECHOPAIR("&gt; BEFORE apply_rotation_xyz &gt; real_z = ", real_z);</front>
<front id="Marlin_mainCPP-3187">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3188">          }</front>
<front id="Marlin_mainCPP-3189">        #endif</front>
<front id="Marlin_mainCPP-3190"></front>
<front id="Marlin_mainCPP-3191">        apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp); // Apply the correction sending the Z probe offset</front>
<front id="Marlin_mainCPP-3192"></front>
<front id="Marlin_mainCPP-3193">        // Get the current Z position and send it to the planner.</front>
<front id="Marlin_mainCPP-3194">        //</front>
<front id="Marlin_mainCPP-3195">        // &gt;&gt; (z_tmp - real_z) : The rotated current Z minus the uncorrected Z (most recent plan_set_position/sync_plan_position)</front>
<front id="Marlin_mainCPP-3196">        //</front>
<front id="Marlin_mainCPP-3197">        // &gt;&gt; zprobe_zoffset : Z distance from nozzle to Z probe (set by default, M851, EEPROM, or Menu)</front>
<front id="Marlin_mainCPP-3198">        //</front>
<front id="Marlin_mainCPP-3199">        // &gt;&gt; Z_RAISE_AFTER_PROBING : The distance the Z probe will have lifted after the last probe</front>
<front id="Marlin_mainCPP-3200">        //</front>
<front id="Marlin_mainCPP-3201">        // &gt;&gt; Should home_offset[Z_AXIS] be included?</front>
<front id="Marlin_mainCPP-3202">        //</front>
<front id="Marlin_mainCPP-3203">        //      Discussion: home_offset[Z_AXIS] was applied in G28 to set the starting Z.</front>
<front id="Marlin_mainCPP-3204">        //      If Z is not tweaked in G29 -and- the Z probe in G29 is not actually "homing" Z...</front>
<front id="Marlin_mainCPP-3205">        //      then perhaps it should not be included here. The purpose of home_offset[] is to</front>
<front id="Marlin_mainCPP-3206">        //      adjust for inaccurate endstops, not for reasonably accurate probes. If it were</front>
<front id="Marlin_mainCPP-3207">        //      added here, it could be seen as a compensating factor for the Z probe.</front>
<front id="Marlin_mainCPP-3208">        //</front>
<front id="Marlin_mainCPP-3209">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3210">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3211">            SERIAL_ECHOPAIR("&gt; AFTER apply_rotation_xyz &gt; z_tmp  = ", z_tmp);</front>
<front id="Marlin_mainCPP-3212">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3213">          }</front>
<front id="Marlin_mainCPP-3214">        #endif</front>
<front id="Marlin_mainCPP-3215"></front>
<front id="Marlin_mainCPP-3216">        current_position[Z_AXIS] = -zprobe_zoffset + (z_tmp - real_z)</front>
<front id="Marlin_mainCPP-3217">          #if HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-3218">             + Z_RAISE_AFTER_PROBING</front>
<front id="Marlin_mainCPP-3219">          #endif</front>
<front id="Marlin_mainCPP-3220">          ;</front>
<front id="Marlin_mainCPP-3221">        // current_position[Z_AXIS] += home_offset[Z_AXIS]; // The Z probe determines Z=0, not "Z home"</front>
<front id="Marlin_mainCPP-3222">        sync_plan_position();</front>
<front id="Marlin_mainCPP-3223"></front>
<front id="Marlin_mainCPP-3224">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3225">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3226">            print_xyz("&gt; corrected Z in G29", current_position);</front>
<front id="Marlin_mainCPP-3227">          }</front>
<front id="Marlin_mainCPP-3228">        #endif</front>
<front id="Marlin_mainCPP-3229">      }</front>
<front id="Marlin_mainCPP-3230"></front>
<front id="Marlin_mainCPP-3231">      // Sled assembly for Cartesian bots</front>
<front id="Marlin_mainCPP-3232">      #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-3233">        dock_sled(true); // dock the sled</front>
<front id="Marlin_mainCPP-3234">      #endif</front>
<front id="Marlin_mainCPP-3235"></front>
<front id="Marlin_mainCPP-3236">    #endif // !DELTA</front>
<front id="Marlin_mainCPP-3237"></front>
<front id="Marlin_mainCPP-3238">    #ifdef Z_PROBE_END_SCRIPT</front>
<front id="Marlin_mainCPP-3239">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3240">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3241">          SERIAL_ECHO("Z Probe End Script: ");</front>
<front id="Marlin_mainCPP-3242">          SERIAL_ECHOLNPGM(Z_PROBE_END_SCRIPT);</front>
<front id="Marlin_mainCPP-3243">        }</front>
<front id="Marlin_mainCPP-3244">      #endif</front>
<front id="Marlin_mainCPP-3245">      enqueuecommands_P(PSTR(Z_PROBE_END_SCRIPT));</front>
<front id="Marlin_mainCPP-3246">      st_synchronize();</front>
<front id="Marlin_mainCPP-3247">    #endif</front>
<front id="Marlin_mainCPP-3248"></front>
<front id="Marlin_mainCPP-3249">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3250">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3251">        SERIAL_ECHOLNPGM("&lt;&lt;&lt; gcode_G29");</front>
<front id="Marlin_mainCPP-3252">      }</front>
<front id="Marlin_mainCPP-3253">    #endif</front>
<front id="Marlin_mainCPP-3254"></front>
<front id="Marlin_mainCPP-3255">    #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-3256">      current_layer = 0;</front>
<front id="Marlin_mainCPP-3257">      last_layer_z = 0;</front>
<front id="Marlin_mainCPP-3258">    #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-3259">  }</front>
<front id="Marlin_mainCPP-3260"></front>
<front id="Marlin_mainCPP-3261">  #if DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-3262"></front>
<front id="Marlin_mainCPP-3263">    /**</front>
<front id="Marlin_mainCPP-3264">     * G30: Do a single Z probe at the current XY</front>
<front id="Marlin_mainCPP-3265">     */</front>
<front id="Marlin_mainCPP-3266">    inline void gcode_G30() {</front>
<front id="Marlin_mainCPP-3267">      #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-3268">        raise_z_for_servo();</front>
<front id="Marlin_mainCPP-3269">      #endif</front>
<front id="Marlin_mainCPP-3270">      deploy_z_probe(); // Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-3271"></front>
<front id="Marlin_mainCPP-3272">      st_synchronize();</front>
<front id="Marlin_mainCPP-3273">      // TODO: clear the leveling matrix or the planner will be set incorrectly</front>
<front id="Marlin_mainCPP-3274">      setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-3275"></front>
<front id="Marlin_mainCPP-3276">      feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-3277"></front>
<front id="Marlin_mainCPP-3278">      run_z_probe();</front>
<front id="Marlin_mainCPP-3279">      SERIAL_PROTOCOLPGM("Bed X: ");</front>
<front id="Marlin_mainCPP-3280">      SERIAL_PROTOCOL(current_position[X_AXIS] + 0.0001);</front>
<front id="Marlin_mainCPP-3281">      SERIAL_PROTOCOLPGM(" Y: ");</front>
<front id="Marlin_mainCPP-3282">      SERIAL_PROTOCOL(current_position[Y_AXIS] + 0.0001);</front>
<front id="Marlin_mainCPP-3283">      SERIAL_PROTOCOLPGM(" Z: ");</front>
<front id="Marlin_mainCPP-3284">      SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);</front>
<front id="Marlin_mainCPP-3285">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3286"></front>
<front id="Marlin_mainCPP-3287">      clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3288"></front>
<front id="Marlin_mainCPP-3289">      #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-3290">        raise_z_for_servo();</front>
<front id="Marlin_mainCPP-3291">      #endif</front>
<front id="Marlin_mainCPP-3292">      stow_z_probe(false); // Retract Z Servo endstop if available</front>
<front id="Marlin_mainCPP-3293">    }</front>
<front id="Marlin_mainCPP-3294"></front>
<front id="Marlin_mainCPP-3295">  #endif //!Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-3296"></front>
<front id="Marlin_mainCPP-3297">#endif //AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-3298"></front>
<front id="Marlin_mainCPP-3299">/**</front>
<front id="Marlin_mainCPP-3300"> * G92: Set current position to given X Y Z E</front>
<front id="Marlin_mainCPP-3301"> */</front>
<front id="Marlin_mainCPP-3302">inline void gcode_G92() {</front>
<front id="Marlin_mainCPP-3303">  if (!code_seen(axis_codes[E_AXIS]))</front>
<front id="Marlin_mainCPP-3304">    st_synchronize();</front>
<front id="Marlin_mainCPP-3305"></front>
<front id="Marlin_mainCPP-3306">  bool didXYZ = false;</front>
<front id="Marlin_mainCPP-3307">  for (int i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-3308">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-3309">      float v = current_position[i] = code_value();</front>
<front id="Marlin_mainCPP-3310">      if (i == E_AXIS)</front>
<front id="Marlin_mainCPP-3311">        plan_set_e_position(v);</front>
<front id="Marlin_mainCPP-3312">      else</front>
<front id="Marlin_mainCPP-3313">        didXYZ = true;</front>
<front id="Marlin_mainCPP-3314">    }</front>
<front id="Marlin_mainCPP-3315">  }</front>
<front id="Marlin_mainCPP-3316">  if (didXYZ) {</front>
<front id="Marlin_mainCPP-3317">    #if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-3318">      sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-3319">    #else</front>
<front id="Marlin_mainCPP-3320">      sync_plan_position();</front>
<front id="Marlin_mainCPP-3321">    #endif</front>
<front id="Marlin_mainCPP-3322">  }</front>
<front id="Marlin_mainCPP-3323">}</front>
<front id="Marlin_mainCPP-3324"></front>
<front id="Marlin_mainCPP-3325">#if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-3326"></front>
<front id="Marlin_mainCPP-3327">  /**</front>
<front id="Marlin_mainCPP-3328">   * M0: // M0 - Unconditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-3329">   * M1: // M1 - Conditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-3330">   */</front>
<front id="Marlin_mainCPP-3331">  inline void gcode_M0_M1() {</front>
<front id="Marlin_mainCPP-3332">    char *args = current_command_args;</front>
<front id="Marlin_mainCPP-3333"></front>
<front id="Marlin_mainCPP-3334">    millis_t codenum = 0;</front>
<front id="Marlin_mainCPP-3335">    bool hasP = false, hasS = false;</front>
<front id="Marlin_mainCPP-3336">    if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-3337">      codenum = code_value_short(); // milliseconds to wait</front>
<front id="Marlin_mainCPP-3338">      hasP = codenum &gt; 0;</front>
<front id="Marlin_mainCPP-3339">    }</front>
<front id="Marlin_mainCPP-3340">    if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-3341">      codenum = code_value() * 1000; // seconds to wait</front>
<front id="Marlin_mainCPP-3342">      hasS = codenum &gt; 0;</front>
<front id="Marlin_mainCPP-3343">    }</front>
<front id="Marlin_mainCPP-3344"></front>
<front id="Marlin_mainCPP-3345">    if (!hasP && !hasS && *args != '\0')</front>
<front id="Marlin_mainCPP-3346">      lcd_setstatus(args, true);</front>
<front id="Marlin_mainCPP-3347">    else {</front>
<front id="Marlin_mainCPP-3348">      LCD_MESSAGEPGM(MSG_USERWAIT);</front>
<front id="Marlin_mainCPP-3349">      #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="Marlin_mainCPP-3350">        dontExpireStatus();</front>
<front id="Marlin_mainCPP-3351">      #endif</front>
<front id="Marlin_mainCPP-3352">    }</front>
<front id="Marlin_mainCPP-3353"></front>
<front id="Marlin_mainCPP-3354">    lcd_ignore_click();</front>
<front id="Marlin_mainCPP-3355">    st_synchronize();</front>
<front id="Marlin_mainCPP-3356">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-3357">    if (codenum &gt; 0) {</front>
<front id="Marlin_mainCPP-3358">      codenum += previous_cmd_ms;  // wait until this time for a click</front>
<front id="Marlin_mainCPP-3359">      while (millis() &lt; codenum && !lcd_clicked()) idle();</front>
<front id="Marlin_mainCPP-3360">      lcd_ignore_click(false);</front>
<front id="Marlin_mainCPP-3361">    }</front>
<front id="Marlin_mainCPP-3362">    else {</front>
<front id="Marlin_mainCPP-3363">      if (!lcd_detected()) return;</front>
<front id="Marlin_mainCPP-3364">      while (!lcd_clicked()) idle();</front>
<front id="Marlin_mainCPP-3365">    }</front>
<front id="Marlin_mainCPP-3366">    if (IS_SD_PRINTING)</front>
<front id="Marlin_mainCPP-3367">      LCD_MESSAGEPGM(MSG_RESUMING);</front>
<front id="Marlin_mainCPP-3368">    else</front>
<front id="Marlin_mainCPP-3369">      LCD_MESSAGEPGM(WELCOME_MSG);</front>
<front id="Marlin_mainCPP-3370">  }</front>
<front id="Marlin_mainCPP-3371"></front>
<front id="Marlin_mainCPP-3372">#endif // ULTIPANEL</front>
<front id="Marlin_mainCPP-3373"></front>
<front id="Marlin_mainCPP-3374">/**</front>
<front id="Marlin_mainCPP-3375"> * M17: Enable power on all stepper motors</front>
<front id="Marlin_mainCPP-3376"> */</front>
<front id="Marlin_mainCPP-3377">inline void gcode_M17() {</front>
<front id="Marlin_mainCPP-3378">  LCD_MESSAGEPGM(MSG_NO_MOVE);</front>
<front id="Marlin_mainCPP-3379">  enable_all_steppers();</front>
<front id="Marlin_mainCPP-3380">}</front>
<front id="Marlin_mainCPP-3381"></front>
<front id="Marlin_mainCPP-3382">#if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-3383">  inline void gcode_M19() {</front>
<front id="Marlin_mainCPP-3384">    if (code_seen('Z')) {</front>
<front id="Marlin_mainCPP-3385">      gcode_get_destination(); // For Z</front>
<front id="Marlin_mainCPP-3386">      prepare_move();</front>
<front id="Marlin_mainCPP-3387">      enqueuecommands_P(PSTR("M114")); // tell the host where it is</front>
<front id="Marlin_mainCPP-3388">    }</front>
<front id="Marlin_mainCPP-3389"></front>
<front id="Marlin_mainCPP-3390">    if (current_position[Z_AXIS] &gt; 0) {</front>
<front id="Marlin_mainCPP-3391">      planner_disabled_below_z = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-3392"></front>
<front id="Marlin_mainCPP-3393">      SERIAL_PROTOCOLPGM("Resume from Z = ");</front>
<front id="Marlin_mainCPP-3394">      SERIAL_PROTOCOL(planner_disabled_below_z);</front>
<front id="Marlin_mainCPP-3395">      SERIAL_PROTOCOLPGM(" mm\n");</front>
<front id="Marlin_mainCPP-3396">    }</front>
<front id="Marlin_mainCPP-3397">    else</front>
<front id="Marlin_mainCPP-3398">      SERIAL_PROTOCOLPGM("Error: Resume from Z &lt;= 0\n");</front>
<front id="Marlin_mainCPP-3399">  }</front>
<front id="Marlin_mainCPP-3400">#endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-3401"></front>
<front id="Marlin_mainCPP-3402">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-3403"></front>
<front id="Marlin_mainCPP-3404">  /**</front>
<front id="Marlin_mainCPP-3405">   * M20: List SD card to serial output</front>
<front id="Marlin_mainCPP-3406">   */</front>
<front id="Marlin_mainCPP-3407">  inline void gcode_M20() {</front>
<front id="Marlin_mainCPP-3408">    SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);</front>
<front id="Marlin_mainCPP-3409">    card.ls();</front>
<front id="Marlin_mainCPP-3410">    SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);</front>
<front id="Marlin_mainCPP-3411">  }</front>
<front id="Marlin_mainCPP-3412"></front>
<front id="Marlin_mainCPP-3413">  /**</front>
<front id="Marlin_mainCPP-3414">   * M21: Init SD Card</front>
<front id="Marlin_mainCPP-3415">   */</front>
<front id="Marlin_mainCPP-3416">  inline void gcode_M21() {</front>
<front id="Marlin_mainCPP-3417">    card.initsd();</front>
<front id="Marlin_mainCPP-3418">  }</front>
<front id="Marlin_mainCPP-3419"></front>
<front id="Marlin_mainCPP-3420">  /**</front>
<front id="Marlin_mainCPP-3421">   * M22: Release SD Card</front>
<front id="Marlin_mainCPP-3422">   */</front>
<front id="Marlin_mainCPP-3423">  inline void gcode_M22() {</front>
<front id="Marlin_mainCPP-3424">    card.release();</front>
<front id="Marlin_mainCPP-3425">  }</front>
<front id="Marlin_mainCPP-3426"></front>
<front id="Marlin_mainCPP-3427">  /**</front>
<front id="Marlin_mainCPP-3428">   * M23: Select a file</front>
<front id="Marlin_mainCPP-3429">   */</front>
<front id="Marlin_mainCPP-3430">  inline void gcode_M23() {</front>
<front id="Marlin_mainCPP-3431">    card.openFile(current_command_args, true);</front>
<front id="Marlin_mainCPP-3432">  }</front>
<front id="Marlin_mainCPP-3433"></front>
<front id="Marlin_mainCPP-3434">  /**</front>
<front id="Marlin_mainCPP-3435">   * M24: Start SD Print</front>
<front id="Marlin_mainCPP-3436">   */</front>
<front id="Marlin_mainCPP-3437">  inline void gcode_M24() {</front>
<front id="Marlin_mainCPP-3438">    card.startFileprint();</front>
<front id="Marlin_mainCPP-3439">    #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-3440">      current_layer = 0;</front>
<front id="Marlin_mainCPP-3441">      last_layer_z = 0;</front>
<front id="Marlin_mainCPP-3442">    #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-3443">    print_job_start_ms = millis();</front>
<front id="Marlin_mainCPP-3444">  }</front>
<front id="Marlin_mainCPP-3445"></front>
<front id="Marlin_mainCPP-3446">  /**</front>
<front id="Marlin_mainCPP-3447">   * M25: Pause SD Print</front>
<front id="Marlin_mainCPP-3448">   */</front>
<front id="Marlin_mainCPP-3449">  inline void gcode_M25() {</front>
<front id="Marlin_mainCPP-3450">    card.pauseSDPrint();</front>
<front id="Marlin_mainCPP-3451">  }</front>
<front id="Marlin_mainCPP-3452"></front>
<front id="Marlin_mainCPP-3453">  /**</front>
<front id="Marlin_mainCPP-3454">   * M26: Set SD Card file index</front>
<front id="Marlin_mainCPP-3455">   */</front>
<front id="Marlin_mainCPP-3456">  inline void gcode_M26() {</front>
<front id="Marlin_mainCPP-3457">    if (card.cardOK && code_seen('S'))</front>
<front id="Marlin_mainCPP-3458">      card.setIndex(code_value_short());</front>
<front id="Marlin_mainCPP-3459">  }</front>
<front id="Marlin_mainCPP-3460"></front>
<front id="Marlin_mainCPP-3461">  /**</front>
<front id="Marlin_mainCPP-3462">   * M27: Get SD Card status</front>
<front id="Marlin_mainCPP-3463">   */</front>
<front id="Marlin_mainCPP-3464">  inline void gcode_M27() {</front>
<front id="Marlin_mainCPP-3465">    card.getStatus();</front>
<front id="Marlin_mainCPP-3466">  }</front>
<front id="Marlin_mainCPP-3467"></front>
<front id="Marlin_mainCPP-3468">  /**</front>
<front id="Marlin_mainCPP-3469">   * M28: Start SD Write</front>
<front id="Marlin_mainCPP-3470">   */</front>
<front id="Marlin_mainCPP-3471">  inline void gcode_M28() {</front>
<front id="Marlin_mainCPP-3472">    card.openFile(current_command_args, false);</front>
<front id="Marlin_mainCPP-3473">  }</front>
<front id="Marlin_mainCPP-3474"></front>
<front id="Marlin_mainCPP-3475">  /**</front>
<front id="Marlin_mainCPP-3476">   * M29: Stop SD Write</front>
<front id="Marlin_mainCPP-3477">   * Processed in write to file routine above</front>
<front id="Marlin_mainCPP-3478">   */</front>
<front id="Marlin_mainCPP-3479">  inline void gcode_M29() {</front>
<front id="Marlin_mainCPP-3480">    // card.saving = false;</front>
<front id="Marlin_mainCPP-3481">  }</front>
<front id="Marlin_mainCPP-3482"></front>
<front id="Marlin_mainCPP-3483">  /**</front>
<front id="Marlin_mainCPP-3484">   * M30 &lt;filename&gt;: Delete SD Card file</front>
<front id="Marlin_mainCPP-3485">   */</front>
<front id="Marlin_mainCPP-3486">  inline void gcode_M30() {</front>
<front id="Marlin_mainCPP-3487">    if (card.cardOK) {</front>
<front id="Marlin_mainCPP-3488">      card.closefile();</front>
<front id="Marlin_mainCPP-3489">      card.removeFile(current_command_args);</front>
<front id="Marlin_mainCPP-3490">    }</front>
<front id="Marlin_mainCPP-3491">  }</front>
<front id="Marlin_mainCPP-3492"></front>
<front id="Marlin_mainCPP-3493">#endif</front>
<front id="Marlin_mainCPP-3494"></front>
<front id="Marlin_mainCPP-3495">/**</front>
<front id="Marlin_mainCPP-3496"> * M31: Get the time since the start of SD Print (or last M109)</front>
<front id="Marlin_mainCPP-3497"> */</front>
<front id="Marlin_mainCPP-3498">inline void gcode_M31() {</front>
<front id="Marlin_mainCPP-3499">  print_job_stop_ms = millis();</front>
<front id="Marlin_mainCPP-3500">  millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;</front>
<front id="Marlin_mainCPP-3501">  int min = t / 60, sec = t % 60;</front>
<front id="Marlin_mainCPP-3502">  char time[30];</front>
<front id="Marlin_mainCPP-3503">  sprintf_P(time, PSTR("%i min, %i sec"), min, sec);</front>
<front id="Marlin_mainCPP-3504">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-3505">  SERIAL_ECHOLN(time);</front>
<front id="Marlin_mainCPP-3506">  lcd_setstatus(time);</front>
<front id="Marlin_mainCPP-3507">  autotempShutdown();</front>
<front id="Marlin_mainCPP-3508">}</front>
<front id="Marlin_mainCPP-3509"></front>
<front id="Marlin_mainCPP-3510">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-3511"></front>
<front id="Marlin_mainCPP-3512">  /**</front>
<front id="Marlin_mainCPP-3513">   * M32: Select file and start SD Print</front>
<front id="Marlin_mainCPP-3514">   */</front>
<front id="Marlin_mainCPP-3515">  inline void gcode_M32() {</front>
<front id="Marlin_mainCPP-3516">    if (card.sdprinting)</front>
<front id="Marlin_mainCPP-3517">      st_synchronize();</front>
<front id="Marlin_mainCPP-3518"></front>
<front id="Marlin_mainCPP-3519">    char* namestartpos = strchr(current_command_args, '!');  // Find ! to indicate filename string start.</front>
<front id="Marlin_mainCPP-3520">    if (!namestartpos)</front>
<front id="Marlin_mainCPP-3521">      namestartpos = current_command_args; // Default name position, 4 letters after the M</front>
<front id="Marlin_mainCPP-3522">    else</front>
<front id="Marlin_mainCPP-3523">      namestartpos++; //to skip the '!'</front>
<front id="Marlin_mainCPP-3524"></front>
<front id="Marlin_mainCPP-3525">    bool call_procedure = code_seen('P') && (seen_pointer &lt; namestartpos);</front>
<front id="Marlin_mainCPP-3526"></front>
<front id="Marlin_mainCPP-3527">    if (card.cardOK) {</front>
<front id="Marlin_mainCPP-3528">      card.openFile(namestartpos, true, !call_procedure);</front>
<front id="Marlin_mainCPP-3529"></front>
<front id="Marlin_mainCPP-3530">      if (code_seen('S') && seen_pointer &lt; namestartpos) // "S" (must occur _before_ the filename!)</front>
<front id="Marlin_mainCPP-3531">        card.setIndex(code_value_short());</front>
<front id="Marlin_mainCPP-3532"></front>
<front id="Marlin_mainCPP-3533">      card.startFileprint();</front>
<front id="Marlin_mainCPP-3534">      if (!call_procedure)</front>
<front id="Marlin_mainCPP-3535">        print_job_start_ms = millis(); //procedure calls count as normal print time.</front>
<front id="Marlin_mainCPP-3536">    }</front>
<front id="Marlin_mainCPP-3537">  }</front>
<front id="Marlin_mainCPP-3538"></front>
<front id="Marlin_mainCPP-3539">  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)</front>
<front id="Marlin_mainCPP-3540"></front>
<front id="Marlin_mainCPP-3541">    /**</front>
<front id="Marlin_mainCPP-3542">     * M33: Get the long full path of a file or folder</front>
<front id="Marlin_mainCPP-3543">     *</front>
<front id="Marlin_mainCPP-3544">     * Parameters:</front>
<front id="Marlin_mainCPP-3545">     *   &lt;dospath&gt; Case-insensitive DOS-style path to a file or folder</front>
<front id="Marlin_mainCPP-3546">     *</front>
<front id="Marlin_mainCPP-3547">     * Example:</front>
<front id="Marlin_mainCPP-3548">     *   M33 miscel~1/armchair/armcha~1.gco</front>
<front id="Marlin_mainCPP-3549">     *</front>
<front id="Marlin_mainCPP-3550">     * Output:</front>
<front id="Marlin_mainCPP-3551">     *   /Miscellaneous/Armchair/Armchair.gcode</front>
<front id="Marlin_mainCPP-3552">     */</front>
<front id="Marlin_mainCPP-3553">    inline void gcode_M33() {</front>
<front id="Marlin_mainCPP-3554">      card.printLongPath(current_command_args);</front>
<front id="Marlin_mainCPP-3555">    }</front>
<front id="Marlin_mainCPP-3556"></front>
<front id="Marlin_mainCPP-3557">  #endif</front>
<front id="Marlin_mainCPP-3558"></front>
<front id="Marlin_mainCPP-3559">  /**</front>
<front id="Marlin_mainCPP-3560">   * M928: Start SD Write</front>
<front id="Marlin_mainCPP-3561">   */</front>
<front id="Marlin_mainCPP-3562">  inline void gcode_M928() {</front>
<front id="Marlin_mainCPP-3563">    card.openLogFile(current_command_args);</front>
<front id="Marlin_mainCPP-3564">  }</front>
<front id="Marlin_mainCPP-3565"></front>
<front id="Marlin_mainCPP-3566">#endif // SDSUPPORT</front>
<front id="Marlin_mainCPP-3567"></front>
<front id="Marlin_mainCPP-3568">/**</front>
<front id="Marlin_mainCPP-3569"> * M42: Change pin status via GCode</front>
<front id="Marlin_mainCPP-3570"> */</front>
<front id="Marlin_mainCPP-3571">inline void gcode_M42() {</front>
<front id="Marlin_mainCPP-3572">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-3573">    int pin_status = code_value_short(),</front>
<front id="Marlin_mainCPP-3574">        pin_number = LED_PIN;</front>
<front id="Marlin_mainCPP-3575"></front>
<front id="Marlin_mainCPP-3576">    if (code_seen('P') && pin_status &gt;= 0 && pin_status &lt;= 255)</front>
<front id="Marlin_mainCPP-3577">      pin_number = code_value_short();</front>
<front id="Marlin_mainCPP-3578"></front>
<front id="Marlin_mainCPP-3579">    for (uint8_t i = 0; i &lt; COUNT(sensitive_pins); i++) {</front>
<front id="Marlin_mainCPP-3580">      if (sensitive_pins[i] == pin_number) {</front>
<front id="Marlin_mainCPP-3581">        pin_number = -1;</front>
<front id="Marlin_mainCPP-3582">        break;</front>
<front id="Marlin_mainCPP-3583">      }</front>
<front id="Marlin_mainCPP-3584">    }</front>
<front id="Marlin_mainCPP-3585"></front>
<front id="Marlin_mainCPP-3586">    #if HAS_FAN</front>
<front id="Marlin_mainCPP-3587">      if (pin_number == FAN_PIN) fanSpeed = pin_status;</front>
<front id="Marlin_mainCPP-3588">    #endif</front>
<front id="Marlin_mainCPP-3589"></front>
<front id="Marlin_mainCPP-3590">    if (pin_number &gt; -1) {</front>
<front id="Marlin_mainCPP-3591">      pinMode(pin_number, OUTPUT);</front>
<front id="Marlin_mainCPP-3592">      digitalWrite(pin_number, pin_status);</front>
<front id="Marlin_mainCPP-3593">      analogWrite(pin_number, pin_status);</front>
<front id="Marlin_mainCPP-3594">    }</front>
<front id="Marlin_mainCPP-3595">  } // code_seen('S')</front>
<front id="Marlin_mainCPP-3596">}</front>
<front id="Marlin_mainCPP-3597"></front>
<front id="Marlin_mainCPP-3598">#if ENABLED(AUTO_BED_LEVELING_FEATURE) && ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)</front>
<front id="Marlin_mainCPP-3599"></front>
<front id="Marlin_mainCPP-3600">  // This is redundant since the SanityCheck.h already checks for a valid Z_MIN_PROBE_PIN, but here for clarity.</front>
<front id="Marlin_mainCPP-3601">  #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-3602">    #if !HAS_Z_PROBE</front>
<front id="Marlin_mainCPP-3603">      #error You must define Z_MIN_PROBE_PIN to enable Z probe repeatability calculation.</front>
<front id="Marlin_mainCPP-3604">    #endif</front>
<front id="Marlin_mainCPP-3605">  #elif !HAS_Z_MIN</front>
<front id="Marlin_mainCPP-3606">    #error You must define Z_MIN_PIN to enable Z probe repeatability calculation.</front>
<front id="Marlin_mainCPP-3607">  #endif</front>
<front id="Marlin_mainCPP-3608"></front>
<front id="Marlin_mainCPP-3609">  /**</front>
<front id="Marlin_mainCPP-3610">   * M48: Z probe repeatability measurement function.</front>
<front id="Marlin_mainCPP-3611">   *</front>
<front id="Marlin_mainCPP-3612">   * Usage:</front>
<front id="Marlin_mainCPP-3613">   *   M48 &lt;P#&gt; &lt;X#&gt; &lt;Y#&gt; &lt;V#&gt; &lt;E&gt; &lt;L#&gt;</front>
<front id="Marlin_mainCPP-3614">   *     P = Number of sampled points (4-50, default 10)</front>
<front id="Marlin_mainCPP-3615">   *     X = Sample X position</front>
<front id="Marlin_mainCPP-3616">   *     Y = Sample Y position</front>
<front id="Marlin_mainCPP-3617">   *     V = Verbose level (0-4, default=1)</front>
<front id="Marlin_mainCPP-3618">   *     E = Engage Z probe for each reading</front>
<front id="Marlin_mainCPP-3619">   *     L = Number of legs of movement before probe</front>
<front id="Marlin_mainCPP-3620">   *</front>
<front id="Marlin_mainCPP-3621">   * This function assumes the bed has been homed.  Specifically, that a G28 command</front>
<front id="Marlin_mainCPP-3622">   * as been issued prior to invoking the M48 Z probe repeatability measurement function.</front>
<front id="Marlin_mainCPP-3623">   * Any information generated by a prior G29 Bed leveling command will be lost and need to be</front>
<front id="Marlin_mainCPP-3624">   * regenerated.</front>
<front id="Marlin_mainCPP-3625">   */</front>
<front id="Marlin_mainCPP-3626">  inline void gcode_M48() {</front>
<front id="Marlin_mainCPP-3627"></front>
<front id="Marlin_mainCPP-3628">    double sum = 0.0, mean = 0.0, sigma = 0.0, sample_set[50];</front>
<front id="Marlin_mainCPP-3629">    uint8_t verbose_level = 1, n_samples = 10, n_legs = 0;</front>
<front id="Marlin_mainCPP-3630"></front>
<front id="Marlin_mainCPP-3631">    if (code_seen('V')) {</front>
<front id="Marlin_mainCPP-3632">      verbose_level = code_value_short();</front>
<front id="Marlin_mainCPP-3633">      if (verbose_level &lt; 0 || verbose_level &gt; 4 ) {</front>
<front id="Marlin_mainCPP-3634">        SERIAL_PROTOCOLPGM("?Verbose Level not plausible (0-4).\n");</front>
<front id="Marlin_mainCPP-3635">        return;</front>
<front id="Marlin_mainCPP-3636">      }</front>
<front id="Marlin_mainCPP-3637">    }</front>
<front id="Marlin_mainCPP-3638"></front>
<front id="Marlin_mainCPP-3639">    if (verbose_level &gt; 0)</front>
<front id="Marlin_mainCPP-3640">      SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test\n");</front>
<front id="Marlin_mainCPP-3641"></front>
<front id="Marlin_mainCPP-3642">    if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-3643">      n_samples = code_value_short();</front>
<front id="Marlin_mainCPP-3644">      if (n_samples &lt; 4 || n_samples &gt; 50) {</front>
<front id="Marlin_mainCPP-3645">        SERIAL_PROTOCOLPGM("?Sample size not plausible (4-50).\n");</front>
<front id="Marlin_mainCPP-3646">        return;</front>
<front id="Marlin_mainCPP-3647">      }</front>
<front id="Marlin_mainCPP-3648">    }</front>
<front id="Marlin_mainCPP-3649"></front>
<front id="Marlin_mainCPP-3650">    double X_current = st_get_position_mm(X_AXIS),</front>
<front id="Marlin_mainCPP-3651">           Y_current = st_get_position_mm(Y_AXIS),</front>
<front id="Marlin_mainCPP-3652">           Z_current = st_get_position_mm(Z_AXIS),</front>
<front id="Marlin_mainCPP-3653">           E_current = st_get_position_mm(E_AXIS),</front>
<front id="Marlin_mainCPP-3654">           X_probe_location = X_current, Y_probe_location = Y_current,</front>
<front id="Marlin_mainCPP-3655">           Z_start_location = Z_current + Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-3656"></front>
<front id="Marlin_mainCPP-3657">    bool deploy_probe_for_each_reading = code_seen('E');</front>
<front id="Marlin_mainCPP-3658"></front>
<front id="Marlin_mainCPP-3659">    if (code_seen('X')) {</front>
<front id="Marlin_mainCPP-3660">      X_probe_location = code_value() - X_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-3661">      if (X_probe_location &lt; X_MIN_POS || X_probe_location &gt; X_MAX_POS) {</front>
<front id="Marlin_mainCPP-3662">        out_of_range_error(PSTR("X"));</front>
<front id="Marlin_mainCPP-3663">        return;</front>
<front id="Marlin_mainCPP-3664">      }</front>
<front id="Marlin_mainCPP-3665">    }</front>
<front id="Marlin_mainCPP-3666"></front>
<front id="Marlin_mainCPP-3667">    if (code_seen('Y')) {</front>
<front id="Marlin_mainCPP-3668">      Y_probe_location = code_value() -  Y_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-3669">      if (Y_probe_location &lt; Y_MIN_POS || Y_probe_location &gt; Y_MAX_POS) {</front>
<front id="Marlin_mainCPP-3670">        out_of_range_error(PSTR("Y"));</front>
<front id="Marlin_mainCPP-3671">        return;</front>
<front id="Marlin_mainCPP-3672">      }</front>
<front id="Marlin_mainCPP-3673">    }</front>
<front id="Marlin_mainCPP-3674"></front>
<front id="Marlin_mainCPP-3675">    if (code_seen('L')) {</front>
<front id="Marlin_mainCPP-3676">      n_legs = code_value_short();</front>
<front id="Marlin_mainCPP-3677">      if (n_legs == 1) n_legs = 2;</front>
<front id="Marlin_mainCPP-3678">      if (n_legs &lt; 0 || n_legs &gt; 15) {</front>
<front id="Marlin_mainCPP-3679">        SERIAL_PROTOCOLPGM("?Number of legs in movement not plausible (0-15).\n");</front>
<front id="Marlin_mainCPP-3680">        return;</front>
<front id="Marlin_mainCPP-3681">      }</front>
<front id="Marlin_mainCPP-3682">    }</front>
<front id="Marlin_mainCPP-3683"></front>
<front id="Marlin_mainCPP-3684">    //</front>
<front id="Marlin_mainCPP-3685">    // Do all the preliminary setup work.   First raise the Z probe.</front>
<front id="Marlin_mainCPP-3686">    //</front>
<front id="Marlin_mainCPP-3687"></front>
<front id="Marlin_mainCPP-3688">    st_synchronize();</front>
<front id="Marlin_mainCPP-3689">    plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-3690">    plan_buffer_line(X_current, Y_current, Z_start_location, E_current, homing_feedrate[Z_AXIS] / 60, active_extruder);</front>
<front id="Marlin_mainCPP-3691">    st_synchronize();</front>
<front id="Marlin_mainCPP-3692"></front>
<front id="Marlin_mainCPP-3693">    //</front>
<front id="Marlin_mainCPP-3694">    // Now get everything to the specified probe point So we can safely do a probe to</front>
<front id="Marlin_mainCPP-3695">    // get us close to the bed.  If the Z-Axis is far from the bed, we don't want to</front>
<front id="Marlin_mainCPP-3696">    // use that as a starting point for each probe.</front>
<front id="Marlin_mainCPP-3697">    //</front>
<front id="Marlin_mainCPP-3698">    if (verbose_level &gt; 2)</front>
<front id="Marlin_mainCPP-3699">      SERIAL_PROTOCOLPGM("Positioning the probe...\n");</front>
<front id="Marlin_mainCPP-3700"></front>
<front id="Marlin_mainCPP-3701">    plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,</front>
<front id="Marlin_mainCPP-3702">        E_current,</front>
<front id="Marlin_mainCPP-3703">        homing_feedrate[X_AXIS]/60,</front>
<front id="Marlin_mainCPP-3704">        active_extruder);</front>
<front id="Marlin_mainCPP-3705">    st_synchronize();</front>
<front id="Marlin_mainCPP-3706"></front>
<front id="Marlin_mainCPP-3707">    current_position[X_AXIS] = X_current = st_get_position_mm(X_AXIS);</front>
<front id="Marlin_mainCPP-3708">    current_position[Y_AXIS] = Y_current = st_get_position_mm(Y_AXIS);</front>
<front id="Marlin_mainCPP-3709">    current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-3710">    current_position[E_AXIS] = E_current = st_get_position_mm(E_AXIS);</front>
<front id="Marlin_mainCPP-3711"></front>
<front id="Marlin_mainCPP-3712">    //</front>
<front id="Marlin_mainCPP-3713">    // OK, do the initial probe to get us close to the bed.</front>
<front id="Marlin_mainCPP-3714">    // Then retrace the right amount and use that in subsequent probes</front>
<front id="Marlin_mainCPP-3715">    //</front>
<front id="Marlin_mainCPP-3716"></front>
<front id="Marlin_mainCPP-3717">    deploy_z_probe();</front>
<front id="Marlin_mainCPP-3718"></front>
<front id="Marlin_mainCPP-3719">    setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-3720">    run_z_probe();</front>
<front id="Marlin_mainCPP-3721"></front>
<front id="Marlin_mainCPP-3722">    current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-3723">    Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-3724"></front>
<front id="Marlin_mainCPP-3725">    plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,</front>
<front id="Marlin_mainCPP-3726">        E_current,</front>
<front id="Marlin_mainCPP-3727">        homing_feedrate[X_AXIS]/60,</front>
<front id="Marlin_mainCPP-3728">        active_extruder);</front>
<front id="Marlin_mainCPP-3729">    st_synchronize();</front>
<front id="Marlin_mainCPP-3730">    current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-3731"></front>
<front id="Marlin_mainCPP-3732">    if (deploy_probe_for_each_reading) stow_z_probe();</front>
<front id="Marlin_mainCPP-3733"></front>
<front id="Marlin_mainCPP-3734">    for (uint8_t n=0; n &lt; n_samples; n++) {</front>
<front id="Marlin_mainCPP-3735">      // Make sure we are at the probe location</front>
<front id="Marlin_mainCPP-3736">      do_blocking_move_to(X_probe_location, Y_probe_location, Z_start_location); // this also updates current_position</front>
<front id="Marlin_mainCPP-3737"></front>
<front id="Marlin_mainCPP-3738">      if (n_legs) {</front>
<front id="Marlin_mainCPP-3739">        millis_t ms = millis();</front>
<front id="Marlin_mainCPP-3740">        double radius = ms % (X_MAX_LENGTH / 4),       // limit how far out to go</front>
<front id="Marlin_mainCPP-3741">               theta = RADIANS(ms % 360L);</front>
<front id="Marlin_mainCPP-3742">        float dir = (ms & 0x0001) ? 1 : -1;            // clockwise or counter clockwise</front>
<front id="Marlin_mainCPP-3743"></front>
<front id="Marlin_mainCPP-3744">        //SERIAL_ECHOPAIR("starting radius: ",radius);</front>
<front id="Marlin_mainCPP-3745">        //SERIAL_ECHOPAIR("   theta: ",theta);</front>
<front id="Marlin_mainCPP-3746">        //SERIAL_ECHOPAIR("   direction: ",dir);</front>
<front id="Marlin_mainCPP-3747">        //SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3748"></front>
<front id="Marlin_mainCPP-3749">        for (uint8_t l = 0; l &lt; n_legs - 1; l++) {</front>
<front id="Marlin_mainCPP-3750">          ms = millis();</front>
<front id="Marlin_mainCPP-3751">          theta += RADIANS(dir * (ms % 20L));</front>
<front id="Marlin_mainCPP-3752">          radius += (ms % 10L) - 5L;</front>
<front id="Marlin_mainCPP-3753">          if (radius &lt; 0.0) radius = -radius;</front>
<front id="Marlin_mainCPP-3754"></front>
<front id="Marlin_mainCPP-3755">          X_current = X_probe_location + cos(theta) * radius;</front>
<front id="Marlin_mainCPP-3756">          X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);</front>
<front id="Marlin_mainCPP-3757">          Y_current = Y_probe_location + sin(theta) * radius;</front>
<front id="Marlin_mainCPP-3758">          Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);</front>
<front id="Marlin_mainCPP-3759"></front>
<front id="Marlin_mainCPP-3760">          if (verbose_level &gt; 3) {</front>
<front id="Marlin_mainCPP-3761">            SERIAL_ECHOPAIR("x: ", X_current);</front>
<front id="Marlin_mainCPP-3762">            SERIAL_ECHOPAIR("y: ", Y_current);</front>
<front id="Marlin_mainCPP-3763">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3764">          }</front>
<front id="Marlin_mainCPP-3765"></front>
<front id="Marlin_mainCPP-3766">          do_blocking_move_to(X_current, Y_current, Z_current); // this also updates current_position</front>
<front id="Marlin_mainCPP-3767"></front>
<front id="Marlin_mainCPP-3768">        } // n_legs loop</front>
<front id="Marlin_mainCPP-3769"></front>
<front id="Marlin_mainCPP-3770">        // Go back to the probe location</front>
<front id="Marlin_mainCPP-3771">        do_blocking_move_to(X_probe_location, Y_probe_location, Z_start_location); // this also updates current_position</front>
<front id="Marlin_mainCPP-3772"></front>
<front id="Marlin_mainCPP-3773">      } // n_legs</front>
<front id="Marlin_mainCPP-3774"></front>
<front id="Marlin_mainCPP-3775">      if (deploy_probe_for_each_reading)  {</front>
<front id="Marlin_mainCPP-3776">        deploy_z_probe();</front>
<front id="Marlin_mainCPP-3777">        delay(1000);</front>
<front id="Marlin_mainCPP-3778">      }</front>
<front id="Marlin_mainCPP-3779"></front>
<front id="Marlin_mainCPP-3780">      setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-3781">      run_z_probe();</front>
<front id="Marlin_mainCPP-3782"></front>
<front id="Marlin_mainCPP-3783">      sample_set[n] = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-3784"></front>
<front id="Marlin_mainCPP-3785">      //</front>
<front id="Marlin_mainCPP-3786">      // Get the current mean for the data points we have so far</front>
<front id="Marlin_mainCPP-3787">      //</front>
<front id="Marlin_mainCPP-3788">      sum = 0.0;</front>
<front id="Marlin_mainCPP-3789">      for (uint8_t j = 0; j &lt;= n; j++) sum += sample_set[j];</front>
<front id="Marlin_mainCPP-3790">      mean = sum / (n + 1);</front>
<front id="Marlin_mainCPP-3791"></front>
<front id="Marlin_mainCPP-3792">      //</front>
<front id="Marlin_mainCPP-3793">      // Now, use that mean to calculate the standard deviation for the</front>
<front id="Marlin_mainCPP-3794">      // data points we have so far</front>
<front id="Marlin_mainCPP-3795">      //</front>
<front id="Marlin_mainCPP-3796">      sum = 0.0;</front>
<front id="Marlin_mainCPP-3797">      for (uint8_t j = 0; j &lt;= n; j++) {</front>
<front id="Marlin_mainCPP-3798">        float ss = sample_set[j] - mean;</front>
<front id="Marlin_mainCPP-3799">        sum += ss * ss;</front>
<front id="Marlin_mainCPP-3800">      }</front>
<front id="Marlin_mainCPP-3801">      sigma = sqrt(sum / (n + 1));</front>
<front id="Marlin_mainCPP-3802"></front>
<front id="Marlin_mainCPP-3803">      if (verbose_level &gt; 1) {</front>
<front id="Marlin_mainCPP-3804">        SERIAL_PROTOCOL(n+1);</front>
<front id="Marlin_mainCPP-3805">        SERIAL_PROTOCOLPGM(" of ");</front>
<front id="Marlin_mainCPP-3806">        SERIAL_PROTOCOL((int)n_samples);</front>
<front id="Marlin_mainCPP-3807">        SERIAL_PROTOCOLPGM("   z: ");</front>
<front id="Marlin_mainCPP-3808">        SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);</front>
<front id="Marlin_mainCPP-3809">        if (verbose_level &gt; 2) {</front>
<front id="Marlin_mainCPP-3810">          SERIAL_PROTOCOLPGM(" mean: ");</front>
<front id="Marlin_mainCPP-3811">          SERIAL_PROTOCOL_F(mean,6);</front>
<front id="Marlin_mainCPP-3812">          SERIAL_PROTOCOLPGM("   sigma: ");</front>
<front id="Marlin_mainCPP-3813">          SERIAL_PROTOCOL_F(sigma,6);</front>
<front id="Marlin_mainCPP-3814">        }</front>
<front id="Marlin_mainCPP-3815">      }</front>
<front id="Marlin_mainCPP-3816"></front>
<front id="Marlin_mainCPP-3817">      if (verbose_level &gt; 0) SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3818"></front>
<front id="Marlin_mainCPP-3819">      plan_buffer_line(X_probe_location, Y_probe_location, Z_start_location, current_position[E_AXIS], homing_feedrate[Z_AXIS]/60, active_extruder);</front>
<front id="Marlin_mainCPP-3820">      st_synchronize();</front>
<front id="Marlin_mainCPP-3821"></front>
<front id="Marlin_mainCPP-3822">      // Stow between</front>
<front id="Marlin_mainCPP-3823">      if (deploy_probe_for_each_reading) {</front>
<front id="Marlin_mainCPP-3824">        stow_z_probe();</front>
<front id="Marlin_mainCPP-3825">        delay(1000);</front>
<front id="Marlin_mainCPP-3826">      }</front>
<front id="Marlin_mainCPP-3827">    }</front>
<front id="Marlin_mainCPP-3828"></front>
<front id="Marlin_mainCPP-3829">    // Stow after</front>
<front id="Marlin_mainCPP-3830">    if (!deploy_probe_for_each_reading) {</front>
<front id="Marlin_mainCPP-3831">      stow_z_probe();</front>
<front id="Marlin_mainCPP-3832">      delay(1000);</front>
<front id="Marlin_mainCPP-3833">    }</front>
<front id="Marlin_mainCPP-3834"></front>
<front id="Marlin_mainCPP-3835">    clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3836"></front>
<front id="Marlin_mainCPP-3837">    if (verbose_level &gt; 0) {</front>
<front id="Marlin_mainCPP-3838">      SERIAL_PROTOCOLPGM("Mean: ");</front>
<front id="Marlin_mainCPP-3839">      SERIAL_PROTOCOL_F(mean, 6);</front>
<front id="Marlin_mainCPP-3840">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3841">    }</front>
<front id="Marlin_mainCPP-3842"></front>
<front id="Marlin_mainCPP-3843">    SERIAL_PROTOCOLPGM("Standard Deviation: ");</front>
<front id="Marlin_mainCPP-3844">    SERIAL_PROTOCOL_F(sigma, 6);</front>
<front id="Marlin_mainCPP-3845">    SERIAL_EOL; SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3846">  }</front>
<front id="Marlin_mainCPP-3847"></front>
<front id="Marlin_mainCPP-3848">#endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST</front>
<front id="Marlin_mainCPP-3849"></front>
<front id="Marlin_mainCPP-3850">/**</front>
<front id="Marlin_mainCPP-3851"> * M104: Set hot end temperature</front>
<front id="Marlin_mainCPP-3852"> */</front>
<front id="Marlin_mainCPP-3853">inline void gcode_M104() {</front>
<front id="Marlin_mainCPP-3854">  if (setTargetedHotend(104)) return;</front>
<front id="Marlin_mainCPP-3855">  if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-3856"></front>
<front id="Marlin_mainCPP-3857">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-3858">    float temp = code_value();</front>
<front id="Marlin_mainCPP-3859">    setTargetHotend(temp, target_extruder);</front>
<front id="Marlin_mainCPP-3860">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-3861">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)</front>
<front id="Marlin_mainCPP-3862">        setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-3863">    #endif</front>
<front id="Marlin_mainCPP-3864">  }</front>
<front id="Marlin_mainCPP-3865">}</front>
<front id="Marlin_mainCPP-3866"></front>
<front id="Marlin_mainCPP-3867">/**</front>
<front id="Marlin_mainCPP-3868"> * M105: Read hot end and bed temperature</front>
<front id="Marlin_mainCPP-3869"> */</front>
<front id="Marlin_mainCPP-3870">inline void gcode_M105() {</front>
<front id="Marlin_mainCPP-3871">  if (setTargetedHotend(105)) return;</front>
<front id="Marlin_mainCPP-3872"></front>
<front id="Marlin_mainCPP-3873">  #if HAS_TEMP_0 || HAS_TEMP_BED || ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="Marlin_mainCPP-3874">    SERIAL_PROTOCOLPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-3875">    #if HAS_TEMP_0 || ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="Marlin_mainCPP-3876">      SERIAL_PROTOCOLPGM(" T:");</front>
<front id="Marlin_mainCPP-3877">      SERIAL_PROTOCOL_F(degHotend(target_extruder), 1);</front>
<front id="Marlin_mainCPP-3878">      SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-3879">      SERIAL_PROTOCOL_F(degTargetHotend(target_extruder), 1);</front>
<front id="Marlin_mainCPP-3880">    #endif</front>
<front id="Marlin_mainCPP-3881">    #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-3882">      SERIAL_PROTOCOLPGM(" B:");</front>
<front id="Marlin_mainCPP-3883">      SERIAL_PROTOCOL_F(degBed(), 1);</front>
<front id="Marlin_mainCPP-3884">      SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-3885">      SERIAL_PROTOCOL_F(degTargetBed(), 1);</front>
<front id="Marlin_mainCPP-3886">    #endif</front>
<front id="Marlin_mainCPP-3887">    for (int8_t e = 0; e &lt; EXTRUDERS; ++e) {</front>
<front id="Marlin_mainCPP-3888">      SERIAL_PROTOCOLPGM(" T");</front>
<front id="Marlin_mainCPP-3889">      SERIAL_PROTOCOL(e);</front>
<front id="Marlin_mainCPP-3890">      SERIAL_PROTOCOLCHAR(':');</front>
<front id="Marlin_mainCPP-3891">      SERIAL_PROTOCOL_F(degHotend(e), 1);</front>
<front id="Marlin_mainCPP-3892">      SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-3893">      SERIAL_PROTOCOL_F(degTargetHotend(e), 1);</front>
<front id="Marlin_mainCPP-3894">    }</front>
<front id="Marlin_mainCPP-3895">  #else // !HAS_TEMP_0 && !HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-3896">    SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-3897">    SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);</front>
<front id="Marlin_mainCPP-3898">  #endif</front>
<front id="Marlin_mainCPP-3899"></front>
<front id="Marlin_mainCPP-3900">  SERIAL_PROTOCOLPGM(" @:");</front>
<front id="Marlin_mainCPP-3901">  #ifdef EXTRUDER_WATTS</front>
<front id="Marlin_mainCPP-3902">    SERIAL_PROTOCOL((EXTRUDER_WATTS * getHeaterPower(target_extruder))/127);</front>
<front id="Marlin_mainCPP-3903">    SERIAL_PROTOCOLCHAR('W');</front>
<front id="Marlin_mainCPP-3904">  #else</front>
<front id="Marlin_mainCPP-3905">    SERIAL_PROTOCOL(getHeaterPower(target_extruder));</front>
<front id="Marlin_mainCPP-3906">  #endif</front>
<front id="Marlin_mainCPP-3907"></front>
<front id="Marlin_mainCPP-3908">  SERIAL_PROTOCOLPGM(" B@:");</front>
<front id="Marlin_mainCPP-3909">  #ifdef BED_WATTS</front>
<front id="Marlin_mainCPP-3910">    SERIAL_PROTOCOL((BED_WATTS * getHeaterPower(-1))/127);</front>
<front id="Marlin_mainCPP-3911">    SERIAL_PROTOCOLCHAR('W');</front>
<front id="Marlin_mainCPP-3912">  #else</front>
<front id="Marlin_mainCPP-3913">    SERIAL_PROTOCOL(getHeaterPower(-1));</front>
<front id="Marlin_mainCPP-3914">  #endif</front>
<front id="Marlin_mainCPP-3915"></front>
<front id="Marlin_mainCPP-3916">  #if ENABLED(SHOW_TEMP_ADC_VALUES)</front>
<front id="Marlin_mainCPP-3917">    #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-3918">      SERIAL_PROTOCOLPGM("    ADC B:");</front>
<front id="Marlin_mainCPP-3919">      SERIAL_PROTOCOL_F(degBed(),1);</front>
<front id="Marlin_mainCPP-3920">      SERIAL_PROTOCOLPGM("C-&gt;");</front>
<front id="Marlin_mainCPP-3921">      SERIAL_PROTOCOL_F(rawBedTemp()/OVERSAMPLENR,0);</front>
<front id="Marlin_mainCPP-3922">    #endif</front>
<front id="Marlin_mainCPP-3923">    for (int8_t cur_extruder = 0; cur_extruder &lt; EXTRUDERS; ++cur_extruder) {</front>
<front id="Marlin_mainCPP-3924">      SERIAL_PROTOCOLPGM("  T");</front>
<front id="Marlin_mainCPP-3925">      SERIAL_PROTOCOL(cur_extruder);</front>
<front id="Marlin_mainCPP-3926">      SERIAL_PROTOCOLCHAR(':');</front>
<front id="Marlin_mainCPP-3927">      SERIAL_PROTOCOL_F(degHotend(cur_extruder),1);</front>
<front id="Marlin_mainCPP-3928">      SERIAL_PROTOCOLPGM("C-&gt;");</front>
<front id="Marlin_mainCPP-3929">      SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder)/OVERSAMPLENR,0);</front>
<front id="Marlin_mainCPP-3930">    }</front>
<front id="Marlin_mainCPP-3931">  #endif</front>
<front id="Marlin_mainCPP-3932"></front>
<front id="Marlin_mainCPP-3933">  SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3934">}</front>
<front id="Marlin_mainCPP-3935"></front>
<front id="Marlin_mainCPP-3936">#if HAS_FAN</front>
<front id="Marlin_mainCPP-3937"></front>
<front id="Marlin_mainCPP-3938">  /**</front>
<front id="Marlin_mainCPP-3939">   * M106: Set Fan Speed</front>
<front id="Marlin_mainCPP-3940">   */</front>
<front id="Marlin_mainCPP-3941">  inline void gcode_M106() { fanSpeed = code_seen('S') ? constrain(code_value_short(), 0, 255) : 255; }</front>
<front id="Marlin_mainCPP-3942"></front>
<front id="Marlin_mainCPP-3943">  /**</front>
<front id="Marlin_mainCPP-3944">   * M107: Fan Off</front>
<front id="Marlin_mainCPP-3945">   */</front>
<front id="Marlin_mainCPP-3946">  inline void gcode_M107() { fanSpeed = 0; }</front>
<front id="Marlin_mainCPP-3947"></front>
<front id="Marlin_mainCPP-3948">#endif // HAS_FAN</front>
<front id="Marlin_mainCPP-3949"></front>
<front id="Marlin_mainCPP-3950">/**</front>
<front id="Marlin_mainCPP-3951"> * M109: Wait for extruder(s) to reach temperature</front>
<front id="Marlin_mainCPP-3952"> */</front>
<front id="Marlin_mainCPP-3953">inline void gcode_M109() {</front>
<front id="Marlin_mainCPP-3954">  if (setTargetedHotend(109)) return;</front>
<front id="Marlin_mainCPP-3955">  if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-3956"></front>
<front id="Marlin_mainCPP-3957">  LCD_MESSAGEPGM(MSG_HEATING);</front>
<front id="Marlin_mainCPP-3958"></front>
<front id="Marlin_mainCPP-3959">  no_wait_for_cooling = code_seen('S');</front>
<front id="Marlin_mainCPP-3960">  if (no_wait_for_cooling || code_seen('R')) {</front>
<front id="Marlin_mainCPP-3961">    float temp = code_value();</front>
<front id="Marlin_mainCPP-3962">    setTargetHotend(temp, target_extruder);</front>
<front id="Marlin_mainCPP-3963">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-3964">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)</front>
<front id="Marlin_mainCPP-3965">        setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-3966">    #endif</front>
<front id="Marlin_mainCPP-3967">  }</front>
<front id="Marlin_mainCPP-3968"></front>
<front id="Marlin_mainCPP-3969">  #if ENABLED(AUTOTEMP)</front>
<front id="Marlin_mainCPP-3970">    autotemp_enabled = code_seen('F');</front>
<front id="Marlin_mainCPP-3971">    if (autotemp_enabled) autotemp_factor = code_value();</front>
<front id="Marlin_mainCPP-3972">    if (code_seen('S')) autotemp_min = code_value();</front>
<front id="Marlin_mainCPP-3973">    if (code_seen('B')) autotemp_max = code_value();</front>
<front id="Marlin_mainCPP-3974">  #endif</front>
<front id="Marlin_mainCPP-3975"></front>
<front id="Marlin_mainCPP-3976">  millis_t temp_ms = millis();</front>
<front id="Marlin_mainCPP-3977"></front>
<front id="Marlin_mainCPP-3978">  /* See if we are heating up or cooling down */</front>
<front id="Marlin_mainCPP-3979">  target_direction = isHeatingHotend(target_extruder); // true if heating, false if cooling</front>
<front id="Marlin_mainCPP-3980"></front>
<front id="Marlin_mainCPP-3981">  cancel_heatup = false;</front>
<front id="Marlin_mainCPP-3982"></front>
<front id="Marlin_mainCPP-3983">  #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-3984">    long residency_start_ms = -1;</front>
<front id="Marlin_mainCPP-3985">    /* continue to loop until we have reached the target temp</front>
<front id="Marlin_mainCPP-3986">      _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */</front>
<front id="Marlin_mainCPP-3987">    while((!cancel_heatup)&&((residency_start_ms == -1) ||</front>
<front id="Marlin_mainCPP-3988">          (residency_start_ms &gt;= 0 && (((unsigned int) (millis() - residency_start_ms)) &lt; (TEMP_RESIDENCY_TIME * 1000UL)))) )</front>
<front id="Marlin_mainCPP-3989">  #else</front>
<front id="Marlin_mainCPP-3990">    while ( target_direction ? (isHeatingHotend(target_extruder)) : (isCoolingHotend(target_extruder)&&(no_wait_for_cooling==false)) )</front>
<front id="Marlin_mainCPP-3991">  #endif //TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-3992"></front>
<front id="Marlin_mainCPP-3993">    { // while loop</front>
<front id="Marlin_mainCPP-3994">      if (millis() &gt; temp_ms + 1000UL) { //Print temp & remaining time every 1s while waiting</front>
<front id="Marlin_mainCPP-3995">        SERIAL_PROTOCOLPGM("T:");</front>
<front id="Marlin_mainCPP-3996">        SERIAL_PROTOCOL_F(degHotend(target_extruder),1);</front>
<front id="Marlin_mainCPP-3997">        SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-3998">        SERIAL_PROTOCOL((int)target_extruder);</front>
<front id="Marlin_mainCPP-3999">        #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-4000">          SERIAL_PROTOCOLPGM(" W:");</front>
<front id="Marlin_mainCPP-4001">          if (residency_start_ms &gt; -1) {</front>
<front id="Marlin_mainCPP-4002">            temp_ms = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residency_start_ms)) / 1000UL;</front>
<front id="Marlin_mainCPP-4003">            SERIAL_PROTOCOLLN(temp_ms);</front>
<front id="Marlin_mainCPP-4004">          }</front>
<front id="Marlin_mainCPP-4005">          else {</front>
<front id="Marlin_mainCPP-4006">            SERIAL_PROTOCOLLNPGM("?");</front>
<front id="Marlin_mainCPP-4007">          }</front>
<front id="Marlin_mainCPP-4008">        #else</front>
<front id="Marlin_mainCPP-4009">          SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4010">        #endif</front>
<front id="Marlin_mainCPP-4011">        temp_ms = millis();</front>
<front id="Marlin_mainCPP-4012">      }</front>
<front id="Marlin_mainCPP-4013"></front>
<front id="Marlin_mainCPP-4014">      idle();</front>
<front id="Marlin_mainCPP-4015"></front>
<front id="Marlin_mainCPP-4016">      #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-4017">        // start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time</front>
<front id="Marlin_mainCPP-4018">        // or when current temp falls outside the hysteresis after target temp was reached</front>
<front id="Marlin_mainCPP-4019">        if ((residency_start_ms == -1 &&  target_direction && (degHotend(target_extruder) &gt;= (degTargetHotend(target_extruder)-TEMP_WINDOW))) ||</front>
<front id="Marlin_mainCPP-4020">            (residency_start_ms == -1 && !target_direction && (degHotend(target_extruder) &lt;= (degTargetHotend(target_extruder)+TEMP_WINDOW))) ||</front>
<front id="Marlin_mainCPP-4021">            (residency_start_ms &gt; -1 && labs(degHotend(target_extruder) - degTargetHotend(target_extruder)) &gt; TEMP_HYSTERESIS) )</front>
<front id="Marlin_mainCPP-4022">        {</front>
<front id="Marlin_mainCPP-4023">          residency_start_ms = millis();</front>
<front id="Marlin_mainCPP-4024">        }</front>
<front id="Marlin_mainCPP-4025">      #endif //TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-4026">    }</front>
<front id="Marlin_mainCPP-4027"></front>
<front id="Marlin_mainCPP-4028">  LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);</front>
<front id="Marlin_mainCPP-4029">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-4030">  print_job_start_ms = previous_cmd_ms;</front>
<front id="Marlin_mainCPP-4031">}</front>
<front id="Marlin_mainCPP-4032"></front>
<front id="Marlin_mainCPP-4033">#if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-4034"></front>
<front id="Marlin_mainCPP-4035">  /**</front>
<front id="Marlin_mainCPP-4036">   * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-4037">   *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-4038">   */</front>
<front id="Marlin_mainCPP-4039">  inline void gcode_M190() {</front>
<front id="Marlin_mainCPP-4040">    if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-4041"></front>
<front id="Marlin_mainCPP-4042">    LCD_MESSAGEPGM(MSG_BED_HEATING);</front>
<front id="Marlin_mainCPP-4043">    no_wait_for_cooling = code_seen('S');</front>
<front id="Marlin_mainCPP-4044">    if (no_wait_for_cooling || code_seen('R'))</front>
<front id="Marlin_mainCPP-4045">      setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-4046"></front>
<front id="Marlin_mainCPP-4047">    millis_t temp_ms = millis();</front>
<front id="Marlin_mainCPP-4048"></front>
<front id="Marlin_mainCPP-4049">    cancel_heatup = false;</front>
<front id="Marlin_mainCPP-4050">    target_direction = isHeatingBed(); // true if heating, false if cooling</front>
<front id="Marlin_mainCPP-4051"></front>
<front id="Marlin_mainCPP-4052">    while ((target_direction && !cancel_heatup) ? isHeatingBed() : isCoolingBed() && !no_wait_for_cooling) {</front>
<front id="Marlin_mainCPP-4053">      millis_t ms = millis();</front>
<front id="Marlin_mainCPP-4054">      if (ms &gt; temp_ms + 1000UL) { //Print Temp Reading every 1 second while heating up.</front>
<front id="Marlin_mainCPP-4055">        temp_ms = ms;</front>
<front id="Marlin_mainCPP-4056">        float tt = degHotend(active_extruder);</front>
<front id="Marlin_mainCPP-4057">        SERIAL_PROTOCOLPGM("T:");</front>
<front id="Marlin_mainCPP-4058">        SERIAL_PROTOCOL(tt);</front>
<front id="Marlin_mainCPP-4059">        SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-4060">        SERIAL_PROTOCOL((int)active_extruder);</front>
<front id="Marlin_mainCPP-4061">        SERIAL_PROTOCOLPGM(" B:");</front>
<front id="Marlin_mainCPP-4062">        SERIAL_PROTOCOL_F(degBed(), 1);</front>
<front id="Marlin_mainCPP-4063">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4064">      }</front>
<front id="Marlin_mainCPP-4065">      idle();</front>
<front id="Marlin_mainCPP-4066">    }</front>
<front id="Marlin_mainCPP-4067">    LCD_MESSAGEPGM(MSG_BED_DONE);</front>
<front id="Marlin_mainCPP-4068">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-4069">  }</front>
<front id="Marlin_mainCPP-4070"></front>
<front id="Marlin_mainCPP-4071">#endif // HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-4072"></front>
<front id="Marlin_mainCPP-4073">/**</front>
<front id="Marlin_mainCPP-4074"> * M111: Set the debug level</front>
<front id="Marlin_mainCPP-4075"> */</front>
<front id="Marlin_mainCPP-4076">inline void gcode_M111() {</front>
<front id="Marlin_mainCPP-4077">  marlin_debug_flags = code_seen('S') ? code_value_short() : DEBUG_INFO|DEBUG_COMMUNICATION;</front>
<front id="Marlin_mainCPP-4078"></front>
<front id="Marlin_mainCPP-4079">  if (marlin_debug_flags & DEBUG_ECHO) {</front>
<front id="Marlin_mainCPP-4080">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4081">    SERIAL_ECHOLNPGM(MSG_DEBUG_ECHO);</front>
<front id="Marlin_mainCPP-4082">  }</front>
<front id="Marlin_mainCPP-4083">  // FOR MOMENT NOT ACTIVE</front>
<front id="Marlin_mainCPP-4084">  //if (marlin_debug_flags & DEBUG_INFO) SERIAL_ECHOLNPGM(MSG_DEBUG_INFO);</front>
<front id="Marlin_mainCPP-4085">  //if (marlin_debug_flags & DEBUG_ERRORS) SERIAL_ECHOLNPGM(MSG_DEBUG_ERRORS);</front>
<front id="Marlin_mainCPP-4086">  if (marlin_debug_flags & DEBUG_DRYRUN) {</front>
<front id="Marlin_mainCPP-4087">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4088">    SERIAL_ECHOLNPGM(MSG_DEBUG_DRYRUN);</front>
<front id="Marlin_mainCPP-4089">    disable_all_heaters();</front>
<front id="Marlin_mainCPP-4090">  }</front>
<front id="Marlin_mainCPP-4091"></front>
<front id="Marlin_mainCPP-4092">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4093">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4094">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4095">      SERIAL_ECHOLNPGM(MSG_DEBUG_LEVELING);</front>
<front id="Marlin_mainCPP-4096">    }</front>
<front id="Marlin_mainCPP-4097">  #endif</front>
<front id="Marlin_mainCPP-4098">}</front>
<front id="Marlin_mainCPP-4099"></front>
<front id="Marlin_mainCPP-4100">/**</front>
<front id="Marlin_mainCPP-4101"> * M112: Emergency Stop</front>
<front id="Marlin_mainCPP-4102"> */</front>
<front id="Marlin_mainCPP-4103">inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }</front>
<front id="Marlin_mainCPP-4104"></front>
<front id="Marlin_mainCPP-4105">#if ENABLED(BARICUDA)</front>
<front id="Marlin_mainCPP-4106"></front>
<front id="Marlin_mainCPP-4107">  #if HAS_HEATER_1</front>
<front id="Marlin_mainCPP-4108">    /**</front>
<front id="Marlin_mainCPP-4109">     * M126: Heater 1 valve open</front>
<front id="Marlin_mainCPP-4110">     */</front>
<front id="Marlin_mainCPP-4111">    inline void gcode_M126() { ValvePressure = code_seen('S') ? constrain(code_value(), 0, 255) : 255; }</front>
<front id="Marlin_mainCPP-4112">    /**</front>
<front id="Marlin_mainCPP-4113">     * M127: Heater 1 valve close</front>
<front id="Marlin_mainCPP-4114">     */</front>
<front id="Marlin_mainCPP-4115">    inline void gcode_M127() { ValvePressure = 0; }</front>
<front id="Marlin_mainCPP-4116">  #endif</front>
<front id="Marlin_mainCPP-4117"></front>
<front id="Marlin_mainCPP-4118">  #if HAS_HEATER_2</front>
<front id="Marlin_mainCPP-4119">    /**</front>
<front id="Marlin_mainCPP-4120">     * M128: Heater 2 valve open</front>
<front id="Marlin_mainCPP-4121">     */</front>
<front id="Marlin_mainCPP-4122">    inline void gcode_M128() { EtoPPressure = code_seen('S') ? constrain(code_value(), 0, 255) : 255; }</front>
<front id="Marlin_mainCPP-4123">    /**</front>
<front id="Marlin_mainCPP-4124">     * M129: Heater 2 valve close</front>
<front id="Marlin_mainCPP-4125">     */</front>
<front id="Marlin_mainCPP-4126">    inline void gcode_M129() { EtoPPressure = 0; }</front>
<front id="Marlin_mainCPP-4127">  #endif</front>
<front id="Marlin_mainCPP-4128"></front>
<front id="Marlin_mainCPP-4129">#endif //BARICUDA</front>
<front id="Marlin_mainCPP-4130"></front>
<front id="Marlin_mainCPP-4131">/**</front>
<front id="Marlin_mainCPP-4132"> * M140: Set bed temperature</front>
<front id="Marlin_mainCPP-4133"> */</front>
<front id="Marlin_mainCPP-4134">inline void gcode_M140() {</front>
<front id="Marlin_mainCPP-4135">  if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-4136">  if (code_seen('S')) setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-4137">}</front>
<front id="Marlin_mainCPP-4138"></front>
<front id="Marlin_mainCPP-4139">#if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-4140"></front>
<front id="Marlin_mainCPP-4141">  /**</front>
<front id="Marlin_mainCPP-4142">   * M145: Set the heatup state for a material in the LCD menu</front>
<front id="Marlin_mainCPP-4143">   *   S&lt;material&gt; (0=PLA, 1=ABS)</front>
<front id="Marlin_mainCPP-4144">   *   H&lt;hotend temp&gt;</front>
<front id="Marlin_mainCPP-4145">   *   B&lt;bed temp&gt;</front>
<front id="Marlin_mainCPP-4146">   *   F&lt;fan speed&gt;</front>
<front id="Marlin_mainCPP-4147">   */</front>
<front id="Marlin_mainCPP-4148">  inline void gcode_M145() {</front>
<front id="Marlin_mainCPP-4149">    uint8_t material = code_seen('S') ? code_value_short() : 0;</front>
<front id="Marlin_mainCPP-4150">    if (material &lt; 0 || material &gt; 1) {</front>
<front id="Marlin_mainCPP-4151">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-4152">      SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);</front>
<front id="Marlin_mainCPP-4153">    }</front>
<front id="Marlin_mainCPP-4154">    else {</front>
<front id="Marlin_mainCPP-4155">      int v;</front>
<front id="Marlin_mainCPP-4156">      switch (material) {</front>
<front id="Marlin_mainCPP-4157">        case 0:</front>
<front id="Marlin_mainCPP-4158">          if (code_seen('H')) {</front>
<front id="Marlin_mainCPP-4159">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4160">            plaPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4161">          }</front>
<front id="Marlin_mainCPP-4162">          if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-4163">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4164">            plaPreheatFanSpeed = constrain(v, 0, 255);</front>
<front id="Marlin_mainCPP-4165">          }</front>
<front id="Marlin_mainCPP-4166">          #if TEMP_SENSOR_BED != 0</front>
<front id="Marlin_mainCPP-4167">            if (code_seen('B')) {</front>
<front id="Marlin_mainCPP-4168">              v = code_value_short();</front>
<front id="Marlin_mainCPP-4169">              plaPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4170">            }</front>
<front id="Marlin_mainCPP-4171">          #endif</front>
<front id="Marlin_mainCPP-4172">          break;</front>
<front id="Marlin_mainCPP-4173">        case 1:</front>
<front id="Marlin_mainCPP-4174">          if (code_seen('H')) {</front>
<front id="Marlin_mainCPP-4175">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4176">            absPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4177">          }</front>
<front id="Marlin_mainCPP-4178">          if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-4179">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4180">            absPreheatFanSpeed = constrain(v, 0, 255);</front>
<front id="Marlin_mainCPP-4181">          }</front>
<front id="Marlin_mainCPP-4182">          #if TEMP_SENSOR_BED != 0</front>
<front id="Marlin_mainCPP-4183">            if (code_seen('B')) {</front>
<front id="Marlin_mainCPP-4184">              v = code_value_short();</front>
<front id="Marlin_mainCPP-4185">              absPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4186">            }</front>
<front id="Marlin_mainCPP-4187">          #endif</front>
<front id="Marlin_mainCPP-4188">          break;</front>
<front id="Marlin_mainCPP-4189">      }</front>
<front id="Marlin_mainCPP-4190">    }</front>
<front id="Marlin_mainCPP-4191">  }</front>
<front id="Marlin_mainCPP-4192"></front>
<front id="Marlin_mainCPP-4193">#endif</front>
<front id="Marlin_mainCPP-4194"></front>
<front id="Marlin_mainCPP-4195">#if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4196"></front>
<front id="Marlin_mainCPP-4197">  /**</front>
<front id="Marlin_mainCPP-4198">   * M80: Turn on Power Supply</front>
<front id="Marlin_mainCPP-4199">   */</front>
<front id="Marlin_mainCPP-4200">  inline void gcode_M80() {</front>
<front id="Marlin_mainCPP-4201">    OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); //GND</front>
<front id="Marlin_mainCPP-4202"></front>
<front id="Marlin_mainCPP-4203">    // If you have a switch on suicide pin, this is useful</front>
<front id="Marlin_mainCPP-4204">    // if you want to start another print with suicide feature after</front>
<front id="Marlin_mainCPP-4205">    // a print without suicide...</front>
<front id="Marlin_mainCPP-4206">    #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-4207">      OUT_WRITE(SUICIDE_PIN, HIGH);</front>
<front id="Marlin_mainCPP-4208">    #endif</front>
<front id="Marlin_mainCPP-4209"></front>
<front id="Marlin_mainCPP-4210">    #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-4211">      powersupply = true;</front>
<front id="Marlin_mainCPP-4212">      LCD_MESSAGEPGM(WELCOME_MSG);</front>
<front id="Marlin_mainCPP-4213">      lcd_update();</front>
<front id="Marlin_mainCPP-4214">    #endif</front>
<front id="Marlin_mainCPP-4215">  }</front>
<front id="Marlin_mainCPP-4216"></front>
<front id="Marlin_mainCPP-4217">#endif // HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4218"></front>
<front id="Marlin_mainCPP-4219">/**</front>
<front id="Marlin_mainCPP-4220"> * M81: Turn off Power, including Power Supply, if there is one.</front>
<front id="Marlin_mainCPP-4221"> *</front>
<front id="Marlin_mainCPP-4222"> *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!</front>
<front id="Marlin_mainCPP-4223"> */</front>
<front id="Marlin_mainCPP-4224">inline void gcode_M81() {</front>
<front id="Marlin_mainCPP-4225">  disable_all_heaters();</front>
<front id="Marlin_mainCPP-4226">  finishAndDisableSteppers();</front>
<front id="Marlin_mainCPP-4227">  fanSpeed = 0;</front>
<front id="Marlin_mainCPP-4228">  delay(1000); // Wait 1 second before switching off</front>
<front id="Marlin_mainCPP-4229">  #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-4230">    st_synchronize();</front>
<front id="Marlin_mainCPP-4231">    suicide();</front>
<front id="Marlin_mainCPP-4232">  #elif HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4233">    OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);</front>
<front id="Marlin_mainCPP-4234">  #endif</front>
<front id="Marlin_mainCPP-4235">  #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-4236">    #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4237">      powersupply = false;</front>
<front id="Marlin_mainCPP-4238">    #endif</front>
<front id="Marlin_mainCPP-4239">    LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");</front>
<front id="Marlin_mainCPP-4240">    lcd_update();</front>
<front id="Marlin_mainCPP-4241">  #endif</front>
<front id="Marlin_mainCPP-4242">}</front>
<front id="Marlin_mainCPP-4243"></front>
<front id="Marlin_mainCPP-4244"></front>
<front id="Marlin_mainCPP-4245">/**</front>
<front id="Marlin_mainCPP-4246"> * M82: Set E codes absolute (default)</front>
<front id="Marlin_mainCPP-4247"> */</front>
<front id="Marlin_mainCPP-4248">inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }</front>
<front id="Marlin_mainCPP-4249"></front>
<front id="Marlin_mainCPP-4250">/**</front>
<front id="Marlin_mainCPP-4251"> * M83: Set E codes relative while in Absolute Coordinates (G90) mode</front>
<front id="Marlin_mainCPP-4252"> */</front>
<front id="Marlin_mainCPP-4253">inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }</front>
<front id="Marlin_mainCPP-4254"></front>
<front id="Marlin_mainCPP-4255">/**</front>
<front id="Marlin_mainCPP-4256"> * M18, M84: Disable all stepper motors</front>
<front id="Marlin_mainCPP-4257"> */</front>
<front id="Marlin_mainCPP-4258">inline void gcode_M18_M84() {</front>
<front id="Marlin_mainCPP-4259">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4260">    stepper_inactive_time = code_value() * 1000;</front>
<front id="Marlin_mainCPP-4261">  }</front>
<front id="Marlin_mainCPP-4262">  else {</front>
<front id="Marlin_mainCPP-4263">    bool all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS]))|| (code_seen(axis_codes[E_AXIS])));</front>
<front id="Marlin_mainCPP-4264">    if (all_axis) {</front>
<front id="Marlin_mainCPP-4265">      finishAndDisableSteppers();</front>
<front id="Marlin_mainCPP-4266">    }</front>
<front id="Marlin_mainCPP-4267">    else {</front>
<front id="Marlin_mainCPP-4268">      st_synchronize();</front>
<front id="Marlin_mainCPP-4269">      if (code_seen('X')) disable_x();</front>
<front id="Marlin_mainCPP-4270">      if (code_seen('Y')) disable_y();</front>
<front id="Marlin_mainCPP-4271">      if (code_seen('Z')) disable_z();</front>
<front id="Marlin_mainCPP-4272">      #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS</front>
<front id="Marlin_mainCPP-4273">        if (code_seen('E')) {</front>
<front id="Marlin_mainCPP-4274">          disable_e0();</front>
<front id="Marlin_mainCPP-4275">          disable_e1();</front>
<front id="Marlin_mainCPP-4276">          disable_e2();</front>
<front id="Marlin_mainCPP-4277">          disable_e3();</front>
<front id="Marlin_mainCPP-4278">        }</front>
<front id="Marlin_mainCPP-4279">      #endif</front>
<front id="Marlin_mainCPP-4280">    }</front>
<front id="Marlin_mainCPP-4281">  }</front>
<front id="Marlin_mainCPP-4282">}</front>
<front id="Marlin_mainCPP-4283"></front>
<front id="Marlin_mainCPP-4284">/**</front>
<front id="Marlin_mainCPP-4285"> * M85: Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</front>
<front id="Marlin_mainCPP-4286"> */</front>
<front id="Marlin_mainCPP-4287">inline void gcode_M85() {</front>
<front id="Marlin_mainCPP-4288">  if (code_seen('S')) max_inactive_time = code_value() * 1000;</front>
<front id="Marlin_mainCPP-4289">}</front>
<front id="Marlin_mainCPP-4290"></front>
<front id="Marlin_mainCPP-4291">/**</front>
<front id="Marlin_mainCPP-4292"> * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.</front>
<front id="Marlin_mainCPP-4293"> *      (Follows the same syntax as G92)</front>
<front id="Marlin_mainCPP-4294"> */</front>
<front id="Marlin_mainCPP-4295">inline void gcode_M92() {</front>
<front id="Marlin_mainCPP-4296">  for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4297">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4298">      if (i == E_AXIS) {</front>
<front id="Marlin_mainCPP-4299">        float value = code_value();</front>
<front id="Marlin_mainCPP-4300">        if (value &lt; 20.0) {</front>
<front id="Marlin_mainCPP-4301">          float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.</front>
<front id="Marlin_mainCPP-4302">          max_e_jerk *= factor;</front>
<front id="Marlin_mainCPP-4303">          max_feedrate[i] *= factor;</front>
<front id="Marlin_mainCPP-4304">          axis_steps_per_sqr_second[i] *= factor;</front>
<front id="Marlin_mainCPP-4305">        }</front>
<front id="Marlin_mainCPP-4306">        axis_steps_per_unit[i] = value;</front>
<front id="Marlin_mainCPP-4307">      }</front>
<front id="Marlin_mainCPP-4308">      else {</front>
<front id="Marlin_mainCPP-4309">        axis_steps_per_unit[i] = code_value();</front>
<front id="Marlin_mainCPP-4310">      }</front>
<front id="Marlin_mainCPP-4311">    }</front>
<front id="Marlin_mainCPP-4312">  }</front>
<front id="Marlin_mainCPP-4313">}</front>
<front id="Marlin_mainCPP-4314"></front>
<front id="Marlin_mainCPP-4315">/**</front>
<front id="Marlin_mainCPP-4316"> * M114: Output current position to serial port</front>
<front id="Marlin_mainCPP-4317"> */</front>
<front id="Marlin_mainCPP-4318">inline void gcode_M114() {</front>
<front id="Marlin_mainCPP-4319">  SERIAL_PROTOCOLPGM("X:");</front>
<front id="Marlin_mainCPP-4320">  SERIAL_PROTOCOL(current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-4321">  SERIAL_PROTOCOLPGM(" Y:");</front>
<front id="Marlin_mainCPP-4322">  SERIAL_PROTOCOL(current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4323">  SERIAL_PROTOCOLPGM(" Z:");</front>
<front id="Marlin_mainCPP-4324">  SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-4325">  SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-4326">  SERIAL_PROTOCOL(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-4327"></front>
<front id="Marlin_mainCPP-4328">  SERIAL_PROTOCOLPGM(MSG_COUNT_X);</front>
<front id="Marlin_mainCPP-4329">  SERIAL_PROTOCOL(st_get_position_mm(X_AXIS));</front>
<front id="Marlin_mainCPP-4330">  SERIAL_PROTOCOLPGM(" Y:");</front>
<front id="Marlin_mainCPP-4331">  SERIAL_PROTOCOL(st_get_position_mm(Y_AXIS));</front>
<front id="Marlin_mainCPP-4332">  SERIAL_PROTOCOLPGM(" Z:");</front>
<front id="Marlin_mainCPP-4333">  SERIAL_PROTOCOL(st_get_position_mm(Z_AXIS));</front>
<front id="Marlin_mainCPP-4334"></front>
<front id="Marlin_mainCPP-4335">  #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-4336">    SERIAL_PROTOCOLPGM("  Layer:");</front>
<front id="Marlin_mainCPP-4337">    SERIAL_PROTOCOL(current_layer);</front>
<front id="Marlin_mainCPP-4338">    SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-4339">  #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-4340"></front>
<front id="Marlin_mainCPP-4341">  SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4342"></front>
<front id="Marlin_mainCPP-4343">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-4344">    SERIAL_PROTOCOLPGM("SCARA Theta:");</front>
<front id="Marlin_mainCPP-4345">    SERIAL_PROTOCOL(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-4346">    SERIAL_PROTOCOLPGM("   Psi+Theta:");</front>
<front id="Marlin_mainCPP-4347">    SERIAL_PROTOCOL(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4348">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4349"></front>
<front id="Marlin_mainCPP-4350">    SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");</front>
<front id="Marlin_mainCPP-4351">    SERIAL_PROTOCOL(delta[X_AXIS]+home_offset[X_AXIS]);</front>
<front id="Marlin_mainCPP-4352">    SERIAL_PROTOCOLPGM("   Psi+Theta (90):");</front>
<front id="Marlin_mainCPP-4353">    SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+home_offset[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4354">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4355"></front>
<front id="Marlin_mainCPP-4356">    SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");</front>
<front id="Marlin_mainCPP-4357">    SERIAL_PROTOCOL(delta[X_AXIS]/90*axis_steps_per_unit[X_AXIS]);</front>
<front id="Marlin_mainCPP-4358">    SERIAL_PROTOCOLPGM("   Psi+Theta:");</front>
<front id="Marlin_mainCPP-4359">    SERIAL_PROTOCOL((delta[Y_AXIS]-delta[X_AXIS])/90*axis_steps_per_unit[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4360">    SERIAL_EOL; SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4361">  #endif</front>
<front id="Marlin_mainCPP-4362">}</front>
<front id="Marlin_mainCPP-4363"></front>
<front id="Marlin_mainCPP-4364">/**</front>
<front id="Marlin_mainCPP-4365"> * M115: Capabilities string</front>
<front id="Marlin_mainCPP-4366"> */</front>
<front id="Marlin_mainCPP-4367">inline void gcode_M115() {</front>
<front id="Marlin_mainCPP-4368">  SERIAL_PROTOCOLPGM(MSG_M115_REPORT);</front>
<front id="Marlin_mainCPP-4369">}</front>
<front id="Marlin_mainCPP-4370"></front>
<front id="Marlin_mainCPP-4371">/**</front>
<front id="Marlin_mainCPP-4372"> * M117: Set LCD Status Message</front>
<front id="Marlin_mainCPP-4373"> */</front>
<front id="Marlin_mainCPP-4374">inline void gcode_M117() {</front>
<front id="Marlin_mainCPP-4375">  lcd_setstatus(current_command_args);</front>
<front id="Marlin_mainCPP-4376">}</front>
<front id="Marlin_mainCPP-4377"></front>
<front id="Marlin_mainCPP-4378">/**</front>
<front id="Marlin_mainCPP-4379"> * M119: Output endstop states to serial output</front>
<front id="Marlin_mainCPP-4380"> */</front>
<front id="Marlin_mainCPP-4381">inline void gcode_M119() {</front>
<front id="Marlin_mainCPP-4382">  SERIAL_PROTOCOLLN(MSG_M119_REPORT);</front>
<front id="Marlin_mainCPP-4383">  #if HAS_X_MIN</front>
<front id="Marlin_mainCPP-4384">    SERIAL_PROTOCOLPGM(MSG_X_MIN);</front>
<front id="Marlin_mainCPP-4385">    SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4386">  #endif</front>
<front id="Marlin_mainCPP-4387">  #if HAS_X_MAX</front>
<front id="Marlin_mainCPP-4388">    SERIAL_PROTOCOLPGM(MSG_X_MAX);</front>
<front id="Marlin_mainCPP-4389">    SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4390">  #endif</front>
<front id="Marlin_mainCPP-4391">  #if HAS_Y_MIN</front>
<front id="Marlin_mainCPP-4392">    SERIAL_PROTOCOLPGM(MSG_Y_MIN);</front>
<front id="Marlin_mainCPP-4393">    SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4394">  #endif</front>
<front id="Marlin_mainCPP-4395">  #if HAS_Y_MAX</front>
<front id="Marlin_mainCPP-4396">    SERIAL_PROTOCOLPGM(MSG_Y_MAX);</front>
<front id="Marlin_mainCPP-4397">    SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4398">  #endif</front>
<front id="Marlin_mainCPP-4399">  #if HAS_Z_MIN</front>
<front id="Marlin_mainCPP-4400">    SERIAL_PROTOCOLPGM(MSG_Z_MIN);</front>
<front id="Marlin_mainCPP-4401">    SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4402">  #endif</front>
<front id="Marlin_mainCPP-4403">  #if HAS_Z_MAX</front>
<front id="Marlin_mainCPP-4404">    SERIAL_PROTOCOLPGM(MSG_Z_MAX);</front>
<front id="Marlin_mainCPP-4405">    SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4406">  #endif</front>
<front id="Marlin_mainCPP-4407">  #if HAS_Z2_MAX</front>
<front id="Marlin_mainCPP-4408">    SERIAL_PROTOCOLPGM(MSG_Z2_MAX);</front>
<front id="Marlin_mainCPP-4409">    SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4410">  #endif</front>
<front id="Marlin_mainCPP-4411">  #if HAS_Z_PROBE</front>
<front id="Marlin_mainCPP-4412">    SERIAL_PROTOCOLPGM(MSG_Z_PROBE);</front>
<front id="Marlin_mainCPP-4413">    SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4414">  #endif</front>
<front id="Marlin_mainCPP-4415">}</front>
<front id="Marlin_mainCPP-4416"></front>
<front id="Marlin_mainCPP-4417">/**</front>
<front id="Marlin_mainCPP-4418"> * M120: Enable endstops</front>
<front id="Marlin_mainCPP-4419"> */</front>
<front id="Marlin_mainCPP-4420">inline void gcode_M120() { enable_endstops(true); }</front>
<front id="Marlin_mainCPP-4421"></front>
<front id="Marlin_mainCPP-4422">/**</front>
<front id="Marlin_mainCPP-4423"> * M121: Disable endstops</front>
<front id="Marlin_mainCPP-4424"> */</front>
<front id="Marlin_mainCPP-4425">inline void gcode_M121() { enable_endstops(false); }</front>
<front id="Marlin_mainCPP-4426"></front>
<front id="Marlin_mainCPP-4427">#if ENABLED(BLINKM)</front>
<front id="Marlin_mainCPP-4428"></front>
<front id="Marlin_mainCPP-4429">  /**</front>
<front id="Marlin_mainCPP-4430">   * M150: Set Status LED Color - Use R-U-B for R-G-B</front>
<front id="Marlin_mainCPP-4431">   */</front>
<front id="Marlin_mainCPP-4432">  inline void gcode_M150() {</front>
<front id="Marlin_mainCPP-4433">    SendColors(</front>
<front id="Marlin_mainCPP-4434">      code_seen('R') ? (byte)code_value_short() : 0,</front>
<front id="Marlin_mainCPP-4435">      code_seen('U') ? (byte)code_value_short() : 0,</front>
<front id="Marlin_mainCPP-4436">      code_seen('B') ? (byte)code_value_short() : 0</front>
<front id="Marlin_mainCPP-4437">    );</front>
<front id="Marlin_mainCPP-4438">  }</front>
<front id="Marlin_mainCPP-4439"></front>
<front id="Marlin_mainCPP-4440">#endif // BLINKM</front>
<front id="Marlin_mainCPP-4441"></front>
<front id="Marlin_mainCPP-4442">/**</front>
<front id="Marlin_mainCPP-4443"> * M200: Set filament diameter and set E axis units to cubic millimeters</front>
<front id="Marlin_mainCPP-4444"> *</front>
<front id="Marlin_mainCPP-4445"> *    T&lt;extruder&gt; - Optional extruder number. Current extruder if omitted.</front>
<front id="Marlin_mainCPP-4446"> *    D&lt;mm&gt; - Diameter of the filament. Use "D0" to set units back to millimeters.</front>
<front id="Marlin_mainCPP-4447"> */</front>
<front id="Marlin_mainCPP-4448">inline void gcode_M200() {</front>
<front id="Marlin_mainCPP-4449"></front>
<front id="Marlin_mainCPP-4450">  if (setTargetedHotend(200)) return;</front>
<front id="Marlin_mainCPP-4451"></front>
<front id="Marlin_mainCPP-4452">  if (code_seen('D')) {</front>
<front id="Marlin_mainCPP-4453">    float diameter = code_value();</front>
<front id="Marlin_mainCPP-4454">    // setting any extruder filament size disables volumetric on the assumption that</front>
<front id="Marlin_mainCPP-4455">    // slicers either generate in extruder values as cubic mm or as as filament feeds</front>
<front id="Marlin_mainCPP-4456">    // for all extruders</front>
<front id="Marlin_mainCPP-4457">    volumetric_enabled = (diameter != 0.0);</front>
<front id="Marlin_mainCPP-4458">    if (volumetric_enabled) {</front>
<front id="Marlin_mainCPP-4459">      filament_size[target_extruder] = diameter;</front>
<front id="Marlin_mainCPP-4460">      // make sure all extruders have some sane value for the filament size</front>
<front id="Marlin_mainCPP-4461">      for (int i=0; i&lt;EXTRUDERS; i++)</front>
<front id="Marlin_mainCPP-4462">        if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;</front>
<front id="Marlin_mainCPP-4463">    }</front>
<front id="Marlin_mainCPP-4464">  }</front>
<front id="Marlin_mainCPP-4465">  else {</front>
<front id="Marlin_mainCPP-4466">    //reserved for setting filament diameter via UFID or filament measuring device</front>
<front id="Marlin_mainCPP-4467">    return;</front>
<front id="Marlin_mainCPP-4468">  }</front>
<front id="Marlin_mainCPP-4469">  calculate_volumetric_multipliers();</front>
<front id="Marlin_mainCPP-4470">}</front>
<front id="Marlin_mainCPP-4471"></front>
<front id="Marlin_mainCPP-4472">/**</front>
<front id="Marlin_mainCPP-4473"> * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</front>
<front id="Marlin_mainCPP-4474"> */</front>
<front id="Marlin_mainCPP-4475">inline void gcode_M201() {</front>
<front id="Marlin_mainCPP-4476">  for (int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4477">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4478">      max_acceleration_units_per_sq_second[i] = code_value();</front>
<front id="Marlin_mainCPP-4479">    }</front>
<front id="Marlin_mainCPP-4480">  }</front>
<front id="Marlin_mainCPP-4481">  // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</front>
<front id="Marlin_mainCPP-4482">  reset_acceleration_rates();</front>
<front id="Marlin_mainCPP-4483">}</front>
<front id="Marlin_mainCPP-4484"></front>
<front id="Marlin_mainCPP-4485">#if 0 // Not used for Sprinter/grbl gen6</front>
<front id="Marlin_mainCPP-4486">  inline void gcode_M202() {</front>
<front id="Marlin_mainCPP-4487">    for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4488">      if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];</front>
<front id="Marlin_mainCPP-4489">    }</front>
<front id="Marlin_mainCPP-4490">  }</front>
<front id="Marlin_mainCPP-4491">#endif</front>
<front id="Marlin_mainCPP-4492"></front>
<front id="Marlin_mainCPP-4493"></front>
<front id="Marlin_mainCPP-4494">/**</front>
<front id="Marlin_mainCPP-4495"> * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</front>
<front id="Marlin_mainCPP-4496"> */</front>
<front id="Marlin_mainCPP-4497">inline void gcode_M203() {</front>
<front id="Marlin_mainCPP-4498">  for (int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4499">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4500">      max_feedrate[i] = code_value();</front>
<front id="Marlin_mainCPP-4501">    }</front>
<front id="Marlin_mainCPP-4502">  }</front>
<front id="Marlin_mainCPP-4503">}</front>
<front id="Marlin_mainCPP-4504"></front>
<front id="Marlin_mainCPP-4505">/**</front>
<front id="Marlin_mainCPP-4506"> * M204: Set Accelerations in mm/sec^2 (M204 P1200 R3000 T3000)</front>
<front id="Marlin_mainCPP-4507"> *</front>
<front id="Marlin_mainCPP-4508"> *    P = Printing moves</front>
<front id="Marlin_mainCPP-4509"> *    R = Retract only (no X, Y, Z) moves</front>
<front id="Marlin_mainCPP-4510"> *    T = Travel (non printing) moves</front>
<front id="Marlin_mainCPP-4511"> *</front>
<front id="Marlin_mainCPP-4512"> *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate</front>
<front id="Marlin_mainCPP-4513"> */</front>
<front id="Marlin_mainCPP-4514">inline void gcode_M204() {</front>
<front id="Marlin_mainCPP-4515">  if (code_seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.</front>
<front id="Marlin_mainCPP-4516">    travel_acceleration = acceleration = code_value();</front>
<front id="Marlin_mainCPP-4517">    SERIAL_ECHOPAIR("Setting Print and Travel Acceleration: ", acceleration);</front>
<front id="Marlin_mainCPP-4518">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4519">  }</front>
<front id="Marlin_mainCPP-4520">  if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-4521">    acceleration = code_value();</front>
<front id="Marlin_mainCPP-4522">    SERIAL_ECHOPAIR("Setting Print Acceleration: ", acceleration );</front>
<front id="Marlin_mainCPP-4523">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4524">  }</front>
<front id="Marlin_mainCPP-4525">  if (code_seen('R')) {</front>
<front id="Marlin_mainCPP-4526">    retract_acceleration = code_value();</front>
<front id="Marlin_mainCPP-4527">    SERIAL_ECHOPAIR("Setting Retract Acceleration: ", retract_acceleration );</front>
<front id="Marlin_mainCPP-4528">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4529">  }</front>
<front id="Marlin_mainCPP-4530">  if (code_seen('T')) {</front>
<front id="Marlin_mainCPP-4531">    travel_acceleration = code_value();</front>
<front id="Marlin_mainCPP-4532">    SERIAL_ECHOPAIR("Setting Travel Acceleration: ", travel_acceleration );</front>
<front id="Marlin_mainCPP-4533">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4534">  }</front>
<front id="Marlin_mainCPP-4535"></front>
<front id="Marlin_mainCPP-4536">}</front>
<front id="Marlin_mainCPP-4537"></front>
<front id="Marlin_mainCPP-4538">/**</front>
<front id="Marlin_mainCPP-4539"> * M205: Set Advanced Settings</front>
<front id="Marlin_mainCPP-4540"> *</front>
<front id="Marlin_mainCPP-4541"> *    S = Min Feed Rate (mm/s)</front>
<front id="Marlin_mainCPP-4542"> *    T = Min Travel Feed Rate (mm/s)</front>
<front id="Marlin_mainCPP-4543"> *    B = Min Segment Time (s)</front>
<front id="Marlin_mainCPP-4544"> *    X = Max XY Jerk (mm/s/s)</front>
<front id="Marlin_mainCPP-4545"> *    Z = Max Z Jerk (mm/s/s)</front>
<front id="Marlin_mainCPP-4546"> *    E = Max E Jerk (mm/s/s)</front>
<front id="Marlin_mainCPP-4547"> */</front>
<front id="Marlin_mainCPP-4548">inline void gcode_M205() {</front>
<front id="Marlin_mainCPP-4549">  if (code_seen('S')) minimumfeedrate = code_value();</front>
<front id="Marlin_mainCPP-4550">  if (code_seen('T')) mintravelfeedrate = code_value();</front>
<front id="Marlin_mainCPP-4551">  if (code_seen('B')) minsegmenttime = code_value();</front>
<front id="Marlin_mainCPP-4552">  if (code_seen('X')) max_xy_jerk = code_value();</front>
<front id="Marlin_mainCPP-4553">  if (code_seen('Z')) max_z_jerk = code_value();</front>
<front id="Marlin_mainCPP-4554">  if (code_seen('E')) max_e_jerk = code_value();</front>
<front id="Marlin_mainCPP-4555">}</front>
<front id="Marlin_mainCPP-4556"></front>
<front id="Marlin_mainCPP-4557">/**</front>
<front id="Marlin_mainCPP-4558"> * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y</front>
<front id="Marlin_mainCPP-4559"> */</front>
<front id="Marlin_mainCPP-4560">inline void gcode_M206() {</front>
<front id="Marlin_mainCPP-4561">  for (int8_t i=X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4562">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4563">      home_offset[i] = code_value();</front>
<front id="Marlin_mainCPP-4564">    }</front>
<front id="Marlin_mainCPP-4565">  }</front>
<front id="Marlin_mainCPP-4566">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-4567">    if (code_seen('T')) home_offset[X_AXIS] = code_value(); // Theta</front>
<front id="Marlin_mainCPP-4568">    if (code_seen('P')) home_offset[Y_AXIS] = code_value(); // Psi</front>
<front id="Marlin_mainCPP-4569">  #endif</front>
<front id="Marlin_mainCPP-4570">}</front>
<front id="Marlin_mainCPP-4571"></front>
<front id="Marlin_mainCPP-4572">#if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-4573">  /**</front>
<front id="Marlin_mainCPP-4574">   * M665: Set delta configurations</front>
<front id="Marlin_mainCPP-4575">   *</front>
<front id="Marlin_mainCPP-4576">   *    L = diagonal rod</front>
<front id="Marlin_mainCPP-4577">   *    R = delta radius</front>
<front id="Marlin_mainCPP-4578">   *    S = segments per second</front>
<front id="Marlin_mainCPP-4579">   *    A = Alpha (Tower 1) diagonal rod trim</front>
<front id="Marlin_mainCPP-4580">   *    B = Beta (Tower 2) diagonal rod trim</front>
<front id="Marlin_mainCPP-4581">   *    C = Gamma (Tower 3) diagonal rod trim</front>
<front id="Marlin_mainCPP-4582">   */</front>
<front id="Marlin_mainCPP-4583">  inline void gcode_M665() {</front>
<front id="Marlin_mainCPP-4584">    if (code_seen('L')) delta_diagonal_rod = code_value();</front>
<front id="Marlin_mainCPP-4585">    if (code_seen('R')) delta_radius = code_value();</front>
<front id="Marlin_mainCPP-4586">    if (code_seen('S')) delta_segments_per_second = code_value();</front>
<front id="Marlin_mainCPP-4587">    if (code_seen('A')) delta_diagonal_rod_trim_tower_1 = code_value();</front>
<front id="Marlin_mainCPP-4588">    if (code_seen('B')) delta_diagonal_rod_trim_tower_2 = code_value();</front>
<front id="Marlin_mainCPP-4589">    if (code_seen('C')) delta_diagonal_rod_trim_tower_3 = code_value();</front>
<front id="Marlin_mainCPP-4590">    recalc_delta_settings(delta_radius, delta_diagonal_rod);</front>
<front id="Marlin_mainCPP-4591">  }</front>
<front id="Marlin_mainCPP-4592">  /**</front>
<front id="Marlin_mainCPP-4593">   * M666: Set delta endstop adjustment</front>
<front id="Marlin_mainCPP-4594">   */</front>
<front id="Marlin_mainCPP-4595">  inline void gcode_M666() {</front>
<front id="Marlin_mainCPP-4596">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4597">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4598">        SERIAL_ECHOLNPGM("&gt;&gt;&gt; gcode_M666");</front>
<front id="Marlin_mainCPP-4599">      }</front>
<front id="Marlin_mainCPP-4600">    #endif</front>
<front id="Marlin_mainCPP-4601">    for (int8_t i = X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4602">      if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4603">        endstop_adj[i] = code_value();</front>
<front id="Marlin_mainCPP-4604">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4605">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4606">            SERIAL_ECHOPGM("endstop_adj[");</front>
<front id="Marlin_mainCPP-4607">            SERIAL_ECHO(axis_codes[i]);</front>
<front id="Marlin_mainCPP-4608">            SERIAL_ECHOPAIR("] = ", endstop_adj[i]);</front>
<front id="Marlin_mainCPP-4609">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4610">          }</front>
<front id="Marlin_mainCPP-4611">        #endif</front>
<front id="Marlin_mainCPP-4612">      }</front>
<front id="Marlin_mainCPP-4613">    }</front>
<front id="Marlin_mainCPP-4614">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4615">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4616">        SERIAL_ECHOLNPGM("&lt;&lt;&lt; gcode_M666");</front>
<front id="Marlin_mainCPP-4617">      }</front>
<front id="Marlin_mainCPP-4618">    #endif</front>
<front id="Marlin_mainCPP-4619">  }</front>
<front id="Marlin_mainCPP-4620">#elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-4621">  /**</front>
<front id="Marlin_mainCPP-4622">   * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.</front>
<front id="Marlin_mainCPP-4623">   */</front>
<front id="Marlin_mainCPP-4624">  inline void gcode_M666() {</front>
<front id="Marlin_mainCPP-4625">    if (code_seen('Z')) z_endstop_adj = code_value();</front>
<front id="Marlin_mainCPP-4626">    SERIAL_ECHOPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);</front>
<front id="Marlin_mainCPP-4627">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4628">  }</front>
<front id="Marlin_mainCPP-4629"></front>
<front id="Marlin_mainCPP-4630">#endif // !DELTA && Z_DUAL_ENDSTOPS</front>
<front id="Marlin_mainCPP-4631"></front>
<front id="Marlin_mainCPP-4632">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-4633"></front>
<front id="Marlin_mainCPP-4634">  /**</front>
<front id="Marlin_mainCPP-4635">   * M207: Set firmware retraction values</front>
<front id="Marlin_mainCPP-4636">   *</front>
<front id="Marlin_mainCPP-4637">   *   S[+mm]    retract_length</front>
<front id="Marlin_mainCPP-4638">   *   W[+mm]    retract_length_swap (multi-extruder)</front>
<front id="Marlin_mainCPP-4639">   *   F[mm/min] retract_feedrate</front>
<front id="Marlin_mainCPP-4640">   *   Z[mm]     retract_zlift</front>
<front id="Marlin_mainCPP-4641">   */</front>
<front id="Marlin_mainCPP-4642">  inline void gcode_M207() {</front>
<front id="Marlin_mainCPP-4643">    if (code_seen('S')) retract_length = code_value();</front>
<front id="Marlin_mainCPP-4644">    if (code_seen('F')) retract_feedrate = code_value() / 60;</front>
<front id="Marlin_mainCPP-4645">    if (code_seen('Z')) retract_zlift = code_value();</front>
<front id="Marlin_mainCPP-4646">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4647">      if (code_seen('W')) retract_length_swap = code_value();</front>
<front id="Marlin_mainCPP-4648">    #endif</front>
<front id="Marlin_mainCPP-4649">  }</front>
<front id="Marlin_mainCPP-4650"></front>
<front id="Marlin_mainCPP-4651">  /**</front>
<front id="Marlin_mainCPP-4652">   * M208: Set firmware un-retraction values</front>
<front id="Marlin_mainCPP-4653">   *</front>
<front id="Marlin_mainCPP-4654">   *   S[+mm]    retract_recover_length (in addition to M207 S*)</front>
<front id="Marlin_mainCPP-4655">   *   W[+mm]    retract_recover_length_swap (multi-extruder)</front>
<front id="Marlin_mainCPP-4656">   *   F[mm/min] retract_recover_feedrate</front>
<front id="Marlin_mainCPP-4657">   */</front>
<front id="Marlin_mainCPP-4658">  inline void gcode_M208() {</front>
<front id="Marlin_mainCPP-4659">    if (code_seen('S')) retract_recover_length = code_value();</front>
<front id="Marlin_mainCPP-4660">    if (code_seen('F')) retract_recover_feedrate = code_value() / 60;</front>
<front id="Marlin_mainCPP-4661">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4662">      if (code_seen('W')) retract_recover_length_swap = code_value();</front>
<front id="Marlin_mainCPP-4663">    #endif</front>
<front id="Marlin_mainCPP-4664">  }</front>
<front id="Marlin_mainCPP-4665"></front>
<front id="Marlin_mainCPP-4666">  /**</front>
<front id="Marlin_mainCPP-4667">   * M209: Enable automatic retract (M209 S1)</front>
<front id="Marlin_mainCPP-4668">   *       detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-4669">   */</front>
<front id="Marlin_mainCPP-4670">  inline void gcode_M209() {</front>
<front id="Marlin_mainCPP-4671">    if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4672">      int t = code_value_short();</front>
<front id="Marlin_mainCPP-4673">      switch(t) {</front>
<front id="Marlin_mainCPP-4674">        case 0:</front>
<front id="Marlin_mainCPP-4675">          autoretract_enabled = false;</front>
<front id="Marlin_mainCPP-4676">          break;</front>
<front id="Marlin_mainCPP-4677">        case 1:</front>
<front id="Marlin_mainCPP-4678">          autoretract_enabled = true;</front>
<front id="Marlin_mainCPP-4679">          break;</front>
<front id="Marlin_mainCPP-4680">        default:</front>
<front id="Marlin_mainCPP-4681">          unknown_command_error();</front>
<front id="Marlin_mainCPP-4682">          return;</front>
<front id="Marlin_mainCPP-4683">      }</front>
<front id="Marlin_mainCPP-4684">      for (int i=0; i&lt;EXTRUDERS; i++) retracted[i] = false;</front>
<front id="Marlin_mainCPP-4685">    }</front>
<front id="Marlin_mainCPP-4686">  }</front>
<front id="Marlin_mainCPP-4687"></front>
<front id="Marlin_mainCPP-4688">#endif // FWRETRACT</front>
<front id="Marlin_mainCPP-4689"></front>
<front id="Marlin_mainCPP-4690">#if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4691"></front>
<front id="Marlin_mainCPP-4692">  /**</front>
<front id="Marlin_mainCPP-4693">   * M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-4694">   */</front>
<front id="Marlin_mainCPP-4695">  inline void gcode_M218() {</front>
<front id="Marlin_mainCPP-4696">    if (setTargetedHotend(218)) return;</front>
<front id="Marlin_mainCPP-4697"></front>
<front id="Marlin_mainCPP-4698">    if (code_seen('X')) extruder_offset[X_AXIS][target_extruder] = code_value();</front>
<front id="Marlin_mainCPP-4699">    if (code_seen('Y')) extruder_offset[Y_AXIS][target_extruder] = code_value();</front>
<front id="Marlin_mainCPP-4700"></front>
<front id="Marlin_mainCPP-4701">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-4702">      if (code_seen('Z')) extruder_offset[Z_AXIS][target_extruder] = code_value();</front>
<front id="Marlin_mainCPP-4703">    #endif</front>
<front id="Marlin_mainCPP-4704"></front>
<front id="Marlin_mainCPP-4705">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4706">    SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);</front>
<front id="Marlin_mainCPP-4707">    for (int e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="Marlin_mainCPP-4708">      SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-4709">      SERIAL_ECHO(extruder_offset[X_AXIS][e]);</front>
<front id="Marlin_mainCPP-4710">      SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-4711">      SERIAL_ECHO(extruder_offset[Y_AXIS][e]);</front>
<front id="Marlin_mainCPP-4712">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-4713">        SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-4714">        SERIAL_ECHO(extruder_offset[Z_AXIS][e]);</front>
<front id="Marlin_mainCPP-4715">      #endif</front>
<front id="Marlin_mainCPP-4716">    }</front>
<front id="Marlin_mainCPP-4717">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4718">  }</front>
<front id="Marlin_mainCPP-4719"></front>
<front id="Marlin_mainCPP-4720">#endif // EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4721"></front>
<front id="Marlin_mainCPP-4722">/**</front>
<front id="Marlin_mainCPP-4723"> * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)</front>
<front id="Marlin_mainCPP-4724"> */</front>
<front id="Marlin_mainCPP-4725">inline void gcode_M220() {</front>
<front id="Marlin_mainCPP-4726">  if (code_seen('S')) feedrate_multiplier = code_value();</front>
<front id="Marlin_mainCPP-4727">}</front>
<front id="Marlin_mainCPP-4728"></front>
<front id="Marlin_mainCPP-4729">/**</front>
<front id="Marlin_mainCPP-4730"> * M221: Set extrusion percentage (M221 T0 S95)</front>
<front id="Marlin_mainCPP-4731"> */</front>
<front id="Marlin_mainCPP-4732">inline void gcode_M221() {</front>
<front id="Marlin_mainCPP-4733">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4734">    int sval = code_value();</front>
<front id="Marlin_mainCPP-4735">    if (code_seen('T')) {</front>
<front id="Marlin_mainCPP-4736">      if (setTargetedHotend(221)) return;</front>
<front id="Marlin_mainCPP-4737">      extruder_multiplier[target_extruder] = sval;</front>
<front id="Marlin_mainCPP-4738">    }</front>
<front id="Marlin_mainCPP-4739">    else {</front>
<front id="Marlin_mainCPP-4740">      extruder_multiplier[active_extruder] = sval;</front>
<front id="Marlin_mainCPP-4741">    }</front>
<front id="Marlin_mainCPP-4742">  }</front>
<front id="Marlin_mainCPP-4743">}</front>
<front id="Marlin_mainCPP-4744"></front>
<front id="Marlin_mainCPP-4745">/**</front>
<front id="Marlin_mainCPP-4746"> * M226: Wait until the specified pin reaches the state required (M226 P&lt;pin&gt; S&lt;state&gt;)</front>
<front id="Marlin_mainCPP-4747"> */</front>
<front id="Marlin_mainCPP-4748">inline void gcode_M226() {</front>
<front id="Marlin_mainCPP-4749">  if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-4750">    int pin_number = code_value();</front>
<front id="Marlin_mainCPP-4751"></front>
<front id="Marlin_mainCPP-4752">    int pin_state = code_seen('S') ? code_value() : -1; // required pin state - default is inverted</front>
<front id="Marlin_mainCPP-4753"></front>
<front id="Marlin_mainCPP-4754">    if (pin_state &gt;= -1 && pin_state &lt;= 1) {</front>
<front id="Marlin_mainCPP-4755"></front>
<front id="Marlin_mainCPP-4756">      for (uint8_t i = 0; i &lt; COUNT(sensitive_pins); i++) {</front>
<front id="Marlin_mainCPP-4757">        if (sensitive_pins[i] == pin_number) {</front>
<front id="Marlin_mainCPP-4758">          pin_number = -1;</front>
<front id="Marlin_mainCPP-4759">          break;</front>
<front id="Marlin_mainCPP-4760">        }</front>
<front id="Marlin_mainCPP-4761">      }</front>
<front id="Marlin_mainCPP-4762"></front>
<front id="Marlin_mainCPP-4763">      if (pin_number &gt; -1) {</front>
<front id="Marlin_mainCPP-4764">        int target = LOW;</front>
<front id="Marlin_mainCPP-4765"></front>
<front id="Marlin_mainCPP-4766">        st_synchronize();</front>
<front id="Marlin_mainCPP-4767"></front>
<front id="Marlin_mainCPP-4768">        pinMode(pin_number, INPUT);</front>
<front id="Marlin_mainCPP-4769"></front>
<front id="Marlin_mainCPP-4770">        switch(pin_state){</front>
<front id="Marlin_mainCPP-4771">          case 1:</front>
<front id="Marlin_mainCPP-4772">            target = HIGH;</front>
<front id="Marlin_mainCPP-4773">            break;</front>
<front id="Marlin_mainCPP-4774"></front>
<front id="Marlin_mainCPP-4775">          case 0:</front>
<front id="Marlin_mainCPP-4776">            target = LOW;</front>
<front id="Marlin_mainCPP-4777">            break;</front>
<front id="Marlin_mainCPP-4778"></front>
<front id="Marlin_mainCPP-4779">          case -1:</front>
<front id="Marlin_mainCPP-4780">            target = !digitalRead(pin_number);</front>
<front id="Marlin_mainCPP-4781">            break;</front>
<front id="Marlin_mainCPP-4782">        }</front>
<front id="Marlin_mainCPP-4783"></front>
<front id="Marlin_mainCPP-4784">        while (digitalRead(pin_number) != target) idle();</front>
<front id="Marlin_mainCPP-4785"></front>
<front id="Marlin_mainCPP-4786">      } // pin_number &gt; -1</front>
<front id="Marlin_mainCPP-4787">    } // pin_state -1 0 1</front>
<front id="Marlin_mainCPP-4788">  } // code_seen('P')</front>
<front id="Marlin_mainCPP-4789">}</front>
<front id="Marlin_mainCPP-4790"></front>
<front id="Marlin_mainCPP-4791">#if HAS_SERVOS</front>
<front id="Marlin_mainCPP-4792"></front>
<front id="Marlin_mainCPP-4793">  /**</front>
<front id="Marlin_mainCPP-4794">   * M280: Get or set servo position. P&lt;index&gt; S&lt;angle&gt;</front>
<front id="Marlin_mainCPP-4795">   */</front>
<front id="Marlin_mainCPP-4796">  inline void gcode_M280() {</front>
<front id="Marlin_mainCPP-4797">    int servo_index = code_seen('P') ? code_value_short() : -1;</front>
<front id="Marlin_mainCPP-4798">    int servo_position = 0;</front>
<front id="Marlin_mainCPP-4799">    if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4800">      servo_position = code_value_short();</front>
<front id="Marlin_mainCPP-4801">      if (servo_index &gt;= 0 && servo_index &lt; NUM_SERVOS)</front>
<front id="Marlin_mainCPP-4802">        servo[servo_index].move(servo_position);</front>
<front id="Marlin_mainCPP-4803">      else {</front>
<front id="Marlin_mainCPP-4804">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4805">        SERIAL_ECHO("Servo ");</front>
<front id="Marlin_mainCPP-4806">        SERIAL_ECHO(servo_index);</front>
<front id="Marlin_mainCPP-4807">        SERIAL_ECHOLN(" out of range");</front>
<front id="Marlin_mainCPP-4808">      }</front>
<front id="Marlin_mainCPP-4809">    }</front>
<front id="Marlin_mainCPP-4810">    else if (servo_index &gt;= 0) {</front>
<front id="Marlin_mainCPP-4811">      SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-4812">      SERIAL_PROTOCOL(" Servo ");</front>
<front id="Marlin_mainCPP-4813">      SERIAL_PROTOCOL(servo_index);</front>
<front id="Marlin_mainCPP-4814">      SERIAL_PROTOCOL(": ");</front>
<front id="Marlin_mainCPP-4815">      SERIAL_PROTOCOL(servo[servo_index].read());</front>
<front id="Marlin_mainCPP-4816">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4817">    }</front>
<front id="Marlin_mainCPP-4818">  }</front>
<front id="Marlin_mainCPP-4819"></front>
<front id="Marlin_mainCPP-4820">#endif // HAS_SERVOS</front>
<front id="Marlin_mainCPP-4821"></front>
<front id="Marlin_mainCPP-4822">#if HAS_BUZZER</front>
<front id="Marlin_mainCPP-4823"></front>
<front id="Marlin_mainCPP-4824">  /**</front>
<front id="Marlin_mainCPP-4825">   * M300: Play beep sound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</front>
<front id="Marlin_mainCPP-4826">   */</front>
<front id="Marlin_mainCPP-4827">  inline void gcode_M300() {</front>
<front id="Marlin_mainCPP-4828">    uint16_t beepS = code_seen('S') ? code_value_short() : 110;</front>
<front id="Marlin_mainCPP-4829">    uint32_t beepP = code_seen('P') ? code_value_long() : 1000;</front>
<front id="Marlin_mainCPP-4830">    if (beepP &gt; 5000) beepP = 5000; // limit to 5 seconds</front>
<front id="Marlin_mainCPP-4831">    buzz(beepP, beepS);</front>
<front id="Marlin_mainCPP-4832">  }</front>
<front id="Marlin_mainCPP-4833"></front>
<front id="Marlin_mainCPP-4834">#endif // HAS_BUZZER</front>
<front id="Marlin_mainCPP-4835"></front>
<front id="Marlin_mainCPP-4836">#if ENABLED(PIDTEMP)</front>
<front id="Marlin_mainCPP-4837"></front>
<front id="Marlin_mainCPP-4838">  /**</front>
<front id="Marlin_mainCPP-4839">   * M301: Set PID parameters P I D (and optionally C, L)</front>
<front id="Marlin_mainCPP-4840">   *</front>
<front id="Marlin_mainCPP-4841">   *   P[float] Kp term</front>
<front id="Marlin_mainCPP-4842">   *   I[float] Ki term (unscaled)</front>
<front id="Marlin_mainCPP-4843">   *   D[float] Kd term (unscaled)</front>
<front id="Marlin_mainCPP-4844">   *</front>
<front id="Marlin_mainCPP-4845">   * With PID_ADD_EXTRUSION_RATE:</front>
<front id="Marlin_mainCPP-4846">   *</front>
<front id="Marlin_mainCPP-4847">   *   C[float] Kc term</front>
<front id="Marlin_mainCPP-4848">   *   L[float] LPQ length</front>
<front id="Marlin_mainCPP-4849">   */</front>
<front id="Marlin_mainCPP-4850">  inline void gcode_M301() {</front>
<front id="Marlin_mainCPP-4851"></front>
<front id="Marlin_mainCPP-4852">    // multi-extruder PID patch: M301 updates or prints a single extruder's PID values</front>
<front id="Marlin_mainCPP-4853">    // default behaviour (omitting E parameter) is to update for extruder 0 only</front>
<front id="Marlin_mainCPP-4854">    int e = code_seen('E') ? code_value() : 0; // extruder being updated</front>
<front id="Marlin_mainCPP-4855"></front>
<front id="Marlin_mainCPP-4856">    if (e &lt; EXTRUDERS) { // catch bad input value</front>
<front id="Marlin_mainCPP-4857">      if (code_seen('P')) PID_PARAM(Kp, e) = code_value();</front>
<front id="Marlin_mainCPP-4858">      if (code_seen('I')) PID_PARAM(Ki, e) = scalePID_i(code_value());</front>
<front id="Marlin_mainCPP-4859">      if (code_seen('D')) PID_PARAM(Kd, e) = scalePID_d(code_value());</front>
<front id="Marlin_mainCPP-4860">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Marlin_mainCPP-4861">        if (code_seen('C')) PID_PARAM(Kc, e) = code_value();</front>
<front id="Marlin_mainCPP-4862">        if (code_seen('L')) lpq_len = code_value();</front>
<front id="Marlin_mainCPP-4863">        NOMORE(lpq_len, LPQ_MAX_LEN);</front>
<front id="Marlin_mainCPP-4864">      #endif</front>
<front id="Marlin_mainCPP-4865"></front>
<front id="Marlin_mainCPP-4866">      updatePID();</front>
<front id="Marlin_mainCPP-4867">      SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-4868">      #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="Marlin_mainCPP-4869">        SERIAL_PROTOCOL(" e:"); // specify extruder in serial output</front>
<front id="Marlin_mainCPP-4870">        SERIAL_PROTOCOL(e);</front>
<front id="Marlin_mainCPP-4871">      #endif // PID_PARAMS_PER_EXTRUDER</front>
<front id="Marlin_mainCPP-4872">      SERIAL_PROTOCOL(" p:");</front>
<front id="Marlin_mainCPP-4873">      SERIAL_PROTOCOL(PID_PARAM(Kp, e));</front>
<front id="Marlin_mainCPP-4874">      SERIAL_PROTOCOL(" i:");</front>
<front id="Marlin_mainCPP-4875">      SERIAL_PROTOCOL(unscalePID_i(PID_PARAM(Ki, e)));</front>
<front id="Marlin_mainCPP-4876">      SERIAL_PROTOCOL(" d:");</front>
<front id="Marlin_mainCPP-4877">      SERIAL_PROTOCOL(unscalePID_d(PID_PARAM(Kd, e)));</front>
<front id="Marlin_mainCPP-4878">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Marlin_mainCPP-4879">        SERIAL_PROTOCOL(" c:");</front>
<front id="Marlin_mainCPP-4880">        //Kc does not have scaling applied above, or in resetting defaults</front>
<front id="Marlin_mainCPP-4881">        SERIAL_PROTOCOL(PID_PARAM(Kc, e));</front>
<front id="Marlin_mainCPP-4882">      #endif</front>
<front id="Marlin_mainCPP-4883">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4884">    }</front>
<front id="Marlin_mainCPP-4885">    else {</front>
<front id="Marlin_mainCPP-4886">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4887">      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-4888">    }</front>
<front id="Marlin_mainCPP-4889">  }</front>
<front id="Marlin_mainCPP-4890"></front>
<front id="Marlin_mainCPP-4891">#endif // PIDTEMP</front>
<front id="Marlin_mainCPP-4892"></front>
<front id="Marlin_mainCPP-4893">#if ENABLED(PIDTEMPBED)</front>
<front id="Marlin_mainCPP-4894"></front>
<front id="Marlin_mainCPP-4895">  inline void gcode_M304() {</front>
<front id="Marlin_mainCPP-4896">    if (code_seen('P')) bedKp = code_value();</front>
<front id="Marlin_mainCPP-4897">    if (code_seen('I')) bedKi = scalePID_i(code_value());</front>
<front id="Marlin_mainCPP-4898">    if (code_seen('D')) bedKd = scalePID_d(code_value());</front>
<front id="Marlin_mainCPP-4899"></front>
<front id="Marlin_mainCPP-4900">    updatePID();</front>
<front id="Marlin_mainCPP-4901">    SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-4902">    SERIAL_PROTOCOL(" p:");</front>
<front id="Marlin_mainCPP-4903">    SERIAL_PROTOCOL(bedKp);</front>
<front id="Marlin_mainCPP-4904">    SERIAL_PROTOCOL(" i:");</front>
<front id="Marlin_mainCPP-4905">    SERIAL_PROTOCOL(unscalePID_i(bedKi));</front>
<front id="Marlin_mainCPP-4906">    SERIAL_PROTOCOL(" d:");</front>
<front id="Marlin_mainCPP-4907">    SERIAL_PROTOCOL(unscalePID_d(bedKd));</front>
<front id="Marlin_mainCPP-4908">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4909">  }</front>
<front id="Marlin_mainCPP-4910"></front>
<front id="Marlin_mainCPP-4911">#endif // PIDTEMPBED</front>
<front id="Marlin_mainCPP-4912"></front>
<front id="Marlin_mainCPP-4913">#if defined(CHDK) || HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-4914"></front>
<front id="Marlin_mainCPP-4915">  /**</front>
<front id="Marlin_mainCPP-4916">   * M240: Trigger a camera by emulating a Canon RC-1</front>
<front id="Marlin_mainCPP-4917">   *       See http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="Marlin_mainCPP-4918">   */</front>
<front id="Marlin_mainCPP-4919">  inline void gcode_M240() {</front>
<front id="Marlin_mainCPP-4920">    #ifdef CHDK</front>
<front id="Marlin_mainCPP-4921"></front>
<front id="Marlin_mainCPP-4922">       OUT_WRITE(CHDK, HIGH);</front>
<front id="Marlin_mainCPP-4923">       chdkHigh = millis();</front>
<front id="Marlin_mainCPP-4924">       chdkActive = true;</front>
<front id="Marlin_mainCPP-4925"></front>
<front id="Marlin_mainCPP-4926">    #elif HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-4927"></front>
<front id="Marlin_mainCPP-4928">      const uint8_t NUM_PULSES = 16;</front>
<front id="Marlin_mainCPP-4929">      const float PULSE_LENGTH = 0.01524;</front>
<front id="Marlin_mainCPP-4930">      for (int i = 0; i &lt; NUM_PULSES; i++) {</front>
<front id="Marlin_mainCPP-4931">        WRITE(PHOTOGRAPH_PIN, HIGH);</front>
<front id="Marlin_mainCPP-4932">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4933">        WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-4934">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4935">      }</front>
<front id="Marlin_mainCPP-4936">      delay(7.33);</front>
<front id="Marlin_mainCPP-4937">      for (int i = 0; i &lt; NUM_PULSES; i++) {</front>
<front id="Marlin_mainCPP-4938">        WRITE(PHOTOGRAPH_PIN, HIGH);</front>
<front id="Marlin_mainCPP-4939">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4940">        WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-4941">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4942">      }</front>
<front id="Marlin_mainCPP-4943"></front>
<front id="Marlin_mainCPP-4944">    #endif // !CHDK && HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-4945">  }</front>
<front id="Marlin_mainCPP-4946"></front>
<front id="Marlin_mainCPP-4947">#endif // CHDK || PHOTOGRAPH_PIN</front>
<front id="Marlin_mainCPP-4948"></front>
<front id="Marlin_mainCPP-4949">#if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="Marlin_mainCPP-4950"></front>
<front id="Marlin_mainCPP-4951">  /**</front>
<front id="Marlin_mainCPP-4952">   * M250: Read and optionally set the LCD contrast</front>
<front id="Marlin_mainCPP-4953">   */</front>
<front id="Marlin_mainCPP-4954">  inline void gcode_M250() {</front>
<front id="Marlin_mainCPP-4955">    if (code_seen('C')) lcd_setcontrast(code_value_short() & 0x3F);</front>
<front id="Marlin_mainCPP-4956">    SERIAL_PROTOCOLPGM("lcd contrast value: ");</front>
<front id="Marlin_mainCPP-4957">    SERIAL_PROTOCOL(lcd_contrast);</front>
<front id="Marlin_mainCPP-4958">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4959">  }</front>
<front id="Marlin_mainCPP-4960"></front>
<front id="Marlin_mainCPP-4961">#endif // HAS_LCD_CONTRAST</front>
<front id="Marlin_mainCPP-4962"></front>
<front id="Marlin_mainCPP-4963">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-4964"></front>
<front id="Marlin_mainCPP-4965">  void set_extrude_min_temp(float temp) { extrude_min_temp = temp; }</front>
<front id="Marlin_mainCPP-4966"></front>
<front id="Marlin_mainCPP-4967">  /**</front>
<front id="Marlin_mainCPP-4968">   * M302: Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</front>
<front id="Marlin_mainCPP-4969">   */</front>
<front id="Marlin_mainCPP-4970">  inline void gcode_M302() {</front>
<front id="Marlin_mainCPP-4971">    set_extrude_min_temp(code_seen('S') ? code_value() : 0);</front>
<front id="Marlin_mainCPP-4972">  }</front>
<front id="Marlin_mainCPP-4973"></front>
<front id="Marlin_mainCPP-4974">#endif // PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-4975"></front>
<front id="Marlin_mainCPP-4976">/**</front>
<front id="Marlin_mainCPP-4977"> * M303: PID relay autotune</front>
<front id="Marlin_mainCPP-4978"> *       S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</front>
<front id="Marlin_mainCPP-4979"> *       E&lt;extruder&gt; (-1 for the bed)</front>
<front id="Marlin_mainCPP-4980"> *       C&lt;cycles&gt;</front>
<front id="Marlin_mainCPP-4981"> */</front>
<front id="Marlin_mainCPP-4982">inline void gcode_M303() {</front>
<front id="Marlin_mainCPP-4983">  int e = code_seen('E') ? code_value_short() : 0;</front>
<front id="Marlin_mainCPP-4984">  int c = code_seen('C') ? code_value_short() : 5;</front>
<front id="Marlin_mainCPP-4985">  float temp = code_seen('S') ? code_value() : (e &lt; 0 ? 70.0 : 150.0);</front>
<front id="Marlin_mainCPP-4986">  PID_autotune(temp, e, c);</front>
<front id="Marlin_mainCPP-4987">}</front>
<front id="Marlin_mainCPP-4988"></front>
<front id="Marlin_mainCPP-4989">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-4990">  bool SCARA_move_to_cal(uint8_t delta_x, uint8_t delta_y) {</front>
<front id="Marlin_mainCPP-4991">    //SoftEndsEnabled = false;              // Ignore soft endstops during calibration</front>
<front id="Marlin_mainCPP-4992">    //SERIAL_ECHOLN(" Soft endstops disabled ");</front>
<front id="Marlin_mainCPP-4993">    if (IsRunning()) {</front>
<front id="Marlin_mainCPP-4994">      //gcode_get_destination(); // For X Y Z E F</front>
<front id="Marlin_mainCPP-4995">      delta[X_AXIS] = delta_x;</front>
<front id="Marlin_mainCPP-4996">      delta[Y_AXIS] = delta_y;</front>
<front id="Marlin_mainCPP-4997">      calculate_SCARA_forward_Transform(delta);</front>
<front id="Marlin_mainCPP-4998">      destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];</front>
<front id="Marlin_mainCPP-4999">      destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];</front>
<front id="Marlin_mainCPP-5000">      prepare_move();</front>
<front id="Marlin_mainCPP-5001">      //ok_to_send();</front>
<front id="Marlin_mainCPP-5002">      return true;</front>
<front id="Marlin_mainCPP-5003">    }</front>
<front id="Marlin_mainCPP-5004">    return false;</front>
<front id="Marlin_mainCPP-5005">  }</front>
<front id="Marlin_mainCPP-5006"></front>
<front id="Marlin_mainCPP-5007">  /**</front>
<front id="Marlin_mainCPP-5008">   * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)</front>
<front id="Marlin_mainCPP-5009">   */</front>
<front id="Marlin_mainCPP-5010">  inline bool gcode_M360() {</front>
<front id="Marlin_mainCPP-5011">    SERIAL_ECHOLN(" Cal: Theta 0 ");</front>
<front id="Marlin_mainCPP-5012">    return SCARA_move_to_cal(0, 120);</front>
<front id="Marlin_mainCPP-5013">  }</front>
<front id="Marlin_mainCPP-5014"></front>
<front id="Marlin_mainCPP-5015">  /**</front>
<front id="Marlin_mainCPP-5016">   * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-5017">   */</front>
<front id="Marlin_mainCPP-5018">  inline bool gcode_M361() {</front>
<front id="Marlin_mainCPP-5019">    SERIAL_ECHOLN(" Cal: Theta 90 ");</front>
<front id="Marlin_mainCPP-5020">    return SCARA_move_to_cal(90, 130);</front>
<front id="Marlin_mainCPP-5021">  }</front>
<front id="Marlin_mainCPP-5022"></front>
<front id="Marlin_mainCPP-5023">  /**</front>
<front id="Marlin_mainCPP-5024">   * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)</front>
<front id="Marlin_mainCPP-5025">   */</front>
<front id="Marlin_mainCPP-5026">  inline bool gcode_M362() {</front>
<front id="Marlin_mainCPP-5027">    SERIAL_ECHOLN(" Cal: Psi 0 ");</front>
<front id="Marlin_mainCPP-5028">    return SCARA_move_to_cal(60, 180);</front>
<front id="Marlin_mainCPP-5029">  }</front>
<front id="Marlin_mainCPP-5030"></front>
<front id="Marlin_mainCPP-5031">  /**</front>
<front id="Marlin_mainCPP-5032">   * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-5033">   */</front>
<front id="Marlin_mainCPP-5034">  inline bool gcode_M363() {</front>
<front id="Marlin_mainCPP-5035">    SERIAL_ECHOLN(" Cal: Psi 90 ");</front>
<front id="Marlin_mainCPP-5036">    return SCARA_move_to_cal(50, 90);</front>
<front id="Marlin_mainCPP-5037">  }</front>
<front id="Marlin_mainCPP-5038"></front>
<front id="Marlin_mainCPP-5039">  /**</front>
<front id="Marlin_mainCPP-5040">   * M364: SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)</front>
<front id="Marlin_mainCPP-5041">   */</front>
<front id="Marlin_mainCPP-5042">  inline bool gcode_M364() {</front>
<front id="Marlin_mainCPP-5043">    SERIAL_ECHOLN(" Cal: Theta-Psi 90 ");</front>
<front id="Marlin_mainCPP-5044">    return SCARA_move_to_cal(45, 135);</front>
<front id="Marlin_mainCPP-5045">  }</front>
<front id="Marlin_mainCPP-5046"></front>
<front id="Marlin_mainCPP-5047">  /**</front>
<front id="Marlin_mainCPP-5048">   * M365: SCARA calibration: Scaling factor, X, Y, Z axis</front>
<front id="Marlin_mainCPP-5049">   */</front>
<front id="Marlin_mainCPP-5050">  inline void gcode_M365() {</front>
<front id="Marlin_mainCPP-5051">    for (int8_t i = X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-5052">      if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-5053">        axis_scaling[i] = code_value();</front>
<front id="Marlin_mainCPP-5054">      }</front>
<front id="Marlin_mainCPP-5055">    }</front>
<front id="Marlin_mainCPP-5056">  }</front>
<front id="Marlin_mainCPP-5057"></front>
<front id="Marlin_mainCPP-5058">#endif // SCARA</front>
<front id="Marlin_mainCPP-5059"></front>
<front id="Marlin_mainCPP-5060">#if ENABLED(EXT_SOLENOID)</front>
<front id="Marlin_mainCPP-5061"></front>
<front id="Marlin_mainCPP-5062">  void enable_solenoid(uint8_t num) {</front>
<front id="Marlin_mainCPP-5063">    switch(num) {</front>
<front id="Marlin_mainCPP-5064">      case 0:</front>
<front id="Marlin_mainCPP-5065">        OUT_WRITE(SOL0_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5066">        break;</front>
<front id="Marlin_mainCPP-5067">        #if HAS_SOLENOID_1</front>
<front id="Marlin_mainCPP-5068">          case 1:</front>
<front id="Marlin_mainCPP-5069">            OUT_WRITE(SOL1_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5070">            break;</front>
<front id="Marlin_mainCPP-5071">        #endif</front>
<front id="Marlin_mainCPP-5072">        #if HAS_SOLENOID_2</front>
<front id="Marlin_mainCPP-5073">          case 2:</front>
<front id="Marlin_mainCPP-5074">            OUT_WRITE(SOL2_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5075">            break;</front>
<front id="Marlin_mainCPP-5076">        #endif</front>
<front id="Marlin_mainCPP-5077">        #if HAS_SOLENOID_3</front>
<front id="Marlin_mainCPP-5078">          case 3:</front>
<front id="Marlin_mainCPP-5079">            OUT_WRITE(SOL3_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5080">            break;</front>
<front id="Marlin_mainCPP-5081">        #endif</front>
<front id="Marlin_mainCPP-5082">      default:</front>
<front id="Marlin_mainCPP-5083">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5084">        SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);</front>
<front id="Marlin_mainCPP-5085">        break;</front>
<front id="Marlin_mainCPP-5086">    }</front>
<front id="Marlin_mainCPP-5087">  }</front>
<front id="Marlin_mainCPP-5088"></front>
<front id="Marlin_mainCPP-5089">  void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }</front>
<front id="Marlin_mainCPP-5090"></front>
<front id="Marlin_mainCPP-5091">  void disable_all_solenoids() {</front>
<front id="Marlin_mainCPP-5092">    OUT_WRITE(SOL0_PIN, LOW);</front>
<front id="Marlin_mainCPP-5093">    OUT_WRITE(SOL1_PIN, LOW);</front>
<front id="Marlin_mainCPP-5094">    OUT_WRITE(SOL2_PIN, LOW);</front>
<front id="Marlin_mainCPP-5095">    OUT_WRITE(SOL3_PIN, LOW);</front>
<front id="Marlin_mainCPP-5096">  }</front>
<front id="Marlin_mainCPP-5097"></front>
<front id="Marlin_mainCPP-5098">  /**</front>
<front id="Marlin_mainCPP-5099">   * M380: Enable solenoid on the active extruder</front>
<front id="Marlin_mainCPP-5100">   */</front>
<front id="Marlin_mainCPP-5101">  inline void gcode_M380() { enable_solenoid_on_active_extruder(); }</front>
<front id="Marlin_mainCPP-5102"></front>
<front id="Marlin_mainCPP-5103">  /**</front>
<front id="Marlin_mainCPP-5104">   * M381: Disable all solenoids</front>
<front id="Marlin_mainCPP-5105">   */</front>
<front id="Marlin_mainCPP-5106">  inline void gcode_M381() { disable_all_solenoids(); }</front>
<front id="Marlin_mainCPP-5107"></front>
<front id="Marlin_mainCPP-5108">#endif // EXT_SOLENOID</front>
<front id="Marlin_mainCPP-5109"></front>
<front id="Marlin_mainCPP-5110">/**</front>
<front id="Marlin_mainCPP-5111"> * M400: Finish all moves</front>
<front id="Marlin_mainCPP-5112"> */</front>
<front id="Marlin_mainCPP-5113">inline void gcode_M400() { st_synchronize(); }</front>
<front id="Marlin_mainCPP-5114"></front>
<front id="Marlin_mainCPP-5115">#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY))</front>
<front id="Marlin_mainCPP-5116"></front>
<front id="Marlin_mainCPP-5117">  /**</front>
<front id="Marlin_mainCPP-5118">   * M401: Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-5119">   */</front>
<front id="Marlin_mainCPP-5120">  inline void gcode_M401() {</front>
<front id="Marlin_mainCPP-5121">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-5122">      raise_z_for_servo();</front>
<front id="Marlin_mainCPP-5123">    #endif</front>
<front id="Marlin_mainCPP-5124">    deploy_z_probe();</front>
<front id="Marlin_mainCPP-5125">  }</front>
<front id="Marlin_mainCPP-5126"></front>
<front id="Marlin_mainCPP-5127">  /**</front>
<front id="Marlin_mainCPP-5128">   * M402: Retract Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-5129">   */</front>
<front id="Marlin_mainCPP-5130">  inline void gcode_M402() {</front>
<front id="Marlin_mainCPP-5131">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-5132">      raise_z_for_servo();</front>
<front id="Marlin_mainCPP-5133">    #endif</front>
<front id="Marlin_mainCPP-5134">    stow_z_probe(false);</front>
<front id="Marlin_mainCPP-5135">  }</front>
<front id="Marlin_mainCPP-5136"></front>
<front id="Marlin_mainCPP-5137">#endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-5138"></front>
<front id="Marlin_mainCPP-5139">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="Marlin_mainCPP-5140"></front>
<front id="Marlin_mainCPP-5141">  /**</front>
<front id="Marlin_mainCPP-5142">   * M404: Display or set the nominal filament width (3mm, 1.75mm ) W&lt;3.0&gt;</front>
<front id="Marlin_mainCPP-5143">   */</front>
<front id="Marlin_mainCPP-5144">  inline void gcode_M404() {</front>
<front id="Marlin_mainCPP-5145">    #if HAS_FILWIDTH</front>
<front id="Marlin_mainCPP-5146">      if (code_seen('W')) {</front>
<front id="Marlin_mainCPP-5147">        filament_width_nominal = code_value();</front>
<front id="Marlin_mainCPP-5148">      }</front>
<front id="Marlin_mainCPP-5149">      else {</front>
<front id="Marlin_mainCPP-5150">        SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");</front>
<front id="Marlin_mainCPP-5151">        SERIAL_PROTOCOLLN(filament_width_nominal);</front>
<front id="Marlin_mainCPP-5152">      }</front>
<front id="Marlin_mainCPP-5153">    #endif</front>
<front id="Marlin_mainCPP-5154">  }</front>
<front id="Marlin_mainCPP-5155"></front>
<front id="Marlin_mainCPP-5156">  /**</front>
<front id="Marlin_mainCPP-5157">   * M405: Turn on filament sensor for control</front>
<front id="Marlin_mainCPP-5158">   */</front>
<front id="Marlin_mainCPP-5159">  inline void gcode_M405() {</front>
<front id="Marlin_mainCPP-5160">    if (code_seen('D')) meas_delay_cm = code_value();</front>
<front id="Marlin_mainCPP-5161">    if (meas_delay_cm &gt; MAX_MEASUREMENT_DELAY) meas_delay_cm = MAX_MEASUREMENT_DELAY;</front>
<front id="Marlin_mainCPP-5162"></front>
<front id="Marlin_mainCPP-5163">    if (delay_index2 == -1) { //initialize the ring buffer if it has not been done since startup</front>
<front id="Marlin_mainCPP-5164">      int temp_ratio = widthFil_to_size_ratio();</front>
<front id="Marlin_mainCPP-5165"></front>
<front id="Marlin_mainCPP-5166">      for (delay_index1 = 0; delay_index1 &lt; MAX_MEASUREMENT_DELAY + 1; ++delay_index1)</front>
<front id="Marlin_mainCPP-5167">        measurement_delay[delay_index1] = temp_ratio - 100;  //subtract 100 to scale within a signed byte</front>
<front id="Marlin_mainCPP-5168"></front>
<front id="Marlin_mainCPP-5169">      delay_index1 = delay_index2 = 0;</front>
<front id="Marlin_mainCPP-5170">    }</front>
<front id="Marlin_mainCPP-5171"></front>
<front id="Marlin_mainCPP-5172">    filament_sensor = true;</front>
<front id="Marlin_mainCPP-5173"></front>
<front id="Marlin_mainCPP-5174">    //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");</front>
<front id="Marlin_mainCPP-5175">    //SERIAL_PROTOCOL(filament_width_meas);</front>
<front id="Marlin_mainCPP-5176">    //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");</front>
<front id="Marlin_mainCPP-5177">    //SERIAL_PROTOCOL(extruder_multiplier[active_extruder]);</front>
<front id="Marlin_mainCPP-5178">  }</front>
<front id="Marlin_mainCPP-5179"></front>
<front id="Marlin_mainCPP-5180">  /**</front>
<front id="Marlin_mainCPP-5181">   * M406: Turn off filament sensor for control</front>
<front id="Marlin_mainCPP-5182">   */</front>
<front id="Marlin_mainCPP-5183">  inline void gcode_M406() { filament_sensor = false; }</front>
<front id="Marlin_mainCPP-5184"></front>
<front id="Marlin_mainCPP-5185">  /**</front>
<front id="Marlin_mainCPP-5186">   * M407: Get measured filament diameter on serial output</front>
<front id="Marlin_mainCPP-5187">   */</front>
<front id="Marlin_mainCPP-5188">  inline void gcode_M407() {</front>
<front id="Marlin_mainCPP-5189">    SERIAL_PROTOCOLPGM("Filament dia (measured mm):");</front>
<front id="Marlin_mainCPP-5190">    SERIAL_PROTOCOLLN(filament_width_meas);</front>
<front id="Marlin_mainCPP-5191">  }</front>
<front id="Marlin_mainCPP-5192"></front>
<front id="Marlin_mainCPP-5193">#endif // FILAMENT_SENSOR</front>
<front id="Marlin_mainCPP-5194"></front>
<front id="Marlin_mainCPP-5195">/**</front>
<front id="Marlin_mainCPP-5196"> * M410: Quickstop - Abort all planned moves</front>
<front id="Marlin_mainCPP-5197"> *</front>
<front id="Marlin_mainCPP-5198"> * This will stop the carriages mid-move, so most likely they</front>
<front id="Marlin_mainCPP-5199"> * will be out of sync with the stepper position after this.</front>
<front id="Marlin_mainCPP-5200"> */</front>
<front id="Marlin_mainCPP-5201">inline void gcode_M410() { quickStop(); }</front>
<front id="Marlin_mainCPP-5202"></front>
<front id="Marlin_mainCPP-5203"></front>
<front id="Marlin_mainCPP-5204">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-5205"></front>
<front id="Marlin_mainCPP-5206">  /**</front>
<front id="Marlin_mainCPP-5207">   * M420: Enable/Disable Mesh Bed Leveling</front>
<front id="Marlin_mainCPP-5208">   */</front>
<front id="Marlin_mainCPP-5209">  inline void gcode_M420() { if (code_seen('S') && code_has_value()) mbl.active = !!code_value_short(); }</front>
<front id="Marlin_mainCPP-5210"></front>
<front id="Marlin_mainCPP-5211">  /**</front>
<front id="Marlin_mainCPP-5212">   * M421: Set a single Mesh Bed Leveling Z coordinate</front>
<front id="Marlin_mainCPP-5213">   */</front>
<front id="Marlin_mainCPP-5214">  inline void gcode_M421() {</front>
<front id="Marlin_mainCPP-5215">    float x, y, z;</front>
<front id="Marlin_mainCPP-5216">    bool err = false, hasX, hasY, hasZ;</front>
<front id="Marlin_mainCPP-5217">    if ((hasX = code_seen('X'))) x = code_value();</front>
<front id="Marlin_mainCPP-5218">    if ((hasY = code_seen('Y'))) y = code_value();</front>
<front id="Marlin_mainCPP-5219">    if ((hasZ = code_seen('Z'))) z = code_value();</front>
<front id="Marlin_mainCPP-5220"></front>
<front id="Marlin_mainCPP-5221">    if (!hasX || !hasY || !hasZ) {</front>
<front id="Marlin_mainCPP-5222">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5223">      SERIAL_ERRORLNPGM(MSG_ERR_M421_REQUIRES_XYZ);</front>
<front id="Marlin_mainCPP-5224">      err = true;</front>
<front id="Marlin_mainCPP-5225">    }</front>
<front id="Marlin_mainCPP-5226"></front>
<front id="Marlin_mainCPP-5227">    if (x &gt;= MESH_NUM_X_POINTS || y &gt;= MESH_NUM_Y_POINTS) {</front>
<front id="Marlin_mainCPP-5228">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5229">      SERIAL_ERRORLNPGM(MSG_ERR_MESH_INDEX_OOB);</front>
<front id="Marlin_mainCPP-5230">      err = true;</front>
<front id="Marlin_mainCPP-5231">    }</front>
<front id="Marlin_mainCPP-5232"></front>
<front id="Marlin_mainCPP-5233">    if (!err) mbl.set_z(mbl.select_x_index(x), mbl.select_y_index(y), z);</front>
<front id="Marlin_mainCPP-5234">  }</front>
<front id="Marlin_mainCPP-5235"></front>
<front id="Marlin_mainCPP-5236">#endif</front>
<front id="Marlin_mainCPP-5237"></front>
<front id="Marlin_mainCPP-5238">/**</front>
<front id="Marlin_mainCPP-5239"> * M428: Set home_offset based on the distance between the</front>
<front id="Marlin_mainCPP-5240"> *       current_position and the nearest "reference point."</front>
<front id="Marlin_mainCPP-5241"> *       If an axis is past center its endstop position</front>
<front id="Marlin_mainCPP-5242"> *       is the reference-point. Otherwise it uses 0. This allows</front>
<front id="Marlin_mainCPP-5243"> *       the Z offset to be set near the bed when using a max endstop.</front>
<front id="Marlin_mainCPP-5244"> *</front>
<front id="Marlin_mainCPP-5245"> *       M428 can't be used more than 2cm away from 0 or an endstop.</front>
<front id="Marlin_mainCPP-5246"> *</front>
<front id="Marlin_mainCPP-5247"> *       Use M206 to set these values directly.</front>
<front id="Marlin_mainCPP-5248"> */</front>
<front id="Marlin_mainCPP-5249">inline void gcode_M428() {</front>
<front id="Marlin_mainCPP-5250">  bool err = false;</front>
<front id="Marlin_mainCPP-5251">  float new_offs[3], new_pos[3];</front>
<front id="Marlin_mainCPP-5252">  memcpy(new_pos, current_position, sizeof(new_pos));</front>
<front id="Marlin_mainCPP-5253">  memcpy(new_offs, home_offset, sizeof(new_offs));</front>
<front id="Marlin_mainCPP-5254">  for (int8_t i = X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-5255">    if (axis_known_position[i]) {</front>
<front id="Marlin_mainCPP-5256">      float base = (new_pos[i] &gt; (min_pos[i] + max_pos[i]) / 2) ? base_home_pos(i) : 0,</front>
<front id="Marlin_mainCPP-5257">            diff = new_pos[i] - base;</front>
<front id="Marlin_mainCPP-5258">      if (diff &gt; -20 && diff &lt; 20) {</front>
<front id="Marlin_mainCPP-5259">        new_offs[i] -= diff;</front>
<front id="Marlin_mainCPP-5260">        new_pos[i] = base;</front>
<front id="Marlin_mainCPP-5261">      }</front>
<front id="Marlin_mainCPP-5262">      else {</front>
<front id="Marlin_mainCPP-5263">        SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5264">        SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);</front>
<front id="Marlin_mainCPP-5265">        LCD_ALERTMESSAGEPGM("Err: Too far!");</front>
<front id="Marlin_mainCPP-5266">        #if HAS_BUZZER</front>
<front id="Marlin_mainCPP-5267">          enqueuecommands_P(PSTR("M300 S40 P200"));</front>
<front id="Marlin_mainCPP-5268">        #endif</front>
<front id="Marlin_mainCPP-5269">        err = true;</front>
<front id="Marlin_mainCPP-5270">        break;</front>
<front id="Marlin_mainCPP-5271">      }</front>
<front id="Marlin_mainCPP-5272">    }</front>
<front id="Marlin_mainCPP-5273">  }</front>
<front id="Marlin_mainCPP-5274"></front>
<front id="Marlin_mainCPP-5275">  if (!err) {</front>
<front id="Marlin_mainCPP-5276">    memcpy(current_position, new_pos, sizeof(new_pos));</front>
<front id="Marlin_mainCPP-5277">    memcpy(home_offset, new_offs, sizeof(new_offs));</front>
<front id="Marlin_mainCPP-5278">    sync_plan_position();</front>
<front id="Marlin_mainCPP-5279">    LCD_ALERTMESSAGEPGM("Offset applied.");</front>
<front id="Marlin_mainCPP-5280">    #if HAS_BUZZER</front>
<front id="Marlin_mainCPP-5281">      enqueuecommands_P(PSTR("M300 S659 P200\nM300 S698 P200"));</front>
<front id="Marlin_mainCPP-5282">    #endif</front>
<front id="Marlin_mainCPP-5283">  }</front>
<front id="Marlin_mainCPP-5284">}</front>
<front id="Marlin_mainCPP-5285"></front>
<front id="Marlin_mainCPP-5286">/**</front>
<front id="Marlin_mainCPP-5287"> * M500: Store settings in EEPROM</front>
<front id="Marlin_mainCPP-5288"> */</front>
<front id="Marlin_mainCPP-5289">inline void gcode_M500() {</front>
<front id="Marlin_mainCPP-5290">  Config_StoreSettings();</front>
<front id="Marlin_mainCPP-5291">}</front>
<front id="Marlin_mainCPP-5292"></front>
<front id="Marlin_mainCPP-5293">/**</front>
<front id="Marlin_mainCPP-5294"> * M501: Read settings from EEPROM</front>
<front id="Marlin_mainCPP-5295"> */</front>
<front id="Marlin_mainCPP-5296">inline void gcode_M501() {</front>
<front id="Marlin_mainCPP-5297">  Config_RetrieveSettings();</front>
<front id="Marlin_mainCPP-5298">}</front>
<front id="Marlin_mainCPP-5299"></front>
<front id="Marlin_mainCPP-5300">/**</front>
<front id="Marlin_mainCPP-5301"> * M502: Revert to default settings</front>
<front id="Marlin_mainCPP-5302"> */</front>
<front id="Marlin_mainCPP-5303">inline void gcode_M502() {</front>
<front id="Marlin_mainCPP-5304">  Config_ResetDefault();</front>
<front id="Marlin_mainCPP-5305">}</front>
<front id="Marlin_mainCPP-5306"></front>
<front id="Marlin_mainCPP-5307">/**</front>
<front id="Marlin_mainCPP-5308"> * M503: print settings currently in memory</front>
<front id="Marlin_mainCPP-5309"> */</front>
<front id="Marlin_mainCPP-5310">inline void gcode_M503() {</front>
<front id="Marlin_mainCPP-5311">  Config_PrintSettings(code_seen('S') && code_value() == 0);</front>
<front id="Marlin_mainCPP-5312">}</front>
<front id="Marlin_mainCPP-5313"></front>
<front id="Marlin_mainCPP-5314">#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-5315"></front>
<front id="Marlin_mainCPP-5316">  /**</front>
<front id="Marlin_mainCPP-5317">   * M540: Set whether SD card print should abort on endstop hit (M540 S&lt;0|1&gt;)</front>
<front id="Marlin_mainCPP-5318">   */</front>
<front id="Marlin_mainCPP-5319">  inline void gcode_M540() {</front>
<front id="Marlin_mainCPP-5320">    if (code_seen('S')) abort_on_endstop_hit = (code_value() &gt; 0);</front>
<front id="Marlin_mainCPP-5321">  }</front>
<front id="Marlin_mainCPP-5322"></front>
<front id="Marlin_mainCPP-5323">#endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="Marlin_mainCPP-5324"></front>
<front id="Marlin_mainCPP-5325">#ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-5326"></front>
<front id="Marlin_mainCPP-5327">  inline void gcode_SET_Z_PROBE_OFFSET() {</front>
<front id="Marlin_mainCPP-5328"></front>
<front id="Marlin_mainCPP-5329">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5330">    SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET);</front>
<front id="Marlin_mainCPP-5331">    SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-5332"></front>
<front id="Marlin_mainCPP-5333">    if (code_seen('Z')) {</front>
<front id="Marlin_mainCPP-5334">      float value = code_value();</front>
<front id="Marlin_mainCPP-5335">      if (Z_PROBE_OFFSET_RANGE_MIN &lt;= value && value &lt;= Z_PROBE_OFFSET_RANGE_MAX) {</front>
<front id="Marlin_mainCPP-5336">        zprobe_zoffset = value;</front>
<front id="Marlin_mainCPP-5337">        SERIAL_ECHOPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-5338">      }</front>
<front id="Marlin_mainCPP-5339">      else {</front>
<front id="Marlin_mainCPP-5340">        SERIAL_ECHOPGM(MSG_Z_MIN);</front>
<front id="Marlin_mainCPP-5341">        SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MIN);</front>
<front id="Marlin_mainCPP-5342">        SERIAL_ECHOPGM(MSG_Z_MAX);</front>
<front id="Marlin_mainCPP-5343">        SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MAX);</front>
<front id="Marlin_mainCPP-5344">      }</front>
<front id="Marlin_mainCPP-5345">    }</front>
<front id="Marlin_mainCPP-5346">    else {</front>
<front id="Marlin_mainCPP-5347">      SERIAL_ECHOPAIR(": ", zprobe_zoffset);</front>
<front id="Marlin_mainCPP-5348">    }</front>
<front id="Marlin_mainCPP-5349"></front>
<front id="Marlin_mainCPP-5350">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-5351">  }</front>
<front id="Marlin_mainCPP-5352"></front>
<front id="Marlin_mainCPP-5353">#endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-5354"></front>
<front id="Marlin_mainCPP-5355">#if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="Marlin_mainCPP-5356"></front>
<front id="Marlin_mainCPP-5357">  /**</front>
<front id="Marlin_mainCPP-5358">   * M600: Pause for filament change</front>
<front id="Marlin_mainCPP-5359">   *</front>
<front id="Marlin_mainCPP-5360">   *  E[distance] - Retract the filament this far (negative value)</front>
<front id="Marlin_mainCPP-5361">   *  Z[distance] - Move the Z axis by this distance</front>
<front id="Marlin_mainCPP-5362">   *  X[position] - Move to this X position, with Y</front>
<front id="Marlin_mainCPP-5363">   *  Y[position] - Move to this Y position, with X</front>
<front id="Marlin_mainCPP-5364">   *  L[distance] - Retract distance for removal (manual reload)</front>
<front id="Marlin_mainCPP-5365">   *</front>
<front id="Marlin_mainCPP-5366">   *  Default values are used for omitted arguments.</front>
<front id="Marlin_mainCPP-5367">   *</front>
<front id="Marlin_mainCPP-5368">   */</front>
<front id="Marlin_mainCPP-5369">  inline void gcode_M600() {</front>
<front id="Marlin_mainCPP-5370"></front>
<front id="Marlin_mainCPP-5371">    if (degHotend(active_extruder) &lt; extrude_min_temp) {</front>
<front id="Marlin_mainCPP-5372">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5373">      SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);</front>
<front id="Marlin_mainCPP-5374">      return;</front>
<front id="Marlin_mainCPP-5375">    }</front>
<front id="Marlin_mainCPP-5376"></front>
<front id="Marlin_mainCPP-5377">    float lastpos[NUM_AXIS], fr60 = feedrate / 60;</front>
<front id="Marlin_mainCPP-5378"></front>
<front id="Marlin_mainCPP-5379">    for (int i=0; i&lt;NUM_AXIS; i++)</front>
<front id="Marlin_mainCPP-5380">      lastpos[i] = destination[i] = current_position[i];</front>
<front id="Marlin_mainCPP-5381"></front>
<front id="Marlin_mainCPP-5382">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-5383">      #define RUNPLAN calculate_delta(destination); \</front>
<front id="Marlin_mainCPP-5384">                      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);</front>
<front id="Marlin_mainCPP-5385">    #else</front>
<front id="Marlin_mainCPP-5386">      #define RUNPLAN line_to_destination();</front>
<front id="Marlin_mainCPP-5387">    #endif</front>
<front id="Marlin_mainCPP-5388"></front>
<front id="Marlin_mainCPP-5389">    //retract by E</front>
<front id="Marlin_mainCPP-5390">    if (code_seen('E')) destination[E_AXIS] += code_value();</front>
<front id="Marlin_mainCPP-5391">    #ifdef FILAMENTCHANGE_FIRSTRETRACT</front>
<front id="Marlin_mainCPP-5392">      else destination[E_AXIS] += FILAMENTCHANGE_FIRSTRETRACT;</front>
<front id="Marlin_mainCPP-5393">    #endif</front>
<front id="Marlin_mainCPP-5394"></front>
<front id="Marlin_mainCPP-5395">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5396"></front>
<front id="Marlin_mainCPP-5397">    //lift Z</front>
<front id="Marlin_mainCPP-5398">    if (code_seen('Z')) destination[Z_AXIS] += code_value();</front>
<front id="Marlin_mainCPP-5399">    #ifdef FILAMENTCHANGE_ZADD</front>
<front id="Marlin_mainCPP-5400">      else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;</front>
<front id="Marlin_mainCPP-5401">    #endif</front>
<front id="Marlin_mainCPP-5402"></front>
<front id="Marlin_mainCPP-5403">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5404"></front>
<front id="Marlin_mainCPP-5405">    //move xy</front>
<front id="Marlin_mainCPP-5406">    if (code_seen('X')) destination[X_AXIS] = code_value();</front>
<front id="Marlin_mainCPP-5407">    #ifdef FILAMENTCHANGE_XPOS</front>
<front id="Marlin_mainCPP-5408">      else destination[X_AXIS] = FILAMENTCHANGE_XPOS;</front>
<front id="Marlin_mainCPP-5409">    #endif</front>
<front id="Marlin_mainCPP-5410"></front>
<front id="Marlin_mainCPP-5411">    if (code_seen('Y')) destination[Y_AXIS] = code_value();</front>
<front id="Marlin_mainCPP-5412">    #ifdef FILAMENTCHANGE_YPOS</front>
<front id="Marlin_mainCPP-5413">      else destination[Y_AXIS] = FILAMENTCHANGE_YPOS;</front>
<front id="Marlin_mainCPP-5414">    #endif</front>
<front id="Marlin_mainCPP-5415"></front>
<front id="Marlin_mainCPP-5416">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5417"></front>
<front id="Marlin_mainCPP-5418">    if (code_seen('L')) destination[E_AXIS] += code_value();</front>
<front id="Marlin_mainCPP-5419">    #ifdef FILAMENTCHANGE_FINALRETRACT</front>
<front id="Marlin_mainCPP-5420">      else destination[E_AXIS] += FILAMENTCHANGE_FINALRETRACT;</front>
<front id="Marlin_mainCPP-5421">    #endif</front>
<front id="Marlin_mainCPP-5422"></front>
<front id="Marlin_mainCPP-5423">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5424"></front>
<front id="Marlin_mainCPP-5425">    //finish moves</front>
<front id="Marlin_mainCPP-5426">    st_synchronize();</front>
<front id="Marlin_mainCPP-5427">    //disable extruder steppers so filament can be removed</front>
<front id="Marlin_mainCPP-5428">    disable_e0();</front>
<front id="Marlin_mainCPP-5429">    disable_e1();</front>
<front id="Marlin_mainCPP-5430">    disable_e2();</front>
<front id="Marlin_mainCPP-5431">    disable_e3();</front>
<front id="Marlin_mainCPP-5432">    delay(100);</front>
<front id="Marlin_mainCPP-5433">    LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);</front>
<front id="Marlin_mainCPP-5434">    millis_t next_tick = 0;</front>
<front id="Marlin_mainCPP-5435">    while (!lcd_clicked()) {</front>
<front id="Marlin_mainCPP-5436">      #if DISABLED(AUTO_FILAMENT_CHANGE)</front>
<front id="Marlin_mainCPP-5437">        millis_t ms = millis();</front>
<front id="Marlin_mainCPP-5438">        if (ms &gt;= next_tick) {</front>
<front id="Marlin_mainCPP-5439">          lcd_quick_feedback();</front>
<front id="Marlin_mainCPP-5440">          next_tick = ms + 2500; // feedback every 2.5s while waiting</front>
<front id="Marlin_mainCPP-5441">        }</front>
<front id="Marlin_mainCPP-5442">        manage_heater();</front>
<front id="Marlin_mainCPP-5443">        manage_inactivity(true);</front>
<front id="Marlin_mainCPP-5444">        lcd_update();</front>
<front id="Marlin_mainCPP-5445">      #else</front>
<front id="Marlin_mainCPP-5446">        current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;</front>
<front id="Marlin_mainCPP-5447">        destination[E_AXIS] = current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-5448">        line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);</front>
<front id="Marlin_mainCPP-5449">        st_synchronize();</front>
<front id="Marlin_mainCPP-5450">      #endif</front>
<front id="Marlin_mainCPP-5451">    } // while(!lcd_clicked)</front>
<front id="Marlin_mainCPP-5452">    lcd_quick_feedback(); // click sound feedback</front>
<front id="Marlin_mainCPP-5453"></front>
<front id="Marlin_mainCPP-5454">    #if ENABLED(AUTO_FILAMENT_CHANGE)</front>
<front id="Marlin_mainCPP-5455">      current_position[E_AXIS] = 0;</front>
<front id="Marlin_mainCPP-5456">      st_synchronize();</front>
<front id="Marlin_mainCPP-5457">    #endif</front>
<front id="Marlin_mainCPP-5458"></front>
<front id="Marlin_mainCPP-5459">    //return to normal</front>
<front id="Marlin_mainCPP-5460">    if (code_seen('L')) destination[E_AXIS] -= code_value();</front>
<front id="Marlin_mainCPP-5461">    #ifdef FILAMENTCHANGE_FINALRETRACT</front>
<front id="Marlin_mainCPP-5462">      else destination[E_AXIS] -= FILAMENTCHANGE_FINALRETRACT;</front>
<front id="Marlin_mainCPP-5463">    #endif</front>
<front id="Marlin_mainCPP-5464"></front>
<front id="Marlin_mainCPP-5465">    current_position[E_AXIS] = destination[E_AXIS]; //the long retract of L is compensated by manual filament feeding</front>
<front id="Marlin_mainCPP-5466">    plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-5467"></front>
<front id="Marlin_mainCPP-5468">    RUNPLAN; //should do nothing</front>
<front id="Marlin_mainCPP-5469"></front>
<front id="Marlin_mainCPP-5470">    lcd_reset_alert_level();</front>
<front id="Marlin_mainCPP-5471"></front>
<front id="Marlin_mainCPP-5472">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-5473">      // Move XYZ to starting position, then E</front>
<front id="Marlin_mainCPP-5474">      calculate_delta(lastpos);</front>
<front id="Marlin_mainCPP-5475">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);</front>
<front id="Marlin_mainCPP-5476">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], fr60, active_extruder);</front>
<front id="Marlin_mainCPP-5477">    #else</front>
<front id="Marlin_mainCPP-5478">      // Move XY to starting position, then Z, then E</front>
<front id="Marlin_mainCPP-5479">      destination[X_AXIS] = lastpos[X_AXIS];</front>
<front id="Marlin_mainCPP-5480">      destination[Y_AXIS] = lastpos[Y_AXIS];</front>
<front id="Marlin_mainCPP-5481">      line_to_destination();</front>
<front id="Marlin_mainCPP-5482">      destination[Z_AXIS] = lastpos[Z_AXIS];</front>
<front id="Marlin_mainCPP-5483">      line_to_destination();</front>
<front id="Marlin_mainCPP-5484">      destination[E_AXIS] = lastpos[E_AXIS];</front>
<front id="Marlin_mainCPP-5485">      line_to_destination();</front>
<front id="Marlin_mainCPP-5486">    #endif</front>
<front id="Marlin_mainCPP-5487"></front>
<front id="Marlin_mainCPP-5488">    #if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="Marlin_mainCPP-5489">      filrunoutEnqueued = false;</front>
<front id="Marlin_mainCPP-5490">    #endif</front>
<front id="Marlin_mainCPP-5491"></front>
<front id="Marlin_mainCPP-5492">  }</front>
<front id="Marlin_mainCPP-5493"></front>
<front id="Marlin_mainCPP-5494">#endif // FILAMENTCHANGEENABLE</front>
<front id="Marlin_mainCPP-5495"></front>
<front id="Marlin_mainCPP-5496">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-5497"></front>
<front id="Marlin_mainCPP-5498">  /**</front>
<front id="Marlin_mainCPP-5499">   * M605: Set dual x-carriage movement mode</front>
<front id="Marlin_mainCPP-5500">   *</front>
<front id="Marlin_mainCPP-5501">   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement</front>
<front id="Marlin_mainCPP-5502">   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement</front>
<front id="Marlin_mainCPP-5503">   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn</front>
<front id="Marlin_mainCPP-5504">   *                         millimeters x-offset and an optional differential hotend temperature of</front>
<front id="Marlin_mainCPP-5505">   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate</front>
<front id="Marlin_mainCPP-5506">   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.</front>
<front id="Marlin_mainCPP-5507">   *</front>
<front id="Marlin_mainCPP-5508">   *    Note: the X axis should be homed after changing dual x-carriage mode.</front>
<front id="Marlin_mainCPP-5509">   */</front>
<front id="Marlin_mainCPP-5510">  inline void gcode_M605() {</front>
<front id="Marlin_mainCPP-5511">    st_synchronize();</front>
<front id="Marlin_mainCPP-5512">    if (code_seen('S')) dual_x_carriage_mode = code_value();</front>
<front id="Marlin_mainCPP-5513">    switch(dual_x_carriage_mode) {</front>
<front id="Marlin_mainCPP-5514">      case DXC_DUPLICATION_MODE:</front>
<front id="Marlin_mainCPP-5515">        if (code_seen('X')) duplicate_extruder_x_offset = max(code_value(), X2_MIN_POS - x_home_pos(0));</front>
<front id="Marlin_mainCPP-5516">        if (code_seen('R')) duplicate_extruder_temp_offset = code_value();</front>
<front id="Marlin_mainCPP-5517">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5518">        SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);</front>
<front id="Marlin_mainCPP-5519">        SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-5520">        SERIAL_ECHO(extruder_offset[X_AXIS][0]);</front>
<front id="Marlin_mainCPP-5521">        SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-5522">        SERIAL_ECHO(extruder_offset[Y_AXIS][0]);</front>
<front id="Marlin_mainCPP-5523">        SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-5524">        SERIAL_ECHO(duplicate_extruder_x_offset);</front>
<front id="Marlin_mainCPP-5525">        SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-5526">        SERIAL_ECHOLN(extruder_offset[Y_AXIS][1]);</front>
<front id="Marlin_mainCPP-5527">        break;</front>
<front id="Marlin_mainCPP-5528">      case DXC_FULL_CONTROL_MODE:</front>
<front id="Marlin_mainCPP-5529">      case DXC_AUTO_PARK_MODE:</front>
<front id="Marlin_mainCPP-5530">        break;</front>
<front id="Marlin_mainCPP-5531">      default:</front>
<front id="Marlin_mainCPP-5532">        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;</front>
<front id="Marlin_mainCPP-5533">        break;</front>
<front id="Marlin_mainCPP-5534">    }</front>
<front id="Marlin_mainCPP-5535">    active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-5536">    extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-5537">    delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-5538">  }</front>
<front id="Marlin_mainCPP-5539"></front>
<front id="Marlin_mainCPP-5540">#endif // DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-5541"></front>
<front id="Marlin_mainCPP-5542">/**</front>
<front id="Marlin_mainCPP-5543"> * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S</front>
<front id="Marlin_mainCPP-5544"> */</front>
<front id="Marlin_mainCPP-5545">inline void gcode_M907() {</front>
<front id="Marlin_mainCPP-5546">  #if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-5547">    for (int i=0;i&lt;NUM_AXIS;i++)</front>
<front id="Marlin_mainCPP-5548">      if (code_seen(axis_codes[i])) digipot_current(i, code_value());</front>
<front id="Marlin_mainCPP-5549">    if (code_seen('B')) digipot_current(4, code_value());</front>
<front id="Marlin_mainCPP-5550">    if (code_seen('S')) for (int i=0; i&lt;=4; i++) digipot_current(i, code_value());</front>
<front id="Marlin_mainCPP-5551">  #endif</front>
<front id="Marlin_mainCPP-5552">  #ifdef MOTOR_CURRENT_PWM_XY_PIN</front>
<front id="Marlin_mainCPP-5553">    if (code_seen('X')) digipot_current(0, code_value());</front>
<front id="Marlin_mainCPP-5554">  #endif</front>
<front id="Marlin_mainCPP-5555">  #ifdef MOTOR_CURRENT_PWM_Z_PIN</front>
<front id="Marlin_mainCPP-5556">    if (code_seen('Z')) digipot_current(1, code_value());</front>
<front id="Marlin_mainCPP-5557">  #endif</front>
<front id="Marlin_mainCPP-5558">  #ifdef MOTOR_CURRENT_PWM_E_PIN</front>
<front id="Marlin_mainCPP-5559">    if (code_seen('E')) digipot_current(2, code_value());</front>
<front id="Marlin_mainCPP-5560">  #endif</front>
<front id="Marlin_mainCPP-5561">  #if ENABLED(DIGIPOT_I2C)</front>
<front id="Marlin_mainCPP-5562">    // this one uses actual amps in floating point</front>
<front id="Marlin_mainCPP-5563">    for (int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value());</front>
<front id="Marlin_mainCPP-5564">    // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)</front>
<front id="Marlin_mainCPP-5565">    for (int i=NUM_AXIS;i&lt;DIGIPOT_I2C_NUM_CHANNELS;i++) if(code_seen('B'+i-NUM_AXIS)) digipot_i2c_set_current(i, code_value());</front>
<front id="Marlin_mainCPP-5566">  #endif</front>
<front id="Marlin_mainCPP-5567">}</front>
<front id="Marlin_mainCPP-5568"></front>
<front id="Marlin_mainCPP-5569">#if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-5570"></front>
<front id="Marlin_mainCPP-5571">  /**</front>
<front id="Marlin_mainCPP-5572">   * M908: Control digital trimpot directly (M908 P&lt;pin&gt; S&lt;current&gt;)</front>
<front id="Marlin_mainCPP-5573">   */</front>
<front id="Marlin_mainCPP-5574">  inline void gcode_M908() {</front>
<front id="Marlin_mainCPP-5575">      digitalPotWrite(</front>
<front id="Marlin_mainCPP-5576">        code_seen('P') ? code_value() : 0,</front>
<front id="Marlin_mainCPP-5577">        code_seen('S') ? code_value() : 0</front>
<front id="Marlin_mainCPP-5578">      );</front>
<front id="Marlin_mainCPP-5579">  }</front>
<front id="Marlin_mainCPP-5580"></front>
<front id="Marlin_mainCPP-5581">#endif // HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-5582"></front>
<front id="Marlin_mainCPP-5583">#if HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-5584"></front>
<front id="Marlin_mainCPP-5585">  // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</front>
<front id="Marlin_mainCPP-5586">  inline void gcode_M350() {</front>
<front id="Marlin_mainCPP-5587">    if(code_seen('S')) for(int i=0;i&lt;=4;i++) microstep_mode(i,code_value());</front>
<front id="Marlin_mainCPP-5588">    for(int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());</front>
<front id="Marlin_mainCPP-5589">    if(code_seen('B')) microstep_mode(4,code_value());</front>
<front id="Marlin_mainCPP-5590">    microstep_readings();</front>
<front id="Marlin_mainCPP-5591">  }</front>
<front id="Marlin_mainCPP-5592"></front>
<front id="Marlin_mainCPP-5593">  /**</front>
<front id="Marlin_mainCPP-5594">   * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B</front>
<front id="Marlin_mainCPP-5595">   *       S# determines MS1 or MS2, X# sets the pin high/low.</front>
<front id="Marlin_mainCPP-5596">   */</front>
<front id="Marlin_mainCPP-5597">  inline void gcode_M351() {</front>
<front id="Marlin_mainCPP-5598">    if (code_seen('S')) switch(code_value_short()) {</front>
<front id="Marlin_mainCPP-5599">      case 1:</front>
<front id="Marlin_mainCPP-5600">        for(int i=0;i&lt;NUM_AXIS;i++) if (code_seen(axis_codes[i])) microstep_ms(i, code_value(), -1);</front>
<front id="Marlin_mainCPP-5601">        if (code_seen('B')) microstep_ms(4, code_value(), -1);</front>
<front id="Marlin_mainCPP-5602">        break;</front>
<front id="Marlin_mainCPP-5603">      case 2:</front>
<front id="Marlin_mainCPP-5604">        for(int i=0;i&lt;NUM_AXIS;i++) if (code_seen(axis_codes[i])) microstep_ms(i, -1, code_value());</front>
<front id="Marlin_mainCPP-5605">        if (code_seen('B')) microstep_ms(4, -1, code_value());</front>
<front id="Marlin_mainCPP-5606">        break;</front>
<front id="Marlin_mainCPP-5607">    }</front>
<front id="Marlin_mainCPP-5608">    microstep_readings();</front>
<front id="Marlin_mainCPP-5609">  }</front>
<front id="Marlin_mainCPP-5610"></front>
<front id="Marlin_mainCPP-5611">#endif // HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-5612"></front>
<front id="Marlin_mainCPP-5613">/**</front>
<front id="Marlin_mainCPP-5614"> * M999: Restart after being stopped</front>
<front id="Marlin_mainCPP-5615"> */</front>
<front id="Marlin_mainCPP-5616">inline void gcode_M999() {</front>
<front id="Marlin_mainCPP-5617">  Running = true;</front>
<front id="Marlin_mainCPP-5618">  lcd_reset_alert_level();</front>
<front id="Marlin_mainCPP-5619">  // gcode_LastN = Stopped_gcode_LastN;</front>
<front id="Marlin_mainCPP-5620">  FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-5621">}</front>
<front id="Marlin_mainCPP-5622"></front>
<front id="Marlin_mainCPP-5623">/**</front>
<front id="Marlin_mainCPP-5624"> * T0-T3: Switch tool, usually switching extruders</front>
<front id="Marlin_mainCPP-5625"> *</front>
<front id="Marlin_mainCPP-5626"> *   F[mm/min] Set the movement feedrate</front>
<front id="Marlin_mainCPP-5627"> */</front>
<front id="Marlin_mainCPP-5628">inline void gcode_T(uint8_t tmp_extruder) {</front>
<front id="Marlin_mainCPP-5629">  if (tmp_extruder &gt;= EXTRUDERS) {</front>
<front id="Marlin_mainCPP-5630">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5631">    SERIAL_CHAR('T');</front>
<front id="Marlin_mainCPP-5632">    SERIAL_PROTOCOL_F(tmp_extruder,DEC);</front>
<front id="Marlin_mainCPP-5633">    SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-5634">  }</front>
<front id="Marlin_mainCPP-5635">  #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-5636">    else if (!planner_disabled_below_z || layer_reached);</front>
<front id="Marlin_mainCPP-5637">  #endif</front>
<front id="Marlin_mainCPP-5638">  else {</front>
<front id="Marlin_mainCPP-5639">    target_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-5640"></front>
<front id="Marlin_mainCPP-5641">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5642">      bool make_move = false;</front>
<front id="Marlin_mainCPP-5643">    #endif</front>
<front id="Marlin_mainCPP-5644"></front>
<front id="Marlin_mainCPP-5645">    if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-5646"></front>
<front id="Marlin_mainCPP-5647">      #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5648">        make_move = true;</front>
<front id="Marlin_mainCPP-5649">      #endif</front>
<front id="Marlin_mainCPP-5650"></front>
<front id="Marlin_mainCPP-5651">      float next_feedrate = code_value();</front>
<front id="Marlin_mainCPP-5652">      if (next_feedrate &gt; 0.0) feedrate = next_feedrate;</front>
<front id="Marlin_mainCPP-5653">    }</front>
<front id="Marlin_mainCPP-5654">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5655">      if (tmp_extruder != active_extruder) {</front>
<front id="Marlin_mainCPP-5656">        // Save current position to return to after applying extruder offset</front>
<front id="Marlin_mainCPP-5657">        set_destination_to_current();</front>
<front id="Marlin_mainCPP-5658">        #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-5659">          if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning() &&</front>
<front id="Marlin_mainCPP-5660">                (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder))) {</front>
<front id="Marlin_mainCPP-5661">            // Park old head: 1) raise 2) move to park position 3) lower</front>
<front id="Marlin_mainCPP-5662">            plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,</front>
<front id="Marlin_mainCPP-5663">                  current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-5664">            plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,</front>
<front id="Marlin_mainCPP-5665">                  current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-5666">            plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-5667">                  current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-5668">            st_synchronize();</front>
<front id="Marlin_mainCPP-5669">          }</front>
<front id="Marlin_mainCPP-5670"></front>
<front id="Marlin_mainCPP-5671">          // apply Y & Z extruder offset (x offset is already used in determining home pos)</front>
<front id="Marlin_mainCPP-5672">          current_position[Y_AXIS] = current_position[Y_AXIS] -</front>
<front id="Marlin_mainCPP-5673">                       extruder_offset[Y_AXIS][active_extruder] +</front>
<front id="Marlin_mainCPP-5674">                       extruder_offset[Y_AXIS][tmp_extruder];</front>
<front id="Marlin_mainCPP-5675">          current_position[Z_AXIS] = current_position[Z_AXIS] -</front>
<front id="Marlin_mainCPP-5676">                       extruder_offset[Z_AXIS][active_extruder] +</front>
<front id="Marlin_mainCPP-5677">                       extruder_offset[Z_AXIS][tmp_extruder];</front>
<front id="Marlin_mainCPP-5678"></front>
<front id="Marlin_mainCPP-5679">          active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-5680"></front>
<front id="Marlin_mainCPP-5681">          // This function resets the max/min values - the current position may be overwritten below.</front>
<front id="Marlin_mainCPP-5682">          set_axis_is_at_home(X_AXIS);</front>
<front id="Marlin_mainCPP-5683"></front>
<front id="Marlin_mainCPP-5684">          if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE) {</front>
<front id="Marlin_mainCPP-5685">            current_position[X_AXIS] = inactive_extruder_x_pos;</front>
<front id="Marlin_mainCPP-5686">            inactive_extruder_x_pos = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-5687">          }</front>
<front id="Marlin_mainCPP-5688">          else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {</front>
<front id="Marlin_mainCPP-5689">            active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position</front>
<front id="Marlin_mainCPP-5690">            if (active_extruder == 0 || active_extruder_parked)</front>
<front id="Marlin_mainCPP-5691">              current_position[X_AXIS] = inactive_extruder_x_pos;</front>
<front id="Marlin_mainCPP-5692">            else</front>
<front id="Marlin_mainCPP-5693">              current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;</front>
<front id="Marlin_mainCPP-5694">            inactive_extruder_x_pos = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-5695">            extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-5696">          }</front>
<front id="Marlin_mainCPP-5697">          else {</front>
<front id="Marlin_mainCPP-5698">            // record raised toolhead position for use by unpark</front>
<front id="Marlin_mainCPP-5699">            memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));</front>
<front id="Marlin_mainCPP-5700">            raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;</front>
<front id="Marlin_mainCPP-5701">            active_extruder_parked = true;</front>
<front id="Marlin_mainCPP-5702">            delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-5703">          }</front>
<front id="Marlin_mainCPP-5704">        #else // !DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-5705">          // Offset extruder (only by XY)</front>
<front id="Marlin_mainCPP-5706">          for (int i=X_AXIS; i&lt;=Y_AXIS; i++)</front>
<front id="Marlin_mainCPP-5707">            current_position[i] += extruder_offset[i][tmp_extruder] - extruder_offset[i][active_extruder];</front>
<front id="Marlin_mainCPP-5708">          // Set the new active extruder and position</front>
<front id="Marlin_mainCPP-5709">          active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-5710">        #endif // !DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-5711">        #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-5712">          sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-5713">        #else</front>
<front id="Marlin_mainCPP-5714">          sync_plan_position();</front>
<front id="Marlin_mainCPP-5715">        #endif</front>
<front id="Marlin_mainCPP-5716">        // Move to the old position if 'F' was in the parameters</front>
<front id="Marlin_mainCPP-5717">        if (make_move && IsRunning()) prepare_move();</front>
<front id="Marlin_mainCPP-5718">      }</front>
<front id="Marlin_mainCPP-5719"></front>
<front id="Marlin_mainCPP-5720">      #if ENABLED(EXT_SOLENOID)</front>
<front id="Marlin_mainCPP-5721">        st_synchronize();</front>
<front id="Marlin_mainCPP-5722">        disable_all_solenoids();</front>
<front id="Marlin_mainCPP-5723">        enable_solenoid_on_active_extruder();</front>
<front id="Marlin_mainCPP-5724">      #endif // EXT_SOLENOID</front>
<front id="Marlin_mainCPP-5725"></front>
<front id="Marlin_mainCPP-5726">    #endif // EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5727">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5728">    SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);</front>
<front id="Marlin_mainCPP-5729">    SERIAL_PROTOCOLLN((int)active_extruder);</front>
<front id="Marlin_mainCPP-5730">  }</front>
<front id="Marlin_mainCPP-5731">}</front>
<front id="Marlin_mainCPP-5732"></front>
<front id="Marlin_mainCPP-5733">/**</front>
<front id="Marlin_mainCPP-5734"> * Process a single command and dispatch it to its handler</front>
<front id="Marlin_mainCPP-5735"> * This is called from the main loop()</front>
<front id="Marlin_mainCPP-5736"> */</front>
<front id="Marlin_mainCPP-5737">void process_next_command() {</front>
<front id="Marlin_mainCPP-5738">  current_command = command_queue[cmd_queue_index_r];</front>
<front id="Marlin_mainCPP-5739"></front>
<front id="Marlin_mainCPP-5740">  if ((marlin_debug_flags & DEBUG_ECHO)) {</front>
<front id="Marlin_mainCPP-5741">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5742">    SERIAL_ECHOLN(current_command);</front>
<front id="Marlin_mainCPP-5743">  }</front>
<front id="Marlin_mainCPP-5744"></front>
<front id="Marlin_mainCPP-5745">  // Sanitize the current command:</front>
<front id="Marlin_mainCPP-5746">  //  - Skip leading spaces</front>
<front id="Marlin_mainCPP-5747">  //  - Bypass N[0-9][0-9]*[ ]*</front>
<front id="Marlin_mainCPP-5748">  //  - Overwrite * with nul to mark the end</front>
<front id="Marlin_mainCPP-5749">  while (*current_command == ' ') ++current_command;</front>
<front id="Marlin_mainCPP-5750">  if (*current_command == 'N' && ((current_command[1] &gt;= '0' && current_command[1] &lt;= '9') || current_command[1] == '-')) {</front>
<front id="Marlin_mainCPP-5751">    current_command += 2; // skip N[-0-9]</front>
<front id="Marlin_mainCPP-5752">    while (*current_command &gt;= '0' && *current_command &lt;= '9') ++current_command; // skip [0-9]*</front>
<front id="Marlin_mainCPP-5753">    while (*current_command == ' ') ++current_command; // skip [ ]*</front>
<front id="Marlin_mainCPP-5754">  }</front>
<front id="Marlin_mainCPP-5755">  char *starpos = strchr(current_command, '*');  // * should always be the last parameter</front>
<front id="Marlin_mainCPP-5756">  if (starpos) while (*starpos == ' ' || *starpos == '*') *starpos-- = '\0'; // nullify '*' and ' '</front>
<front id="Marlin_mainCPP-5757"></front>
<front id="Marlin_mainCPP-5758">  // Get the command code, which must be G, M, or T</front>
<front id="Marlin_mainCPP-5759">  char command_code = *current_command;</front>
<front id="Marlin_mainCPP-5760"></front>
<front id="Marlin_mainCPP-5761">  // The code must have a numeric value</front>
<front id="Marlin_mainCPP-5762">  bool code_is_good = (current_command[1] &gt;= '0' && current_command[1] &lt;= '9');</front>
<front id="Marlin_mainCPP-5763"></front>
<front id="Marlin_mainCPP-5764">  int codenum; // define ahead of goto</front>
<front id="Marlin_mainCPP-5765"></front>
<front id="Marlin_mainCPP-5766">  // Bail early if there's no code</front>
<front id="Marlin_mainCPP-5767">  if (!code_is_good) goto ExitUnknownCommand;</front>
<front id="Marlin_mainCPP-5768"></front>
<front id="Marlin_mainCPP-5769">  // Args pointer optimizes code_seen, especially those taking XYZEF</front>
<front id="Marlin_mainCPP-5770">  // This wastes a little cpu on commands that expect no arguments.</front>
<front id="Marlin_mainCPP-5771">  current_command_args = current_command;</front>
<front id="Marlin_mainCPP-5772">  while (*current_command_args && *current_command_args != ' ') ++current_command_args;</front>
<front id="Marlin_mainCPP-5773">  while (*current_command_args == ' ') ++current_command_args;</front>
<front id="Marlin_mainCPP-5774"></front>
<front id="Marlin_mainCPP-5775">  // Interpret the code int</front>
<front id="Marlin_mainCPP-5776">  seen_pointer = current_command;</front>
<front id="Marlin_mainCPP-5777">  codenum = code_value_short();</front>
<front id="Marlin_mainCPP-5778"></front>
<front id="Marlin_mainCPP-5779">  // Handle a known G, M, or T</front>
<front id="Marlin_mainCPP-5780">  switch(command_code) {</front>
<front id="Marlin_mainCPP-5781">    case 'G': switch (codenum) {</front>
<front id="Marlin_mainCPP-5782"></front>
<front id="Marlin_mainCPP-5783">      // G0, G1</front>
<front id="Marlin_mainCPP-5784">      case 0:</front>
<front id="Marlin_mainCPP-5785">      case 1:</front>
<front id="Marlin_mainCPP-5786">        gcode_G0_G1();</front>
<front id="Marlin_mainCPP-5787">        break;</front>
<front id="Marlin_mainCPP-5788"></front>
<front id="Marlin_mainCPP-5789">      // G2, G3</front>
<front id="Marlin_mainCPP-5790">      #if DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-5791">        case 2: // G2  - CW ARC</front>
<front id="Marlin_mainCPP-5792">        case 3: // G3  - CCW ARC</front>
<front id="Marlin_mainCPP-5793">          gcode_G2_G3(codenum == 2);</front>
<front id="Marlin_mainCPP-5794">          break;</front>
<front id="Marlin_mainCPP-5795">      #endif</front>
<front id="Marlin_mainCPP-5796"></front>
<front id="Marlin_mainCPP-5797">      // G4 Dwell</front>
<front id="Marlin_mainCPP-5798">      case 4:</front>
<front id="Marlin_mainCPP-5799">        gcode_G4();</front>
<front id="Marlin_mainCPP-5800">        break;</front>
<front id="Marlin_mainCPP-5801"></front>
<front id="Marlin_mainCPP-5802">      #if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-5803"></front>
<front id="Marlin_mainCPP-5804">        case 10: // G10: retract</front>
<front id="Marlin_mainCPP-5805">        case 11: // G11: retract_recover</front>
<front id="Marlin_mainCPP-5806">          gcode_G10_G11(codenum == 10);</front>
<front id="Marlin_mainCPP-5807">          break;</front>
<front id="Marlin_mainCPP-5808"></front>
<front id="Marlin_mainCPP-5809">      #endif //FWRETRACT</front>
<front id="Marlin_mainCPP-5810"></front>
<front id="Marlin_mainCPP-5811">      case 28: // G28: Home all axes, one at a time</front>
<front id="Marlin_mainCPP-5812">        gcode_G28();</front>
<front id="Marlin_mainCPP-5813">        break;</front>
<front id="Marlin_mainCPP-5814"></front>
<front id="Marlin_mainCPP-5815">      #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-5816">        case 29: // G29 Detailed Z probe, probes the bed at 3 or more points.</front>
<front id="Marlin_mainCPP-5817">          gcode_G29();</front>
<front id="Marlin_mainCPP-5818">          break;</front>
<front id="Marlin_mainCPP-5819">      #endif</front>
<front id="Marlin_mainCPP-5820"></front>
<front id="Marlin_mainCPP-5821">      #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-5822"></front>
<front id="Marlin_mainCPP-5823">        #if DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-5824"></front>
<front id="Marlin_mainCPP-5825">          case 30: // G30 Single Z probe</front>
<front id="Marlin_mainCPP-5826">            gcode_G30();</front>
<front id="Marlin_mainCPP-5827">            break;</front>
<front id="Marlin_mainCPP-5828"></front>
<front id="Marlin_mainCPP-5829">        #else // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-5830"></front>
<front id="Marlin_mainCPP-5831">            case 31: // G31: dock the sled</front>
<front id="Marlin_mainCPP-5832">            case 32: // G32: undock the sled</front>
<front id="Marlin_mainCPP-5833">              dock_sled(codenum == 31);</front>
<front id="Marlin_mainCPP-5834">              break;</front>
<front id="Marlin_mainCPP-5835"></front>
<front id="Marlin_mainCPP-5836">        #endif // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-5837"></front>
<front id="Marlin_mainCPP-5838">      #endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-5839"></front>
<front id="Marlin_mainCPP-5840">      case 90: // G90</front>
<front id="Marlin_mainCPP-5841">        relative_mode = false;</front>
<front id="Marlin_mainCPP-5842">        break;</front>
<front id="Marlin_mainCPP-5843">      case 91: // G91</front>
<front id="Marlin_mainCPP-5844">        relative_mode = true;</front>
<front id="Marlin_mainCPP-5845">        break;</front>
<front id="Marlin_mainCPP-5846"></front>
<front id="Marlin_mainCPP-5847">      case 92: // G92</front>
<front id="Marlin_mainCPP-5848">        gcode_G92();</front>
<front id="Marlin_mainCPP-5849">        break;</front>
<front id="Marlin_mainCPP-5850">    }</front>
<front id="Marlin_mainCPP-5851">    break;</front>
<front id="Marlin_mainCPP-5852"></front>
<front id="Marlin_mainCPP-5853">    case 'M': switch (codenum) {</front>
<front id="Marlin_mainCPP-5854">      #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-5855">        case 0: // M0 - Unconditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-5856">        case 1: // M1 - Conditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-5857">          gcode_M0_M1();</front>
<front id="Marlin_mainCPP-5858">          break;</front>
<front id="Marlin_mainCPP-5859">      #endif // ULTIPANEL</front>
<front id="Marlin_mainCPP-5860"></front>
<front id="Marlin_mainCPP-5861">      case 17:</front>
<front id="Marlin_mainCPP-5862">        gcode_M17();</front>
<front id="Marlin_mainCPP-5863">        break;</front>
<front id="Marlin_mainCPP-5864"></front>
<front id="Marlin_mainCPP-5865">      #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-5866">        case 19: // M19 - resume Z</front>
<front id="Marlin_mainCPP-5867">          gcode_M19(); break;</front>
<front id="Marlin_mainCPP-5868">      #endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-5869"></front>
<front id="Marlin_mainCPP-5870">    #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-5871"></front>
<front id="Marlin_mainCPP-5872">        case 20: // M20 - list SD card</front>
<front id="Marlin_mainCPP-5873">          gcode_M20(); break;</front>
<front id="Marlin_mainCPP-5874">        case 21: // M21 - init SD card</front>
<front id="Marlin_mainCPP-5875">          gcode_M21(); break;</front>
<front id="Marlin_mainCPP-5876">        case 22: //M22 - release SD card</front>
<front id="Marlin_mainCPP-5877">          gcode_M22(); break;</front>
<front id="Marlin_mainCPP-5878">        case 23: //M23 - Select file</front>
<front id="Marlin_mainCPP-5879">          gcode_M23(); break;</front>
<front id="Marlin_mainCPP-5880">        case 24: //M24 - Start SD print</front>
<front id="Marlin_mainCPP-5881">          gcode_M24(); break;</front>
<front id="Marlin_mainCPP-5882">        case 25: //M25 - Pause SD print</front>
<front id="Marlin_mainCPP-5883">          gcode_M25(); break;</front>
<front id="Marlin_mainCPP-5884">        case 26: //M26 - Set SD index</front>
<front id="Marlin_mainCPP-5885">          gcode_M26(); break;</front>
<front id="Marlin_mainCPP-5886">        case 27: //M27 - Get SD status</front>
<front id="Marlin_mainCPP-5887">          gcode_M27(); break;</front>
<front id="Marlin_mainCPP-5888">        case 28: //M28 - Start SD write</front>
<front id="Marlin_mainCPP-5889">          gcode_M28(); break;</front>
<front id="Marlin_mainCPP-5890">        case 29: //M29 - Stop SD write</front>
<front id="Marlin_mainCPP-5891">          gcode_M29(); break;</front>
<front id="Marlin_mainCPP-5892">        case 30: //M30 &lt;filename&gt; Delete File</front>
<front id="Marlin_mainCPP-5893">          gcode_M30(); break;</front>
<front id="Marlin_mainCPP-5894">        case 32: //M32 - Select file and start SD print</front>
<front id="Marlin_mainCPP-5895">          gcode_M32(); break;</front>
<front id="Marlin_mainCPP-5896"></front>
<front id="Marlin_mainCPP-5897">        #if ENABLED(LONG_FILENAME_HOST_SUPPORT)</front>
<front id="Marlin_mainCPP-5898">          case 33: //M33 - Get the long full path to a file or folder</front>
<front id="Marlin_mainCPP-5899">            gcode_M33(); break;</front>
<front id="Marlin_mainCPP-5900">        #endif // LONG_FILENAME_HOST_SUPPORT</front>
<front id="Marlin_mainCPP-5901"></front>
<front id="Marlin_mainCPP-5902">        case 928: //M928 - Start SD write</front>
<front id="Marlin_mainCPP-5903">          gcode_M928(); break;</front>
<front id="Marlin_mainCPP-5904"></front>
<front id="Marlin_mainCPP-5905">      #endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-5906"></front>
<front id="Marlin_mainCPP-5907">      case 31: //M31 take time since the start of the SD print or an M109 command</front>
<front id="Marlin_mainCPP-5908">        gcode_M31();</front>
<front id="Marlin_mainCPP-5909">        break;</front>
<front id="Marlin_mainCPP-5910"></front>
<front id="Marlin_mainCPP-5911">      case 42: //M42 -Change pin status via gcode</front>
<front id="Marlin_mainCPP-5912">        gcode_M42();</front>
<front id="Marlin_mainCPP-5913">        break;</front>
<front id="Marlin_mainCPP-5914"></front>
<front id="Marlin_mainCPP-5915">      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)</front>
<front id="Marlin_mainCPP-5916">        case 48: // M48 Z probe repeatability</front>
<front id="Marlin_mainCPP-5917">          gcode_M48();</front>
<front id="Marlin_mainCPP-5918">          break;</front>
<front id="Marlin_mainCPP-5919">      #endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST</front>
<front id="Marlin_mainCPP-5920"></front>
<front id="Marlin_mainCPP-5921">      #if ENABLED(M100_FREE_MEMORY_WATCHER)</front>
<front id="Marlin_mainCPP-5922">        case 100:</front>
<front id="Marlin_mainCPP-5923">          gcode_M100();</front>
<front id="Marlin_mainCPP-5924">          break;</front>
<front id="Marlin_mainCPP-5925">      #endif</front>
<front id="Marlin_mainCPP-5926"></front>
<front id="Marlin_mainCPP-5927">      case 104: // M104</front>
<front id="Marlin_mainCPP-5928">        gcode_M104();</front>
<front id="Marlin_mainCPP-5929">        break;</front>
<front id="Marlin_mainCPP-5930"></front>
<front id="Marlin_mainCPP-5931">      case 111: // M111: Set debug level</front>
<front id="Marlin_mainCPP-5932">        gcode_M111();</front>
<front id="Marlin_mainCPP-5933">        break;</front>
<front id="Marlin_mainCPP-5934"></front>
<front id="Marlin_mainCPP-5935">      case 112: // M112: Emergency Stop</front>
<front id="Marlin_mainCPP-5936">        gcode_M112();</front>
<front id="Marlin_mainCPP-5937">        break;</front>
<front id="Marlin_mainCPP-5938"></front>
<front id="Marlin_mainCPP-5939">      case 140: // M140: Set bed temp</front>
<front id="Marlin_mainCPP-5940">        gcode_M140();</front>
<front id="Marlin_mainCPP-5941">        break;</front>
<front id="Marlin_mainCPP-5942"></front>
<front id="Marlin_mainCPP-5943">      case 105: // M105: Read current temperature</front>
<front id="Marlin_mainCPP-5944">        gcode_M105();</front>
<front id="Marlin_mainCPP-5945">        return; // "ok" already printed</front>
<front id="Marlin_mainCPP-5946"></front>
<front id="Marlin_mainCPP-5947">      case 109: // M109: Wait for temperature</front>
<front id="Marlin_mainCPP-5948">        gcode_M109();</front>
<front id="Marlin_mainCPP-5949">        break;</front>
<front id="Marlin_mainCPP-5950"></front>
<front id="Marlin_mainCPP-5951">      #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-5952">        case 190: // M190: Wait for bed heater to reach target</front>
<front id="Marlin_mainCPP-5953">          gcode_M190();</front>
<front id="Marlin_mainCPP-5954">          break;</front>
<front id="Marlin_mainCPP-5955">      #endif // HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-5956"></front>
<front id="Marlin_mainCPP-5957">      #if HAS_FAN</front>
<front id="Marlin_mainCPP-5958">        case 106: // M106: Fan On</front>
<front id="Marlin_mainCPP-5959">          gcode_M106();</front>
<front id="Marlin_mainCPP-5960">          break;</front>
<front id="Marlin_mainCPP-5961">        case 107: // M107: Fan Off</front>
<front id="Marlin_mainCPP-5962">          gcode_M107();</front>
<front id="Marlin_mainCPP-5963">          break;</front>
<front id="Marlin_mainCPP-5964">      #endif // HAS_FAN</front>
<front id="Marlin_mainCPP-5965"></front>
<front id="Marlin_mainCPP-5966">      #if ENABLED(BARICUDA)</front>
<front id="Marlin_mainCPP-5967">        // PWM for HEATER_1_PIN</front>
<front id="Marlin_mainCPP-5968">        #if HAS_HEATER_1</front>
<front id="Marlin_mainCPP-5969">          case 126: // M126: valve open</front>
<front id="Marlin_mainCPP-5970">            gcode_M126();</front>
<front id="Marlin_mainCPP-5971">            break;</front>
<front id="Marlin_mainCPP-5972">          case 127: // M127: valve closed</front>
<front id="Marlin_mainCPP-5973">            gcode_M127();</front>
<front id="Marlin_mainCPP-5974">            break;</front>
<front id="Marlin_mainCPP-5975">        #endif // HAS_HEATER_1</front>
<front id="Marlin_mainCPP-5976"></front>
<front id="Marlin_mainCPP-5977">        // PWM for HEATER_2_PIN</front>
<front id="Marlin_mainCPP-5978">        #if HAS_HEATER_2</front>
<front id="Marlin_mainCPP-5979">          case 128: // M128: valve open</front>
<front id="Marlin_mainCPP-5980">            gcode_M128();</front>
<front id="Marlin_mainCPP-5981">            break;</front>
<front id="Marlin_mainCPP-5982">          case 129: // M129: valve closed</front>
<front id="Marlin_mainCPP-5983">            gcode_M129();</front>
<front id="Marlin_mainCPP-5984">            break;</front>
<front id="Marlin_mainCPP-5985">        #endif // HAS_HEATER_2</front>
<front id="Marlin_mainCPP-5986">      #endif // BARICUDA</front>
<front id="Marlin_mainCPP-5987"></front>
<front id="Marlin_mainCPP-5988">      #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-5989"></front>
<front id="Marlin_mainCPP-5990">        case 80: // M80: Turn on Power Supply</front>
<front id="Marlin_mainCPP-5991">          gcode_M80();</front>
<front id="Marlin_mainCPP-5992">          break;</front>
<front id="Marlin_mainCPP-5993"></front>
<front id="Marlin_mainCPP-5994">      #endif // HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-5995"></front>
<front id="Marlin_mainCPP-5996">      case 81: // M81: Turn off Power, including Power Supply, if possible</front>
<front id="Marlin_mainCPP-5997">        gcode_M81();</front>
<front id="Marlin_mainCPP-5998">        break;</front>
<front id="Marlin_mainCPP-5999"></front>
<front id="Marlin_mainCPP-6000">      case 82:</front>
<front id="Marlin_mainCPP-6001">        gcode_M82();</front>
<front id="Marlin_mainCPP-6002">        break;</front>
<front id="Marlin_mainCPP-6003">      case 83:</front>
<front id="Marlin_mainCPP-6004">        gcode_M83();</front>
<front id="Marlin_mainCPP-6005">        break;</front>
<front id="Marlin_mainCPP-6006">      case 18: // (for compatibility)</front>
<front id="Marlin_mainCPP-6007">      case 84: // M84</front>
<front id="Marlin_mainCPP-6008">        gcode_M18_M84();</front>
<front id="Marlin_mainCPP-6009">        break;</front>
<front id="Marlin_mainCPP-6010">      case 85: // M85</front>
<front id="Marlin_mainCPP-6011">        gcode_M85();</front>
<front id="Marlin_mainCPP-6012">        break;</front>
<front id="Marlin_mainCPP-6013">      case 92: // M92: Set the steps-per-unit for one or more axes</front>
<front id="Marlin_mainCPP-6014">        gcode_M92();</front>
<front id="Marlin_mainCPP-6015">        break;</front>
<front id="Marlin_mainCPP-6016">      case 115: // M115: Report capabilities</front>
<front id="Marlin_mainCPP-6017">        gcode_M115();</front>
<front id="Marlin_mainCPP-6018">        break;</front>
<front id="Marlin_mainCPP-6019">      case 117: // M117: Set LCD message text, if possible</front>
<front id="Marlin_mainCPP-6020">        gcode_M117();</front>
<front id="Marlin_mainCPP-6021">        break;</front>
<front id="Marlin_mainCPP-6022">      case 114: // M114: Report current position</front>
<front id="Marlin_mainCPP-6023">        gcode_M114();</front>
<front id="Marlin_mainCPP-6024">        break;</front>
<front id="Marlin_mainCPP-6025">      case 120: // M120: Enable endstops</front>
<front id="Marlin_mainCPP-6026">        gcode_M120();</front>
<front id="Marlin_mainCPP-6027">        break;</front>
<front id="Marlin_mainCPP-6028">      case 121: // M121: Disable endstops</front>
<front id="Marlin_mainCPP-6029">        gcode_M121();</front>
<front id="Marlin_mainCPP-6030">        break;</front>
<front id="Marlin_mainCPP-6031">      case 119: // M119: Report endstop states</front>
<front id="Marlin_mainCPP-6032">        gcode_M119();</front>
<front id="Marlin_mainCPP-6033">        break;</front>
<front id="Marlin_mainCPP-6034"></front>
<front id="Marlin_mainCPP-6035">      #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-6036"></front>
<front id="Marlin_mainCPP-6037">        case 145: // M145: Set material heatup parameters</front>
<front id="Marlin_mainCPP-6038">          gcode_M145();</front>
<front id="Marlin_mainCPP-6039">          break;</front>
<front id="Marlin_mainCPP-6040"></front>
<front id="Marlin_mainCPP-6041">      #endif</front>
<front id="Marlin_mainCPP-6042"></front>
<front id="Marlin_mainCPP-6043">      #if ENABLED(BLINKM)</front>
<front id="Marlin_mainCPP-6044"></front>
<front id="Marlin_mainCPP-6045">        case 150: // M150</front>
<front id="Marlin_mainCPP-6046">          gcode_M150();</front>
<front id="Marlin_mainCPP-6047">          break;</front>
<front id="Marlin_mainCPP-6048"></front>
<front id="Marlin_mainCPP-6049">      #endif //BLINKM</front>
<front id="Marlin_mainCPP-6050"></front>
<front id="Marlin_mainCPP-6051">      case 200: // M200 D&lt;millimeters&gt; set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).</front>
<front id="Marlin_mainCPP-6052">        gcode_M200();</front>
<front id="Marlin_mainCPP-6053">        break;</front>
<front id="Marlin_mainCPP-6054">      case 201: // M201</front>
<front id="Marlin_mainCPP-6055">        gcode_M201();</front>
<front id="Marlin_mainCPP-6056">        break;</front>
<front id="Marlin_mainCPP-6057">      #if 0 // Not used for Sprinter/grbl gen6</front>
<front id="Marlin_mainCPP-6058">      case 202: // M202</front>
<front id="Marlin_mainCPP-6059">        gcode_M202();</front>
<front id="Marlin_mainCPP-6060">        break;</front>
<front id="Marlin_mainCPP-6061">      #endif</front>
<front id="Marlin_mainCPP-6062">      case 203: // M203 max feedrate mm/sec</front>
<front id="Marlin_mainCPP-6063">        gcode_M203();</front>
<front id="Marlin_mainCPP-6064">        break;</front>
<front id="Marlin_mainCPP-6065">      case 204: // M204 acclereration S normal moves T filmanent only moves</front>
<front id="Marlin_mainCPP-6066">        gcode_M204();</front>
<front id="Marlin_mainCPP-6067">        break;</front>
<front id="Marlin_mainCPP-6068">      case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk</front>
<front id="Marlin_mainCPP-6069">        gcode_M205();</front>
<front id="Marlin_mainCPP-6070">        break;</front>
<front id="Marlin_mainCPP-6071">      case 206: // M206 additional homing offset</front>
<front id="Marlin_mainCPP-6072">        gcode_M206();</front>
<front id="Marlin_mainCPP-6073">        break;</front>
<front id="Marlin_mainCPP-6074"></front>
<front id="Marlin_mainCPP-6075">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-6076">        case 665: // M665 set delta configurations L&lt;diagonal_rod&gt; R&lt;delta_radius&gt; S&lt;segments_per_sec&gt;</front>
<front id="Marlin_mainCPP-6077">          gcode_M665();</front>
<front id="Marlin_mainCPP-6078">          break;</front>
<front id="Marlin_mainCPP-6079">      #endif</front>
<front id="Marlin_mainCPP-6080"></front>
<front id="Marlin_mainCPP-6081">      #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-6082">        case 666: // M666 set delta / dual endstop adjustment</front>
<front id="Marlin_mainCPP-6083">          gcode_M666();</front>
<front id="Marlin_mainCPP-6084">          break;</front>
<front id="Marlin_mainCPP-6085">      #endif</front>
<front id="Marlin_mainCPP-6086"></front>
<front id="Marlin_mainCPP-6087">      #if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-6088">        case 207: //M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop]</front>
<front id="Marlin_mainCPP-6089">          gcode_M207();</front>
<front id="Marlin_mainCPP-6090">          break;</front>
<front id="Marlin_mainCPP-6091">        case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/min]</front>
<front id="Marlin_mainCPP-6092">          gcode_M208();</front>
<front id="Marlin_mainCPP-6093">          break;</front>
<front id="Marlin_mainCPP-6094">        case 209: // M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-6095">          gcode_M209();</front>
<front id="Marlin_mainCPP-6096">          break;</front>
<front id="Marlin_mainCPP-6097">      #endif // FWRETRACT</front>
<front id="Marlin_mainCPP-6098"></front>
<front id="Marlin_mainCPP-6099">      #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-6100">        case 218: // M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-6101">          gcode_M218();</front>
<front id="Marlin_mainCPP-6102">          break;</front>
<front id="Marlin_mainCPP-6103">      #endif</front>
<front id="Marlin_mainCPP-6104"></front>
<front id="Marlin_mainCPP-6105">      case 220: // M220 S&lt;factor in percent&gt;- set speed factor override percentage</front>
<front id="Marlin_mainCPP-6106">        gcode_M220();</front>
<front id="Marlin_mainCPP-6107">        break;</front>
<front id="Marlin_mainCPP-6108"></front>
<front id="Marlin_mainCPP-6109">      case 221: // M221 S&lt;factor in percent&gt;- set extrude factor override percentage</front>
<front id="Marlin_mainCPP-6110">        gcode_M221();</front>
<front id="Marlin_mainCPP-6111">        break;</front>
<front id="Marlin_mainCPP-6112"></front>
<front id="Marlin_mainCPP-6113">      case 226: // M226 P&lt;pin number&gt; S&lt;pin state&gt;- Wait until the specified pin reaches the state required</front>
<front id="Marlin_mainCPP-6114">        gcode_M226();</front>
<front id="Marlin_mainCPP-6115">        break;</front>
<front id="Marlin_mainCPP-6116"></front>
<front id="Marlin_mainCPP-6117">      #if HAS_SERVOS</front>
<front id="Marlin_mainCPP-6118">        case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds</front>
<front id="Marlin_mainCPP-6119">          gcode_M280();</front>
<front id="Marlin_mainCPP-6120">          break;</front>
<front id="Marlin_mainCPP-6121">      #endif // HAS_SERVOS</front>
<front id="Marlin_mainCPP-6122"></front>
<front id="Marlin_mainCPP-6123">      #if HAS_BUZZER</front>
<front id="Marlin_mainCPP-6124">        case 300: // M300 - Play beep tone</front>
<front id="Marlin_mainCPP-6125">          gcode_M300();</front>
<front id="Marlin_mainCPP-6126">          break;</front>
<front id="Marlin_mainCPP-6127">      #endif // HAS_BUZZER</front>
<front id="Marlin_mainCPP-6128"></front>
<front id="Marlin_mainCPP-6129">      #if ENABLED(PIDTEMP)</front>
<front id="Marlin_mainCPP-6130">        case 301: // M301</front>
<front id="Marlin_mainCPP-6131">          gcode_M301();</front>
<front id="Marlin_mainCPP-6132">          break;</front>
<front id="Marlin_mainCPP-6133">      #endif // PIDTEMP</front>
<front id="Marlin_mainCPP-6134"></front>
<front id="Marlin_mainCPP-6135">      #if ENABLED(PIDTEMPBED)</front>
<front id="Marlin_mainCPP-6136">        case 304: // M304</front>
<front id="Marlin_mainCPP-6137">          gcode_M304();</front>
<front id="Marlin_mainCPP-6138">          break;</front>
<front id="Marlin_mainCPP-6139">      #endif // PIDTEMPBED</front>
<front id="Marlin_mainCPP-6140"></front>
<front id="Marlin_mainCPP-6141">      #if defined(CHDK) || HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-6142">        case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="Marlin_mainCPP-6143">          gcode_M240();</front>
<front id="Marlin_mainCPP-6144">          break;</front>
<front id="Marlin_mainCPP-6145">      #endif // CHDK || PHOTOGRAPH_PIN</front>
<front id="Marlin_mainCPP-6146"></front>
<front id="Marlin_mainCPP-6147">      #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="Marlin_mainCPP-6148">        case 250: // M250  Set LCD contrast value: C&lt;value&gt; (value 0..63)</front>
<front id="Marlin_mainCPP-6149">          gcode_M250();</front>
<front id="Marlin_mainCPP-6150">          break;</front>
<front id="Marlin_mainCPP-6151">      #endif // HAS_LCD_CONTRAST</front>
<front id="Marlin_mainCPP-6152"></front>
<front id="Marlin_mainCPP-6153">      #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-6154">        case 302: // allow cold extrudes, or set the minimum extrude temperature</front>
<front id="Marlin_mainCPP-6155">          gcode_M302();</front>
<front id="Marlin_mainCPP-6156">          break;</front>
<front id="Marlin_mainCPP-6157">      #endif // PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-6158"></front>
<front id="Marlin_mainCPP-6159">      case 303: // M303 PID autotune</front>
<front id="Marlin_mainCPP-6160">        gcode_M303();</front>
<front id="Marlin_mainCPP-6161">        break;</front>
<front id="Marlin_mainCPP-6162"></front>
<front id="Marlin_mainCPP-6163">      #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6164">        case 360:  // M360 SCARA Theta pos1</front>
<front id="Marlin_mainCPP-6165">          if (gcode_M360()) return;</front>
<front id="Marlin_mainCPP-6166">          break;</front>
<front id="Marlin_mainCPP-6167">        case 361:  // M361 SCARA Theta pos2</front>
<front id="Marlin_mainCPP-6168">          if (gcode_M361()) return;</front>
<front id="Marlin_mainCPP-6169">          break;</front>
<front id="Marlin_mainCPP-6170">        case 362:  // M362 SCARA Psi pos1</front>
<front id="Marlin_mainCPP-6171">          if (gcode_M362()) return;</front>
<front id="Marlin_mainCPP-6172">          break;</front>
<front id="Marlin_mainCPP-6173">        case 363:  // M363 SCARA Psi pos2</front>
<front id="Marlin_mainCPP-6174">          if (gcode_M363()) return;</front>
<front id="Marlin_mainCPP-6175">          break;</front>
<front id="Marlin_mainCPP-6176">        case 364:  // M364 SCARA Psi pos3 (90 deg to Theta)</front>
<front id="Marlin_mainCPP-6177">          if (gcode_M364()) return;</front>
<front id="Marlin_mainCPP-6178">          break;</front>
<front id="Marlin_mainCPP-6179">        case 365: // M365 Set SCARA scaling for X Y Z</front>
<front id="Marlin_mainCPP-6180">          gcode_M365();</front>
<front id="Marlin_mainCPP-6181">          break;</front>
<front id="Marlin_mainCPP-6182">      #endif // SCARA</front>
<front id="Marlin_mainCPP-6183"></front>
<front id="Marlin_mainCPP-6184">      case 400: // M400 finish all moves</front>
<front id="Marlin_mainCPP-6185">        gcode_M400();</front>
<front id="Marlin_mainCPP-6186">        break;</front>
<front id="Marlin_mainCPP-6187"></front>
<front id="Marlin_mainCPP-6188">      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-6189">        case 401:</front>
<front id="Marlin_mainCPP-6190">          gcode_M401();</front>
<front id="Marlin_mainCPP-6191">          break;</front>
<front id="Marlin_mainCPP-6192">        case 402:</front>
<front id="Marlin_mainCPP-6193">          gcode_M402();</front>
<front id="Marlin_mainCPP-6194">          break;</front>
<front id="Marlin_mainCPP-6195">      #endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-6196"></front>
<front id="Marlin_mainCPP-6197">      #if ENABLED(FILAMENT_SENSOR)</front>
<front id="Marlin_mainCPP-6198">        case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N&lt;3.0&gt; or display nominal filament width</front>
<front id="Marlin_mainCPP-6199">          gcode_M404();</front>
<front id="Marlin_mainCPP-6200">          break;</front>
<front id="Marlin_mainCPP-6201">        case 405:  //M405 Turn on filament sensor for control</front>
<front id="Marlin_mainCPP-6202">          gcode_M405();</front>
<front id="Marlin_mainCPP-6203">          break;</front>
<front id="Marlin_mainCPP-6204">        case 406:  //M406 Turn off filament sensor for control</front>
<front id="Marlin_mainCPP-6205">          gcode_M406();</front>
<front id="Marlin_mainCPP-6206">          break;</front>
<front id="Marlin_mainCPP-6207">        case 407:   //M407 Display measured filament diameter</front>
<front id="Marlin_mainCPP-6208">          gcode_M407();</front>
<front id="Marlin_mainCPP-6209">          break;</front>
<front id="Marlin_mainCPP-6210">      #endif // FILAMENT_SENSOR</front>
<front id="Marlin_mainCPP-6211"></front>
<front id="Marlin_mainCPP-6212">      case 410: // M410 quickstop - Abort all the planned moves.</front>
<front id="Marlin_mainCPP-6213">        gcode_M410();</front>
<front id="Marlin_mainCPP-6214">        break;</front>
<front id="Marlin_mainCPP-6215"></front>
<front id="Marlin_mainCPP-6216">      #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-6217">        case 420: // M420 Enable/Disable Mesh Bed Leveling</front>
<front id="Marlin_mainCPP-6218">          gcode_M420();</front>
<front id="Marlin_mainCPP-6219">          break;</front>
<front id="Marlin_mainCPP-6220">        case 421: // M421 Set a Mesh Bed Leveling Z coordinate</front>
<front id="Marlin_mainCPP-6221">          gcode_M421();</front>
<front id="Marlin_mainCPP-6222">          break;</front>
<front id="Marlin_mainCPP-6223">      #endif</front>
<front id="Marlin_mainCPP-6224"></front>
<front id="Marlin_mainCPP-6225">      case 428: // M428 Apply current_position to home_offset</front>
<front id="Marlin_mainCPP-6226">        gcode_M428();</front>
<front id="Marlin_mainCPP-6227">        break;</front>
<front id="Marlin_mainCPP-6228"></front>
<front id="Marlin_mainCPP-6229">      case 500: // M500 Store settings in EEPROM</front>
<front id="Marlin_mainCPP-6230">        gcode_M500();</front>
<front id="Marlin_mainCPP-6231">        break;</front>
<front id="Marlin_mainCPP-6232">      case 501: // M501 Read settings from EEPROM</front>
<front id="Marlin_mainCPP-6233">        gcode_M501();</front>
<front id="Marlin_mainCPP-6234">        break;</front>
<front id="Marlin_mainCPP-6235">      case 502: // M502 Revert to default settings</front>
<front id="Marlin_mainCPP-6236">        gcode_M502();</front>
<front id="Marlin_mainCPP-6237">        break;</front>
<front id="Marlin_mainCPP-6238">      case 503: // M503 print settings currently in memory</front>
<front id="Marlin_mainCPP-6239">        gcode_M503();</front>
<front id="Marlin_mainCPP-6240">        break;</front>
<front id="Marlin_mainCPP-6241"></front>
<front id="Marlin_mainCPP-6242">      #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-6243">        case 540:</front>
<front id="Marlin_mainCPP-6244">          gcode_M540();</front>
<front id="Marlin_mainCPP-6245">          break;</front>
<front id="Marlin_mainCPP-6246">      #endif</front>
<front id="Marlin_mainCPP-6247"></front>
<front id="Marlin_mainCPP-6248">      #ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-6249">        case CUSTOM_M_CODE_SET_Z_PROBE_OFFSET:</front>
<front id="Marlin_mainCPP-6250">          gcode_SET_Z_PROBE_OFFSET();</front>
<front id="Marlin_mainCPP-6251">          break;</front>
<front id="Marlin_mainCPP-6252">      #endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-6253"></front>
<front id="Marlin_mainCPP-6254">      #if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="Marlin_mainCPP-6255">        case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</front>
<front id="Marlin_mainCPP-6256">          gcode_M600();</front>
<front id="Marlin_mainCPP-6257">          break;</front>
<front id="Marlin_mainCPP-6258">      #endif // FILAMENTCHANGEENABLE</front>
<front id="Marlin_mainCPP-6259"></front>
<front id="Marlin_mainCPP-6260">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-6261">        case 605:</front>
<front id="Marlin_mainCPP-6262">          gcode_M605();</front>
<front id="Marlin_mainCPP-6263">          break;</front>
<front id="Marlin_mainCPP-6264">      #endif // DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-6265"></front>
<front id="Marlin_mainCPP-6266">      case 907: // M907 Set digital trimpot motor current using axis codes.</front>
<front id="Marlin_mainCPP-6267">        gcode_M907();</front>
<front id="Marlin_mainCPP-6268">        break;</front>
<front id="Marlin_mainCPP-6269"></front>
<front id="Marlin_mainCPP-6270">      #if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-6271">        case 908: // M908 Control digital trimpot directly.</front>
<front id="Marlin_mainCPP-6272">          gcode_M908();</front>
<front id="Marlin_mainCPP-6273">          break;</front>
<front id="Marlin_mainCPP-6274">      #endif // HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-6275"></front>
<front id="Marlin_mainCPP-6276">      #if HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-6277"></front>
<front id="Marlin_mainCPP-6278">        case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</front>
<front id="Marlin_mainCPP-6279">          gcode_M350();</front>
<front id="Marlin_mainCPP-6280">          break;</front>
<front id="Marlin_mainCPP-6281"></front>
<front id="Marlin_mainCPP-6282">        case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.</front>
<front id="Marlin_mainCPP-6283">          gcode_M351();</front>
<front id="Marlin_mainCPP-6284">          break;</front>
<front id="Marlin_mainCPP-6285"></front>
<front id="Marlin_mainCPP-6286">      #endif // HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-6287"></front>
<front id="Marlin_mainCPP-6288">      case 999: // M999: Restart after being Stopped</front>
<front id="Marlin_mainCPP-6289">        gcode_M999();</front>
<front id="Marlin_mainCPP-6290">        break;</front>
<front id="Marlin_mainCPP-6291">    }</front>
<front id="Marlin_mainCPP-6292">    break;</front>
<front id="Marlin_mainCPP-6293"></front>
<front id="Marlin_mainCPP-6294">    case 'T':</front>
<front id="Marlin_mainCPP-6295">      gcode_T(codenum);</front>
<front id="Marlin_mainCPP-6296">    break;</front>
<front id="Marlin_mainCPP-6297"></front>
<front id="Marlin_mainCPP-6298">    default: code_is_good = false;</front>
<front id="Marlin_mainCPP-6299">  }</front>
<front id="Marlin_mainCPP-6300"></front>
<front id="Marlin_mainCPP-6301">ExitUnknownCommand:</front>
<front id="Marlin_mainCPP-6302"></front>
<front id="Marlin_mainCPP-6303">  // Still unknown command? Throw an error</front>
<front id="Marlin_mainCPP-6304">  if (!code_is_good) unknown_command_error();</front>
<front id="Marlin_mainCPP-6305"></front>
<front id="Marlin_mainCPP-6306">  ok_to_send();</front>
<front id="Marlin_mainCPP-6307">}</front>
<front id="Marlin_mainCPP-6308"></front>
<front id="Marlin_mainCPP-6309">void FlushSerialRequestResend() {</front>
<front id="Marlin_mainCPP-6310">  //char command_queue[cmd_queue_index_r][100]="Resend:";</front>
<front id="Marlin_mainCPP-6311">  MYSERIAL.flush();</front>
<front id="Marlin_mainCPP-6312">  SERIAL_PROTOCOLPGM(MSG_RESEND);</front>
<front id="Marlin_mainCPP-6313">  SERIAL_PROTOCOLLN(gcode_LastN + 1);</front>
<front id="Marlin_mainCPP-6314">  ok_to_send();</front>
<front id="Marlin_mainCPP-6315">}</front>
<front id="Marlin_mainCPP-6316"></front>
<front id="Marlin_mainCPP-6317">void ok_to_send() {</front>
<front id="Marlin_mainCPP-6318">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-6319">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-6320">    if (fromsd[cmd_queue_index_r]) return;</front>
<front id="Marlin_mainCPP-6321">  #endif</front>
<front id="Marlin_mainCPP-6322">  SERIAL_PROTOCOLPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-6323">  #if ENABLED(ADVANCED_OK)</front>
<front id="Marlin_mainCPP-6324">    SERIAL_PROTOCOLPGM(" N"); SERIAL_PROTOCOL(gcode_LastN);</front>
<front id="Marlin_mainCPP-6325">    SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - movesplanned() - 1));</front>
<front id="Marlin_mainCPP-6326">    SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);</front>
<front id="Marlin_mainCPP-6327">  #endif</front>
<front id="Marlin_mainCPP-6328">  SERIAL_EOL;</front>
<front id="Marlin_mainCPP-6329">}</front>
<front id="Marlin_mainCPP-6330"></front>
<front id="Marlin_mainCPP-6331">void clamp_to_software_endstops(float target[3]) {</front>
<front id="Marlin_mainCPP-6332">  if (min_software_endstops) {</front>
<front id="Marlin_mainCPP-6333">    NOLESS(target[X_AXIS], min_pos[X_AXIS]);</front>
<front id="Marlin_mainCPP-6334">    NOLESS(target[Y_AXIS], min_pos[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6335"></front>
<front id="Marlin_mainCPP-6336">    float negative_z_offset = 0;</front>
<front id="Marlin_mainCPP-6337">    #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6338">      if (zprobe_zoffset &lt; 0) negative_z_offset += zprobe_zoffset;</front>
<front id="Marlin_mainCPP-6339">      if (home_offset[Z_AXIS] &lt; 0) {</front>
<front id="Marlin_mainCPP-6340">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6341">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-6342">            SERIAL_ECHOPAIR("&gt; clamp_to_software_endstops &gt; Add home_offset[Z_AXIS]:", home_offset[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6343">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-6344">          }</front>
<front id="Marlin_mainCPP-6345">        #endif</front>
<front id="Marlin_mainCPP-6346">        negative_z_offset += home_offset[Z_AXIS];</front>
<front id="Marlin_mainCPP-6347">      }</front>
<front id="Marlin_mainCPP-6348">    #endif</front>
<front id="Marlin_mainCPP-6349">    NOLESS(target[Z_AXIS], min_pos[Z_AXIS] + negative_z_offset);</front>
<front id="Marlin_mainCPP-6350">  }</front>
<front id="Marlin_mainCPP-6351"></front>
<front id="Marlin_mainCPP-6352">  if (max_software_endstops) {</front>
<front id="Marlin_mainCPP-6353">    NOMORE(target[X_AXIS], max_pos[X_AXIS]);</front>
<front id="Marlin_mainCPP-6354">    NOMORE(target[Y_AXIS], max_pos[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6355">    NOMORE(target[Z_AXIS], max_pos[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6356">  }</front>
<front id="Marlin_mainCPP-6357">}</front>
<front id="Marlin_mainCPP-6358"></front>
<front id="Marlin_mainCPP-6359">#if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-6360"></front>
<front id="Marlin_mainCPP-6361">  void recalc_delta_settings(float radius, float diagonal_rod) {</front>
<front id="Marlin_mainCPP-6362">    delta_tower1_x = -SIN_60 * (radius + DELTA_RADIUS_TRIM_TOWER_1);  // front left tower</front>
<front id="Marlin_mainCPP-6363">    delta_tower1_y = -COS_60 * (radius + DELTA_RADIUS_TRIM_TOWER_1);</front>
<front id="Marlin_mainCPP-6364">    delta_tower2_x =  SIN_60 * (radius + DELTA_RADIUS_TRIM_TOWER_2);  // front right tower</front>
<front id="Marlin_mainCPP-6365">    delta_tower2_y = -COS_60 * (radius + DELTA_RADIUS_TRIM_TOWER_2);</front>
<front id="Marlin_mainCPP-6366">    delta_tower3_x = 0.0;                                             // back middle tower</front>
<front id="Marlin_mainCPP-6367">    delta_tower3_y = (radius + DELTA_RADIUS_TRIM_TOWER_3);</front>
<front id="Marlin_mainCPP-6368">    delta_diagonal_rod_2_tower_1 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_1);</front>
<front id="Marlin_mainCPP-6369">    delta_diagonal_rod_2_tower_2 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_2);</front>
<front id="Marlin_mainCPP-6370">    delta_diagonal_rod_2_tower_3 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_3);</front>
<front id="Marlin_mainCPP-6371">  }</front>
<front id="Marlin_mainCPP-6372"></front>
<front id="Marlin_mainCPP-6373">  void calculate_delta(float cartesian[3]) {</front>
<front id="Marlin_mainCPP-6374"></front>
<front id="Marlin_mainCPP-6375">    delta[TOWER_1] = sqrt(delta_diagonal_rod_2_tower_1</front>
<front id="Marlin_mainCPP-6376">                         - sq(delta_tower1_x-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-6377">                         - sq(delta_tower1_y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-6378">                         ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6379">    delta[TOWER_2] = sqrt(delta_diagonal_rod_2_tower_2</front>
<front id="Marlin_mainCPP-6380">                         - sq(delta_tower2_x-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-6381">                         - sq(delta_tower2_y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-6382">                         ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6383">    delta[TOWER_3] = sqrt(delta_diagonal_rod_2_tower_3</front>
<front id="Marlin_mainCPP-6384">                         - sq(delta_tower3_x-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-6385">                         - sq(delta_tower3_y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-6386">                         ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6387">    /*</front>
<front id="Marlin_mainCPP-6388">    SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);</front>
<front id="Marlin_mainCPP-6389">    SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6390">    SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6391"></front>
<front id="Marlin_mainCPP-6392">    SERIAL_ECHOPGM("delta a="); SERIAL_ECHO(delta[TOWER_1]);</front>
<front id="Marlin_mainCPP-6393">    SERIAL_ECHOPGM(" b="); SERIAL_ECHO(delta[TOWER_2]);</front>
<front id="Marlin_mainCPP-6394">    SERIAL_ECHOPGM(" c="); SERIAL_ECHOLN(delta[TOWER_3]);</front>
<front id="Marlin_mainCPP-6395">    */</front>
<front id="Marlin_mainCPP-6396">  }</front>
<front id="Marlin_mainCPP-6397"></front>
<front id="Marlin_mainCPP-6398">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6399"></front>
<front id="Marlin_mainCPP-6400">    // Adjust print surface height by linear interpolation over the bed_level array.</front>
<front id="Marlin_mainCPP-6401">    void adjust_delta(float cartesian[3]) {</front>
<front id="Marlin_mainCPP-6402">      if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!</front>
<front id="Marlin_mainCPP-6403"></front>
<front id="Marlin_mainCPP-6404">      int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;</front>
<front id="Marlin_mainCPP-6405">      float h1 = 0.001 - half, h2 = half - 0.001,</front>
<front id="Marlin_mainCPP-6406">            grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),</front>
<front id="Marlin_mainCPP-6407">            grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));</front>
<front id="Marlin_mainCPP-6408">      int floor_x = floor(grid_x), floor_y = floor(grid_y);</front>
<front id="Marlin_mainCPP-6409">      float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,</front>
<front id="Marlin_mainCPP-6410">            z1 = bed_level[floor_x + half][floor_y + half],</front>
<front id="Marlin_mainCPP-6411">            z2 = bed_level[floor_x + half][floor_y + half + 1],</front>
<front id="Marlin_mainCPP-6412">            z3 = bed_level[floor_x + half + 1][floor_y + half],</front>
<front id="Marlin_mainCPP-6413">            z4 = bed_level[floor_x + half + 1][floor_y + half + 1],</front>
<front id="Marlin_mainCPP-6414">            left = (1 - ratio_y) * z1 + ratio_y * z2,</front>
<front id="Marlin_mainCPP-6415">            right = (1 - ratio_y) * z3 + ratio_y * z4,</front>
<front id="Marlin_mainCPP-6416">            offset = (1 - ratio_x) * left + ratio_x * right;</front>
<front id="Marlin_mainCPP-6417"></front>
<front id="Marlin_mainCPP-6418">      delta[X_AXIS] += offset;</front>
<front id="Marlin_mainCPP-6419">      delta[Y_AXIS] += offset;</front>
<front id="Marlin_mainCPP-6420">      delta[Z_AXIS] += offset;</front>
<front id="Marlin_mainCPP-6421"></front>
<front id="Marlin_mainCPP-6422">      /*</front>
<front id="Marlin_mainCPP-6423">      SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);</front>
<front id="Marlin_mainCPP-6424">      SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);</front>
<front id="Marlin_mainCPP-6425">      SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);</front>
<front id="Marlin_mainCPP-6426">      SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);</front>
<front id="Marlin_mainCPP-6427">      SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);</front>
<front id="Marlin_mainCPP-6428">      SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);</front>
<front id="Marlin_mainCPP-6429">      SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);</front>
<front id="Marlin_mainCPP-6430">      SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);</front>
<front id="Marlin_mainCPP-6431">      SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);</front>
<front id="Marlin_mainCPP-6432">      SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);</front>
<front id="Marlin_mainCPP-6433">      SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);</front>
<front id="Marlin_mainCPP-6434">      SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);</front>
<front id="Marlin_mainCPP-6435">      SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);</front>
<front id="Marlin_mainCPP-6436">      */</front>
<front id="Marlin_mainCPP-6437">    }</front>
<front id="Marlin_mainCPP-6438">  #endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-6439"></front>
<front id="Marlin_mainCPP-6440">#endif // DELTA</front>
<front id="Marlin_mainCPP-6441"></front>
<front id="Marlin_mainCPP-6442">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-6443"></front>
<front id="Marlin_mainCPP-6444">// This function is used to split lines on mesh borders so each segment is only part of one mesh area</front>
<front id="Marlin_mainCPP-6445">void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_rate, const uint8_t &extruder, uint8_t x_splits=0xff, uint8_t y_splits=0xff)</front>
<front id="Marlin_mainCPP-6446">{</front>
<front id="Marlin_mainCPP-6447">  if (!mbl.active) {</front>
<front id="Marlin_mainCPP-6448">    plan_buffer_line(x, y, z, e, feed_rate, extruder);</front>
<front id="Marlin_mainCPP-6449">    set_current_to_destination();</front>
<front id="Marlin_mainCPP-6450">    return;</front>
<front id="Marlin_mainCPP-6451">  }</front>
<front id="Marlin_mainCPP-6452">  int pix = mbl.select_x_index(current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-6453">  int piy = mbl.select_y_index(current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6454">  int ix = mbl.select_x_index(x);</front>
<front id="Marlin_mainCPP-6455">  int iy = mbl.select_y_index(y);</front>
<front id="Marlin_mainCPP-6456">  pix = min(pix, MESH_NUM_X_POINTS - 2);</front>
<front id="Marlin_mainCPP-6457">  piy = min(piy, MESH_NUM_Y_POINTS - 2);</front>
<front id="Marlin_mainCPP-6458">  ix = min(ix, MESH_NUM_X_POINTS - 2);</front>
<front id="Marlin_mainCPP-6459">  iy = min(iy, MESH_NUM_Y_POINTS - 2);</front>
<front id="Marlin_mainCPP-6460">  if (pix == ix && piy == iy) {</front>
<front id="Marlin_mainCPP-6461">    // Start and end on same mesh square</front>
<front id="Marlin_mainCPP-6462">    plan_buffer_line(x, y, z, e, feed_rate, extruder);</front>
<front id="Marlin_mainCPP-6463">    set_current_to_destination();</front>
<front id="Marlin_mainCPP-6464">    return;</front>
<front id="Marlin_mainCPP-6465">  }</front>
<front id="Marlin_mainCPP-6466">  float nx, ny, ne, normalized_dist;</front>
<front id="Marlin_mainCPP-6467">  if (ix &gt; pix && (x_splits) & BIT(ix)) {</front>
<front id="Marlin_mainCPP-6468">    nx = mbl.get_x(ix);</front>
<front id="Marlin_mainCPP-6469">    normalized_dist = (nx - current_position[X_AXIS])/(x - current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-6470">    ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6471">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6472">    x_splits ^= BIT(ix);</front>
<front id="Marlin_mainCPP-6473">  } else if (ix &lt; pix && (x_splits) & BIT(pix)) {</front>
<front id="Marlin_mainCPP-6474">    nx = mbl.get_x(pix);</front>
<front id="Marlin_mainCPP-6475">    normalized_dist = (nx - current_position[X_AXIS])/(x - current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-6476">    ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6477">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6478">    x_splits ^= BIT(pix);</front>
<front id="Marlin_mainCPP-6479">  } else if (iy &gt; piy && (y_splits) & BIT(iy)) {</front>
<front id="Marlin_mainCPP-6480">    ny = mbl.get_y(iy);</front>
<front id="Marlin_mainCPP-6481">    normalized_dist = (ny - current_position[Y_AXIS])/(y - current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6482">    nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6483">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6484">    y_splits ^= BIT(iy);</front>
<front id="Marlin_mainCPP-6485">  } else if (iy &lt; piy && (y_splits) & BIT(piy)) {</front>
<front id="Marlin_mainCPP-6486">    ny = mbl.get_y(piy);</front>
<front id="Marlin_mainCPP-6487">    normalized_dist = (ny - current_position[Y_AXIS])/(y - current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6488">    nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6489">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6490">    y_splits ^= BIT(piy);</front>
<front id="Marlin_mainCPP-6491">  } else {</front>
<front id="Marlin_mainCPP-6492">    // Already split on a border</front>
<front id="Marlin_mainCPP-6493">    plan_buffer_line(x, y, z, e, feed_rate, extruder);</front>
<front id="Marlin_mainCPP-6494">    set_current_to_destination();</front>
<front id="Marlin_mainCPP-6495">    return;</front>
<front id="Marlin_mainCPP-6496">  }</front>
<front id="Marlin_mainCPP-6497">  // Do the split and look for more borders</front>
<front id="Marlin_mainCPP-6498">  destination[X_AXIS] = nx;</front>
<front id="Marlin_mainCPP-6499">  destination[Y_AXIS] = ny;</front>
<front id="Marlin_mainCPP-6500">  destination[E_AXIS] = ne;</front>
<front id="Marlin_mainCPP-6501">  mesh_plan_buffer_line(nx, ny, z, ne, feed_rate, extruder, x_splits, y_splits);</front>
<front id="Marlin_mainCPP-6502">  destination[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-6503">  destination[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-6504">  destination[E_AXIS] = e;</front>
<front id="Marlin_mainCPP-6505">  mesh_plan_buffer_line(x, y, z, e, feed_rate, extruder, x_splits, y_splits);</front>
<front id="Marlin_mainCPP-6506">}</front>
<front id="Marlin_mainCPP-6507">#endif  // MESH_BED_LEVELING</front>
<front id="Marlin_mainCPP-6508"></front>
<front id="Marlin_mainCPP-6509">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-6510"></front>
<front id="Marlin_mainCPP-6511">  inline void prevent_dangerous_extrude(float &curr_e, float &dest_e) {</front>
<front id="Marlin_mainCPP-6512">    if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-6513">    float de = dest_e - curr_e;</front>
<front id="Marlin_mainCPP-6514">    if (de) {</front>
<front id="Marlin_mainCPP-6515">      if (degHotend(active_extruder) &lt; extrude_min_temp) {</front>
<front id="Marlin_mainCPP-6516">        curr_e = dest_e; // Behave as if the move really took place, but ignore E part</front>
<front id="Marlin_mainCPP-6517">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-6518">        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);</front>
<front id="Marlin_mainCPP-6519">      }</front>
<front id="Marlin_mainCPP-6520">      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)</front>
<front id="Marlin_mainCPP-6521">        if (labs(de) &gt; EXTRUDE_MAXLENGTH) {</front>
<front id="Marlin_mainCPP-6522">          curr_e = dest_e; // Behave as if the move really took place, but ignore E part</front>
<front id="Marlin_mainCPP-6523">          SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-6524">          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);</front>
<front id="Marlin_mainCPP-6525">        }</front>
<front id="Marlin_mainCPP-6526">      #endif</front>
<front id="Marlin_mainCPP-6527">    }</front>
<front id="Marlin_mainCPP-6528">  }</front>
<front id="Marlin_mainCPP-6529"></front>
<front id="Marlin_mainCPP-6530">#endif // PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-6531"></front>
<front id="Marlin_mainCPP-6532">#if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6533"></front>
<front id="Marlin_mainCPP-6534">  inline bool prepare_move_delta(float target[NUM_AXIS]) {</front>
<front id="Marlin_mainCPP-6535">    float difference[NUM_AXIS];</front>
<front id="Marlin_mainCPP-6536">    for (int8_t i=0; i &lt; NUM_AXIS; i++) difference[i] = target[i] - current_position[i];</front>
<front id="Marlin_mainCPP-6537"></front>
<front id="Marlin_mainCPP-6538">    float cartesian_mm = sqrt(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));</front>
<front id="Marlin_mainCPP-6539">    if (cartesian_mm &lt; 0.000001) cartesian_mm = abs(difference[E_AXIS]);</front>
<front id="Marlin_mainCPP-6540">    if (cartesian_mm &lt; 0.000001) return false;</front>
<front id="Marlin_mainCPP-6541">    float seconds = 6000 * cartesian_mm / feedrate / feedrate_multiplier;</front>
<front id="Marlin_mainCPP-6542">    int steps = max(1, int(delta_segments_per_second * seconds));</front>
<front id="Marlin_mainCPP-6543"></front>
<front id="Marlin_mainCPP-6544">    // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);</front>
<front id="Marlin_mainCPP-6545">    // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);</front>
<front id="Marlin_mainCPP-6546">    // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);</front>
<front id="Marlin_mainCPP-6547"></front>
<front id="Marlin_mainCPP-6548">    for (int s = 1; s &lt;= steps; s++) {</front>
<front id="Marlin_mainCPP-6549"></front>
<front id="Marlin_mainCPP-6550">      float fraction = float(s) / float(steps);</front>
<front id="Marlin_mainCPP-6551"></front>
<front id="Marlin_mainCPP-6552">      for (int8_t i = 0; i &lt; NUM_AXIS; i++)</front>
<front id="Marlin_mainCPP-6553">        target[i] = current_position[i] + difference[i] * fraction;</front>
<front id="Marlin_mainCPP-6554"></front>
<front id="Marlin_mainCPP-6555">      calculate_delta(target);</front>
<front id="Marlin_mainCPP-6556"></front>
<front id="Marlin_mainCPP-6557">      #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6558">        adjust_delta(target);</front>
<front id="Marlin_mainCPP-6559">      #endif</front>
<front id="Marlin_mainCPP-6560"></front>
<front id="Marlin_mainCPP-6561">      //SERIAL_ECHOPGM("target[X_AXIS]="); SERIAL_ECHOLN(target[X_AXIS]);</front>
<front id="Marlin_mainCPP-6562">      //SERIAL_ECHOPGM("target[Y_AXIS]="); SERIAL_ECHOLN(target[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6563">      //SERIAL_ECHOPGM("target[Z_AXIS]="); SERIAL_ECHOLN(target[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6564">      //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-6565">      //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6566">      //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6567"></front>
<front id="Marlin_mainCPP-6568">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feedrate/60*feedrate_multiplier/100.0, active_extruder);</front>
<front id="Marlin_mainCPP-6569">    }</front>
<front id="Marlin_mainCPP-6570">    return true;</front>
<front id="Marlin_mainCPP-6571">  }</front>
<front id="Marlin_mainCPP-6572"></front>
<front id="Marlin_mainCPP-6573">#endif // DELTA || SCARA</front>
<front id="Marlin_mainCPP-6574"></front>
<front id="Marlin_mainCPP-6575">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6576">  inline bool prepare_move_scara(float target[NUM_AXIS]) { return prepare_move_delta(target); }</front>
<front id="Marlin_mainCPP-6577">#endif</front>
<front id="Marlin_mainCPP-6578"></front>
<front id="Marlin_mainCPP-6579">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-6580"></front>
<front id="Marlin_mainCPP-6581">  inline bool prepare_move_dual_x_carriage() {</front>
<front id="Marlin_mainCPP-6582">    if (active_extruder_parked) {</front>
<front id="Marlin_mainCPP-6583">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {</front>
<front id="Marlin_mainCPP-6584">        // move duplicate extruder into correct duplication position.</front>
<front id="Marlin_mainCPP-6585">        plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-6586">        plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,</front>
<front id="Marlin_mainCPP-6587">          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[X_AXIS], 1);</front>
<front id="Marlin_mainCPP-6588">        sync_plan_position();</front>
<front id="Marlin_mainCPP-6589">        st_synchronize();</front>
<front id="Marlin_mainCPP-6590">        extruder_duplication_enabled = true;</front>
<front id="Marlin_mainCPP-6591">        active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-6592">      }</front>
<front id="Marlin_mainCPP-6593">      else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) { // handle unparking of head</front>
<front id="Marlin_mainCPP-6594">        if (current_position[E_AXIS] == destination[E_AXIS]) {</front>
<front id="Marlin_mainCPP-6595">          // This is a travel move (with no extrusion)</front>
<front id="Marlin_mainCPP-6596">          // Skip it, but keep track of the current position</front>
<front id="Marlin_mainCPP-6597">          // (so it can be used as the start of the next non-travel move)</front>
<front id="Marlin_mainCPP-6598">          if (delayed_move_time != 0xFFFFFFFFUL) {</front>
<front id="Marlin_mainCPP-6599">            set_current_to_destination();</front>
<front id="Marlin_mainCPP-6600">            NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6601">            delayed_move_time = millis();</front>
<front id="Marlin_mainCPP-6602">            return false;</front>
<front id="Marlin_mainCPP-6603">          }</front>
<front id="Marlin_mainCPP-6604">        }</front>
<front id="Marlin_mainCPP-6605">        delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-6606">        // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower</front>
<front id="Marlin_mainCPP-6607">        plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-6608">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], min(max_feedrate[X_AXIS], max_feedrate[Y_AXIS]), active_extruder);</front>
<front id="Marlin_mainCPP-6609">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-6610">        active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-6611">      }</front>
<front id="Marlin_mainCPP-6612">    }</front>
<front id="Marlin_mainCPP-6613">    return true;</front>
<front id="Marlin_mainCPP-6614">  }</front>
<front id="Marlin_mainCPP-6615"></front>
<front id="Marlin_mainCPP-6616">#endif // DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-6617"></front>
<front id="Marlin_mainCPP-6618">#if DISABLED(DELTA) && DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-6619"></front>
<front id="Marlin_mainCPP-6620">  inline bool prepare_move_cartesian() {</front>
<front id="Marlin_mainCPP-6621">    // Do not use feedrate_multiplier for E or Z only moves</front>
<front id="Marlin_mainCPP-6622">    if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-6623">      line_to_destination();</front>
<front id="Marlin_mainCPP-6624">    }</front>
<front id="Marlin_mainCPP-6625">    else {</front>
<front id="Marlin_mainCPP-6626">      #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-6627">        mesh_plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], (feedrate/60)*(feedrate_multiplier/100.0), active_extruder);</front>
<front id="Marlin_mainCPP-6628">        return false;</front>
<front id="Marlin_mainCPP-6629">      #else</front>
<front id="Marlin_mainCPP-6630">        line_to_destination(feedrate * feedrate_multiplier / 100.0);</front>
<front id="Marlin_mainCPP-6631">      #endif</front>
<front id="Marlin_mainCPP-6632">    }</front>
<front id="Marlin_mainCPP-6633">    return true;</front>
<front id="Marlin_mainCPP-6634">  }</front>
<front id="Marlin_mainCPP-6635"></front>
<front id="Marlin_mainCPP-6636">#endif // !DELTA && !SCARA</front>
<front id="Marlin_mainCPP-6637"></front>
<front id="Marlin_mainCPP-6638">/**</front>
<front id="Marlin_mainCPP-6639"> * Prepare a single move and get ready for the next one</front>
<front id="Marlin_mainCPP-6640"> *</front>
<front id="Marlin_mainCPP-6641"> * (This may call plan_buffer_line several times to put</front>
<front id="Marlin_mainCPP-6642"> *  smaller moves into the planner for DELTA or SCARA.)</front>
<front id="Marlin_mainCPP-6643"> */</front>
<front id="Marlin_mainCPP-6644">void prepare_move() {</front>
<front id="Marlin_mainCPP-6645">  clamp_to_software_endstops(destination);</front>
<front id="Marlin_mainCPP-6646">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-6647"></front>
<front id="Marlin_mainCPP-6648">  #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-6649">    prevent_dangerous_extrude(current_position[E_AXIS], destination[E_AXIS]);</front>
<front id="Marlin_mainCPP-6650">  #endif</front>
<front id="Marlin_mainCPP-6651"></front>
<front id="Marlin_mainCPP-6652">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6653">    if (!prepare_move_scara(destination)) return;</front>
<front id="Marlin_mainCPP-6654">  #elif ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-6655">    if (!prepare_move_delta(destination)) return;</front>
<front id="Marlin_mainCPP-6656">  #endif</front>
<front id="Marlin_mainCPP-6657"></front>
<front id="Marlin_mainCPP-6658">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-6659">    if (!prepare_move_dual_x_carriage()) return;</front>
<front id="Marlin_mainCPP-6660">  #endif</front>
<front id="Marlin_mainCPP-6661"></front>
<front id="Marlin_mainCPP-6662">  #if DISABLED(DELTA) && DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-6663">    if (!prepare_move_cartesian()) return;</front>
<front id="Marlin_mainCPP-6664">  #endif</front>
<front id="Marlin_mainCPP-6665"></front>
<front id="Marlin_mainCPP-6666">  set_current_to_destination();</front>
<front id="Marlin_mainCPP-6667">}</front>
<front id="Marlin_mainCPP-6668"></front>
<front id="Marlin_mainCPP-6669">/**</front>
<front id="Marlin_mainCPP-6670"> * Plan an arc in 2 dimensions</front>
<front id="Marlin_mainCPP-6671"> *</front>
<front id="Marlin_mainCPP-6672"> * The arc is approximated by generating many small linear segments.</front>
<front id="Marlin_mainCPP-6673"> * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)</front>
<front id="Marlin_mainCPP-6674"> * Arcs should only be made relatively large (over 5mm), as larger arcs with</front>
<front id="Marlin_mainCPP-6675"> * larger segments will tend to be more efficient. Your slicer should have</front>
<front id="Marlin_mainCPP-6676"> * options for G2/G3 arc generation. In future these options may be GCode tunable.</front>
<front id="Marlin_mainCPP-6677"> */</front>
<front id="Marlin_mainCPP-6678">void plan_arc(</front>
<front id="Marlin_mainCPP-6679">  float target[NUM_AXIS], // Destination position</front>
<front id="Marlin_mainCPP-6680">  float *offset,          // Center of rotation relative to current_position</front>
<front id="Marlin_mainCPP-6681">  uint8_t clockwise       // Clockwise?</front>
<front id="Marlin_mainCPP-6682">) {</front>
<front id="Marlin_mainCPP-6683"></front>
<front id="Marlin_mainCPP-6684">  float radius = hypot(offset[X_AXIS], offset[Y_AXIS]),</front>
<front id="Marlin_mainCPP-6685">        center_axis0 = current_position[X_AXIS] + offset[X_AXIS],</front>
<front id="Marlin_mainCPP-6686">        center_axis1 = current_position[Y_AXIS] + offset[Y_AXIS],</front>
<front id="Marlin_mainCPP-6687">        linear_travel = target[Z_AXIS] - current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-6688">        extruder_travel = target[E_AXIS] - current_position[E_AXIS],</front>
<front id="Marlin_mainCPP-6689">        r_axis0 = -offset[X_AXIS],  // Radius vector from center to current location</front>
<front id="Marlin_mainCPP-6690">        r_axis1 = -offset[Y_AXIS],</front>
<front id="Marlin_mainCPP-6691">        rt_axis0 = target[X_AXIS] - center_axis0,</front>
<front id="Marlin_mainCPP-6692">        rt_axis1 = target[Y_AXIS] - center_axis1;</front>
<front id="Marlin_mainCPP-6693"></front>
<front id="Marlin_mainCPP-6694">  // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.</front>
<front id="Marlin_mainCPP-6695">  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);</front>
<front id="Marlin_mainCPP-6696">  if (angular_travel &lt; 0) { angular_travel += RADIANS(360); }</front>
<front id="Marlin_mainCPP-6697">  if (clockwise) { angular_travel -= RADIANS(360); }</front>
<front id="Marlin_mainCPP-6698"></front>
<front id="Marlin_mainCPP-6699">  // Make a circle if the angular rotation is 0</front>
<front id="Marlin_mainCPP-6700">  if (current_position[X_AXIS] == target[X_AXIS] && current_position[Y_AXIS] == target[Y_AXIS] && angular_travel == 0)</front>
<front id="Marlin_mainCPP-6701">    angular_travel += RADIANS(360);</front>
<front id="Marlin_mainCPP-6702"></front>
<front id="Marlin_mainCPP-6703">  float mm_of_travel = hypot(angular_travel*radius, fabs(linear_travel));</front>
<front id="Marlin_mainCPP-6704">  if (mm_of_travel &lt; 0.001) { return; }</front>
<front id="Marlin_mainCPP-6705">  uint16_t segments = floor(mm_of_travel / MM_PER_ARC_SEGMENT);</front>
<front id="Marlin_mainCPP-6706">  if (segments == 0) segments = 1;</front>
<front id="Marlin_mainCPP-6707"></front>
<front id="Marlin_mainCPP-6708">  float theta_per_segment = angular_travel/segments;</front>
<front id="Marlin_mainCPP-6709">  float linear_per_segment = linear_travel/segments;</front>
<front id="Marlin_mainCPP-6710">  float extruder_per_segment = extruder_travel/segments;</front>
<front id="Marlin_mainCPP-6711"></front>
<front id="Marlin_mainCPP-6712">  /* Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,</front>
<front id="Marlin_mainCPP-6713">     and phi is the angle of rotation. Based on the solution approach by Jens Geisler.</front>
<front id="Marlin_mainCPP-6714">         r_T = [cos(phi) -sin(phi);</front>
<front id="Marlin_mainCPP-6715">                sin(phi)  cos(phi] * r ;</front>
<front id="Marlin_mainCPP-6716"></front>
<front id="Marlin_mainCPP-6717">     For arc generation, the center of the circle is the axis of rotation and the radius vector is</front>
<front id="Marlin_mainCPP-6718">     defined from the circle center to the initial position. Each line segment is formed by successive</front>
<front id="Marlin_mainCPP-6719">     vector rotations. This requires only two cos() and sin() computations to form the rotation</front>
<front id="Marlin_mainCPP-6720">     matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since</front>
<front id="Marlin_mainCPP-6721">     all double numbers are single precision on the Arduino. (True double precision will not have</front>
<front id="Marlin_mainCPP-6722">     round off issues for CNC applications.) Single precision error can accumulate to be greater than</front>
<front id="Marlin_mainCPP-6723">     tool precision in some cases. Therefore, arc path correction is implemented.</front>
<front id="Marlin_mainCPP-6724"></front>
<front id="Marlin_mainCPP-6725">     Small angle approximation may be used to reduce computation overhead further. This approximation</front>
<front id="Marlin_mainCPP-6726">     holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,</front>
<front id="Marlin_mainCPP-6727">     theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large</front>
<front id="Marlin_mainCPP-6728">     to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for</front>
<front id="Marlin_mainCPP-6729">     numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an</front>
<front id="Marlin_mainCPP-6730">     issue for CNC machines with the single precision Arduino calculations.</front>
<front id="Marlin_mainCPP-6731"></front>
<front id="Marlin_mainCPP-6732">     This approximation also allows plan_arc to immediately insert a line segment into the planner</front>
<front id="Marlin_mainCPP-6733">     without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied</front>
<front id="Marlin_mainCPP-6734">     a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.</front>
<front id="Marlin_mainCPP-6735">     This is important when there are successive arc motions.</front>
<front id="Marlin_mainCPP-6736">  */</front>
<front id="Marlin_mainCPP-6737">  // Vector rotation matrix values</front>
<front id="Marlin_mainCPP-6738">  float cos_T = 1-0.5*theta_per_segment*theta_per_segment; // Small angle approximation</front>
<front id="Marlin_mainCPP-6739">  float sin_T = theta_per_segment;</front>
<front id="Marlin_mainCPP-6740"></front>
<front id="Marlin_mainCPP-6741">  float arc_target[NUM_AXIS];</front>
<front id="Marlin_mainCPP-6742">  float sin_Ti;</front>
<front id="Marlin_mainCPP-6743">  float cos_Ti;</front>
<front id="Marlin_mainCPP-6744">  float r_axisi;</front>
<front id="Marlin_mainCPP-6745">  uint16_t i;</front>
<front id="Marlin_mainCPP-6746">  int8_t count = 0;</front>
<front id="Marlin_mainCPP-6747"></front>
<front id="Marlin_mainCPP-6748">  // Initialize the linear axis</front>
<front id="Marlin_mainCPP-6749">  arc_target[Z_AXIS] = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-6750"></front>
<front id="Marlin_mainCPP-6751">  // Initialize the extruder axis</front>
<front id="Marlin_mainCPP-6752">  arc_target[E_AXIS] = current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-6753"></front>
<front id="Marlin_mainCPP-6754">  float feed_rate = feedrate*feedrate_multiplier/60/100.0;</front>
<front id="Marlin_mainCPP-6755"></front>
<front id="Marlin_mainCPP-6756">  for (i = 1; i &lt; segments; i++) { // Increment (segments-1)</front>
<front id="Marlin_mainCPP-6757"></front>
<front id="Marlin_mainCPP-6758">    if (count &lt; N_ARC_CORRECTION) {</front>
<front id="Marlin_mainCPP-6759">      // Apply vector rotation matrix to previous r_axis0 / 1</front>
<front id="Marlin_mainCPP-6760">      r_axisi = r_axis0*sin_T + r_axis1*cos_T;</front>
<front id="Marlin_mainCPP-6761">      r_axis0 = r_axis0*cos_T - r_axis1*sin_T;</front>
<front id="Marlin_mainCPP-6762">      r_axis1 = r_axisi;</front>
<front id="Marlin_mainCPP-6763">      count++;</front>
<front id="Marlin_mainCPP-6764">    }</front>
<front id="Marlin_mainCPP-6765">    else {</front>
<front id="Marlin_mainCPP-6766">      // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.</front>
<front id="Marlin_mainCPP-6767">      // Compute exact location by applying transformation matrix from initial radius vector(=-offset).</front>
<front id="Marlin_mainCPP-6768">      cos_Ti = cos(i*theta_per_segment);</front>
<front id="Marlin_mainCPP-6769">      sin_Ti = sin(i*theta_per_segment);</front>
<front id="Marlin_mainCPP-6770">      r_axis0 = -offset[X_AXIS]*cos_Ti + offset[Y_AXIS]*sin_Ti;</front>
<front id="Marlin_mainCPP-6771">      r_axis1 = -offset[X_AXIS]*sin_Ti - offset[Y_AXIS]*cos_Ti;</front>
<front id="Marlin_mainCPP-6772">      count = 0;</front>
<front id="Marlin_mainCPP-6773">    }</front>
<front id="Marlin_mainCPP-6774"></front>
<front id="Marlin_mainCPP-6775">    // Update arc_target location</front>
<front id="Marlin_mainCPP-6776">    arc_target[X_AXIS] = center_axis0 + r_axis0;</front>
<front id="Marlin_mainCPP-6777">    arc_target[Y_AXIS] = center_axis1 + r_axis1;</front>
<front id="Marlin_mainCPP-6778">    arc_target[Z_AXIS] += linear_per_segment;</front>
<front id="Marlin_mainCPP-6779">    arc_target[E_AXIS] += extruder_per_segment;</front>
<front id="Marlin_mainCPP-6780"></front>
<front id="Marlin_mainCPP-6781">    clamp_to_software_endstops(arc_target);</front>
<front id="Marlin_mainCPP-6782"></front>
<front id="Marlin_mainCPP-6783">    #if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6784">      calculate_delta(arc_target);</front>
<front id="Marlin_mainCPP-6785">      #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6786">        adjust_delta(arc_target);</front>
<front id="Marlin_mainCPP-6787">      #endif</front>
<front id="Marlin_mainCPP-6788">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], arc_target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6789">    #else</front>
<front id="Marlin_mainCPP-6790">      plan_buffer_line(arc_target[X_AXIS], arc_target[Y_AXIS], arc_target[Z_AXIS], arc_target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6791">    #endif</front>
<front id="Marlin_mainCPP-6792">  }</front>
<front id="Marlin_mainCPP-6793"></front>
<front id="Marlin_mainCPP-6794">  // Ensure last segment arrives at target location.</front>
<front id="Marlin_mainCPP-6795">  #if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6796">    calculate_delta(target);</front>
<front id="Marlin_mainCPP-6797">    #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6798">      adjust_delta(target);</front>
<front id="Marlin_mainCPP-6799">    #endif</front>
<front id="Marlin_mainCPP-6800">    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6801">  #else</front>
<front id="Marlin_mainCPP-6802">    plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6803">  #endif</front>
<front id="Marlin_mainCPP-6804"></front>
<front id="Marlin_mainCPP-6805">  // As far as the parser is concerned, the position is now == target. In reality the</front>
<front id="Marlin_mainCPP-6806">  // motion control system might still be processing the action and the real tool position</front>
<front id="Marlin_mainCPP-6807">  // in any intermediate location.</front>
<front id="Marlin_mainCPP-6808">  set_current_to_destination();</front>
<front id="Marlin_mainCPP-6809">}</front>
<front id="Marlin_mainCPP-6810"></front>
<front id="Marlin_mainCPP-6811">#if HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-6812"></front>
<front id="Marlin_mainCPP-6813">  void controllerFan() {</front>
<front id="Marlin_mainCPP-6814">    static millis_t lastMotor = 0;      // Last time a motor was turned on</front>
<front id="Marlin_mainCPP-6815">    static millis_t lastMotorCheck = 0; // Last time the state was checked</front>
<front id="Marlin_mainCPP-6816">    millis_t ms = millis();</front>
<front id="Marlin_mainCPP-6817">    if (ms &gt;= lastMotorCheck + 2500) { // Not a time critical function, so we only check every 2500ms</front>
<front id="Marlin_mainCPP-6818">      lastMotorCheck = ms;</front>
<front id="Marlin_mainCPP-6819">      if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || soft_pwm_bed &gt; 0</front>
<front id="Marlin_mainCPP-6820">        || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...</front>
<front id="Marlin_mainCPP-6821">        #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-6822">          || E1_ENABLE_READ == E_ENABLE_ON</front>
<front id="Marlin_mainCPP-6823">          #if HAS_X2_ENABLE</front>
<front id="Marlin_mainCPP-6824">            || X2_ENABLE_READ == X_ENABLE_ON</front>
<front id="Marlin_mainCPP-6825">          #endif</front>
<front id="Marlin_mainCPP-6826">          #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-6827">            || E2_ENABLE_READ == E_ENABLE_ON</front>
<front id="Marlin_mainCPP-6828">            #if EXTRUDERS &gt; 3</front>
<front id="Marlin_mainCPP-6829">              || E3_ENABLE_READ == E_ENABLE_ON</front>
<front id="Marlin_mainCPP-6830">            #endif</front>
<front id="Marlin_mainCPP-6831">          #endif</front>
<front id="Marlin_mainCPP-6832">        #endif</front>
<front id="Marlin_mainCPP-6833">      ) {</front>
<front id="Marlin_mainCPP-6834">        lastMotor = ms; //... set time to NOW so the fan will turn on</front>
<front id="Marlin_mainCPP-6835">      }</front>
<front id="Marlin_mainCPP-6836">      uint8_t speed = (lastMotor == 0 || ms &gt;= lastMotor + (CONTROLLERFAN_SECS * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;</front>
<front id="Marlin_mainCPP-6837">      // allows digital or PWM fan output to be used (see M42 handling)</front>
<front id="Marlin_mainCPP-6838">      digitalWrite(CONTROLLERFAN_PIN, speed);</front>
<front id="Marlin_mainCPP-6839">      analogWrite(CONTROLLERFAN_PIN, speed);</front>
<front id="Marlin_mainCPP-6840">    }</front>
<front id="Marlin_mainCPP-6841">  }</front>
<front id="Marlin_mainCPP-6842"></front>
<front id="Marlin_mainCPP-6843">#endif // HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-6844"></front>
<front id="Marlin_mainCPP-6845">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6846"></front>
<front id="Marlin_mainCPP-6847">  void calculate_SCARA_forward_Transform(float f_scara[3]) {</front>
<front id="Marlin_mainCPP-6848">    // Perform forward kinematics, and place results in delta[3]</front>
<front id="Marlin_mainCPP-6849">    // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014</front>
<front id="Marlin_mainCPP-6850"></front>
<front id="Marlin_mainCPP-6851">    float x_sin, x_cos, y_sin, y_cos;</front>
<front id="Marlin_mainCPP-6852"></front>
<front id="Marlin_mainCPP-6853">    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);</front>
<front id="Marlin_mainCPP-6854">    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6855"></front>
<front id="Marlin_mainCPP-6856">    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;</front>
<front id="Marlin_mainCPP-6857">    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;</front>
<front id="Marlin_mainCPP-6858">    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;</front>
<front id="Marlin_mainCPP-6859">    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;</front>
<front id="Marlin_mainCPP-6860"></front>
<front id="Marlin_mainCPP-6861">    //SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);</front>
<front id="Marlin_mainCPP-6862">    //SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);</front>
<front id="Marlin_mainCPP-6863">    //SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);</front>
<front id="Marlin_mainCPP-6864">    //SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);</front>
<front id="Marlin_mainCPP-6865"></front>
<front id="Marlin_mainCPP-6866">    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta</front>
<front id="Marlin_mainCPP-6867">    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi</front>
<front id="Marlin_mainCPP-6868"></front>
<front id="Marlin_mainCPP-6869">    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-6870">    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6871">  }</front>
<front id="Marlin_mainCPP-6872"></front>
<front id="Marlin_mainCPP-6873">  void calculate_delta(float cartesian[3]){</front>
<front id="Marlin_mainCPP-6874">    //reverse kinematics.</front>
<front id="Marlin_mainCPP-6875">    // Perform reversed kinematics, and place results in delta[3]</front>
<front id="Marlin_mainCPP-6876">    // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014</front>
<front id="Marlin_mainCPP-6877"></front>
<front id="Marlin_mainCPP-6878">    float SCARA_pos[2];</front>
<front id="Marlin_mainCPP-6879">    static float SCARA_C2, SCARA_S2, SCARA_K1, SCARA_K2, SCARA_theta, SCARA_psi;</front>
<front id="Marlin_mainCPP-6880"></front>
<front id="Marlin_mainCPP-6881">    SCARA_pos[X_AXIS] = cartesian[X_AXIS] * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y</front>
<front id="Marlin_mainCPP-6882">    SCARA_pos[Y_AXIS] = cartesian[Y_AXIS] * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.</front>
<front id="Marlin_mainCPP-6883"></front>
<front id="Marlin_mainCPP-6884">    #if (Linkage_1 == Linkage_2)</front>
<front id="Marlin_mainCPP-6885">      SCARA_C2 = ( ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) ) / (2 * (float)L1_2) ) - 1;</front>
<front id="Marlin_mainCPP-6886">    #else</front>
<front id="Marlin_mainCPP-6887">      SCARA_C2 =   ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) - (float)L1_2 - (float)L2_2 ) / 45000;</front>
<front id="Marlin_mainCPP-6888">    #endif</front>
<front id="Marlin_mainCPP-6889"></front>
<front id="Marlin_mainCPP-6890">    SCARA_S2 = sqrt( 1 - sq(SCARA_C2) );</front>
<front id="Marlin_mainCPP-6891"></front>
<front id="Marlin_mainCPP-6892">    SCARA_K1 = Linkage_1 + Linkage_2 * SCARA_C2;</front>
<front id="Marlin_mainCPP-6893">    SCARA_K2 = Linkage_2 * SCARA_S2;</front>
<front id="Marlin_mainCPP-6894"></front>
<front id="Marlin_mainCPP-6895">    SCARA_theta = ( atan2(SCARA_pos[X_AXIS],SCARA_pos[Y_AXIS])-atan2(SCARA_K1, SCARA_K2) ) * -1;</front>
<front id="Marlin_mainCPP-6896">    SCARA_psi   =   atan2(SCARA_S2,SCARA_C2);</front>
<front id="Marlin_mainCPP-6897"></front>
<front id="Marlin_mainCPP-6898">    delta[X_AXIS] = SCARA_theta * SCARA_RAD2DEG;  // Multiply by 180/Pi  -  theta is support arm angle</front>
<front id="Marlin_mainCPP-6899">    delta[Y_AXIS] = (SCARA_theta + SCARA_psi) * SCARA_RAD2DEG;  //       -  equal to sub arm angle (inverted motor)</front>
<front id="Marlin_mainCPP-6900">    delta[Z_AXIS] = cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6901"></front>
<front id="Marlin_mainCPP-6902">    /*</front>
<front id="Marlin_mainCPP-6903">    SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);</front>
<front id="Marlin_mainCPP-6904">    SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6905">    SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6906"></front>
<front id="Marlin_mainCPP-6907">    SERIAL_ECHOPGM("scara x="); SERIAL_ECHO(SCARA_pos[X_AXIS]);</front>
<front id="Marlin_mainCPP-6908">    SERIAL_ECHOPGM(" y="); SERIAL_ECHOLN(SCARA_pos[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6909"></front>
<front id="Marlin_mainCPP-6910">    SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-6911">    SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6912">    SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6913"></front>
<front id="Marlin_mainCPP-6914">    SERIAL_ECHOPGM("C2="); SERIAL_ECHO(SCARA_C2);</front>
<front id="Marlin_mainCPP-6915">    SERIAL_ECHOPGM(" S2="); SERIAL_ECHO(SCARA_S2);</front>
<front id="Marlin_mainCPP-6916">    SERIAL_ECHOPGM(" Theta="); SERIAL_ECHO(SCARA_theta);</front>
<front id="Marlin_mainCPP-6917">    SERIAL_ECHOPGM(" Psi="); SERIAL_ECHOLN(SCARA_psi);</front>
<front id="Marlin_mainCPP-6918">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-6919">    */</front>
<front id="Marlin_mainCPP-6920">  }</front>
<front id="Marlin_mainCPP-6921"></front>
<front id="Marlin_mainCPP-6922">#endif // SCARA</front>
<front id="Marlin_mainCPP-6923"></front>
<front id="Marlin_mainCPP-6924">#if ENABLED(TEMP_STAT_LEDS)</front>
<front id="Marlin_mainCPP-6925"></front>
<front id="Marlin_mainCPP-6926">  static bool red_led = false;</front>
<front id="Marlin_mainCPP-6927">  static millis_t next_status_led_update_ms = 0;</front>
<front id="Marlin_mainCPP-6928"></front>
<front id="Marlin_mainCPP-6929">  void handle_status_leds(void) {</front>
<front id="Marlin_mainCPP-6930">    float max_temp = 0.0;</front>
<front id="Marlin_mainCPP-6931">    if (millis() &gt; next_status_led_update_ms) {</front>
<front id="Marlin_mainCPP-6932">      next_status_led_update_ms += 500; // Update every 0.5s</front>
<front id="Marlin_mainCPP-6933">      for (int8_t cur_extruder = 0; cur_extruder &lt; EXTRUDERS; ++cur_extruder)</front>
<front id="Marlin_mainCPP-6934">         max_temp = max(max(max_temp, degHotend(cur_extruder)), degTargetHotend(cur_extruder));</front>
<front id="Marlin_mainCPP-6935">      #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-6936">        max_temp = max(max(max_temp, degTargetBed()), degBed());</front>
<front id="Marlin_mainCPP-6937">      #endif</front>
<front id="Marlin_mainCPP-6938">      bool new_led = (max_temp &gt; 55.0) ? true : (max_temp &lt; 54.0) ? false : red_led;</front>
<front id="Marlin_mainCPP-6939">      if (new_led != red_led) {</front>
<front id="Marlin_mainCPP-6940">        red_led = new_led;</front>
<front id="Marlin_mainCPP-6941">        digitalWrite(STAT_LED_RED, new_led ? HIGH : LOW);</front>
<front id="Marlin_mainCPP-6942">        digitalWrite(STAT_LED_BLUE, new_led ? LOW : HIGH);</front>
<front id="Marlin_mainCPP-6943">      }</front>
<front id="Marlin_mainCPP-6944">    }</front>
<front id="Marlin_mainCPP-6945">  }</front>
<front id="Marlin_mainCPP-6946"></front>
<front id="Marlin_mainCPP-6947">#endif</front>
<front id="Marlin_mainCPP-6948"></front>
<front id="Marlin_mainCPP-6949">void enable_all_steppers() {</front>
<front id="Marlin_mainCPP-6950">  enable_x();</front>
<front id="Marlin_mainCPP-6951">  enable_y();</front>
<front id="Marlin_mainCPP-6952">  enable_z();</front>
<front id="Marlin_mainCPP-6953">  enable_e0();</front>
<front id="Marlin_mainCPP-6954">  enable_e1();</front>
<front id="Marlin_mainCPP-6955">  enable_e2();</front>
<front id="Marlin_mainCPP-6956">  enable_e3();</front>
<front id="Marlin_mainCPP-6957">}</front>
<front id="Marlin_mainCPP-6958"></front>
<front id="Marlin_mainCPP-6959">void disable_all_steppers() {</front>
<front id="Marlin_mainCPP-6960">  disable_x();</front>
<front id="Marlin_mainCPP-6961">  disable_y();</front>
<front id="Marlin_mainCPP-6962">  disable_z();</front>
<front id="Marlin_mainCPP-6963">  disable_e0();</front>
<front id="Marlin_mainCPP-6964">  disable_e1();</front>
<front id="Marlin_mainCPP-6965">  disable_e2();</front>
<front id="Marlin_mainCPP-6966">  disable_e3();</front>
<front id="Marlin_mainCPP-6967">}</front>
<front id="Marlin_mainCPP-6968"></front>
<front id="Marlin_mainCPP-6969">/**</front>
<front id="Marlin_mainCPP-6970"> * Standard idle routine keeps the machine alive</front>
<front id="Marlin_mainCPP-6971"> */</front>
<front id="Marlin_mainCPP-6972">void idle() {</front>
<front id="Marlin_mainCPP-6973">  manage_heater();</front>
<front id="Marlin_mainCPP-6974">  manage_inactivity();</front>
<front id="Marlin_mainCPP-6975">  lcd_update();</front>
<front id="Marlin_mainCPP-6976">}</front>
<front id="Marlin_mainCPP-6977"></front>
<front id="Marlin_mainCPP-6978">/**</front>
<front id="Marlin_mainCPP-6979"> * Manage several activities:</front>
<front id="Marlin_mainCPP-6980"> *  - Check for Filament Runout</front>
<front id="Marlin_mainCPP-6981"> *  - Keep the command buffer full</front>
<front id="Marlin_mainCPP-6982"> *  - Check for maximum inactive time between commands</front>
<front id="Marlin_mainCPP-6983"> *  - Check for maximum inactive time between stepper commands</front>
<front id="Marlin_mainCPP-6984"> *  - Check if pin CHDK needs to go LOW</front>
<front id="Marlin_mainCPP-6985"> *  - Check for KILL button held down</front>
<front id="Marlin_mainCPP-6986"> *  - Check for HOME button held down</front>
<front id="Marlin_mainCPP-6987"> *  - Check if cooling fan needs to be switched on</front>
<front id="Marlin_mainCPP-6988"> *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)</front>
<front id="Marlin_mainCPP-6989"> */</front>
<front id="Marlin_mainCPP-6990">void manage_inactivity(bool ignore_stepper_queue/*=false*/) {</front>
<front id="Marlin_mainCPP-6991"></front>
<front id="Marlin_mainCPP-6992">  #if HAS_FILRUNOUT</front>
<front id="Marlin_mainCPP-6993">    if (IS_SD_PRINTING && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING))</front>
<front id="Marlin_mainCPP-6994">      filrunout();</front>
<front id="Marlin_mainCPP-6995">  #endif</front>
<front id="Marlin_mainCPP-6996"></front>
<front id="Marlin_mainCPP-6997">  if (commands_in_queue &lt; BUFSIZE - 1) get_command();</front>
<front id="Marlin_mainCPP-6998"></front>
<front id="Marlin_mainCPP-6999">  millis_t ms = millis();</front>
<front id="Marlin_mainCPP-7000"></front>
<front id="Marlin_mainCPP-7001">  if (max_inactive_time && ms &gt; previous_cmd_ms + max_inactive_time) kill(PSTR(MSG_KILLED));</front>
<front id="Marlin_mainCPP-7002"></front>
<front id="Marlin_mainCPP-7003">  if (stepper_inactive_time && ms &gt; previous_cmd_ms + stepper_inactive_time</front>
<front id="Marlin_mainCPP-7004">      && !ignore_stepper_queue && !blocks_queued()) {</front>
<front id="Marlin_mainCPP-7005">    #if DISABLE_X == true</front>
<front id="Marlin_mainCPP-7006">      disable_x();</front>
<front id="Marlin_mainCPP-7007">    #endif</front>
<front id="Marlin_mainCPP-7008">    #if DISABLE_Y == true</front>
<front id="Marlin_mainCPP-7009">      disable_y();</front>
<front id="Marlin_mainCPP-7010">    #endif</front>
<front id="Marlin_mainCPP-7011">    #if DISABLE_Z == true</front>
<front id="Marlin_mainCPP-7012">      disable_z();</front>
<front id="Marlin_mainCPP-7013">    #endif</front>
<front id="Marlin_mainCPP-7014">    #if DISABLE_E == true</front>
<front id="Marlin_mainCPP-7015">      disable_e0();</front>
<front id="Marlin_mainCPP-7016">      disable_e1();</front>
<front id="Marlin_mainCPP-7017">      disable_e2();</front>
<front id="Marlin_mainCPP-7018">      disable_e3();</front>
<front id="Marlin_mainCPP-7019">    #endif</front>
<front id="Marlin_mainCPP-7020">  }</front>
<front id="Marlin_mainCPP-7021"></front>
<front id="Marlin_mainCPP-7022">  #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH</front>
<front id="Marlin_mainCPP-7023">    if (chdkActive && ms &gt; chdkHigh + CHDK_DELAY) {</front>
<front id="Marlin_mainCPP-7024">      chdkActive = false;</front>
<front id="Marlin_mainCPP-7025">      WRITE(CHDK, LOW);</front>
<front id="Marlin_mainCPP-7026">    }</front>
<front id="Marlin_mainCPP-7027">  #endif</front>
<front id="Marlin_mainCPP-7028"></front>
<front id="Marlin_mainCPP-7029">  #if HAS_KILL</front>
<front id="Marlin_mainCPP-7030"></front>
<front id="Marlin_mainCPP-7031">    // Check if the kill button was pressed and wait just in case it was an accidental</front>
<front id="Marlin_mainCPP-7032">    // key kill key press</front>
<front id="Marlin_mainCPP-7033">    // -------------------------------------------------------------------------------</front>
<front id="Marlin_mainCPP-7034">    static int killCount = 0;   // make the inactivity button a bit less responsive</front>
<front id="Marlin_mainCPP-7035">    const int KILL_DELAY = 750;</front>
<front id="Marlin_mainCPP-7036">    if (!READ(KILL_PIN))</front>
<front id="Marlin_mainCPP-7037">       killCount++;</front>
<front id="Marlin_mainCPP-7038">    else if (killCount &gt; 0)</front>
<front id="Marlin_mainCPP-7039">       killCount--;</front>
<front id="Marlin_mainCPP-7040"></front>
<front id="Marlin_mainCPP-7041">    // Exceeded threshold and we can confirm that it was not accidental</front>
<front id="Marlin_mainCPP-7042">    // KILL the machine</front>
<front id="Marlin_mainCPP-7043">    // ----------------------------------------------------------------</front>
<front id="Marlin_mainCPP-7044">    if (killCount &gt;= KILL_DELAY) kill(PSTR(MSG_KILLED));</front>
<front id="Marlin_mainCPP-7045">  #endif</front>
<front id="Marlin_mainCPP-7046"></front>
<front id="Marlin_mainCPP-7047">  #if HAS_HOME</front>
<front id="Marlin_mainCPP-7048">    // Check to see if we have to home, use poor man's debouncer</front>
<front id="Marlin_mainCPP-7049">    // ---------------------------------------------------------</front>
<front id="Marlin_mainCPP-7050">    static int homeDebounceCount = 0;   // poor man's debouncing count</front>
<front id="Marlin_mainCPP-7051">    const int HOME_DEBOUNCE_DELAY = 2500;</front>
<front id="Marlin_mainCPP-7052">    if (!READ(HOME_PIN)) {</front>
<front id="Marlin_mainCPP-7053">      if (!homeDebounceCount) {</front>
<front id="Marlin_mainCPP-7054">        enqueuecommands_P(PSTR("G28"));</front>
<front id="Marlin_mainCPP-7055">        LCD_MESSAGEPGM(MSG_AUTO_HOME);</front>
<front id="Marlin_mainCPP-7056">      }</front>
<front id="Marlin_mainCPP-7057">      if (homeDebounceCount &lt; HOME_DEBOUNCE_DELAY)</front>
<front id="Marlin_mainCPP-7058">        homeDebounceCount++;</front>
<front id="Marlin_mainCPP-7059">      else</front>
<front id="Marlin_mainCPP-7060">        homeDebounceCount = 0;</front>
<front id="Marlin_mainCPP-7061">    }</front>
<front id="Marlin_mainCPP-7062">  #endif</front>
<front id="Marlin_mainCPP-7063"></front>
<front id="Marlin_mainCPP-7064">  #if HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-7065">    controllerFan(); // Check if fan should be turned on to cool stepper drivers down</front>
<front id="Marlin_mainCPP-7066">  #endif</front>
<front id="Marlin_mainCPP-7067"></front>
<front id="Marlin_mainCPP-7068">  #if ENABLED(EXTRUDER_RUNOUT_PREVENT)</front>
<front id="Marlin_mainCPP-7069">    if (ms &gt; previous_cmd_ms + EXTRUDER_RUNOUT_SECONDS * 1000)</front>
<front id="Marlin_mainCPP-7070">    if (degHotend(active_extruder) &gt; EXTRUDER_RUNOUT_MINTEMP) {</front>
<front id="Marlin_mainCPP-7071">      bool oldstatus;</front>
<front id="Marlin_mainCPP-7072">      switch(active_extruder) {</front>
<front id="Marlin_mainCPP-7073">        case 0:</front>
<front id="Marlin_mainCPP-7074">          oldstatus = E0_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7075">          enable_e0();</front>
<front id="Marlin_mainCPP-7076">          break;</front>
<front id="Marlin_mainCPP-7077">        #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-7078">          case 1:</front>
<front id="Marlin_mainCPP-7079">            oldstatus = E1_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7080">            enable_e1();</front>
<front id="Marlin_mainCPP-7081">            break;</front>
<front id="Marlin_mainCPP-7082">          #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-7083">            case 2:</front>
<front id="Marlin_mainCPP-7084">              oldstatus = E2_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7085">              enable_e2();</front>
<front id="Marlin_mainCPP-7086">              break;</front>
<front id="Marlin_mainCPP-7087">            #if EXTRUDERS &gt; 3</front>
<front id="Marlin_mainCPP-7088">              case 3:</front>
<front id="Marlin_mainCPP-7089">                oldstatus = E3_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7090">                enable_e3();</front>
<front id="Marlin_mainCPP-7091">                break;</front>
<front id="Marlin_mainCPP-7092">            #endif</front>
<front id="Marlin_mainCPP-7093">          #endif</front>
<front id="Marlin_mainCPP-7094">        #endif</front>
<front id="Marlin_mainCPP-7095">      }</front>
<front id="Marlin_mainCPP-7096">      float oldepos = current_position[E_AXIS], oldedes = destination[E_AXIS];</front>
<front id="Marlin_mainCPP-7097">      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],</front>
<front id="Marlin_mainCPP-7098">                      destination[E_AXIS] + EXTRUDER_RUNOUT_EXTRUDE * EXTRUDER_RUNOUT_ESTEPS / axis_steps_per_unit[E_AXIS],</front>
<front id="Marlin_mainCPP-7099">                      EXTRUDER_RUNOUT_SPEED / 60. * EXTRUDER_RUNOUT_ESTEPS / axis_steps_per_unit[E_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-7100">      current_position[E_AXIS] = oldepos;</front>
<front id="Marlin_mainCPP-7101">      destination[E_AXIS] = oldedes;</front>
<front id="Marlin_mainCPP-7102">      plan_set_e_position(oldepos);</front>
<front id="Marlin_mainCPP-7103">      previous_cmd_ms = ms; // refresh_cmd_timeout()</front>
<front id="Marlin_mainCPP-7104">      st_synchronize();</front>
<front id="Marlin_mainCPP-7105">      switch(active_extruder) {</front>
<front id="Marlin_mainCPP-7106">        case 0:</front>
<front id="Marlin_mainCPP-7107">          E0_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7108">          break;</front>
<front id="Marlin_mainCPP-7109">        #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-7110">          case 1:</front>
<front id="Marlin_mainCPP-7111">            E1_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7112">            break;</front>
<front id="Marlin_mainCPP-7113">          #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-7114">            case 2:</front>
<front id="Marlin_mainCPP-7115">              E2_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7116">              break;</front>
<front id="Marlin_mainCPP-7117">            #if EXTRUDERS &gt; 3</front>
<front id="Marlin_mainCPP-7118">              case 3:</front>
<front id="Marlin_mainCPP-7119">                E3_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7120">                break;</front>
<front id="Marlin_mainCPP-7121">            #endif</front>
<front id="Marlin_mainCPP-7122">          #endif</front>
<front id="Marlin_mainCPP-7123">        #endif</front>
<front id="Marlin_mainCPP-7124">      }</front>
<front id="Marlin_mainCPP-7125">    }</front>
<front id="Marlin_mainCPP-7126">  #endif</front>
<front id="Marlin_mainCPP-7127"></front>
<front id="Marlin_mainCPP-7128">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-7129">    // handle delayed move timeout</front>
<front id="Marlin_mainCPP-7130">    if (delayed_move_time && ms &gt; delayed_move_time + 1000 && IsRunning()) {</front>
<front id="Marlin_mainCPP-7131">      // travel moves have been received so enact them</front>
<front id="Marlin_mainCPP-7132">      delayed_move_time = 0xFFFFFFFFUL; // force moves to be done</front>
<front id="Marlin_mainCPP-7133">      set_destination_to_current();</front>
<front id="Marlin_mainCPP-7134">      prepare_move();</front>
<front id="Marlin_mainCPP-7135">    }</front>
<front id="Marlin_mainCPP-7136">  #endif</front>
<front id="Marlin_mainCPP-7137"></front>
<front id="Marlin_mainCPP-7138">  #if ENABLED(TEMP_STAT_LEDS)</front>
<front id="Marlin_mainCPP-7139">    handle_status_leds();</front>
<front id="Marlin_mainCPP-7140">  #endif</front>
<front id="Marlin_mainCPP-7141"></front>
<front id="Marlin_mainCPP-7142">  check_axes_activity();</front>
<front id="Marlin_mainCPP-7143">}</front>
<front id="Marlin_mainCPP-7144"></front>
<front id="Marlin_mainCPP-7145">void kill(const char *lcd_msg) {</front>
<front id="Marlin_mainCPP-7146">  #if ENABLED(ULTRA_LCD)</front>
<front id="Marlin_mainCPP-7147">    lcd_setalertstatuspgm(lcd_msg);</front>
<front id="Marlin_mainCPP-7148">  #endif</front>
<front id="Marlin_mainCPP-7149"></front>
<front id="Marlin_mainCPP-7150">  cli(); // Stop interrupts</front>
<front id="Marlin_mainCPP-7151">  disable_all_heaters();</front>
<front id="Marlin_mainCPP-7152">  disable_all_steppers();</front>
<front id="Marlin_mainCPP-7153"></front>
<front id="Marlin_mainCPP-7154">  #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-7155">    pinMode(PS_ON_PIN, INPUT);</front>
<front id="Marlin_mainCPP-7156">  #endif</front>
<front id="Marlin_mainCPP-7157"></front>
<front id="Marlin_mainCPP-7158">  SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-7159">  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);</front>
<front id="Marlin_mainCPP-7160"></front>
<front id="Marlin_mainCPP-7161">  // FMC small patch to update the LCD before ending</front>
<front id="Marlin_mainCPP-7162">  sei();   // enable interrupts</front>
<front id="Marlin_mainCPP-7163">  for (int i = 5; i--; lcd_update()) delay(200); // Wait a short time</front>
<front id="Marlin_mainCPP-7164">  cli();   // disable interrupts</front>
<front id="Marlin_mainCPP-7165">  suicide();</front>
<front id="Marlin_mainCPP-7166">  while(1) { /* Intentionally left empty */ } // Wait for reset</front>
<front id="Marlin_mainCPP-7167">}</front>
<front id="Marlin_mainCPP-7168"></front>
<front id="Marlin_mainCPP-7169">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="Marlin_mainCPP-7170"></front>
<front id="Marlin_mainCPP-7171">  void filrunout() {</front>
<front id="Marlin_mainCPP-7172">    if (!filrunoutEnqueued) {</front>
<front id="Marlin_mainCPP-7173">      filrunoutEnqueued = true;</front>
<front id="Marlin_mainCPP-7174">      enqueuecommands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));</front>
<front id="Marlin_mainCPP-7175">      st_synchronize();</front>
<front id="Marlin_mainCPP-7176">    }</front>
<front id="Marlin_mainCPP-7177">  }</front>
<front id="Marlin_mainCPP-7178"></front>
<front id="Marlin_mainCPP-7179">#endif // FILAMENT_RUNOUT_SENSOR</front>
<front id="Marlin_mainCPP-7180"></front>
<front id="Marlin_mainCPP-7181">#if ENABLED(FAST_PWM_FAN)</front>
<front id="Marlin_mainCPP-7182"></front>
<front id="Marlin_mainCPP-7183">  void setPwmFrequency(uint8_t pin, int val) {</front>
<front id="Marlin_mainCPP-7184">    val &= 0x07;</front>
<front id="Marlin_mainCPP-7185">    switch (digitalPinToTimer(pin)) {</front>
<front id="Marlin_mainCPP-7186"></front>
<front id="Marlin_mainCPP-7187">      #if defined(TCCR0A)</front>
<front id="Marlin_mainCPP-7188">        case TIMER0A:</front>
<front id="Marlin_mainCPP-7189">        case TIMER0B:</front>
<front id="Marlin_mainCPP-7190">             // TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));</front>
<front id="Marlin_mainCPP-7191">             // TCCR0B |= val;</front>
<front id="Marlin_mainCPP-7192">             break;</front>
<front id="Marlin_mainCPP-7193">      #endif</front>
<front id="Marlin_mainCPP-7194"></front>
<front id="Marlin_mainCPP-7195">      #if defined(TCCR1A)</front>
<front id="Marlin_mainCPP-7196">        case TIMER1A:</front>
<front id="Marlin_mainCPP-7197">        case TIMER1B:</front>
<front id="Marlin_mainCPP-7198">             // TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</front>
<front id="Marlin_mainCPP-7199">             // TCCR1B |= val;</front>
<front id="Marlin_mainCPP-7200">             break;</front>
<front id="Marlin_mainCPP-7201">      #endif</front>
<front id="Marlin_mainCPP-7202"></front>
<front id="Marlin_mainCPP-7203">      #if defined(TCCR2)</front>
<front id="Marlin_mainCPP-7204">        case TIMER2:</front>
<front id="Marlin_mainCPP-7205">        case TIMER2:</front>
<front id="Marlin_mainCPP-7206">             TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</front>
<front id="Marlin_mainCPP-7207">             TCCR2 |= val;</front>
<front id="Marlin_mainCPP-7208">             break;</front>
<front id="Marlin_mainCPP-7209">      #endif</front>
<front id="Marlin_mainCPP-7210"></front>
<front id="Marlin_mainCPP-7211">      #if defined(TCCR2A)</front>
<front id="Marlin_mainCPP-7212">        case TIMER2A:</front>
<front id="Marlin_mainCPP-7213">        case TIMER2B:</front>
<front id="Marlin_mainCPP-7214">             TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));</front>
<front id="Marlin_mainCPP-7215">             TCCR2B |= val;</front>
<front id="Marlin_mainCPP-7216">             break;</front>
<front id="Marlin_mainCPP-7217">      #endif</front>
<front id="Marlin_mainCPP-7218"></front>
<front id="Marlin_mainCPP-7219">      #if defined(TCCR3A)</front>
<front id="Marlin_mainCPP-7220">        case TIMER3A:</front>
<front id="Marlin_mainCPP-7221">        case TIMER3B:</front>
<front id="Marlin_mainCPP-7222">        case TIMER3C:</front>
<front id="Marlin_mainCPP-7223">             TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));</front>
<front id="Marlin_mainCPP-7224">             TCCR3B |= val;</front>
<front id="Marlin_mainCPP-7225">             break;</front>
<front id="Marlin_mainCPP-7226">      #endif</front>
<front id="Marlin_mainCPP-7227"></front>
<front id="Marlin_mainCPP-7228">      #if defined(TCCR4A)</front>
<front id="Marlin_mainCPP-7229">        case TIMER4A:</front>
<front id="Marlin_mainCPP-7230">        case TIMER4B:</front>
<front id="Marlin_mainCPP-7231">        case TIMER4C:</front>
<front id="Marlin_mainCPP-7232">             TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));</front>
<front id="Marlin_mainCPP-7233">             TCCR4B |= val;</front>
<front id="Marlin_mainCPP-7234">             break;</front>
<front id="Marlin_mainCPP-7235">      #endif</front>
<front id="Marlin_mainCPP-7236"></front>
<front id="Marlin_mainCPP-7237">      #if defined(TCCR5A)</front>
<front id="Marlin_mainCPP-7238">        case TIMER5A:</front>
<front id="Marlin_mainCPP-7239">        case TIMER5B:</front>
<front id="Marlin_mainCPP-7240">        case TIMER5C:</front>
<front id="Marlin_mainCPP-7241">             TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));</front>
<front id="Marlin_mainCPP-7242">             TCCR5B |= val;</front>
<front id="Marlin_mainCPP-7243">             break;</front>
<front id="Marlin_mainCPP-7244">      #endif</front>
<front id="Marlin_mainCPP-7245"></front>
<front id="Marlin_mainCPP-7246">    }</front>
<front id="Marlin_mainCPP-7247">  }</front>
<front id="Marlin_mainCPP-7248"></front>
<front id="Marlin_mainCPP-7249">#endif // FAST_PWM_FAN</front>
<front id="Marlin_mainCPP-7250"></front>
<front id="Marlin_mainCPP-7251">void Stop() {</front>
<front id="Marlin_mainCPP-7252">  disable_all_heaters();</front>
<front id="Marlin_mainCPP-7253">  if (IsRunning()) {</front>
<front id="Marlin_mainCPP-7254">    Running = false;</front>
<front id="Marlin_mainCPP-7255">    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart</front>
<front id="Marlin_mainCPP-7256">    SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-7257">    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);</front>
<front id="Marlin_mainCPP-7258">    LCD_MESSAGEPGM(MSG_STOPPED);</front>
<front id="Marlin_mainCPP-7259">  }</front>
<front id="Marlin_mainCPP-7260">}</front>
<front id="Marlin_mainCPP-7261"></front>
<front id="Marlin_mainCPP-7262">/**</front>
<front id="Marlin_mainCPP-7263"> * Set target_extruder from the T parameter or the active_extruder</front>
<front id="Marlin_mainCPP-7264"> *</front>
<front id="Marlin_mainCPP-7265"> * Returns TRUE if the target is invalid</front>
<front id="Marlin_mainCPP-7266"> */</front>
<front id="Marlin_mainCPP-7267">bool setTargetedHotend(int code) {</front>
<front id="Marlin_mainCPP-7268">  target_extruder = active_extruder;</front>
<front id="Marlin_mainCPP-7269">  if (code_seen('T')) {</front>
<front id="Marlin_mainCPP-7270">    target_extruder = code_value_short();</front>
<front id="Marlin_mainCPP-7271">    if (target_extruder &gt;= EXTRUDERS) {</front>
<front id="Marlin_mainCPP-7272">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-7273">      SERIAL_CHAR('M');</front>
<front id="Marlin_mainCPP-7274">      SERIAL_ECHO(code);</front>
<front id="Marlin_mainCPP-7275">      SERIAL_ECHOPGM(" " MSG_INVALID_EXTRUDER " ");</front>
<front id="Marlin_mainCPP-7276">      SERIAL_ECHOLN(target_extruder);</front>
<front id="Marlin_mainCPP-7277">      return true;</front>
<front id="Marlin_mainCPP-7278">    }</front>
<front id="Marlin_mainCPP-7279">  }</front>
<front id="Marlin_mainCPP-7280">  return false;</front>
<front id="Marlin_mainCPP-7281">}</front>
<front id="Marlin_mainCPP-7282"></front>
<front id="Marlin_mainCPP-7283">float calculate_volumetric_multiplier(float diameter) {</front>
<front id="Marlin_mainCPP-7284">  if (!volumetric_enabled || diameter == 0) return 1.0;</front>
<front id="Marlin_mainCPP-7285">  float d2 = diameter * 0.5;</front>
<front id="Marlin_mainCPP-7286">  return 1.0 / (M_PI * d2 * d2);</front>
<front id="Marlin_mainCPP-7287">}</front>
<front id="Marlin_mainCPP-7288"></front>
<front id="Marlin_mainCPP-7289">void calculate_volumetric_multipliers() {</front>
<front id="Marlin_mainCPP-7290">  for (int i=0; i&lt;EXTRUDERS; i++)</front>
<front id="Marlin_mainCPP-7291">    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);</front>
<front id="Marlin_mainCPP-7292">}</front>
 </pre>
<h1 id="plannerCPPtitle" >planner.cpp</h1>
<pre id="plannerCPP"  class="prettyprint linenums"><front id="plannerCPP-1">/**</front>
<front id="plannerCPP-2"> * planner.cpp - Buffer movement commands and manage the acceleration profile plan</front>
<front id="plannerCPP-3"> * Part of Grbl</front>
<front id="plannerCPP-4"> *</front>
<front id="plannerCPP-5"> * Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="plannerCPP-6"> *</front>
<front id="plannerCPP-7"> * Grbl is free software: you can redistribute it and/or modify</front>
<front id="plannerCPP-8"> * it under the terms of the GNU General Public License as published by</front>
<front id="plannerCPP-9"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="plannerCPP-10"> * (at your option) any later version.</front>
<front id="plannerCPP-11"> *</front>
<front id="plannerCPP-12"> * Grbl is distributed in the hope that it will be useful,</front>
<front id="plannerCPP-13"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="plannerCPP-14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="plannerCPP-15"> * GNU General Public License for more details.</front>
<front id="plannerCPP-16"> *</front>
<front id="plannerCPP-17"> * You should have received a copy of the GNU General Public License</front>
<front id="plannerCPP-18"> * along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="plannerCPP-19"> *</front>
<front id="plannerCPP-20"> *</front>
<front id="plannerCPP-21"> * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.</front>
<front id="plannerCPP-22"> *</front>
<front id="plannerCPP-23"> *</front>
<front id="plannerCPP-24"> * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):</front>
<front id="plannerCPP-25"> *</front>
<front id="plannerCPP-26"> * s == speed, a == acceleration, t == time, d == distance</front>
<front id="plannerCPP-27"> *</front>
<front id="plannerCPP-28"> * Basic definitions:</front>
<front id="plannerCPP-29"> *   Speed[s_, a_, t_] := s + (a*t)</front>
<front id="plannerCPP-30"> *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]</front>
<front id="plannerCPP-31"> *</front>
<front id="plannerCPP-32"> * Distance to reach a specific speed with a constant acceleration:</front>
<front id="plannerCPP-33"> *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]</front>
<front id="plannerCPP-34"> *   d -&gt; (m^2 - s^2)/(2 a) --&gt; estimate_acceleration_distance()</front>
<front id="plannerCPP-35"> *</front>
<front id="plannerCPP-36"> * Speed after a given distance of travel with constant acceleration:</front>
<front id="plannerCPP-37"> *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]</front>
<front id="plannerCPP-38"> *   m -&gt; Sqrt[2 a d + s^2]</front>
<front id="plannerCPP-39"> *</front>
<front id="plannerCPP-40"> * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]</front>
<front id="plannerCPP-41"> *</front>
<front id="plannerCPP-42"> * When to start braking (di) to reach a specified destination speed (s2) after accelerating</front>
<front id="plannerCPP-43"> * from initial speed s1 without ever stopping at a plateau:</front>
<front id="plannerCPP-44"> *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]</front>
<front id="plannerCPP-45"> *   di -&gt; (2 a d - s1^2 + s2^2)/(4 a) --&gt; intersection_distance()</front>
<front id="plannerCPP-46"> *</front>
<front id="plannerCPP-47"> * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)</front>
<front id="plannerCPP-48"> *</front>
<front id="plannerCPP-49"> */</front>
<front id="plannerCPP-50"></front>
<front id="plannerCPP-51">#include "Marlin.h"</front>
<front id="plannerCPP-52">#include "planner.h"</front>
<front id="plannerCPP-53">#include "stepper.h"</front>
<front id="plannerCPP-54">#include "temperature.h"</front>
<front id="plannerCPP-55">#include "ultralcd.h"</front>
<front id="plannerCPP-56">#include "language.h"</front>
<front id="plannerCPP-57"></front>
<front id="plannerCPP-58">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-59">  #include "mesh_bed_leveling.h"</front>
<front id="plannerCPP-60">#endif</front>
<front id="plannerCPP-61"></front>
<front id="plannerCPP-62">//===========================================================================</front>
<front id="plannerCPP-63">//============================= public variables ============================</front>
<front id="plannerCPP-64">//===========================================================================</front>
<front id="plannerCPP-65"></front>
<front id="plannerCPP-66">millis_t minsegmenttime;</front>
<front id="plannerCPP-67">float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute</front>
<front id="plannerCPP-68">float axis_steps_per_unit[NUM_AXIS];</front>
<front id="plannerCPP-69">unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software</front>
<front id="plannerCPP-70">float minimumfeedrate;</front>
<front id="plannerCPP-71">float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX</front>
<front id="plannerCPP-72">float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX</front>
<front id="plannerCPP-73">float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX</front>
<front id="plannerCPP-74">float max_xy_jerk;          // The largest speed change requiring no acceleration</front>
<front id="plannerCPP-75">float max_z_jerk;</front>
<front id="plannerCPP-76">float max_e_jerk;</front>
<front id="plannerCPP-77">float mintravelfeedrate;</front>
<front id="plannerCPP-78">unsigned long axis_steps_per_sqr_second[NUM_AXIS];</front>
<front id="plannerCPP-79">#ifdef RESUME_FEATURE</front>
<front id="plannerCPP-80">  float planner_disabled_below_z = 0;</front>
<front id="plannerCPP-81">  float last_z = 0;</front>
<front id="plannerCPP-82">  bool z_reached = false;</front>
<front id="plannerCPP-83">  bool layer_reached = false;</front>
<front id="plannerCPP-84">  bool hops = false;</front>
<front id="plannerCPP-85">  bool gone_up = false;</front>
<front id="plannerCPP-86">#endif //RESUME_FEATURE</front>
<front id="plannerCPP-87">#ifdef TRACK_LAYER</front>
<front id="plannerCPP-88">  unsigned short current_layer = 0;</front>
<front id="plannerCPP-89">  float last_layer_z = 0;</front>
<front id="plannerCPP-90">  #ifndef RESUME_FEATURE</front>
<front id="plannerCPP-91">    bool gone_up = false;</front>
<front id="plannerCPP-92">    float last_z = 0;</front>
<front id="plannerCPP-93">  #endif //RESUME_FEATURE</front>
<front id="plannerCPP-94">#endif //TRACK_LAYER</front>
<front id="plannerCPP-95"></front>
<front id="plannerCPP-96">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerCPP-97">  // Transform required to compensate for bed level</front>
<front id="plannerCPP-98">  matrix_3x3 plan_bed_level_matrix = {</front>
<front id="plannerCPP-99">    1.0, 0.0, 0.0,</front>
<front id="plannerCPP-100">    0.0, 1.0, 0.0,</front>
<front id="plannerCPP-101">    0.0, 0.0, 1.0</front>
<front id="plannerCPP-102">  };</front>
<front id="plannerCPP-103">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="plannerCPP-104"></front>
<front id="plannerCPP-105">#if ENABLED(AUTOTEMP)</front>
<front id="plannerCPP-106">  float autotemp_max = 250;</front>
<front id="plannerCPP-107">  float autotemp_min = 210;</front>
<front id="plannerCPP-108">  float autotemp_factor = 0.1;</front>
<front id="plannerCPP-109">  bool autotemp_enabled = false;</front>
<front id="plannerCPP-110">#endif</front>
<front id="plannerCPP-111"></front>
<front id="plannerCPP-112">//===========================================================================</front>
<front id="plannerCPP-113">//============ semi-private variables, used in inline functions =============</front>
<front id="plannerCPP-114">//===========================================================================</front>
<front id="plannerCPP-115"></front>
<front id="plannerCPP-116">block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions</front>
<front id="plannerCPP-117">volatile unsigned char block_buffer_head;           // Index of the next block to be pushed</front>
<front id="plannerCPP-118">volatile unsigned char block_buffer_tail;           // Index of the block to process now</front>
<front id="plannerCPP-119"></front>
<front id="plannerCPP-120">//===========================================================================</front>
<front id="plannerCPP-121">//============================ private variables ============================</front>
<front id="plannerCPP-122">//===========================================================================</front>
<front id="plannerCPP-123"></front>
<front id="plannerCPP-124">// The current position of the tool in absolute steps</front>
<front id="plannerCPP-125">long position[NUM_AXIS];               // Rescaled from extern when axis_steps_per_unit are changed by gcode</front>
<front id="plannerCPP-126">static float previous_speed[NUM_AXIS]; // Speed of previous path line segment</front>
<front id="plannerCPP-127">static float previous_nominal_speed;   // Nominal speed of previous path line segment</front>
<front id="plannerCPP-128"></front>
<front id="plannerCPP-129">unsigned char g_uc_extruder_last_move[4] = {0,0,0,0};</front>
<front id="plannerCPP-130"></front>
<front id="plannerCPP-131">#ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-132">  // Used for the frequency limit</front>
<front id="plannerCPP-133">  #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)</front>
<front id="plannerCPP-134">  // Old direction bits. Used for speed calculations</front>
<front id="plannerCPP-135">  static unsigned char old_direction_bits = 0;</front>
<front id="plannerCPP-136">  // Segment times (in s). Used for speed calculations</front>
<front id="plannerCPP-137">  static long axis_segment_time[2][3] = { {MAX_FREQ_TIME+1,0,0}, {MAX_FREQ_TIME+1,0,0} };</front>
<front id="plannerCPP-138">#endif</front>
<front id="plannerCPP-139"></front>
<front id="plannerCPP-140">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="plannerCPP-141">  static char meas_sample; //temporary variable to hold filament measurement sample</front>
<front id="plannerCPP-142">#endif</front>
<front id="plannerCPP-143"></front>
<front id="plannerCPP-144">//===========================================================================</front>
<front id="plannerCPP-145">//================================ functions ================================</front>
<front id="plannerCPP-146">//===========================================================================</front>
<front id="plannerCPP-147"></front>
<front id="plannerCPP-148">// Get the next / previous index of the next block in the ring buffer</front>
<front id="plannerCPP-149">// NOTE: Using & here (not %) because BLOCK_BUFFER_SIZE is always a power of 2</front>
<front id="plannerCPP-150">FORCE_INLINE int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }</front>
<front id="plannerCPP-151">FORCE_INLINE int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }</front>
<front id="plannerCPP-152"></front>
<front id="plannerCPP-153">// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the</front>
<front id="plannerCPP-154">// given acceleration:</front>
<front id="plannerCPP-155">FORCE_INLINE float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {</front>
<front id="plannerCPP-156">  if (acceleration == 0) return 0; // acceleration was 0, set acceleration distance to 0</front>
<front id="plannerCPP-157">  return (target_rate * target_rate - initial_rate * initial_rate) / (acceleration * 2);</front>
<front id="plannerCPP-158">}</front>
<front id="plannerCPP-159"></front>
<front id="plannerCPP-160">// This function gives you the point at which you must start braking (at the rate of -acceleration) if</front>
<front id="plannerCPP-161">// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after</front>
<front id="plannerCPP-162">// a total travel of distance. This can be used to compute the intersection point between acceleration and</front>
<front id="plannerCPP-163">// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)</front>
<front id="plannerCPP-164"></front>
<front id="plannerCPP-165">FORCE_INLINE float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {</front>
<front id="plannerCPP-166">  if (acceleration == 0) return 0; // acceleration was 0, set intersection distance to 0</front>
<front id="plannerCPP-167">  return (acceleration * 2 * distance - initial_rate * initial_rate + final_rate * final_rate) / (acceleration * 4);</front>
<front id="plannerCPP-168">}</front>
<front id="plannerCPP-169"></front>
<front id="plannerCPP-170">// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.</front>
<front id="plannerCPP-171"></front>
<front id="plannerCPP-172">void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exit_factor) {</front>
<front id="plannerCPP-173">  unsigned long initial_rate = ceil(block-&gt;nominal_rate * entry_factor); // (step/min)</front>
<front id="plannerCPP-174">  unsigned long final_rate = ceil(block-&gt;nominal_rate * exit_factor); // (step/min)</front>
<front id="plannerCPP-175"></front>
<front id="plannerCPP-176">  // Limit minimal step rate (Otherwise the timer will overflow.)</front>
<front id="plannerCPP-177">  NOLESS(initial_rate, 120);</front>
<front id="plannerCPP-178">  NOLESS(final_rate, 120);</front>
<front id="plannerCPP-179"></front>
<front id="plannerCPP-180">  long acceleration = block-&gt;acceleration_st;</front>
<front id="plannerCPP-181">  int32_t accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block-&gt;nominal_rate, acceleration));</front>
<front id="plannerCPP-182">  int32_t decelerate_steps = floor(estimate_acceleration_distance(block-&gt;nominal_rate, final_rate, -acceleration));</front>
<front id="plannerCPP-183"></front>
<front id="plannerCPP-184">  // Calculate the size of Plateau of Nominal Rate.</front>
<front id="plannerCPP-185">  int32_t plateau_steps = block-&gt;step_event_count - accelerate_steps - decelerate_steps;</front>
<front id="plannerCPP-186"></front>
<front id="plannerCPP-187">  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will</front>
<front id="plannerCPP-188">  // have to use intersection_distance() to calculate when to abort acceleration and start braking</front>
<front id="plannerCPP-189">  // in order to reach the final_rate exactly at the end of this block.</front>
<front id="plannerCPP-190">  if (plateau_steps &lt; 0) {</front>
<front id="plannerCPP-191">    accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, acceleration, block-&gt;step_event_count));</front>
<front id="plannerCPP-192">    accelerate_steps = max(accelerate_steps, 0); // Check limits due to numerical round-off</front>
<front id="plannerCPP-193">    accelerate_steps = min((uint32_t)accelerate_steps, block-&gt;step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)</front>
<front id="plannerCPP-194">    plateau_steps = 0;</front>
<front id="plannerCPP-195">  }</front>
<front id="plannerCPP-196"></front>
<front id="plannerCPP-197">#if ENABLED(ADVANCE)</front>
<front id="plannerCPP-198">  volatile long initial_advance = block-&gt;advance * entry_factor * entry_factor;</front>
<front id="plannerCPP-199">  volatile long final_advance = block-&gt;advance * exit_factor * exit_factor;</front>
<front id="plannerCPP-200">#endif // ADVANCE</front>
<front id="plannerCPP-201"></front>
<front id="plannerCPP-202">  // block-&gt;accelerate_until = accelerate_steps;</front>
<front id="plannerCPP-203">  // block-&gt;decelerate_after = accelerate_steps+plateau_steps;</front>
<front id="plannerCPP-204">  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section</front>
<front id="plannerCPP-205">  if (!block-&gt;busy) { // Don't update variables if block is busy.</front>
<front id="plannerCPP-206">    block-&gt;accelerate_until = accelerate_steps;</front>
<front id="plannerCPP-207">    block-&gt;decelerate_after = accelerate_steps+plateau_steps;</front>
<front id="plannerCPP-208">    block-&gt;initial_rate = initial_rate;</front>
<front id="plannerCPP-209">    block-&gt;final_rate = final_rate;</front>
<front id="plannerCPP-210">    #if ENABLED(ADVANCE)</front>
<front id="plannerCPP-211">      block-&gt;initial_advance = initial_advance;</front>
<front id="plannerCPP-212">      block-&gt;final_advance = final_advance;</front>
<front id="plannerCPP-213">    #endif</front>
<front id="plannerCPP-214">  }</front>
<front id="plannerCPP-215">  CRITICAL_SECTION_END;</front>
<front id="plannerCPP-216">}</front>
<front id="plannerCPP-217"></front>
<front id="plannerCPP-218">// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the</front>
<front id="plannerCPP-219">// acceleration within the allotted distance.</front>
<front id="plannerCPP-220">FORCE_INLINE float max_allowable_speed(float acceleration, float target_velocity, float distance) {</front>
<front id="plannerCPP-221">  return sqrt(target_velocity * target_velocity - 2 * acceleration * distance);</front>
<front id="plannerCPP-222">}</front>
<front id="plannerCPP-223"></front>
<front id="plannerCPP-224">// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.</front>
<front id="plannerCPP-225">// This method will calculate the junction jerk as the euclidean distance between the nominal</front>
<front id="plannerCPP-226">// velocities of the respective blocks.</front>
<front id="plannerCPP-227">//inline float junction_jerk(block_t *before, block_t *after) {</front>
<front id="plannerCPP-228">//  return sqrt(</front>
<front id="plannerCPP-229">//    pow((before-&gt;speed_x-after-&gt;speed_x), 2)+pow((before-&gt;speed_y-after-&gt;speed_y), 2));</front>
<front id="plannerCPP-230">//}</front>
<front id="plannerCPP-231"></front>
<front id="plannerCPP-232"></front>
<front id="plannerCPP-233">// The kernel called by planner_recalculate() when scanning the plan from last to first entry.</front>
<front id="plannerCPP-234">void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {</front>
<front id="plannerCPP-235">  if (!current) return;</front>
<front id="plannerCPP-236">  UNUSED(previous);</front>
<front id="plannerCPP-237"></front>
<front id="plannerCPP-238">  if (next) {</front>
<front id="plannerCPP-239">    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.</front>
<front id="plannerCPP-240">    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and</front>
<front id="plannerCPP-241">    // check for maximum allowable speed reductions to ensure maximum possible planned speed.</front>
<front id="plannerCPP-242">    if (current-&gt;entry_speed != current-&gt;max_entry_speed) {</front>
<front id="plannerCPP-243"></front>
<front id="plannerCPP-244">      // If nominal length true, max junction speed is guaranteed to be reached. Only compute</front>
<front id="plannerCPP-245">      // for max allowable speed if block is decelerating and nominal length is false.</front>
<front id="plannerCPP-246">      if (!current-&gt;nominal_length_flag && current-&gt;max_entry_speed &gt; next-&gt;entry_speed) {</front>
<front id="plannerCPP-247">        current-&gt;entry_speed = min(current-&gt;max_entry_speed,</front>
<front id="plannerCPP-248">          max_allowable_speed(-current-&gt;acceleration, next-&gt;entry_speed, current-&gt;millimeters));</front>
<front id="plannerCPP-249">      }</front>
<front id="plannerCPP-250">      else {</front>
<front id="plannerCPP-251">        current-&gt;entry_speed = current-&gt;max_entry_speed;</front>
<front id="plannerCPP-252">      }</front>
<front id="plannerCPP-253">      current-&gt;recalculate_flag = true;</front>
<front id="plannerCPP-254"></front>
<front id="plannerCPP-255">    }</front>
<front id="plannerCPP-256">  } // Skip last block. Already initialized and set for recalculation.</front>
<front id="plannerCPP-257">}</front>
<front id="plannerCPP-258"></front>
<front id="plannerCPP-259">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This</front>
<front id="plannerCPP-260">// implements the reverse pass.</front>
<front id="plannerCPP-261">void planner_reverse_pass() {</front>
<front id="plannerCPP-262">  uint8_t block_index = block_buffer_head;</front>
<front id="plannerCPP-263"></front>
<front id="plannerCPP-264">  //Make a local copy of block_buffer_tail, because the interrupt can alter it</front>
<front id="plannerCPP-265">  CRITICAL_SECTION_START;</front>
<front id="plannerCPP-266">    unsigned char tail = block_buffer_tail;</front>
<front id="plannerCPP-267">  CRITICAL_SECTION_END</front>
<front id="plannerCPP-268"></front>
<front id="plannerCPP-269">  if (BLOCK_MOD(block_buffer_head - tail + BLOCK_BUFFER_SIZE) &gt; 3) { // moves queued</front>
<front id="plannerCPP-270">    block_index = BLOCK_MOD(block_buffer_head - 3);</front>
<front id="plannerCPP-271">    block_t *block[3] = { NULL, NULL, NULL };</front>
<front id="plannerCPP-272">    while (block_index != tail) {</front>
<front id="plannerCPP-273">      block_index = prev_block_index(block_index);</front>
<front id="plannerCPP-274">      block[2]= block[1];</front>
<front id="plannerCPP-275">      block[1]= block[0];</front>
<front id="plannerCPP-276">      block[0] = &block_buffer[block_index];</front>
<front id="plannerCPP-277">      planner_reverse_pass_kernel(block[0], block[1], block[2]);</front>
<front id="plannerCPP-278">    }</front>
<front id="plannerCPP-279">  }</front>
<front id="plannerCPP-280">}</front>
<front id="plannerCPP-281"></front>
<front id="plannerCPP-282">// The kernel called by planner_recalculate() when scanning the plan from first to last entry.</front>
<front id="plannerCPP-283">void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {</front>
<front id="plannerCPP-284">  if (!previous) return;</front>
<front id="plannerCPP-285">  UNUSED(next);</front>
<front id="plannerCPP-286"></front>
<front id="plannerCPP-287">  // If the previous block is an acceleration block, but it is not long enough to complete the</front>
<front id="plannerCPP-288">  // full speed change within the block, we need to adjust the entry speed accordingly. Entry</front>
<front id="plannerCPP-289">  // speeds have already been reset, maximized, and reverse planned by reverse planner.</front>
<front id="plannerCPP-290">  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.</front>
<front id="plannerCPP-291">  if (!previous-&gt;nominal_length_flag) {</front>
<front id="plannerCPP-292">    if (previous-&gt;entry_speed &lt; current-&gt;entry_speed) {</front>
<front id="plannerCPP-293">      double entry_speed = min(current-&gt;entry_speed,</front>
<front id="plannerCPP-294">        max_allowable_speed(-previous-&gt;acceleration, previous-&gt;entry_speed, previous-&gt;millimeters));</front>
<front id="plannerCPP-295"></front>
<front id="plannerCPP-296">      // Check for junction speed change</front>
<front id="plannerCPP-297">      if (current-&gt;entry_speed != entry_speed) {</front>
<front id="plannerCPP-298">        current-&gt;entry_speed = entry_speed;</front>
<front id="plannerCPP-299">        current-&gt;recalculate_flag = true;</front>
<front id="plannerCPP-300">      }</front>
<front id="plannerCPP-301">    }</front>
<front id="plannerCPP-302">  }</front>
<front id="plannerCPP-303">}</front>
<front id="plannerCPP-304"></front>
<front id="plannerCPP-305">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This</front>
<front id="plannerCPP-306">// implements the forward pass.</front>
<front id="plannerCPP-307">void planner_forward_pass() {</front>
<front id="plannerCPP-308">  uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-309">  block_t *block[3] = { NULL, NULL, NULL };</front>
<front id="plannerCPP-310"></front>
<front id="plannerCPP-311">  while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-312">    block[0] = block[1];</front>
<front id="plannerCPP-313">    block[1] = block[2];</front>
<front id="plannerCPP-314">    block[2] = &block_buffer[block_index];</front>
<front id="plannerCPP-315">    planner_forward_pass_kernel(block[0], block[1], block[2]);</front>
<front id="plannerCPP-316">    block_index = next_block_index(block_index);</front>
<front id="plannerCPP-317">  }</front>
<front id="plannerCPP-318">  planner_forward_pass_kernel(block[1], block[2], NULL);</front>
<front id="plannerCPP-319">}</front>
<front id="plannerCPP-320"></front>
<front id="plannerCPP-321">// Recalculates the trapezoid speed profiles for all blocks in the plan according to the</front>
<front id="plannerCPP-322">// entry_factor for each junction. Must be called by planner_recalculate() after</front>
<front id="plannerCPP-323">// updating the blocks.</front>
<front id="plannerCPP-324">void planner_recalculate_trapezoids() {</front>
<front id="plannerCPP-325">  int8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-326">  block_t *current;</front>
<front id="plannerCPP-327">  block_t *next = NULL;</front>
<front id="plannerCPP-328"></front>
<front id="plannerCPP-329">  while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-330">    current = next;</front>
<front id="plannerCPP-331">    next = &block_buffer[block_index];</front>
<front id="plannerCPP-332">    if (current) {</front>
<front id="plannerCPP-333">      // Recalculate if current block entry or exit junction speed has changed.</front>
<front id="plannerCPP-334">      if (current-&gt;recalculate_flag || next-&gt;recalculate_flag) {</front>
<front id="plannerCPP-335">        // NOTE: Entry and exit factors always &gt; 0 by all previous logic operations.</front>
<front id="plannerCPP-336">        float nom = current-&gt;nominal_speed;</front>
<front id="plannerCPP-337">        calculate_trapezoid_for_block(current, current-&gt;entry_speed / nom, next-&gt;entry_speed / nom);</front>
<front id="plannerCPP-338">        current-&gt;recalculate_flag = false; // Reset current only to ensure next trapezoid is computed</front>
<front id="plannerCPP-339">      }</front>
<front id="plannerCPP-340">    }</front>
<front id="plannerCPP-341">    block_index = next_block_index( block_index );</front>
<front id="plannerCPP-342">  }</front>
<front id="plannerCPP-343">  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.</front>
<front id="plannerCPP-344">  if (next) {</front>
<front id="plannerCPP-345">    float nom = next-&gt;nominal_speed;</front>
<front id="plannerCPP-346">    calculate_trapezoid_for_block(next, next-&gt;entry_speed / nom, MINIMUM_PLANNER_SPEED / nom);</front>
<front id="plannerCPP-347">    next-&gt;recalculate_flag = false;</front>
<front id="plannerCPP-348">  }</front>
<front id="plannerCPP-349">}</front>
<front id="plannerCPP-350"></front>
<front id="plannerCPP-351">// Recalculates the motion plan according to the following algorithm:</front>
<front id="plannerCPP-352">//</front>
<front id="plannerCPP-353">//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor)</front>
<front id="plannerCPP-354">//      so that:</front>
<front id="plannerCPP-355">//     a. The junction jerk is within the set limit</front>
<front id="plannerCPP-356">//     b. No speed reduction within one block requires faster deceleration than the one, true constant</front>
<front id="plannerCPP-357">//        acceleration.</front>
<front id="plannerCPP-358">//   2. Go over every block in chronological order and dial down junction speed reduction values if</front>
<front id="plannerCPP-359">//     a. The speed increase within one block would require faster acceleration than the one, true</front>
<front id="plannerCPP-360">//        constant acceleration.</front>
<front id="plannerCPP-361">//</front>
<front id="plannerCPP-362">// When these stages are complete all blocks have an entry_factor that will allow all speed changes to</front>
<front id="plannerCPP-363">// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than</front>
<front id="plannerCPP-364">// the set limit. Finally it will:</front>
<front id="plannerCPP-365">//</front>
<front id="plannerCPP-366">//   3. Recalculate trapezoids for all blocks.</front>
<front id="plannerCPP-367"></front>
<front id="plannerCPP-368">void planner_recalculate() {</front>
<front id="plannerCPP-369">  planner_reverse_pass();</front>
<front id="plannerCPP-370">  planner_forward_pass();</front>
<front id="plannerCPP-371">  planner_recalculate_trapezoids();</front>
<front id="plannerCPP-372">}</front>
<front id="plannerCPP-373"></front>
<front id="plannerCPP-374">void plan_init() {</front>
<front id="plannerCPP-375">  block_buffer_head = block_buffer_tail = 0;</front>
<front id="plannerCPP-376">  memset(position, 0, sizeof(position)); // clear position</front>
<front id="plannerCPP-377">  for (int i=0; i&lt;NUM_AXIS; i++) previous_speed[i] = 0.0;</front>
<front id="plannerCPP-378">  previous_nominal_speed = 0.0;</front>
<front id="plannerCPP-379">}</front>
<front id="plannerCPP-380"></front>
<front id="plannerCPP-381"></front>
<front id="plannerCPP-382">#if ENABLED(AUTOTEMP)</front>
<front id="plannerCPP-383">  void getHighESpeed() {</front>
<front id="plannerCPP-384">    static float oldt = 0;</front>
<front id="plannerCPP-385"></front>
<front id="plannerCPP-386">    if (!autotemp_enabled) return;</front>
<front id="plannerCPP-387">    if (degTargetHotend0() + 2 &lt; autotemp_min) return; // probably temperature set to zero.</front>
<front id="plannerCPP-388"></front>
<front id="plannerCPP-389">    float high = 0.0;</front>
<front id="plannerCPP-390">    uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-391"></front>
<front id="plannerCPP-392">    while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-393">      block_t *block = &block_buffer[block_index];</front>
<front id="plannerCPP-394">      if (block-&gt;steps[X_AXIS] || block-&gt;steps[Y_AXIS] || block-&gt;steps[Z_AXIS]) {</front>
<front id="plannerCPP-395">        float se = (float)block-&gt;steps[E_AXIS] / block-&gt;step_event_count * block-&gt;nominal_speed; // mm/sec;</front>
<front id="plannerCPP-396">        if (se &gt; high) high = se;</front>
<front id="plannerCPP-397">      }</front>
<front id="plannerCPP-398">      block_index = next_block_index(block_index);</front>
<front id="plannerCPP-399">    }</front>
<front id="plannerCPP-400"></front>
<front id="plannerCPP-401">    float t = autotemp_min + high * autotemp_factor;</front>
<front id="plannerCPP-402">    t = constrain(t, autotemp_min, autotemp_max);</front>
<front id="plannerCPP-403">    if (oldt &gt; t) {</front>
<front id="plannerCPP-404">      t *= (1 - AUTOTEMP_OLDWEIGHT);</front>
<front id="plannerCPP-405">      t += AUTOTEMP_OLDWEIGHT * oldt;</front>
<front id="plannerCPP-406">    }</front>
<front id="plannerCPP-407">    oldt = t;</front>
<front id="plannerCPP-408">    setTargetHotend0(t);</front>
<front id="plannerCPP-409">  }</front>
<front id="plannerCPP-410">#endif</front>
<front id="plannerCPP-411"></front>
<front id="plannerCPP-412">void check_axes_activity() {</front>
<front id="plannerCPP-413">  unsigned char axis_active[NUM_AXIS] = { 0 },</front>
<front id="plannerCPP-414">                tail_fan_speed = fanSpeed;</front>
<front id="plannerCPP-415">  #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-416">    unsigned char tail_valve_pressure = ValvePressure,</front>
<front id="plannerCPP-417">                  tail_e_to_p_pressure = EtoPPressure;</front>
<front id="plannerCPP-418">  #endif</front>
<front id="plannerCPP-419"></front>
<front id="plannerCPP-420">  block_t *block;</front>
<front id="plannerCPP-421"></front>
<front id="plannerCPP-422">  if (blocks_queued()) {</front>
<front id="plannerCPP-423">    uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-424">    tail_fan_speed = block_buffer[block_index].fan_speed;</front>
<front id="plannerCPP-425">    #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-426">      block = &block_buffer[block_index];</front>
<front id="plannerCPP-427">      tail_valve_pressure = block-&gt;valve_pressure;</front>
<front id="plannerCPP-428">      tail_e_to_p_pressure = block-&gt;e_to_p_pressure;</front>
<front id="plannerCPP-429">    #endif</front>
<front id="plannerCPP-430">    while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-431">      block = &block_buffer[block_index];</front>
<front id="plannerCPP-432">      for (int i=0; i&lt;NUM_AXIS; i++) if (block-&gt;steps[i]) axis_active[i]++;</front>
<front id="plannerCPP-433">      block_index = next_block_index(block_index);</front>
<front id="plannerCPP-434">    }</front>
<front id="plannerCPP-435">  }</front>
<front id="plannerCPP-436">  if (DISABLE_X && !axis_active[X_AXIS]) disable_x();</front>
<front id="plannerCPP-437">  if (DISABLE_Y && !axis_active[Y_AXIS]) disable_y();</front>
<front id="plannerCPP-438">  if (DISABLE_Z && !axis_active[Z_AXIS]) disable_z();</front>
<front id="plannerCPP-439">  if (DISABLE_E && !axis_active[E_AXIS]) {</front>
<front id="plannerCPP-440">    disable_e0();</front>
<front id="plannerCPP-441">    disable_e1();</front>
<front id="plannerCPP-442">    disable_e2();</front>
<front id="plannerCPP-443">    disable_e3();</front>
<front id="plannerCPP-444">  }</front>
<front id="plannerCPP-445"></front>
<front id="plannerCPP-446">  #if HAS_FAN</front>
<front id="plannerCPP-447">    #ifdef FAN_KICKSTART_TIME</front>
<front id="plannerCPP-448">      static millis_t fan_kick_end;</front>
<front id="plannerCPP-449">      if (tail_fan_speed) {</front>
<front id="plannerCPP-450">        millis_t ms = millis();</front>
<front id="plannerCPP-451">        if (fan_kick_end == 0) {</front>
<front id="plannerCPP-452">          // Just starting up fan - run at full power.</front>
<front id="plannerCPP-453">          fan_kick_end = ms + FAN_KICKSTART_TIME;</front>
<front id="plannerCPP-454">          tail_fan_speed = 255;</front>
<front id="plannerCPP-455">        } else if (fan_kick_end &gt; ms)</front>
<front id="plannerCPP-456">          // Fan still spinning up.</front>
<front id="plannerCPP-457">          tail_fan_speed = 255;</front>
<front id="plannerCPP-458">        } else {</front>
<front id="plannerCPP-459">          fan_kick_end = 0;</front>
<front id="plannerCPP-460">        }</front>
<front id="plannerCPP-461">    #endif //FAN_KICKSTART_TIME</front>
<front id="plannerCPP-462">    #if ENABLED(FAN_MIN_PWM)</front>
<front id="plannerCPP-463">      #define CALC_FAN_SPEED (tail_fan_speed ? ( FAN_MIN_PWM + (tail_fan_speed * (255 - FAN_MIN_PWM)) / 255 ) : 0)</front>
<front id="plannerCPP-464">    #else</front>
<front id="plannerCPP-465">      #define CALC_FAN_SPEED tail_fan_speed</front>
<front id="plannerCPP-466">    #endif // FAN_MIN_PWM</front>
<front id="plannerCPP-467">    #if ENABLED(FAN_SOFT_PWM)</front>
<front id="plannerCPP-468">      fanSpeedSoftPwm = CALC_FAN_SPEED;</front>
<front id="plannerCPP-469">    #else</front>
<front id="plannerCPP-470">      analogWrite(FAN_PIN, CALC_FAN_SPEED);</front>
<front id="plannerCPP-471">    #endif // FAN_SOFT_PWM</front>
<front id="plannerCPP-472">  #endif // HAS_FAN</front>
<front id="plannerCPP-473"></front>
<front id="plannerCPP-474">  #if ENABLED(AUTOTEMP)</front>
<front id="plannerCPP-475">    getHighESpeed();</front>
<front id="plannerCPP-476">  #endif</front>
<front id="plannerCPP-477"></front>
<front id="plannerCPP-478">  #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-479">    #if HAS_HEATER_1</front>
<front id="plannerCPP-480">      analogWrite(HEATER_1_PIN,tail_valve_pressure);</front>
<front id="plannerCPP-481">    #endif</front>
<front id="plannerCPP-482">    #if HAS_HEATER_2</front>
<front id="plannerCPP-483">      analogWrite(HEATER_2_PIN,tail_e_to_p_pressure);</front>
<front id="plannerCPP-484">    #endif</front>
<front id="plannerCPP-485">  #endif</front>
<front id="plannerCPP-486">}</front>
<front id="plannerCPP-487"></front>
<front id="plannerCPP-488">#ifdef RESUME_FEATURE</front>
<front id="plannerCPP-489">  void floor_z(const float &z)</front>
<front id="plannerCPP-490">  {</front>
<front id="plannerCPP-491">    // filter out moves below a given floor height and attempt to ignore any hops/travels</front>
<front id="plannerCPP-492">    if (planner_disabled_below_z && !layer_reached) {</front>
<front id="plannerCPP-493">      if (z &lt; planner_disabled_below_z) {</front>
<front id="plannerCPP-494">        if (z &gt; last_z && !gone_up) // up once</front>
<front id="plannerCPP-495">          gone_up = true;</front>
<front id="plannerCPP-496">        else if (z &lt; last_z) { // back down</front>
<front id="plannerCPP-497">          #ifdef TRACK_LAYER</front>
<front id="plannerCPP-498">            if (z &gt; last_layer_z)</front>
<front id="plannerCPP-499">              current_layer++;</front>
<front id="plannerCPP-500">            else if (z &lt; last_layer_z && z != 0)</front>
<front id="plannerCPP-501">              current_layer = 1; // if it goes lower than what we would think was the previous layer then we might as well assume it's printing another object</front>
<front id="plannerCPP-502">            else if (z == 0)</front>
<front id="plannerCPP-503">              current_layer = 0;</front>
<front id="plannerCPP-504">            last_layer_z = z;</front>
<front id="plannerCPP-505">          #endif //TRACK_LAYER</front>
<front id="plannerCPP-506">          hops = true;</front>
<front id="plannerCPP-507">          gone_up = false;</front>
<front id="plannerCPP-508">        }</front>
<front id="plannerCPP-509">        else if (z &gt; last_z && gone_up) { // up twice</front>
<front id="plannerCPP-510">          #ifdef TRACK_LAYER</front>
<front id="plannerCPP-511">            current_layer++; // be careful with prints like the spiral vase</front>
<front id="plannerCPP-512">          #endif //TRACK_LAYER</front>
<front id="plannerCPP-513">          hops = false;</front>
<front id="plannerCPP-514">        }</front>
<front id="plannerCPP-515">        z_reached = false;</front>
<front id="plannerCPP-516">        last_z = z;</front>
<front id="plannerCPP-517">        return;</front>
<front id="plannerCPP-518">      }</front>
<front id="plannerCPP-519">      else if (hops && !z_reached) {</front>
<front id="plannerCPP-520">        z_reached = true;</front>
<front id="plannerCPP-521">        last_z = z;</front>
<front id="plannerCPP-522">        return;</front>
<front id="plannerCPP-523">      }</front>
<front id="plannerCPP-524">      else if (hops && z == last_z)</front>
<front id="plannerCPP-525">        return;</front>
<front id="plannerCPP-526">      else</front>
<front id="plannerCPP-527">        layer_reached = true;</front>
<front id="plannerCPP-528">    }</front>
<front id="plannerCPP-529">    else if (planner_disabled_below_z && z &lt; planner_disabled_below_z) {</front>
<front id="plannerCPP-530">      z_reached = false;</front>
<front id="plannerCPP-531">      layer_reached = false;</front>
<front id="plannerCPP-532">      return;</front>
<front id="plannerCPP-533">    }</front>
<front id="plannerCPP-534">  }</front>
<front id="plannerCPP-535">#endif //RESUME_FEATURE</front>
<front id="plannerCPP-536"></front>
<front id="plannerCPP-537">#ifdef TRACK_LAYER</front>
<front id="plannerCPP-538">  void layer_count(const float &z)</front>
<front id="plannerCPP-539">  {</front>
<front id="plannerCPP-540">    if (z &gt; last_z && !gone_up) // up once</front>
<front id="plannerCPP-541">      gone_up = true;</front>
<front id="plannerCPP-542">    else if (z &lt; last_z) { // back down</front>
<front id="plannerCPP-543">      if (z &gt; last_layer_z)</front>
<front id="plannerCPP-544">        current_layer++;</front>
<front id="plannerCPP-545">      else if (z &lt; last_layer_z && z != 0)</front>
<front id="plannerCPP-546">        current_layer = 1; // if it goes lower than what we would think was the previous layer then we might as well assume it's printing another object</front>
<front id="plannerCPP-547">      else if (z == 0)</front>
<front id="plannerCPP-548">        current_layer = 0;</front>
<front id="plannerCPP-549">      last_layer_z = z;</front>
<front id="plannerCPP-550">      gone_up = false;</front>
<front id="plannerCPP-551">    }</front>
<front id="plannerCPP-552">    else if (z &gt; last_z && gone_up) // up twice</front>
<front id="plannerCPP-553">      current_layer++; // be careful with prints like the spiral vase</front>
<front id="plannerCPP-554"></front>
<front id="plannerCPP-555">    last_z = z;</front>
<front id="plannerCPP-556">  }</front>
<front id="plannerCPP-557">#endif //TRACK_LAYER</front>
<front id="plannerCPP-558"></front>
<front id="plannerCPP-559">float junction_deviation = 0.1;</front>
<front id="plannerCPP-560">// Add a new linear movement to the buffer. steps[X_AXIS], _y and _z is the absolute position in </front>
<front id="plannerCPP-561">// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration</front>
<front id="plannerCPP-562">// calculation the caller must also provide the physical length of the line in millimeters.</front>
<front id="plannerCPP-563">#if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-564">  void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t extruder)</front>
<front id="plannerCPP-565">#else</front>
<front id="plannerCPP-566">  void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t extruder)</front>
<front id="plannerCPP-567">#endif  // AUTO_BED_LEVELING_FEATURE</front>
<front id="plannerCPP-568">{</front>
<front id="plannerCPP-569">  #ifdef RESUME_FEATURE</front>
<front id="plannerCPP-570">    floor_z(z);</front>
<front id="plannerCPP-571">  #endif</front>
<front id="plannerCPP-572"></front>
<front id="plannerCPP-573">  #ifdef TRACK_LAYER</front>
<front id="plannerCPP-574">    layer_count(z);</front>
<front id="plannerCPP-575">  #endif //TRACK_LAYER</front>
<front id="plannerCPP-576"></front>
<front id="plannerCPP-577">  // Calculate the buffer head after we push this byte</front>
<front id="plannerCPP-578">  int next_buffer_head = next_block_index(block_buffer_head);</front>
<front id="plannerCPP-579"></front>
<front id="plannerCPP-580">  // If the buffer is full: good! That means we are well ahead of the robot.</front>
<front id="plannerCPP-581">  // Rest here until there is room in the buffer.</front>
<front id="plannerCPP-582">  while (block_buffer_tail == next_buffer_head) idle();</front>
<front id="plannerCPP-583"></front>
<front id="plannerCPP-584">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-585">    if (mbl.active) z += mbl.get_z(x, y);</front>
<front id="plannerCPP-586">  #elif ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerCPP-587">    apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</front>
<front id="plannerCPP-588">  #endif</front>
<front id="plannerCPP-589"></front>
<front id="plannerCPP-590">  // The target position of the tool in absolute steps</front>
<front id="plannerCPP-591">  // Calculate target position in absolute steps</front>
<front id="plannerCPP-592">  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow</front>
<front id="plannerCPP-593">  long target[NUM_AXIS];</front>
<front id="plannerCPP-594">  target[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]);</front>
<front id="plannerCPP-595">  target[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]);</front>
<front id="plannerCPP-596">  target[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]);</front>
<front id="plannerCPP-597">  target[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-598"></front>
<front id="plannerCPP-599">  float dx = target[X_AXIS] - position[X_AXIS],</front>
<front id="plannerCPP-600">        dy = target[Y_AXIS] - position[Y_AXIS],</front>
<front id="plannerCPP-601">        dz = target[Z_AXIS] - position[Z_AXIS];</front>
<front id="plannerCPP-602"></front>
<front id="plannerCPP-603">  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied</front>
<front id="plannerCPP-604">  if (marlin_debug_flags & DEBUG_DRYRUN)</front>
<front id="plannerCPP-605">    position[E_AXIS] = target[E_AXIS];</front>
<front id="plannerCPP-606"></front>
<front id="plannerCPP-607">  float de = target[E_AXIS] - position[E_AXIS];</front>
<front id="plannerCPP-608"></front>
<front id="plannerCPP-609">  #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="plannerCPP-610">    if (de) {</front>
<front id="plannerCPP-611">      if (degHotend(extruder) &lt; extrude_min_temp) {</front>
<front id="plannerCPP-612">        position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part</front>
<front id="plannerCPP-613">        de = 0; // no difference</front>
<front id="plannerCPP-614">        SERIAL_ECHO_START;</front>
<front id="plannerCPP-615">        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);</front>
<front id="plannerCPP-616">      }</front>
<front id="plannerCPP-617">      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)</front>
<front id="plannerCPP-618">        if (labs(de) &gt; axis_steps_per_unit[E_AXIS] * EXTRUDE_MAXLENGTH) {</front>
<front id="plannerCPP-619">          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part</front>
<front id="plannerCPP-620">          de = 0; // no difference</front>
<front id="plannerCPP-621">          SERIAL_ECHO_START;</front>
<front id="plannerCPP-622">          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);</front>
<front id="plannerCPP-623">        }</front>
<front id="plannerCPP-624">      #endif</front>
<front id="plannerCPP-625">    }</front>
<front id="plannerCPP-626">  #endif</front>
<front id="plannerCPP-627"></front>
<front id="plannerCPP-628">  // Prepare to set up new block</front>
<front id="plannerCPP-629">  block_t *block = &block_buffer[block_buffer_head];</front>
<front id="plannerCPP-630"></front>
<front id="plannerCPP-631">  // Mark block as not busy (Not executed by the stepper interrupt)</front>
<front id="plannerCPP-632">  block-&gt;busy = false;</front>
<front id="plannerCPP-633"></front>
<front id="plannerCPP-634">  // Number of steps for each axis</front>
<front id="plannerCPP-635">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-636">    // corexy planning</front>
<front id="plannerCPP-637">    // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html</front>
<front id="plannerCPP-638">    block-&gt;steps[A_AXIS] = labs(dx + dy);</front>
<front id="plannerCPP-639">    block-&gt;steps[B_AXIS] = labs(dx - dy);</front>
<front id="plannerCPP-640">    block-&gt;steps[Z_AXIS] = labs(dz);</front>
<front id="plannerCPP-641">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-642">    // corexz planning</front>
<front id="plannerCPP-643">    block-&gt;steps[A_AXIS] = labs(dx + dz);</front>
<front id="plannerCPP-644">    block-&gt;steps[Y_AXIS] = labs(dy);</front>
<front id="plannerCPP-645">    block-&gt;steps[C_AXIS] = labs(dx - dz);</front>
<front id="plannerCPP-646">  #else</front>
<front id="plannerCPP-647">    // default non-h-bot planning</front>
<front id="plannerCPP-648">    block-&gt;steps[X_AXIS] = labs(dx);</front>
<front id="plannerCPP-649">    block-&gt;steps[Y_AXIS] = labs(dy);</front>
<front id="plannerCPP-650">    block-&gt;steps[Z_AXIS] = labs(dz);</front>
<front id="plannerCPP-651">  #endif</front>
<front id="plannerCPP-652"></front>
<front id="plannerCPP-653">  block-&gt;steps[E_AXIS] = labs(de);</front>
<front id="plannerCPP-654">  block-&gt;steps[E_AXIS] *= volumetric_multiplier[extruder];</front>
<front id="plannerCPP-655">  block-&gt;steps[E_AXIS] *= extruder_multiplier[extruder];</front>
<front id="plannerCPP-656">  block-&gt;steps[E_AXIS] /= 100;</front>
<front id="plannerCPP-657">  block-&gt;step_event_count = max(block-&gt;steps[X_AXIS], max(block-&gt;steps[Y_AXIS], max(block-&gt;steps[Z_AXIS], block-&gt;steps[E_AXIS])));</front>
<front id="plannerCPP-658"></front>
<front id="plannerCPP-659">  // Bail if this is a zero-length block</front>
<front id="plannerCPP-660">  if (block-&gt;step_event_count &lt;= dropsegments) return;</front>
<front id="plannerCPP-661"></front>
<front id="plannerCPP-662">  block-&gt;fan_speed = fanSpeed;</front>
<front id="plannerCPP-663">  #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-664">    block-&gt;valve_pressure = ValvePressure;</front>
<front id="plannerCPP-665">    block-&gt;e_to_p_pressure = EtoPPressure;</front>
<front id="plannerCPP-666">  #endif</front>
<front id="plannerCPP-667"></front>
<front id="plannerCPP-668">  // Compute direction bits for this block</front>
<front id="plannerCPP-669">  uint8_t db = 0;</front>
<front id="plannerCPP-670">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-671">    if (dx &lt; 0) db |= BIT(X_HEAD); // Save the real Extruder (head) direction in X Axis</front>
<front id="plannerCPP-672">    if (dy &lt; 0) db |= BIT(Y_HEAD); // ...and Y</front>
<front id="plannerCPP-673">    if (dz &lt; 0) db |= BIT(Z_AXIS);</front>
<front id="plannerCPP-674">    if (dx + dy &lt; 0) db |= BIT(A_AXIS); // Motor A direction</front>
<front id="plannerCPP-675">    if (dx - dy &lt; 0) db |= BIT(B_AXIS); // Motor B direction</front>
<front id="plannerCPP-676">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-677">    if (dx &lt; 0) db |= BIT(X_HEAD); // Save the real Extruder (head) direction in X Axis</front>
<front id="plannerCPP-678">    if (dy &lt; 0) db |= BIT(Y_AXIS);</front>
<front id="plannerCPP-679">    if (dz &lt; 0) db |= BIT(Z_HEAD); // ...and Z</front>
<front id="plannerCPP-680">    if (dx + dz &lt; 0) db |= BIT(A_AXIS); // Motor A direction</front>
<front id="plannerCPP-681">    if (dx - dz &lt; 0) db |= BIT(C_AXIS); // Motor B direction</front>
<front id="plannerCPP-682">  #else</front>
<front id="plannerCPP-683">    if (dx &lt; 0) db |= BIT(X_AXIS);</front>
<front id="plannerCPP-684">    if (dy &lt; 0) db |= BIT(Y_AXIS);</front>
<front id="plannerCPP-685">    if (dz &lt; 0) db |= BIT(Z_AXIS);</front>
<front id="plannerCPP-686">  #endif</front>
<front id="plannerCPP-687">  if (de &lt; 0) db |= BIT(E_AXIS);</front>
<front id="plannerCPP-688">  block-&gt;direction_bits = db;</front>
<front id="plannerCPP-689"></front>
<front id="plannerCPP-690">  block-&gt;active_extruder = extruder;</front>
<front id="plannerCPP-691"></front>
<front id="plannerCPP-692">  //enable active axes</front>
<front id="plannerCPP-693">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-694">    if (block-&gt;steps[A_AXIS] || block-&gt;steps[B_AXIS]) {</front>
<front id="plannerCPP-695">      enable_x();</front>
<front id="plannerCPP-696">      enable_y();</front>
<front id="plannerCPP-697">    }</front>
<front id="plannerCPP-698">    #if DISABLED(Z_LATE_ENABLE)</front>
<front id="plannerCPP-699">      if (block-&gt;steps[Z_AXIS]) enable_z();</front>
<front id="plannerCPP-700">    #endif</front>
<front id="plannerCPP-701">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-702">    if (block-&gt;steps[A_AXIS] || block-&gt;steps[C_AXIS]) {</front>
<front id="plannerCPP-703">      enable_x();</front>
<front id="plannerCPP-704">      enable_z();</front>
<front id="plannerCPP-705">    }</front>
<front id="plannerCPP-706">    if (block-&gt;steps[Y_AXIS]) enable_y();</front>
<front id="plannerCPP-707">  #else</front>
<front id="plannerCPP-708">    if (block-&gt;steps[X_AXIS]) enable_x();</front>
<front id="plannerCPP-709">    if (block-&gt;steps[Y_AXIS]) enable_y();</front>
<front id="plannerCPP-710">    #if DISABLED(Z_LATE_ENABLE)</front>
<front id="plannerCPP-711">      if (block-&gt;steps[Z_AXIS]) enable_z();</front>
<front id="plannerCPP-712">    #endif</front>
<front id="plannerCPP-713">  #endif</front>
<front id="plannerCPP-714"></front>
<front id="plannerCPP-715">  // Enable extruder(s)</front>
<front id="plannerCPP-716">  if (block-&gt;steps[E_AXIS]) {</front>
<front id="plannerCPP-717">    if (DISABLE_INACTIVE_EXTRUDER) { //enable only selected extruder</front>
<front id="plannerCPP-718"></front>
<front id="plannerCPP-719">      for (int i=0; i&lt;EXTRUDERS; i++)</front>
<front id="plannerCPP-720">        if (g_uc_extruder_last_move[i] &gt; 0) g_uc_extruder_last_move[i]--;</front>
<front id="plannerCPP-721"></front>
<front id="plannerCPP-722">      switch(extruder) {</front>
<front id="plannerCPP-723">        case 0:</front>
<front id="plannerCPP-724">          enable_e0();</front>
<front id="plannerCPP-725">          g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-726">          #if EXTRUDERS &gt; 1</front>
<front id="plannerCPP-727">            if (g_uc_extruder_last_move[1] == 0) disable_e1();</front>
<front id="plannerCPP-728">            #if EXTRUDERS &gt; 2</front>
<front id="plannerCPP-729">              if (g_uc_extruder_last_move[2] == 0) disable_e2();</front>
<front id="plannerCPP-730">              #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-731">                if (g_uc_extruder_last_move[3] == 0) disable_e3();</front>
<front id="plannerCPP-732">              #endif</front>
<front id="plannerCPP-733">            #endif</front>
<front id="plannerCPP-734">          #endif</front>
<front id="plannerCPP-735">        break;</front>
<front id="plannerCPP-736">        #if EXTRUDERS &gt; 1</front>
<front id="plannerCPP-737">          case 1:</front>
<front id="plannerCPP-738">            enable_e1();</front>
<front id="plannerCPP-739">            g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-740">            if (g_uc_extruder_last_move[0] == 0) disable_e0();</front>
<front id="plannerCPP-741">            #if EXTRUDERS &gt; 2</front>
<front id="plannerCPP-742">              if (g_uc_extruder_last_move[2] == 0) disable_e2();</front>
<front id="plannerCPP-743">              #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-744">                if (g_uc_extruder_last_move[3] == 0) disable_e3();</front>
<front id="plannerCPP-745">              #endif</front>
<front id="plannerCPP-746">            #endif</front>
<front id="plannerCPP-747">          break;</front>
<front id="plannerCPP-748">          #if EXTRUDERS &gt; 2</front>
<front id="plannerCPP-749">            case 2:</front>
<front id="plannerCPP-750">              enable_e2();</front>
<front id="plannerCPP-751">              g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-752">              if (g_uc_extruder_last_move[0] == 0) disable_e0();</front>
<front id="plannerCPP-753">              if (g_uc_extruder_last_move[1] == 0) disable_e1();</front>
<front id="plannerCPP-754">              #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-755">                if (g_uc_extruder_last_move[3] == 0) disable_e3();</front>
<front id="plannerCPP-756">              #endif</front>
<front id="plannerCPP-757">            break;</front>
<front id="plannerCPP-758">            #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-759">              case 3:</front>
<front id="plannerCPP-760">                enable_e3();</front>
<front id="plannerCPP-761">                g_uc_extruder_last_move[3] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-762">                if (g_uc_extruder_last_move[0] == 0) disable_e0();</front>
<front id="plannerCPP-763">                if (g_uc_extruder_last_move[1] == 0) disable_e1();</front>
<front id="plannerCPP-764">                if (g_uc_extruder_last_move[2] == 0) disable_e2();</front>
<front id="plannerCPP-765">              break;</front>
<front id="plannerCPP-766">            #endif // EXTRUDERS &gt; 3</front>
<front id="plannerCPP-767">          #endif // EXTRUDERS &gt; 2</front>
<front id="plannerCPP-768">        #endif // EXTRUDERS &gt; 1</front>
<front id="plannerCPP-769">      }</front>
<front id="plannerCPP-770">    }</front>
<front id="plannerCPP-771">    else { // enable all</front>
<front id="plannerCPP-772">      enable_e0();</front>
<front id="plannerCPP-773">      enable_e1();</front>
<front id="plannerCPP-774">      enable_e2();</front>
<front id="plannerCPP-775">      enable_e3();</front>
<front id="plannerCPP-776">    }</front>
<front id="plannerCPP-777">  }</front>
<front id="plannerCPP-778"></front>
<front id="plannerCPP-779">  if (block-&gt;steps[E_AXIS])</front>
<front id="plannerCPP-780">    NOLESS(feed_rate, minimumfeedrate);</front>
<front id="plannerCPP-781">  else</front>
<front id="plannerCPP-782">    NOLESS(feed_rate, mintravelfeedrate);</front>
<front id="plannerCPP-783"></front>
<front id="plannerCPP-784">  /**</front>
<front id="plannerCPP-785">   * This part of the code calculates the total length of the movement.</front>
<front id="plannerCPP-786">   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.</front>
<front id="plannerCPP-787">   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS</front>
<front id="plannerCPP-788">   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.</front>
<front id="plannerCPP-789">   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.</front>
<front id="plannerCPP-790">   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.</front>
<front id="plannerCPP-791">   */</front>
<front id="plannerCPP-792">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-793">    float delta_mm[6];</front>
<front id="plannerCPP-794">    delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-795">    delta_mm[Y_HEAD] = dy / axis_steps_per_unit[B_AXIS];</front>
<front id="plannerCPP-796">    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];</front>
<front id="plannerCPP-797">    delta_mm[A_AXIS] = (dx + dy) / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-798">    delta_mm[B_AXIS] = (dx - dy) / axis_steps_per_unit[B_AXIS];</front>
<front id="plannerCPP-799">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-800">    float delta_mm[6];</front>
<front id="plannerCPP-801">    delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-802">    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];</front>
<front id="plannerCPP-803">    delta_mm[Z_HEAD] = dz / axis_steps_per_unit[C_AXIS];</front>
<front id="plannerCPP-804">    delta_mm[A_AXIS] = (dx + dz) / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-805">    delta_mm[C_AXIS] = (dx - dz) / axis_steps_per_unit[C_AXIS];</front>
<front id="plannerCPP-806">  #else</front>
<front id="plannerCPP-807">    float delta_mm[4];</front>
<front id="plannerCPP-808">    delta_mm[X_AXIS] = dx / axis_steps_per_unit[X_AXIS];</front>
<front id="plannerCPP-809">    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];</front>
<front id="plannerCPP-810">    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];</front>
<front id="plannerCPP-811">  #endif</front>
<front id="plannerCPP-812">  delta_mm[E_AXIS] = (de / axis_steps_per_unit[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder] / 100.0;</front>
<front id="plannerCPP-813"></front>
<front id="plannerCPP-814">  if (block-&gt;steps[X_AXIS] &lt;= dropsegments && block-&gt;steps[Y_AXIS] &lt;= dropsegments && block-&gt;steps[Z_AXIS] &lt;= dropsegments) {</front>
<front id="plannerCPP-815">    block-&gt;millimeters = fabs(delta_mm[E_AXIS]);</front>
<front id="plannerCPP-816">  }</front>
<front id="plannerCPP-817">  else {</front>
<front id="plannerCPP-818">    block-&gt;millimeters = sqrt(</front>
<front id="plannerCPP-819">      #if ENABLED(COREXY)</front>
<front id="plannerCPP-820">        square(delta_mm[X_HEAD]) + square(delta_mm[Y_HEAD]) + square(delta_mm[Z_AXIS])</front>
<front id="plannerCPP-821">      #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-822">        square(delta_mm[X_HEAD]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_HEAD])</front>
<front id="plannerCPP-823">      #else</front>
<front id="plannerCPP-824">        square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS])</front>
<front id="plannerCPP-825">      #endif</front>
<front id="plannerCPP-826">    );</front>
<front id="plannerCPP-827">  }</front>
<front id="plannerCPP-828">  float inverse_millimeters = 1.0 / block-&gt;millimeters;  // Inverse millimeters to remove multiple divides</front>
<front id="plannerCPP-829"></front>
<front id="plannerCPP-830">  // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.</front>
<front id="plannerCPP-831">  float inverse_second = feed_rate * inverse_millimeters;</front>
<front id="plannerCPP-832"></front>
<front id="plannerCPP-833">  int moves_queued = movesplanned();</front>
<front id="plannerCPP-834"></front>
<front id="plannerCPP-835">  // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill</front>
<front id="plannerCPP-836">  #if ENABLED(OLD_SLOWDOWN) || ENABLED(SLOWDOWN)</front>
<front id="plannerCPP-837">    bool mq = moves_queued &gt; 1 && moves_queued &lt; BLOCK_BUFFER_SIZE / 2;</front>
<front id="plannerCPP-838">    #if ENABLED(OLD_SLOWDOWN)</front>
<front id="plannerCPP-839">      if (mq) feed_rate *= 2.0 * moves_queued / BLOCK_BUFFER_SIZE;</front>
<front id="plannerCPP-840">    #endif</front>
<front id="plannerCPP-841">    #if ENABLED(SLOWDOWN)</front>
<front id="plannerCPP-842">      //  segment time im micro seconds</front>
<front id="plannerCPP-843">      unsigned long segment_time = lround(1000000.0/inverse_second);</front>
<front id="plannerCPP-844">      if (mq) {</front>
<front id="plannerCPP-845">        if (segment_time &lt; minsegmenttime) {</front>
<front id="plannerCPP-846">          // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.</front>
<front id="plannerCPP-847">          inverse_second = 1000000.0 / (segment_time + lround(2 * (minsegmenttime - segment_time) / moves_queued));</front>
<front id="plannerCPP-848">          #ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-849">            segment_time = lround(1000000.0 / inverse_second);</front>
<front id="plannerCPP-850">          #endif</front>
<front id="plannerCPP-851">        }</front>
<front id="plannerCPP-852">      }</front>
<front id="plannerCPP-853">    #endif</front>
<front id="plannerCPP-854">  #endif</front>
<front id="plannerCPP-855"></front>
<front id="plannerCPP-856">  block-&gt;nominal_speed = block-&gt;millimeters * inverse_second; // (mm/sec) Always &gt; 0</front>
<front id="plannerCPP-857">  block-&gt;nominal_rate = ceil(block-&gt;step_event_count * inverse_second); // (step/sec) Always &gt; 0</front>
<front id="plannerCPP-858"></front>
<front id="plannerCPP-859">  #if ENABLED(FILAMENT_SENSOR)</front>
<front id="plannerCPP-860">    //FMM update ring buffer used for delay with filament measurements</front>
<front id="plannerCPP-861"></front>
<front id="plannerCPP-862">    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && delay_index2 &gt; -1) {  //only for extruder with filament sensor and if ring buffer is initialized</front>
<front id="plannerCPP-863"></front>
<front id="plannerCPP-864">      const int MMD = MAX_MEASUREMENT_DELAY + 1, MMD10 = MMD * 10;</front>
<front id="plannerCPP-865"></front>
<front id="plannerCPP-866">      delay_dist += delta_mm[E_AXIS];  // increment counter with next move in e axis</front>
<front id="plannerCPP-867">      while (delay_dist &gt;= MMD10) delay_dist -= MMD10; // loop around the buffer</front>
<front id="plannerCPP-868">      while (delay_dist &lt; 0) delay_dist += MMD10;</front>
<front id="plannerCPP-869"></front>
<front id="plannerCPP-870">      delay_index1 = delay_dist / 10.0;  // calculate index</front>
<front id="plannerCPP-871">      delay_index1 = constrain(delay_index1, 0, MAX_MEASUREMENT_DELAY); // (already constrained above)</front>
<front id="plannerCPP-872"></front>
<front id="plannerCPP-873">      if (delay_index1 != delay_index2) { // moved index</front>
<front id="plannerCPP-874">        meas_sample = widthFil_to_size_ratio() - 100;  // Subtract 100 to reduce magnitude - to store in a signed char</front>
<front id="plannerCPP-875">        while (delay_index1 != delay_index2) {</front>
<front id="plannerCPP-876">          // Increment and loop around buffer</front>
<front id="plannerCPP-877">          if (++delay_index2 &gt;= MMD) delay_index2 -= MMD;</front>
<front id="plannerCPP-878">          delay_index2 = constrain(delay_index2, 0, MAX_MEASUREMENT_DELAY);</front>
<front id="plannerCPP-879">          measurement_delay[delay_index2] = meas_sample;</front>
<front id="plannerCPP-880">        }</front>
<front id="plannerCPP-881">      }</front>
<front id="plannerCPP-882">    }</front>
<front id="plannerCPP-883">  #endif</front>
<front id="plannerCPP-884"></front>
<front id="plannerCPP-885">  // Calculate and limit speed in mm/sec for each axis</front>
<front id="plannerCPP-886">  float current_speed[NUM_AXIS];</front>
<front id="plannerCPP-887">  float speed_factor = 1.0; //factor &lt;=1 do decrease speed</front>
<front id="plannerCPP-888">  for (int i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="plannerCPP-889">    current_speed[i] = delta_mm[i] * inverse_second;</front>
<front id="plannerCPP-890">    float cs = fabs(current_speed[i]), mf = max_feedrate[i];</front>
<front id="plannerCPP-891">    if (cs &gt; mf) speed_factor = min(speed_factor, mf / cs);</front>
<front id="plannerCPP-892">  }</front>
<front id="plannerCPP-893"></front>
<front id="plannerCPP-894">  // Max segement time in us.</front>
<front id="plannerCPP-895">  #ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-896"></front>
<front id="plannerCPP-897">    // Check and limit the xy direction change frequency</front>
<front id="plannerCPP-898">    unsigned char direction_change = block-&gt;direction_bits ^ old_direction_bits;</front>
<front id="plannerCPP-899">    old_direction_bits = block-&gt;direction_bits;</front>
<front id="plannerCPP-900">    segment_time = lround((float)segment_time / speed_factor);</front>
<front id="plannerCPP-901"></front>
<front id="plannerCPP-902">    long xs0 = axis_segment_time[X_AXIS][0],</front>
<front id="plannerCPP-903">         xs1 = axis_segment_time[X_AXIS][1],</front>
<front id="plannerCPP-904">         xs2 = axis_segment_time[X_AXIS][2],</front>
<front id="plannerCPP-905">         ys0 = axis_segment_time[Y_AXIS][0],</front>
<front id="plannerCPP-906">         ys1 = axis_segment_time[Y_AXIS][1],</front>
<front id="plannerCPP-907">         ys2 = axis_segment_time[Y_AXIS][2];</front>
<front id="plannerCPP-908"></front>
<front id="plannerCPP-909">    if ((direction_change & BIT(X_AXIS)) != 0) {</front>
<front id="plannerCPP-910">      xs2 = axis_segment_time[X_AXIS][2] = xs1;</front>
<front id="plannerCPP-911">      xs1 = axis_segment_time[X_AXIS][1] = xs0;</front>
<front id="plannerCPP-912">      xs0 = 0;</front>
<front id="plannerCPP-913">    }</front>
<front id="plannerCPP-914">    xs0 = axis_segment_time[X_AXIS][0] = xs0 + segment_time;</front>
<front id="plannerCPP-915"></front>
<front id="plannerCPP-916">    if ((direction_change & BIT(Y_AXIS)) != 0) {</front>
<front id="plannerCPP-917">      ys2 = axis_segment_time[Y_AXIS][2] = axis_segment_time[Y_AXIS][1];</front>
<front id="plannerCPP-918">      ys1 = axis_segment_time[Y_AXIS][1] = axis_segment_time[Y_AXIS][0];</front>
<front id="plannerCPP-919">      ys0 = 0;</front>
<front id="plannerCPP-920">    }</front>
<front id="plannerCPP-921">    ys0 = axis_segment_time[Y_AXIS][0] = ys0 + segment_time;</front>
<front id="plannerCPP-922"></front>
<front id="plannerCPP-923">    long max_x_segment_time = max(xs0, max(xs1, xs2)),</front>
<front id="plannerCPP-924">         max_y_segment_time = max(ys0, max(ys1, ys2)),</front>
<front id="plannerCPP-925">         min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);</front>
<front id="plannerCPP-926">    if (min_xy_segment_time &lt; MAX_FREQ_TIME) {</front>
<front id="plannerCPP-927">      float low_sf = speed_factor * min_xy_segment_time / MAX_FREQ_TIME;</front>
<front id="plannerCPP-928">      speed_factor = min(speed_factor, low_sf);</front>
<front id="plannerCPP-929">    }</front>
<front id="plannerCPP-930">  #endif // XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-931"></front>
<front id="plannerCPP-932">  // Correct the speed</front>
<front id="plannerCPP-933">  if (speed_factor &lt; 1.0) {</front>
<front id="plannerCPP-934">    for (unsigned char i = 0; i &lt; NUM_AXIS; i++) current_speed[i] *= speed_factor;</front>
<front id="plannerCPP-935">    block-&gt;nominal_speed *= speed_factor;</front>
<front id="plannerCPP-936">    block-&gt;nominal_rate *= speed_factor;</front>
<front id="plannerCPP-937">  }</front>
<front id="plannerCPP-938"></front>
<front id="plannerCPP-939">  // Compute and limit the acceleration rate for the trapezoid generator.</front>
<front id="plannerCPP-940">  float steps_per_mm = block-&gt;step_event_count / block-&gt;millimeters;</front>
<front id="plannerCPP-941">  long bsx = block-&gt;steps[X_AXIS], bsy = block-&gt;steps[Y_AXIS], bsz = block-&gt;steps[Z_AXIS], bse = block-&gt;steps[E_AXIS];</front>
<front id="plannerCPP-942">  if (bsx == 0 && bsy == 0 && bsz == 0) {</front>
<front id="plannerCPP-943">    block-&gt;acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-944">  }</front>
<front id="plannerCPP-945">  else if (bse == 0) {</front>
<front id="plannerCPP-946">    block-&gt;acceleration_st = ceil(travel_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-947">  }</front>
<front id="plannerCPP-948">  else {</front>
<front id="plannerCPP-949">    block-&gt;acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-950">  }</front>
<front id="plannerCPP-951">  // Limit acceleration per axis</front>
<front id="plannerCPP-952">  unsigned long acc_st = block-&gt;acceleration_st,</front>
<front id="plannerCPP-953">                xsteps = axis_steps_per_sqr_second[X_AXIS],</front>
<front id="plannerCPP-954">                ysteps = axis_steps_per_sqr_second[Y_AXIS],</front>
<front id="plannerCPP-955">                zsteps = axis_steps_per_sqr_second[Z_AXIS],</front>
<front id="plannerCPP-956">                esteps = axis_steps_per_sqr_second[E_AXIS];</front>
<front id="plannerCPP-957">  if ((float)acc_st * bsx / block-&gt;step_event_count &gt; xsteps) acc_st = xsteps;</front>
<front id="plannerCPP-958">  if ((float)acc_st * bsy / block-&gt;step_event_count &gt; ysteps) acc_st = ysteps;</front>
<front id="plannerCPP-959">  if ((float)acc_st * bsz / block-&gt;step_event_count &gt; zsteps) acc_st = zsteps;</front>
<front id="plannerCPP-960">  if ((float)acc_st * bse / block-&gt;step_event_count &gt; esteps) acc_st = esteps;</front>
<front id="plannerCPP-961"></front>
<front id="plannerCPP-962">  block-&gt;acceleration_st = acc_st;</front>
<front id="plannerCPP-963">  block-&gt;acceleration = acc_st / steps_per_mm;</front>
<front id="plannerCPP-964">  block-&gt;acceleration_rate = (long)(acc_st * 16777216.0 / (F_CPU / 8.0));</front>
<front id="plannerCPP-965"></front>
<front id="plannerCPP-966">  #if 0  // Use old jerk for now</front>
<front id="plannerCPP-967">    // Compute path unit vector</front>
<front id="plannerCPP-968">    double unit_vec[3];</front>
<front id="plannerCPP-969"></front>
<front id="plannerCPP-970">    unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-971">    unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-972">    unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-973"></front>
<front id="plannerCPP-974">    // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.</front>
<front id="plannerCPP-975">    // Let a circle be tangent to both previous and current path line segments, where the junction</front>
<front id="plannerCPP-976">    // deviation is defined as the distance from the junction to the closest edge of the circle,</front>
<front id="plannerCPP-977">    // colinear with the circle center. The circular segment joining the two paths represents the</front>
<front id="plannerCPP-978">    // path of centripetal acceleration. Solve for max velocity based on max acceleration about the</front>
<front id="plannerCPP-979">    // radius of the circle, defined indirectly by junction deviation. This may be also viewed as</front>
<front id="plannerCPP-980">    // path width or max_jerk in the previous grbl version. This approach does not actually deviate</front>
<front id="plannerCPP-981">    // from path, but used as a robust way to compute cornering speeds, as it takes into account the</front>
<front id="plannerCPP-982">    // nonlinearities of both the junction angle and junction velocity.</front>
<front id="plannerCPP-983">    double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed</front>
<front id="plannerCPP-984"></front>
<front id="plannerCPP-985">    // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.</front>
<front id="plannerCPP-986">    if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed &gt; 0.0)) {</front>
<front id="plannerCPP-987">      // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)</front>
<front id="plannerCPP-988">      // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.</front>
<front id="plannerCPP-989">      double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]</front>
<front id="plannerCPP-990">        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]</front>
<front id="plannerCPP-991">        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;</front>
<front id="plannerCPP-992"></front>
<front id="plannerCPP-993">      // Skip and use default max junction speed for 0 degree acute junction.</front>
<front id="plannerCPP-994">      if (cos_theta &lt; 0.95) {</front>
<front id="plannerCPP-995">        vmax_junction = min(previous_nominal_speed,block-&gt;nominal_speed);</front>
<front id="plannerCPP-996">        // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.</front>
<front id="plannerCPP-997">        if (cos_theta &gt; -0.95) {</front>
<front id="plannerCPP-998">          // Compute maximum junction velocity based on maximum acceleration and junction deviation</front>
<front id="plannerCPP-999">          double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.</front>
<front id="plannerCPP-1000">          vmax_junction = min(vmax_junction,</front>
<front id="plannerCPP-1001">          sqrt(block-&gt;acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );</front>
<front id="plannerCPP-1002">        }</front>
<front id="plannerCPP-1003">      }</front>
<front id="plannerCPP-1004">    }</front>
<front id="plannerCPP-1005">  #endif</front>
<front id="plannerCPP-1006"></front>
<front id="plannerCPP-1007">  // Start with a safe speed</front>
<front id="plannerCPP-1008">  float vmax_junction = max_xy_jerk / 2;</front>
<front id="plannerCPP-1009">  float vmax_junction_factor = 1.0;</front>
<front id="plannerCPP-1010">  float mz2 = max_z_jerk / 2, me2 = max_e_jerk / 2;</front>
<front id="plannerCPP-1011">  float csz = current_speed[Z_AXIS], cse = current_speed[E_AXIS];</front>
<front id="plannerCPP-1012">  if (fabs(csz) &gt; mz2) vmax_junction = min(vmax_junction, mz2);</front>
<front id="plannerCPP-1013">  if (fabs(cse) &gt; me2) vmax_junction = min(vmax_junction, me2);</front>
<front id="plannerCPP-1014">  vmax_junction = min(vmax_junction, block-&gt;nominal_speed);</front>
<front id="plannerCPP-1015">  float safe_speed = vmax_junction;</front>
<front id="plannerCPP-1016"></front>
<front id="plannerCPP-1017">  if ((moves_queued &gt; 1) && (previous_nominal_speed &gt; 0.0001)) {</front>
<front id="plannerCPP-1018">    float dx = current_speed[X_AXIS] - previous_speed[X_AXIS],</front>
<front id="plannerCPP-1019">          dy = current_speed[Y_AXIS] - previous_speed[Y_AXIS],</front>
<front id="plannerCPP-1020">          dz = fabs(csz - previous_speed[Z_AXIS]),</front>
<front id="plannerCPP-1021">          de = fabs(cse - previous_speed[E_AXIS]),</front>
<front id="plannerCPP-1022">          jerk = sqrt(dx * dx + dy * dy);</front>
<front id="plannerCPP-1023"></front>
<front id="plannerCPP-1024">    //    if ((fabs(previous_speed[X_AXIS]) &gt; 0.0001) || (fabs(previous_speed[Y_AXIS]) &gt; 0.0001)) {</front>
<front id="plannerCPP-1025">    vmax_junction = block-&gt;nominal_speed;</front>
<front id="plannerCPP-1026">    //    }</front>
<front id="plannerCPP-1027">    if (jerk &gt; max_xy_jerk) vmax_junction_factor = max_xy_jerk / jerk;</front>
<front id="plannerCPP-1028">    if (dz &gt; max_z_jerk) vmax_junction_factor = min(vmax_junction_factor, max_z_jerk / dz);</front>
<front id="plannerCPP-1029">    if (de &gt; max_e_jerk) vmax_junction_factor = min(vmax_junction_factor, max_e_jerk / de);</front>
<front id="plannerCPP-1030"></front>
<front id="plannerCPP-1031">    vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed</front>
<front id="plannerCPP-1032">  }</front>
<front id="plannerCPP-1033">  block-&gt;max_entry_speed = vmax_junction;</front>
<front id="plannerCPP-1034"></front>
<front id="plannerCPP-1035">  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.</front>
<front id="plannerCPP-1036">  double v_allowable = max_allowable_speed(-block-&gt;acceleration, MINIMUM_PLANNER_SPEED, block-&gt;millimeters);</front>
<front id="plannerCPP-1037">  block-&gt;entry_speed = min(vmax_junction, v_allowable);</front>
<front id="plannerCPP-1038"></front>
<front id="plannerCPP-1039">  // Initialize planner efficiency flags</front>
<front id="plannerCPP-1040">  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.</front>
<front id="plannerCPP-1041">  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then</front>
<front id="plannerCPP-1042">  // the current block and next block junction speeds are guaranteed to always be at their maximum</front>
<front id="plannerCPP-1043">  // junction speeds in deceleration and acceleration, respectively. This is due to how the current</front>
<front id="plannerCPP-1044">  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both</front>
<front id="plannerCPP-1045">  // the reverse and forward planners, the corresponding block junction speed will always be at the</front>
<front id="plannerCPP-1046">  // the maximum junction speed and may always be ignored for any speed reduction checks.</front>
<front id="plannerCPP-1047">  block-&gt;nominal_length_flag = (block-&gt;nominal_speed &lt;= v_allowable);</front>
<front id="plannerCPP-1048">  block-&gt;recalculate_flag = true; // Always calculate trapezoid for new block</front>
<front id="plannerCPP-1049"></front>
<front id="plannerCPP-1050">  // Update previous path unit_vector and nominal speed</front>
<front id="plannerCPP-1051">  for (int i = 0; i &lt; NUM_AXIS; i++) previous_speed[i] = current_speed[i];</front>
<front id="plannerCPP-1052">  previous_nominal_speed = block-&gt;nominal_speed;</front>
<front id="plannerCPP-1053"></front>
<front id="plannerCPP-1054">  #if ENABLED(ADVANCE)</front>
<front id="plannerCPP-1055">    // Calculate advance rate</front>
<front id="plannerCPP-1056">    if (!bse || (!bsx && !bsy && !bsz)) {</front>
<front id="plannerCPP-1057">      block-&gt;advance_rate = 0;</front>
<front id="plannerCPP-1058">      block-&gt;advance = 0;</front>
<front id="plannerCPP-1059">    }</front>
<front id="plannerCPP-1060">    else {</front>
<front id="plannerCPP-1061">      long acc_dist = estimate_acceleration_distance(0, block-&gt;nominal_rate, block-&gt;acceleration_st);</front>
<front id="plannerCPP-1062">      float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * (cse * cse * EXTRUSION_AREA * EXTRUSION_AREA) * 256;</front>
<front id="plannerCPP-1063">      block-&gt;advance = advance;</front>
<front id="plannerCPP-1064">      block-&gt;advance_rate = acc_dist ? advance / (float)acc_dist : 0;</front>
<front id="plannerCPP-1065">    }</front>
<front id="plannerCPP-1066">    /*</front>
<front id="plannerCPP-1067">      SERIAL_ECHO_START;</front>
<front id="plannerCPP-1068">     SERIAL_ECHOPGM("advance :");</front>
<front id="plannerCPP-1069">     SERIAL_ECHO(block-&gt;advance/256.0);</front>
<front id="plannerCPP-1070">     SERIAL_ECHOPGM("advance rate :");</front>
<front id="plannerCPP-1071">     SERIAL_ECHOLN(block-&gt;advance_rate/256.0);</front>
<front id="plannerCPP-1072">     */</front>
<front id="plannerCPP-1073">  #endif // ADVANCE</front>
<front id="plannerCPP-1074"></front>
<front id="plannerCPP-1075">  calculate_trapezoid_for_block(block, block-&gt;entry_speed / block-&gt;nominal_speed, safe_speed / block-&gt;nominal_speed);</front>
<front id="plannerCPP-1076"></front>
<front id="plannerCPP-1077">  // Move buffer head</front>
<front id="plannerCPP-1078">  block_buffer_head = next_buffer_head;</front>
<front id="plannerCPP-1079"></front>
<front id="plannerCPP-1080">  // Update position</front>
<front id="plannerCPP-1081">  for (int i = 0; i &lt; NUM_AXIS; i++) position[i] = target[i];</front>
<front id="plannerCPP-1082"></front>
<front id="plannerCPP-1083">  planner_recalculate();</front>
<front id="plannerCPP-1084"></front>
<front id="plannerCPP-1085">  st_wake_up();</front>
<front id="plannerCPP-1086"></front>
<front id="plannerCPP-1087">} // plan_buffer_line()</front>
<front id="plannerCPP-1088"></front>
<front id="plannerCPP-1089">#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(DELTA)</front>
<front id="plannerCPP-1090">  vector_3 plan_get_position() {</front>
<front id="plannerCPP-1091">    vector_3 position = vector_3(st_get_position_mm(X_AXIS), st_get_position_mm(Y_AXIS), st_get_position_mm(Z_AXIS));</front>
<front id="plannerCPP-1092"></front>
<front id="plannerCPP-1093">    //position.debug("in plan_get position");</front>
<front id="plannerCPP-1094">    //plan_bed_level_matrix.debug("in plan_get_position");</front>
<front id="plannerCPP-1095">    matrix_3x3 inverse = matrix_3x3::transpose(plan_bed_level_matrix);</front>
<front id="plannerCPP-1096">    //inverse.debug("in plan_get inverse");</front>
<front id="plannerCPP-1097">    position.apply_rotation(inverse);</front>
<front id="plannerCPP-1098">    //position.debug("after rotation");</front>
<front id="plannerCPP-1099"></front>
<front id="plannerCPP-1100">    return position;</front>
<front id="plannerCPP-1101">  }</front>
<front id="plannerCPP-1102">#endif // AUTO_BED_LEVELING_FEATURE && !DELTA</front>
<front id="plannerCPP-1103"></front>
<front id="plannerCPP-1104">#if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-1105">  void plan_set_position(float x, float y, float z, const float &e)</front>
<front id="plannerCPP-1106">#else</front>
<front id="plannerCPP-1107">  void plan_set_position(const float &x, const float &y, const float &z, const float &e)</front>
<front id="plannerCPP-1108">#endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING</front>
<front id="plannerCPP-1109">  {</front>
<front id="plannerCPP-1110">    #if ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-1111">      if (mbl.active) z += mbl.get_z(x, y);</front>
<front id="plannerCPP-1112">    #elif ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerCPP-1113">      apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</front>
<front id="plannerCPP-1114">    #endif</front>
<front id="plannerCPP-1115"></front>
<front id="plannerCPP-1116">    float nx = position[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]),</front>
<front id="plannerCPP-1117">          ny = position[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]),</front>
<front id="plannerCPP-1118">          nz = position[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]),</front>
<front id="plannerCPP-1119">          ne = position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-1120">    st_set_position(nx, ny, nz, ne);</front>
<front id="plannerCPP-1121">    previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.</front>
<front id="plannerCPP-1122"></front>
<front id="plannerCPP-1123">    for (int i=0; i&lt;NUM_AXIS; i++) previous_speed[i] = 0.0;</front>
<front id="plannerCPP-1124">  }</front>
<front id="plannerCPP-1125"></front>
<front id="plannerCPP-1126">void plan_set_e_position(const float &e) {</front>
<front id="plannerCPP-1127">  position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-1128">  st_set_e_position(position[E_AXIS]);</front>
<front id="plannerCPP-1129">}</front>
<front id="plannerCPP-1130"></front>
<front id="plannerCPP-1131">// Calculate the steps/s^2 acceleration rates, based on the mm/s^s</front>
<front id="plannerCPP-1132">void reset_acceleration_rates() {</front>
<front id="plannerCPP-1133">  for (int i = 0; i &lt; NUM_AXIS; i++)</front>
<front id="plannerCPP-1134">    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];</front>
<front id="plannerCPP-1135">}</front>
 </pre>
<h1 id="ultralcdCPPtitle" >ultralcd.cpp</h1>
<pre id="ultralcdCPP"  class="prettyprint linenums"><front id="ultralcdCPP-1">#include "ultralcd.h"</front>
<front id="ultralcdCPP-2">#if ENABLED(ULTRA_LCD)</front>
<front id="ultralcdCPP-3">#include "Marlin.h"</front>
<front id="ultralcdCPP-4">#include "language.h"</front>
<front id="ultralcdCPP-5">#include "cardreader.h"</front>
<front id="ultralcdCPP-6">#include "temperature.h"</front>
<front id="ultralcdCPP-7">#include "stepper.h"</front>
<front id="ultralcdCPP-8">#include "configuration_store.h"</front>
<front id="ultralcdCPP-9"></front>
<front id="ultralcdCPP-10">int8_t encoderDiff; // updated from interrupt context and added to encoderPosition every LCD update</front>
<front id="ultralcdCPP-11"></front>
<front id="ultralcdCPP-12">bool encoderRateMultiplierEnabled;</front>
<front id="ultralcdCPP-13">int32_t lastEncoderMovementMillis;</front>
<front id="ultralcdCPP-14"></front>
<front id="ultralcdCPP-15">int plaPreheatHotendTemp;</front>
<front id="ultralcdCPP-16">int plaPreheatHPBTemp;</front>
<front id="ultralcdCPP-17">int plaPreheatFanSpeed;</front>
<front id="ultralcdCPP-18"></front>
<front id="ultralcdCPP-19">int absPreheatHotendTemp;</front>
<front id="ultralcdCPP-20">int absPreheatHPBTemp;</front>
<front id="ultralcdCPP-21">int absPreheatFanSpeed;</front>
<front id="ultralcdCPP-22"></front>
<front id="ultralcdCPP-23">#if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdCPP-24">  millis_t previous_lcd_status_ms = 0;</front>
<front id="ultralcdCPP-25">#endif</front>
<front id="ultralcdCPP-26"></front>
<front id="ultralcdCPP-27">// Function pointer to menu functions.</front>
<front id="ultralcdCPP-28">typedef void (*menuFunc_t)();</front>
<front id="ultralcdCPP-29"></front>
<front id="ultralcdCPP-30">uint8_t lcd_status_message_level;</front>
<front id="ultralcdCPP-31">char lcd_status_message[3*LCD_WIDTH+1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1</front>
<front id="ultralcdCPP-32"></front>
<front id="ultralcdCPP-33">#if ENABLED(DOGLCD)</front>
<front id="ultralcdCPP-34">  #include "dogm_lcd_implementation.h"</front>
<front id="ultralcdCPP-35">#else</front>
<front id="ultralcdCPP-36">  #include "ultralcd_implementation_hitachi_HD44780.h"</front>
<front id="ultralcdCPP-37">#endif</front>
<front id="ultralcdCPP-38"></front>
<front id="ultralcdCPP-39">// The main status screen</front>
<front id="ultralcdCPP-40">static void lcd_status_screen();</front>
<front id="ultralcdCPP-41"></front>
<front id="ultralcdCPP-42">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-43"></front>
<front id="ultralcdCPP-44">  #if HAS_POWER_SWITCH</front>
<front id="ultralcdCPP-45">    extern bool powersupply;</front>
<front id="ultralcdCPP-46">  #endif</front>
<front id="ultralcdCPP-47">  const float manual_feedrate[] = MANUAL_FEEDRATE;</front>
<front id="ultralcdCPP-48">  static void lcd_main_menu();</front>
<front id="ultralcdCPP-49">  static void lcd_tune_menu();</front>
<front id="ultralcdCPP-50">  static void lcd_prepare_menu();</front>
<front id="ultralcdCPP-51">  static void lcd_move_menu();</front>
<front id="ultralcdCPP-52">  static void lcd_control_menu();</front>
<front id="ultralcdCPP-53">  static void lcd_control_temperature_menu();</front>
<front id="ultralcdCPP-54">  static void lcd_control_temperature_preheat_pla_settings_menu();</front>
<front id="ultralcdCPP-55">  static void lcd_control_temperature_preheat_abs_settings_menu();</front>
<front id="ultralcdCPP-56">  static void lcd_control_motion_menu();</front>
<front id="ultralcdCPP-57">  static void lcd_control_volumetric_menu();</front>
<front id="ultralcdCPP-58"></front>
<front id="ultralcdCPP-59">  #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-60">    static void lcd_set_contrast();</front>
<front id="ultralcdCPP-61">  #endif</front>
<front id="ultralcdCPP-62"></front>
<front id="ultralcdCPP-63">  #if ENABLED(FWRETRACT)</front>
<front id="ultralcdCPP-64">    static void lcd_control_retract_menu();</front>
<front id="ultralcdCPP-65">  #endif</front>
<front id="ultralcdCPP-66"></front>
<front id="ultralcdCPP-67">  #if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-68">    static void lcd_sdcard_resume_menu();</front>
<front id="ultralcdCPP-69">    static void lcd_sdcard_print_menu();</front>
<front id="ultralcdCPP-70">    extern float planner_disabled_below_z;</front>
<front id="ultralcdCPP-71">    extern float last_z;</front>
<front id="ultralcdCPP-72">    extern bool z_reached;</front>
<front id="ultralcdCPP-73">    extern bool layer_reached;</front>
<front id="ultralcdCPP-74">    extern bool hops;</front>
<front id="ultralcdCPP-75">    extern bool gone_up;</front>
<front id="ultralcdCPP-76">  #endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-77"></front>
<front id="ultralcdCPP-78">  #if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="ultralcdCPP-79">    static void lcd_delta_calibrate_menu();</front>
<front id="ultralcdCPP-80">  #endif</front>
<front id="ultralcdCPP-81"></front>
<front id="ultralcdCPP-82">  #if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-83">    #include "mesh_bed_leveling.h"</front>
<front id="ultralcdCPP-84">    static void _lcd_level_bed();</front>
<front id="ultralcdCPP-85">    static void _lcd_level_bed_homing();</front>
<front id="ultralcdCPP-86">    static void lcd_level_bed();</front>
<front id="ultralcdCPP-87">  #endif</front>
<front id="ultralcdCPP-88"></front>
<front id="ultralcdCPP-89">  /* Different types of actions that can be used in menu items. */</front>
<front id="ultralcdCPP-90">  static void menu_action_back(menuFunc_t data);</front>
<front id="ultralcdCPP-91">  static void menu_action_submenu(menuFunc_t data);</front>
<front id="ultralcdCPP-92">  static void menu_action_gcode(const char* pgcode);</front>
<front id="ultralcdCPP-93">  static void menu_action_function(menuFunc_t data);</front>
<front id="ultralcdCPP-94">  static void menu_action_setting_edit_bool(const char* pstr, bool* ptr);</front>
<front id="ultralcdCPP-95">  static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);</front>
<front id="ultralcdCPP-96">  static void menu_action_setting_edit_float3(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-97">  static void menu_action_setting_edit_float32(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-98">  static void menu_action_setting_edit_float43(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-99">  static void menu_action_setting_edit_float5(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-100">  static void menu_action_setting_edit_float51(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-101">  static void menu_action_setting_edit_float52(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-102">  static void menu_action_setting_edit_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue);</front>
<front id="ultralcdCPP-103">  static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-104">  static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-105">  static void menu_action_setting_edit_callback_float3(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-106">  static void menu_action_setting_edit_callback_float32(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-107">  static void menu_action_setting_edit_callback_float43(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-108">  static void menu_action_setting_edit_callback_float5(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-109">  static void menu_action_setting_edit_callback_float51(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-110">  static void menu_action_setting_edit_callback_float52(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-111">  static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-112"></front>
<front id="ultralcdCPP-113">  #if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-114">    static void lcd_sdcard_menu();</front>
<front id="ultralcdCPP-115">    static void menu_action_sdfile(const char* filename, char* longFilename);</front>
<front id="ultralcdCPP-116">    static void menu_action_sddirectory(const char* filename, char* longFilename);</front>
<front id="ultralcdCPP-117">  #endif</front>
<front id="ultralcdCPP-118"></front>
<front id="ultralcdCPP-119">  #define ENCODER_FEEDRATE_DEADZONE 10</front>
<front id="ultralcdCPP-120"></front>
<front id="ultralcdCPP-121">  #if DISABLED(LCD_I2C_VIKI)</front>
<front id="ultralcdCPP-122">    #ifndef ENCODER_STEPS_PER_MENU_ITEM</front>
<front id="ultralcdCPP-123">      #define ENCODER_STEPS_PER_MENU_ITEM 5</front>
<front id="ultralcdCPP-124">    #endif</front>
<front id="ultralcdCPP-125">    #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ultralcdCPP-126">      #define ENCODER_PULSES_PER_STEP 1</front>
<front id="ultralcdCPP-127">    #endif</front>
<front id="ultralcdCPP-128">  #else</front>
<front id="ultralcdCPP-129">    #ifndef ENCODER_STEPS_PER_MENU_ITEM</front>
<front id="ultralcdCPP-130">      #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation</front>
<front id="ultralcdCPP-131">    #endif</front>
<front id="ultralcdCPP-132">    #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ultralcdCPP-133">      #define ENCODER_PULSES_PER_STEP 1</front>
<front id="ultralcdCPP-134">    #endif</front>
<front id="ultralcdCPP-135">  #endif</front>
<front id="ultralcdCPP-136"></front>
<front id="ultralcdCPP-137"></front>
<front id="ultralcdCPP-138">  /* Helper macros for menus */</front>
<front id="ultralcdCPP-139"></front>
<front id="ultralcdCPP-140">  /**</front>
<front id="ultralcdCPP-141">   * START_MENU generates the init code for a menu function</front>
<front id="ultralcdCPP-142">   */</front>
<front id="ultralcdCPP-143">  #define START_MENU() do { \</front>
<front id="ultralcdCPP-144">    encoderRateMultiplierEnabled = false; \</front>
<front id="ultralcdCPP-145">    if (encoderPosition &gt; 0x8000) encoderPosition = 0; \</front>
<front id="ultralcdCPP-146">    uint8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \</front>
<front id="ultralcdCPP-147">    if (encoderLine &lt; currentMenuViewOffset) currentMenuViewOffset = encoderLine; \</front>
<front id="ultralcdCPP-148">    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \</front>
<front id="ultralcdCPP-149">    bool wasClicked = LCD_CLICKED, itemSelected; \</front>
<front id="ultralcdCPP-150">    for (uint8_t _drawLineNr = 0; _drawLineNr &lt; LCD_HEIGHT; _drawLineNr++, _lineNr++) { \</front>
<front id="ultralcdCPP-151">      _menuItemNr = 0;</front>
<front id="ultralcdCPP-152"></front>
<front id="ultralcdCPP-153">  /**</front>
<front id="ultralcdCPP-154">   * MENU_ITEM generates draw & handler code for a menu item, potentially calling:</front>
<front id="ultralcdCPP-155">   *</front>
<front id="ultralcdCPP-156">   *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)</front>
<front id="ultralcdCPP-157">   *   menu_action_[type](arg3...)</front>
<front id="ultralcdCPP-158">   *</front>
<front id="ultralcdCPP-159">   * Examples:</front>
<front id="ultralcdCPP-160">   *   MENU_ITEM(back, MSG_WATCH, lcd_status_screen)</front>
<front id="ultralcdCPP-161">   *     lcd_implementation_drawmenu_back(sel, row, PSTR(MSG_WATCH), lcd_status_screen)</front>
<front id="ultralcdCPP-162">   *     menu_action_back(lcd_status_screen)</front>
<front id="ultralcdCPP-163">   *</front>
<front id="ultralcdCPP-164">   *   MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause)</front>
<front id="ultralcdCPP-165">   *     lcd_implementation_drawmenu_function(sel, row, PSTR(MSG_PAUSE_PRINT), lcd_sdcard_pause)</front>
<front id="ultralcdCPP-166">   *     menu_action_function(lcd_sdcard_pause)</front>
<front id="ultralcdCPP-167">   *</front>
<front id="ultralcdCPP-168">   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-169">   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-170">   *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-171">   *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-172">   *</front>
<front id="ultralcdCPP-173">   */</front>
<front id="ultralcdCPP-174">  #define MENU_ITEM(type, label, args...) do { \</front>
<front id="ultralcdCPP-175">    if (_menuItemNr == _lineNr) { \</front>
<front id="ultralcdCPP-176">      itemSelected = encoderLine == _menuItemNr; \</front>
<front id="ultralcdCPP-177">      if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-178">        lcd_implementation_drawmenu_ ## type(itemSelected, _drawLineNr, PSTR(label), ## args); \</front>
<front id="ultralcdCPP-179">      if (wasClicked && itemSelected) { \</front>
<front id="ultralcdCPP-180">        lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-181">        menu_action_ ## type(args); \</front>
<front id="ultralcdCPP-182">        return; \</front>
<front id="ultralcdCPP-183">      } \</front>
<front id="ultralcdCPP-184">    } \</front>
<front id="ultralcdCPP-185">    _menuItemNr++; \</front>
<front id="ultralcdCPP-186">  } while(0)</front>
<front id="ultralcdCPP-187"></front>
<front id="ultralcdCPP-188">  #if ENABLED(ENCODER_RATE_MULTIPLIER)</front>
<front id="ultralcdCPP-189"></front>
<front id="ultralcdCPP-190">    //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value</front>
<front id="ultralcdCPP-191"></front>
<front id="ultralcdCPP-192">    /**</front>
<front id="ultralcdCPP-193">     * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item</front>
<front id="ultralcdCPP-194">     */</front>
<front id="ultralcdCPP-195">    #define MENU_MULTIPLIER_ITEM(type, label, args...) do { \</front>
<front id="ultralcdCPP-196">      if (_menuItemNr == _lineNr) { \</front>
<front id="ultralcdCPP-197">        itemSelected = encoderLine == _menuItemNr; \</front>
<front id="ultralcdCPP-198">        if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-199">          lcd_implementation_drawmenu_ ## type(itemSelected, _drawLineNr, PSTR(label), ## args); \</front>
<front id="ultralcdCPP-200">        if (wasClicked && itemSelected) { \</front>
<front id="ultralcdCPP-201">          lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-202">          encoderRateMultiplierEnabled = true; \</front>
<front id="ultralcdCPP-203">          lastEncoderMovementMillis = 0; \</front>
<front id="ultralcdCPP-204">          menu_action_ ## type(args); \</front>
<front id="ultralcdCPP-205">          return; \</front>
<front id="ultralcdCPP-206">        } \</front>
<front id="ultralcdCPP-207">      } \</front>
<front id="ultralcdCPP-208">      _menuItemNr++; \</front>
<front id="ultralcdCPP-209">    } while(0)</front>
<front id="ultralcdCPP-210">  #endif //ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-211"></front>
<front id="ultralcdCPP-212">  #define MENU_ITEM_DUMMY() do { _menuItemNr++; } while(0)</front>
<front id="ultralcdCPP-213">  #define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-214">  #define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-215">  #if ENABLED(ENCODER_RATE_MULTIPLIER)</front>
<front id="ultralcdCPP-216">    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-217">    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-218">  #else //!ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-219">    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-220">    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-221">  #endif //!ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-222">  #define END_MENU() \</front>
<front id="ultralcdCPP-223">      if (encoderLine &gt;= _menuItemNr) { encoderPosition = _menuItemNr * ENCODER_STEPS_PER_MENU_ITEM - 1; encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; }\</front>
<front id="ultralcdCPP-224">      if (encoderLine &gt;= currentMenuViewOffset + LCD_HEIGHT) { currentMenuViewOffset = encoderLine - LCD_HEIGHT + 1; lcdDrawUpdate = 1; _lineNr = currentMenuViewOffset - 1; _drawLineNr = -1; } \</front>
<front id="ultralcdCPP-225">      } } while(0)</front>
<front id="ultralcdCPP-226"></front>
<front id="ultralcdCPP-227">  /** Used variables to keep track of the menu */</front>
<front id="ultralcdCPP-228">  volatile uint8_t buttons;  //the last checked buttons in a bit array.</front>
<front id="ultralcdCPP-229">  #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-230">    volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shift register values</front>
<front id="ultralcdCPP-231">  #endif</front>
<front id="ultralcdCPP-232">    </front>
<front id="ultralcdCPP-233">  #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-234">    volatile uint8_t slow_buttons; // Bits of the pressed buttons.</front>
<front id="ultralcdCPP-235">  #endif</front>
<front id="ultralcdCPP-236">  uint8_t currentMenuViewOffset;              /* scroll offset in the current menu */</front>
<front id="ultralcdCPP-237">  millis_t next_button_update_ms;</front>
<front id="ultralcdCPP-238">  uint8_t lastEncoderBits;</front>
<front id="ultralcdCPP-239">  uint32_t encoderPosition;</front>
<front id="ultralcdCPP-240">  #if PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-241">    uint8_t lcd_sd_status;</front>
<front id="ultralcdCPP-242">  #endif</front>
<front id="ultralcdCPP-243"></front>
<front id="ultralcdCPP-244">#endif // ULTIPANEL</front>
<front id="ultralcdCPP-245"></front>
<front id="ultralcdCPP-246">menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */</front>
<front id="ultralcdCPP-247">millis_t next_lcd_update_ms;</front>
<front id="ultralcdCPP-248">uint8_t lcd_status_update_delay;</front>
<front id="ultralcdCPP-249">bool ignore_click = false;</front>
<front id="ultralcdCPP-250">bool wait_for_unclick;</front>
<front id="ultralcdCPP-251">uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial) */</front>
<front id="ultralcdCPP-252"></front>
<front id="ultralcdCPP-253">//prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.</front>
<front id="ultralcdCPP-254">menuFunc_t prevMenu = NULL;</front>
<front id="ultralcdCPP-255">uint16_t prevEncoderPosition;</front>
<front id="ultralcdCPP-256">//Variables used when editing values.</front>
<front id="ultralcdCPP-257">const char* editLabel;</front>
<front id="ultralcdCPP-258">void* editValue;</front>
<front id="ultralcdCPP-259">int32_t minEditValue, maxEditValue;</front>
<front id="ultralcdCPP-260">menuFunc_t callbackFunc;</front>
<front id="ultralcdCPP-261"></front>
<front id="ultralcdCPP-262">// place-holders for Ki and Kd edits</front>
<front id="ultralcdCPP-263">float raw_Ki, raw_Kd;</front>
<front id="ultralcdCPP-264"></front>
<front id="ultralcdCPP-265">/**</front>
<front id="ultralcdCPP-266"> * General function to go directly to a menu</front>
<front id="ultralcdCPP-267"> */</front>
<front id="ultralcdCPP-268">static void lcd_goto_menu(menuFunc_t menu, const bool feedback=false, const uint32_t encoder=0) {</front>
<front id="ultralcdCPP-269">  if (currentMenu != menu) {</front>
<front id="ultralcdCPP-270">    currentMenu = menu;</front>
<front id="ultralcdCPP-271">    #if ENABLED(NEWPANEL)</front>
<front id="ultralcdCPP-272">      encoderPosition = encoder;</front>
<front id="ultralcdCPP-273">      if (feedback) lcd_quick_feedback();</front>
<front id="ultralcdCPP-274">    #endif</front>
<front id="ultralcdCPP-275">    // For LCD_PROGRESS_BAR re-initialize the custom characters</front>
<front id="ultralcdCPP-276">    #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-277">      lcd_set_custom_characters(menu == lcd_status_screen);</front>
<front id="ultralcdCPP-278">    #endif</front>
<front id="ultralcdCPP-279">  }</front>
<front id="ultralcdCPP-280">}</front>
<front id="ultralcdCPP-281"></front>
<front id="ultralcdCPP-282">/**</front>
<front id="ultralcdCPP-283"> *</front>
<front id="ultralcdCPP-284"> * "Info Screen"</front>
<front id="ultralcdCPP-285"> *</front>
<front id="ultralcdCPP-286"> * This is very display-dependent, so the lcd implementation draws this.</front>
<front id="ultralcdCPP-287"> */</front>
<front id="ultralcdCPP-288"></front>
<front id="ultralcdCPP-289">static void lcd_status_screen() {</front>
<front id="ultralcdCPP-290">	encoderRateMultiplierEnabled = false;</front>
<front id="ultralcdCPP-291"></front>
<front id="ultralcdCPP-292">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-293">    millis_t ms = millis();</front>
<front id="ultralcdCPP-294">    #if DISABLED(PROGRESS_MSG_ONCE)</front>
<front id="ultralcdCPP-295">      if (ms &gt; progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME) {</front>
<front id="ultralcdCPP-296">        progress_bar_ms = ms;</front>
<front id="ultralcdCPP-297">      }</front>
<front id="ultralcdCPP-298">    #endif</front>
<front id="ultralcdCPP-299">    #if PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdCPP-300">      // Handle message expire</front>
<front id="ultralcdCPP-301">      if (expire_status_ms &gt; 0) {</front>
<front id="ultralcdCPP-302">        #if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-303">          if (card.isFileOpen()) {</front>
<front id="ultralcdCPP-304">            // Expire the message when printing is active</front>
<front id="ultralcdCPP-305">            if (IS_SD_PRINTING) {</front>
<front id="ultralcdCPP-306">              if (ms &gt;= expire_status_ms) {</front>
<front id="ultralcdCPP-307">                lcd_status_message[0] = '\0';</front>
<front id="ultralcdCPP-308">                expire_status_ms = 0;</front>
<front id="ultralcdCPP-309">              }</front>
<front id="ultralcdCPP-310">            }</front>
<front id="ultralcdCPP-311">            else {</front>
<front id="ultralcdCPP-312">              expire_status_ms += LCD_UPDATE_INTERVAL;</front>
<front id="ultralcdCPP-313">            }</front>
<front id="ultralcdCPP-314">          }</front>
<front id="ultralcdCPP-315">          else {</front>
<front id="ultralcdCPP-316">            expire_status_ms = 0;</front>
<front id="ultralcdCPP-317">          }</front>
<front id="ultralcdCPP-318">        #else</front>
<front id="ultralcdCPP-319">          expire_status_ms = 0;</front>
<front id="ultralcdCPP-320">        #endif //SDSUPPORT</front>
<front id="ultralcdCPP-321">      }</front>
<front id="ultralcdCPP-322">    #endif</front>
<front id="ultralcdCPP-323">  #endif //LCD_PROGRESS_BAR</front>
<front id="ultralcdCPP-324"></front>
<front id="ultralcdCPP-325">  lcd_implementation_status_screen();</front>
<front id="ultralcdCPP-326"></front>
<front id="ultralcdCPP-327">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-328"></front>
<front id="ultralcdCPP-329">    bool current_click = LCD_CLICKED;</front>
<front id="ultralcdCPP-330"></front>
<front id="ultralcdCPP-331">    if (ignore_click) {</front>
<front id="ultralcdCPP-332">      if (wait_for_unclick) {</front>
<front id="ultralcdCPP-333">        if (!current_click)</front>
<front id="ultralcdCPP-334">          ignore_click = wait_for_unclick = false;</front>
<front id="ultralcdCPP-335">        else</front>
<front id="ultralcdCPP-336">          current_click = false;</front>
<front id="ultralcdCPP-337">      }</front>
<front id="ultralcdCPP-338">      else if (current_click) {</front>
<front id="ultralcdCPP-339">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-340">        wait_for_unclick = true;</front>
<front id="ultralcdCPP-341">        current_click = false;</front>
<front id="ultralcdCPP-342">      }</front>
<front id="ultralcdCPP-343">    }</front>
<front id="ultralcdCPP-344"></front>
<front id="ultralcdCPP-345">    if (current_click) {</front>
<front id="ultralcdCPP-346">      lcd_goto_menu(lcd_main_menu, true);</front>
<front id="ultralcdCPP-347">      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.</front>
<front id="ultralcdCPP-348">        #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-349">          currentMenu == lcd_status_screen</front>
<front id="ultralcdCPP-350">        #endif</front>
<front id="ultralcdCPP-351">      );</front>
<front id="ultralcdCPP-352">      #if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdCPP-353">        previous_lcd_status_ms = millis();  // get status message to show up for a while</front>
<front id="ultralcdCPP-354">      #endif</front>
<front id="ultralcdCPP-355">    }</front>
<front id="ultralcdCPP-356"></front>
<front id="ultralcdCPP-357">    #if ENABLED(ULTIPANEL_FEEDMULTIPLY)</front>
<front id="ultralcdCPP-358">      // Dead zone at 100% feedrate</front>
<front id="ultralcdCPP-359">      if ((feedrate_multiplier &lt; 100 && (feedrate_multiplier + int(encoderPosition)) &gt; 100) ||</front>
<front id="ultralcdCPP-360">              (feedrate_multiplier &gt; 100 && (feedrate_multiplier + int(encoderPosition)) &lt; 100)) {</front>
<front id="ultralcdCPP-361">        encoderPosition = 0;</front>
<front id="ultralcdCPP-362">        feedrate_multiplier = 100;</front>
<front id="ultralcdCPP-363">      }</front>
<front id="ultralcdCPP-364">      if (feedrate_multiplier == 100) {</front>
<front id="ultralcdCPP-365">        if (int(encoderPosition) &gt; ENCODER_FEEDRATE_DEADZONE) {</front>
<front id="ultralcdCPP-366">          feedrate_multiplier += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;</front>
<front id="ultralcdCPP-367">          encoderPosition = 0;</front>
<front id="ultralcdCPP-368">        }</front>
<front id="ultralcdCPP-369">        else if (int(encoderPosition) &lt; -ENCODER_FEEDRATE_DEADZONE) {</front>
<front id="ultralcdCPP-370">          feedrate_multiplier += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;</front>
<front id="ultralcdCPP-371">          encoderPosition = 0;</front>
<front id="ultralcdCPP-372">        }</front>
<front id="ultralcdCPP-373">      }</front>
<front id="ultralcdCPP-374">      else {</front>
<front id="ultralcdCPP-375">        feedrate_multiplier += int(encoderPosition);</front>
<front id="ultralcdCPP-376">        encoderPosition = 0;</front>
<front id="ultralcdCPP-377">      }</front>
<front id="ultralcdCPP-378">    #endif // ULTIPANEL_FEEDMULTIPLY</front>
<front id="ultralcdCPP-379"></front>
<front id="ultralcdCPP-380">    feedrate_multiplier = constrain(feedrate_multiplier, 10, 999);</front>
<front id="ultralcdCPP-381"></front>
<front id="ultralcdCPP-382">  #endif //ULTIPANEL</front>
<front id="ultralcdCPP-383">}</front>
<front id="ultralcdCPP-384"></front>
<front id="ultralcdCPP-385">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-386"></front>
<front id="ultralcdCPP-387">static void lcd_return_to_status() { lcd_goto_menu(lcd_status_screen); }</front>
<front id="ultralcdCPP-388"></front>
<front id="ultralcdCPP-389">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-390"></front>
<front id="ultralcdCPP-391">  static void lcd_sdcard_pause() { card.pauseSDPrint(); }</front>
<front id="ultralcdCPP-392"></front>
<front id="ultralcdCPP-393">  static void lcd_sdcard_resume() { card.startFileprint(); }</front>
<front id="ultralcdCPP-394"></front>
<front id="ultralcdCPP-395">  static void lcd_sdcard_stop() {</front>
<front id="ultralcdCPP-396">    quickStop();</front>
<front id="ultralcdCPP-397">    card.sdprinting = false;</front>
<front id="ultralcdCPP-398">    card.closefile();</front>
<front id="ultralcdCPP-399">    autotempShutdown();</front>
<front id="ultralcdCPP-400">    cancel_heatup = true;</front>
<front id="ultralcdCPP-401">    lcd_setstatus(MSG_PRINT_ABORTED, true);</front>
<front id="ultralcdCPP-402">    #if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-403">      planner_disabled_below_z = 0;</front>
<front id="ultralcdCPP-404">    #endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-405">  }</front>
<front id="ultralcdCPP-406"></front>
<front id="ultralcdCPP-407">#endif //SDSUPPORT</front>
<front id="ultralcdCPP-408"></front>
<front id="ultralcdCPP-409">/**</front>
<front id="ultralcdCPP-410"> *</front>
<front id="ultralcdCPP-411"> * "Main" menu</front>
<front id="ultralcdCPP-412"> *</front>
<front id="ultralcdCPP-413"> */</front>
<front id="ultralcdCPP-414"></front>
<front id="ultralcdCPP-415">static void lcd_main_menu() {</front>
<front id="ultralcdCPP-416">  START_MENU();</front>
<front id="ultralcdCPP-417">  MENU_ITEM(back, MSG_WATCH, lcd_status_screen);</front>
<front id="ultralcdCPP-418">  if (movesplanned() || IS_SD_PRINTING) {</front>
<front id="ultralcdCPP-419">    MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);</front>
<front id="ultralcdCPP-420">  }</front>
<front id="ultralcdCPP-421">  else {</front>
<front id="ultralcdCPP-422">    MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-423">    #if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="ultralcdCPP-424">      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);</front>
<front id="ultralcdCPP-425">    #endif</front>
<front id="ultralcdCPP-426">  }</front>
<front id="ultralcdCPP-427">  MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-428"></front>
<front id="ultralcdCPP-429">  #if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-430">    if (card.cardOK) {</front>
<front id="ultralcdCPP-431">      if (card.isFileOpen()) {</front>
<front id="ultralcdCPP-432">        if (card.sdprinting)</front>
<front id="ultralcdCPP-433">          MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);</front>
<front id="ultralcdCPP-434">        else</front>
<front id="ultralcdCPP-435">          MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);</front>
<front id="ultralcdCPP-436">        MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);</front>
<front id="ultralcdCPP-437">      }</front>
<front id="ultralcdCPP-438">      else {</front>
<front id="ultralcdCPP-439">        #if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-440">          MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_print_menu);</front>
<front id="ultralcdCPP-441">          if (current_position[Z_AXIS] &gt; 0)</front>
<front id="ultralcdCPP-442">            MENU_ITEM(submenu, MSG_CARD_RESUME_MENU, lcd_sdcard_resume_menu);</front>
<front id="ultralcdCPP-443">        #endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-444">        #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-445">          MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user</front>
<front id="ultralcdCPP-446">        #endif</front>
<front id="ultralcdCPP-447">      }</front>
<front id="ultralcdCPP-448">    }</front>
<front id="ultralcdCPP-449">    else {</front>
<front id="ultralcdCPP-450">      MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);</front>
<front id="ultralcdCPP-451">      #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-452">        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface</front>
<front id="ultralcdCPP-453">      #endif</front>
<front id="ultralcdCPP-454">    }</front>
<front id="ultralcdCPP-455">  #endif //SDSUPPORT</front>
<front id="ultralcdCPP-456"></front>
<front id="ultralcdCPP-457">  END_MENU();</front>
<front id="ultralcdCPP-458">}</front>
<front id="ultralcdCPP-459"></front>
<front id="ultralcdCPP-460">#if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)</front>
<front id="ultralcdCPP-461">  static void lcd_autostart_sd() {</front>
<front id="ultralcdCPP-462">    card.autostart_index = 0;</front>
<front id="ultralcdCPP-463">    card.setroot();</front>
<front id="ultralcdCPP-464">    card.checkautostart(true);</front>
<front id="ultralcdCPP-465">  }</front>
<front id="ultralcdCPP-466">#endif</front>
<front id="ultralcdCPP-467"></front>
<front id="ultralcdCPP-468">/**</front>
<front id="ultralcdCPP-469"> * Set the home offset based on the current_position</front>
<front id="ultralcdCPP-470"> */</front>
<front id="ultralcdCPP-471">void lcd_set_home_offsets() {</front>
<front id="ultralcdCPP-472">  // M428 Command</front>
<front id="ultralcdCPP-473">  enqueuecommands_P(PSTR("M428"));</front>
<front id="ultralcdCPP-474">  lcd_return_to_status();</front>
<front id="ultralcdCPP-475">}</front>
<front id="ultralcdCPP-476"></front>
<front id="ultralcdCPP-477"></front>
<front id="ultralcdCPP-478">#if ENABLED(BABYSTEPPING)</front>
<front id="ultralcdCPP-479"></front>
<front id="ultralcdCPP-480">  static void _lcd_babystep(int axis, const char *msg) {</front>
<front id="ultralcdCPP-481">    if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-482">      babystepsTodo[axis] += (int)encoderPosition;</front>
<front id="ultralcdCPP-483">      encoderPosition = 0;</front>
<front id="ultralcdCPP-484">      lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-485">    }</front>
<front id="ultralcdCPP-486">    if (lcdDrawUpdate) lcd_implementation_drawedit(msg, "");</front>
<front id="ultralcdCPP-487">    if (LCD_CLICKED) lcd_goto_menu(lcd_tune_menu);</front>
<front id="ultralcdCPP-488">  }</front>
<front id="ultralcdCPP-489">  static void lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }</front>
<front id="ultralcdCPP-490">  static void lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }</front>
<front id="ultralcdCPP-491">  static void lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }</front>
<front id="ultralcdCPP-492"></front>
<front id="ultralcdCPP-493">#endif //BABYSTEPPING</front>
<front id="ultralcdCPP-494"></front>
<front id="ultralcdCPP-495">/**</front>
<front id="ultralcdCPP-496"> *</front>
<front id="ultralcdCPP-497"> * "Tune" submenu</front>
<front id="ultralcdCPP-498"> *</front>
<front id="ultralcdCPP-499"> */</front>
<front id="ultralcdCPP-500"></front>
<front id="ultralcdCPP-501">static void lcd_tune_menu() {</front>
<front id="ultralcdCPP-502">  START_MENU();</front>
<front id="ultralcdCPP-503"></front>
<front id="ultralcdCPP-504">  //</front>
<front id="ultralcdCPP-505">  // ^ Main</front>
<front id="ultralcdCPP-506">  //</front>
<front id="ultralcdCPP-507">  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-508"></front>
<front id="ultralcdCPP-509">  //</front>
<front id="ultralcdCPP-510">  // Speed:</front>
<front id="ultralcdCPP-511">  //</front>
<front id="ultralcdCPP-512">  MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999);</front>
<front id="ultralcdCPP-513"></front>
<front id="ultralcdCPP-514">  //</front>
<front id="ultralcdCPP-515">  // Nozzle:</front>
<front id="ultralcdCPP-516">  // Nozzle 1:</front>
<front id="ultralcdCPP-517">  // Nozzle 2:</front>
<front id="ultralcdCPP-518">  // Nozzle 3:</front>
<front id="ultralcdCPP-519">  // Nozzle 4:</front>
<front id="ultralcdCPP-520">  //</front>
<front id="ultralcdCPP-521">  #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-522">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-523">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-524">    #endif</front>
<front id="ultralcdCPP-525">  #else //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-526">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-527">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N1, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-528">    #endif</front>
<front id="ultralcdCPP-529">    #if TEMP_SENSOR_1 != 0</front>
<front id="ultralcdCPP-530">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);</front>
<front id="ultralcdCPP-531">    #endif</front>
<front id="ultralcdCPP-532">    #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-533">      #if TEMP_SENSOR_2 != 0</front>
<front id="ultralcdCPP-534">        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);</front>
<front id="ultralcdCPP-535">      #endif</front>
<front id="ultralcdCPP-536">      #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-537">        #if TEMP_SENSOR_3 != 0</front>
<front id="ultralcdCPP-538">          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);</front>
<front id="ultralcdCPP-539">        #endif</front>
<front id="ultralcdCPP-540">      #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-541">    #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-542">  #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-543"></front>
<front id="ultralcdCPP-544">  //</front>
<front id="ultralcdCPP-545">  // Bed:</front>
<front id="ultralcdCPP-546">  //</front>
<front id="ultralcdCPP-547">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-548">    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-549">  #endif</front>
<front id="ultralcdCPP-550"></front>
<front id="ultralcdCPP-551">  //</front>
<front id="ultralcdCPP-552">  // Fan Speed:</front>
<front id="ultralcdCPP-553">  //</front>
<front id="ultralcdCPP-554">  MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);</front>
<front id="ultralcdCPP-555"></front>
<front id="ultralcdCPP-556">  //</front>
<front id="ultralcdCPP-557">  // Flow:</front>
<front id="ultralcdCPP-558">  //</front>
<front id="ultralcdCPP-559">  MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[active_extruder], 10, 999);</front>
<front id="ultralcdCPP-560"></front>
<front id="ultralcdCPP-561">  //</front>
<front id="ultralcdCPP-562">  // Flow:</front>
<front id="ultralcdCPP-563">  // Flow 1:</front>
<front id="ultralcdCPP-564">  // Flow 2:</front>
<front id="ultralcdCPP-565">  // Flow 3:</front>
<front id="ultralcdCPP-566">  // Flow 4:</front>
<front id="ultralcdCPP-567">  //</front>
<front id="ultralcdCPP-568">  #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-569">    MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[0], 10, 999);</front>
<front id="ultralcdCPP-570">  #else // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-571">    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &extruder_multiplier[0], 10, 999);</front>
<front id="ultralcdCPP-572">    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &extruder_multiplier[1], 10, 999);</front>
<front id="ultralcdCPP-573">    #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-574">      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &extruder_multiplier[2], 10, 999);</front>
<front id="ultralcdCPP-575">      #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-576">        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &extruder_multiplier[3], 10, 999);</front>
<front id="ultralcdCPP-577">      #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-578">    #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-579">  #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-580"></front>
<front id="ultralcdCPP-581">  #if ENABLED(TRACK_LAYER)</front>
<front id="ultralcdCPP-582">    int layer = current_layer;</front>
<front id="ultralcdCPP-583">    MENU_ITEM_EDIT(int3, MSG_LAYER, &layer, layer, layer);</front>
<front id="ultralcdCPP-584">  #endif //TRACK_LAYER</front>
<front id="ultralcdCPP-585"></front>
<front id="ultralcdCPP-586">  //</front>
<front id="ultralcdCPP-587">  // Babystep X:</front>
<front id="ultralcdCPP-588">  // Babystep Y:</front>
<front id="ultralcdCPP-589">  // Babystep Z:</front>
<front id="ultralcdCPP-590">  //</front>
<front id="ultralcdCPP-591">  #if ENABLED(BABYSTEPPING)</front>
<front id="ultralcdCPP-592">    #if ENABLED(BABYSTEP_XY)</front>
<front id="ultralcdCPP-593">      MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);</front>
<front id="ultralcdCPP-594">      MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);</front>
<front id="ultralcdCPP-595">    #endif //BABYSTEP_XY</front>
<front id="ultralcdCPP-596">    MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);</front>
<front id="ultralcdCPP-597">  #endif</front>
<front id="ultralcdCPP-598"></front>
<front id="ultralcdCPP-599">  //</front>
<front id="ultralcdCPP-600">  // Change filament</front>
<front id="ultralcdCPP-601">  //</front>
<front id="ultralcdCPP-602">  #if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="ultralcdCPP-603">     MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));</front>
<front id="ultralcdCPP-604">  #endif</front>
<front id="ultralcdCPP-605"></front>
<front id="ultralcdCPP-606">  END_MENU();</front>
<front id="ultralcdCPP-607">}</front>
<front id="ultralcdCPP-608"></front>
<front id="ultralcdCPP-609">void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {</front>
<front id="ultralcdCPP-610">  if (temph &gt; 0) setTargetHotend(temph, endnum);</front>
<front id="ultralcdCPP-611">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-612">    setTargetBed(tempb);</front>
<front id="ultralcdCPP-613">  #endif</front>
<front id="ultralcdCPP-614">  fanSpeed = fan;</front>
<front id="ultralcdCPP-615">  lcd_return_to_status();</front>
<front id="ultralcdCPP-616">}</front>
<front id="ultralcdCPP-617"></front>
<front id="ultralcdCPP-618">#if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-619">  void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-620">  void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-621">#endif</front>
<front id="ultralcdCPP-622"></front>
<front id="ultralcdCPP-623">#if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-624">  void lcd_preheat_pla1() { _lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-625">  void lcd_preheat_abs1() { _lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-626">  #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-627">    void lcd_preheat_pla2() { _lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-628">    void lcd_preheat_abs2() { _lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-629">    #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-630">      void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-631">      void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-632">    #endif</front>
<front id="ultralcdCPP-633">  #endif</front>
<front id="ultralcdCPP-634"></front>
<front id="ultralcdCPP-635">  void lcd_preheat_pla0123() {</front>
<front id="ultralcdCPP-636">    setTargetHotend0(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-637">    setTargetHotend1(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-638">    setTargetHotend2(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-639">    _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);</front>
<front id="ultralcdCPP-640">  }</front>
<front id="ultralcdCPP-641">  void lcd_preheat_abs0123() {</front>
<front id="ultralcdCPP-642">    setTargetHotend0(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-643">    setTargetHotend1(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-644">    setTargetHotend2(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-645">    _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);</front>
<front id="ultralcdCPP-646">  }</front>
<front id="ultralcdCPP-647"></front>
<front id="ultralcdCPP-648">#endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-649"></front>
<front id="ultralcdCPP-650">#if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-651">  void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-652">  void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-653">#endif</front>
<front id="ultralcdCPP-654"></front>
<front id="ultralcdCPP-655">#if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0)</front>
<front id="ultralcdCPP-656"></front>
<front id="ultralcdCPP-657">  static void lcd_preheat_pla_menu() {</front>
<front id="ultralcdCPP-658">    START_MENU();</front>
<front id="ultralcdCPP-659">    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-660">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-661">      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);</front>
<front id="ultralcdCPP-662">    #else</front>
<front id="ultralcdCPP-663">      MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0);</front>
<front id="ultralcdCPP-664">      MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1);</front>
<front id="ultralcdCPP-665">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-666">        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2);</front>
<front id="ultralcdCPP-667">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-668">          MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3);</front>
<front id="ultralcdCPP-669">        #endif</front>
<front id="ultralcdCPP-670">      #endif</front>
<front id="ultralcdCPP-671">      MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);</front>
<front id="ultralcdCPP-672">    #endif</front>
<front id="ultralcdCPP-673">    #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-674">      MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);</front>
<front id="ultralcdCPP-675">    #endif</front>
<front id="ultralcdCPP-676">    END_MENU();</front>
<front id="ultralcdCPP-677">  }</front>
<front id="ultralcdCPP-678"></front>
<front id="ultralcdCPP-679">  static void lcd_preheat_abs_menu() {</front>
<front id="ultralcdCPP-680">    START_MENU();</front>
<front id="ultralcdCPP-681">    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-682">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-683">      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);</front>
<front id="ultralcdCPP-684">    #else</front>
<front id="ultralcdCPP-685">      MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0);</front>
<front id="ultralcdCPP-686">      MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1);</front>
<front id="ultralcdCPP-687">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-688">        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2);</front>
<front id="ultralcdCPP-689">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-690">          MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3);</front>
<front id="ultralcdCPP-691">        #endif</front>
<front id="ultralcdCPP-692">      #endif</front>
<front id="ultralcdCPP-693">      MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);</front>
<front id="ultralcdCPP-694">    #endif</front>
<front id="ultralcdCPP-695">    #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-696">      MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);</front>
<front id="ultralcdCPP-697">    #endif</front>
<front id="ultralcdCPP-698">    END_MENU();</front>
<front id="ultralcdCPP-699">  }</front>
<front id="ultralcdCPP-700"></front>
<front id="ultralcdCPP-701">#endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_BED)</front>
<front id="ultralcdCPP-702"></front>
<front id="ultralcdCPP-703">void lcd_cooldown() {</front>
<front id="ultralcdCPP-704">  disable_all_heaters();</front>
<front id="ultralcdCPP-705">  fanSpeed = 0;</front>
<front id="ultralcdCPP-706">  lcd_return_to_status();</front>
<front id="ultralcdCPP-707">}</front>
<front id="ultralcdCPP-708"></front>
<front id="ultralcdCPP-709">/**</front>
<front id="ultralcdCPP-710"> *</front>
<front id="ultralcdCPP-711"> * "Prepare" submenu</front>
<front id="ultralcdCPP-712"> *</front>
<front id="ultralcdCPP-713"> */</front>
<front id="ultralcdCPP-714"></front>
<front id="ultralcdCPP-715">static void lcd_prepare_menu() {</front>
<front id="ultralcdCPP-716">  START_MENU();</front>
<front id="ultralcdCPP-717"></front>
<front id="ultralcdCPP-718">  //</front>
<front id="ultralcdCPP-719">  // ^ Main</front>
<front id="ultralcdCPP-720">  //</front>
<front id="ultralcdCPP-721">  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-722"></front>
<front id="ultralcdCPP-723">  //</front>
<front id="ultralcdCPP-724">  // Auto Home</front>
<front id="ultralcdCPP-725">  //</front>
<front id="ultralcdCPP-726">  MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));</front>
<front id="ultralcdCPP-727"></front>
<front id="ultralcdCPP-728">  //</front>
<front id="ultralcdCPP-729">  // Set Home Offsets</front>
<front id="ultralcdCPP-730">  //</front>
<front id="ultralcdCPP-731">  MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);</front>
<front id="ultralcdCPP-732">  //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));</front>
<front id="ultralcdCPP-733"></front>
<front id="ultralcdCPP-734">  //</front>
<front id="ultralcdCPP-735">  // Level Bed</front>
<front id="ultralcdCPP-736">  //</front>
<front id="ultralcdCPP-737">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ultralcdCPP-738">    if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS])</front>
<front id="ultralcdCPP-739">      MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G29"));</front>
<front id="ultralcdCPP-740">  #elif ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-741">    MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);</front>
<front id="ultralcdCPP-742">  #endif</front>
<front id="ultralcdCPP-743"></front>
<front id="ultralcdCPP-744">  //</front>
<front id="ultralcdCPP-745">  // Move Axis</front>
<front id="ultralcdCPP-746">  //</front>
<front id="ultralcdCPP-747">  MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);</front>
<front id="ultralcdCPP-748"></front>
<front id="ultralcdCPP-749">  //</front>
<front id="ultralcdCPP-750">  // Disable Steppers</front>
<front id="ultralcdCPP-751">  //</front>
<front id="ultralcdCPP-752">  MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));</front>
<front id="ultralcdCPP-753"></front>
<front id="ultralcdCPP-754">  //</front>
<front id="ultralcdCPP-755">  // Preheat PLA</front>
<front id="ultralcdCPP-756">  // Preheat ABS</front>
<front id="ultralcdCPP-757">  //</front>
<front id="ultralcdCPP-758">  #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-759">    #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-760">      MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);</front>
<front id="ultralcdCPP-761">      MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);</front>
<front id="ultralcdCPP-762">    #else</front>
<front id="ultralcdCPP-763">      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);</front>
<front id="ultralcdCPP-764">      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);</front>
<front id="ultralcdCPP-765">    #endif</front>
<front id="ultralcdCPP-766">  #endif</front>
<front id="ultralcdCPP-767"></front>
<front id="ultralcdCPP-768">  //</front>
<front id="ultralcdCPP-769">  // Cooldown</front>
<front id="ultralcdCPP-770">  //</front>
<front id="ultralcdCPP-771">  MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);</front>
<front id="ultralcdCPP-772"></front>
<front id="ultralcdCPP-773">  //</front>
<front id="ultralcdCPP-774">  // Switch power on/off</front>
<front id="ultralcdCPP-775">  //</front>
<front id="ultralcdCPP-776">  #if HAS_POWER_SWITCH</front>
<front id="ultralcdCPP-777">    if (powersupply)</front>
<front id="ultralcdCPP-778">      MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));</front>
<front id="ultralcdCPP-779">    else</front>
<front id="ultralcdCPP-780">      MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));</front>
<front id="ultralcdCPP-781">  #endif</front>
<front id="ultralcdCPP-782"></front>
<front id="ultralcdCPP-783">  //</front>
<front id="ultralcdCPP-784">  // Autostart</front>
<front id="ultralcdCPP-785">  //</front>
<front id="ultralcdCPP-786">  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)</front>
<front id="ultralcdCPP-787">    MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);</front>
<front id="ultralcdCPP-788">  #endif</front>
<front id="ultralcdCPP-789"></front>
<front id="ultralcdCPP-790">  END_MENU();</front>
<front id="ultralcdCPP-791">}</front>
<front id="ultralcdCPP-792"></front>
<front id="ultralcdCPP-793">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="ultralcdCPP-794"></front>
<front id="ultralcdCPP-795">  static void lcd_delta_calibrate_menu() {</front>
<front id="ultralcdCPP-796">    START_MENU();</front>
<front id="ultralcdCPP-797">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-798">    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));</front>
<front id="ultralcdCPP-799">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_X, PSTR("G0 F8000 X-77.94 Y-45 Z0"));</front>
<front id="ultralcdCPP-800">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Y, PSTR("G0 F8000 X77.94 Y-45 Z0"));</front>
<front id="ultralcdCPP-801">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Z, PSTR("G0 F8000 X0 Y90 Z0"));</front>
<front id="ultralcdCPP-802">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_CENTER, PSTR("G0 F8000 X0 Y0 Z0"));</front>
<front id="ultralcdCPP-803">    END_MENU();</front>
<front id="ultralcdCPP-804">  }</front>
<front id="ultralcdCPP-805"></front>
<front id="ultralcdCPP-806">#endif // DELTA_CALIBRATION_MENU</front>
<front id="ultralcdCPP-807"></front>
<front id="ultralcdCPP-808">inline void line_to_current(AxisEnum axis) {</front>
<front id="ultralcdCPP-809">  #if ENABLED(DELTA)</front>
<front id="ultralcdCPP-810">    calculate_delta(current_position);</front>
<front id="ultralcdCPP-811">    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);</front>
<front id="ultralcdCPP-812">  #else</front>
<front id="ultralcdCPP-813">    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);</front>
<front id="ultralcdCPP-814">  #endif</front>
<front id="ultralcdCPP-815">}</front>
<front id="ultralcdCPP-816"></front>
<front id="ultralcdCPP-817">/**</front>
<front id="ultralcdCPP-818"> *</front>
<front id="ultralcdCPP-819"> * "Prepare" &gt; "Move Axis" submenu</front>
<front id="ultralcdCPP-820"> *</front>
<front id="ultralcdCPP-821"> */</front>
<front id="ultralcdCPP-822"></front>
<front id="ultralcdCPP-823">float move_menu_scale;</front>
<front id="ultralcdCPP-824">static void lcd_move_menu_axis();</front>
<front id="ultralcdCPP-825"></front>
<front id="ultralcdCPP-826">static void _lcd_move(const char *name, AxisEnum axis, int min, int max) {</front>
<front id="ultralcdCPP-827">  if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-828">    refresh_cmd_timeout();</front>
<front id="ultralcdCPP-829">    current_position[axis] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-830">    if (min_software_endstops && current_position[axis] &lt; min) current_position[axis] = min;</front>
<front id="ultralcdCPP-831">    if (max_software_endstops && current_position[axis] &gt; max) current_position[axis] = max;</front>
<front id="ultralcdCPP-832">    encoderPosition = 0;</front>
<front id="ultralcdCPP-833">    line_to_current(axis);</front>
<front id="ultralcdCPP-834">    lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-835">  }</front>
<front id="ultralcdCPP-836">  if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));</front>
<front id="ultralcdCPP-837">  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);</front>
<front id="ultralcdCPP-838">}</front>
<front id="ultralcdCPP-839">static void lcd_move_x() { _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, X_MIN_POS, X_MAX_POS); }</front>
<front id="ultralcdCPP-840">static void lcd_move_y() { _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, Y_MIN_POS, Y_MAX_POS); }</front>
<front id="ultralcdCPP-841">static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, Z_MIN_POS, Z_MAX_POS); }</front>
<front id="ultralcdCPP-842">static void lcd_move_e(</front>
<front id="ultralcdCPP-843">  #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-844">    uint8_t e</front>
<front id="ultralcdCPP-845">  #endif</front>
<front id="ultralcdCPP-846">) {</front>
<front id="ultralcdCPP-847">  #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-848">    unsigned short original_active_extruder = active_extruder;</front>
<front id="ultralcdCPP-849">    active_extruder = e;</front>
<front id="ultralcdCPP-850">  #endif</front>
<front id="ultralcdCPP-851">  if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-852">    current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-853">    encoderPosition = 0;</front>
<front id="ultralcdCPP-854">    line_to_current(E_AXIS);</front>
<front id="ultralcdCPP-855">    lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-856">  }</front>
<front id="ultralcdCPP-857">  if (lcdDrawUpdate) {</front>
<front id="ultralcdCPP-858">    PGM_P pos_label;</front>
<front id="ultralcdCPP-859">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-860">      pos_label = PSTR(MSG_MOVE_E);</front>
<front id="ultralcdCPP-861">    #else</front>
<front id="ultralcdCPP-862">      switch (e) {</front>
<front id="ultralcdCPP-863">        case 0: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;</front>
<front id="ultralcdCPP-864">        case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;</front>
<front id="ultralcdCPP-865">        #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-866">          case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;</front>
<front id="ultralcdCPP-867">          #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-868">            case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;</front>
<front id="ultralcdCPP-869">          #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-870">        #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-871">      }</front>
<front id="ultralcdCPP-872">    #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-873">    lcd_implementation_drawedit(pos_label, ftostr31(current_position[E_AXIS]));</front>
<front id="ultralcdCPP-874">  }</front>
<front id="ultralcdCPP-875">  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);</front>
<front id="ultralcdCPP-876">  #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-877">    active_extruder = original_active_extruder;</front>
<front id="ultralcdCPP-878">  #endif</front>
<front id="ultralcdCPP-879">}</front>
<front id="ultralcdCPP-880"></front>
<front id="ultralcdCPP-881">#if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-882">  static void lcd_move_e0() { lcd_move_e(0); }</front>
<front id="ultralcdCPP-883">  static void lcd_move_e1() { lcd_move_e(1); }</front>
<front id="ultralcdCPP-884">  #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-885">    static void lcd_move_e2() { lcd_move_e(2); }</front>
<front id="ultralcdCPP-886">    #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-887">      static void lcd_move_e3() { lcd_move_e(3); }</front>
<front id="ultralcdCPP-888">    #endif</front>
<front id="ultralcdCPP-889">  #endif</front>
<front id="ultralcdCPP-890">#endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-891"></front>
<front id="ultralcdCPP-892">/**</front>
<front id="ultralcdCPP-893"> *</front>
<front id="ultralcdCPP-894"> * "Prepare" &gt; "Move Xmm" &gt; "Move XYZ" submenu</front>
<front id="ultralcdCPP-895"> *</front>
<front id="ultralcdCPP-896"> */</front>
<front id="ultralcdCPP-897"></front>
<front id="ultralcdCPP-898">static void lcd_move_menu_axis() {</front>
<front id="ultralcdCPP-899">  START_MENU();</front>
<front id="ultralcdCPP-900">  MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);</front>
<front id="ultralcdCPP-901">  MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);</front>
<front id="ultralcdCPP-902">  MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);</front>
<front id="ultralcdCPP-903">  if (move_menu_scale &lt; 10.0) {</front>
<front id="ultralcdCPP-904">    MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);</front>
<front id="ultralcdCPP-905">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-906">      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);</front>
<front id="ultralcdCPP-907">    #else</front>
<front id="ultralcdCPP-908">      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_e0);</front>
<front id="ultralcdCPP-909">      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_e1);</front>
<front id="ultralcdCPP-910">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-911">        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_e2);</front>
<front id="ultralcdCPP-912">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-913">          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_e3);</front>
<front id="ultralcdCPP-914">        #endif</front>
<front id="ultralcdCPP-915">      #endif</front>
<front id="ultralcdCPP-916">    #endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-917">  }</front>
<front id="ultralcdCPP-918">  END_MENU();</front>
<front id="ultralcdCPP-919">}</front>
<front id="ultralcdCPP-920"></front>
<front id="ultralcdCPP-921">static void lcd_move_menu_10mm() {</front>
<front id="ultralcdCPP-922">  move_menu_scale = 10.0;</front>
<front id="ultralcdCPP-923">  lcd_move_menu_axis();</front>
<front id="ultralcdCPP-924">}</front>
<front id="ultralcdCPP-925">static void lcd_move_menu_1mm() {</front>
<front id="ultralcdCPP-926">  move_menu_scale = 1.0;</front>
<front id="ultralcdCPP-927">  lcd_move_menu_axis();</front>
<front id="ultralcdCPP-928">}</front>
<front id="ultralcdCPP-929">static void lcd_move_menu_01mm() {</front>
<front id="ultralcdCPP-930">  move_menu_scale = 0.1;</front>
<front id="ultralcdCPP-931">  lcd_move_menu_axis();</front>
<front id="ultralcdCPP-932">}</front>
<front id="ultralcdCPP-933"></front>
<front id="ultralcdCPP-934">/**</front>
<front id="ultralcdCPP-935"> *</front>
<front id="ultralcdCPP-936"> * "Prepare" &gt; "Move Axis" submenu</front>
<front id="ultralcdCPP-937"> *</front>
<front id="ultralcdCPP-938"> */</front>
<front id="ultralcdCPP-939"></front>
<front id="ultralcdCPP-940">static void lcd_move_menu() {</front>
<front id="ultralcdCPP-941">  START_MENU();</front>
<front id="ultralcdCPP-942">  MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-943">  MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);</front>
<front id="ultralcdCPP-944">  MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);</front>
<front id="ultralcdCPP-945">  MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);</front>
<front id="ultralcdCPP-946">  //TODO:X,Y,Z,E</front>
<front id="ultralcdCPP-947">  END_MENU();</front>
<front id="ultralcdCPP-948">}</front>
<front id="ultralcdCPP-949"></front>
<front id="ultralcdCPP-950">/**</front>
<front id="ultralcdCPP-951"> *</front>
<front id="ultralcdCPP-952"> * "Control" submenu</front>
<front id="ultralcdCPP-953"> *</front>
<front id="ultralcdCPP-954"> */</front>
<front id="ultralcdCPP-955"></front>
<front id="ultralcdCPP-956">static void lcd_control_menu() {</front>
<front id="ultralcdCPP-957">  START_MENU();</front>
<front id="ultralcdCPP-958">  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-959">  MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-960">  MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);</front>
<front id="ultralcdCPP-961">  MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);</front>
<front id="ultralcdCPP-962"></front>
<front id="ultralcdCPP-963">  #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-964">    //MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);</front>
<front id="ultralcdCPP-965">    MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);</front>
<front id="ultralcdCPP-966">  #endif</front>
<front id="ultralcdCPP-967">  #if ENABLED(FWRETRACT)</front>
<front id="ultralcdCPP-968">    MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);</front>
<front id="ultralcdCPP-969">  #endif</front>
<front id="ultralcdCPP-970">  #if ENABLED(EEPROM_SETTINGS)</front>
<front id="ultralcdCPP-971">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-972">    MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);</front>
<front id="ultralcdCPP-973">  #endif</front>
<front id="ultralcdCPP-974">  MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);</front>
<front id="ultralcdCPP-975">  END_MENU();</front>
<front id="ultralcdCPP-976">}</front>
<front id="ultralcdCPP-977"></front>
<front id="ultralcdCPP-978">/**</front>
<front id="ultralcdCPP-979"> *</front>
<front id="ultralcdCPP-980"> * "Temperature" submenu</front>
<front id="ultralcdCPP-981"> *</front>
<front id="ultralcdCPP-982"> */</front>
<front id="ultralcdCPP-983"></front>
<front id="ultralcdCPP-984">#if ENABLED(PIDTEMP)</front>
<front id="ultralcdCPP-985"></front>
<front id="ultralcdCPP-986">  // Helpers for editing PID Ki & Kd values</front>
<front id="ultralcdCPP-987">  // grab the PID value out of the temp variable; scale it; then update the PID driver</front>
<front id="ultralcdCPP-988">  void copy_and_scalePID_i(int e) {</front>
<front id="ultralcdCPP-989">    PID_PARAM(Ki, e) = scalePID_i(raw_Ki);</front>
<front id="ultralcdCPP-990">    updatePID();</front>
<front id="ultralcdCPP-991">  }</front>
<front id="ultralcdCPP-992">  void copy_and_scalePID_d(int e) {</front>
<front id="ultralcdCPP-993">    PID_PARAM(Kd, e) = scalePID_d(raw_Kd);</front>
<front id="ultralcdCPP-994">    updatePID();</front>
<front id="ultralcdCPP-995">  }</front>
<front id="ultralcdCPP-996">  #define COPY_AND_SCALE(eindex) \</front>
<front id="ultralcdCPP-997">    void copy_and_scalePID_i_E ## eindex() { copy_and_scalePID_i(eindex); } \</front>
<front id="ultralcdCPP-998">    void copy_and_scalePID_d_E ## eindex() { copy_and_scalePID_d(eindex); }</front>
<front id="ultralcdCPP-999"></front>
<front id="ultralcdCPP-1000">  COPY_AND_SCALE(0);</front>
<front id="ultralcdCPP-1001">  #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="ultralcdCPP-1002">    #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1003">      COPY_AND_SCALE(1);</front>
<front id="ultralcdCPP-1004">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1005">        COPY_AND_SCALE(2);</front>
<front id="ultralcdCPP-1006">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1007">          COPY_AND_SCALE(3);</front>
<front id="ultralcdCPP-1008">        #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1009">      #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1010">    #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1011">  #endif //PID_PARAMS_PER_EXTRUDER</front>
<front id="ultralcdCPP-1012"></front>
<front id="ultralcdCPP-1013">#endif //PIDTEMP</front>
<front id="ultralcdCPP-1014"></front>
<front id="ultralcdCPP-1015">/**</front>
<front id="ultralcdCPP-1016"> *</front>
<front id="ultralcdCPP-1017"> * "Control" &gt; "Temperature" submenu</front>
<front id="ultralcdCPP-1018"> *</front>
<front id="ultralcdCPP-1019"> */</front>
<front id="ultralcdCPP-1020">static void lcd_control_temperature_menu() {</front>
<front id="ultralcdCPP-1021">  START_MENU();</front>
<front id="ultralcdCPP-1022"></front>
<front id="ultralcdCPP-1023">  //</front>
<front id="ultralcdCPP-1024">  // ^ Control</front>
<front id="ultralcdCPP-1025">  //</front>
<front id="ultralcdCPP-1026">  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1027"></front>
<front id="ultralcdCPP-1028">  //</front>
<front id="ultralcdCPP-1029">  // Nozzle</front>
<front id="ultralcdCPP-1030">  // Nozzle 1, Nozzle 2, Nozzle 3, Nozzle 4</front>
<front id="ultralcdCPP-1031">  //</front>
<front id="ultralcdCPP-1032">  #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-1033">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1034">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1035">    #endif</front>
<front id="ultralcdCPP-1036">  #else //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1037">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1038">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N1, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1039">    #endif</front>
<front id="ultralcdCPP-1040">    #if TEMP_SENSOR_1 != 0</front>
<front id="ultralcdCPP-1041">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1042">    #endif</front>
<front id="ultralcdCPP-1043">    #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1044">      #if TEMP_SENSOR_2 != 0</front>
<front id="ultralcdCPP-1045">        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1046">      #endif</front>
<front id="ultralcdCPP-1047">      #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1048">        #if TEMP_SENSOR_3 != 0</front>
<front id="ultralcdCPP-1049">          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1050">        #endif</front>
<front id="ultralcdCPP-1051">      #endif // EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1052">    #endif // EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1053">  #endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1054"></front>
<front id="ultralcdCPP-1055">  //</front>
<front id="ultralcdCPP-1056">  // Bed</front>
<front id="ultralcdCPP-1057">  //</front>
<front id="ultralcdCPP-1058">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-1059">    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1060">  #endif</front>
<front id="ultralcdCPP-1061"></front>
<front id="ultralcdCPP-1062">  //</front>
<front id="ultralcdCPP-1063">  // Fan Speed</front>
<front id="ultralcdCPP-1064">  //</front>
<front id="ultralcdCPP-1065">  MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);</front>
<front id="ultralcdCPP-1066"></front>
<front id="ultralcdCPP-1067">  //</front>
<front id="ultralcdCPP-1068">  // Autotemp, Min, Max, Fact</front>
<front id="ultralcdCPP-1069">  //</front>
<front id="ultralcdCPP-1070">  #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)</front>
<front id="ultralcdCPP-1071">    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);</front>
<front id="ultralcdCPP-1072">    MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1073">    MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1074">    MENU_ITEM_EDIT(float32, MSG_FACTOR, &autotemp_factor, 0.0, 1.0);</front>
<front id="ultralcdCPP-1075">  #endif</front>
<front id="ultralcdCPP-1076"></front>
<front id="ultralcdCPP-1077">  //</front>
<front id="ultralcdCPP-1078">  // PID-P, PID-I, PID-D, PID-C</front>
<front id="ultralcdCPP-1079">  // PID-P E1, PID-I E1, PID-D E1, PID-C E1</front>
<front id="ultralcdCPP-1080">  // PID-P E2, PID-I E2, PID-D E2, PID-C E2</front>
<front id="ultralcdCPP-1081">  // PID-P E3, PID-I E3, PID-D E3, PID-C E3</front>
<front id="ultralcdCPP-1082">  // PID-P E4, PID-I E4, PID-D E4, PID-C E4</front>
<front id="ultralcdCPP-1083">  //</front>
<front id="ultralcdCPP-1084">  #if ENABLED(PIDTEMP)</front>
<front id="ultralcdCPP-1085"></front>
<front id="ultralcdCPP-1086">    #define _PID_MENU_ITEMS(ELABEL, eindex) \</front>
<front id="ultralcdCPP-1087">      raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \</front>
<front id="ultralcdCPP-1088">      raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \</front>
<front id="ultralcdCPP-1089">      MENU_ITEM_EDIT(float52, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \</front>
<front id="ultralcdCPP-1090">      MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \</front>
<front id="ultralcdCPP-1091">      MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)</front>
<front id="ultralcdCPP-1092"></front>
<front id="ultralcdCPP-1093">    #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="ultralcdCPP-1094">      #define PID_MENU_ITEMS(ELABEL, eindex) \</front>
<front id="ultralcdCPP-1095">        _PID_MENU_ITEMS(ELABEL, eindex); \</front>
<front id="ultralcdCPP-1096">        MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)</front>
<front id="ultralcdCPP-1097">    #else</front>
<front id="ultralcdCPP-1098">      #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)</front>
<front id="ultralcdCPP-1099">    #endif</front>
<front id="ultralcdCPP-1100"></front>
<front id="ultralcdCPP-1101">    #if ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1102">      PID_MENU_ITEMS(MSG_E1, 0);</front>
<front id="ultralcdCPP-1103">      PID_MENU_ITEMS(MSG_E2, 1);</front>
<front id="ultralcdCPP-1104">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1105">        PID_MENU_ITEMS(MSG_E3, 2);</front>
<front id="ultralcdCPP-1106">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1107">          PID_MENU_ITEMS(MSG_E4, 3);</front>
<front id="ultralcdCPP-1108">        #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1109">      #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1110">    #else //!PID_PARAMS_PER_EXTRUDER || EXTRUDERS == 1</front>
<front id="ultralcdCPP-1111">      PID_MENU_ITEMS("", 0);</front>
<front id="ultralcdCPP-1112">    #endif //!PID_PARAMS_PER_EXTRUDER || EXTRUDERS == 1</front>
<front id="ultralcdCPP-1113"></front>
<front id="ultralcdCPP-1114">  #endif //PIDTEMP</front>
<front id="ultralcdCPP-1115"></front>
<front id="ultralcdCPP-1116">  //</front>
<front id="ultralcdCPP-1117">  // Preheat PLA conf</front>
<front id="ultralcdCPP-1118">  //</front>
<front id="ultralcdCPP-1119">  MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);</front>
<front id="ultralcdCPP-1120"></front>
<front id="ultralcdCPP-1121">  //</front>
<front id="ultralcdCPP-1122">  // Preheat ABS conf</front>
<front id="ultralcdCPP-1123">  //</front>
<front id="ultralcdCPP-1124">  MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);</front>
<front id="ultralcdCPP-1125">  END_MENU();</front>
<front id="ultralcdCPP-1126">}</front>
<front id="ultralcdCPP-1127"></front>
<front id="ultralcdCPP-1128">/**</front>
<front id="ultralcdCPP-1129"> *</front>
<front id="ultralcdCPP-1130"> * "Temperature" &gt; "Preheat PLA conf" submenu</front>
<front id="ultralcdCPP-1131"> *</front>
<front id="ultralcdCPP-1132"> */</front>
<front id="ultralcdCPP-1133">static void lcd_control_temperature_preheat_pla_settings_menu() {</front>
<front id="ultralcdCPP-1134">  START_MENU();</front>
<front id="ultralcdCPP-1135">  MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-1136">  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);</front>
<front id="ultralcdCPP-1137">  #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1138">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1139">  #endif</front>
<front id="ultralcdCPP-1140">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-1141">    MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1142">  #endif</front>
<front id="ultralcdCPP-1143">  #if ENABLED(EEPROM_SETTINGS)</front>
<front id="ultralcdCPP-1144">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-1145">  #endif</front>
<front id="ultralcdCPP-1146">  END_MENU();</front>
<front id="ultralcdCPP-1147">}</front>
<front id="ultralcdCPP-1148"></front>
<front id="ultralcdCPP-1149">/**</front>
<front id="ultralcdCPP-1150"> *</front>
<front id="ultralcdCPP-1151"> * "Temperature" &gt; "Preheat ABS conf" submenu</front>
<front id="ultralcdCPP-1152"> *</front>
<front id="ultralcdCPP-1153"> */</front>
<front id="ultralcdCPP-1154">static void lcd_control_temperature_preheat_abs_settings_menu() {</front>
<front id="ultralcdCPP-1155">  START_MENU();</front>
<front id="ultralcdCPP-1156">  MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-1157">  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);</front>
<front id="ultralcdCPP-1158">  #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1159">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1160">  #endif</front>
<front id="ultralcdCPP-1161">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-1162">    MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1163">  #endif</front>
<front id="ultralcdCPP-1164">  #if ENABLED(EEPROM_SETTINGS)</front>
<front id="ultralcdCPP-1165">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-1166">  #endif</front>
<front id="ultralcdCPP-1167">  END_MENU();</front>
<front id="ultralcdCPP-1168">}</front>
<front id="ultralcdCPP-1169"></front>
<front id="ultralcdCPP-1170">/**</front>
<front id="ultralcdCPP-1171"> *</front>
<front id="ultralcdCPP-1172"> * "Control" &gt; "Motion" submenu</front>
<front id="ultralcdCPP-1173"> *</front>
<front id="ultralcdCPP-1174"> */</front>
<front id="ultralcdCPP-1175">static void lcd_control_motion_menu() {</front>
<front id="ultralcdCPP-1176">  START_MENU();</front>
<front id="ultralcdCPP-1177">  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1178">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ultralcdCPP-1179">    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);</front>
<front id="ultralcdCPP-1180">  #endif</front>
<front id="ultralcdCPP-1181">  MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 10, 99000);</front>
<front id="ultralcdCPP-1182">  MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);</front>
<front id="ultralcdCPP-1183">  MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);</front>
<front id="ultralcdCPP-1184">  MENU_ITEM_EDIT(float3, MSG_VE_JERK, &max_e_jerk, 1, 990);</front>
<front id="ultralcdCPP-1185">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &max_feedrate[X_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1186">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &max_feedrate[Y_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1187">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &max_feedrate[Z_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1188">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &max_feedrate[E_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1189">  MENU_ITEM_EDIT(float3, MSG_VMIN, &minimumfeedrate, 0, 999);</front>
<front id="ultralcdCPP-1190">  MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &mintravelfeedrate, 0, 999);</front>
<front id="ultralcdCPP-1191">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1192">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1193">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 10, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1194">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1195">  MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &retract_acceleration, 100, 99000);</front>
<front id="ultralcdCPP-1196">  MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &travel_acceleration, 100, 99000);</front>
<front id="ultralcdCPP-1197">  MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1198">  MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1199">  MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1200">  MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1201">  #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="ultralcdCPP-1202">    MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);</front>
<front id="ultralcdCPP-1203">  #endif</front>
<front id="ultralcdCPP-1204">  #if ENABLED(SCARA)</front>
<front id="ultralcdCPP-1205">    MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS],0.5,2);</front>
<front id="ultralcdCPP-1206">    MENU_ITEM_EDIT(float74, MSG_YSCALE, &axis_scaling[Y_AXIS],0.5,2);</front>
<front id="ultralcdCPP-1207">  #endif</front>
<front id="ultralcdCPP-1208">  END_MENU();</front>
<front id="ultralcdCPP-1209">}</front>
<front id="ultralcdCPP-1210"></front>
<front id="ultralcdCPP-1211">/**</front>
<front id="ultralcdCPP-1212"> *</front>
<front id="ultralcdCPP-1213"> * "Control" &gt; "Filament" submenu</front>
<front id="ultralcdCPP-1214"> *</front>
<front id="ultralcdCPP-1215"> */</front>
<front id="ultralcdCPP-1216">static void lcd_control_volumetric_menu() {</front>
<front id="ultralcdCPP-1217">  START_MENU();</front>
<front id="ultralcdCPP-1218">  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1219"></front>
<front id="ultralcdCPP-1220">  MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1221"></front>
<front id="ultralcdCPP-1222">  if (volumetric_enabled) {</front>
<front id="ultralcdCPP-1223">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-1224">      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1225">    #else //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1226">      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1227">      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1228">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1229">        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1230">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1231">          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1232">        #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1233">      #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1234">    #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1235">  }</front>
<front id="ultralcdCPP-1236"></front>
<front id="ultralcdCPP-1237">  END_MENU();</front>
<front id="ultralcdCPP-1238">}</front>
<front id="ultralcdCPP-1239"></front>
<front id="ultralcdCPP-1240">/**</front>
<front id="ultralcdCPP-1241"> *</front>
<front id="ultralcdCPP-1242"> * "Control" &gt; "Contrast" submenu</front>
<front id="ultralcdCPP-1243"> *</front>
<front id="ultralcdCPP-1244"> */</front>
<front id="ultralcdCPP-1245">#if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-1246">  static void lcd_set_contrast() {</front>
<front id="ultralcdCPP-1247">    if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-1248">      #if ENABLED(U8GLIB_LM6059_AF)</front>
<front id="ultralcdCPP-1249">        lcd_contrast += encoderPosition;</front>
<front id="ultralcdCPP-1250">        lcd_contrast &= 0xFF;</front>
<front id="ultralcdCPP-1251">      #else</front>
<front id="ultralcdCPP-1252">        lcd_contrast -= encoderPosition;</front>
<front id="ultralcdCPP-1253">        lcd_contrast &= 0x3F;</front>
<front id="ultralcdCPP-1254">      #endif</front>
<front id="ultralcdCPP-1255">      encoderPosition = 0;</front>
<front id="ultralcdCPP-1256">      lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1257">      u8g.setContrast(lcd_contrast);</front>
<front id="ultralcdCPP-1258">    }</front>
<front id="ultralcdCPP-1259">    if (lcdDrawUpdate) {</front>
<front id="ultralcdCPP-1260">      #if ENABLED(U8GLIB_LM6059_AF)</front>
<front id="ultralcdCPP-1261">        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr3(lcd_contrast));</front>
<front id="ultralcdCPP-1262">      #else</front>
<front id="ultralcdCPP-1263">        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));</front>
<front id="ultralcdCPP-1264">      #endif</front>
<front id="ultralcdCPP-1265">    }</front>
<front id="ultralcdCPP-1266">    if (LCD_CLICKED) lcd_goto_menu(lcd_control_menu);</front>
<front id="ultralcdCPP-1267">  }</front>
<front id="ultralcdCPP-1268">#endif // HAS_LCD_CONTRAST</front>
<front id="ultralcdCPP-1269"></front>
<front id="ultralcdCPP-1270">/**</front>
<front id="ultralcdCPP-1271"> *</front>
<front id="ultralcdCPP-1272"> * "Control" &gt; "Retract" submenu</front>
<front id="ultralcdCPP-1273"> *</front>
<front id="ultralcdCPP-1274"> */</front>
<front id="ultralcdCPP-1275">#if ENABLED(FWRETRACT)</front>
<front id="ultralcdCPP-1276">  static void lcd_control_retract_menu() {</front>
<front id="ultralcdCPP-1277">    START_MENU();</front>
<front id="ultralcdCPP-1278">    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1279">    MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);</front>
<front id="ultralcdCPP-1280">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);</front>
<front id="ultralcdCPP-1281">    #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1282">      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);</front>
<front id="ultralcdCPP-1283">    #endif</front>
<front id="ultralcdCPP-1284">    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);</front>
<front id="ultralcdCPP-1285">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);</front>
<front id="ultralcdCPP-1286">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);</front>
<front id="ultralcdCPP-1287">    #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1288">      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);</front>
<front id="ultralcdCPP-1289">    #endif</front>
<front id="ultralcdCPP-1290">    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);</front>
<front id="ultralcdCPP-1291">    END_MENU();</front>
<front id="ultralcdCPP-1292">  }</front>
<front id="ultralcdCPP-1293">#endif // FWRETRACT</front>
<front id="ultralcdCPP-1294"></front>
<front id="ultralcdCPP-1295">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-1296"></front>
<front id="ultralcdCPP-1297">  #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1298">    static void lcd_sd_refresh() {</front>
<front id="ultralcdCPP-1299">      card.initsd();</front>
<front id="ultralcdCPP-1300">      currentMenuViewOffset = 0;</front>
<front id="ultralcdCPP-1301">    }</front>
<front id="ultralcdCPP-1302">  #endif</front>
<front id="ultralcdCPP-1303"></front>
<front id="ultralcdCPP-1304">  static void lcd_sd_updir() {</front>
<front id="ultralcdCPP-1305">    card.updir();</front>
<front id="ultralcdCPP-1306">    currentMenuViewOffset = 0;</front>
<front id="ultralcdCPP-1307">  }</front>
<front id="ultralcdCPP-1308"></front>
<front id="ultralcdCPP-1309">#if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-1310">  // Print from SD</front>
<front id="ultralcdCPP-1311">  void lcd_sdcard_print_menu() {</front>
<front id="ultralcdCPP-1312">    planner_disabled_below_z = 0;</front>
<front id="ultralcdCPP-1313">    lcd_sdcard_menu();</front>
<front id="ultralcdCPP-1314">  }</front>
<front id="ultralcdCPP-1315"></front>
<front id="ultralcdCPP-1316">  // Print from SD but set flag to ignore movements below a certain Z</front>
<front id="ultralcdCPP-1317">  void lcd_sdcard_resume_menu() {</front>
<front id="ultralcdCPP-1318">    planner_disabled_below_z = current_position[Z_AXIS];</front>
<front id="ultralcdCPP-1319">    last_z = 0;</front>
<front id="ultralcdCPP-1320">    z_reached = false;</front>
<front id="ultralcdCPP-1321">    layer_reached = false;</front>
<front id="ultralcdCPP-1322">    hops = false;</front>
<front id="ultralcdCPP-1323">    gone_up = false;</front>
<front id="ultralcdCPP-1324">    lcd_sdcard_menu();</front>
<front id="ultralcdCPP-1325">  }</front>
<front id="ultralcdCPP-1326">#endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-1327"></front>
<front id="ultralcdCPP-1328">  /**</front>
<front id="ultralcdCPP-1329">   *</front>
<front id="ultralcdCPP-1330">   * "Print from SD" submenu</front>
<front id="ultralcdCPP-1331">   *</front>
<front id="ultralcdCPP-1332">   */</front>
<front id="ultralcdCPP-1333">  void lcd_sdcard_menu() {</front>
<front id="ultralcdCPP-1334">    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) return;	// nothing to do (so don't thrash the SD card)</front>
<front id="ultralcdCPP-1335">    uint16_t fileCnt = card.getnrfilenames();</front>
<front id="ultralcdCPP-1336">    START_MENU();</front>
<front id="ultralcdCPP-1337">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-1338">    card.getWorkDirName();</front>
<front id="ultralcdCPP-1339">    if (card.filename[0] == '/') {</front>
<front id="ultralcdCPP-1340">      #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1341">        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);</front>
<front id="ultralcdCPP-1342">      #endif</front>
<front id="ultralcdCPP-1343">    }</front>
<front id="ultralcdCPP-1344">    else {</front>
<front id="ultralcdCPP-1345">      MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);</front>
<front id="ultralcdCPP-1346">    }</front>
<front id="ultralcdCPP-1347"></front>
<front id="ultralcdCPP-1348">    for (uint16_t i = 0; i &lt; fileCnt; i++) {</front>
<front id="ultralcdCPP-1349">      if (_menuItemNr == _lineNr) {</front>
<front id="ultralcdCPP-1350">        card.getfilename(</front>
<front id="ultralcdCPP-1351">          #if ENABLED(SDCARD_RATHERRECENTFIRST)</front>
<front id="ultralcdCPP-1352">            fileCnt-1 -</front>
<front id="ultralcdCPP-1353">          #endif</front>
<front id="ultralcdCPP-1354">          i</front>
<front id="ultralcdCPP-1355">        );</front>
<front id="ultralcdCPP-1356">        if (card.filenameIsDir)</front>
<front id="ultralcdCPP-1357">          MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);</front>
<front id="ultralcdCPP-1358">        else</front>
<front id="ultralcdCPP-1359">          MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);</front>
<front id="ultralcdCPP-1360">      }</front>
<front id="ultralcdCPP-1361">      else {</front>
<front id="ultralcdCPP-1362">        MENU_ITEM_DUMMY();</front>
<front id="ultralcdCPP-1363">      }</front>
<front id="ultralcdCPP-1364">    }</front>
<front id="ultralcdCPP-1365">    END_MENU();</front>
<front id="ultralcdCPP-1366">  }</front>
<front id="ultralcdCPP-1367"></front>
<front id="ultralcdCPP-1368"> #endif //SDSUPPORT</front>
<front id="ultralcdCPP-1369"></front>
<front id="ultralcdCPP-1370">/**</front>
<front id="ultralcdCPP-1371"> *</front>
<front id="ultralcdCPP-1372"> * Functions for editing single values</front>
<front id="ultralcdCPP-1373"> *</front>
<front id="ultralcdCPP-1374"> */</front>
<front id="ultralcdCPP-1375">#define menu_edit_type(_type, _name, _strFunc, scale) \</front>
<front id="ultralcdCPP-1376">  bool _menu_edit_ ## _name () { \</front>
<front id="ultralcdCPP-1377">    bool isClicked = LCD_CLICKED; \</front>
<front id="ultralcdCPP-1378">    if ((int32_t)encoderPosition &lt; 0) encoderPosition = 0; \</front>
<front id="ultralcdCPP-1379">    if ((int32_t)encoderPosition &gt; maxEditValue) encoderPosition = maxEditValue; \</front>
<front id="ultralcdCPP-1380">    if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-1381">        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \</front>
<front id="ultralcdCPP-1382">    if (isClicked) { \</front>
<front id="ultralcdCPP-1383">      *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \</front>
<front id="ultralcdCPP-1384">      lcd_goto_menu(prevMenu, prevEncoderPosition); \</front>
<front id="ultralcdCPP-1385">    } \</front>
<front id="ultralcdCPP-1386">    return isClicked; \</front>
<front id="ultralcdCPP-1387">  } \</front>
<front id="ultralcdCPP-1388">  void menu_edit_ ## _name () { _menu_edit_ ## _name(); } \</front>
<front id="ultralcdCPP-1389">  void menu_edit_callback_ ## _name () { if (_menu_edit_ ## _name ()) (*callbackFunc)(); } \</front>
<front id="ultralcdCPP-1390">  static void _menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \</front>
<front id="ultralcdCPP-1391">    prevMenu = currentMenu; \</front>
<front id="ultralcdCPP-1392">    prevEncoderPosition = encoderPosition; \</front>
<front id="ultralcdCPP-1393">     \</front>
<front id="ultralcdCPP-1394">    lcdDrawUpdate = 2; \</front>
<front id="ultralcdCPP-1395">    currentMenu = menu_edit_ ## _name; \</front>
<front id="ultralcdCPP-1396">     \</front>
<front id="ultralcdCPP-1397">    editLabel = pstr; \</front>
<front id="ultralcdCPP-1398">    editValue = ptr; \</front>
<front id="ultralcdCPP-1399">    minEditValue = minValue * scale; \</front>
<front id="ultralcdCPP-1400">    maxEditValue = maxValue * scale - minEditValue; \</front>
<front id="ultralcdCPP-1401">    encoderPosition = (*ptr) * scale - minEditValue; \</front>
<front id="ultralcdCPP-1402">  } \</front>
<front id="ultralcdCPP-1403">  static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \</front>
<front id="ultralcdCPP-1404">    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \</front>
<front id="ultralcdCPP-1405">    currentMenu = menu_edit_ ## _name; \</front>
<front id="ultralcdCPP-1406">  }\</front>
<front id="ultralcdCPP-1407">  static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) { \</front>
<front id="ultralcdCPP-1408">    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \</front>
<front id="ultralcdCPP-1409">    currentMenu = menu_edit_callback_ ## _name; \</front>
<front id="ultralcdCPP-1410">    callbackFunc = callback; \</front>
<front id="ultralcdCPP-1411">  }</front>
<front id="ultralcdCPP-1412">menu_edit_type(int, int3, itostr3, 1)</front>
<front id="ultralcdCPP-1413">menu_edit_type(float, float3, ftostr3, 1)</front>
<front id="ultralcdCPP-1414">menu_edit_type(float, float32, ftostr32, 100)</front>
<front id="ultralcdCPP-1415">menu_edit_type(float, float43, ftostr43, 1000)</front>
<front id="ultralcdCPP-1416">menu_edit_type(float, float5, ftostr5, 0.01)</front>
<front id="ultralcdCPP-1417">menu_edit_type(float, float51, ftostr51, 10)</front>
<front id="ultralcdCPP-1418">menu_edit_type(float, float52, ftostr52, 100)</front>
<front id="ultralcdCPP-1419">menu_edit_type(unsigned long, long5, ftostr5, 0.01)</front>
<front id="ultralcdCPP-1420"></front>
<front id="ultralcdCPP-1421">/**</front>
<front id="ultralcdCPP-1422"> *</front>
<front id="ultralcdCPP-1423"> * Handlers for RepRap World Keypad input</front>
<front id="ultralcdCPP-1424"> *</front>
<front id="ultralcdCPP-1425"> */</front>
<front id="ultralcdCPP-1426">#if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1427">  static void reprapworld_keypad_move_z_up() {</front>
<front id="ultralcdCPP-1428">    encoderPosition = 1;</front>
<front id="ultralcdCPP-1429">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1430">    lcd_move_z();</front>
<front id="ultralcdCPP-1431">  }</front>
<front id="ultralcdCPP-1432">  static void reprapworld_keypad_move_z_down() {</front>
<front id="ultralcdCPP-1433">    encoderPosition = -1;</front>
<front id="ultralcdCPP-1434">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1435">    lcd_move_z();</front>
<front id="ultralcdCPP-1436">  }</front>
<front id="ultralcdCPP-1437">  static void reprapworld_keypad_move_x_left() {</front>
<front id="ultralcdCPP-1438">    encoderPosition = -1;</front>
<front id="ultralcdCPP-1439">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1440">    lcd_move_x();</front>
<front id="ultralcdCPP-1441">  }</front>
<front id="ultralcdCPP-1442">  static void reprapworld_keypad_move_x_right() {</front>
<front id="ultralcdCPP-1443">    encoderPosition = 1;</front>
<front id="ultralcdCPP-1444">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1445">    lcd_move_x();</front>
<front id="ultralcdCPP-1446">  }</front>
<front id="ultralcdCPP-1447">  static void reprapworld_keypad_move_y_down() {</front>
<front id="ultralcdCPP-1448">    encoderPosition = 1;</front>
<front id="ultralcdCPP-1449">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1450">    lcd_move_y();</front>
<front id="ultralcdCPP-1451">  }</front>
<front id="ultralcdCPP-1452">  static void reprapworld_keypad_move_y_up() {</front>
<front id="ultralcdCPP-1453">    encoderPosition = -1;</front>
<front id="ultralcdCPP-1454">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1455">    lcd_move_y();</front>
<front id="ultralcdCPP-1456">  }</front>
<front id="ultralcdCPP-1457">  static void reprapworld_keypad_move_home() {</front>
<front id="ultralcdCPP-1458">    enqueuecommands_P((PSTR("G28"))); // move all axis home</front>
<front id="ultralcdCPP-1459">  }</front>
<front id="ultralcdCPP-1460">#endif // REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-1461"></front>
<front id="ultralcdCPP-1462"></front>
<front id="ultralcdCPP-1463">/**</front>
<front id="ultralcdCPP-1464"> *</front>
<front id="ultralcdCPP-1465"> * Audio feedback for controller clicks</front>
<front id="ultralcdCPP-1466"> *</front>
<front id="ultralcdCPP-1467"> */</front>
<front id="ultralcdCPP-1468"></front>
<front id="ultralcdCPP-1469">#if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="ultralcdCPP-1470">  void lcd_buzz(long duration, uint16_t freq) { // called from buzz() in Marlin_main.cpp where lcd is unknown</front>
<front id="ultralcdCPP-1471">    lcd.buzz(duration, freq);</front>
<front id="ultralcdCPP-1472">  }</front>
<front id="ultralcdCPP-1473">#endif</front>
<front id="ultralcdCPP-1474"></front>
<front id="ultralcdCPP-1475">void lcd_quick_feedback() {</front>
<front id="ultralcdCPP-1476">  lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1477">  next_button_update_ms = millis() + 500;</front>
<front id="ultralcdCPP-1478">    </front>
<front id="ultralcdCPP-1479">  #if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="ultralcdCPP-1480">    #ifndef LCD_FEEDBACK_FREQUENCY_HZ</front>
<front id="ultralcdCPP-1481">      #define LCD_FEEDBACK_FREQUENCY_HZ 100</front>
<front id="ultralcdCPP-1482">    #endif</front>
<front id="ultralcdCPP-1483">    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS</front>
<front id="ultralcdCPP-1484">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS (1000/6)</front>
<front id="ultralcdCPP-1485">    #endif    </front>
<front id="ultralcdCPP-1486">    lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);</front>
<front id="ultralcdCPP-1487">  #elif PIN_EXISTS(BEEPER)</front>
<front id="ultralcdCPP-1488">    #ifndef LCD_FEEDBACK_FREQUENCY_HZ</front>
<front id="ultralcdCPP-1489">      #define LCD_FEEDBACK_FREQUENCY_HZ 5000</front>
<front id="ultralcdCPP-1490">    #endif</front>
<front id="ultralcdCPP-1491">    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS</front>
<front id="ultralcdCPP-1492">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2</front>
<front id="ultralcdCPP-1493">    #endif</front>
<front id="ultralcdCPP-1494">    buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);</front>
<front id="ultralcdCPP-1495">  #else</front>
<front id="ultralcdCPP-1496">    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS</front>
<front id="ultralcdCPP-1497">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2</front>
<front id="ultralcdCPP-1498">    #endif</front>
<front id="ultralcdCPP-1499">    delay(LCD_FEEDBACK_FREQUENCY_DURATION_MS);</front>
<front id="ultralcdCPP-1500">  #endif</front>
<front id="ultralcdCPP-1501">}</front>
<front id="ultralcdCPP-1502"></front>
<front id="ultralcdCPP-1503">/**</front>
<front id="ultralcdCPP-1504"> *</front>
<front id="ultralcdCPP-1505"> * Menu actions</front>
<front id="ultralcdCPP-1506"> *</front>
<front id="ultralcdCPP-1507"> */</front>
<front id="ultralcdCPP-1508">static void menu_action_back(menuFunc_t func) { lcd_goto_menu(func); }</front>
<front id="ultralcdCPP-1509">static void menu_action_submenu(menuFunc_t func) { lcd_goto_menu(func); }</front>
<front id="ultralcdCPP-1510">static void menu_action_gcode(const char* pgcode) { enqueuecommands_P(pgcode); }</front>
<front id="ultralcdCPP-1511">static void menu_action_function(menuFunc_t func) { (*func)(); }</front>
<front id="ultralcdCPP-1512"></front>
<front id="ultralcdCPP-1513">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-1514"></front>
<front id="ultralcdCPP-1515">  static void menu_action_sdfile(const char* filename, char* longFilename) {</front>
<front id="ultralcdCPP-1516">    char cmd[30];</front>
<front id="ultralcdCPP-1517">    char* c;</front>
<front id="ultralcdCPP-1518">    sprintf_P(cmd, PSTR("M23 %s"), filename);</front>
<front id="ultralcdCPP-1519">    for(c = &cmd[4]; *c; c++) *c = tolower(*c);</front>
<front id="ultralcdCPP-1520">    enqueuecommand(cmd);</front>
<front id="ultralcdCPP-1521">    enqueuecommands_P(PSTR("M24"));</front>
<front id="ultralcdCPP-1522">    lcd_return_to_status();</front>
<front id="ultralcdCPP-1523">  }</front>
<front id="ultralcdCPP-1524"></front>
<front id="ultralcdCPP-1525">  static void menu_action_sddirectory(const char* filename, char* longFilename) {</front>
<front id="ultralcdCPP-1526">    card.chdir(filename);</front>
<front id="ultralcdCPP-1527">    encoderPosition = 0;</front>
<front id="ultralcdCPP-1528">  }</front>
<front id="ultralcdCPP-1529"></front>
<front id="ultralcdCPP-1530">#endif //SDSUPPORT</front>
<front id="ultralcdCPP-1531"></front>
<front id="ultralcdCPP-1532">static void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { *ptr = !(*ptr); }</front>
<front id="ultralcdCPP-1533">static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback) {</front>
<front id="ultralcdCPP-1534">  menu_action_setting_edit_bool(pstr, ptr);</front>
<front id="ultralcdCPP-1535">  (*callback)();</front>
<front id="ultralcdCPP-1536">}</front>
<front id="ultralcdCPP-1537"></front>
<front id="ultralcdCPP-1538">#endif //ULTIPANEL</front>
<front id="ultralcdCPP-1539"></front>
<front id="ultralcdCPP-1540">/** LCD API **/</front>
<front id="ultralcdCPP-1541">void lcd_init() {</front>
<front id="ultralcdCPP-1542">  lcd_implementation_init();</front>
<front id="ultralcdCPP-1543"></front>
<front id="ultralcdCPP-1544">  #if ENABLED(NEWPANEL)</front>
<front id="ultralcdCPP-1545"></front>
<front id="ultralcdCPP-1546">    SET_INPUT(BTN_EN1);</front>
<front id="ultralcdCPP-1547">    SET_INPUT(BTN_EN2);</front>
<front id="ultralcdCPP-1548">    WRITE(BTN_EN1,HIGH);</front>
<front id="ultralcdCPP-1549">    WRITE(BTN_EN2,HIGH);</front>
<front id="ultralcdCPP-1550">  #if BTN_ENC &gt; 0</front>
<front id="ultralcdCPP-1551">    SET_INPUT(BTN_ENC);</front>
<front id="ultralcdCPP-1552">    WRITE(BTN_ENC,HIGH);</front>
<front id="ultralcdCPP-1553">  #endif</front>
<front id="ultralcdCPP-1554">  #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1555">    pinMode(SHIFT_CLK,OUTPUT);</front>
<front id="ultralcdCPP-1556">    pinMode(SHIFT_LD,OUTPUT);</front>
<front id="ultralcdCPP-1557">    pinMode(SHIFT_OUT,INPUT);</front>
<front id="ultralcdCPP-1558">    WRITE(SHIFT_OUT,HIGH);</front>
<front id="ultralcdCPP-1559">    WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-1560">  #endif</front>
<front id="ultralcdCPP-1561">#else  // Not NEWPANEL</front>
<front id="ultralcdCPP-1562">  #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register</front>
<front id="ultralcdCPP-1563">     pinMode (SR_DATA_PIN, OUTPUT);</front>
<front id="ultralcdCPP-1564">     pinMode (SR_CLK_PIN, OUTPUT);</front>
<front id="ultralcdCPP-1565">  #elif defined(SHIFT_CLK)</front>
<front id="ultralcdCPP-1566">     pinMode(SHIFT_CLK,OUTPUT);</front>
<front id="ultralcdCPP-1567">     pinMode(SHIFT_LD,OUTPUT);</front>
<front id="ultralcdCPP-1568">     pinMode(SHIFT_EN,OUTPUT);</front>
<front id="ultralcdCPP-1569">     pinMode(SHIFT_OUT,INPUT);</front>
<front id="ultralcdCPP-1570">     WRITE(SHIFT_OUT,HIGH);</front>
<front id="ultralcdCPP-1571">     WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-1572">     WRITE(SHIFT_EN,LOW);</front>
<front id="ultralcdCPP-1573">  #endif // SR_LCD_2W_NL</front>
<front id="ultralcdCPP-1574">#endif//!NEWPANEL</front>
<front id="ultralcdCPP-1575"></front>
<front id="ultralcdCPP-1576">  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1577">    pinMode(SD_DETECT_PIN, INPUT);</front>
<front id="ultralcdCPP-1578">    WRITE(SD_DETECT_PIN, HIGH);</front>
<front id="ultralcdCPP-1579">    lcd_sd_status = 2; // UNKNOWN</front>
<front id="ultralcdCPP-1580">  #endif</front>
<front id="ultralcdCPP-1581"></front>
<front id="ultralcdCPP-1582">  #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-1583">    slow_buttons = 0;</front>
<front id="ultralcdCPP-1584">  #endif</front>
<front id="ultralcdCPP-1585"></front>
<front id="ultralcdCPP-1586">  lcd_buttons_update();</front>
<front id="ultralcdCPP-1587"></front>
<front id="ultralcdCPP-1588">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1589">    encoderDiff = 0;</front>
<front id="ultralcdCPP-1590">  #endif</front>
<front id="ultralcdCPP-1591">}</front>
<front id="ultralcdCPP-1592"></front>
<front id="ultralcdCPP-1593">int lcd_strlen(char *s) {</front>
<front id="ultralcdCPP-1594">  int i = 0, j = 0;</front>
<front id="ultralcdCPP-1595">  while (s[i]) {</front>
<front id="ultralcdCPP-1596">    if ((s[i] & 0xc0) != 0x80) j++;</front>
<front id="ultralcdCPP-1597">    i++;</front>
<front id="ultralcdCPP-1598">  }</front>
<front id="ultralcdCPP-1599">  return j;</front>
<front id="ultralcdCPP-1600">}</front>
<front id="ultralcdCPP-1601"></front>
<front id="ultralcdCPP-1602">int lcd_strlen_P(const char *s) {</front>
<front id="ultralcdCPP-1603">  int j = 0;</front>
<front id="ultralcdCPP-1604">  while (pgm_read_byte(s)) {</front>
<front id="ultralcdCPP-1605">    if ((pgm_read_byte(s) & 0xc0) != 0x80) j++;</front>
<front id="ultralcdCPP-1606">    s++;</front>
<front id="ultralcdCPP-1607">  }</front>
<front id="ultralcdCPP-1608">  return j;</front>
<front id="ultralcdCPP-1609">}</front>
<front id="ultralcdCPP-1610"></front>
<front id="ultralcdCPP-1611">/**</front>
<front id="ultralcdCPP-1612"> * Update the LCD, read encoder buttons, etc.</front>
<front id="ultralcdCPP-1613"> *   - Read button states</front>
<front id="ultralcdCPP-1614"> *   - Check the SD Card slot state</front>
<front id="ultralcdCPP-1615"> *   - Act on RepRap World keypad input</front>
<front id="ultralcdCPP-1616"> *   - Update the encoder position</front>
<front id="ultralcdCPP-1617"> *   - Apply acceleration to the encoder position</front>
<front id="ultralcdCPP-1618"> *   - Reset the Info Screen timeout if there's any input</front>
<front id="ultralcdCPP-1619"> *   - Update status indicators, if any</front>
<front id="ultralcdCPP-1620"> *   - Clear the LCD if lcdDrawUpdate == 2</front>
<front id="ultralcdCPP-1621"> *</front>
<front id="ultralcdCPP-1622"> * Warning: This function is called from interrupt context!</front>
<front id="ultralcdCPP-1623"> */</front>
<front id="ultralcdCPP-1624">void lcd_update() {</front>
<front id="ultralcdCPP-1625">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1626">    static millis_t return_to_status_ms = 0;</front>
<front id="ultralcdCPP-1627">  #endif</front>
<front id="ultralcdCPP-1628"></front>
<front id="ultralcdCPP-1629">  #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-1630">    slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context</front>
<front id="ultralcdCPP-1631">  #endif</front>
<front id="ultralcdCPP-1632"></front>
<front id="ultralcdCPP-1633">  lcd_buttons_update();</front>
<front id="ultralcdCPP-1634"></front>
<front id="ultralcdCPP-1635">  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1636"></front>
<front id="ultralcdCPP-1637">    bool sd_status = IS_SD_INSERTED;</front>
<front id="ultralcdCPP-1638">    if (sd_status != lcd_sd_status && lcd_detected()) {</front>
<front id="ultralcdCPP-1639">      lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1640">      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.</front>
<front id="ultralcdCPP-1641">        #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-1642">          currentMenu == lcd_status_screen</front>
<front id="ultralcdCPP-1643">        #endif</front>
<front id="ultralcdCPP-1644">      );</front>
<front id="ultralcdCPP-1645"></front>
<front id="ultralcdCPP-1646">      if (sd_status) {</front>
<front id="ultralcdCPP-1647">        card.initsd();</front>
<front id="ultralcdCPP-1648">        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);</front>
<front id="ultralcdCPP-1649">      }</front>
<front id="ultralcdCPP-1650">      else {</front>
<front id="ultralcdCPP-1651">        card.release();</front>
<front id="ultralcdCPP-1652">        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);</front>
<front id="ultralcdCPP-1653">      }</front>
<front id="ultralcdCPP-1654"></front>
<front id="ultralcdCPP-1655">      lcd_sd_status = sd_status;</front>
<front id="ultralcdCPP-1656">    }</front>
<front id="ultralcdCPP-1657"></front>
<front id="ultralcdCPP-1658">  #endif //SDSUPPORT && SD_DETECT_PIN</front>
<front id="ultralcdCPP-1659">  </front>
<front id="ultralcdCPP-1660">  millis_t ms = millis();</front>
<front id="ultralcdCPP-1661">  if (ms &gt; next_lcd_update_ms) {</front>
<front id="ultralcdCPP-1662"></front>
<front id="ultralcdCPP-1663">    #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1664"></front>
<front id="ultralcdCPP-1665">      #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1666">        if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();</front>
<front id="ultralcdCPP-1667">        if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();</front>
<front id="ultralcdCPP-1668">        if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();</front>
<front id="ultralcdCPP-1669">        if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();</front>
<front id="ultralcdCPP-1670">        if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();</front>
<front id="ultralcdCPP-1671">        if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();</front>
<front id="ultralcdCPP-1672">        if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();</front>
<front id="ultralcdCPP-1673">      #endif</front>
<front id="ultralcdCPP-1674"></front>
<front id="ultralcdCPP-1675">      bool encoderPastThreshold = (abs(encoderDiff) &gt;= ENCODER_PULSES_PER_STEP);</front>
<front id="ultralcdCPP-1676">      if (encoderPastThreshold || LCD_CLICKED) {</front>
<front id="ultralcdCPP-1677">        if (encoderPastThreshold) {</front>
<front id="ultralcdCPP-1678">          int32_t encoderMultiplier = 1;</front>
<front id="ultralcdCPP-1679"></front>
<front id="ultralcdCPP-1680">          #if ENABLED(ENCODER_RATE_MULTIPLIER)</front>
<front id="ultralcdCPP-1681"></front>
<front id="ultralcdCPP-1682">            if (encoderRateMultiplierEnabled) {</front>
<front id="ultralcdCPP-1683">              int32_t encoderMovementSteps = abs(encoderDiff) / ENCODER_PULSES_PER_STEP;</front>
<front id="ultralcdCPP-1684"></front>
<front id="ultralcdCPP-1685">              if (lastEncoderMovementMillis != 0) {</front>
<front id="ultralcdCPP-1686">                // Note that the rate is always calculated between to passes through the </front>
<front id="ultralcdCPP-1687">                // loop and that the abs of the encoderDiff value is tracked.</front>
<front id="ultralcdCPP-1688">                float encoderStepRate = (float)(encoderMovementSteps) / ((float)(ms - lastEncoderMovementMillis)) * 1000.0;</front>
<front id="ultralcdCPP-1689"></front>
<front id="ultralcdCPP-1690">                if (encoderStepRate &gt;= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;</front>
<front id="ultralcdCPP-1691">                else if (encoderStepRate &gt;= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;</front>
<front id="ultralcdCPP-1692"></front>
<front id="ultralcdCPP-1693">                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)</front>
<front id="ultralcdCPP-1694">                  SERIAL_ECHO_START;</front>
<front id="ultralcdCPP-1695">                  SERIAL_ECHO("Enc Step Rate: ");</front>
<front id="ultralcdCPP-1696">                  SERIAL_ECHO(encoderStepRate);</front>
<front id="ultralcdCPP-1697">                  SERIAL_ECHO("  Multiplier: ");</front>
<front id="ultralcdCPP-1698">                  SERIAL_ECHO(encoderMultiplier);</front>
<front id="ultralcdCPP-1699">                  SERIAL_ECHO("  ENCODER_10X_STEPS_PER_SEC: ");</front>
<front id="ultralcdCPP-1700">                  SERIAL_ECHO(ENCODER_10X_STEPS_PER_SEC);</front>
<front id="ultralcdCPP-1701">                  SERIAL_ECHO("  ENCODER_100X_STEPS_PER_SEC: ");</front>
<front id="ultralcdCPP-1702">                  SERIAL_ECHOLN(ENCODER_100X_STEPS_PER_SEC);</front>
<front id="ultralcdCPP-1703">                #endif //ENCODER_RATE_MULTIPLIER_DEBUG</front>
<front id="ultralcdCPP-1704">              }</front>
<front id="ultralcdCPP-1705"></front>
<front id="ultralcdCPP-1706">              lastEncoderMovementMillis = ms;</front>
<front id="ultralcdCPP-1707">            } // encoderRateMultiplierEnabled</front>
<front id="ultralcdCPP-1708">          #endif //ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-1709"></front>
<front id="ultralcdCPP-1710">          encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;</front>
<front id="ultralcdCPP-1711">          encoderDiff = 0;</front>
<front id="ultralcdCPP-1712">        }</front>
<front id="ultralcdCPP-1713">        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;</front>
<front id="ultralcdCPP-1714">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1715">      }</front>
<front id="ultralcdCPP-1716">    #endif //ULTIPANEL</front>
<front id="ultralcdCPP-1717"></front>
<front id="ultralcdCPP-1718">    if (currentMenu == lcd_status_screen) {</front>
<front id="ultralcdCPP-1719">      if (!lcd_status_update_delay) {</front>
<front id="ultralcdCPP-1720">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1721">        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */</front>
<front id="ultralcdCPP-1722">      }</front>
<front id="ultralcdCPP-1723">      else {</front>
<front id="ultralcdCPP-1724">        lcd_status_update_delay--;</front>
<front id="ultralcdCPP-1725">      }</front>
<front id="ultralcdCPP-1726">    }</front>
<front id="ultralcdCPP-1727">    #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display</front>
<front id="ultralcdCPP-1728">      if (lcdDrawUpdate) {</front>
<front id="ultralcdCPP-1729">        blink++;     // Variable for fan animation and alive dot</front>
<front id="ultralcdCPP-1730">        u8g.firstPage();</front>
<front id="ultralcdCPP-1731">        do {</front>
<front id="ultralcdCPP-1732">          lcd_setFont(FONT_MENU);</front>
<front id="ultralcdCPP-1733">          u8g.setPrintPos(125, 0);</front>
<front id="ultralcdCPP-1734">          if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot</front>
<front id="ultralcdCPP-1735">          u8g.drawPixel(127, 63); // draw alive dot</front>
<front id="ultralcdCPP-1736">          u8g.setColorIndex(1); // black on white</front>
<front id="ultralcdCPP-1737">          (*currentMenu)();</front>
<front id="ultralcdCPP-1738">        } while( u8g.nextPage() );</front>
<front id="ultralcdCPP-1739">      }</front>
<front id="ultralcdCPP-1740">    #else</front>
<front id="ultralcdCPP-1741">      (*currentMenu)();</front>
<front id="ultralcdCPP-1742">    #endif</front>
<front id="ultralcdCPP-1743"></front>
<front id="ultralcdCPP-1744">    #if ENABLED(LCD_HAS_STATUS_INDICATORS)</front>
<front id="ultralcdCPP-1745">      lcd_implementation_update_indicators();</front>
<front id="ultralcdCPP-1746">    #endif</front>
<front id="ultralcdCPP-1747"></front>
<front id="ultralcdCPP-1748">    #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1749"></front>
<front id="ultralcdCPP-1750">      // Return to Status Screen after a timeout</front>
<front id="ultralcdCPP-1751">      if (currentMenu != lcd_status_screen &&</front>
<front id="ultralcdCPP-1752">        #if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-1753">          currentMenu != _lcd_level_bed &&</front>
<front id="ultralcdCPP-1754">          currentMenu != _lcd_level_bed_homing &&</front>
<front id="ultralcdCPP-1755">        #endif</front>
<front id="ultralcdCPP-1756">        millis() &gt; return_to_status_ms</front>
<front id="ultralcdCPP-1757">      ) {</front>
<front id="ultralcdCPP-1758">        lcd_return_to_status();</front>
<front id="ultralcdCPP-1759">        lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1760">      }</front>
<front id="ultralcdCPP-1761"></front>
<front id="ultralcdCPP-1762">    #endif // ULTIPANEL</front>
<front id="ultralcdCPP-1763"></front>
<front id="ultralcdCPP-1764">    if (lcdDrawUpdate == 2) lcd_implementation_clear();</front>
<front id="ultralcdCPP-1765">    if (lcdDrawUpdate) lcdDrawUpdate--;</front>
<front id="ultralcdCPP-1766">    next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;</front>
<front id="ultralcdCPP-1767">  }</front>
<front id="ultralcdCPP-1768">}</front>
<front id="ultralcdCPP-1769"></front>
<front id="ultralcdCPP-1770">void lcd_ignore_click(bool b) {</front>
<front id="ultralcdCPP-1771">  ignore_click = b;</front>
<front id="ultralcdCPP-1772">  wait_for_unclick = false;</front>
<front id="ultralcdCPP-1773">}</front>
<front id="ultralcdCPP-1774"></front>
<front id="ultralcdCPP-1775">void lcd_finishstatus(bool persist=false) {</front>
<front id="ultralcdCPP-1776">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-1777">    progress_bar_ms = millis();</front>
<front id="ultralcdCPP-1778">    #if PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdCPP-1779">      expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;</front>
<front id="ultralcdCPP-1780">    #endif</front>
<front id="ultralcdCPP-1781">  #endif</front>
<front id="ultralcdCPP-1782">  lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1783"></front>
<front id="ultralcdCPP-1784">  #if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdCPP-1785">    previous_lcd_status_ms = millis();  //get status message to show up for a while</front>
<front id="ultralcdCPP-1786">  #endif</front>
<front id="ultralcdCPP-1787">}</front>
<front id="ultralcdCPP-1788"></front>
<front id="ultralcdCPP-1789">#if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdCPP-1790">  void dontExpireStatus() { expire_status_ms = 0; }</front>
<front id="ultralcdCPP-1791">#endif</front>
<front id="ultralcdCPP-1792"></front>
<front id="ultralcdCPP-1793">void set_utf_strlen(char *s, uint8_t n) {</front>
<front id="ultralcdCPP-1794">  uint8_t i = 0, j = 0;</front>
<front id="ultralcdCPP-1795">  while (s[i] && (j &lt; n)) {</front>
<front id="ultralcdCPP-1796">    if ((s[i] & 0xc0u) != 0x80u) j++;</front>
<front id="ultralcdCPP-1797">    i++;</front>
<front id="ultralcdCPP-1798">  }</front>
<front id="ultralcdCPP-1799">  while (j++ &lt; n) s[i++] = ' ';</front>
<front id="ultralcdCPP-1800">  s[i] = 0;</front>
<front id="ultralcdCPP-1801">}</front>
<front id="ultralcdCPP-1802"></front>
<front id="ultralcdCPP-1803">bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }</front>
<front id="ultralcdCPP-1804"></front>
<front id="ultralcdCPP-1805">void lcd_setstatus(const char* message, bool persist) {</front>
<front id="ultralcdCPP-1806">  if (lcd_status_message_level &gt; 0) return;</front>
<front id="ultralcdCPP-1807">  strncpy(lcd_status_message, message, 3*LCD_WIDTH);</front>
<front id="ultralcdCPP-1808">  set_utf_strlen(lcd_status_message, LCD_WIDTH);</front>
<front id="ultralcdCPP-1809">  lcd_finishstatus(persist);</front>
<front id="ultralcdCPP-1810">}</front>
<front id="ultralcdCPP-1811"></front>
<front id="ultralcdCPP-1812">void lcd_setstatuspgm(const char* message, uint8_t level) {</front>
<front id="ultralcdCPP-1813">  if (level &gt;= lcd_status_message_level) {</front>
<front id="ultralcdCPP-1814">    strncpy_P(lcd_status_message, message, 3*LCD_WIDTH);</front>
<front id="ultralcdCPP-1815">    set_utf_strlen(lcd_status_message, LCD_WIDTH);</front>
<front id="ultralcdCPP-1816">    lcd_status_message_level = level;</front>
<front id="ultralcdCPP-1817">    lcd_finishstatus(level &gt; 0);</front>
<front id="ultralcdCPP-1818">  }</front>
<front id="ultralcdCPP-1819">}</front>
<front id="ultralcdCPP-1820"></front>
<front id="ultralcdCPP-1821">void lcd_setalertstatuspgm(const char* message) {</front>
<front id="ultralcdCPP-1822">  lcd_setstatuspgm(message, 1);</front>
<front id="ultralcdCPP-1823">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1824">    lcd_return_to_status();</front>
<front id="ultralcdCPP-1825">  #endif</front>
<front id="ultralcdCPP-1826">}</front>
<front id="ultralcdCPP-1827"></front>
<front id="ultralcdCPP-1828">void lcd_reset_alert_level() { lcd_status_message_level = 0; }</front>
<front id="ultralcdCPP-1829"></front>
<front id="ultralcdCPP-1830">#if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-1831">  void lcd_setcontrast(uint8_t value) {</front>
<front id="ultralcdCPP-1832">    lcd_contrast = value & 0x3F;</front>
<front id="ultralcdCPP-1833">    u8g.setContrast(lcd_contrast);</front>
<front id="ultralcdCPP-1834">  }</front>
<front id="ultralcdCPP-1835">#endif</front>
<front id="ultralcdCPP-1836"></front>
<front id="ultralcdCPP-1837">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1838"></front>
<front id="ultralcdCPP-1839">  /**</front>
<front id="ultralcdCPP-1840">   * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)</front>
<front id="ultralcdCPP-1841">   * These values are independent of which pins are used for EN_A and EN_B indications</front>
<front id="ultralcdCPP-1842">   * The rotary encoder part is also independent to the chipset used for the LCD</front>
<front id="ultralcdCPP-1843">   */</front>
<front id="ultralcdCPP-1844">  #if defined(EN_A) && defined(EN_B)</front>
<front id="ultralcdCPP-1845">    #define encrot0 0</front>
<front id="ultralcdCPP-1846">    #define encrot1 2</front>
<front id="ultralcdCPP-1847">    #define encrot2 3</front>
<front id="ultralcdCPP-1848">    #define encrot3 1</front>
<front id="ultralcdCPP-1849">  #endif</front>
<front id="ultralcdCPP-1850"></front>
<front id="ultralcdCPP-1851">  /**</front>
<front id="ultralcdCPP-1852">   * Read encoder buttons from the hardware registers</front>
<front id="ultralcdCPP-1853">   * Warning: This function is called from interrupt context!</front>
<front id="ultralcdCPP-1854">   */</front>
<front id="ultralcdCPP-1855">  void lcd_buttons_update() {</front>
<front id="ultralcdCPP-1856">    #if ENABLED(NEWPANEL)</front>
<front id="ultralcdCPP-1857">      uint8_t newbutton = 0;</front>
<front id="ultralcdCPP-1858">      if (READ(BTN_EN1) == 0) newbutton |= EN_A;</front>
<front id="ultralcdCPP-1859">      if (READ(BTN_EN2) == 0) newbutton |= EN_B;</front>
<front id="ultralcdCPP-1860">      #if BTN_ENC &gt; 0</front>
<front id="ultralcdCPP-1861">        if (millis() &gt; next_button_update_ms && READ(BTN_ENC) == 0) newbutton |= EN_C;</front>
<front id="ultralcdCPP-1862">      #endif</front>
<front id="ultralcdCPP-1863">      buttons = newbutton;</front>
<front id="ultralcdCPP-1864">      #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-1865">        buttons |= slow_buttons;</front>
<front id="ultralcdCPP-1866">      #endif</front>
<front id="ultralcdCPP-1867">      #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1868">        // for the reprapworld_keypad</front>
<front id="ultralcdCPP-1869">        uint8_t newbutton_reprapworld_keypad=0;</front>
<front id="ultralcdCPP-1870">        WRITE(SHIFT_LD, LOW);</front>
<front id="ultralcdCPP-1871">        WRITE(SHIFT_LD, HIGH);</front>
<front id="ultralcdCPP-1872">        for(int8_t i = 0; i &lt; 8; i++) {</front>
<front id="ultralcdCPP-1873">          newbutton_reprapworld_keypad &gt;&gt;= 1;</front>
<front id="ultralcdCPP-1874">          if (READ(SHIFT_OUT)) newbutton_reprapworld_keypad |= BIT(7);</front>
<front id="ultralcdCPP-1875">          WRITE(SHIFT_CLK, HIGH);</front>
<front id="ultralcdCPP-1876">          WRITE(SHIFT_CLK, LOW);</front>
<front id="ultralcdCPP-1877">        }</front>
<front id="ultralcdCPP-1878">        buttons_reprapworld_keypad=~newbutton_reprapworld_keypad; //invert it, because a pressed switch produces a logical 0</front>
<front id="ultralcdCPP-1879">      #endif</front>
<front id="ultralcdCPP-1880">    #else   //read it from the shift register</front>
<front id="ultralcdCPP-1881">      uint8_t newbutton = 0;</front>
<front id="ultralcdCPP-1882">      WRITE(SHIFT_LD, LOW);</front>
<front id="ultralcdCPP-1883">      WRITE(SHIFT_LD, HIGH);</front>
<front id="ultralcdCPP-1884">      unsigned char tmp_buttons = 0;</front>
<front id="ultralcdCPP-1885">      for(int8_t i=0; i&lt;8; i++) {</front>
<front id="ultralcdCPP-1886">        newbutton &gt;&gt;= 1;</front>
<front id="ultralcdCPP-1887">        if (READ(SHIFT_OUT)) newbutton |= BIT(7);</front>
<front id="ultralcdCPP-1888">        WRITE(SHIFT_CLK, HIGH);</front>
<front id="ultralcdCPP-1889">        WRITE(SHIFT_CLK, LOW);</front>
<front id="ultralcdCPP-1890">      }</front>
<front id="ultralcdCPP-1891">      buttons = ~newbutton; //invert it, because a pressed switch produces a logical 0</front>
<front id="ultralcdCPP-1892">    #endif //!NEWPANEL</front>
<front id="ultralcdCPP-1893"></front>
<front id="ultralcdCPP-1894">    //manage encoder rotation</front>
<front id="ultralcdCPP-1895">    uint8_t enc=0;</front>
<front id="ultralcdCPP-1896">    if (buttons & EN_A) enc |= B01;</front>
<front id="ultralcdCPP-1897">    if (buttons & EN_B) enc |= B10;</front>
<front id="ultralcdCPP-1898">    if (enc != lastEncoderBits) {</front>
<front id="ultralcdCPP-1899">      switch(enc) {</front>
<front id="ultralcdCPP-1900">        case encrot0:</front>
<front id="ultralcdCPP-1901">          if (lastEncoderBits==encrot3) encoderDiff++;</front>
<front id="ultralcdCPP-1902">          else if (lastEncoderBits==encrot1) encoderDiff--;</front>
<front id="ultralcdCPP-1903">          break;</front>
<front id="ultralcdCPP-1904">        case encrot1:</front>
<front id="ultralcdCPP-1905">          if (lastEncoderBits==encrot0) encoderDiff++;</front>
<front id="ultralcdCPP-1906">          else if (lastEncoderBits==encrot2) encoderDiff--;</front>
<front id="ultralcdCPP-1907">          break;</front>
<front id="ultralcdCPP-1908">        case encrot2:</front>
<front id="ultralcdCPP-1909">          if (lastEncoderBits==encrot1) encoderDiff++;</front>
<front id="ultralcdCPP-1910">          else if (lastEncoderBits==encrot3) encoderDiff--;</front>
<front id="ultralcdCPP-1911">          break;</front>
<front id="ultralcdCPP-1912">        case encrot3:</front>
<front id="ultralcdCPP-1913">          if (lastEncoderBits==encrot2) encoderDiff++;</front>
<front id="ultralcdCPP-1914">          else if (lastEncoderBits==encrot0) encoderDiff--;</front>
<front id="ultralcdCPP-1915">          break;</front>
<front id="ultralcdCPP-1916">      }</front>
<front id="ultralcdCPP-1917">    }</front>
<front id="ultralcdCPP-1918">    lastEncoderBits = enc;</front>
<front id="ultralcdCPP-1919">  }</front>
<front id="ultralcdCPP-1920"></front>
<front id="ultralcdCPP-1921">  bool lcd_detected(void) {</front>
<front id="ultralcdCPP-1922">    #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)</front>
<front id="ultralcdCPP-1923">      return lcd.LcdDetected() == 1;</front>
<front id="ultralcdCPP-1924">    #else</front>
<front id="ultralcdCPP-1925">      return true;</front>
<front id="ultralcdCPP-1926">    #endif</front>
<front id="ultralcdCPP-1927">  }</front>
<front id="ultralcdCPP-1928"></front>
<front id="ultralcdCPP-1929">  bool lcd_clicked() { return LCD_CLICKED; }</front>
<front id="ultralcdCPP-1930"></front>
<front id="ultralcdCPP-1931">#endif // ULTIPANEL</front>
<front id="ultralcdCPP-1932"></front>
<front id="ultralcdCPP-1933">/*********************************/</front>
<front id="ultralcdCPP-1934">/** Number to string conversion **/</front>
<front id="ultralcdCPP-1935">/*********************************/</front>
<front id="ultralcdCPP-1936"></front>
<front id="ultralcdCPP-1937">char conv[8];</front>
<front id="ultralcdCPP-1938"></front>
<front id="ultralcdCPP-1939">// Convert float to string with +123.4 format</front>
<front id="ultralcdCPP-1940">char *ftostr3(const float &x) {</front>
<front id="ultralcdCPP-1941">  return itostr3((int)x);</front>
<front id="ultralcdCPP-1942">}</front>
<front id="ultralcdCPP-1943"></front>
<front id="ultralcdCPP-1944">// Convert int to string with 12 format</front>
<front id="ultralcdCPP-1945">char *itostr2(const uint8_t &x) {</front>
<front id="ultralcdCPP-1946">  //sprintf(conv,"%5.1f",x);</front>
<front id="ultralcdCPP-1947">  int xx = x;</front>
<front id="ultralcdCPP-1948">  conv[0] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1949">  conv[1] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1950">  conv[2] = 0;</front>
<front id="ultralcdCPP-1951">  return conv;</front>
<front id="ultralcdCPP-1952">}</front>
<front id="ultralcdCPP-1953"></front>
<front id="ultralcdCPP-1954">// Convert float to string with +123.4 format</front>
<front id="ultralcdCPP-1955">char *ftostr31(const float &x) {</front>
<front id="ultralcdCPP-1956">  int xx = abs(x * 10);</front>
<front id="ultralcdCPP-1957">  conv[0] = (x &gt;= 0) ? '+' : '-';</front>
<front id="ultralcdCPP-1958">  conv[1] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1959">  conv[2] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-1960">  conv[3] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1961">  conv[4] = '.';</front>
<front id="ultralcdCPP-1962">  conv[5] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1963">  conv[6] = 0;</front>
<front id="ultralcdCPP-1964">  return conv;</front>
<front id="ultralcdCPP-1965">}</front>
<front id="ultralcdCPP-1966"></front>
<front id="ultralcdCPP-1967">// Convert float to string with 123.4 format, dropping sign</front>
<front id="ultralcdCPP-1968">char *ftostr31ns(const float &x) {</front>
<front id="ultralcdCPP-1969">  int xx = abs(x * 10);</front>
<front id="ultralcdCPP-1970">  conv[0] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1971">  conv[1] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-1972">  conv[2] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1973">  conv[3] = '.';</front>
<front id="ultralcdCPP-1974">  conv[4] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1975">  conv[5] = 0;</front>
<front id="ultralcdCPP-1976">  return conv;</front>
<front id="ultralcdCPP-1977">}</front>
<front id="ultralcdCPP-1978"></front>
<front id="ultralcdCPP-1979">// Convert float to string with 123.4 format</front>
<front id="ultralcdCPP-1980">char *ftostr32(const float &x) {</front>
<front id="ultralcdCPP-1981">  long xx = abs(x * 100);</front>
<front id="ultralcdCPP-1982">  conv[0] = x &gt;= 0 ? (xx / 10000) % 10 + '0' : '-';</front>
<front id="ultralcdCPP-1983">  conv[1] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1984">  conv[2] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-1985">  conv[3] = '.';</front>
<front id="ultralcdCPP-1986">  conv[4] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1987">  conv[5] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1988">  conv[6] = 0;</front>
<front id="ultralcdCPP-1989">  return conv;</front>
<front id="ultralcdCPP-1990">}</front>
<front id="ultralcdCPP-1991"></front>
<front id="ultralcdCPP-1992">// Convert float to string with 1.234 format</front>
<front id="ultralcdCPP-1993">char *ftostr43(const float &x) {</front>
<front id="ultralcdCPP-1994">	long xx = x * 1000;</front>
<front id="ultralcdCPP-1995">    if (xx &gt;= 0)</front>
<front id="ultralcdCPP-1996">		conv[0] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1997">	else</front>
<front id="ultralcdCPP-1998">		conv[0] = '-';</front>
<front id="ultralcdCPP-1999">	xx = abs(xx);</front>
<front id="ultralcdCPP-2000">	conv[1] = '.';</front>
<front id="ultralcdCPP-2001">	conv[2] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2002">	conv[3] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2003">	conv[4] = (xx) % 10 + '0';</front>
<front id="ultralcdCPP-2004">	conv[5] = 0;</front>
<front id="ultralcdCPP-2005">	return conv;</front>
<front id="ultralcdCPP-2006">}</front>
<front id="ultralcdCPP-2007"></front>
<front id="ultralcdCPP-2008">// Convert float to string with 1.23 format</front>
<front id="ultralcdCPP-2009">char *ftostr12ns(const float &x) {</front>
<front id="ultralcdCPP-2010">  long xx=x*100;</front>
<front id="ultralcdCPP-2011">  </front>
<front id="ultralcdCPP-2012">  xx=abs(xx);</front>
<front id="ultralcdCPP-2013">  conv[0]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-2014">  conv[1]='.';</front>
<front id="ultralcdCPP-2015">  conv[2]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-2016">  conv[3]=(xx)%10+'0';</front>
<front id="ultralcdCPP-2017">  conv[4]=0;</front>
<front id="ultralcdCPP-2018">  return conv;</front>
<front id="ultralcdCPP-2019">}</front>
<front id="ultralcdCPP-2020"></front>
<front id="ultralcdCPP-2021">// Convert float to space-padded string with -_23.4_ format</front>
<front id="ultralcdCPP-2022">char *ftostr32sp(const float &x) {</front>
<front id="ultralcdCPP-2023">  long xx = abs(x * 100);</front>
<front id="ultralcdCPP-2024">  uint8_t dig;</front>
<front id="ultralcdCPP-2025"></front>
<front id="ultralcdCPP-2026">  if (x &lt; 0) { // negative val = -_0</front>
<front id="ultralcdCPP-2027">    conv[0] = '-';</front>
<front id="ultralcdCPP-2028">    dig = (xx / 1000) % 10;</front>
<front id="ultralcdCPP-2029">    conv[1] = dig ? '0' + dig : ' ';</front>
<front id="ultralcdCPP-2030">  }</front>
<front id="ultralcdCPP-2031">  else { // positive val = __0</front>
<front id="ultralcdCPP-2032">    dig = (xx / 10000) % 10;</front>
<front id="ultralcdCPP-2033">    if (dig) {</front>
<front id="ultralcdCPP-2034">      conv[0] = '0' + dig;</front>
<front id="ultralcdCPP-2035">      conv[1] = '0' + (xx / 1000) % 10;</front>
<front id="ultralcdCPP-2036">    }</front>
<front id="ultralcdCPP-2037">    else {</front>
<front id="ultralcdCPP-2038">      conv[0] = ' ';</front>
<front id="ultralcdCPP-2039">      dig = (xx / 1000) % 10;</front>
<front id="ultralcdCPP-2040">      conv[1] = dig ? '0' + dig : ' ';</front>
<front id="ultralcdCPP-2041">    }</front>
<front id="ultralcdCPP-2042">  }</front>
<front id="ultralcdCPP-2043"></front>
<front id="ultralcdCPP-2044">  conv[2] = '0' + (xx / 100) % 10; // lsd always</front>
<front id="ultralcdCPP-2045"></front>
<front id="ultralcdCPP-2046">  dig = xx % 10;</front>
<front id="ultralcdCPP-2047">  if (dig) { // 2 decimal places</front>
<front id="ultralcdCPP-2048">    conv[5] = '0' + dig;</front>
<front id="ultralcdCPP-2049">    conv[4] = '0' + (xx / 10) % 10;</front>
<front id="ultralcdCPP-2050">    conv[3] = '.';</front>
<front id="ultralcdCPP-2051">  }</front>
<front id="ultralcdCPP-2052">  else { // 1 or 0 decimal place</front>
<front id="ultralcdCPP-2053">    dig = (xx / 10) % 10;</front>
<front id="ultralcdCPP-2054">    if (dig) {</front>
<front id="ultralcdCPP-2055">      conv[4] = '0' + dig;</front>
<front id="ultralcdCPP-2056">      conv[3] = '.';</front>
<front id="ultralcdCPP-2057">    }</front>
<front id="ultralcdCPP-2058">    else {</front>
<front id="ultralcdCPP-2059">      conv[3] = conv[4] = ' ';</front>
<front id="ultralcdCPP-2060">    }</front>
<front id="ultralcdCPP-2061">    conv[5] = ' ';</front>
<front id="ultralcdCPP-2062">  }</front>
<front id="ultralcdCPP-2063">  conv[6] = '\0';</front>
<front id="ultralcdCPP-2064">  return conv;</front>
<front id="ultralcdCPP-2065">}</front>
<front id="ultralcdCPP-2066"></front>
<front id="ultralcdCPP-2067">// Convert int to lj string with +123.0 format</front>
<front id="ultralcdCPP-2068">char *itostr31(const int &x) {</front>
<front id="ultralcdCPP-2069">  conv[0] = x &gt;= 0 ? '+' : '-';</front>
<front id="ultralcdCPP-2070">  int xx = abs(x);</front>
<front id="ultralcdCPP-2071">  conv[1] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2072">  conv[2] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2073">  conv[3] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2074">  conv[4] = '.';</front>
<front id="ultralcdCPP-2075">  conv[5] = '0';</front>
<front id="ultralcdCPP-2076">  conv[6] = 0;</front>
<front id="ultralcdCPP-2077">  return conv;</front>
<front id="ultralcdCPP-2078">}</front>
<front id="ultralcdCPP-2079"></front>
<front id="ultralcdCPP-2080">// Convert int to rj string with 123 or -12 format</front>
<front id="ultralcdCPP-2081">char *itostr3(const int &x) {</front>
<front id="ultralcdCPP-2082">  int xx = x;</front>
<front id="ultralcdCPP-2083">  if (xx &lt; 0) {</front>
<front id="ultralcdCPP-2084">     conv[0] = '-';</front>
<front id="ultralcdCPP-2085">     xx = -xx;</front>
<front id="ultralcdCPP-2086">  }</front>
<front id="ultralcdCPP-2087">  else</front>
<front id="ultralcdCPP-2088">    conv[0] = xx &gt;= 100 ? (xx / 100) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2089"></front>
<front id="ultralcdCPP-2090">  conv[1] = xx &gt;= 10 ? (xx / 10) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2091">  conv[2] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2092">  conv[3] = 0;</front>
<front id="ultralcdCPP-2093">  return conv;</front>
<front id="ultralcdCPP-2094">}</front>
<front id="ultralcdCPP-2095"></front>
<front id="ultralcdCPP-2096">// Convert int to lj string with 123 format</front>
<front id="ultralcdCPP-2097">char *itostr3left(const int &xx) {</front>
<front id="ultralcdCPP-2098">  if (xx &gt;= 100) {</front>
<front id="ultralcdCPP-2099">    conv[0] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2100">    conv[1] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2101">    conv[2] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2102">    conv[3] = 0;</front>
<front id="ultralcdCPP-2103">  }</front>
<front id="ultralcdCPP-2104">  else if (xx &gt;= 10) {</front>
<front id="ultralcdCPP-2105">    conv[0] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2106">    conv[1] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2107">    conv[2] = 0;</front>
<front id="ultralcdCPP-2108">  }</front>
<front id="ultralcdCPP-2109">  else {</front>
<front id="ultralcdCPP-2110">    conv[0] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2111">    conv[1] = 0;</front>
<front id="ultralcdCPP-2112">  }</front>
<front id="ultralcdCPP-2113">  return conv;</front>
<front id="ultralcdCPP-2114">}</front>
<front id="ultralcdCPP-2115"></front>
<front id="ultralcdCPP-2116">// Convert int to rj string with 1234 format</front>
<front id="ultralcdCPP-2117">char *itostr4(const int &xx) {</front>
<front id="ultralcdCPP-2118">  conv[0] = xx &gt;= 1000 ? (xx / 1000) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2119">  conv[1] = xx &gt;= 100 ? (xx / 100) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2120">  conv[2] = xx &gt;= 10 ? (xx / 10) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2121">  conv[3] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2122">  conv[4] = 0;</front>
<front id="ultralcdCPP-2123">  return conv;</front>
<front id="ultralcdCPP-2124">}</front>
<front id="ultralcdCPP-2125"></front>
<front id="ultralcdCPP-2126">// Convert float to rj string with 12345 format</front>
<front id="ultralcdCPP-2127">char *ftostr5(const float &x) {</front>
<front id="ultralcdCPP-2128">  long xx = abs(x);</front>
<front id="ultralcdCPP-2129">  conv[0] = xx &gt;= 10000 ? (xx / 10000) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2130">  conv[1] = xx &gt;= 1000 ? (xx / 1000) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2131">  conv[2] = xx &gt;= 100 ? (xx / 100) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2132">  conv[3] = xx &gt;= 10 ? (xx / 10) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2133">  conv[4] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2134">  conv[5] = 0;</front>
<front id="ultralcdCPP-2135">  return conv;</front>
<front id="ultralcdCPP-2136">}</front>
<front id="ultralcdCPP-2137"></front>
<front id="ultralcdCPP-2138">// Convert float to string with +1234.5 format</front>
<front id="ultralcdCPP-2139">char *ftostr51(const float &x) {</front>
<front id="ultralcdCPP-2140">  long xx = abs(x * 10);</front>
<front id="ultralcdCPP-2141">  conv[0] = (x &gt;= 0) ? '+' : '-';</front>
<front id="ultralcdCPP-2142">  conv[1] = (xx / 10000) % 10 + '0';</front>
<front id="ultralcdCPP-2143">  conv[2] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-2144">  conv[3] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2145">  conv[4] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2146">  conv[5] = '.';</front>
<front id="ultralcdCPP-2147">  conv[6] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2148">  conv[7] = 0;</front>
<front id="ultralcdCPP-2149">  return conv;</front>
<front id="ultralcdCPP-2150">}</front>
<front id="ultralcdCPP-2151"></front>
<front id="ultralcdCPP-2152">// Convert float to string with +123.45 format</front>
<front id="ultralcdCPP-2153">char *ftostr52(const float &x) {</front>
<front id="ultralcdCPP-2154">  conv[0] = (x &gt;= 0) ? '+' : '-';</front>
<front id="ultralcdCPP-2155">  long xx = abs(x * 100);</front>
<front id="ultralcdCPP-2156">  conv[1] = (xx / 10000) % 10 + '0';</front>
<front id="ultralcdCPP-2157">  conv[2] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-2158">  conv[3] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2159">  conv[4] = '.';</front>
<front id="ultralcdCPP-2160">  conv[5] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2161">  conv[6] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2162">  conv[7] = 0;</front>
<front id="ultralcdCPP-2163">  return conv;</front>
<front id="ultralcdCPP-2164">}</front>
<front id="ultralcdCPP-2165"></front>
<front id="ultralcdCPP-2166">#if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-2167"></front>
<front id="ultralcdCPP-2168">  static int _lcd_level_bed_position;</front>
<front id="ultralcdCPP-2169"></front>
<front id="ultralcdCPP-2170">  /**</front>
<front id="ultralcdCPP-2171">   * MBL Wait for controller movement and clicks:</front>
<front id="ultralcdCPP-2172">   *   - Movement adjusts the Z axis</front>
<front id="ultralcdCPP-2173">   *   - Click saves the Z and goes to the next mesh point</front>
<front id="ultralcdCPP-2174">   */</front>
<front id="ultralcdCPP-2175">  static void _lcd_level_bed() {</front>
<front id="ultralcdCPP-2176">    if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-2177">      refresh_cmd_timeout();</front>
<front id="ultralcdCPP-2178">      current_position[Z_AXIS] += float((int)encoderPosition) * MBL_Z_STEP;</front>
<front id="ultralcdCPP-2179">      if (min_software_endstops && current_position[Z_AXIS] &lt; Z_MIN_POS) current_position[Z_AXIS] = Z_MIN_POS;</front>
<front id="ultralcdCPP-2180">      if (max_software_endstops && current_position[Z_AXIS] &gt; Z_MAX_POS) current_position[Z_AXIS] = Z_MAX_POS;</front>
<front id="ultralcdCPP-2181">      encoderPosition = 0;</front>
<front id="ultralcdCPP-2182">      line_to_current(Z_AXIS);</front>
<front id="ultralcdCPP-2183">      lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2184">    }</front>
<front id="ultralcdCPP-2185">    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("Z"), ftostr43(current_position[Z_AXIS]));</front>
<front id="ultralcdCPP-2186">    static bool debounce_click = false;</front>
<front id="ultralcdCPP-2187">    if (LCD_CLICKED) {</front>
<front id="ultralcdCPP-2188">      if (!debounce_click) {</front>
<front id="ultralcdCPP-2189">        debounce_click = true;</front>
<front id="ultralcdCPP-2190">        int ix = _lcd_level_bed_position % MESH_NUM_X_POINTS,</front>
<front id="ultralcdCPP-2191">            iy = _lcd_level_bed_position / MESH_NUM_X_POINTS;</front>
<front id="ultralcdCPP-2192">        if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // Zig zag</front>
<front id="ultralcdCPP-2193">        mbl.set_z(ix, iy, current_position[Z_AXIS]);</front>
<front id="ultralcdCPP-2194">        _lcd_level_bed_position++;</front>
<front id="ultralcdCPP-2195">        if (_lcd_level_bed_position == MESH_NUM_X_POINTS*MESH_NUM_Y_POINTS) {</front>
<front id="ultralcdCPP-2196">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="ultralcdCPP-2197">          line_to_current(Z_AXIS);</front>
<front id="ultralcdCPP-2198">          mbl.active = 1;</front>
<front id="ultralcdCPP-2199">          enqueuecommands_P(PSTR("G28"));</front>
<front id="ultralcdCPP-2200">          lcd_return_to_status();</front>
<front id="ultralcdCPP-2201">        }</front>
<front id="ultralcdCPP-2202">        else {</front>
<front id="ultralcdCPP-2203">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="ultralcdCPP-2204">          line_to_current(Z_AXIS);</front>
<front id="ultralcdCPP-2205">          ix = _lcd_level_bed_position % MESH_NUM_X_POINTS;</front>
<front id="ultralcdCPP-2206">          iy = _lcd_level_bed_position / MESH_NUM_X_POINTS;</front>
<front id="ultralcdCPP-2207">          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // Zig zag</front>
<front id="ultralcdCPP-2208">          current_position[X_AXIS] = mbl.get_x(ix);</front>
<front id="ultralcdCPP-2209">          current_position[Y_AXIS] = mbl.get_y(iy);</front>
<front id="ultralcdCPP-2210">          line_to_current(manual_feedrate[X_AXIS] &lt;= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);</front>
<front id="ultralcdCPP-2211">          lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2212">        }</front>
<front id="ultralcdCPP-2213">      }</front>
<front id="ultralcdCPP-2214">    }</front>
<front id="ultralcdCPP-2215">    else {</front>
<front id="ultralcdCPP-2216">      debounce_click = false;</front>
<front id="ultralcdCPP-2217">    }</front>
<front id="ultralcdCPP-2218">  }</front>
<front id="ultralcdCPP-2219"></front>
<front id="ultralcdCPP-2220">  /**</front>
<front id="ultralcdCPP-2221">   * MBL Move to mesh starting point</front>
<front id="ultralcdCPP-2222">   */</front>
<front id="ultralcdCPP-2223">  static void _lcd_level_bed_homing() {</front>
<front id="ultralcdCPP-2224">    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("XYZ"), "Homing");</front>
<front id="ultralcdCPP-2225">    if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]) {</front>
<front id="ultralcdCPP-2226">      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="ultralcdCPP-2227">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="ultralcdCPP-2228">      current_position[X_AXIS] = MESH_MIN_X;</front>
<front id="ultralcdCPP-2229">      current_position[Y_AXIS] = MESH_MIN_Y;</front>
<front id="ultralcdCPP-2230">      line_to_current(manual_feedrate[X_AXIS] &lt;= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);</front>
<front id="ultralcdCPP-2231">      _lcd_level_bed_position = 0;</front>
<front id="ultralcdCPP-2232">      lcd_goto_menu(_lcd_level_bed);</front>
<front id="ultralcdCPP-2233">    }</front>
<front id="ultralcdCPP-2234">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2235">  }</front>
<front id="ultralcdCPP-2236"></front>
<front id="ultralcdCPP-2237">  /**</front>
<front id="ultralcdCPP-2238">   * MBL entry-point</front>
<front id="ultralcdCPP-2239">   */</front>
<front id="ultralcdCPP-2240">  static void lcd_level_bed() {</front>
<front id="ultralcdCPP-2241">    axis_known_position[X_AXIS] = axis_known_position[Y_AXIS] = axis_known_position[Z_AXIS] = false;</front>
<front id="ultralcdCPP-2242">    mbl.reset();</front>
<front id="ultralcdCPP-2243">    enqueuecommands_P(PSTR("G28"));</front>
<front id="ultralcdCPP-2244">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2245">    lcd_goto_menu(_lcd_level_bed_homing);</front>
<front id="ultralcdCPP-2246">  }</front>
<front id="ultralcdCPP-2247"></front>
<front id="ultralcdCPP-2248">#endif  // MANUAL_BED_LEVELING</front>
<front id="ultralcdCPP-2249"></front>
<front id="ultralcdCPP-2250">#endif // ULTRA_LCD</front>
 </pre>
<script src="svgDraw.js"></script>
</body>
</html>
