<html>
<head>
	<title></title>
<link rel="stylesheet" type="text/css" href="6236.css">
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
 <script src="http://code.jquery.com/jquery-1.10.2.js"></script>
  <script src="http://code.jquery.com/ui/1.11.4/jquery-ui.js"></script>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
</head>
<body ginger_software_stylesheet="true" ginger_software_doc="true">
	  <IMG id= "expectIMG"SRC="expect.png" style="float: right;width:300px;height:250px;" />
        <IMG id= "resultIMG"SRC="result.png" style="float: right;width:300px;height:250px;" />
       
	<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
	 <style>
        .prettyprint ol.linenums > li { list-style-type: decimal; }
    </style>
<button>toggle the div</button>
<script src="toggle.js"></script>
<h1 id="blinkmCPPtitle" >blinkm.cpp</h1>
<pre id="blinkmCPP"  class="prettyprint linenums"><front id="blinkmCPP-1">/*</front>
<front id="blinkmCPP-2">  blinkm.cpp - Library for controlling a BlinkM over i2c</front>
<front id="blinkmCPP-3">  Created by Tim Koster, August 21 2013.</front>
<front id="blinkmCPP-4">*/</front>
<front id="blinkmCPP-5">#include "Marlin.h"</front>
<front id="blinkmCPP-6"></front>
<front id="blinkmCPP-7">#if ENABLED(BLINKM)</front>
<front id="blinkmCPP-8"></front>
<front id="blinkmCPP-9">#include "blinkm.h"</front>
<front id="blinkmCPP-10"></front>
<front id="blinkmCPP-11">void SendColors(byte red, byte grn, byte blu) {</front>
<front id="blinkmCPP-12">  Wire.begin(); </front>
<front id="blinkmCPP-13">  Wire.beginTransmission(0x09);</front>
<front id="blinkmCPP-14">  Wire.write('o');                    //to disable ongoing script, only needs to be used once</front>
<front id="blinkmCPP-15">  Wire.write('n');</front>
<front id="blinkmCPP-16">  Wire.write(red);</front>
<front id="blinkmCPP-17">  Wire.write(grn);</front>
<front id="blinkmCPP-18">  Wire.write(blu);</front>
<front id="blinkmCPP-19">  Wire.endTransmission();</front>
<front id="blinkmCPP-20">}</front>
<front id="blinkmCPP-21"></front>
<front id="blinkmCPP-22">#endif //BLINKM</front>
<front id="blinkmCPP-23"></front>
 </pre>
<h1 id="blinkmHtitle" >blinkm.h</h1>
<pre id="blinkmH"  class="prettyprint linenums"><front id="blinkmH-1">/*</front>
<front id="blinkmH-2">  blinkm.h</front>
<front id="blinkmH-3">  Library header file for BlinkM library</front>
<front id="blinkmH-4"> */</front>
<front id="blinkmH-5"></front>
<front id="blinkmH-6">#include "Arduino.h"</front>
<front id="blinkmH-7">#include "Wire.h"</front>
<front id="blinkmH-8"></front>
<front id="blinkmH-9">void SendColors(byte red, byte grn, byte blu);</front>
 </pre>
<h1 id="boardsHtitle" >boards.h</h1>
<pre id="boardsH"  class="prettyprint linenums"><front id="boardsH-1">#ifndef BOARDS_H</front>
<front id="boardsH-2">#define BOARDS_H</front>
<front id="boardsH-3"></front>
<front id="boardsH-4">#define BOARD_UNKNOWN -1</front>
<front id="boardsH-5"></front>
<front id="boardsH-6">#define BOARD_GEN7_CUSTOM       10   // Gen7 custom (Alfons3 Version) "https://github.com/Alfons3/Generation_7_Electronics"</front>
<front id="boardsH-7">#define BOARD_GEN7_12           11   // Gen7 v1.1, v1.2</front>
<front id="boardsH-8">#define BOARD_GEN7_13           12   // Gen7 v1.3</front>
<front id="boardsH-9">#define BOARD_GEN7_14           13   // Gen7 v1.4</front>
<front id="boardsH-10">#define BOARD_CHEAPTRONIC       2    // Cheaptronic v1.0</front>
<front id="boardsH-11">#define BOARD_SETHI             20   // Sethi 3D_1</front>
<front id="boardsH-12">#define BOARD_RAMPS_OLD         3    // MEGA/RAMPS up to 1.2</front>
<front id="boardsH-13">#define BOARD_RAMPS_13_EFB      33   // RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Bed)</front>
<front id="boardsH-14">#define BOARD_RAMPS_13_EEB      34   // RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Bed)</front>
<front id="boardsH-15">#define BOARD_RAMPS_13_EFF      35   // RAMPS 1.3 / 1.4 (Power outputs: Extruder, Fan, Fan)</front>
<front id="boardsH-16">#define BOARD_RAMPS_13_EEF      36   // RAMPS 1.3 / 1.4 (Power outputs: Extruder0, Extruder1, Fan)</front>
<front id="boardsH-17">#define BOARD_RAMPS_13_SF       38   // RAMPS 1.3 / 1.4 (Power outputs: Spindle, Controller Fan)</front>
<front id="boardsH-18">#define BOARD_FELIX2            37   // Felix 2.0+ Electronics Board (RAMPS like)</front>
<front id="boardsH-19">#define BOARD_RIGIDBOARD        42   // Invent-A-Part RigidBoard</front>
<front id="boardsH-20">#define BOARD_GEN6              5    // Gen6</front>
<front id="boardsH-21">#define BOARD_GEN6_DELUXE       51   // Gen6 deluxe</front>
<front id="boardsH-22">#define BOARD_SANGUINOLOLU_11   6    // Sanguinololu &lt; 1.2</front>
<front id="boardsH-23">#define BOARD_SANGUINOLOLU_12   62   // Sanguinololu 1.2 and above</front>
<front id="boardsH-24">#define BOARD_MELZI             63   // Melzi</front>
<front id="boardsH-25">#define BOARD_STB_11            64   // STB V1.1</front>
<front id="boardsH-26">#define BOARD_AZTEEG_X1         65   // Azteeg X1</front>
<front id="boardsH-27">#define BOARD_MELZI_MAKR3D      66   // Melzi with ATmega1284 (MaKr3d version)</front>
<front id="boardsH-28">#define BOARD_AZTEEG_X3         67   // Azteeg X3</front>
<front id="boardsH-29">#define BOARD_AZTEEG_X3_PRO     68   // Azteeg X3 Pro</front>
<front id="boardsH-30">#define BOARD_ULTIMAKER         7    // Ultimaker</front>
<front id="boardsH-31">#define BOARD_ULTIMAKER_OLD     71   // Ultimaker (Older electronics. Pre 1.5.4. This is rare)</front>
<front id="boardsH-32">#define BOARD_ULTIMAIN_2        72   // Ultimainboard 2.x (Uses TEMP_SENSOR 20)</front>
<front id="boardsH-33">#define BOARD_3DRAG             77   // 3Drag Controller</front>
<front id="boardsH-34">#define BOARD_K8200             78   // Vellemann K8200 Controller (derived from 3Drag Controller)</front>
<front id="boardsH-35">#define BOARD_TEENSYLU          8    // Teensylu</front>
<front id="boardsH-36">#define BOARD_RUMBA             80   // Rumba</front>
<front id="boardsH-37">#define BOARD_PRINTRBOARD       81   // Printrboard (AT90USB1286)</front>
<front id="boardsH-38">#define BOARD_BRAINWAVE         82   // Brainwave (AT90USB646)</front>
<front id="boardsH-39">#define BOARD_SAV_MKI           83   // SAV Mk-I (AT90USB1286)</front>
<front id="boardsH-40">#define BOARD_TEENSY2           84   // Teensy++2.0 (AT90USB1286) - CLI compile: DEFINES=AT90USBxx_TEENSYPP_ASSIGNMENTS HARDWARE_MOTHERBOARD=84  make</front>
<front id="boardsH-41">#define BOARD_BRAINWAVE_PRO     85   // Brainwave Pro (AT90USB1286)</front>
<front id="boardsH-42">#define BOARD_GEN3_PLUS         9    // Gen3+</front>
<front id="boardsH-43">#define BOARD_GEN3_MONOLITHIC   22   // Gen3 Monolithic Electronics</front>
<front id="boardsH-44">#define BOARD_MEGATRONICS       70   // Megatronics</front>
<front id="boardsH-45">#define BOARD_MEGATRONICS_2     701  // Megatronics v2.0</front>
<front id="boardsH-46">#define BOARD_MINITRONICS       702  // Minitronics v1.0/1.1</front>
<front id="boardsH-47">#define BOARD_MEGATRONICS_3     703  // Megatronics v3.0</front>
<front id="boardsH-48">#define BOARD_OMCA_A            90   // Alpha OMCA board</front>
<front id="boardsH-49">#define BOARD_OMCA              91   // Final OMCA board</front>
<front id="boardsH-50">#define BOARD_RAMBO             301  // Rambo</front>
<front id="boardsH-51">#define BOARD_MINIRAMBO         302  // Mini-Rambo</front>
<front id="boardsH-52">#define BOARD_MEGACONTROLLER    310  // Mega controller</front>
<front id="boardsH-53">#define BOARD_ELEFU_3           21   // Elefu Ra Board (v3)</front>
<front id="boardsH-54">#define BOARD_5DPRINT           88   // 5DPrint D8 Driver Board</front>
<front id="boardsH-55">#define BOARD_LEAPFROG          999  // Leapfrog</front>
<front id="boardsH-56">#define BOARD_MKS_BASE          40   // MKS BASE 1.0</front>
<front id="boardsH-57">#define BOARD_BAM_DICE          401  // 2PrintBeta BAM&DICE with STK drivers</front>
<front id="boardsH-58">#define BOARD_BAM_DICE_DUE      402  // 2PrintBeta BAM&DICE Due with STK drivers</front>
<front id="boardsH-59"></front>
<front id="boardsH-60">#define BOARD_99                99   // This is in pins.h but...?</front>
<front id="boardsH-61"></front>
<front id="boardsH-62">#define MB(board) (MOTHERBOARD==BOARD_##board)</front>
<front id="boardsH-63"></front>
<front id="boardsH-64">#endif //__BOARDS_H</front>
 </pre>
<h1 id="buzzerCPPtitle" >buzzer.cpp</h1>
<pre id="buzzerCPP"  class="prettyprint linenums"><front id="buzzerCPP-1">#include "Marlin.h"</front>
<front id="buzzerCPP-2">#if HAS_BUZZER</front>
<front id="buzzerCPP-3">  #include "buzzer.h"</front>
<front id="buzzerCPP-4">  #include "ultralcd.h"</front>
<front id="buzzerCPP-5"></front>
<front id="buzzerCPP-6">  void buzz(long duration, uint16_t freq) {</front>
<front id="buzzerCPP-7">    if (freq &gt; 0) {</front>
<front id="buzzerCPP-8">      #if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="buzzerCPP-9">        lcd_buzz(duration, freq);</front>
<front id="buzzerCPP-10">      #elif PIN_EXISTS(BEEPER) // on-board buzzers have no further condition</front>
<front id="buzzerCPP-11">        SET_OUTPUT(BEEPER_PIN);</front>
<front id="buzzerCPP-12">        #if ENABLED(SPEAKER) // a speaker needs a AC ore a pulsed DC</front>
<front id="buzzerCPP-13">          //tone(BEEPER_PIN, freq, duration); // needs a PWMable pin</front>
<front id="buzzerCPP-14">          unsigned int delay = 1000000 / freq / 2;</front>
<front id="buzzerCPP-15">          int i = duration * freq / 1000;</front>
<front id="buzzerCPP-16">          while (i--) {</front>
<front id="buzzerCPP-17">            WRITE(BEEPER_PIN, HIGH);</front>
<front id="buzzerCPP-18">            delayMicroseconds(delay);</front>
<front id="buzzerCPP-19">            WRITE(BEEPER_PIN, LOW);</front>
<front id="buzzerCPP-20">            delayMicroseconds(delay);</front>
<front id="buzzerCPP-21">           }</front>
<front id="buzzerCPP-22">        #else // buzzer has its own resonator - needs a DC</front>
<front id="buzzerCPP-23">          WRITE(BEEPER_PIN, HIGH);</front>
<front id="buzzerCPP-24">          delay(duration);</front>
<front id="buzzerCPP-25">          WRITE(BEEPER_PIN, LOW);</front>
<front id="buzzerCPP-26">        #endif</front>
<front id="buzzerCPP-27">      #else</front>
<front id="buzzerCPP-28">        delay(duration);</front>
<front id="buzzerCPP-29">      #endif</front>
<front id="buzzerCPP-30">    }</front>
<front id="buzzerCPP-31">    else {</front>
<front id="buzzerCPP-32">      delay(duration);</front>
<front id="buzzerCPP-33">    }</front>
<front id="buzzerCPP-34">  }</front>
<front id="buzzerCPP-35">#endif</front>
 </pre>
<h1 id="buzzerHtitle" >buzzer.h</h1>
<pre id="buzzerH"  class="prettyprint linenums"><front id="buzzerH-1">#ifndef BUZZER_H</front>
<front id="buzzerH-2">  #define BUZZER_H</front>
<front id="buzzerH-3"></front>
<front id="buzzerH-4">  #if HAS_BUZZER</front>
<front id="buzzerH-5">    void buzz(long duration,uint16_t freq);</front>
<front id="buzzerH-6">  #endif</front>
<front id="buzzerH-7"></front>
<front id="buzzerH-8">#endif //BUZZER_H</front>
 </pre>
<h1 id="cardreaderCPPtitle" >cardreader.cpp</h1>
<pre id="cardreaderCPP"  class="prettyprint linenums"><front id="cardreaderCPP-1">#include "Marlin.h"</front>
<front id="cardreaderCPP-2">#include "cardreader.h"</front>
<front id="cardreaderCPP-3">#include "ultralcd.h"</front>
<front id="cardreaderCPP-4">#include "stepper.h"</front>
<front id="cardreaderCPP-5">#include "temperature.h"</front>
<front id="cardreaderCPP-6">#include "language.h"</front>
<front id="cardreaderCPP-7"></front>
<front id="cardreaderCPP-8">#if ENABLED(SDSUPPORT)</front>
<front id="cardreaderCPP-9"></front>
<front id="cardreaderCPP-10">CardReader::CardReader() {</front>
<front id="cardreaderCPP-11">  filesize = 0;</front>
<front id="cardreaderCPP-12">  sdpos = 0;</front>
<front id="cardreaderCPP-13">  sdprinting = false;</front>
<front id="cardreaderCPP-14">  cardOK = false;</front>
<front id="cardreaderCPP-15">  saving = false;</front>
<front id="cardreaderCPP-16">  logging = false;</front>
<front id="cardreaderCPP-17">  workDirDepth = 0;</front>
<front id="cardreaderCPP-18">  file_subcall_ctr = 0;</front>
<front id="cardreaderCPP-19">  memset(workDirParents, 0, sizeof(workDirParents));</front>
<front id="cardreaderCPP-20"></front>
<front id="cardreaderCPP-21">  autostart_stilltocheck = true; //the SD start is delayed, because otherwise the serial cannot answer fast enough to make contact with the host software.</front>
<front id="cardreaderCPP-22">  autostart_index = 0;</front>
<front id="cardreaderCPP-23"></front>
<front id="cardreaderCPP-24">  //power to SD reader</front>
<front id="cardreaderCPP-25">  #if SDPOWER &gt; -1</front>
<front id="cardreaderCPP-26">    OUT_WRITE(SDPOWER, HIGH);</front>
<front id="cardreaderCPP-27">  #endif //SDPOWER</front>
<front id="cardreaderCPP-28"></front>
<front id="cardreaderCPP-29">  next_autostart_ms = millis() + 5000;</front>
<front id="cardreaderCPP-30">}</front>
<front id="cardreaderCPP-31"></front>
<front id="cardreaderCPP-32">char *createFilename(char *buffer, const dir_t &p) { //buffer &gt; 12characters</front>
<front id="cardreaderCPP-33">  char *pos = buffer;</front>
<front id="cardreaderCPP-34">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="cardreaderCPP-35">    if (p.name[i] == ' ') continue;</front>
<front id="cardreaderCPP-36">    if (i == 8) *pos++ = '.';</front>
<front id="cardreaderCPP-37">    *pos++ = p.name[i];</front>
<front id="cardreaderCPP-38">  }</front>
<front id="cardreaderCPP-39">  *pos++ = 0;</front>
<front id="cardreaderCPP-40">  return buffer;</front>
<front id="cardreaderCPP-41">}</front>
<front id="cardreaderCPP-42"></front>
<front id="cardreaderCPP-43">/**</front>
<front id="cardreaderCPP-44"> * Dive into a folder and recurse depth-first to perform a pre-set operation lsAction:</front>
<front id="cardreaderCPP-45"> *   LS_Count       - Add +1 to nrFiles for every file within the parent</front>
<front id="cardreaderCPP-46"> *   LS_GetFilename - Get the filename of the file indexed by nrFiles</front>
<front id="cardreaderCPP-47"> *   LS_SerialPrint - Print the full path of each file to serial output</front>
<front id="cardreaderCPP-48"> */</front>
<front id="cardreaderCPP-49">void CardReader::lsDive(const char *prepend, SdFile parent, const char * const match/*=NULL*/) {</front>
<front id="cardreaderCPP-50">  dir_t p;</front>
<front id="cardreaderCPP-51">  uint8_t cnt = 0;</front>
<front id="cardreaderCPP-52"></front>
<front id="cardreaderCPP-53">  // Read the next entry from a directory</front>
<front id="cardreaderCPP-54">  while (parent.readDir(p, longFilename) &gt; 0) {</front>
<front id="cardreaderCPP-55"></front>
<front id="cardreaderCPP-56">    // If the entry is a directory and the action is LS_SerialPrint</front>
<front id="cardreaderCPP-57">    if (DIR_IS_SUBDIR(&p) && lsAction != LS_Count && lsAction != LS_GetFilename) {</front>
<front id="cardreaderCPP-58"></front>
<front id="cardreaderCPP-59">      // Get the short name for the item, which we know is a folder</front>
<front id="cardreaderCPP-60">      char lfilename[FILENAME_LENGTH];</front>
<front id="cardreaderCPP-61">      createFilename(lfilename, p);</front>
<front id="cardreaderCPP-62"></front>
<front id="cardreaderCPP-63">      // Allocate enough stack space for the full path to a folder, trailing slash, and nul</front>
<front id="cardreaderCPP-64">      boolean prepend_is_empty = (prepend[0] == '\0');</front>
<front id="cardreaderCPP-65">      int len = (prepend_is_empty ? 1 : strlen(prepend)) + strlen(lfilename) + 1 + 1;</front>
<front id="cardreaderCPP-66">      char path[len];</front>
<front id="cardreaderCPP-67"></front>
<front id="cardreaderCPP-68">      // Append the FOLDERNAME12/ to the passed string.</front>
<front id="cardreaderCPP-69">      // It contains the full path to the "parent" argument.</front>
<front id="cardreaderCPP-70">      // We now have the full path to the item in this folder.</front>
<front id="cardreaderCPP-71">      strcpy(path, prepend_is_empty ? "/" : prepend); // root slash if prepend is empty</front>
<front id="cardreaderCPP-72">      strcat(path, lfilename); // FILENAME_LENGTH-1 characters maximum</front>
<front id="cardreaderCPP-73">      strcat(path, "/");       // 1 character</front>
<front id="cardreaderCPP-74"></front>
<front id="cardreaderCPP-75">      // Serial.print(path);</front>
<front id="cardreaderCPP-76"></front>
<front id="cardreaderCPP-77">      // Get a new directory object using the full path</front>
<front id="cardreaderCPP-78">      // and dive recursively into it.</front>
<front id="cardreaderCPP-79">      SdFile dir;</front>
<front id="cardreaderCPP-80">      if (!dir.open(parent, lfilename, O_READ)) {</front>
<front id="cardreaderCPP-81">        if (lsAction == LS_SerialPrint) {</front>
<front id="cardreaderCPP-82">          SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-83">          SERIAL_ECHOLN(MSG_SD_CANT_OPEN_SUBDIR);</front>
<front id="cardreaderCPP-84">          SERIAL_ECHOLN(lfilename);</front>
<front id="cardreaderCPP-85">        }</front>
<front id="cardreaderCPP-86">      }</front>
<front id="cardreaderCPP-87">      lsDive(path, dir);</front>
<front id="cardreaderCPP-88">      // close() is done automatically by destructor of SdFile</front>
<front id="cardreaderCPP-89">    }</front>
<front id="cardreaderCPP-90">    else {</front>
<front id="cardreaderCPP-91">      char pn0 = p.name[0];</front>
<front id="cardreaderCPP-92">      if (pn0 == DIR_NAME_FREE) break;</front>
<front id="cardreaderCPP-93">      if (pn0 == DIR_NAME_DELETED || pn0 == '.') continue;</front>
<front id="cardreaderCPP-94">      if (longFilename[0] == '.') continue;</front>
<front id="cardreaderCPP-95"></front>
<front id="cardreaderCPP-96">      if (!DIR_IS_FILE_OR_SUBDIR(&p)) continue;</front>
<front id="cardreaderCPP-97"></front>
<front id="cardreaderCPP-98">      filenameIsDir = DIR_IS_SUBDIR(&p);</front>
<front id="cardreaderCPP-99"></front>
<front id="cardreaderCPP-100">      if (!filenameIsDir && (p.name[8] != 'G' || p.name[9] == '~')) continue;</front>
<front id="cardreaderCPP-101"></front>
<front id="cardreaderCPP-102">      switch (lsAction) {</front>
<front id="cardreaderCPP-103">        case LS_Count:</front>
<front id="cardreaderCPP-104">          nrFiles++;</front>
<front id="cardreaderCPP-105">          break;</front>
<front id="cardreaderCPP-106">        case LS_SerialPrint:</front>
<front id="cardreaderCPP-107">          createFilename(filename, p);</front>
<front id="cardreaderCPP-108">          SERIAL_PROTOCOL(prepend);</front>
<front id="cardreaderCPP-109">          SERIAL_PROTOCOLLN(filename);</front>
<front id="cardreaderCPP-110">          break;</front>
<front id="cardreaderCPP-111">        case LS_GetFilename:</front>
<front id="cardreaderCPP-112">          createFilename(filename, p);</front>
<front id="cardreaderCPP-113">          if (match != NULL) {</front>
<front id="cardreaderCPP-114">            if (strcasecmp(match, filename) == 0) return;</front>
<front id="cardreaderCPP-115">          }</front>
<front id="cardreaderCPP-116">          else if (cnt == nrFiles) return;</front>
<front id="cardreaderCPP-117">          cnt++;</front>
<front id="cardreaderCPP-118">          break;</front>
<front id="cardreaderCPP-119">      }</front>
<front id="cardreaderCPP-120"></front>
<front id="cardreaderCPP-121">    }</front>
<front id="cardreaderCPP-122">  } // while readDir</front>
<front id="cardreaderCPP-123">}</front>
<front id="cardreaderCPP-124"></front>
<front id="cardreaderCPP-125">void CardReader::ls()  {</front>
<front id="cardreaderCPP-126">  lsAction = LS_SerialPrint;</front>
<front id="cardreaderCPP-127">  root.rewind();</front>
<front id="cardreaderCPP-128">  lsDive("", root);</front>
<front id="cardreaderCPP-129">}</front>
<front id="cardreaderCPP-130"></front>
<front id="cardreaderCPP-131">#if ENABLED(LONG_FILENAME_HOST_SUPPORT)</front>
<front id="cardreaderCPP-132"></front>
<front id="cardreaderCPP-133">  /**</front>
<front id="cardreaderCPP-134">   * Get a long pretty path based on a DOS 8.3 path</front>
<front id="cardreaderCPP-135">   */</front>
<front id="cardreaderCPP-136">  void CardReader::printLongPath(char *path) {</front>
<front id="cardreaderCPP-137">    lsAction = LS_GetFilename;</front>
<front id="cardreaderCPP-138"></front>
<front id="cardreaderCPP-139">    int i, pathLen = strlen(path);</front>
<front id="cardreaderCPP-140"></front>
<front id="cardreaderCPP-141">    // SERIAL_ECHOPGM("Full Path: "); SERIAL_ECHOLN(path);</front>
<front id="cardreaderCPP-142"></front>
<front id="cardreaderCPP-143">    // Zero out slashes to make segments</front>
<front id="cardreaderCPP-144">    for (i = 0; i &lt; pathLen; i++) if (path[i] == '/') path[i] = '\0';</front>
<front id="cardreaderCPP-145"></front>
<front id="cardreaderCPP-146">    SdFile diveDir = root; // start from the root for segment 1</front>
<front id="cardreaderCPP-147">    for (i = 0; i &lt; pathLen;) {</front>
<front id="cardreaderCPP-148"></front>
<front id="cardreaderCPP-149">      if (path[i] == '\0') i++; // move past a single nul</front>
<front id="cardreaderCPP-150"></front>
<front id="cardreaderCPP-151">      char *segment = &path[i]; // The segment after most slashes</front>
<front id="cardreaderCPP-152"></front>
<front id="cardreaderCPP-153">      // If a segment is empty (extra-slash) then exit</front>
<front id="cardreaderCPP-154">      if (!*segment) break;</front>
<front id="cardreaderCPP-155"></front>
<front id="cardreaderCPP-156">      // Go to the next segment</front>
<front id="cardreaderCPP-157">      while (path[++i]) { }</front>
<front id="cardreaderCPP-158"></front>
<front id="cardreaderCPP-159">      // SERIAL_ECHOPGM("Looking for segment: "); SERIAL_ECHOLN(segment);</front>
<front id="cardreaderCPP-160"></front>
<front id="cardreaderCPP-161">      // Find the item, setting the long filename</front>
<front id="cardreaderCPP-162">      diveDir.rewind();</front>
<front id="cardreaderCPP-163">      lsDive("", diveDir, segment);</front>
<front id="cardreaderCPP-164"></front>
<front id="cardreaderCPP-165">      // Print /LongNamePart to serial output</front>
<front id="cardreaderCPP-166">      SERIAL_PROTOCOLCHAR('/');</front>
<front id="cardreaderCPP-167">      SERIAL_PROTOCOL(longFilename[0] ? longFilename : "???");</front>
<front id="cardreaderCPP-168"></front>
<front id="cardreaderCPP-169">      // If the filename was printed then that's it</front>
<front id="cardreaderCPP-170">      if (!filenameIsDir) break;</front>
<front id="cardreaderCPP-171"></front>
<front id="cardreaderCPP-172">      // SERIAL_ECHOPGM("Opening dir: "); SERIAL_ECHOLN(segment);</front>
<front id="cardreaderCPP-173"></front>
<front id="cardreaderCPP-174">      // Open the sub-item as the new dive parent</front>
<front id="cardreaderCPP-175">      SdFile dir;</front>
<front id="cardreaderCPP-176">      if (!dir.open(diveDir, segment, O_READ)) {</front>
<front id="cardreaderCPP-177">        SERIAL_EOL;</front>
<front id="cardreaderCPP-178">        SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-179">        SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);</front>
<front id="cardreaderCPP-180">        SERIAL_ECHO(segment);</front>
<front id="cardreaderCPP-181">        break;</front>
<front id="cardreaderCPP-182">      }</front>
<front id="cardreaderCPP-183"></front>
<front id="cardreaderCPP-184">      diveDir.close();</front>
<front id="cardreaderCPP-185">      diveDir = dir;</front>
<front id="cardreaderCPP-186"></front>
<front id="cardreaderCPP-187">    } // while i&lt;pathLen</front>
<front id="cardreaderCPP-188"></front>
<front id="cardreaderCPP-189">    SERIAL_EOL;</front>
<front id="cardreaderCPP-190">  }</front>
<front id="cardreaderCPP-191"></front>
<front id="cardreaderCPP-192">#endif // LONG_FILENAME_HOST_SUPPORT</front>
<front id="cardreaderCPP-193"></front>
<front id="cardreaderCPP-194">void CardReader::initsd() {</front>
<front id="cardreaderCPP-195">  cardOK = false;</front>
<front id="cardreaderCPP-196">  if (root.isOpen()) root.close();</front>
<front id="cardreaderCPP-197"></front>
<front id="cardreaderCPP-198">  #if ENABLED(SDEXTRASLOW)</front>
<front id="cardreaderCPP-199">    #define SPI_SPEED SPI_QUARTER_SPEED</front>
<front id="cardreaderCPP-200">  #elif ENABLED(SDSLOW)</front>
<front id="cardreaderCPP-201">    #define SPI_SPEED SPI_HALF_SPEED</front>
<front id="cardreaderCPP-202">  #else</front>
<front id="cardreaderCPP-203">    #define SPI_SPEED SPI_FULL_SPEED</front>
<front id="cardreaderCPP-204">  #endif</front>
<front id="cardreaderCPP-205"></front>
<front id="cardreaderCPP-206">  if (!card.init(SPI_SPEED,SDSS)</front>
<front id="cardreaderCPP-207">    #if defined(LCD_SDSS) && (LCD_SDSS != SDSS)</front>
<front id="cardreaderCPP-208">      && !card.init(SPI_SPEED, LCD_SDSS)</front>
<front id="cardreaderCPP-209">    #endif</front>
<front id="cardreaderCPP-210">  ) {</front>
<front id="cardreaderCPP-211">    //if (!card.init(SPI_HALF_SPEED,SDSS))</front>
<front id="cardreaderCPP-212">    SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-213">    SERIAL_ECHOLNPGM(MSG_SD_INIT_FAIL);</front>
<front id="cardreaderCPP-214">  }</front>
<front id="cardreaderCPP-215">  else if (!volume.init(&card)) {</front>
<front id="cardreaderCPP-216">    SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-217">    SERIAL_ERRORLNPGM(MSG_SD_VOL_INIT_FAIL);</front>
<front id="cardreaderCPP-218">  }</front>
<front id="cardreaderCPP-219">  else if (!root.openRoot(&volume)) {</front>
<front id="cardreaderCPP-220">    SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-221">    SERIAL_ERRORLNPGM(MSG_SD_OPENROOT_FAIL);</front>
<front id="cardreaderCPP-222">  }</front>
<front id="cardreaderCPP-223">  else {</front>
<front id="cardreaderCPP-224">    cardOK = true;</front>
<front id="cardreaderCPP-225">    SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-226">    SERIAL_ECHOLNPGM(MSG_SD_CARD_OK);</front>
<front id="cardreaderCPP-227">  }</front>
<front id="cardreaderCPP-228">  workDir = root;</front>
<front id="cardreaderCPP-229">  curDir = &root;</front>
<front id="cardreaderCPP-230">  /*</front>
<front id="cardreaderCPP-231">  if (!workDir.openRoot(&volume)) {</front>
<front id="cardreaderCPP-232">    SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);</front>
<front id="cardreaderCPP-233">  }</front>
<front id="cardreaderCPP-234">  */</front>
<front id="cardreaderCPP-235">}</front>
<front id="cardreaderCPP-236"></front>
<front id="cardreaderCPP-237">void CardReader::setroot() {</front>
<front id="cardreaderCPP-238">  /*if (!workDir.openRoot(&volume)) {</front>
<front id="cardreaderCPP-239">    SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);</front>
<front id="cardreaderCPP-240">  }*/</front>
<front id="cardreaderCPP-241">  workDir = root;</front>
<front id="cardreaderCPP-242">  curDir = &workDir;</front>
<front id="cardreaderCPP-243">}</front>
<front id="cardreaderCPP-244"></front>
<front id="cardreaderCPP-245">void CardReader::release() {</front>
<front id="cardreaderCPP-246">  sdprinting = false;</front>
<front id="cardreaderCPP-247">  cardOK = false;</front>
<front id="cardreaderCPP-248">}</front>
<front id="cardreaderCPP-249"></front>
<front id="cardreaderCPP-250">void CardReader::startFileprint() {</front>
<front id="cardreaderCPP-251">  if (cardOK) {</front>
<front id="cardreaderCPP-252">    sdprinting = true;</front>
<front id="cardreaderCPP-253">  }</front>
<front id="cardreaderCPP-254">}</front>
<front id="cardreaderCPP-255"></front>
<front id="cardreaderCPP-256">void CardReader::pauseSDPrint() {</front>
<front id="cardreaderCPP-257">  if (sdprinting) sdprinting = false;</front>
<front id="cardreaderCPP-258">}</front>
<front id="cardreaderCPP-259"></front>
<front id="cardreaderCPP-260">void CardReader::openLogFile(char* name) {</front>
<front id="cardreaderCPP-261">  logging = true;</front>
<front id="cardreaderCPP-262">  openFile(name, false);</front>
<front id="cardreaderCPP-263">}</front>
<front id="cardreaderCPP-264"></front>
<front id="cardreaderCPP-265">void CardReader::getAbsFilename(char *t) {</front>
<front id="cardreaderCPP-266">  uint8_t cnt = 0;</front>
<front id="cardreaderCPP-267">  *t = '/'; t++; cnt++;</front>
<front id="cardreaderCPP-268">  for (uint8_t i = 0; i &lt; workDirDepth; i++) {</front>
<front id="cardreaderCPP-269">    workDirParents[i].getFilename(t); //SDBaseFile.getfilename!</front>
<front id="cardreaderCPP-270">    while(*t && cnt &lt; MAXPATHNAMELENGTH) { t++; cnt++; } //crawl counter forward.</front>
<front id="cardreaderCPP-271">  }</front>
<front id="cardreaderCPP-272">  if (cnt &lt; MAXPATHNAMELENGTH - FILENAME_LENGTH)</front>
<front id="cardreaderCPP-273">    file.getFilename(t);</front>
<front id="cardreaderCPP-274">  else</front>
<front id="cardreaderCPP-275">    t[0] = 0;</front>
<front id="cardreaderCPP-276">}</front>
<front id="cardreaderCPP-277"></front>
<front id="cardreaderCPP-278">void CardReader::openFile(char* name, bool read, bool replace_current/*=true*/) {</front>
<front id="cardreaderCPP-279">  if (!cardOK) return;</front>
<front id="cardreaderCPP-280">  if (file.isOpen()) { //replacing current file by new file, or subfile call</front>
<front id="cardreaderCPP-281">    if (!replace_current) {</front>
<front id="cardreaderCPP-282">     if (file_subcall_ctr &gt; SD_PROCEDURE_DEPTH - 1) {</front>
<front id="cardreaderCPP-283">       SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-284">       SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");</front>
<front id="cardreaderCPP-285">       SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);</front>
<front id="cardreaderCPP-286">       kill(PSTR(MSG_KILLED));</front>
<front id="cardreaderCPP-287">       return;</front>
<front id="cardreaderCPP-288">     }</front>
<front id="cardreaderCPP-289"></front>
<front id="cardreaderCPP-290">     SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-291">     SERIAL_ECHOPGM("SUBROUTINE CALL target:\"");</front>
<front id="cardreaderCPP-292">     SERIAL_ECHO(name);</front>
<front id="cardreaderCPP-293">     SERIAL_ECHOPGM("\" parent:\"");</front>
<front id="cardreaderCPP-294"></front>
<front id="cardreaderCPP-295">     //store current filename and position</front>
<front id="cardreaderCPP-296">     getAbsFilename(filenames[file_subcall_ctr]);</front>
<front id="cardreaderCPP-297"></front>
<front id="cardreaderCPP-298">     SERIAL_ECHO(filenames[file_subcall_ctr]);</front>
<front id="cardreaderCPP-299">     SERIAL_ECHOPGM("\" pos");</front>
<front id="cardreaderCPP-300">     SERIAL_ECHOLN(sdpos);</front>
<front id="cardreaderCPP-301">     filespos[file_subcall_ctr] = sdpos;</front>
<front id="cardreaderCPP-302">     file_subcall_ctr++;</front>
<front id="cardreaderCPP-303">    }</front>
<front id="cardreaderCPP-304">    else {</front>
<front id="cardreaderCPP-305">     SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-306">     SERIAL_ECHOPGM("Now doing file: ");</front>
<front id="cardreaderCPP-307">     SERIAL_ECHOLN(name);</front>
<front id="cardreaderCPP-308">    }</front>
<front id="cardreaderCPP-309">    file.close();</front>
<front id="cardreaderCPP-310">  }</front>
<front id="cardreaderCPP-311">  else { //opening fresh file</front>
<front id="cardreaderCPP-312">    file_subcall_ctr = 0; //resetting procedure depth in case user cancels print while in procedure</front>
<front id="cardreaderCPP-313">    SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-314">    SERIAL_ECHOPGM("Now fresh file: ");</front>
<front id="cardreaderCPP-315">    SERIAL_ECHOLN(name);</front>
<front id="cardreaderCPP-316">  }</front>
<front id="cardreaderCPP-317">  sdprinting = false;</front>
<front id="cardreaderCPP-318"></front>
<front id="cardreaderCPP-319">  SdFile myDir;</front>
<front id="cardreaderCPP-320">  curDir = &root;</front>
<front id="cardreaderCPP-321">  char *fname = name;</front>
<front id="cardreaderCPP-322"></front>
<front id="cardreaderCPP-323">  char *dirname_start, *dirname_end;</front>
<front id="cardreaderCPP-324">  if (name[0] == '/') {</front>
<front id="cardreaderCPP-325">    dirname_start = &name[1];</front>
<front id="cardreaderCPP-326">    while (dirname_start &gt; 0) {</front>
<front id="cardreaderCPP-327">      dirname_end = strchr(dirname_start, '/');</front>
<front id="cardreaderCPP-328">      //SERIAL_ECHO("start:");SERIAL_ECHOLN((int)(dirname_start - name));</front>
<front id="cardreaderCPP-329">      //SERIAL_ECHO("end  :");SERIAL_ECHOLN((int)(dirname_end - name));</front>
<front id="cardreaderCPP-330">      if (dirname_end &gt; 0 && dirname_end &gt; dirname_start) {</front>
<front id="cardreaderCPP-331">        char subdirname[FILENAME_LENGTH];</front>
<front id="cardreaderCPP-332">        strncpy(subdirname, dirname_start, dirname_end - dirname_start);</front>
<front id="cardreaderCPP-333">        subdirname[dirname_end - dirname_start] = 0;</front>
<front id="cardreaderCPP-334">        SERIAL_ECHOLN(subdirname);</front>
<front id="cardreaderCPP-335">        if (!myDir.open(curDir, subdirname, O_READ)) {</front>
<front id="cardreaderCPP-336">          SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);</front>
<front id="cardreaderCPP-337">          SERIAL_PROTOCOL(subdirname);</front>
<front id="cardreaderCPP-338">          SERIAL_PROTOCOLCHAR('.');</front>
<front id="cardreaderCPP-339">          return;</front>
<front id="cardreaderCPP-340">        }</front>
<front id="cardreaderCPP-341">        else {</front>
<front id="cardreaderCPP-342">          //SERIAL_ECHOLN("dive ok");</front>
<front id="cardreaderCPP-343">        }</front>
<front id="cardreaderCPP-344"></front>
<front id="cardreaderCPP-345">        curDir = &myDir;</front>
<front id="cardreaderCPP-346">        dirname_start = dirname_end + 1;</front>
<front id="cardreaderCPP-347">      }</front>
<front id="cardreaderCPP-348">      else { // the remainder after all /fsa/fdsa/ is the filename</front>
<front id="cardreaderCPP-349">        fname = dirname_start;</front>
<front id="cardreaderCPP-350">        //SERIAL_ECHOLN("remainder");</front>
<front id="cardreaderCPP-351">        //SERIAL_ECHOLN(fname);</front>
<front id="cardreaderCPP-352">        break;</front>
<front id="cardreaderCPP-353">      }</front>
<front id="cardreaderCPP-354">    }</front>
<front id="cardreaderCPP-355">  }</front>
<front id="cardreaderCPP-356">  else { //relative path</front>
<front id="cardreaderCPP-357">    curDir = &workDir;</front>
<front id="cardreaderCPP-358">  }</front>
<front id="cardreaderCPP-359"></front>
<front id="cardreaderCPP-360">  if (read) {</front>
<front id="cardreaderCPP-361">    if (file.open(curDir, fname, O_READ)) {</front>
<front id="cardreaderCPP-362">      filesize = file.fileSize();</front>
<front id="cardreaderCPP-363">      SERIAL_PROTOCOLPGM(MSG_SD_FILE_OPENED);</front>
<front id="cardreaderCPP-364">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-365">      SERIAL_PROTOCOLPGM(MSG_SD_SIZE);</front>
<front id="cardreaderCPP-366">      SERIAL_PROTOCOLLN(filesize);</front>
<front id="cardreaderCPP-367">      sdpos = 0;</front>
<front id="cardreaderCPP-368"></front>
<front id="cardreaderCPP-369">      SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);</front>
<front id="cardreaderCPP-370">      getfilename(0, fname);</front>
<front id="cardreaderCPP-371">      lcd_setstatus(longFilename[0] ? longFilename : fname);</front>
<front id="cardreaderCPP-372">    }</front>
<front id="cardreaderCPP-373">    else {</front>
<front id="cardreaderCPP-374">      SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);</front>
<front id="cardreaderCPP-375">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-376">      SERIAL_PROTOCOLPGM(".\n");</front>
<front id="cardreaderCPP-377">    }</front>
<front id="cardreaderCPP-378">  }</front>
<front id="cardreaderCPP-379">  else { //write</front>
<front id="cardreaderCPP-380">    if (!file.open(curDir, fname, O_CREAT | O_APPEND | O_WRITE | O_TRUNC)) {</front>
<front id="cardreaderCPP-381">      SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);</front>
<front id="cardreaderCPP-382">      SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-383">      SERIAL_PROTOCOLPGM(".\n");</front>
<front id="cardreaderCPP-384">    }</front>
<front id="cardreaderCPP-385">    else {</front>
<front id="cardreaderCPP-386">      saving = true;</front>
<front id="cardreaderCPP-387">      SERIAL_PROTOCOLPGM(MSG_SD_WRITE_TO_FILE);</front>
<front id="cardreaderCPP-388">      SERIAL_PROTOCOLLN(name);</front>
<front id="cardreaderCPP-389">      lcd_setstatus(fname);</front>
<front id="cardreaderCPP-390">    }</front>
<front id="cardreaderCPP-391">  }</front>
<front id="cardreaderCPP-392">}</front>
<front id="cardreaderCPP-393"></front>
<front id="cardreaderCPP-394">void CardReader::removeFile(char* name) {</front>
<front id="cardreaderCPP-395">  if (!cardOK) return;</front>
<front id="cardreaderCPP-396"></front>
<front id="cardreaderCPP-397">  file.close();</front>
<front id="cardreaderCPP-398">  sdprinting = false;</front>
<front id="cardreaderCPP-399"></front>
<front id="cardreaderCPP-400">  SdFile myDir;</front>
<front id="cardreaderCPP-401">  curDir = &root;</front>
<front id="cardreaderCPP-402">  char *fname = name;</front>
<front id="cardreaderCPP-403"></front>
<front id="cardreaderCPP-404">  char *dirname_start, *dirname_end;</front>
<front id="cardreaderCPP-405">  if (name[0] == '/') {</front>
<front id="cardreaderCPP-406">    dirname_start = strchr(name, '/') + 1;</front>
<front id="cardreaderCPP-407">    while (dirname_start &gt; 0) {</front>
<front id="cardreaderCPP-408">      dirname_end = strchr(dirname_start, '/');</front>
<front id="cardreaderCPP-409">      //SERIAL_ECHO("start:");SERIAL_ECHOLN((int)(dirname_start - name));</front>
<front id="cardreaderCPP-410">      //SERIAL_ECHO("end  :");SERIAL_ECHOLN((int)(dirname_end - name));</front>
<front id="cardreaderCPP-411">      if (dirname_end &gt; 0 && dirname_end &gt; dirname_start) {</front>
<front id="cardreaderCPP-412">        char subdirname[FILENAME_LENGTH];</front>
<front id="cardreaderCPP-413">        strncpy(subdirname, dirname_start, dirname_end - dirname_start);</front>
<front id="cardreaderCPP-414">        subdirname[dirname_end - dirname_start] = 0;</front>
<front id="cardreaderCPP-415">        SERIAL_ECHOLN(subdirname);</front>
<front id="cardreaderCPP-416">        if (!myDir.open(curDir, subdirname, O_READ)) {</front>
<front id="cardreaderCPP-417">          SERIAL_PROTOCOLPGM("open failed, File: ");</front>
<front id="cardreaderCPP-418">          SERIAL_PROTOCOL(subdirname);</front>
<front id="cardreaderCPP-419">          SERIAL_PROTOCOLCHAR('.');</front>
<front id="cardreaderCPP-420">          return;</front>
<front id="cardreaderCPP-421">        }</front>
<front id="cardreaderCPP-422">        else {</front>
<front id="cardreaderCPP-423">          //SERIAL_ECHOLN("dive ok");</front>
<front id="cardreaderCPP-424">        }</front>
<front id="cardreaderCPP-425"></front>
<front id="cardreaderCPP-426">        curDir = &myDir;</front>
<front id="cardreaderCPP-427">        dirname_start = dirname_end + 1;</front>
<front id="cardreaderCPP-428">      }</front>
<front id="cardreaderCPP-429">      else { // the remainder after all /fsa/fdsa/ is the filename</front>
<front id="cardreaderCPP-430">        fname = dirname_start;</front>
<front id="cardreaderCPP-431">        //SERIAL_ECHOLN("remainder");</front>
<front id="cardreaderCPP-432">        //SERIAL_ECHOLN(fname);</front>
<front id="cardreaderCPP-433">        break;</front>
<front id="cardreaderCPP-434">      }</front>
<front id="cardreaderCPP-435">    }</front>
<front id="cardreaderCPP-436">  }</front>
<front id="cardreaderCPP-437">  else { // relative path</front>
<front id="cardreaderCPP-438">    curDir = &workDir;</front>
<front id="cardreaderCPP-439">  }</front>
<front id="cardreaderCPP-440"></front>
<front id="cardreaderCPP-441">  if (file.remove(curDir, fname)) {</front>
<front id="cardreaderCPP-442">    SERIAL_PROTOCOLPGM("File deleted:");</front>
<front id="cardreaderCPP-443">    SERIAL_PROTOCOLLN(fname);</front>
<front id="cardreaderCPP-444">    sdpos = 0;</front>
<front id="cardreaderCPP-445">  }</front>
<front id="cardreaderCPP-446">  else {</front>
<front id="cardreaderCPP-447">    SERIAL_PROTOCOLPGM("Deletion failed, File: ");</front>
<front id="cardreaderCPP-448">    SERIAL_PROTOCOL(fname);</front>
<front id="cardreaderCPP-449">    SERIAL_PROTOCOLCHAR('.');</front>
<front id="cardreaderCPP-450">  }</front>
<front id="cardreaderCPP-451">}</front>
<front id="cardreaderCPP-452"></front>
<front id="cardreaderCPP-453">void CardReader::getStatus() {</front>
<front id="cardreaderCPP-454">  if (cardOK) {</front>
<front id="cardreaderCPP-455">    SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);</front>
<front id="cardreaderCPP-456">    SERIAL_PROTOCOL(sdpos);</front>
<front id="cardreaderCPP-457">    SERIAL_PROTOCOLCHAR('/');</front>
<front id="cardreaderCPP-458">    SERIAL_PROTOCOLLN(filesize);</front>
<front id="cardreaderCPP-459">  }</front>
<front id="cardreaderCPP-460">  else {</front>
<front id="cardreaderCPP-461">    SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);</front>
<front id="cardreaderCPP-462">  }</front>
<front id="cardreaderCPP-463">}</front>
<front id="cardreaderCPP-464"></front>
<front id="cardreaderCPP-465">void CardReader::write_command(char *buf) {</front>
<front id="cardreaderCPP-466">  char* begin = buf;</front>
<front id="cardreaderCPP-467">  char* npos = 0;</front>
<front id="cardreaderCPP-468">  char* end = buf + strlen(buf) - 1;</front>
<front id="cardreaderCPP-469"></front>
<front id="cardreaderCPP-470">  file.writeError = false;</front>
<front id="cardreaderCPP-471">  if ((npos = strchr(buf, 'N')) != NULL) {</front>
<front id="cardreaderCPP-472">    begin = strchr(npos, ' ') + 1;</front>
<front id="cardreaderCPP-473">    end = strchr(npos, '*') - 1;</front>
<front id="cardreaderCPP-474">  }</front>
<front id="cardreaderCPP-475">  end[1] = '\r';</front>
<front id="cardreaderCPP-476">  end[2] = '\n';</front>
<front id="cardreaderCPP-477">  end[3] = '\0';</front>
<front id="cardreaderCPP-478">  file.write(begin);</front>
<front id="cardreaderCPP-479">  if (file.writeError) {</front>
<front id="cardreaderCPP-480">    SERIAL_ERROR_START;</front>
<front id="cardreaderCPP-481">    SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);</front>
<front id="cardreaderCPP-482">  }</front>
<front id="cardreaderCPP-483">}</front>
<front id="cardreaderCPP-484"></front>
<front id="cardreaderCPP-485">void CardReader::checkautostart(bool force) {</front>
<front id="cardreaderCPP-486">  if (!force && (!autostart_stilltocheck || next_autostart_ms &lt; millis()))</front>
<front id="cardreaderCPP-487">    return;</front>
<front id="cardreaderCPP-488"></front>
<front id="cardreaderCPP-489">  autostart_stilltocheck = false;</front>
<front id="cardreaderCPP-490"></front>
<front id="cardreaderCPP-491">  if (!cardOK) {</front>
<front id="cardreaderCPP-492">    initsd();</front>
<front id="cardreaderCPP-493">    if (!cardOK) return; // fail</front>
<front id="cardreaderCPP-494">  }</front>
<front id="cardreaderCPP-495"></front>
<front id="cardreaderCPP-496">  char autoname[10];</front>
<front id="cardreaderCPP-497">  sprintf_P(autoname, PSTR("auto%i.g"), autostart_index);</front>
<front id="cardreaderCPP-498">  for (int8_t i = 0; i &lt; (int8_t)strlen(autoname); i++) autoname[i] = tolower(autoname[i]);</front>
<front id="cardreaderCPP-499"></front>
<front id="cardreaderCPP-500">  dir_t p;</front>
<front id="cardreaderCPP-501"></front>
<front id="cardreaderCPP-502">  root.rewind();</front>
<front id="cardreaderCPP-503"></front>
<front id="cardreaderCPP-504">  bool found = false;</front>
<front id="cardreaderCPP-505">  while (root.readDir(p, NULL) &gt; 0) {</front>
<front id="cardreaderCPP-506">    for (int8_t i = 0; i &lt; (int8_t)strlen((char*)p.name); i++) p.name[i] = tolower(p.name[i]);</front>
<front id="cardreaderCPP-507">    if (p.name[9] != '~' && strncmp((char*)p.name, autoname, 5) == 0) {</front>
<front id="cardreaderCPP-508">      char cmd[4 + (FILENAME_LENGTH + 1) * MAX_DIR_DEPTH + 2];</front>
<front id="cardreaderCPP-509">      sprintf_P(cmd, PSTR("M23 %s"), autoname);</front>
<front id="cardreaderCPP-510">      enqueuecommand(cmd);</front>
<front id="cardreaderCPP-511">      enqueuecommands_P(PSTR("M24"));</front>
<front id="cardreaderCPP-512">      found = true;</front>
<front id="cardreaderCPP-513">    }</front>
<front id="cardreaderCPP-514">  }</front>
<front id="cardreaderCPP-515">  if (!found)</front>
<front id="cardreaderCPP-516">    autostart_index = -1;</front>
<front id="cardreaderCPP-517">  else</front>
<front id="cardreaderCPP-518">    autostart_index++;</front>
<front id="cardreaderCPP-519">}</front>
<front id="cardreaderCPP-520"></front>
<front id="cardreaderCPP-521">void CardReader::closefile(bool store_location) {</front>
<front id="cardreaderCPP-522">  file.sync();</front>
<front id="cardreaderCPP-523">  file.close();</front>
<front id="cardreaderCPP-524">  saving = logging = false;</front>
<front id="cardreaderCPP-525"></front>
<front id="cardreaderCPP-526">  if (store_location) {</front>
<front id="cardreaderCPP-527">    //future: store printer state, filename and position for continuing a stopped print</front>
<front id="cardreaderCPP-528">    // so one can unplug the printer and continue printing the next day.</front>
<front id="cardreaderCPP-529">  }</front>
<front id="cardreaderCPP-530">}</front>
<front id="cardreaderCPP-531"></front>
<front id="cardreaderCPP-532">/**</front>
<front id="cardreaderCPP-533"> * Get the name of a file in the current directory by index</front>
<front id="cardreaderCPP-534"> */</front>
<front id="cardreaderCPP-535">void CardReader::getfilename(uint16_t nr, const char * const match/*=NULL*/) {</front>
<front id="cardreaderCPP-536">  curDir = &workDir;</front>
<front id="cardreaderCPP-537">  lsAction = LS_GetFilename;</front>
<front id="cardreaderCPP-538">  nrFiles = nr;</front>
<front id="cardreaderCPP-539">  curDir-&gt;rewind();</front>
<front id="cardreaderCPP-540">  lsDive("", *curDir, match);</front>
<front id="cardreaderCPP-541">}</front>
<front id="cardreaderCPP-542"></front>
<front id="cardreaderCPP-543">uint16_t CardReader::getnrfilenames() {</front>
<front id="cardreaderCPP-544">  curDir = &workDir;</front>
<front id="cardreaderCPP-545">  lsAction = LS_Count;</front>
<front id="cardreaderCPP-546">  nrFiles = 0;</front>
<front id="cardreaderCPP-547">  curDir-&gt;rewind();</front>
<front id="cardreaderCPP-548">  lsDive("", *curDir);</front>
<front id="cardreaderCPP-549">  //SERIAL_ECHOLN(nrFiles);</front>
<front id="cardreaderCPP-550">  return nrFiles;</front>
<front id="cardreaderCPP-551">}</front>
<front id="cardreaderCPP-552"></front>
<front id="cardreaderCPP-553">void CardReader::chdir(const char * relpath) {</front>
<front id="cardreaderCPP-554">  SdFile newfile;</front>
<front id="cardreaderCPP-555">  SdFile *parent = &root;</front>
<front id="cardreaderCPP-556"></front>
<front id="cardreaderCPP-557">  if (workDir.isOpen()) parent = &workDir;</front>
<front id="cardreaderCPP-558"></front>
<front id="cardreaderCPP-559">  if (!newfile.open(*parent, relpath, O_READ)) {</front>
<front id="cardreaderCPP-560">    SERIAL_ECHO_START;</front>
<front id="cardreaderCPP-561">    SERIAL_ECHOPGM(MSG_SD_CANT_ENTER_SUBDIR);</front>
<front id="cardreaderCPP-562">    SERIAL_ECHOLN(relpath);</front>
<front id="cardreaderCPP-563">  }</front>
<front id="cardreaderCPP-564">  else {</front>
<front id="cardreaderCPP-565">    if (workDirDepth &lt; MAX_DIR_DEPTH) {</front>
<front id="cardreaderCPP-566">      ++workDirDepth;</front>
<front id="cardreaderCPP-567">      for (int d = workDirDepth; d--;) workDirParents[d + 1] = workDirParents[d];</front>
<front id="cardreaderCPP-568">      workDirParents[0] = *parent;</front>
<front id="cardreaderCPP-569">    }</front>
<front id="cardreaderCPP-570">    workDir = newfile;</front>
<front id="cardreaderCPP-571">  }</front>
<front id="cardreaderCPP-572">}</front>
<front id="cardreaderCPP-573"></front>
<front id="cardreaderCPP-574">void CardReader::updir() {</front>
<front id="cardreaderCPP-575">  if (workDirDepth &gt; 0) {</front>
<front id="cardreaderCPP-576">    --workDirDepth;</front>
<front id="cardreaderCPP-577">    workDir = workDirParents[0];</front>
<front id="cardreaderCPP-578">    for (uint16_t d = 0; d &lt; workDirDepth; d++)</front>
<front id="cardreaderCPP-579">      workDirParents[d] = workDirParents[d+1];</front>
<front id="cardreaderCPP-580">  }</front>
<front id="cardreaderCPP-581">}</front>
<front id="cardreaderCPP-582"></front>
<front id="cardreaderCPP-583">void CardReader::printingHasFinished() {</front>
<front id="cardreaderCPP-584">  st_synchronize();</front>
<front id="cardreaderCPP-585">  if (file_subcall_ctr &gt; 0) { // Heading up to a parent file that called current as a procedure.</front>
<front id="cardreaderCPP-586">    file.close();</front>
<front id="cardreaderCPP-587">    file_subcall_ctr--;</front>
<front id="cardreaderCPP-588">    openFile(filenames[file_subcall_ctr], true, true);</front>
<front id="cardreaderCPP-589">    setIndex(filespos[file_subcall_ctr]);</front>
<front id="cardreaderCPP-590">    startFileprint();</front>
<front id="cardreaderCPP-591">  }</front>
<front id="cardreaderCPP-592">  else {</front>
<front id="cardreaderCPP-593">    file.close();</front>
<front id="cardreaderCPP-594">    sdprinting = false;</front>
<front id="cardreaderCPP-595">    if (SD_FINISHED_STEPPERRELEASE) {</front>
<front id="cardreaderCPP-596">      //finishAndDisableSteppers();</front>
<front id="cardreaderCPP-597">      enqueuecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));</front>
<front id="cardreaderCPP-598">    }</front>
<front id="cardreaderCPP-599">    autotempShutdown();</front>
<front id="cardreaderCPP-600">  }</front>
<front id="cardreaderCPP-601">}</front>
<front id="cardreaderCPP-602"></front>
<front id="cardreaderCPP-603">#endif //SDSUPPORT</front>
 </pre>
<h1 id="cardreaderHtitle" >cardreader.h</h1>
<pre id="cardreaderH"  class="prettyprint linenums"><front id="cardreaderH-1">#ifndef CARDREADER_H</front>
<front id="cardreaderH-2">#define CARDREADER_H</front>
<front id="cardreaderH-3"></front>
<front id="cardreaderH-4">#if ENABLED(SDSUPPORT)</front>
<front id="cardreaderH-5"></front>
<front id="cardreaderH-6">#define MAX_DIR_DEPTH 10          // Maximum folder depth</front>
<front id="cardreaderH-7"></front>
<front id="cardreaderH-8">#include "SdFile.h"</front>
<front id="cardreaderH-9">enum LsAction { LS_SerialPrint, LS_Count, LS_GetFilename };</front>
<front id="cardreaderH-10"></front>
<front id="cardreaderH-11">class CardReader {</front>
<front id="cardreaderH-12">public:</front>
<front id="cardreaderH-13">  CardReader();</front>
<front id="cardreaderH-14"></front>
<front id="cardreaderH-15">  void initsd();</front>
<front id="cardreaderH-16">  void write_command(char *buf);</front>
<front id="cardreaderH-17">  //files auto[0-9].g on the sd card are performed in a row</front>
<front id="cardreaderH-18">  //this is to delay autostart and hence the initialisaiton of the sd card to some seconds after the normal init, so the device is available quick after a reset</front>
<front id="cardreaderH-19"></front>
<front id="cardreaderH-20">  void checkautostart(bool x);</front>
<front id="cardreaderH-21">  void openFile(char* name,bool read,bool replace_current=true);</front>
<front id="cardreaderH-22">  void openLogFile(char* name);</front>
<front id="cardreaderH-23">  void removeFile(char* name);</front>
<front id="cardreaderH-24">  void closefile(bool store_location=false);</front>
<front id="cardreaderH-25">  void release();</front>
<front id="cardreaderH-26">  void startFileprint();</front>
<front id="cardreaderH-27">  void pauseSDPrint();</front>
<front id="cardreaderH-28">  void getStatus();</front>
<front id="cardreaderH-29">  void printingHasFinished();</front>
<front id="cardreaderH-30"></front>
<front id="cardreaderH-31">  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)</front>
<front id="cardreaderH-32">    void printLongPath(char *path);</front>
<front id="cardreaderH-33">  #endif</front>
<front id="cardreaderH-34"></front>
<front id="cardreaderH-35">  void getfilename(uint16_t nr, const char* const match=NULL);</front>
<front id="cardreaderH-36">  uint16_t getnrfilenames();</front>
<front id="cardreaderH-37"></front>
<front id="cardreaderH-38">  void getAbsFilename(char *t);</front>
<front id="cardreaderH-39"></front>
<front id="cardreaderH-40">  void ls();</front>
<front id="cardreaderH-41">  void chdir(const char * relpath);</front>
<front id="cardreaderH-42">  void updir();</front>
<front id="cardreaderH-43">  void setroot();</front>
<front id="cardreaderH-44"></front>
<front id="cardreaderH-45"></front>
<front id="cardreaderH-46">  FORCE_INLINE bool isFileOpen() { return file.isOpen(); }</front>
<front id="cardreaderH-47">  FORCE_INLINE bool eof() { return sdpos &gt;= filesize; }</front>
<front id="cardreaderH-48">  FORCE_INLINE int16_t get() { sdpos = file.curPosition(); return (int16_t)file.read(); }</front>
<front id="cardreaderH-49">  FORCE_INLINE void setIndex(long index) { sdpos = index; file.seekSet(index); }</front>
<front id="cardreaderH-50">  FORCE_INLINE uint8_t percentDone() { return (isFileOpen() && filesize) ? sdpos / ((filesize + 99) / 100) : 0; }</front>
<front id="cardreaderH-51">  FORCE_INLINE char* getWorkDirName() { workDir.getFilename(filename); return filename; }</front>
<front id="cardreaderH-52"></front>
<front id="cardreaderH-53">public:</front>
<front id="cardreaderH-54">  bool saving, logging, sdprinting, cardOK, filenameIsDir;</front>
<front id="cardreaderH-55">  char filename[FILENAME_LENGTH], longFilename[LONG_FILENAME_LENGTH];</front>
<front id="cardreaderH-56">  int autostart_index;</front>
<front id="cardreaderH-57">private:</front>
<front id="cardreaderH-58">  SdFile root, *curDir, workDir, workDirParents[MAX_DIR_DEPTH];</front>
<front id="cardreaderH-59">  uint16_t workDirDepth;</front>
<front id="cardreaderH-60">  Sd2Card card;</front>
<front id="cardreaderH-61">  SdVolume volume;</front>
<front id="cardreaderH-62">  SdFile file;</front>
<front id="cardreaderH-63">  #define SD_PROCEDURE_DEPTH 1</front>
<front id="cardreaderH-64">  #define MAXPATHNAMELENGTH (FILENAME_LENGTH*MAX_DIR_DEPTH + MAX_DIR_DEPTH + 1)</front>
<front id="cardreaderH-65">  uint8_t file_subcall_ctr;</front>
<front id="cardreaderH-66">  uint32_t filespos[SD_PROCEDURE_DEPTH];</front>
<front id="cardreaderH-67">  char filenames[SD_PROCEDURE_DEPTH][MAXPATHNAMELENGTH];</front>
<front id="cardreaderH-68">  uint32_t filesize;</front>
<front id="cardreaderH-69">  millis_t next_autostart_ms;</front>
<front id="cardreaderH-70">  uint32_t sdpos;</front>
<front id="cardreaderH-71"></front>
<front id="cardreaderH-72">  bool autostart_stilltocheck; //the sd start is delayed, because otherwise the serial cannot answer fast enought to make contact with the hostsoftware.</front>
<front id="cardreaderH-73"></front>
<front id="cardreaderH-74">  LsAction lsAction; //stored for recursion.</front>
<front id="cardreaderH-75">  uint16_t nrFiles; //counter for the files in the current directory and recycled as position counter for getting the nrFiles'th name in the directory.</front>
<front id="cardreaderH-76">  char* diveDirName;</front>
<front id="cardreaderH-77">  void lsDive(const char *prepend, SdFile parent, const char * const match=NULL);</front>
<front id="cardreaderH-78">};</front>
<front id="cardreaderH-79"></front>
<front id="cardreaderH-80">extern CardReader card;</front>
<front id="cardreaderH-81"></front>
<front id="cardreaderH-82">#define IS_SD_PRINTING (card.sdprinting)</front>
<front id="cardreaderH-83"></front>
<front id="cardreaderH-84">#if PIN_EXISTS(SD_DETECT)</front>
<front id="cardreaderH-85">  #if ENABLED(SD_DETECT_INVERTED)</front>
<front id="cardreaderH-86">    #define IS_SD_INSERTED (READ(SD_DETECT_PIN) != 0)</front>
<front id="cardreaderH-87">  #else</front>
<front id="cardreaderH-88">    #define IS_SD_INSERTED (READ(SD_DETECT_PIN) == 0)</front>
<front id="cardreaderH-89">  #endif</front>
<front id="cardreaderH-90">#else</front>
<front id="cardreaderH-91">  //No card detect line? Assume the card is inserted.</front>
<front id="cardreaderH-92">  #define IS_SD_INSERTED true</front>
<front id="cardreaderH-93">#endif</front>
<front id="cardreaderH-94"></front>
<front id="cardreaderH-95">#else</front>
<front id="cardreaderH-96"></front>
<front id="cardreaderH-97">#define IS_SD_PRINTING (false)</front>
<front id="cardreaderH-98"></front>
<front id="cardreaderH-99">#endif //SDSUPPORT</front>
<front id="cardreaderH-100"></front>
<front id="cardreaderH-101">#endif //__CARDREADER_H</front>
 </pre>
<h1 id="ConditionalsHtitle" >Conditionals.h</h1>
<pre id="ConditionalsH"  class="prettyprint linenums"><front id="ConditionalsH-1">/**</front>
<front id="ConditionalsH-2"> * Conditionals.h</front>
<front id="ConditionalsH-3"> * Defines that depend on configuration but are not editable.</front>
<front id="ConditionalsH-4"> */</front>
<front id="ConditionalsH-5">#ifndef CONDITIONALS_H</front>
<front id="ConditionalsH-6"></front>
<front id="ConditionalsH-7">#ifndef M_PI</front>
<front id="ConditionalsH-8">  #define M_PI 3.1415926536</front>
<front id="ConditionalsH-9">#endif</front>
<front id="ConditionalsH-10"></front>
<front id="ConditionalsH-11">#ifndef CONFIGURATION_LCD // Get the LCD defines which are needed first</front>
<front id="ConditionalsH-12"></front>
<front id="ConditionalsH-13">  #define PIN_EXISTS(PN) (defined(PN##_PIN) && PN##_PIN &gt;= 0)</front>
<front id="ConditionalsH-14"></front>
<front id="ConditionalsH-15">  #define CONFIGURATION_LCD</front>
<front id="ConditionalsH-16"></front>
<front id="ConditionalsH-17">  #if ENABLED(MAKRPANEL)</front>
<front id="ConditionalsH-18">    #define DOGLCD</front>
<front id="ConditionalsH-19">    #define DEFAULT_LCD_CONTRAST 17</front>
<front id="ConditionalsH-20">    #define ULTIPANEL</front>
<front id="ConditionalsH-21">    #define NEWPANEL</front>
<front id="ConditionalsH-22">  #endif</front>
<front id="ConditionalsH-23"></front>
<front id="ConditionalsH-24">  #if ENABLED(miniVIKI) || ENABLED(VIKI2) || ENABLED(ELB_FULL_GRAPHIC_CONTROLLER)</front>
<front id="ConditionalsH-25">    #define ULTRA_LCD  //general LCD support, also 16x2</front>
<front id="ConditionalsH-26">    #define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)</front>
<front id="ConditionalsH-27">    #define ULTIMAKERCONTROLLER //as available from the Ultimaker online store.</front>
<front id="ConditionalsH-28"></front>
<front id="ConditionalsH-29">    #if ENABLED(miniVIKI)</front>
<front id="ConditionalsH-30">      #define DEFAULT_LCD_CONTRAST 95</front>
<front id="ConditionalsH-31">    #elif ENABLED(VIKI2)</front>
<front id="ConditionalsH-32">      #define DEFAULT_LCD_CONTRAST 40</front>
<front id="ConditionalsH-33">    #elif ENABLED(ELB_FULL_GRAPHIC_CONTROLLER)</front>
<front id="ConditionalsH-34">      #define DEFAULT_LCD_CONTRAST 110</front>
<front id="ConditionalsH-35">      #define U8GLIB_LM6059_AF</front>
<front id="ConditionalsH-36">    #endif</front>
<front id="ConditionalsH-37"></front>
<front id="ConditionalsH-38">    #define ENCODER_PULSES_PER_STEP 4</front>
<front id="ConditionalsH-39">    #define ENCODER_STEPS_PER_MENU_ITEM 1</front>
<front id="ConditionalsH-40">  #endif</front>
<front id="ConditionalsH-41"></front>
<front id="ConditionalsH-42">  // Generic support for SSD1306 OLED based LCDs.</front>
<front id="ConditionalsH-43">  #if ENABLED(U8GLIB_SSD1306)</front>
<front id="ConditionalsH-44">    #define ULTRA_LCD  //general LCD support, also 16x2</front>
<front id="ConditionalsH-45">    #define DOGLCD  // Support for I2C LCD 128x64 (Controller SSD1306 graphic Display Family)</front>
<front id="ConditionalsH-46">  #endif</front>
<front id="ConditionalsH-47"></front>
<front id="ConditionalsH-48"></front>
<front id="ConditionalsH-49">  #if ENABLED(PANEL_ONE)</front>
<front id="ConditionalsH-50">    #define ULTIMAKERCONTROLLER</front>
<front id="ConditionalsH-51">  #endif</front>
<front id="ConditionalsH-52"></front>
<front id="ConditionalsH-53">  #if ENABLED(REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER)</front>
<front id="ConditionalsH-54">    #define DOGLCD</front>
<front id="ConditionalsH-55">    #define U8GLIB_ST7920</front>
<front id="ConditionalsH-56">    #define REPRAP_DISCOUNT_SMART_CONTROLLER</front>
<front id="ConditionalsH-57">  #endif</front>
<front id="ConditionalsH-58"></front>
<front id="ConditionalsH-59">  #if ENABLED(ULTIMAKERCONTROLLER) || ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER) || ENABLED(G3D_PANEL) || ENABLED(RIGIDBOT_PANEL)</front>
<front id="ConditionalsH-60">    #define ULTIPANEL</front>
<front id="ConditionalsH-61">    #define NEWPANEL</front>
<front id="ConditionalsH-62">  #endif</front>
<front id="ConditionalsH-63"></front>
<front id="ConditionalsH-64">  #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ConditionalsH-65">    #define ULTIPANEL</front>
<front id="ConditionalsH-66">    #define NEWPANEL</front>
<front id="ConditionalsH-67">  #endif</front>
<front id="ConditionalsH-68"></front>
<front id="ConditionalsH-69">  #if ENABLED(RA_CONTROL_PANEL)</front>
<front id="ConditionalsH-70">    #define LCD_I2C_TYPE_PCA8574</front>
<front id="ConditionalsH-71">    #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander</front>
<front id="ConditionalsH-72">    #define ULTIPANEL</front>
<front id="ConditionalsH-73">    #define NEWPANEL</front>
<front id="ConditionalsH-74">  #endif</front>
<front id="ConditionalsH-75"></front>
<front id="ConditionalsH-76">  #if ENABLED(MINIPANEL)</front>
<front id="ConditionalsH-77">   #define DOGLCD</front>
<front id="ConditionalsH-78">   #define ULTIPANEL</front>
<front id="ConditionalsH-79">   #define NEWPANEL</front>
<front id="ConditionalsH-80">   #define DEFAULT_LCD_CONTRAST 17</front>
<front id="ConditionalsH-81">  #endif</front>
<front id="ConditionalsH-82"></front>
<front id="ConditionalsH-83">  /**</front>
<front id="ConditionalsH-84">   * I2C PANELS</front>
<front id="ConditionalsH-85">   */</front>
<front id="ConditionalsH-86"></front>
<front id="ConditionalsH-87">  #if ENABLED(LCD_I2C_SAINSMART_YWROBOT)</front>
<front id="ConditionalsH-88">    // This uses the LiquidCrystal_I2C library ( https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/Home )</front>
<front id="ConditionalsH-89">    // Make sure it is placed in the Arduino libraries directory.</front>
<front id="ConditionalsH-90">    #define LCD_I2C_TYPE_PCF8575</front>
<front id="ConditionalsH-91">    #define LCD_I2C_ADDRESS 0x27   // I2C Address of the port expander</front>
<front id="ConditionalsH-92">    #define ULTIPANEL</front>
<front id="ConditionalsH-93">    #define NEWPANEL</front>
<front id="ConditionalsH-94">  #endif</front>
<front id="ConditionalsH-95"></front>
<front id="ConditionalsH-96">  // PANELOLU2 LCD with status LEDs, separate encoder and click inputs</front>
<front id="ConditionalsH-97">  #if ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="ConditionalsH-98">    #define LCD_I2C_TYPE_MCP23017</front>
<front id="ConditionalsH-99">    #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander</front>
<front id="ConditionalsH-100">    #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD</front>
<front id="ConditionalsH-101"></front>
<front id="ConditionalsH-102">    #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ConditionalsH-103">      #define ENCODER_PULSES_PER_STEP 4</front>
<front id="ConditionalsH-104">    #endif</front>
<front id="ConditionalsH-105"></front>
<front id="ConditionalsH-106">    #ifndef ENCODER_STEPS_PER_MENU_ITEM</front>
<front id="ConditionalsH-107">      #define ENCODER_STEPS_PER_MENU_ITEM 1</front>
<front id="ConditionalsH-108">    #endif</front>
<front id="ConditionalsH-109"></front>
<front id="ConditionalsH-110">    #if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="ConditionalsH-111">      #define LCD_FEEDBACK_FREQUENCY_HZ 1000</front>
<front id="ConditionalsH-112">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100</front>
<front id="ConditionalsH-113">    #endif</front>
<front id="ConditionalsH-114"></front>
<front id="ConditionalsH-115">    #define ULTIPANEL</front>
<front id="ConditionalsH-116">    #define NEWPANEL</front>
<front id="ConditionalsH-117">  #endif</front>
<front id="ConditionalsH-118"></front>
<front id="ConditionalsH-119">  // Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs</front>
<front id="ConditionalsH-120">  #if ENABLED(LCD_I2C_VIKI)</front>
<front id="ConditionalsH-121">    // This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )</front>
<front id="ConditionalsH-122">    // Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.</front>
<front id="ConditionalsH-123">    // Note: The pause/stop/resume LCD button pin should be connected to the Arduino</front>
<front id="ConditionalsH-124">    //       BTN_ENC pin (or set BTN_ENC to -1 if not used)</front>
<front id="ConditionalsH-125">    #define LCD_I2C_TYPE_MCP23017</front>
<front id="ConditionalsH-126">    #define LCD_I2C_ADDRESS 0x20 // I2C Address of the port expander</front>
<front id="ConditionalsH-127">    #define LCD_USE_I2C_BUZZER //comment out to disable buzzer on LCD (requires LiquidTWI2 v1.2.3 or later)</front>
<front id="ConditionalsH-128">    #define ULTIPANEL</front>
<front id="ConditionalsH-129">    #define NEWPANEL</front>
<front id="ConditionalsH-130">  #endif</front>
<front id="ConditionalsH-131"></front>
<front id="ConditionalsH-132">  // Shift register panels</front>
<front id="ConditionalsH-133">  // ---------------------</front>
<front id="ConditionalsH-134">  // 2 wire Non-latching LCD SR from:</front>
<front id="ConditionalsH-135">  // https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection</front>
<front id="ConditionalsH-136"></front>
<front id="ConditionalsH-137">  #if ENABLED(SAV_3DLCD)</front>
<front id="ConditionalsH-138">     #define SR_LCD_2W_NL    // Non latching 2 wire shiftregister</front>
<front id="ConditionalsH-139">     #define ULTIPANEL</front>
<front id="ConditionalsH-140">     #define NEWPANEL</front>
<front id="ConditionalsH-141">  #endif</front>
<front id="ConditionalsH-142"></front>
<front id="ConditionalsH-143">  #if ENABLED(ULTIPANEL)</front>
<front id="ConditionalsH-144">    #define NEWPANEL  //enable this if you have a click-encoder panel</front>
<front id="ConditionalsH-145">    #define ULTRA_LCD</front>
<front id="ConditionalsH-146">    #if ENABLED(DOGLCD) // Change number of lines to match the DOG graphic display</front>
<front id="ConditionalsH-147">      #define LCD_WIDTH 22</front>
<front id="ConditionalsH-148">      #define LCD_HEIGHT 5</front>
<front id="ConditionalsH-149">    #else</front>
<front id="ConditionalsH-150">      #define LCD_WIDTH 20</front>
<front id="ConditionalsH-151">      #define LCD_HEIGHT 4</front>
<front id="ConditionalsH-152">    #endif</front>
<front id="ConditionalsH-153">  #else //no panel but just LCD</front>
<front id="ConditionalsH-154">    #if ENABLED(ULTRA_LCD)</front>
<front id="ConditionalsH-155">      #if ENABLED(DOGLCD) // Change number of lines to match the 128x64 graphics display</front>
<front id="ConditionalsH-156">        #define LCD_WIDTH 22</front>
<front id="ConditionalsH-157">        #define LCD_HEIGHT 5</front>
<front id="ConditionalsH-158">      #else</front>
<front id="ConditionalsH-159">        #define LCD_WIDTH 16</front>
<front id="ConditionalsH-160">        #define LCD_HEIGHT 2</front>
<front id="ConditionalsH-161">      #endif</front>
<front id="ConditionalsH-162">    #endif</front>
<front id="ConditionalsH-163">  #endif</front>
<front id="ConditionalsH-164"></front>
<front id="ConditionalsH-165">  #if ENABLED(DOGLCD)</front>
<front id="ConditionalsH-166">    /* Custom characters defined in font font_6x10_marlin_symbols */</front>
<front id="ConditionalsH-167">    // \x00 intentionally skipped to avoid problems in strings</front>
<front id="ConditionalsH-168">    #define LCD_STR_REFRESH     "\x01"</front>
<front id="ConditionalsH-169">    #define LCD_STR_FOLDER      "\x02"</front>
<front id="ConditionalsH-170">    #define LCD_STR_ARROW_RIGHT "\x03"</front>
<front id="ConditionalsH-171">    #define LCD_STR_UPLEVEL     "\x04"</front>
<front id="ConditionalsH-172">    #define LCD_STR_CLOCK       "\x05"</front>
<front id="ConditionalsH-173">    #define LCD_STR_FEEDRATE    "\x06"</front>
<front id="ConditionalsH-174">    #define LCD_STR_BEDTEMP     "\x07"</front>
<front id="ConditionalsH-175">    #define LCD_STR_THERMOMETER "\x08"</front>
<front id="ConditionalsH-176">    #define LCD_STR_DEGREE      "\x09"</front>
<front id="ConditionalsH-177"></front>
<front id="ConditionalsH-178">    #define LCD_STR_SPECIAL_MAX '\x09'</front>
<front id="ConditionalsH-179">    // Maximum here is 0x1f because 0x20 is ' ' (space) and the normal charsets begin.</front>
<front id="ConditionalsH-180">    // Better stay below 0x10 because DISPLAY_CHARSET_HD44780_WESTERN begins here.</front>
<front id="ConditionalsH-181">  #else</front>
<front id="ConditionalsH-182">    /* Custom characters defined in the first 8 characters of the LCD */</front>
<front id="ConditionalsH-183">    #define LCD_STR_BEDTEMP     "\x00"  // this will have 'unexpected' results when used in a string!</front>
<front id="ConditionalsH-184">    #define LCD_STR_DEGREE      "\x01"</front>
<front id="ConditionalsH-185">    #define LCD_STR_THERMOMETER "\x02"</front>
<front id="ConditionalsH-186">    #define LCD_STR_UPLEVEL     "\x03"</front>
<front id="ConditionalsH-187">    #define LCD_STR_REFRESH     "\x04"</front>
<front id="ConditionalsH-188">    #define LCD_STR_FOLDER      "\x05"</front>
<front id="ConditionalsH-189">    #define LCD_STR_FEEDRATE    "\x06"</front>
<front id="ConditionalsH-190">    #define LCD_STR_CLOCK       "\x07"</front>
<front id="ConditionalsH-191">    #define LCD_STR_ARROW_RIGHT "&gt;"  /* from the default character set */</front>
<front id="ConditionalsH-192">  #endif</front>
<front id="ConditionalsH-193"></front>
<front id="ConditionalsH-194">  /**</front>
<front id="ConditionalsH-195">   * Default LCD contrast for dogm-like LCD displays</front>
<front id="ConditionalsH-196">   */</front>
<front id="ConditionalsH-197">  #if ENABLED(DOGLCD) && DISABLED(DEFAULT_LCD_CONTRAST)</front>
<front id="ConditionalsH-198">    #define DEFAULT_LCD_CONTRAST 32</front>
<front id="ConditionalsH-199">  #endif</front>
<front id="ConditionalsH-200"></front>
<front id="ConditionalsH-201">  #if ENABLED(DOGLCD)</front>
<front id="ConditionalsH-202">    #define HAS_LCD_CONTRAST</front>
<front id="ConditionalsH-203">    #if ENABLED(U8GLIB_ST7920)</front>
<front id="ConditionalsH-204">      #undef HAS_LCD_CONTRAST</front>
<front id="ConditionalsH-205">    #endif</front>
<front id="ConditionalsH-206">    #if ENABLED(U8GLIB_SSD1306)</front>
<front id="ConditionalsH-207">      #undef HAS_LCD_CONTRAST</front>
<front id="ConditionalsH-208">    #endif  </front>
<front id="ConditionalsH-209">  #endif</front>
<front id="ConditionalsH-210"></front>
<front id="ConditionalsH-211">#else // CONFIGURATION_LCD</front>
<front id="ConditionalsH-212"></front>
<front id="ConditionalsH-213">  #define CONDITIONALS_H</front>
<front id="ConditionalsH-214"></front>
<front id="ConditionalsH-215">  #include "pins.h"</front>
<front id="ConditionalsH-216"></front>
<front id="ConditionalsH-217">  #ifndef USBCON</front>
<front id="ConditionalsH-218">    #define HardwareSerial_h // trick to disable the standard HWserial</front>
<front id="ConditionalsH-219">  #endif</front>
<front id="ConditionalsH-220"></front>
<front id="ConditionalsH-221">  #include "Arduino.h"</front>
<front id="ConditionalsH-222"></front>
<front id="ConditionalsH-223">  /**</front>
<front id="ConditionalsH-224">   * ENDSTOPPULLUPS</front>
<front id="ConditionalsH-225">   */</front>
<front id="ConditionalsH-226">  #if ENABLED(ENDSTOPPULLUPS)</front>
<front id="ConditionalsH-227">    #if DISABLED(DISABLE_MAX_ENDSTOPS)</front>
<front id="ConditionalsH-228">      #define ENDSTOPPULLUP_XMAX</front>
<front id="ConditionalsH-229">      #define ENDSTOPPULLUP_YMAX</front>
<front id="ConditionalsH-230">      #define ENDSTOPPULLUP_ZMAX</front>
<front id="ConditionalsH-231">    #endif</front>
<front id="ConditionalsH-232">    #if DISABLED(DISABLE_MIN_ENDSTOPS)</front>
<front id="ConditionalsH-233">      #define ENDSTOPPULLUP_XMIN</front>
<front id="ConditionalsH-234">      #define ENDSTOPPULLUP_YMIN</front>
<front id="ConditionalsH-235">      #define ENDSTOPPULLUP_ZMIN</front>
<front id="ConditionalsH-236">    #endif</front>
<front id="ConditionalsH-237">    #if DISABLED(DISABLE_Z_MIN_PROBE_ENDSTOP)</front>
<front id="ConditionalsH-238">      #define ENDSTOPPULLUP_ZMIN_PROBE</front>
<front id="ConditionalsH-239">    #endif</front>
<front id="ConditionalsH-240">  #endif</front>
<front id="ConditionalsH-241"></front>
<front id="ConditionalsH-242">  /**</front>
<front id="ConditionalsH-243">   * Axis lengths</front>
<front id="ConditionalsH-244">   */</front>
<front id="ConditionalsH-245">  #define X_MAX_LENGTH (X_MAX_POS - X_MIN_POS)</front>
<front id="ConditionalsH-246">  #define Y_MAX_LENGTH (Y_MAX_POS - Y_MIN_POS)</front>
<front id="ConditionalsH-247">  #define Z_MAX_LENGTH (Z_MAX_POS - Z_MIN_POS)</front>
<front id="ConditionalsH-248"></front>
<front id="ConditionalsH-249">  /**</front>
<front id="ConditionalsH-250">   * SCARA</front>
<front id="ConditionalsH-251">   */</front>
<front id="ConditionalsH-252">  #if ENABLED(SCARA)</front>
<front id="ConditionalsH-253">    #undef SLOWDOWN</front>
<front id="ConditionalsH-254">    #define QUICK_HOME //SCARA needs Quickhome</front>
<front id="ConditionalsH-255">  #endif</front>
<front id="ConditionalsH-256"></front>
<front id="ConditionalsH-257">  /**</front>
<front id="ConditionalsH-258">   * AUTOSET LOCATIONS OF LIMIT SWITCHES</front>
<front id="ConditionalsH-259">   */</front>
<front id="ConditionalsH-260">  #if ENABLED(MANUAL_HOME_POSITIONS)  // Use manual limit switch locations</front>
<front id="ConditionalsH-261">    #define X_HOME_POS MANUAL_X_HOME_POS</front>
<front id="ConditionalsH-262">    #define Y_HOME_POS MANUAL_Y_HOME_POS</front>
<front id="ConditionalsH-263">    #define Z_HOME_POS MANUAL_Z_HOME_POS</front>
<front id="ConditionalsH-264">  #else //!MANUAL_HOME_POSITIONS  Use home switch positions based on homing direction and travel limits</front>
<front id="ConditionalsH-265">    #if ENABLED(BED_CENTER_AT_0_0)</front>
<front id="ConditionalsH-266">      #define X_HOME_POS X_MAX_LENGTH * X_HOME_DIR * 0.5</front>
<front id="ConditionalsH-267">      #define Y_HOME_POS Y_MAX_LENGTH * Y_HOME_DIR * 0.5</front>
<front id="ConditionalsH-268">    #else</front>
<front id="ConditionalsH-269">      #define X_HOME_POS (X_HOME_DIR &lt; 0 ? X_MIN_POS : X_MAX_POS)</front>
<front id="ConditionalsH-270">      #define Y_HOME_POS (Y_HOME_DIR &lt; 0 ? Y_MIN_POS : Y_MAX_POS)</front>
<front id="ConditionalsH-271">    #endif</front>
<front id="ConditionalsH-272">    #define Z_HOME_POS (Z_HOME_DIR &lt; 0 ? Z_MIN_POS : Z_MAX_POS)</front>
<front id="ConditionalsH-273">  #endif //!MANUAL_HOME_POSITIONS</front>
<front id="ConditionalsH-274"></front>
<front id="ConditionalsH-275">  /**</front>
<front id="ConditionalsH-276">   * Auto Bed Leveling</front>
<front id="ConditionalsH-277">   */</front>
<front id="ConditionalsH-278">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ConditionalsH-279">    // Boundaries for probing based on set limits</front>
<front id="ConditionalsH-280">    #define MIN_PROBE_X (max(X_MIN_POS, X_MIN_POS + X_PROBE_OFFSET_FROM_EXTRUDER))</front>
<front id="ConditionalsH-281">    #define MAX_PROBE_X (min(X_MAX_POS, X_MAX_POS + X_PROBE_OFFSET_FROM_EXTRUDER))</front>
<front id="ConditionalsH-282">    #define MIN_PROBE_Y (max(Y_MIN_POS, Y_MIN_POS + Y_PROBE_OFFSET_FROM_EXTRUDER))</front>
<front id="ConditionalsH-283">    #define MAX_PROBE_Y (min(Y_MAX_POS, Y_MAX_POS + Y_PROBE_OFFSET_FROM_EXTRUDER))</front>
<front id="ConditionalsH-284">  #endif</front>
<front id="ConditionalsH-285"></front>
<front id="ConditionalsH-286">  #define SERVO_LEVELING (defined(AUTO_BED_LEVELING_FEATURE) && defined(Z_ENDSTOP_SERVO_NR))</front>
<front id="ConditionalsH-287"></front>
<front id="ConditionalsH-288">   /**</front>
<front id="ConditionalsH-289">    * Sled Options</front>
<front id="ConditionalsH-290">    */ </front>
<front id="ConditionalsH-291">  #if ENABLED(Z_PROBE_SLED)</front>
<front id="ConditionalsH-292">    #define Z_SAFE_HOMING</front>
<front id="ConditionalsH-293">  #endif</front>
<front id="ConditionalsH-294">  </front>
<front id="ConditionalsH-295">  /**</front>
<front id="ConditionalsH-296">   * MAX_STEP_FREQUENCY differs for TOSHIBA</front>
<front id="ConditionalsH-297">   */</front>
<front id="ConditionalsH-298">  #if ENABLED(CONFIG_STEPPERS_TOSHIBA)</front>
<front id="ConditionalsH-299">    #define MAX_STEP_FREQUENCY 10000 // Max step frequency for Toshiba Stepper Controllers</front>
<front id="ConditionalsH-300">  #else</front>
<front id="ConditionalsH-301">    #define MAX_STEP_FREQUENCY 40000 // Max step frequency for Ultimaker (5000 pps / half step)</front>
<front id="ConditionalsH-302">  #endif</front>
<front id="ConditionalsH-303"></front>
<front id="ConditionalsH-304">  // MS1 MS2 Stepper Driver Microstepping mode table</front>
<front id="ConditionalsH-305">  #define MICROSTEP1 LOW,LOW</front>
<front id="ConditionalsH-306">  #define MICROSTEP2 HIGH,LOW</front>
<front id="ConditionalsH-307">  #define MICROSTEP4 LOW,HIGH</front>
<front id="ConditionalsH-308">  #define MICROSTEP8 HIGH,HIGH</front>
<front id="ConditionalsH-309">  #define MICROSTEP16 HIGH,HIGH</front>
<front id="ConditionalsH-310"></front>
<front id="ConditionalsH-311">  /**</front>
<front id="ConditionalsH-312">   * Advance calculated values</front>
<front id="ConditionalsH-313">   */</front>
<front id="ConditionalsH-314">  #if ENABLED(ADVANCE)</front>
<front id="ConditionalsH-315">    #define EXTRUSION_AREA (0.25 * D_FILAMENT * D_FILAMENT * M_PI)</front>
<front id="ConditionalsH-316">    #define STEPS_PER_CUBIC_MM_E (axis_steps_per_unit[E_AXIS] / EXTRUSION_AREA)</front>
<front id="ConditionalsH-317">  #endif</front>
<front id="ConditionalsH-318"></front>
<front id="ConditionalsH-319">  #if ENABLED(ULTIPANEL) && DISABLED(ELB_FULL_GRAPHIC_CONTROLLER)</front>
<front id="ConditionalsH-320">    #undef SD_DETECT_INVERTED</front>
<front id="ConditionalsH-321">  #endif</front>
<front id="ConditionalsH-322"></front>
<front id="ConditionalsH-323">  // Power Signal Control Definitions</front>
<front id="ConditionalsH-324">  // By default use ATX definition</front>
<front id="ConditionalsH-325">  #ifndef POWER_SUPPLY</front>
<front id="ConditionalsH-326">    #define POWER_SUPPLY 1</front>
<front id="ConditionalsH-327">  #endif</front>
<front id="ConditionalsH-328">  #if (POWER_SUPPLY == 1)     // 1 = ATX</front>
<front id="ConditionalsH-329">    #define PS_ON_AWAKE  LOW</front>
<front id="ConditionalsH-330">    #define PS_ON_ASLEEP HIGH</front>
<front id="ConditionalsH-331">  #elif (POWER_SUPPLY == 2)   // 2 = X-Box 360 203W</front>
<front id="ConditionalsH-332">    #define PS_ON_AWAKE  HIGH</front>
<front id="ConditionalsH-333">    #define PS_ON_ASLEEP LOW</front>
<front id="ConditionalsH-334">  #endif</front>
<front id="ConditionalsH-335">  #define HAS_POWER_SWITCH (POWER_SUPPLY &gt; 0 && PIN_EXISTS(PS_ON))</front>
<front id="ConditionalsH-336"></front>
<front id="ConditionalsH-337">  /**</front>
<front id="ConditionalsH-338">   * Temp Sensor defines</front>
<front id="ConditionalsH-339">   */</front>
<front id="ConditionalsH-340">  #if TEMP_SENSOR_0 == -2</front>
<front id="ConditionalsH-341">    #define HEATER_0_USES_MAX6675</front>
<front id="ConditionalsH-342">  #elif TEMP_SENSOR_0 == -1</front>
<front id="ConditionalsH-343">    #define HEATER_0_USES_AD595</front>
<front id="ConditionalsH-344">  #elif TEMP_SENSOR_0 == 0</front>
<front id="ConditionalsH-345">    #undef HEATER_0_MINTEMP</front>
<front id="ConditionalsH-346">    #undef HEATER_0_MAXTEMP</front>
<front id="ConditionalsH-347">  #elif TEMP_SENSOR_0 &gt; 0</front>
<front id="ConditionalsH-348">    #define THERMISTORHEATER_0 TEMP_SENSOR_0</front>
<front id="ConditionalsH-349">    #define HEATER_0_USES_THERMISTOR</front>
<front id="ConditionalsH-350">  #endif</front>
<front id="ConditionalsH-351"></front>
<front id="ConditionalsH-352">  #if TEMP_SENSOR_1 == -1</front>
<front id="ConditionalsH-353">    #define HEATER_1_USES_AD595</front>
<front id="ConditionalsH-354">  #elif TEMP_SENSOR_1 == 0</front>
<front id="ConditionalsH-355">    #undef HEATER_1_MINTEMP</front>
<front id="ConditionalsH-356">    #undef HEATER_1_MAXTEMP</front>
<front id="ConditionalsH-357">  #elif TEMP_SENSOR_1 &gt; 0</front>
<front id="ConditionalsH-358">    #define THERMISTORHEATER_1 TEMP_SENSOR_1</front>
<front id="ConditionalsH-359">    #define HEATER_1_USES_THERMISTOR</front>
<front id="ConditionalsH-360">  #endif</front>
<front id="ConditionalsH-361"></front>
<front id="ConditionalsH-362">  #if TEMP_SENSOR_2 == -1</front>
<front id="ConditionalsH-363">    #define HEATER_2_USES_AD595</front>
<front id="ConditionalsH-364">  #elif TEMP_SENSOR_2 == 0</front>
<front id="ConditionalsH-365">    #undef HEATER_2_MINTEMP</front>
<front id="ConditionalsH-366">    #undef HEATER_2_MAXTEMP</front>
<front id="ConditionalsH-367">  #elif TEMP_SENSOR_2 &gt; 0</front>
<front id="ConditionalsH-368">    #define THERMISTORHEATER_2 TEMP_SENSOR_2</front>
<front id="ConditionalsH-369">    #define HEATER_2_USES_THERMISTOR</front>
<front id="ConditionalsH-370">  #endif</front>
<front id="ConditionalsH-371"></front>
<front id="ConditionalsH-372">  #if TEMP_SENSOR_3 == -1</front>
<front id="ConditionalsH-373">    #define HEATER_3_USES_AD595</front>
<front id="ConditionalsH-374">  #elif TEMP_SENSOR_3 == 0</front>
<front id="ConditionalsH-375">    #undef HEATER_3_MINTEMP</front>
<front id="ConditionalsH-376">    #undef HEATER_3_MAXTEMP</front>
<front id="ConditionalsH-377">  #elif TEMP_SENSOR_3 &gt; 0</front>
<front id="ConditionalsH-378">    #define THERMISTORHEATER_3 TEMP_SENSOR_3</front>
<front id="ConditionalsH-379">    #define HEATER_3_USES_THERMISTOR</front>
<front id="ConditionalsH-380">  #endif</front>
<front id="ConditionalsH-381"></front>
<front id="ConditionalsH-382">  #if TEMP_SENSOR_BED == -1</front>
<front id="ConditionalsH-383">    #define BED_USES_AD595</front>
<front id="ConditionalsH-384">  #elif TEMP_SENSOR_BED == 0</front>
<front id="ConditionalsH-385">    #undef BED_MINTEMP</front>
<front id="ConditionalsH-386">    #undef BED_MAXTEMP</front>
<front id="ConditionalsH-387">  #elif TEMP_SENSOR_BED &gt; 0</front>
<front id="ConditionalsH-388">    #define THERMISTORBED TEMP_SENSOR_BED</front>
<front id="ConditionalsH-389">    #define BED_USES_THERMISTOR</front>
<front id="ConditionalsH-390">  #endif</front>
<front id="ConditionalsH-391"></front>
<front id="ConditionalsH-392">  /**</front>
<front id="ConditionalsH-393">   * ARRAY_BY_EXTRUDERS based on EXTRUDERS</front>
<front id="ConditionalsH-394">   */</front>
<front id="ConditionalsH-395">  #if EXTRUDERS &gt; 3</front>
<front id="ConditionalsH-396">    #define ARRAY_BY_EXTRUDERS(v1, v2, v3, v4) { v1, v2, v3, v4 }</front>
<front id="ConditionalsH-397">  #elif EXTRUDERS &gt; 2</front>
<front id="ConditionalsH-398">    #define ARRAY_BY_EXTRUDERS(v1, v2, v3, v4) { v1, v2, v3 }</front>
<front id="ConditionalsH-399">  #elif EXTRUDERS &gt; 1</front>
<front id="ConditionalsH-400">    #define ARRAY_BY_EXTRUDERS(v1, v2, v3, v4) { v1, v2 }</front>
<front id="ConditionalsH-401">  #else</front>
<front id="ConditionalsH-402">    #define ARRAY_BY_EXTRUDERS(v1, v2, v3, v4) { v1 }</front>
<front id="ConditionalsH-403">  #endif</front>
<front id="ConditionalsH-404"></front>
<front id="ConditionalsH-405">  #define ARRAY_BY_EXTRUDERS1(v1) ARRAY_BY_EXTRUDERS(v1, v1, v1, v1)</front>
<front id="ConditionalsH-406"></front>
<front id="ConditionalsH-407">  /**</front>
<front id="ConditionalsH-408">   * Shorthand for pin tests, used wherever needed</front>
<front id="ConditionalsH-409">   */</front>
<front id="ConditionalsH-410">  #define HAS_TEMP_0 (PIN_EXISTS(TEMP_0) && TEMP_SENSOR_0 != 0 && TEMP_SENSOR_0 != -2)</front>
<front id="ConditionalsH-411">  #define HAS_TEMP_1 (PIN_EXISTS(TEMP_1) && TEMP_SENSOR_1 != 0)</front>
<front id="ConditionalsH-412">  #define HAS_TEMP_2 (PIN_EXISTS(TEMP_2) && TEMP_SENSOR_2 != 0)</front>
<front id="ConditionalsH-413">  #define HAS_TEMP_3 (PIN_EXISTS(TEMP_3) && TEMP_SENSOR_3 != 0)</front>
<front id="ConditionalsH-414">  #define HAS_TEMP_BED (PIN_EXISTS(TEMP_BED) && TEMP_SENSOR_BED != 0)</front>
<front id="ConditionalsH-415">  #define HAS_HEATER_0 (PIN_EXISTS(HEATER_0))</front>
<front id="ConditionalsH-416">  #define HAS_HEATER_1 (PIN_EXISTS(HEATER_1))</front>
<front id="ConditionalsH-417">  #define HAS_HEATER_2 (PIN_EXISTS(HEATER_2))</front>
<front id="ConditionalsH-418">  #define HAS_HEATER_3 (PIN_EXISTS(HEATER_3))</front>
<front id="ConditionalsH-419">  #define HAS_HEATER_BED (PIN_EXISTS(HEATER_BED))</front>
<front id="ConditionalsH-420">  #define HAS_AUTO_FAN_0 (PIN_EXISTS(EXTRUDER_0_AUTO_FAN))</front>
<front id="ConditionalsH-421">  #define HAS_AUTO_FAN_1 (PIN_EXISTS(EXTRUDER_1_AUTO_FAN))</front>
<front id="ConditionalsH-422">  #define HAS_AUTO_FAN_2 (PIN_EXISTS(EXTRUDER_2_AUTO_FAN))</front>
<front id="ConditionalsH-423">  #define HAS_AUTO_FAN_3 (PIN_EXISTS(EXTRUDER_3_AUTO_FAN))</front>
<front id="ConditionalsH-424">  #define HAS_AUTO_FAN (HAS_AUTO_FAN_0 || HAS_AUTO_FAN_1 || HAS_AUTO_FAN_2 || HAS_AUTO_FAN_3)</front>
<front id="ConditionalsH-425">  #define HAS_FAN (PIN_EXISTS(FAN))</front>
<front id="ConditionalsH-426">  #define HAS_CONTROLLERFAN (PIN_EXISTS(CONTROLLERFAN))</front>
<front id="ConditionalsH-427">  #define HAS_SERVOS (defined(NUM_SERVOS) && NUM_SERVOS &gt; 0)</front>
<front id="ConditionalsH-428">  #define HAS_SERVO_0 (PIN_EXISTS(SERVO0))</front>
<front id="ConditionalsH-429">  #define HAS_SERVO_1 (PIN_EXISTS(SERVO1))</front>
<front id="ConditionalsH-430">  #define HAS_SERVO_2 (PIN_EXISTS(SERVO2))</front>
<front id="ConditionalsH-431">  #define HAS_SERVO_3 (PIN_EXISTS(SERVO3))</front>
<front id="ConditionalsH-432">  #define HAS_FILAMENT_SENSOR (ENABLED(FILAMENT_SENSOR) && PIN_EXISTS(FILWIDTH))</front>
<front id="ConditionalsH-433">  #define HAS_FILRUNOUT (PIN_EXISTS(FILRUNOUT))</front>
<front id="ConditionalsH-434">  #define HAS_HOME (PIN_EXISTS(HOME))</front>
<front id="ConditionalsH-435">  #define HAS_KILL (PIN_EXISTS(KILL))</front>
<front id="ConditionalsH-436">  #define HAS_SUICIDE (PIN_EXISTS(SUICIDE))</front>
<front id="ConditionalsH-437">  #define HAS_PHOTOGRAPH (PIN_EXISTS(PHOTOGRAPH))</front>
<front id="ConditionalsH-438">  #define HAS_X_MIN (PIN_EXISTS(X_MIN))</front>
<front id="ConditionalsH-439">  #define HAS_X_MAX (PIN_EXISTS(X_MAX))</front>
<front id="ConditionalsH-440">  #define HAS_Y_MIN (PIN_EXISTS(Y_MIN))</front>
<front id="ConditionalsH-441">  #define HAS_Y_MAX (PIN_EXISTS(Y_MAX))</front>
<front id="ConditionalsH-442">  #define HAS_Z_MIN (PIN_EXISTS(Z_MIN))</front>
<front id="ConditionalsH-443">  #define HAS_Z_MAX (PIN_EXISTS(Z_MAX))</front>
<front id="ConditionalsH-444">  #define HAS_Z2_MIN (PIN_EXISTS(Z2_MIN))</front>
<front id="ConditionalsH-445">  #define HAS_Z2_MAX (PIN_EXISTS(Z2_MAX))</front>
<front id="ConditionalsH-446">  #define HAS_Z_PROBE (PIN_EXISTS(Z_MIN_PROBE))</front>
<front id="ConditionalsH-447">  #define HAS_SOLENOID_1 (PIN_EXISTS(SOL1))</front>
<front id="ConditionalsH-448">  #define HAS_SOLENOID_2 (PIN_EXISTS(SOL2))</front>
<front id="ConditionalsH-449">  #define HAS_SOLENOID_3 (PIN_EXISTS(SOL3))</front>
<front id="ConditionalsH-450">  #define HAS_MICROSTEPS (PIN_EXISTS(X_MS1))</front>
<front id="ConditionalsH-451">  #define HAS_MICROSTEPS_E0 (PIN_EXISTS(E0_MS1))</front>
<front id="ConditionalsH-452">  #define HAS_MICROSTEPS_E1 (PIN_EXISTS(E1_MS1))</front>
<front id="ConditionalsH-453">  #define HAS_MICROSTEPS_E2 (PIN_EXISTS(E2_MS1))</front>
<front id="ConditionalsH-454">  #define HAS_STEPPER_RESET (PIN_EXISTS(STEPPER_RESET))</front>
<front id="ConditionalsH-455">  #define HAS_X_ENABLE (PIN_EXISTS(X_ENABLE))</front>
<front id="ConditionalsH-456">  #define HAS_X2_ENABLE (PIN_EXISTS(X2_ENABLE))</front>
<front id="ConditionalsH-457">  #define HAS_Y_ENABLE (PIN_EXISTS(Y_ENABLE))</front>
<front id="ConditionalsH-458">  #define HAS_Y2_ENABLE (PIN_EXISTS(Y2_ENABLE))</front>
<front id="ConditionalsH-459">  #define HAS_Z_ENABLE (PIN_EXISTS(Z_ENABLE))</front>
<front id="ConditionalsH-460">  #define HAS_Z2_ENABLE (PIN_EXISTS(Z2_ENABLE))</front>
<front id="ConditionalsH-461">  #define HAS_E0_ENABLE (PIN_EXISTS(E0_ENABLE))</front>
<front id="ConditionalsH-462">  #define HAS_E1_ENABLE (PIN_EXISTS(E1_ENABLE))</front>
<front id="ConditionalsH-463">  #define HAS_E2_ENABLE (PIN_EXISTS(E2_ENABLE))</front>
<front id="ConditionalsH-464">  #define HAS_E3_ENABLE (PIN_EXISTS(E3_ENABLE))</front>
<front id="ConditionalsH-465">  #define HAS_X_DIR (PIN_EXISTS(X_DIR))</front>
<front id="ConditionalsH-466">  #define HAS_X2_DIR (PIN_EXISTS(X2_DIR))</front>
<front id="ConditionalsH-467">  #define HAS_Y_DIR (PIN_EXISTS(Y_DIR))</front>
<front id="ConditionalsH-468">  #define HAS_Y2_DIR (PIN_EXISTS(Y2_DIR))</front>
<front id="ConditionalsH-469">  #define HAS_Z_DIR (PIN_EXISTS(Z_DIR))</front>
<front id="ConditionalsH-470">  #define HAS_Z2_DIR (PIN_EXISTS(Z2_DIR))</front>
<front id="ConditionalsH-471">  #define HAS_E0_DIR (PIN_EXISTS(E0_DIR))</front>
<front id="ConditionalsH-472">  #define HAS_E1_DIR (PIN_EXISTS(E1_DIR))</front>
<front id="ConditionalsH-473">  #define HAS_E2_DIR (PIN_EXISTS(E2_DIR))</front>
<front id="ConditionalsH-474">  #define HAS_E3_DIR (PIN_EXISTS(E3_DIR))</front>
<front id="ConditionalsH-475">  #define HAS_X_STEP (PIN_EXISTS(X_STEP))</front>
<front id="ConditionalsH-476">  #define HAS_X2_STEP (PIN_EXISTS(X2_STEP))</front>
<front id="ConditionalsH-477">  #define HAS_Y_STEP (PIN_EXISTS(Y_STEP))</front>
<front id="ConditionalsH-478">  #define HAS_Y2_STEP (PIN_EXISTS(Y2_STEP))</front>
<front id="ConditionalsH-479">  #define HAS_Z_STEP (PIN_EXISTS(Z_STEP))</front>
<front id="ConditionalsH-480">  #define HAS_Z2_STEP (PIN_EXISTS(Z2_STEP))</front>
<front id="ConditionalsH-481">  #define HAS_E0_STEP (PIN_EXISTS(E0_STEP))</front>
<front id="ConditionalsH-482">  #define HAS_E1_STEP (PIN_EXISTS(E1_STEP))</front>
<front id="ConditionalsH-483">  #define HAS_E2_STEP (PIN_EXISTS(E2_STEP))</front>
<front id="ConditionalsH-484">  #define HAS_E3_STEP (PIN_EXISTS(E3_STEP))</front>
<front id="ConditionalsH-485"></front>
<front id="ConditionalsH-486">  /**</front>
<front id="ConditionalsH-487">   * Helper Macros for heaters and extruder fan</front>
<front id="ConditionalsH-488">   */</front>
<front id="ConditionalsH-489">  #define WRITE_HEATER_0P(v) WRITE(HEATER_0_PIN, v)</front>
<front id="ConditionalsH-490">  #if EXTRUDERS &gt; 1 || ENABLED(HEATERS_PARALLEL)</front>
<front id="ConditionalsH-491">    #define WRITE_HEATER_1(v) WRITE(HEATER_1_PIN, v)</front>
<front id="ConditionalsH-492">    #if EXTRUDERS &gt; 2</front>
<front id="ConditionalsH-493">      #define WRITE_HEATER_2(v) WRITE(HEATER_2_PIN, v)</front>
<front id="ConditionalsH-494">      #if EXTRUDERS &gt; 3</front>
<front id="ConditionalsH-495">        #define WRITE_HEATER_3(v) WRITE(HEATER_3_PIN, v)</front>
<front id="ConditionalsH-496">      #endif</front>
<front id="ConditionalsH-497">    #endif</front>
<front id="ConditionalsH-498">  #endif</front>
<front id="ConditionalsH-499">  #if ENABLED(HEATERS_PARALLEL)</front>
<front id="ConditionalsH-500">    #define WRITE_HEATER_0(v) { WRITE_HEATER_0P(v); WRITE_HEATER_1(v); }</front>
<front id="ConditionalsH-501">  #else</front>
<front id="ConditionalsH-502">    #define WRITE_HEATER_0(v) WRITE_HEATER_0P(v)</front>
<front id="ConditionalsH-503">  #endif</front>
<front id="ConditionalsH-504">  #if HAS_HEATER_BED</front>
<front id="ConditionalsH-505">    #define WRITE_HEATER_BED(v) WRITE(HEATER_BED_PIN, v)</front>
<front id="ConditionalsH-506">  #endif</front>
<front id="ConditionalsH-507">  #if HAS_FAN</front>
<front id="ConditionalsH-508">    #define WRITE_FAN(v) WRITE(FAN_PIN, v)</front>
<front id="ConditionalsH-509">  #endif</front>
<front id="ConditionalsH-510"></front>
<front id="ConditionalsH-511">  #define HAS_BUZZER (PIN_EXISTS(BEEPER) || defined(LCD_USE_I2C_BUZZER))</front>
<front id="ConditionalsH-512"></front>
<front id="ConditionalsH-513">  #if defined(NUM_SERVOS) && NUM_SERVOS &gt; 0</front>
<front id="ConditionalsH-514">    #ifndef X_ENDSTOP_SERVO_NR</front>
<front id="ConditionalsH-515">      #define X_ENDSTOP_SERVO_NR -1</front>
<front id="ConditionalsH-516">    #endif</front>
<front id="ConditionalsH-517">    #ifndef Y_ENDSTOP_SERVO_NR</front>
<front id="ConditionalsH-518">      #define Y_ENDSTOP_SERVO_NR -1</front>
<front id="ConditionalsH-519">    #endif</front>
<front id="ConditionalsH-520">    #ifndef Z_ENDSTOP_SERVO_NR</front>
<front id="ConditionalsH-521">      #define Z_ENDSTOP_SERVO_NR -1</front>
<front id="ConditionalsH-522">    #endif</front>
<front id="ConditionalsH-523">    #if X_ENDSTOP_SERVO_NR &gt;= 0 || Y_ENDSTOP_SERVO_NR &gt;= 0 || Z_ENDSTOP_SERVO_NR &gt;= 0</front>
<front id="ConditionalsH-524">      #define HAS_SERVO_ENDSTOPS true</front>
<front id="ConditionalsH-525">      #define SERVO_ENDSTOP_IDS { X_ENDSTOP_SERVO_NR, Y_ENDSTOP_SERVO_NR, Z_ENDSTOP_SERVO_NR }</front>
<front id="ConditionalsH-526">    #endif</front>
<front id="ConditionalsH-527">  #endif</front>
<front id="ConditionalsH-528"></front>
<front id="ConditionalsH-529">#endif //CONFIGURATION_LCD</front>
<front id="ConditionalsH-530">#endif //CONDITIONALS_H</front>
 </pre>
<h1 id="ConfigurationHtitle" >Configuration.h</h1>
<pre id="ConfigurationH"  class="prettyprint linenums"><front id="ConfigurationH-1">#ifndef CONFIGURATION_H</front>
<front id="ConfigurationH-2">#define CONFIGURATION_H</front>
<front id="ConfigurationH-3"></front>
<front id="ConfigurationH-4">#include "boards.h"</front>
<front id="ConfigurationH-5">#include "macros.h"</front>
<front id="ConfigurationH-6"></front>
<front id="ConfigurationH-7">//===========================================================================</front>
<front id="ConfigurationH-8">//============================= Getting Started =============================</front>
<front id="ConfigurationH-9">//===========================================================================</front>
<front id="ConfigurationH-10">/*</front>
<front id="ConfigurationH-11">Here are some standard links for getting your machine calibrated:</front>
<front id="ConfigurationH-12"> * http://reprap.org/wiki/Calibration</front>
<front id="ConfigurationH-13"> * http://youtu.be/wAL9d7FgInk</front>
<front id="ConfigurationH-14"> * http://calculator.josefprusa.cz</front>
<front id="ConfigurationH-15"> * http://reprap.org/wiki/Triffid_Hunter%27s_Calibration_Guide</front>
<front id="ConfigurationH-16"> * http://www.thingiverse.com/thing:5573</front>
<front id="ConfigurationH-17"> * https://sites.google.com/site/repraplogphase/calibration-of-your-reprap</front>
<front id="ConfigurationH-18"> * http://www.thingiverse.com/thing:298812</front>
<front id="ConfigurationH-19">*/</front>
<front id="ConfigurationH-20"></front>
<front id="ConfigurationH-21">// This configuration file contains the basic settings.</front>
<front id="ConfigurationH-22">// Advanced settings can be found in Configuration_adv.h</front>
<front id="ConfigurationH-23">// BASIC SETTINGS: select your board type, temperature sensor type, axis scaling, and endstop configuration</front>
<front id="ConfigurationH-24"></front>
<front id="ConfigurationH-25">//===========================================================================</front>
<front id="ConfigurationH-26">//============================= DELTA Printer ===============================</front>
<front id="ConfigurationH-27">//===========================================================================</front>
<front id="ConfigurationH-28">// For a Delta printer replace the configuration files with the files in the</front>
<front id="ConfigurationH-29">// example_configurations/delta directory.</front>
<front id="ConfigurationH-30">//</front>
<front id="ConfigurationH-31"></front>
<front id="ConfigurationH-32">//===========================================================================</front>
<front id="ConfigurationH-33">//============================= SCARA Printer ===============================</front>
<front id="ConfigurationH-34">//===========================================================================</front>
<front id="ConfigurationH-35">// For a Scara printer replace the configuration files with the files in the</front>
<front id="ConfigurationH-36">// example_configurations/SCARA directory.</front>
<front id="ConfigurationH-37">//</front>
<front id="ConfigurationH-38"></front>
<front id="ConfigurationH-39">// @section info</front>
<front id="ConfigurationH-40"></front>
<front id="ConfigurationH-41">#if ENABLED(USE_AUTOMATIC_VERSIONING)</front>
<front id="ConfigurationH-42">  #include "_Version.h"</front>
<front id="ConfigurationH-43">#else</front>
<front id="ConfigurationH-44">  #include "Default_Version.h"</front>
<front id="ConfigurationH-45">#endif</front>
<front id="ConfigurationH-46"></front>
<front id="ConfigurationH-47">// User-specified version info of this build to display in [Pronterface, etc] terminal window during</front>
<front id="ConfigurationH-48">// startup. Implementation of an idea by Prof Braino to inform user that any changes made to this</front>
<front id="ConfigurationH-49">// build by the user have been successfully uploaded into firmware.</front>
<front id="ConfigurationH-50">#define STRING_CONFIG_H_AUTHOR "(none, default config)" // Who made the changes.</front>
<front id="ConfigurationH-51">#define SHOW_BOOTSCREEN</front>
<front id="ConfigurationH-52">#define STRING_SPLASH_LINE1 SHORT_BUILD_VERSION // will be shown during bootup in line 1</front>
<front id="ConfigurationH-53">//#define STRING_SPLASH_LINE2 STRING_DISTRIBUTION_DATE // will be shown during bootup in line 2</front>
<front id="ConfigurationH-54"></front>
<front id="ConfigurationH-55">// @section machine</front>
<front id="ConfigurationH-56"></front>
<front id="ConfigurationH-57">// SERIAL_PORT selects which serial port should be used for communication with the host.</front>
<front id="ConfigurationH-58">// This allows the connection of wireless adapters (for instance) to non-default port pins.</front>
<front id="ConfigurationH-59">// Serial port 0 is still used by the Arduino bootloader regardless of this setting.</front>
<front id="ConfigurationH-60">// :[0,1,2,3,4,5,6,7]</front>
<front id="ConfigurationH-61">#define SERIAL_PORT 0</front>
<front id="ConfigurationH-62"></front>
<front id="ConfigurationH-63">// This determines the communication speed of the printer</front>
<front id="ConfigurationH-64">// :[2400,9600,19200,38400,57600,115200,250000]</front>
<front id="ConfigurationH-65">#define BAUDRATE 250000</front>
<front id="ConfigurationH-66"></front>
<front id="ConfigurationH-67">// Enable the Bluetooth serial interface on AT90USB devices</front>
<front id="ConfigurationH-68">//#define BLUETOOTH</front>
<front id="ConfigurationH-69"></front>
<front id="ConfigurationH-70">// The following define selects which electronics board you have.</front>
<front id="ConfigurationH-71">// Please choose the name from boards.h that matches your setup</front>
<front id="ConfigurationH-72">#ifndef MOTHERBOARD</front>
<front id="ConfigurationH-73">  #define MOTHERBOARD BOARD_RAMPS_13_EFB</front>
<front id="ConfigurationH-74">#endif</front>
<front id="ConfigurationH-75"></front>
<front id="ConfigurationH-76">// Optional custom name for your RepStrap or other custom machine</front>
<front id="ConfigurationH-77">// Displayed in the LCD "Ready" message</front>
<front id="ConfigurationH-78">// #define CUSTOM_MACHINE_NAME "3D Printer"</front>
<front id="ConfigurationH-79"></front>
<front id="ConfigurationH-80">// Define this to set a unique identifier for this printer, (Used by some programs to differentiate between machines)</front>
<front id="ConfigurationH-81">// You can use an online service to generate a random UUID. (eg http://www.uuidgenerator.net/version4)</front>
<front id="ConfigurationH-82">// #define MACHINE_UUID "00000000-0000-0000-0000-000000000000"</front>
<front id="ConfigurationH-83"></front>
<front id="ConfigurationH-84">// This defines the number of extruders</front>
<front id="ConfigurationH-85">// :[1,2,3,4]</front>
<front id="ConfigurationH-86">#define EXTRUDERS 1</front>
<front id="ConfigurationH-87"></front>
<front id="ConfigurationH-88">// Offset of the extruders (uncomment if using more than one and relying on firmware to position when changing).</front>
<front id="ConfigurationH-89">// The offset has to be X=0, Y=0 for the extruder 0 hotend (default extruder).</front>
<front id="ConfigurationH-90">// For the other hotends it is their distance from the extruder 0 hotend.</front>
<front id="ConfigurationH-91">//#define EXTRUDER_OFFSET_X {0.0, 20.00} // (in mm) for each extruder, offset of the hotend on the X axis</front>
<front id="ConfigurationH-92">//#define EXTRUDER_OFFSET_Y {0.0, 5.00}  // (in mm) for each extruder, offset of the hotend on the Y axis</front>
<front id="ConfigurationH-93"></front>
<front id="ConfigurationH-94">//// The following define selects which power supply you have. Please choose the one that matches your setup</front>
<front id="ConfigurationH-95">// 1 = ATX</front>
<front id="ConfigurationH-96">// 2 = X-Box 360 203Watts (the blue wire connected to PS_ON and the red wire to VCC)</front>
<front id="ConfigurationH-97">// :{1:'ATX',2:'X-Box 360'}</front>
<front id="ConfigurationH-98"></front>
<front id="ConfigurationH-99">#define POWER_SUPPLY 1</front>
<front id="ConfigurationH-100"></front>
<front id="ConfigurationH-101">// Define this to have the electronics keep the power supply off on startup. If you don't know what this is leave it.</front>
<front id="ConfigurationH-102">//#define PS_DEFAULT_OFF</front>
<front id="ConfigurationH-103"></front>
<front id="ConfigurationH-104">// @section temperature</front>
<front id="ConfigurationH-105"></front>
<front id="ConfigurationH-106">//===========================================================================</front>
<front id="ConfigurationH-107">//============================= Thermal Settings ============================</front>
<front id="ConfigurationH-108">//===========================================================================</front>
<front id="ConfigurationH-109">//</front>
<front id="ConfigurationH-110">//--NORMAL IS 4.7kohm PULLUP!-- 1kohm pullup can be used on hotend sensor, using correct resistor and table</front>
<front id="ConfigurationH-111">//</front>
<front id="ConfigurationH-112">//// Temperature sensor settings:</front>
<front id="ConfigurationH-113">// -2 is thermocouple with MAX6675 (only for sensor 0)</front>
<front id="ConfigurationH-114">// -1 is thermocouple with AD595</front>
<front id="ConfigurationH-115">// 0 is not used</front>
<front id="ConfigurationH-116">// 1 is 100k thermistor - best choice for EPCOS 100k (4.7k pullup)</front>
<front id="ConfigurationH-117">// 2 is 200k thermistor - ATC Semitec 204GT-2 (4.7k pullup)</front>
<front id="ConfigurationH-118">// 3 is Mendel-parts thermistor (4.7k pullup)</front>
<front id="ConfigurationH-119">// 4 is 10k thermistor !! do not use it for a hotend. It gives bad resolution at high temp. !!</front>
<front id="ConfigurationH-120">// 5 is 100K thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (4.7k pullup)</front>
<front id="ConfigurationH-121">// 6 is 100k EPCOS - Not as accurate as table 1 (created using a fluke thermocouple) (4.7k pullup)</front>
<front id="ConfigurationH-122">// 7 is 100k Honeywell thermistor 135-104LAG-J01 (4.7k pullup)</front>
<front id="ConfigurationH-123">// 71 is 100k Honeywell thermistor 135-104LAF-J01 (4.7k pullup)</front>
<front id="ConfigurationH-124">// 8 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)</front>
<front id="ConfigurationH-125">// 9 is 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)</front>
<front id="ConfigurationH-126">// 10 is 100k RS thermistor 198-961 (4.7k pullup)</front>
<front id="ConfigurationH-127">// 11 is 100k beta 3950 1% thermistor (4.7k pullup)</front>
<front id="ConfigurationH-128">// 12 is 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)</front>
<front id="ConfigurationH-129">// 13 is 100k Hisens 3950  1% up to 300C for hotend "Simple ONE " & "Hotend "All In ONE"</front>
<front id="ConfigurationH-130">// 20 is the PT100 circuit found in the Ultimainboard V2.x</front>
<front id="ConfigurationH-131">// 60 is 100k Maker's Tool Works Kapton Bed Thermistor beta=3950</front>
<front id="ConfigurationH-132">//</front>
<front id="ConfigurationH-133">//    1k ohm pullup tables - This is not normal, you would have to have changed out your 4.7k for 1k</front>
<front id="ConfigurationH-134">//                          (but gives greater accuracy and more stable PID)</front>
<front id="ConfigurationH-135">// 51 is 100k thermistor - EPCOS (1k pullup)</front>
<front id="ConfigurationH-136">// 52 is 200k thermistor - ATC Semitec 204GT-2 (1k pullup)</front>
<front id="ConfigurationH-137">// 55 is 100k thermistor - ATC Semitec 104GT-2 (Used in ParCan & J-Head) (1k pullup)</front>
<front id="ConfigurationH-138">//</front>
<front id="ConfigurationH-139">// 1047 is Pt1000 with 4k7 pullup</front>
<front id="ConfigurationH-140">// 1010 is Pt1000 with 1k pullup (non standard)</front>
<front id="ConfigurationH-141">// 147 is Pt100 with 4k7 pullup</front>
<front id="ConfigurationH-142">// 110 is Pt100 with 1k pullup (non standard)</front>
<front id="ConfigurationH-143">// 998 and 999 are Dummy Tables. They will ALWAYS read 25C or the temperature defined below.</front>
<front id="ConfigurationH-144">//     Use it for Testing or Development purposes. NEVER for production machine.</front>
<front id="ConfigurationH-145">//     #define DUMMY_THERMISTOR_998_VALUE 25</front>
<front id="ConfigurationH-146">//     #define DUMMY_THERMISTOR_999_VALUE 100</front>
<front id="ConfigurationH-147">// :{ '0': "Not used", '4': "10k !! do not use for a hotend. Bad resolution at high temp. !!", '1': "100k / 4.7k - EPCOS", '51': "100k / 1k - EPCOS", '6': "100k / 4.7k EPCOS - Not as accurate as Table 1", '5': "100K / 4.7k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)", '7': "100k / 4.7k Honeywell 135-104LAG-J01", '71': "100k / 4.7k Honeywell 135-104LAF-J01", '8': "100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT", '9': "100k / 4.7k GE Sensing AL03006-58.2K-97-G1", '10': "100k / 4.7k RS 198-961", '11': "100k / 4.7k beta 3950 1%", '12': "100k / 4.7k 0603 SMD Vishay NTCS0603E3104FXT (calibrated for Makibox hot bed)", '13': "100k Hisens 3950  1% up to 300C for hotend 'Simple ONE ' & hotend 'All In ONE'", '60': "100k Maker's Tool Works Kapton Bed Thermistor beta=3950", '55': "100k / 1k - ATC Semitec 104GT-2 (Used in ParCan & J-Head)", '2': "200k / 4.7k - ATC Semitec 204GT-2", '52': "200k / 1k - ATC Semitec 204GT-2", '-2': "Thermocouple + MAX6675 (only for sensor 0)", '-1': "Thermocouple + AD595", '3': "Mendel-parts / 4.7k", '1047': "Pt1000 / 4.7k", '1010': "Pt1000 / 1k (non standard)", '20': "PT100 (Ultimainboard V2.x)", '147': "Pt100 / 4.7k", '110': "Pt100 / 1k (non-standard)", '998': "Dummy 1", '999': "Dummy 2" }</front>
<front id="ConfigurationH-148">#define TEMP_SENSOR_0 1</front>
<front id="ConfigurationH-149">#define TEMP_SENSOR_1 0</front>
<front id="ConfigurationH-150">#define TEMP_SENSOR_2 0</front>
<front id="ConfigurationH-151">#define TEMP_SENSOR_3 0</front>
<front id="ConfigurationH-152">#define TEMP_SENSOR_BED 0</front>
<front id="ConfigurationH-153"></front>
<front id="ConfigurationH-154">// This makes temp sensor 1 a redundant sensor for sensor 0. If the temperatures difference between these sensors is to high the print will be aborted.</front>
<front id="ConfigurationH-155">//#define TEMP_SENSOR_1_AS_REDUNDANT</front>
<front id="ConfigurationH-156">#define MAX_REDUNDANT_TEMP_SENSOR_DIFF 10</front>
<front id="ConfigurationH-157"></front>
<front id="ConfigurationH-158">// Actual temperature must be close to target for this long before M109 returns success</front>
<front id="ConfigurationH-159">#define TEMP_RESIDENCY_TIME 10  // (seconds)</front>
<front id="ConfigurationH-160">#define TEMP_HYSTERESIS 3       // (degC) range of +/- temperatures considered "close" to the target one</front>
<front id="ConfigurationH-161">#define TEMP_WINDOW     1       // (degC) Window around target to start the residency timer x degC early.</front>
<front id="ConfigurationH-162"></front>
<front id="ConfigurationH-163">// The minimal temperature defines the temperature below which the heater will not be enabled It is used</front>
<front id="ConfigurationH-164">// to check that the wiring to the thermistor is not broken.</front>
<front id="ConfigurationH-165">// Otherwise this would lead to the heater being powered on all the time.</front>
<front id="ConfigurationH-166">#define HEATER_0_MINTEMP 5</front>
<front id="ConfigurationH-167">#define HEATER_1_MINTEMP 5</front>
<front id="ConfigurationH-168">#define HEATER_2_MINTEMP 5</front>
<front id="ConfigurationH-169">#define HEATER_3_MINTEMP 5</front>
<front id="ConfigurationH-170">#define BED_MINTEMP 5</front>
<front id="ConfigurationH-171"></front>
<front id="ConfigurationH-172">// When temperature exceeds max temp, your heater will be switched off.</front>
<front id="ConfigurationH-173">// This feature exists to protect your hotend from overheating accidentally, but *NOT* from thermistor short/failure!</front>
<front id="ConfigurationH-174">// You should use MINTEMP for thermistor short/failure protection.</front>
<front id="ConfigurationH-175">#define HEATER_0_MAXTEMP 275</front>
<front id="ConfigurationH-176">#define HEATER_1_MAXTEMP 275</front>
<front id="ConfigurationH-177">#define HEATER_2_MAXTEMP 275</front>
<front id="ConfigurationH-178">#define HEATER_3_MAXTEMP 275</front>
<front id="ConfigurationH-179">#define BED_MAXTEMP 150</front>
<front id="ConfigurationH-180"></front>
<front id="ConfigurationH-181">// If your bed has low resistance e.g. .6 ohm and throws the fuse you can duty cycle it to reduce the</front>
<front id="ConfigurationH-182">// average current. The value should be an integer and the heat bed will be turned on for 1 interval of</front>
<front id="ConfigurationH-183">// HEATER_BED_DUTY_CYCLE_DIVIDER intervals.</front>
<front id="ConfigurationH-184">//#define HEATER_BED_DUTY_CYCLE_DIVIDER 4</front>
<front id="ConfigurationH-185"></front>
<front id="ConfigurationH-186">// If you want the M105 heater power reported in watts, define the BED_WATTS, and (shared for all extruders) EXTRUDER_WATTS</front>
<front id="ConfigurationH-187">//#define EXTRUDER_WATTS (12.0*12.0/6.7) //  P=I^2/R</front>
<front id="ConfigurationH-188">//#define BED_WATTS (12.0*12.0/1.1)      // P=I^2/R</front>
<front id="ConfigurationH-189"></front>
<front id="ConfigurationH-190">//===========================================================================</front>
<front id="ConfigurationH-191">//============================= PID Settings ================================</front>
<front id="ConfigurationH-192">//===========================================================================</front>
<front id="ConfigurationH-193">// PID Tuning Guide here: http://reprap.org/wiki/PID_Tuning</front>
<front id="ConfigurationH-194"></front>
<front id="ConfigurationH-195">// Comment the following line to disable PID and enable bang-bang.</front>
<front id="ConfigurationH-196">#define PIDTEMP</front>
<front id="ConfigurationH-197">#define BANG_MAX 255 // limits current to nozzle while in bang-bang mode; 255=full current</front>
<front id="ConfigurationH-198">#define PID_MAX BANG_MAX // limits current to nozzle while PID is active (see PID_FUNCTIONAL_RANGE below); 255=full current</front>
<front id="ConfigurationH-199">#if ENABLED(PIDTEMP)</front>
<front id="ConfigurationH-200">  //#define PID_DEBUG // Sends debug data to the serial port.</front>
<front id="ConfigurationH-201">  //#define PID_OPENLOOP 1 // Puts PID in open loop. M104/M140 sets the output power from 0 to PID_MAX</front>
<front id="ConfigurationH-202">  //#define SLOW_PWM_HEATERS // PWM with very low frequency (roughly 0.125Hz=8s) and minimum state time of approximately 1s useful for heaters driven by a relay</front>
<front id="ConfigurationH-203">  //#define PID_PARAMS_PER_EXTRUDER // Uses separate PID parameters for each extruder (useful for mismatched extruders)</front>
<front id="ConfigurationH-204">                                    // Set/get with gcode: M301 E[extruder number, 0-2]</front>
<front id="ConfigurationH-205">  #define PID_FUNCTIONAL_RANGE 10 // If the temperature difference between the target temperature and the actual temperature</front>
<front id="ConfigurationH-206">                                  // is more then PID_FUNCTIONAL_RANGE then the PID will be shut off and the heater will be set to min/max.</front>
<front id="ConfigurationH-207">  #define PID_INTEGRAL_DRIVE_MAX PID_MAX  //limit for the integral term</front>
<front id="ConfigurationH-208">  #define K1 0.95 //smoothing factor within the PID</front>
<front id="ConfigurationH-209"></front>
<front id="ConfigurationH-210">  // If you are using a pre-configured hotend then you can use one of the value sets by uncommenting it</front>
<front id="ConfigurationH-211">  // Ultimaker</front>
<front id="ConfigurationH-212">  #define  DEFAULT_Kp 22.2</front>
<front id="ConfigurationH-213">  #define  DEFAULT_Ki 1.08</front>
<front id="ConfigurationH-214">  #define  DEFAULT_Kd 114</front>
<front id="ConfigurationH-215"></front>
<front id="ConfigurationH-216">  // MakerGear</front>
<front id="ConfigurationH-217">  //#define  DEFAULT_Kp 7.0</front>
<front id="ConfigurationH-218">  //#define  DEFAULT_Ki 0.1</front>
<front id="ConfigurationH-219">  //#define  DEFAULT_Kd 12</front>
<front id="ConfigurationH-220"></front>
<front id="ConfigurationH-221">  // Mendel Parts V9 on 12V</front>
<front id="ConfigurationH-222">  //#define  DEFAULT_Kp 63.0</front>
<front id="ConfigurationH-223">  //#define  DEFAULT_Ki 2.25</front>
<front id="ConfigurationH-224">  //#define  DEFAULT_Kd 440</front>
<front id="ConfigurationH-225"></front>
<front id="ConfigurationH-226">#endif // PIDTEMP</front>
<front id="ConfigurationH-227"></front>
<front id="ConfigurationH-228">//===========================================================================</front>
<front id="ConfigurationH-229">//============================= PID &gt; Bed Temperature Control ===============</front>
<front id="ConfigurationH-230">//===========================================================================</front>
<front id="ConfigurationH-231">// Select PID or bang-bang with PIDTEMPBED. If bang-bang, BED_LIMIT_SWITCHING will enable hysteresis</front>
<front id="ConfigurationH-232">//</front>
<front id="ConfigurationH-233">// Uncomment this to enable PID on the bed. It uses the same frequency PWM as the extruder.</front>
<front id="ConfigurationH-234">// If your PID_dT is the default, and correct for your hardware/configuration, that means 7.689Hz,</front>
<front id="ConfigurationH-235">// which is fine for driving a square wave into a resistive load and does not significantly impact you FET heating.</front>
<front id="ConfigurationH-236">// This also works fine on a Fotek SSR-10DA Solid State Relay into a 250W heater.</front>
<front id="ConfigurationH-237">// If your configuration is significantly different than this and you don't understand the issues involved, you probably</front>
<front id="ConfigurationH-238">// shouldn't use bed PID until someone else verifies your hardware works.</front>
<front id="ConfigurationH-239">// If this is enabled, find your own PID constants below.</front>
<front id="ConfigurationH-240">//#define PIDTEMPBED</front>
<front id="ConfigurationH-241"></front>
<front id="ConfigurationH-242">//#define BED_LIMIT_SWITCHING</front>
<front id="ConfigurationH-243"></front>
<front id="ConfigurationH-244">// This sets the max power delivered to the bed, and replaces the HEATER_BED_DUTY_CYCLE_DIVIDER option.</front>
<front id="ConfigurationH-245">// all forms of bed control obey this (PID, bang-bang, bang-bang with hysteresis)</front>
<front id="ConfigurationH-246">// setting this to anything other than 255 enables a form of PWM to the bed just like HEATER_BED_DUTY_CYCLE_DIVIDER did,</front>
<front id="ConfigurationH-247">// so you shouldn't use it unless you are OK with PWM on your bed.  (see the comment on enabling PIDTEMPBED)</front>
<front id="ConfigurationH-248">#define MAX_BED_POWER 255 // limits duty cycle to bed; 255=full current</front>
<front id="ConfigurationH-249"></front>
<front id="ConfigurationH-250">//#define PID_BED_DEBUG // Sends debug data to the serial port.</front>
<front id="ConfigurationH-251"></front>
<front id="ConfigurationH-252">#if ENABLED(PIDTEMPBED)</front>
<front id="ConfigurationH-253"></front>
<front id="ConfigurationH-254">  #define PID_BED_INTEGRAL_DRIVE_MAX MAX_BED_POWER //limit for the integral term</front>
<front id="ConfigurationH-255"></front>
<front id="ConfigurationH-256">  //120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)</front>
<front id="ConfigurationH-257">  //from FOPDT model - kp=.39 Tp=405 Tdead=66, Tc set to 79.2, aggressive factor of .15 (vs .1, 1, 10)</front>
<front id="ConfigurationH-258">  #define  DEFAULT_bedKp 10.00</front>
<front id="ConfigurationH-259">  #define  DEFAULT_bedKi .023</front>
<front id="ConfigurationH-260">  #define  DEFAULT_bedKd 305.4</front>
<front id="ConfigurationH-261"></front>
<front id="ConfigurationH-262">  //120v 250W silicone heater into 4mm borosilicate (MendelMax 1.5+)</front>
<front id="ConfigurationH-263">  //from pidautotune</front>
<front id="ConfigurationH-264">  //#define  DEFAULT_bedKp 97.1</front>
<front id="ConfigurationH-265">  //#define  DEFAULT_bedKi 1.41</front>
<front id="ConfigurationH-266">  //#define  DEFAULT_bedKd 1675.16</front>
<front id="ConfigurationH-267"></front>
<front id="ConfigurationH-268">  // FIND YOUR OWN: "M303 E-1 C8 S90" to run autotune on the bed at 90 degreesC for 8 cycles.</front>
<front id="ConfigurationH-269">#endif // PIDTEMPBED</front>
<front id="ConfigurationH-270"></front>
<front id="ConfigurationH-271">// @section extruder</front>
<front id="ConfigurationH-272"></front>
<front id="ConfigurationH-273">//this prevents dangerous Extruder moves, i.e. if the temperature is under the limit</front>
<front id="ConfigurationH-274">//can be software-disabled for whatever purposes by</front>
<front id="ConfigurationH-275">#define PREVENT_DANGEROUS_EXTRUDE</front>
<front id="ConfigurationH-276">//if PREVENT_DANGEROUS_EXTRUDE is on, you can still disable (uncomment) very long bits of extrusion separately.</front>
<front id="ConfigurationH-277">#define PREVENT_LENGTHY_EXTRUDE</front>
<front id="ConfigurationH-278"></front>
<front id="ConfigurationH-279">#define EXTRUDE_MINTEMP 170</front>
<front id="ConfigurationH-280">#define EXTRUDE_MAXLENGTH (X_MAX_LENGTH+Y_MAX_LENGTH) //prevent extrusion of very large distances.</front>
<front id="ConfigurationH-281"></front>
<front id="ConfigurationH-282">//===========================================================================</front>
<front id="ConfigurationH-283">//======================== Thermal Runaway Protection =======================</front>
<front id="ConfigurationH-284">//===========================================================================</front>
<front id="ConfigurationH-285"></front>
<front id="ConfigurationH-286">/**</front>
<front id="ConfigurationH-287"> * Thermal Runaway Protection protects your printer from damage and fire if a</front>
<front id="ConfigurationH-288"> * thermistor falls out or temperature sensors fail in any way.</front>
<front id="ConfigurationH-289"> *</front>
<front id="ConfigurationH-290"> * The issue: If a thermistor falls out or a temperature sensor fails,</front>
<front id="ConfigurationH-291"> * Marlin can no longer sense the actual temperature. Since a disconnected</front>
<front id="ConfigurationH-292"> * thermistor reads as a low temperature, the firmware will keep the heater on.</front>
<front id="ConfigurationH-293"> *</front>
<front id="ConfigurationH-294"> * The solution: Once the temperature reaches the target, start observing.</front>
<front id="ConfigurationH-295"> * If the temperature stays too far below the target (hysteresis) for too long,</front>
<front id="ConfigurationH-296"> * the firmware will halt as a safety precaution.</front>
<front id="ConfigurationH-297"> */</front>
<front id="ConfigurationH-298"></front>
<front id="ConfigurationH-299">#define THERMAL_PROTECTION_HOTENDS // Enable thermal protection for all extruders</front>
<front id="ConfigurationH-300">#define THERMAL_PROTECTION_BED     // Enable thermal protection for the heated bed</front>
<front id="ConfigurationH-301"></front>
<front id="ConfigurationH-302">//===========================================================================</front>
<front id="ConfigurationH-303">//============================= Mechanical Settings =========================</front>
<front id="ConfigurationH-304">//===========================================================================</front>
<front id="ConfigurationH-305"></front>
<front id="ConfigurationH-306">// @section machine</front>
<front id="ConfigurationH-307"></front>
<front id="ConfigurationH-308">// Uncomment this option to enable CoreXY kinematics</front>
<front id="ConfigurationH-309">//#define COREXY</front>
<front id="ConfigurationH-310"></front>
<front id="ConfigurationH-311">// Uncomment this option to enable CoreXZ kinematics</front>
<front id="ConfigurationH-312">//#define COREXZ</front>
<front id="ConfigurationH-313"></front>
<front id="ConfigurationH-314">// Enable this option for Toshiba steppers</front>
<front id="ConfigurationH-315">//#define CONFIG_STEPPERS_TOSHIBA</front>
<front id="ConfigurationH-316"></front>
<front id="ConfigurationH-317">// @section homing</front>
<front id="ConfigurationH-318"></front>
<front id="ConfigurationH-319">// coarse Endstop Settings</front>
<front id="ConfigurationH-320">#define ENDSTOPPULLUPS // Comment this out (using // at the start of the line) to disable the endstop pullup resistors</front>
<front id="ConfigurationH-321"></front>
<front id="ConfigurationH-322">#if DISABLED(ENDSTOPPULLUPS)</front>
<front id="ConfigurationH-323">  // fine endstop settings: Individual pullups. will be ignored if ENDSTOPPULLUPS is defined</front>
<front id="ConfigurationH-324">  // #define ENDSTOPPULLUP_XMAX</front>
<front id="ConfigurationH-325">  // #define ENDSTOPPULLUP_YMAX</front>
<front id="ConfigurationH-326">  // #define ENDSTOPPULLUP_ZMAX</front>
<front id="ConfigurationH-327">  // #define ENDSTOPPULLUP_XMIN</front>
<front id="ConfigurationH-328">  // #define ENDSTOPPULLUP_YMIN</front>
<front id="ConfigurationH-329">  // #define ENDSTOPPULLUP_ZMIN</front>
<front id="ConfigurationH-330">  // #define ENDSTOPPULLUP_ZMIN_PROBE</front>
<front id="ConfigurationH-331">#endif</front>
<front id="ConfigurationH-332"></front>
<front id="ConfigurationH-333">// Mechanical endstop with COM to ground and NC to Signal uses "false" here (most common setup).</front>
<front id="ConfigurationH-334">const bool X_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-335">const bool Y_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-336">const bool Z_MIN_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-337">const bool X_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-338">const bool Y_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-339">const bool Z_MAX_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-340">const bool Z_MIN_PROBE_ENDSTOP_INVERTING = false; // set to true to invert the logic of the endstop.</front>
<front id="ConfigurationH-341">//#define DISABLE_MAX_ENDSTOPS</front>
<front id="ConfigurationH-342">//#define DISABLE_MIN_ENDSTOPS</front>
<front id="ConfigurationH-343"></front>
<front id="ConfigurationH-344">// If you want to enable the Z probe pin, but disable its use, uncomment the line below.</front>
<front id="ConfigurationH-345">// This only affects a Z probe endstop if you have separate Z min endstop as well and have</front>
<front id="ConfigurationH-346">// activated Z_MIN_PROBE_ENDSTOP below. If you are using the Z Min endstop on your Z probe,</front>
<front id="ConfigurationH-347">// this has no effect.</front>
<front id="ConfigurationH-348">//#define DISABLE_Z_MIN_PROBE_ENDSTOP</front>
<front id="ConfigurationH-349"></front>
<front id="ConfigurationH-350">// For Inverting Stepper Enable Pins (Active Low) use 0, Non Inverting (Active High) use 1</front>
<front id="ConfigurationH-351">// :{0:'Low',1:'High'}</front>
<front id="ConfigurationH-352">#define X_ENABLE_ON 0</front>
<front id="ConfigurationH-353">#define Y_ENABLE_ON 0</front>
<front id="ConfigurationH-354">#define Z_ENABLE_ON 0</front>
<front id="ConfigurationH-355">#define E_ENABLE_ON 0 // For all extruders</front>
<front id="ConfigurationH-356"></front>
<front id="ConfigurationH-357">// Disables axis when it's not being used.</front>
<front id="ConfigurationH-358">// WARNING: When motors turn off there is a chance of losing position accuracy!</front>
<front id="ConfigurationH-359">#define DISABLE_X false</front>
<front id="ConfigurationH-360">#define DISABLE_Y false</front>
<front id="ConfigurationH-361">#define DISABLE_Z false</front>
<front id="ConfigurationH-362"></front>
<front id="ConfigurationH-363">// @section extruder</front>
<front id="ConfigurationH-364"></front>
<front id="ConfigurationH-365">#define DISABLE_E false // For all extruders</front>
<front id="ConfigurationH-366">#define DISABLE_INACTIVE_EXTRUDER true //disable only inactive extruders and keep active extruder enabled</front>
<front id="ConfigurationH-367"></front>
<front id="ConfigurationH-368">// @section machine</front>
<front id="ConfigurationH-369"></front>
<front id="ConfigurationH-370">// Invert the stepper direction. Change (or reverse the motor connector) if an axis goes the wrong way.</front>
<front id="ConfigurationH-371">#define INVERT_X_DIR false</front>
<front id="ConfigurationH-372">#define INVERT_Y_DIR true</front>
<front id="ConfigurationH-373">#define INVERT_Z_DIR false</front>
<front id="ConfigurationH-374"></front>
<front id="ConfigurationH-375">// @section extruder</front>
<front id="ConfigurationH-376"></front>
<front id="ConfigurationH-377">// For direct drive extruder v9 set to true, for geared extruder set to false.</front>
<front id="ConfigurationH-378">#define INVERT_E0_DIR false</front>
<front id="ConfigurationH-379">#define INVERT_E1_DIR false</front>
<front id="ConfigurationH-380">#define INVERT_E2_DIR false</front>
<front id="ConfigurationH-381">#define INVERT_E3_DIR false</front>
<front id="ConfigurationH-382"></front>
<front id="ConfigurationH-383">// @section homing</front>
<front id="ConfigurationH-384"></front>
<front id="ConfigurationH-385">// ENDSTOP SETTINGS:</front>
<front id="ConfigurationH-386">// Sets direction of endstops when homing; 1=MAX, -1=MIN</front>
<front id="ConfigurationH-387">// :[-1,1]</front>
<front id="ConfigurationH-388">#define X_HOME_DIR -1</front>
<front id="ConfigurationH-389">#define Y_HOME_DIR -1</front>
<front id="ConfigurationH-390">#define Z_HOME_DIR -1</front>
<front id="ConfigurationH-391"></front>
<front id="ConfigurationH-392">#define min_software_endstops true // If true, axis won't move to coordinates less than HOME_POS.</front>
<front id="ConfigurationH-393">#define max_software_endstops true  // If true, axis won't move to coordinates greater than the defined lengths below.</front>
<front id="ConfigurationH-394"></front>
<front id="ConfigurationH-395">// @section machine</front>
<front id="ConfigurationH-396"></front>
<front id="ConfigurationH-397">// Travel limits after homing (units are in mm)</front>
<front id="ConfigurationH-398">#define X_MIN_POS 0</front>
<front id="ConfigurationH-399">#define Y_MIN_POS 0</front>
<front id="ConfigurationH-400">#define Z_MIN_POS 0</front>
<front id="ConfigurationH-401">#define X_MAX_POS 200</front>
<front id="ConfigurationH-402">#define Y_MAX_POS 200</front>
<front id="ConfigurationH-403">#define Z_MAX_POS 200</front>
<front id="ConfigurationH-404"></front>
<front id="ConfigurationH-405">//===========================================================================</front>
<front id="ConfigurationH-406">//========================= Filament Runout Sensor ==========================</front>
<front id="ConfigurationH-407">//===========================================================================</front>
<front id="ConfigurationH-408">//#define FILAMENT_RUNOUT_SENSOR // Uncomment for defining a filament runout sensor such as a mechanical or opto endstop to check the existence of filament</front>
<front id="ConfigurationH-409">                                 // In RAMPS uses servo pin 2. Can be changed in pins file. For other boards pin definition should be made.</front>
<front id="ConfigurationH-410">                                 // It is assumed that when logic high = filament available</front>
<front id="ConfigurationH-411">                                 //                    when logic  low = filament ran out</front>
<front id="ConfigurationH-412">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="ConfigurationH-413">  const bool FIL_RUNOUT_INVERTING = true;  // Should be uncommented and true or false should assigned</front>
<front id="ConfigurationH-414">  #define ENDSTOPPULLUP_FIL_RUNOUT // Uncomment to use internal pullup for filament runout pins if the sensor is defined.</front>
<front id="ConfigurationH-415">  #define FILAMENT_RUNOUT_SCRIPT "M600"</front>
<front id="ConfigurationH-416">#endif</front>
<front id="ConfigurationH-417"></front>
<front id="ConfigurationH-418">//===========================================================================</front>
<front id="ConfigurationH-419">//=========================== Manual Bed Leveling ===========================</front>
<front id="ConfigurationH-420">//===========================================================================</front>
<front id="ConfigurationH-421"></front>
<front id="ConfigurationH-422">// #define MANUAL_BED_LEVELING  // Add display menu option for bed leveling.</front>
<front id="ConfigurationH-423">// #define MESH_BED_LEVELING    // Enable mesh bed leveling.</front>
<front id="ConfigurationH-424"></front>
<front id="ConfigurationH-425">#if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ConfigurationH-426">  #define MBL_Z_STEP 0.025  // Step size while manually probing Z axis.</front>
<front id="ConfigurationH-427">#endif  // MANUAL_BED_LEVELING</front>
<front id="ConfigurationH-428"></front>
<front id="ConfigurationH-429">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="ConfigurationH-430">  #define MESH_MIN_X 10</front>
<front id="ConfigurationH-431">  #define MESH_MAX_X (X_MAX_POS - MESH_MIN_X)</front>
<front id="ConfigurationH-432">  #define MESH_MIN_Y 10</front>
<front id="ConfigurationH-433">  #define MESH_MAX_Y (Y_MAX_POS - MESH_MIN_Y)</front>
<front id="ConfigurationH-434">  #define MESH_NUM_X_POINTS 3  // Don't use more than 7 points per axis, implementation limited.</front>
<front id="ConfigurationH-435">  #define MESH_NUM_Y_POINTS 3</front>
<front id="ConfigurationH-436">  #define MESH_HOME_SEARCH_Z 4  // Z after Home, bed somewhere below but above 0.0.</front>
<front id="ConfigurationH-437">#endif  // MESH_BED_LEVELING</front>
<front id="ConfigurationH-438"></front>
<front id="ConfigurationH-439">//===========================================================================</front>
<front id="ConfigurationH-440">//============================ Bed Auto Leveling ============================</front>
<front id="ConfigurationH-441">//===========================================================================</front>
<front id="ConfigurationH-442"></front>
<front id="ConfigurationH-443">// @section bedlevel</front>
<front id="ConfigurationH-444"></front>
<front id="ConfigurationH-445">//#define AUTO_BED_LEVELING_FEATURE // Delete the comment to enable (remove // at the start of the line)</front>
<front id="ConfigurationH-446">//#define DEBUG_LEVELING_FEATURE</front>
<front id="ConfigurationH-447">#define Z_MIN_PROBE_REPEATABILITY_TEST  // If not commented out, Z-Probe Repeatability test will be included if Auto Bed Leveling is Enabled.</front>
<front id="ConfigurationH-448"></front>
<front id="ConfigurationH-449">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ConfigurationH-450"></front>
<front id="ConfigurationH-451">  // There are 2 different ways to specify probing locations:</front>
<front id="ConfigurationH-452">  //</front>
<front id="ConfigurationH-453">  // - "grid" mode</front>
<front id="ConfigurationH-454">  //   Probe several points in a rectangular grid.</front>
<front id="ConfigurationH-455">  //   You specify the rectangle and the density of sample points.</front>
<front id="ConfigurationH-456">  //   This mode is preferred because there are more measurements.</front>
<front id="ConfigurationH-457">  //</front>
<front id="ConfigurationH-458">  // - "3-point" mode</front>
<front id="ConfigurationH-459">  //   Probe 3 arbitrary points on the bed (that aren't colinear)</front>
<front id="ConfigurationH-460">  //   You specify the XY coordinates of all 3 points.</front>
<front id="ConfigurationH-461"></front>
<front id="ConfigurationH-462">  // Enable this to sample the bed in a grid (least squares solution).</front>
<front id="ConfigurationH-463">  // Note: this feature generates 10KB extra code size.</front>
<front id="ConfigurationH-464">  #define AUTO_BED_LEVELING_GRID</front>
<front id="ConfigurationH-465"></front>
<front id="ConfigurationH-466">  #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="ConfigurationH-467"></front>
<front id="ConfigurationH-468">    #define LEFT_PROBE_BED_POSITION 15</front>
<front id="ConfigurationH-469">    #define RIGHT_PROBE_BED_POSITION 170</front>
<front id="ConfigurationH-470">    #define FRONT_PROBE_BED_POSITION 20</front>
<front id="ConfigurationH-471">    #define BACK_PROBE_BED_POSITION 170</front>
<front id="ConfigurationH-472"></front>
<front id="ConfigurationH-473">    #define MIN_PROBE_EDGE 10 // The Z probe minimum square sides can be no smaller than this.</front>
<front id="ConfigurationH-474"></front>
<front id="ConfigurationH-475">    // Set the number of grid points per dimension.</front>
<front id="ConfigurationH-476">    // You probably don't need more than 3 (squared=9).</front>
<front id="ConfigurationH-477">    #define AUTO_BED_LEVELING_GRID_POINTS 2</front>
<front id="ConfigurationH-478"></front>
<front id="ConfigurationH-479">  #else  // !AUTO_BED_LEVELING_GRID</front>
<front id="ConfigurationH-480"></front>
<front id="ConfigurationH-481">      // Arbitrary points to probe.</front>
<front id="ConfigurationH-482">      // A simple cross-product is used to estimate the plane of the bed.</front>
<front id="ConfigurationH-483">      #define ABL_PROBE_PT_1_X 15</front>
<front id="ConfigurationH-484">      #define ABL_PROBE_PT_1_Y 180</front>
<front id="ConfigurationH-485">      #define ABL_PROBE_PT_2_X 15</front>
<front id="ConfigurationH-486">      #define ABL_PROBE_PT_2_Y 20</front>
<front id="ConfigurationH-487">      #define ABL_PROBE_PT_3_X 170</front>
<front id="ConfigurationH-488">      #define ABL_PROBE_PT_3_Y 20</front>
<front id="ConfigurationH-489"></front>
<front id="ConfigurationH-490">  #endif // AUTO_BED_LEVELING_GRID</front>
<front id="ConfigurationH-491"></front>
<front id="ConfigurationH-492">  // Offsets to the Z probe relative to the nozzle tip.</front>
<front id="ConfigurationH-493">  // X and Y offsets must be integers.</front>
<front id="ConfigurationH-494">  #define X_PROBE_OFFSET_FROM_EXTRUDER -25     // Z probe to nozzle X offset: -left  +right</front>
<front id="ConfigurationH-495">  #define Y_PROBE_OFFSET_FROM_EXTRUDER -29     // Z probe to nozzle Y offset: -front +behind</front>
<front id="ConfigurationH-496">  #define Z_PROBE_OFFSET_FROM_EXTRUDER -12.35  // Z probe to nozzle Z offset: -below (always!)</front>
<front id="ConfigurationH-497"></front>
<front id="ConfigurationH-498">  #define Z_RAISE_BEFORE_HOMING 4       // (in mm) Raise Z axis before homing (G28) for Z probe clearance.</front>
<front id="ConfigurationH-499">                                        // Be sure you have this distance over your Z_MAX_POS in case.</front>
<front id="ConfigurationH-500"></front>
<front id="ConfigurationH-501">  #define XY_TRAVEL_SPEED 8000         // X and Y axis travel speed between probes, in mm/min.</front>
<front id="ConfigurationH-502"></front>
<front id="ConfigurationH-503">  #define Z_RAISE_BEFORE_PROBING 15   // How much the Z axis will be raised before traveling to the first probing point.</front>
<front id="ConfigurationH-504">  #define Z_RAISE_BETWEEN_PROBINGS 5  // How much the Z axis will be raised when traveling from between next probing points.</front>
<front id="ConfigurationH-505">  #define Z_RAISE_AFTER_PROBING 15    // How much the Z axis will be raised after the last probing point.</front>
<front id="ConfigurationH-506"></front>
<front id="ConfigurationH-507">//   #define Z_PROBE_END_SCRIPT "G1 Z10 F12000\nG1 X15 Y330\nG1 Z0.5\nG1 Z10" // These commands will be executed in the end of G29 routine.</front>
<front id="ConfigurationH-508">                                                                            // Useful to retract a deployable Z probe.</front>
<front id="ConfigurationH-509"></front>
<front id="ConfigurationH-510">  //#define Z_PROBE_SLED // Turn on if you have a Z probe mounted on a sled like those designed by Charles Bell.</front>
<front id="ConfigurationH-511">  //#define SLED_DOCKING_OFFSET 5 // The extra distance the X axis must travel to pickup the sled. 0 should be fine but you can push it further if you'd like.</front>
<front id="ConfigurationH-512"></front>
<front id="ConfigurationH-513"></front>
<front id="ConfigurationH-514">  //If you have enabled the Bed Auto Leveling and are using the same Z Probe for Z Homing,</front>
<front id="ConfigurationH-515">  //it is highly recommended you let this Z_SAFE_HOMING enabled!!!</front>
<front id="ConfigurationH-516"></front>
<front id="ConfigurationH-517">  #define Z_SAFE_HOMING   // This feature is meant to avoid Z homing with Z probe outside the bed area.</front>
<front id="ConfigurationH-518">                          // When defined, it will:</front>
<front id="ConfigurationH-519">                          // - Allow Z homing only after X and Y homing AND stepper drivers still enabled.</front>
<front id="ConfigurationH-520">                          // - If stepper drivers timeout, it will need X and Y homing again before Z homing.</front>
<front id="ConfigurationH-521">                          // - Position the Z probe in a defined XY point before Z Homing when homing all axis (G28).</front>
<front id="ConfigurationH-522">                          // - Block Z homing only when the Z probe is outside bed area.</front>
<front id="ConfigurationH-523"></front>
<front id="ConfigurationH-524">  #if ENABLED(Z_SAFE_HOMING)</front>
<front id="ConfigurationH-525"></front>
<front id="ConfigurationH-526">    #define Z_SAFE_HOMING_X_POINT ((X_MIN_POS + X_MAX_POS) / 2)    // X point for Z homing when homing all axis (G28).</front>
<front id="ConfigurationH-527">    #define Z_SAFE_HOMING_Y_POINT ((Y_MIN_POS + Y_MAX_POS) / 2)    // Y point for Z homing when homing all axis (G28).</front>
<front id="ConfigurationH-528"></front>
<front id="ConfigurationH-529">  #endif</front>
<front id="ConfigurationH-530"></front>
<front id="ConfigurationH-531">  // Support for a dedicated Z probe endstop separate from the Z min endstop.</front>
<front id="ConfigurationH-532">  // If you would like to use both a Z probe and a Z min endstop together,</front>
<front id="ConfigurationH-533">  // uncomment #define Z_MIN_PROBE_ENDSTOP and read the instructions below.</front>
<front id="ConfigurationH-534">  // If you still want to use the Z min endstop for homing, disable Z_SAFE_HOMING above.</front>
<front id="ConfigurationH-535">  // Example: To park the head outside the bed area when homing with G28.</front>
<front id="ConfigurationH-536">  //</front>
<front id="ConfigurationH-537">  // WARNING:</front>
<front id="ConfigurationH-538">  // The Z min endstop will need to set properly as it would without a Z probe</front>
<front id="ConfigurationH-539">  // to prevent head crashes and premature stopping during a print.</front>
<front id="ConfigurationH-540">  //</front>
<front id="ConfigurationH-541">  // To use a separate Z probe endstop, you must have a Z_MIN_PROBE_PIN</front>
<front id="ConfigurationH-542">  // defined in the pins_XXXXX.h file for your control board.</front>
<front id="ConfigurationH-543">  // If you are using a servo based Z probe, you will need to enable NUM_SERVOS,</front>
<front id="ConfigurationH-544">  // Z_ENDSTOP_SERVO_NR and SERVO_ENDSTOP_ANGLES in the R/C SERVO support below.</front>
<front id="ConfigurationH-545">  // RAMPS 1.3/1.4 boards may be able to use the 5V, Ground and the D32 pin</front>
<front id="ConfigurationH-546">  // in the Aux 4 section of the RAMPS board. Use 5V for powered sensors,</front>
<front id="ConfigurationH-547">  // otherwise connect to ground and D32 for normally closed configuration</front>
<front id="ConfigurationH-548">  // and 5V and D32 for normally open configurations.</front>
<front id="ConfigurationH-549">  // Normally closed configuration is advised and assumed.</front>
<front id="ConfigurationH-550">  // The D32 pin in Aux 4 on RAMPS maps to the Arduino D32 pin.</front>
<front id="ConfigurationH-551">  // Z_MIN_PROBE_PIN is setting the pin to use on the Arduino.</front>
<front id="ConfigurationH-552">  // Since the D32 pin on the RAMPS maps to D32 on Arduino, this works.</front>
<front id="ConfigurationH-553">  // D32 is currently selected in the RAMPS 1.3/1.4 pin file.</front>
<front id="ConfigurationH-554">  // All other boards will need changes to the respective pins_XXXXX.h file.</front>
<front id="ConfigurationH-555">  //</front>
<front id="ConfigurationH-556">  // WARNING:</front>
<front id="ConfigurationH-557">  // Setting the wrong pin may have unexpected and potentially disastrous outcomes.</front>
<front id="ConfigurationH-558">  // Use with caution and do your homework.</front>
<front id="ConfigurationH-559">  //</front>
<front id="ConfigurationH-560">  //#define Z_MIN_PROBE_ENDSTOP</front>
<front id="ConfigurationH-561"></front>
<front id="ConfigurationH-562">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="ConfigurationH-563"></front>
<front id="ConfigurationH-564"></front>
<front id="ConfigurationH-565">// @section homing</front>
<front id="ConfigurationH-566"></front>
<front id="ConfigurationH-567">// The position of the homing switches</front>
<front id="ConfigurationH-568">//#define MANUAL_HOME_POSITIONS  // If defined, MANUAL_*_HOME_POS below will be used</front>
<front id="ConfigurationH-569">//#define BED_CENTER_AT_0_0  // If defined, the center of the bed is at (X=0, Y=0)</front>
<front id="ConfigurationH-570"></front>
<front id="ConfigurationH-571">// Manual homing switch locations:</front>
<front id="ConfigurationH-572">// For deltabots this means top and center of the Cartesian print volume.</front>
<front id="ConfigurationH-573">#if ENABLED(MANUAL_HOME_POSITIONS)</front>
<front id="ConfigurationH-574">  #define MANUAL_X_HOME_POS 0</front>
<front id="ConfigurationH-575">  #define MANUAL_Y_HOME_POS 0</front>
<front id="ConfigurationH-576">  #define MANUAL_Z_HOME_POS 0</front>
<front id="ConfigurationH-577">  //#define MANUAL_Z_HOME_POS 402 // For delta: Distance between nozzle and print surface after homing.</front>
<front id="ConfigurationH-578">#endif</front>
<front id="ConfigurationH-579"></front>
<front id="ConfigurationH-580">// @section movement</front>
<front id="ConfigurationH-581"></front>
<front id="ConfigurationH-582">/**</front>
<front id="ConfigurationH-583"> * MOVEMENT SETTINGS</front>
<front id="ConfigurationH-584"> */</front>
<front id="ConfigurationH-585"></front>
<front id="ConfigurationH-586">#define HOMING_FEEDRATE {50*60, 50*60, 4*60, 0}  // set the homing speeds (mm/min)</front>
<front id="ConfigurationH-587"></front>
<front id="ConfigurationH-588">// default settings</front>
<front id="ConfigurationH-589"></front>
<front id="ConfigurationH-590">#define DEFAULT_AXIS_STEPS_PER_UNIT   {80,80,4000,500}  // default steps per unit for Ultimaker</front>
<front id="ConfigurationH-591">#define DEFAULT_MAX_FEEDRATE          {300, 300, 5, 25}    // (mm/sec)</front>
<front id="ConfigurationH-592">#define DEFAULT_MAX_ACCELERATION      {3000,3000,100,10000}    // X, Y, Z, E maximum start speed for accelerated moves. E default values are good for Skeinforge 40+, for older versions raise them a lot.</front>
<front id="ConfigurationH-593"></front>
<front id="ConfigurationH-594">#define DEFAULT_ACCELERATION          3000    // X, Y, Z and E acceleration in mm/s^2 for printing moves</front>
<front id="ConfigurationH-595">#define DEFAULT_RETRACT_ACCELERATION  3000    // E acceleration in mm/s^2 for retracts</front>
<front id="ConfigurationH-596">#define DEFAULT_TRAVEL_ACCELERATION   3000    // X, Y, Z acceleration in mm/s^2 for travel (non printing) moves</front>
<front id="ConfigurationH-597"></front>
<front id="ConfigurationH-598">// The speed change that does not require acceleration (i.e. the software might assume it can be done instantaneously)</front>
<front id="ConfigurationH-599">#define DEFAULT_XYJERK                20.0    // (mm/sec)</front>
<front id="ConfigurationH-600">#define DEFAULT_ZJERK                 0.4     // (mm/sec)</front>
<front id="ConfigurationH-601">#define DEFAULT_EJERK                 5.0    // (mm/sec)</front>
<front id="ConfigurationH-602"></front>
<front id="ConfigurationH-603">//===========================================================================</front>
<front id="ConfigurationH-604">//============================== Resume From Z ==============================</front>
<front id="ConfigurationH-605">//===========================================================================</front>
<front id="ConfigurationH-606"></front>
<front id="ConfigurationH-607">//This feature allows you to resume a failed print from given Z height.</front>
<front id="ConfigurationH-608">//It parses through the gcode until it passes the given Z threshold height</front>
<front id="ConfigurationH-609">//(either from the current location when selecting Menu &gt; Resume SD from Z &gt; file.gcode or just M19; or with M19 Z(some number here)),</front>
<front id="ConfigurationH-610">//it also compensates for z-lifts around the given threshold.</front>
<front id="ConfigurationH-611"></front>
<front id="ConfigurationH-612">//#define RESUME_FEATURE</front>
<front id="ConfigurationH-613"></front>
<front id="ConfigurationH-614">//===========================================================================</front>
<front id="ConfigurationH-615">//============================== Layer Tracking =============================</front>
<front id="ConfigurationH-616">//===========================================================================</front>
<front id="ConfigurationH-617"></front>
<front id="ConfigurationH-618">//This feature keeps track of the current layer, accounting for Z lifts and multiple objects</front>
<front id="ConfigurationH-619">//The current layer number can be found in Menu &gt; Tune &gt; Layer whilst printing from an LCD controller (via SD) or by sending M114 (SD or not).</front>
<front id="ConfigurationH-620"></front>
<front id="ConfigurationH-621">//#define TRACK_LAYER</front>
<front id="ConfigurationH-622"></front>
<front id="ConfigurationH-623">//=============================================================================</front>
<front id="ConfigurationH-624">//============================= Additional Features ===========================</front>
<front id="ConfigurationH-625">//=============================================================================</front>
<front id="ConfigurationH-626"></front>
<front id="ConfigurationH-627">// @section more</front>
<front id="ConfigurationH-628"></front>
<front id="ConfigurationH-629">// Custom M code points</front>
<front id="ConfigurationH-630">#define CUSTOM_M_CODES</front>
<front id="ConfigurationH-631">#if ENABLED(CUSTOM_M_CODES)</front>
<front id="ConfigurationH-632">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ConfigurationH-633">    #define CUSTOM_M_CODE_SET_Z_PROBE_OFFSET 851</front>
<front id="ConfigurationH-634">    #define Z_PROBE_OFFSET_RANGE_MIN -20</front>
<front id="ConfigurationH-635">    #define Z_PROBE_OFFSET_RANGE_MAX 20</front>
<front id="ConfigurationH-636">  #endif</front>
<front id="ConfigurationH-637">#endif</front>
<front id="ConfigurationH-638"></front>
<front id="ConfigurationH-639">// @section extras</front>
<front id="ConfigurationH-640"></front>
<front id="ConfigurationH-641">// EEPROM</front>
<front id="ConfigurationH-642">// The microcontroller can store settings in the EEPROM, e.g. max velocity...</front>
<front id="ConfigurationH-643">// M500 - stores parameters in EEPROM</front>
<front id="ConfigurationH-644">// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).</front>
<front id="ConfigurationH-645">// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.</front>
<front id="ConfigurationH-646">//define this to enable EEPROM support</front>
<front id="ConfigurationH-647">//#define EEPROM_SETTINGS</front>
<front id="ConfigurationH-648"></front>
<front id="ConfigurationH-649">#if ENABLED(EEPROM_SETTINGS)</front>
<front id="ConfigurationH-650">  // To disable EEPROM Serial responses and decrease program space by ~1700 byte: comment this out:</front>
<front id="ConfigurationH-651">  #define EEPROM_CHITCHAT // Please keep turned on if you can.</front>
<front id="ConfigurationH-652">#endif</front>
<front id="ConfigurationH-653"></front>
<front id="ConfigurationH-654">//</front>
<front id="ConfigurationH-655">// M100 Free Memory Watcher</front>
<front id="ConfigurationH-656">//</front>
<front id="ConfigurationH-657">//#define M100_FREE_MEMORY_WATCHER // uncomment to add the M100 Free Memory Watcher for debug purpose</front>
<front id="ConfigurationH-658"></front>
<front id="ConfigurationH-659">// @section temperature</front>
<front id="ConfigurationH-660"></front>
<front id="ConfigurationH-661">// Preheat Constants</front>
<front id="ConfigurationH-662">#define PLA_PREHEAT_HOTEND_TEMP 180</front>
<front id="ConfigurationH-663">#define PLA_PREHEAT_HPB_TEMP 70</front>
<front id="ConfigurationH-664">#define PLA_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255</front>
<front id="ConfigurationH-665"></front>
<front id="ConfigurationH-666">#define ABS_PREHEAT_HOTEND_TEMP 240</front>
<front id="ConfigurationH-667">#define ABS_PREHEAT_HPB_TEMP 110</front>
<front id="ConfigurationH-668">#define ABS_PREHEAT_FAN_SPEED 0   // Insert Value between 0 and 255</front>
<front id="ConfigurationH-669"></front>
<front id="ConfigurationH-670">//==============================LCD and SD support=============================</front>
<front id="ConfigurationH-671">// @section lcd</front>
<front id="ConfigurationH-672"></front>
<front id="ConfigurationH-673">// Define your display language below. Replace (en) with your language code and uncomment.</front>
<front id="ConfigurationH-674">// en, pl, fr, de, es, ru, bg, it, pt, pt-br, fi, an, nl, ca, eu, kana, kana_utf8, cn, test</front>
<front id="ConfigurationH-675">// See also language.h</front>
<front id="ConfigurationH-676">#define LANGUAGE_INCLUDE GENERATE_LANGUAGE_INCLUDE(en)</front>
<front id="ConfigurationH-677"></front>
<front id="ConfigurationH-678">// Choose ONE of these 3 charsets. This has to match your hardware. Ignored for full graphic display.</front>
<front id="ConfigurationH-679">// To find out what type you have - compile with (test) - upload - click to get the menu. You'll see two typical lines from the upper half of the charset.</front>
<front id="ConfigurationH-680">// See also documentation/LCDLanguageFont.md</front>
<front id="ConfigurationH-681">  #define DISPLAY_CHARSET_HD44780_JAPAN        // this is the most common hardware</front>
<front id="ConfigurationH-682">  //#define DISPLAY_CHARSET_HD44780_WESTERN</front>
<front id="ConfigurationH-683">  //#define DISPLAY_CHARSET_HD44780_CYRILLIC</front>
<front id="ConfigurationH-684"></front>
<front id="ConfigurationH-685">//#define ULTRA_LCD  //general LCD support, also 16x2</front>
<front id="ConfigurationH-686">//#define DOGLCD  // Support for SPI LCD 128x64 (Controller ST7565R graphic Display Family)</front>
<front id="ConfigurationH-687">//#define SDSUPPORT // Enable SD Card Support in Hardware Console</front>
<front id="ConfigurationH-688">//#define SDSLOW // Use slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)</front>
<front id="ConfigurationH-689">//#define SDEXTRASLOW // Use even slower SD transfer mode (not normally needed - uncomment if you're getting volume init error)</front>
<front id="ConfigurationH-690">//#define SD_CHECK_AND_RETRY // Use CRC checks and retries on the SD communication</front>
<front id="ConfigurationH-691">//#define ENCODER_PULSES_PER_STEP 1 // Increase if you have a high resolution encoder</front>
<front id="ConfigurationH-692">//#define ENCODER_STEPS_PER_MENU_ITEM 5 // Set according to ENCODER_PULSES_PER_STEP or your liking</front>
<front id="ConfigurationH-693">//#define ULTIMAKERCONTROLLER //as available from the Ultimaker online store.</front>
<front id="ConfigurationH-694">//#define ULTIPANEL  //the UltiPanel as on Thingiverse</front>
<front id="ConfigurationH-695">//#define SPEAKER // The sound device is a speaker - not a buzzer. A buzzer resonates with his own frequency.</front>
<front id="ConfigurationH-696">//#define LCD_FEEDBACK_FREQUENCY_DURATION_MS 100 // the duration the buzzer plays the UI feedback sound. ie Screen Click</front>
<front id="ConfigurationH-697">//#define LCD_FEEDBACK_FREQUENCY_HZ 1000         // this is the tone frequency the buzzer plays when on UI feedback. ie Screen Click</front>
<front id="ConfigurationH-698">                                                 // 0 to disable buzzer feedback. Test with M300 S&lt;frequency Hz&gt; P&lt;duration ms&gt;</front>
<front id="ConfigurationH-699">// PanelOne from T3P3 (via RAMPS 1.4 AUX2/AUX3)</front>
<front id="ConfigurationH-700">// http://reprap.org/wiki/PanelOne</front>
<front id="ConfigurationH-701">//#define PANEL_ONE</front>
<front id="ConfigurationH-702"></front>
<front id="ConfigurationH-703">// The MaKr3d Makr-Panel with graphic controller and SD support</front>
<front id="ConfigurationH-704">// http://reprap.org/wiki/MaKr3d_MaKrPanel</front>
<front id="ConfigurationH-705">//#define MAKRPANEL</front>
<front id="ConfigurationH-706"></front>
<front id="ConfigurationH-707">// The Panucatt Devices Viki 2.0 and mini Viki with Graphic LCD</front>
<front id="ConfigurationH-708">// http://panucatt.com</front>
<front id="ConfigurationH-709">// ==&gt; REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib</front>
<front id="ConfigurationH-710">//#define VIKI2</front>
<front id="ConfigurationH-711">//#define miniVIKI</front>
<front id="ConfigurationH-712"></front>
<front id="ConfigurationH-713">// This is a new controller currently under development.  https://github.com/eboston/Adafruit-ST7565-Full-Graphic-Controller/</front>
<front id="ConfigurationH-714">//</front>
<front id="ConfigurationH-715">// ==&gt; REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib</front>
<front id="ConfigurationH-716">//#define ELB_FULL_GRAPHIC_CONTROLLER</front>
<front id="ConfigurationH-717">//#define SD_DETECT_INVERTED</front>
<front id="ConfigurationH-718"></front>
<front id="ConfigurationH-719">// The RepRapDiscount Smart Controller (white PCB)</front>
<front id="ConfigurationH-720">// http://reprap.org/wiki/RepRapDiscount_Smart_Controller</front>
<front id="ConfigurationH-721">//#define REPRAP_DISCOUNT_SMART_CONTROLLER</front>
<front id="ConfigurationH-722"></front>
<front id="ConfigurationH-723">// The GADGETS3D G3D LCD/SD Controller (blue PCB)</front>
<front id="ConfigurationH-724">// http://reprap.org/wiki/RAMPS_1.3/1.4_GADGETS3D_Shield_with_Panel</front>
<front id="ConfigurationH-725">//#define G3D_PANEL</front>
<front id="ConfigurationH-726"></front>
<front id="ConfigurationH-727">// The RepRapDiscount FULL GRAPHIC Smart Controller (quadratic white PCB)</front>
<front id="ConfigurationH-728">// http://reprap.org/wiki/RepRapDiscount_Full_Graphic_Smart_Controller</front>
<front id="ConfigurationH-729">//</front>
<front id="ConfigurationH-730">// ==&gt; REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib</front>
<front id="ConfigurationH-731">//#define REPRAP_DISCOUNT_FULL_GRAPHIC_SMART_CONTROLLER</front>
<front id="ConfigurationH-732"></front>
<front id="ConfigurationH-733">// The RepRapWorld REPRAPWORLD_KEYPAD v1.1</front>
<front id="ConfigurationH-734">// http://reprapworld.com/?products_details&products_id=202&cPath=1591_1626</front>
<front id="ConfigurationH-735">//#define REPRAPWORLD_KEYPAD</front>
<front id="ConfigurationH-736">//#define REPRAPWORLD_KEYPAD_MOVE_STEP 10.0 // how much should be moved when a key is pressed, eg 10.0 means 10mm per click</front>
<front id="ConfigurationH-737"></front>
<front id="ConfigurationH-738">// The Elefu RA Board Control Panel</front>
<front id="ConfigurationH-739">// http://www.elefu.com/index.php?route=product/product&product_id=53</front>
<front id="ConfigurationH-740">// REMEMBER TO INSTALL LiquidCrystal_I2C.h in your ARDUINO library folder: https://github.com/kiyoshigawa/LiquidCrystal_I2C</front>
<front id="ConfigurationH-741">//#define RA_CONTROL_PANEL</front>
<front id="ConfigurationH-742"></front>
<front id="ConfigurationH-743">// The MakerLab Mini Panel with graphic controller and SD support</front>
<front id="ConfigurationH-744">// http://reprap.org/wiki/Mini_panel</front>
<front id="ConfigurationH-745">// #define MINIPANEL</front>
<front id="ConfigurationH-746"></front>
<front id="ConfigurationH-747">/**</front>
<front id="ConfigurationH-748"> * I2C Panels</front>
<front id="ConfigurationH-749"> */</front>
<front id="ConfigurationH-750"></front>
<front id="ConfigurationH-751">//#define LCD_I2C_SAINSMART_YWROBOT</front>
<front id="ConfigurationH-752"></front>
<front id="ConfigurationH-753">// PANELOLU2 LCD with status LEDs, separate encoder and click inputs</front>
<front id="ConfigurationH-754">//</front>
<front id="ConfigurationH-755">// This uses the LiquidTWI2 library v1.2.3 or later ( https://github.com/lincomatic/LiquidTWI2 )</front>
<front id="ConfigurationH-756">// Make sure the LiquidTWI2 directory is placed in the Arduino or Sketchbook libraries subdirectory.</front>
<front id="ConfigurationH-757">// (v1.2.3 no longer requires you to define PANELOLU in the LiquidTWI2.h library header file)</front>
<front id="ConfigurationH-758">// Note: The PANELOLU2 encoder click input can either be directly connected to a pin</front>
<front id="ConfigurationH-759">//       (if BTN_ENC defined to != -1) or read through I2C (when BTN_ENC == -1).</front>
<front id="ConfigurationH-760">//#define LCD_I2C_PANELOLU2</front>
<front id="ConfigurationH-761"></front>
<front id="ConfigurationH-762">// Panucatt VIKI LCD with status LEDs, integrated click & L/R/U/P buttons, separate encoder inputs</front>
<front id="ConfigurationH-763">//#define LCD_I2C_VIKI</front>
<front id="ConfigurationH-764">  </front>
<front id="ConfigurationH-765">// SSD1306 OLED generic display support</front>
<front id="ConfigurationH-766">// ==&gt; REMEMBER TO INSTALL U8glib to your ARDUINO library folder: http://code.google.com/p/u8glib/wiki/u8glib</front>
<front id="ConfigurationH-767">//#define U8GLIB_SSD1306</front>
<front id="ConfigurationH-768"></front>
<front id="ConfigurationH-769">// Shift register panels</front>
<front id="ConfigurationH-770">// ---------------------</front>
<front id="ConfigurationH-771">// 2 wire Non-latching LCD SR from:</front>
<front id="ConfigurationH-772">// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection</front>
<front id="ConfigurationH-773">// LCD configuration: http://reprap.org/wiki/SAV_3D_LCD</front>
<front id="ConfigurationH-774">//#define SAV_3DLCD</front>
<front id="ConfigurationH-775"></front>
<front id="ConfigurationH-776">// @section extras</front>
<front id="ConfigurationH-777"></front>
<front id="ConfigurationH-778">// Increase the FAN pwm frequency. Removes the PWM noise but increases heating in the FET/Arduino</front>
<front id="ConfigurationH-779">//#define FAST_PWM_FAN</front>
<front id="ConfigurationH-780"></front>
<front id="ConfigurationH-781">// Use software PWM to drive the fan, as for the heaters. This uses a very low frequency</front>
<front id="ConfigurationH-782">// which is not as annoying as with the hardware PWM. On the other hand, if this frequency</front>
<front id="ConfigurationH-783">// is too low, you should also increment SOFT_PWM_SCALE.</front>
<front id="ConfigurationH-784">//#define FAN_SOFT_PWM</front>
<front id="ConfigurationH-785"></front>
<front id="ConfigurationH-786">// Incrementing this by 1 will double the software PWM frequency,</front>
<front id="ConfigurationH-787">// affecting heaters, and the fan if FAN_SOFT_PWM is enabled.</front>
<front id="ConfigurationH-788">// However, control resolution will be halved for each increment;</front>
<front id="ConfigurationH-789">// at zero value, there are 128 effective control positions.</front>
<front id="ConfigurationH-790">#define SOFT_PWM_SCALE 0</front>
<front id="ConfigurationH-791"></front>
<front id="ConfigurationH-792">// Temperature status LEDs that display the hotend and bet temperature.</front>
<front id="ConfigurationH-793">// If all hotends and bed temperature and temperature setpoint are &lt; 54C then the BLUE led is on.</front>
<front id="ConfigurationH-794">// Otherwise the RED led is on. There is 1C hysteresis.</front>
<front id="ConfigurationH-795">//#define TEMP_STAT_LEDS</front>
<front id="ConfigurationH-796"></front>
<front id="ConfigurationH-797">// M240  Triggers a camera by emulating a Canon RC-1 Remote</front>
<front id="ConfigurationH-798">// Data from: http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="ConfigurationH-799">// #define PHOTOGRAPH_PIN     23</front>
<front id="ConfigurationH-800"></front>
<front id="ConfigurationH-801">// SkeinForge sends the wrong arc g-codes when using Arc Point as fillet procedure</front>
<front id="ConfigurationH-802">//#define SF_ARC_FIX</front>
<front id="ConfigurationH-803"></front>
<front id="ConfigurationH-804">// Support for the BariCUDA Paste Extruder.</front>
<front id="ConfigurationH-805">//#define BARICUDA</front>
<front id="ConfigurationH-806"></front>
<front id="ConfigurationH-807">//define BlinkM/CyzRgb Support</front>
<front id="ConfigurationH-808">//#define BLINKM</front>
<front id="ConfigurationH-809"></front>
<front id="ConfigurationH-810">/*********************************************************************\</front>
<front id="ConfigurationH-811">* R/C SERVO support</front>
<front id="ConfigurationH-812">* Sponsored by TrinityLabs, Reworked by codexmas</front>
<front id="ConfigurationH-813">**********************************************************************/</front>
<front id="ConfigurationH-814"></front>
<front id="ConfigurationH-815">// Number of servos</front>
<front id="ConfigurationH-816">//</front>
<front id="ConfigurationH-817">// If you select a configuration below, this will receive a default value and does not need to be set manually</front>
<front id="ConfigurationH-818">// set it manually if you have more servos than extruders and wish to manually control some</front>
<front id="ConfigurationH-819">// leaving it undefined or defining as 0 will disable the servo subsystem</front>
<front id="ConfigurationH-820">// If unsure, leave commented / disabled</front>
<front id="ConfigurationH-821">//</front>
<front id="ConfigurationH-822">//#define NUM_SERVOS 3 // Servo index starts with 0 for M280 command</front>
<front id="ConfigurationH-823"></front>
<front id="ConfigurationH-824">// Servo Endstops</front>
<front id="ConfigurationH-825">//</front>
<front id="ConfigurationH-826">// This allows for servo actuated endstops, primary usage is for the Z Axis to eliminate calibration or bed height changes.</front>
<front id="ConfigurationH-827">// Use M851 to set the Z probe vertical offset from the nozzle. Store that setting with M500.</front>
<front id="ConfigurationH-828">//</front>
<front id="ConfigurationH-829">//#define X_ENDSTOP_SERVO_NR 1</front>
<front id="ConfigurationH-830">//#define Y_ENDSTOP_SERVO_NR 2</front>
<front id="ConfigurationH-831">//#define Z_ENDSTOP_SERVO_NR 0</front>
<front id="ConfigurationH-832">//#define SERVO_ENDSTOP_ANGLES {{0,0}, {0,0}, {70,0}} // X,Y,Z Axis Extend and Retract angles</front>
<front id="ConfigurationH-833"></front>
<front id="ConfigurationH-834">// Servo deactivation</front>
<front id="ConfigurationH-835">//</front>
<front id="ConfigurationH-836">// With this option servos are powered only during movement, then turned off to prevent jitter.</front>
<front id="ConfigurationH-837">//#define DEACTIVATE_SERVOS_AFTER_MOVE</front>
<front id="ConfigurationH-838"></front>
<front id="ConfigurationH-839">#if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)</front>
<front id="ConfigurationH-840">  // Delay (in microseconds) before turning the servo off. This depends on the servo speed.</front>
<front id="ConfigurationH-841">  // 300ms is a good value but you can try less delay.</front>
<front id="ConfigurationH-842">  // If the servo can't reach the requested position, increase it.</front>
<front id="ConfigurationH-843">  #define SERVO_DEACTIVATION_DELAY 300</front>
<front id="ConfigurationH-844">#endif</front>
<front id="ConfigurationH-845"></front>
<front id="ConfigurationH-846">/**********************************************************************\</front>
<front id="ConfigurationH-847"> * Support for a filament diameter sensor</front>
<front id="ConfigurationH-848"> * Also allows adjustment of diameter at print time (vs  at slicing)</front>
<front id="ConfigurationH-849"> * Single extruder only at this point (extruder 0)</front>
<front id="ConfigurationH-850"> *</front>
<front id="ConfigurationH-851"> * Motherboards</front>
<front id="ConfigurationH-852"> * 34 - RAMPS1.4 - uses Analog input 5 on the AUX2 connector</front>
<front id="ConfigurationH-853"> * 81 - Printrboard - Uses Analog input 2 on the Exp1 connector (version B,C,D,E)</front>
<front id="ConfigurationH-854"> * 301 - Rambo  - uses Analog input 3</front>
<front id="ConfigurationH-855"> * Note may require analog pins to be defined for different motherboards</front>
<front id="ConfigurationH-856"> **********************************************************************/</front>
<front id="ConfigurationH-857">// Uncomment below to enable</front>
<front id="ConfigurationH-858">//#define FILAMENT_SENSOR</front>
<front id="ConfigurationH-859"></front>
<front id="ConfigurationH-860">#define FILAMENT_SENSOR_EXTRUDER_NUM 0   //The number of the extruder that has the filament sensor (0,1,2)</front>
<front id="ConfigurationH-861">#define MEASUREMENT_DELAY_CM        14   //measurement delay in cm.  This is the distance from filament sensor to middle of barrel</front>
<front id="ConfigurationH-862"></front>
<front id="ConfigurationH-863">#define DEFAULT_NOMINAL_FILAMENT_DIA 3.00  //Enter the diameter (in mm) of the filament generally used (3.0 mm or 1.75 mm) - this is then used in the slicer software.  Used for sensor reading validation</front>
<front id="ConfigurationH-864">#define MEASURED_UPPER_LIMIT         3.30  //upper limit factor used for sensor reading validation in mm</front>
<front id="ConfigurationH-865">#define MEASURED_LOWER_LIMIT         1.90  //lower limit factor for sensor reading validation in mm</front>
<front id="ConfigurationH-866">#define MAX_MEASUREMENT_DELAY       20     //delay buffer size in bytes (1 byte = 1cm)- limits maximum measurement delay allowable (must be larger than MEASUREMENT_DELAY_CM  and lower number saves RAM)</front>
<front id="ConfigurationH-867"></front>
<front id="ConfigurationH-868">//defines used in the code</front>
<front id="ConfigurationH-869">#define DEFAULT_MEASURED_FILAMENT_DIA  DEFAULT_NOMINAL_FILAMENT_DIA  //set measured to nominal initially</front>
<front id="ConfigurationH-870"></front>
<front id="ConfigurationH-871">//When using an LCD, uncomment the line below to display the Filament sensor data on the last line instead of status.  Status will appear for 5 sec.</front>
<front id="ConfigurationH-872">//#define FILAMENT_LCD_DISPLAY</front>
<front id="ConfigurationH-873"></front>
<front id="ConfigurationH-874"></front>
<front id="ConfigurationH-875"></front>
<front id="ConfigurationH-876"></front>
<front id="ConfigurationH-877"></front>
<front id="ConfigurationH-878"></front>
<front id="ConfigurationH-879">#include "Configuration_adv.h"</front>
<front id="ConfigurationH-880">#include "thermistortables.h"</front>
<front id="ConfigurationH-881"></front>
<front id="ConfigurationH-882">#endif //CONFIGURATION_H</front>
 </pre>
<h1 id="Configuration_advHtitle" >Configuration_adv.h</h1>
<pre id="Configuration_advH"  class="prettyprint linenums"><front id="Configuration_advH-1">#ifndef CONFIGURATION_ADV_H</front>
<front id="Configuration_advH-2">#define CONFIGURATION_ADV_H</front>
<front id="Configuration_advH-3"></front>
<front id="Configuration_advH-4">#include "Conditionals.h"</front>
<front id="Configuration_advH-5"></front>
<front id="Configuration_advH-6">// @section temperature</front>
<front id="Configuration_advH-7"></front>
<front id="Configuration_advH-8">//===========================================================================</front>
<front id="Configuration_advH-9">//=============================Thermal Settings  ============================</front>
<front id="Configuration_advH-10">//===========================================================================</front>
<front id="Configuration_advH-11"></front>
<front id="Configuration_advH-12">#if ENABLED(BED_LIMIT_SWITCHING)</front>
<front id="Configuration_advH-13">  #define BED_HYSTERESIS 2 //only disable heating if T&gt;target+BED_HYSTERESIS and enable heating if T&gt;target-BED_HYSTERESIS</front>
<front id="Configuration_advH-14">#endif</front>
<front id="Configuration_advH-15">#define BED_CHECK_INTERVAL 5000 //ms between checks in bang-bang control</front>
<front id="Configuration_advH-16"></front>
<front id="Configuration_advH-17">/**</front>
<front id="Configuration_advH-18"> * Thermal Protection parameters</front>
<front id="Configuration_advH-19"> */</front>
<front id="Configuration_advH-20">#if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="Configuration_advH-21">  #define THERMAL_PROTECTION_PERIOD 40        // Seconds</front>
<front id="Configuration_advH-22">  #define THERMAL_PROTECTION_HYSTERESIS 4     // Degrees Celsius</front>
<front id="Configuration_advH-23"></front>
<front id="Configuration_advH-24">  /**</front>
<front id="Configuration_advH-25">   * Whenever an M104 or M109 increases the target temperature the firmware will wait for the</front>
<front id="Configuration_advH-26">   * WATCH_TEMP_PERIOD to expire, and if the temperature hasn't increased by WATCH_TEMP_INCREASE</front>
<front id="Configuration_advH-27">   * degrees, the machine is halted, requiring a hard reset. This test restarts with any M104/M109,</front>
<front id="Configuration_advH-28">   * but only if the current temperature is far enough below the target for a reliable test.</front>
<front id="Configuration_advH-29">   */</front>
<front id="Configuration_advH-30">  #define WATCH_TEMP_PERIOD 16                // Seconds</front>
<front id="Configuration_advH-31">  #define WATCH_TEMP_INCREASE 4               // Degrees Celsius</front>
<front id="Configuration_advH-32">#endif</front>
<front id="Configuration_advH-33"></front>
<front id="Configuration_advH-34">#if ENABLED(THERMAL_PROTECTION_BED)</front>
<front id="Configuration_advH-35">  #define THERMAL_PROTECTION_BED_PERIOD 20    // Seconds</front>
<front id="Configuration_advH-36">  #define THERMAL_PROTECTION_BED_HYSTERESIS 2 // Degrees Celsius</front>
<front id="Configuration_advH-37">#endif</front>
<front id="Configuration_advH-38"></front>
<front id="Configuration_advH-39">#if ENABLED(PIDTEMP)</front>
<front id="Configuration_advH-40">  // this adds an experimental additional term to the heating power, proportional to the extrusion speed.</front>
<front id="Configuration_advH-41">  // if Kc is chosen well, the additional required power due to increased melting should be compensated.</front>
<front id="Configuration_advH-42">  #define PID_ADD_EXTRUSION_RATE</front>
<front id="Configuration_advH-43">  #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Configuration_advH-44">    #define DEFAULT_Kc (100) //heating power=Kc*(e_speed)</front>
<front id="Configuration_advH-45">    #define LPQ_MAX_LEN 50</front>
<front id="Configuration_advH-46">  #endif</front>
<front id="Configuration_advH-47">#endif</front>
<front id="Configuration_advH-48"></front>
<front id="Configuration_advH-49">/**</front>
<front id="Configuration_advH-50"> * Automatic Temperature:</front>
<front id="Configuration_advH-51"> * The hotend target temperature is calculated by all the buffered lines of gcode.</front>
<front id="Configuration_advH-52"> * The maximum buffered steps/sec of the extruder motor is called "se".</front>
<front id="Configuration_advH-53"> * Start autotemp mode with M109 S&lt;mintemp&gt; B&lt;maxtemp&gt; F&lt;factor&gt;</front>
<front id="Configuration_advH-54"> * The target temperature is set to mintemp+factor*se[steps/sec] and is limited by</front>
<front id="Configuration_advH-55"> * mintemp and maxtemp. Turn this off by excuting M109 without F*</front>
<front id="Configuration_advH-56"> * Also, if the temperature is set to a value below mintemp, it will not be changed by autotemp.</front>
<front id="Configuration_advH-57"> * On an Ultimaker, some initial testing worked with M109 S215 B260 F1 in the start.gcode</front>
<front id="Configuration_advH-58"> */</front>
<front id="Configuration_advH-59">#define AUTOTEMP</front>
<front id="Configuration_advH-60">#if ENABLED(AUTOTEMP)</front>
<front id="Configuration_advH-61">  #define AUTOTEMP_OLDWEIGHT 0.98</front>
<front id="Configuration_advH-62">#endif</front>
<front id="Configuration_advH-63"></front>
<front id="Configuration_advH-64">//Show Temperature ADC value</front>
<front id="Configuration_advH-65">//The M105 command return, besides traditional information, the ADC value read from temperature sensors.</front>
<front id="Configuration_advH-66">//#define SHOW_TEMP_ADC_VALUES</front>
<front id="Configuration_advH-67"></front>
<front id="Configuration_advH-68">// @section extruder</front>
<front id="Configuration_advH-69"></front>
<front id="Configuration_advH-70">//  extruder run-out prevention.</front>
<front id="Configuration_advH-71">//if the machine is idle, and the temperature over MINTEMP, every couple of SECONDS some filament is extruded</front>
<front id="Configuration_advH-72">//#define EXTRUDER_RUNOUT_PREVENT</front>
<front id="Configuration_advH-73">#define EXTRUDER_RUNOUT_MINTEMP 190</front>
<front id="Configuration_advH-74">#define EXTRUDER_RUNOUT_SECONDS 30.</front>
<front id="Configuration_advH-75">#define EXTRUDER_RUNOUT_ESTEPS 14. //mm filament</front>
<front id="Configuration_advH-76">#define EXTRUDER_RUNOUT_SPEED 1500.  //extrusion speed</front>
<front id="Configuration_advH-77">#define EXTRUDER_RUNOUT_EXTRUDE 100</front>
<front id="Configuration_advH-78"></front>
<front id="Configuration_advH-79">// @section temperature</front>
<front id="Configuration_advH-80"></front>
<front id="Configuration_advH-81">//These defines help to calibrate the AD595 sensor in case you get wrong temperature measurements.</front>
<front id="Configuration_advH-82">//The measured temperature is defined as "actualTemp = (measuredTemp * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET"</front>
<front id="Configuration_advH-83">#define TEMP_SENSOR_AD595_OFFSET 0.0</front>
<front id="Configuration_advH-84">#define TEMP_SENSOR_AD595_GAIN   1.0</front>
<front id="Configuration_advH-85"></front>
<front id="Configuration_advH-86">//This is for controlling a fan to cool down the stepper drivers</front>
<front id="Configuration_advH-87">//it will turn on when any driver is enabled</front>
<front id="Configuration_advH-88">//and turn off after the set amount of seconds from last driver being disabled again</front>
<front id="Configuration_advH-89">#define CONTROLLERFAN_PIN -1 //Pin used for the fan to cool controller (-1 to disable)</front>
<front id="Configuration_advH-90">#define CONTROLLERFAN_SECS 60 //How many seconds, after all motors were disabled, the fan should run</front>
<front id="Configuration_advH-91">#define CONTROLLERFAN_SPEED 255  // == full speed</front>
<front id="Configuration_advH-92"></front>
<front id="Configuration_advH-93">// When first starting the main fan, run it at full speed for the</front>
<front id="Configuration_advH-94">// given number of milliseconds.  This gets the fan spinning reliably</front>
<front id="Configuration_advH-95">// before setting a PWM value. (Does not work with software PWM for fan on Sanguinololu)</front>
<front id="Configuration_advH-96">//#define FAN_KICKSTART_TIME 100</front>
<front id="Configuration_advH-97"></front>
<front id="Configuration_advH-98">// This defines the minimal speed for the main fan, run in PWM mode</front>
<front id="Configuration_advH-99">// to enable uncomment and set minimal PWM speed for reliable running (1-255)</front>
<front id="Configuration_advH-100">// if fan speed is [1 - (FAN_MIN_PWM-1)] it is set to FAN_MIN_PWM</front>
<front id="Configuration_advH-101">//#define FAN_MIN_PWM 50</front>
<front id="Configuration_advH-102"></front>
<front id="Configuration_advH-103">// @section extruder</front>
<front id="Configuration_advH-104"></front>
<front id="Configuration_advH-105">// Extruder cooling fans</front>
<front id="Configuration_advH-106">// Configure fan pin outputs to automatically turn on/off when the associated</front>
<front id="Configuration_advH-107">// extruder temperature is above/below EXTRUDER_AUTO_FAN_TEMPERATURE.</front>
<front id="Configuration_advH-108">// Multiple extruders can be assigned to the same pin in which case</front>
<front id="Configuration_advH-109">// the fan will turn on when any selected extruder is above the threshold.</front>
<front id="Configuration_advH-110">#define EXTRUDER_0_AUTO_FAN_PIN -1</front>
<front id="Configuration_advH-111">#define EXTRUDER_1_AUTO_FAN_PIN -1</front>
<front id="Configuration_advH-112">#define EXTRUDER_2_AUTO_FAN_PIN -1</front>
<front id="Configuration_advH-113">#define EXTRUDER_3_AUTO_FAN_PIN -1</front>
<front id="Configuration_advH-114">#define EXTRUDER_AUTO_FAN_TEMPERATURE 50</front>
<front id="Configuration_advH-115">#define EXTRUDER_AUTO_FAN_SPEED   255  // == full speed</front>
<front id="Configuration_advH-116"></front>
<front id="Configuration_advH-117"></front>
<front id="Configuration_advH-118">//===========================================================================</front>
<front id="Configuration_advH-119">//=============================Mechanical Settings===========================</front>
<front id="Configuration_advH-120">//===========================================================================</front>
<front id="Configuration_advH-121"></front>
<front id="Configuration_advH-122">// @section homing</front>
<front id="Configuration_advH-123"></front>
<front id="Configuration_advH-124">#define ENDSTOPS_ONLY_FOR_HOMING // If defined the endstops will only be used for homing</front>
<front id="Configuration_advH-125"></front>
<front id="Configuration_advH-126">// @section extras</front>
<front id="Configuration_advH-127"></front>
<front id="Configuration_advH-128">//#define Z_LATE_ENABLE // Enable Z the last moment. Needed if your Z driver overheats.</front>
<front id="Configuration_advH-129"></front>
<front id="Configuration_advH-130">// A single Z stepper driver is usually used to drive 2 stepper motors.</front>
<front id="Configuration_advH-131">// Uncomment this define to utilize a separate stepper driver for each Z axis motor.</front>
<front id="Configuration_advH-132">// Only a few motherboards support this, like RAMPS, which have dual extruder support (the 2nd, often unused, extruder driver is used</front>
<front id="Configuration_advH-133">// to control the 2nd Z axis stepper motor). The pins are currently only defined for a RAMPS motherboards.</front>
<front id="Configuration_advH-134">// On a RAMPS (or other 5 driver) motherboard, using this feature will limit you to using 1 extruder.</front>
<front id="Configuration_advH-135">//#define Z_DUAL_STEPPER_DRIVERS</front>
<front id="Configuration_advH-136"></front>
<front id="Configuration_advH-137">#if ENABLED(Z_DUAL_STEPPER_DRIVERS)</front>
<front id="Configuration_advH-138"></front>
<front id="Configuration_advH-139">  // Z_DUAL_ENDSTOPS is a feature to enable the use of 2 endstops for both Z steppers - Let's call them Z stepper and Z2 stepper.</front>
<front id="Configuration_advH-140">  // That way the machine is capable to align the bed during home, since both Z steppers are homed. </front>
<front id="Configuration_advH-141">  // There is also an implementation of M666 (software endstops adjustment) to this feature.</front>
<front id="Configuration_advH-142">  // After Z homing, this adjustment is applied to just one of the steppers in order to align the bed.</front>
<front id="Configuration_advH-143">  // One just need to home the Z axis and measure the distance difference between both Z axis and apply the math: Z adjust = Z - Z2.</front>
<front id="Configuration_advH-144">  // If the Z stepper axis is closer to the bed, the measure Z &gt; Z2 (yes, it is.. think about it) and the Z adjust would be positive.</front>
<front id="Configuration_advH-145">  // Play a little bit with small adjustments (0.5mm) and check the behaviour.</front>
<front id="Configuration_advH-146">  // The M119 (endstops report) will start reporting the Z2 Endstop as well.</front>
<front id="Configuration_advH-147"></front>
<front id="Configuration_advH-148">  // #define Z_DUAL_ENDSTOPS</front>
<front id="Configuration_advH-149"></front>
<front id="Configuration_advH-150">  #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Configuration_advH-151">    #define Z2_MAX_PIN 36                     //Endstop used for Z2 axis. In this case I'm using XMAX in a Rumba Board (pin 36)</front>
<front id="Configuration_advH-152">    const bool Z2_MAX_ENDSTOP_INVERTING = false;</front>
<front id="Configuration_advH-153">    #define DISABLE_XMAX_ENDSTOP              //Better to disable the XMAX to avoid conflict. Just rename "XMAX_ENDSTOP" by the endstop you are using for Z2 axis.</front>
<front id="Configuration_advH-154">  #endif</front>
<front id="Configuration_advH-155"></front>
<front id="Configuration_advH-156">#endif // Z_DUAL_STEPPER_DRIVERS</front>
<front id="Configuration_advH-157"></front>
<front id="Configuration_advH-158">// Same again but for Y Axis.</front>
<front id="Configuration_advH-159">//#define Y_DUAL_STEPPER_DRIVERS</front>
<front id="Configuration_advH-160"></front>
<front id="Configuration_advH-161">#if ENABLED(Y_DUAL_STEPPER_DRIVERS)</front>
<front id="Configuration_advH-162">  // Define if the two Y drives need to rotate in opposite directions</front>
<front id="Configuration_advH-163">  #define INVERT_Y2_VS_Y_DIR true</front>
<front id="Configuration_advH-164">#endif</front>
<front id="Configuration_advH-165"></front>
<front id="Configuration_advH-166">// Enable this for dual x-carriage printers.</front>
<front id="Configuration_advH-167">// A dual x-carriage design has the advantage that the inactive extruder can be parked which</front>
<front id="Configuration_advH-168">// prevents hot-end ooze contaminating the print. It also reduces the weight of each x-carriage</front>
<front id="Configuration_advH-169">// allowing faster printing speeds.</front>
<front id="Configuration_advH-170">//#define DUAL_X_CARRIAGE</front>
<front id="Configuration_advH-171">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Configuration_advH-172">  // Configuration for second X-carriage</front>
<front id="Configuration_advH-173">  // Note: the first x-carriage is defined as the x-carriage which homes to the minimum endstop;</front>
<front id="Configuration_advH-174">  // the second x-carriage always homes to the maximum endstop.</front>
<front id="Configuration_advH-175">  #define X2_MIN_POS 80     // set minimum to ensure second x-carriage doesn't hit the parked first X-carriage</front>
<front id="Configuration_advH-176">  #define X2_MAX_POS 353    // set maximum to the distance between toolheads when both heads are homed</front>
<front id="Configuration_advH-177">  #define X2_HOME_DIR 1     // the second X-carriage always homes to the maximum endstop position</front>
<front id="Configuration_advH-178">  #define X2_HOME_POS X2_MAX_POS // default home position is the maximum carriage position</front>
<front id="Configuration_advH-179">      // However: In this mode the EXTRUDER_OFFSET_X value for the second extruder provides a software</front>
<front id="Configuration_advH-180">      // override for X2_HOME_POS. This also allow recalibration of the distance between the two endstops</front>
<front id="Configuration_advH-181">      // without modifying the firmware (through the "M218 T1 X???" command).</front>
<front id="Configuration_advH-182">      // Remember: you should set the second extruder x-offset to 0 in your slicer.</front>
<front id="Configuration_advH-183"></front>
<front id="Configuration_advH-184">  // Pins for second x-carriage stepper driver (defined here to avoid further complicating pins.h)</front>
<front id="Configuration_advH-185">  #define X2_ENABLE_PIN 29</front>
<front id="Configuration_advH-186">  #define X2_STEP_PIN 25</front>
<front id="Configuration_advH-187">  #define X2_DIR_PIN 23</front>
<front id="Configuration_advH-188"></front>
<front id="Configuration_advH-189">  // There are a few selectable movement modes for dual x-carriages using M605 S&lt;mode&gt;</front>
<front id="Configuration_advH-190">  //    Mode 0: Full control. The slicer has full control over both x-carriages and can achieve optimal travel results</front>
<front id="Configuration_advH-191">  //                           as long as it supports dual x-carriages. (M605 S0)</front>
<front id="Configuration_advH-192">  //    Mode 1: Auto-park mode. The firmware will automatically park and unpark the x-carriages on tool changes so</front>
<front id="Configuration_advH-193">  //                           that additional slicer support is not required. (M605 S1)</front>
<front id="Configuration_advH-194">  //    Mode 2: Duplication mode. The firmware will transparently make the second x-carriage and extruder copy all</front>
<front id="Configuration_advH-195">  //                           actions of the first x-carriage. This allows the printer to print 2 arbitrary items at</front>
<front id="Configuration_advH-196">  //                           once. (2nd extruder x offset and temp offset are set using: M605 S2 [Xnnn] [Rmmm])</front>
<front id="Configuration_advH-197"></front>
<front id="Configuration_advH-198">  // This is the default power-up mode which can be later using M605.</front>
<front id="Configuration_advH-199">  #define DEFAULT_DUAL_X_CARRIAGE_MODE 0</front>
<front id="Configuration_advH-200"></front>
<front id="Configuration_advH-201">  // Default settings in "Auto-park Mode"</front>
<front id="Configuration_advH-202">  #define TOOLCHANGE_PARK_ZLIFT   0.2      // the distance to raise Z axis when parking an extruder</front>
<front id="Configuration_advH-203">  #define TOOLCHANGE_UNPARK_ZLIFT 1        // the distance to raise Z axis when unparking an extruder</front>
<front id="Configuration_advH-204"></front>
<front id="Configuration_advH-205">  // Default x offset in duplication mode (typically set to half print bed width)</front>
<front id="Configuration_advH-206">  #define DEFAULT_DUPLICATION_X_OFFSET 100</front>
<front id="Configuration_advH-207"></front>
<front id="Configuration_advH-208">#endif //DUAL_X_CARRIAGE</front>
<front id="Configuration_advH-209"></front>
<front id="Configuration_advH-210">// @section homing</front>
<front id="Configuration_advH-211"></front>
<front id="Configuration_advH-212">//homing hits the endstop, then retracts by this distance, before it tries to slowly bump again:</front>
<front id="Configuration_advH-213">#define X_HOME_BUMP_MM 5</front>
<front id="Configuration_advH-214">#define Y_HOME_BUMP_MM 5</front>
<front id="Configuration_advH-215">#define Z_HOME_BUMP_MM 2</front>
<front id="Configuration_advH-216">#define HOMING_BUMP_DIVISOR {2, 2, 4}  // Re-Bump Speed Divisor (Divides the Homing Feedrate)</front>
<front id="Configuration_advH-217">//#define QUICK_HOME  //if this is defined, if both x and y are to be homed, a diagonal move will be performed initially.</front>
<front id="Configuration_advH-218"></front>
<front id="Configuration_advH-219">// When G28 is called, this option will make Y home before X</front>
<front id="Configuration_advH-220">// #define HOME_Y_BEFORE_X</front>
<front id="Configuration_advH-221"></front>
<front id="Configuration_advH-222">// @section machine</front>
<front id="Configuration_advH-223"></front>
<front id="Configuration_advH-224">#define AXIS_RELATIVE_MODES {false, false, false, false}</front>
<front id="Configuration_advH-225"></front>
<front id="Configuration_advH-226">// @section machine</front>
<front id="Configuration_advH-227"></front>
<front id="Configuration_advH-228">//By default pololu step drivers require an active high signal. However, some high power drivers require an active low signal as step.</front>
<front id="Configuration_advH-229">#define INVERT_X_STEP_PIN false</front>
<front id="Configuration_advH-230">#define INVERT_Y_STEP_PIN false</front>
<front id="Configuration_advH-231">#define INVERT_Z_STEP_PIN false</front>
<front id="Configuration_advH-232">#define INVERT_E_STEP_PIN false</front>
<front id="Configuration_advH-233"></front>
<front id="Configuration_advH-234">// Default stepper release if idle. Set to 0 to deactivate.</front>
<front id="Configuration_advH-235">#define DEFAULT_STEPPER_DEACTIVE_TIME 60</front>
<front id="Configuration_advH-236"></front>
<front id="Configuration_advH-237">#define DEFAULT_MINIMUMFEEDRATE       0.0     // minimum feedrate</front>
<front id="Configuration_advH-238">#define DEFAULT_MINTRAVELFEEDRATE     0.0</front>
<front id="Configuration_advH-239"></front>
<front id="Configuration_advH-240">// @section lcd</front>
<front id="Configuration_advH-241"></front>
<front id="Configuration_advH-242">#if ENABLED(ULTIPANEL)</front>
<front id="Configuration_advH-243">  #define MANUAL_FEEDRATE {50*60, 50*60, 4*60, 60} // Feedrates for manual moves along X, Y, Z, E from panel</front>
<front id="Configuration_advH-244">  #define ULTIPANEL_FEEDMULTIPLY  // Comment to disable setting feedrate multiplier via encoder</front>
<front id="Configuration_advH-245">#endif</front>
<front id="Configuration_advH-246"></front>
<front id="Configuration_advH-247">// @section extras</front>
<front id="Configuration_advH-248"></front>
<front id="Configuration_advH-249">// minimum time in microseconds that a movement needs to take if the buffer is emptied.</front>
<front id="Configuration_advH-250">#define DEFAULT_MINSEGMENTTIME        20000</front>
<front id="Configuration_advH-251"></front>
<front id="Configuration_advH-252">// If defined the movements slow down when the look ahead buffer is only half full</front>
<front id="Configuration_advH-253">#define SLOWDOWN</front>
<front id="Configuration_advH-254"></front>
<front id="Configuration_advH-255">// Frequency limit</front>
<front id="Configuration_advH-256">// See nophead's blog for more info</front>
<front id="Configuration_advH-257">// Not working O</front>
<front id="Configuration_advH-258">//#define XY_FREQUENCY_LIMIT  15</front>
<front id="Configuration_advH-259"></front>
<front id="Configuration_advH-260">// Minimum planner junction speed. Sets the default minimum speed the planner plans for at the end</front>
<front id="Configuration_advH-261">// of the buffer and all stops. This should not be much greater than zero and should only be changed</front>
<front id="Configuration_advH-262">// if unwanted behavior is observed on a user's machine when running at very slow speeds.</front>
<front id="Configuration_advH-263">#define MINIMUM_PLANNER_SPEED 0.05// (mm/sec)</front>
<front id="Configuration_advH-264"></front>
<front id="Configuration_advH-265">// Microstep setting (Only functional when stepper driver microstep pins are connected to MCU.</front>
<front id="Configuration_advH-266">#define MICROSTEP_MODES {16,16,16,16,16} // [1,2,4,8,16]</front>
<front id="Configuration_advH-267"></front>
<front id="Configuration_advH-268">// Motor Current setting (Only functional when motor driver current ref pins are connected to a digital trimpot on supported boards)</front>
<front id="Configuration_advH-269">#define DIGIPOT_MOTOR_CURRENT {135,135,135,135,135} // Values 0-255 (RAMBO 135 = ~0.75A, 185 = ~1A)</front>
<front id="Configuration_advH-270"></front>
<front id="Configuration_advH-271">// uncomment to enable an I2C based DIGIPOT like on the Azteeg X3 Pro</front>
<front id="Configuration_advH-272">//#define DIGIPOT_I2C</front>
<front id="Configuration_advH-273">// Number of channels available for I2C digipot, For Azteeg X3 Pro we have 8</front>
<front id="Configuration_advH-274">#define DIGIPOT_I2C_NUM_CHANNELS 8</front>
<front id="Configuration_advH-275">// actual motor currents in Amps, need as many here as DIGIPOT_I2C_NUM_CHANNELS</front>
<front id="Configuration_advH-276">#define DIGIPOT_I2C_MOTOR_CURRENTS {1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0}</front>
<front id="Configuration_advH-277"></front>
<front id="Configuration_advH-278">//===========================================================================</front>
<front id="Configuration_advH-279">//=============================Additional Features===========================</front>
<front id="Configuration_advH-280">//===========================================================================</front>
<front id="Configuration_advH-281"></front>
<front id="Configuration_advH-282">#define ENCODER_RATE_MULTIPLIER         // If defined, certain menu edit operations automatically multiply the steps when the encoder is moved quickly</front>
<front id="Configuration_advH-283">#define ENCODER_10X_STEPS_PER_SEC 75    // If the encoder steps per sec exceeds this value, multiply steps moved x10 to quickly advance the value</front>
<front id="Configuration_advH-284">#define ENCODER_100X_STEPS_PER_SEC 160  // If the encoder steps per sec exceeds this value, multiply steps moved x100 to really quickly advance the value</front>
<front id="Configuration_advH-285"></front>
<front id="Configuration_advH-286">//#define CHDK 4        //Pin for triggering CHDK to take a picture see how to use it here http://captain-slow.dk/2014/03/09/3d-printing-timelapses/</front>
<front id="Configuration_advH-287">#define CHDK_DELAY 50 //How long in ms the pin should stay HIGH before going LOW again</front>
<front id="Configuration_advH-288"></front>
<front id="Configuration_advH-289">// @section lcd</front>
<front id="Configuration_advH-290"></front>
<front id="Configuration_advH-291">#if ENABLED(SDSUPPORT)</front>
<front id="Configuration_advH-292"></front>
<front id="Configuration_advH-293">  // Some RAMPS and other boards don't detect when an SD card is inserted. You can work</front>
<front id="Configuration_advH-294">  // around this by connecting a push button or single throw switch to the pin defined</front>
<front id="Configuration_advH-295">  // as SD_DETECT_PIN in your board's pins definitions.</front>
<front id="Configuration_advH-296">  // This setting should be disabled unless you are using a push button, pulling the pin to ground.</front>
<front id="Configuration_advH-297">  // Note: This is always disabled for ULTIPANEL (except ELB_FULL_GRAPHIC_CONTROLLER).</front>
<front id="Configuration_advH-298">  #define SD_DETECT_INVERTED</front>
<front id="Configuration_advH-299"></front>
<front id="Configuration_advH-300">  #define SD_FINISHED_STEPPERRELEASE true  //if sd support and the file is finished: disable steppers?</front>
<front id="Configuration_advH-301">  #define SD_FINISHED_RELEASECOMMAND "M84 X Y Z E" // You might want to keep the z enabled so your bed stays in place.</front>
<front id="Configuration_advH-302"></front>
<front id="Configuration_advH-303">  #define SDCARD_RATHERRECENTFIRST  //reverse file order of sd card menu display. Its sorted practically after the file system block order.</front>
<front id="Configuration_advH-304">  // if a file is deleted, it frees a block. hence, the order is not purely chronological. To still have auto0.g accessible, there is again the option to do that.</front>
<front id="Configuration_advH-305">  // using:</front>
<front id="Configuration_advH-306">  //#define MENU_ADDAUTOSTART</front>
<front id="Configuration_advH-307"></front>
<front id="Configuration_advH-308">  // Show a progress bar on HD44780 LCDs for SD printing</front>
<front id="Configuration_advH-309">  //#define LCD_PROGRESS_BAR</front>
<front id="Configuration_advH-310"></front>
<front id="Configuration_advH-311">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="Configuration_advH-312">    // Amount of time (ms) to show the bar</front>
<front id="Configuration_advH-313">    #define PROGRESS_BAR_BAR_TIME 2000</front>
<front id="Configuration_advH-314">    // Amount of time (ms) to show the status message</front>
<front id="Configuration_advH-315">    #define PROGRESS_BAR_MSG_TIME 3000</front>
<front id="Configuration_advH-316">    // Amount of time (ms) to retain the status message (0=forever)</front>
<front id="Configuration_advH-317">    #define PROGRESS_MSG_EXPIRE   0</front>
<front id="Configuration_advH-318">    // Enable this to show messages for MSG_TIME then hide them</front>
<front id="Configuration_advH-319">    //#define PROGRESS_MSG_ONCE</front>
<front id="Configuration_advH-320">  #endif</front>
<front id="Configuration_advH-321"></front>
<front id="Configuration_advH-322">  // This allows hosts to request long names for files and folders with M33</front>
<front id="Configuration_advH-323">  //#define LONG_FILENAME_HOST_SUPPORT</front>
<front id="Configuration_advH-324"></front>
<front id="Configuration_advH-325">  // This option allows you to abort SD printing when any endstop is triggered.</front>
<front id="Configuration_advH-326">  // This feature must be enabled with "M540 S1" or from the LCD menu.</front>
<front id="Configuration_advH-327">  // To have any effect, endstops must be enabled during SD printing.</front>
<front id="Configuration_advH-328">  // With ENDSTOPS_ONLY_FOR_HOMING you must send "M120" to enable endstops.</front>
<front id="Configuration_advH-329">  //#define ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="Configuration_advH-330"></front>
<front id="Configuration_advH-331">#endif // SDSUPPORT</front>
<front id="Configuration_advH-332"></front>
<front id="Configuration_advH-333">// for dogm lcd displays you can choose some additional fonts:</front>
<front id="Configuration_advH-334">#if ENABLED(DOGLCD)</front>
<front id="Configuration_advH-335">  // save 3120 bytes of PROGMEM by commenting out #define USE_BIG_EDIT_FONT</front>
<front id="Configuration_advH-336">  // we don't have a big font for Cyrillic, Kana</front>
<front id="Configuration_advH-337">  //#define USE_BIG_EDIT_FONT</front>
<front id="Configuration_advH-338"> </front>
<front id="Configuration_advH-339">  // If you have spare 2300Byte of progmem and want to use a </front>
<front id="Configuration_advH-340">  // smaller font on the Info-screen uncomment the next line.</front>
<front id="Configuration_advH-341">  //#define USE_SMALL_INFOFONT</front>
<front id="Configuration_advH-342">#endif // DOGLCD</front>
<front id="Configuration_advH-343"></front>
<front id="Configuration_advH-344">// @section more</front>
<front id="Configuration_advH-345"></front>
<front id="Configuration_advH-346">// The hardware watchdog should reset the microcontroller disabling all outputs, in case the firmware gets stuck and doesn't do temperature regulation.</front>
<front id="Configuration_advH-347">//#define USE_WATCHDOG</front>
<front id="Configuration_advH-348"></front>
<front id="Configuration_advH-349">#if ENABLED(USE_WATCHDOG)</front>
<front id="Configuration_advH-350">// If you have a watchdog reboot in an ArduinoMega2560 then the device will hang forever, as a watchdog reset will leave the watchdog on.</front>
<front id="Configuration_advH-351">// The "WATCHDOG_RESET_MANUAL" goes around this by not using the hardware reset.</front>
<front id="Configuration_advH-352">//  However, THIS FEATURE IS UNSAFE!, as it will only work if interrupts are disabled. And the code could hang in an interrupt routine with interrupts disabled.</front>
<front id="Configuration_advH-353">//#define WATCHDOG_RESET_MANUAL</front>
<front id="Configuration_advH-354">#endif</front>
<front id="Configuration_advH-355"></front>
<front id="Configuration_advH-356">// @section lcd</front>
<front id="Configuration_advH-357"></front>
<front id="Configuration_advH-358">// Babystepping enables the user to control the axis in tiny amounts, independently from the normal printing process</front>
<front id="Configuration_advH-359">// it can e.g. be used to change z-positions in the print startup phase in real-time</front>
<front id="Configuration_advH-360">// does not respect endstops!</front>
<front id="Configuration_advH-361">//#define BABYSTEPPING</front>
<front id="Configuration_advH-362">#if ENABLED(BABYSTEPPING)</front>
<front id="Configuration_advH-363">  #define BABYSTEP_XY  //not only z, but also XY in the menu. more clutter, more functions</front>
<front id="Configuration_advH-364">                       //not implemented for CoreXY and deltabots!</front>
<front id="Configuration_advH-365">  #define BABYSTEP_INVERT_Z false  //true for inverse movements in Z</front>
<front id="Configuration_advH-366">  #define BABYSTEP_Z_MULTIPLICATOR 2 //faster z movements</front>
<front id="Configuration_advH-367">#endif</front>
<front id="Configuration_advH-368"></front>
<front id="Configuration_advH-369">// @section extruder</front>
<front id="Configuration_advH-370"></front>
<front id="Configuration_advH-371">// extruder advance constant (s2/mm3)</front>
<front id="Configuration_advH-372">//</front>
<front id="Configuration_advH-373">// advance (steps) = STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K * cubic mm per second ^ 2</front>
<front id="Configuration_advH-374">//</front>
<front id="Configuration_advH-375">// Hooke's law says:    force = k * distance</front>
<front id="Configuration_advH-376">// Bernoulli's principle says:  v ^ 2 / 2 + g . h + pressure / density = constant</front>
<front id="Configuration_advH-377">// so: v ^ 2 is proportional to number of steps we advance the extruder</front>
<front id="Configuration_advH-378">//#define ADVANCE</front>
<front id="Configuration_advH-379"></front>
<front id="Configuration_advH-380">#if ENABLED(ADVANCE)</front>
<front id="Configuration_advH-381">  #define EXTRUDER_ADVANCE_K .0</front>
<front id="Configuration_advH-382">  #define D_FILAMENT 2.85</front>
<front id="Configuration_advH-383">  #define STEPS_MM_E 836</front>
<front id="Configuration_advH-384">#endif</front>
<front id="Configuration_advH-385"></front>
<front id="Configuration_advH-386">// @section extras</front>
<front id="Configuration_advH-387"></front>
<front id="Configuration_advH-388">// Arc interpretation settings:</front>
<front id="Configuration_advH-389">#define MM_PER_ARC_SEGMENT 1</front>
<front id="Configuration_advH-390">#define N_ARC_CORRECTION 25</front>
<front id="Configuration_advH-391"></front>
<front id="Configuration_advH-392">const unsigned int dropsegments=5; //everything with less than this number of steps will be ignored as move and joined with the next movement</front>
<front id="Configuration_advH-393"></front>
<front id="Configuration_advH-394">// @section temperature</front>
<front id="Configuration_advH-395"></front>
<front id="Configuration_advH-396">// Control heater 0 and heater 1 in parallel.</front>
<front id="Configuration_advH-397">//#define HEATERS_PARALLEL</front>
<front id="Configuration_advH-398"></front>
<front id="Configuration_advH-399">//===========================================================================</front>
<front id="Configuration_advH-400">//================================= Buffers =================================</front>
<front id="Configuration_advH-401">//===========================================================================</front>
<front id="Configuration_advH-402"></front>
<front id="Configuration_advH-403">// @section hidden</front>
<front id="Configuration_advH-404"></front>
<front id="Configuration_advH-405">// The number of linear motions that can be in the plan at any give time.</front>
<front id="Configuration_advH-406">// THE BLOCK_BUFFER_SIZE NEEDS TO BE A POWER OF 2, i.g. 8,16,32 because shifts and ors are used to do the ring-buffering.</front>
<front id="Configuration_advH-407">#if ENABLED(SDSUPPORT)</front>
<front id="Configuration_advH-408">  #define BLOCK_BUFFER_SIZE 16   // SD,LCD,Buttons take more memory, block buffer needs to be smaller</front>
<front id="Configuration_advH-409">#else</front>
<front id="Configuration_advH-410">  #define BLOCK_BUFFER_SIZE 16 // maximize block buffer</front>
<front id="Configuration_advH-411">#endif</front>
<front id="Configuration_advH-412"></front>
<front id="Configuration_advH-413">// @section more</front>
<front id="Configuration_advH-414"></front>
<front id="Configuration_advH-415">//The ASCII buffer for receiving from the serial:</front>
<front id="Configuration_advH-416">#define MAX_CMD_SIZE 96</front>
<front id="Configuration_advH-417">#define BUFSIZE 4</front>
<front id="Configuration_advH-418"></front>
<front id="Configuration_advH-419">// Bad Serial-connections can miss a received command by sending an 'ok'</front>
<front id="Configuration_advH-420">// Therefore some clients abort after 30 seconds in a timeout.</front>
<front id="Configuration_advH-421">// Some other clients start sending commands while receiving a 'wait'.</front>
<front id="Configuration_advH-422">// This "wait" is only sent when the buffer is empty. 1 second is a good value here.</front>
<front id="Configuration_advH-423">//#define NO_TIMEOUTS 1000 // Milliseconds</front>
<front id="Configuration_advH-424"></front>
<front id="Configuration_advH-425">// Some clients will have this feature soon. This could make the NO_TIMEOUTS unnecessary.</front>
<front id="Configuration_advH-426">//#define ADVANCED_OK</front>
<front id="Configuration_advH-427"></front>
<front id="Configuration_advH-428">// @section fwretract</front>
<front id="Configuration_advH-429"></front>
<front id="Configuration_advH-430">// Firmware based and LCD controlled retract</front>
<front id="Configuration_advH-431">// M207 and M208 can be used to define parameters for the retraction.</front>
<front id="Configuration_advH-432">// The retraction can be called by the slicer using G10 and G11</front>
<front id="Configuration_advH-433">// until then, intended retractions can be detected by moves that only extrude and the direction.</front>
<front id="Configuration_advH-434">// the moves are than replaced by the firmware controlled ones.</front>
<front id="Configuration_advH-435"></front>
<front id="Configuration_advH-436">// #define FWRETRACT  //ONLY PARTIALLY TESTED</front>
<front id="Configuration_advH-437">#if ENABLED(FWRETRACT)</front>
<front id="Configuration_advH-438">  #define MIN_RETRACT 0.1                //minimum extruded mm to accept a automatic gcode retraction attempt</front>
<front id="Configuration_advH-439">  #define RETRACT_LENGTH 3               //default retract length (positive mm)</front>
<front id="Configuration_advH-440">  #define RETRACT_LENGTH_SWAP 13         //default swap retract length (positive mm), for extruder change</front>
<front id="Configuration_advH-441">  #define RETRACT_FEEDRATE 45            //default feedrate for retracting (mm/s)</front>
<front id="Configuration_advH-442">  #define RETRACT_ZLIFT 0                //default retract Z-lift</front>
<front id="Configuration_advH-443">  #define RETRACT_RECOVER_LENGTH 0       //default additional recover length (mm, added to retract length when recovering)</front>
<front id="Configuration_advH-444">  #define RETRACT_RECOVER_LENGTH_SWAP 0  //default additional swap recover length (mm, added to retract length when recovering from extruder change)</front>
<front id="Configuration_advH-445">  #define RETRACT_RECOVER_FEEDRATE 8     //default feedrate for recovering from retraction (mm/s)</front>
<front id="Configuration_advH-446">#endif</front>
<front id="Configuration_advH-447"></front>
<front id="Configuration_advH-448">// Add support for experimental filament exchange support M600; requires display</front>
<front id="Configuration_advH-449">#if ENABLED(ULTIPANEL)</front>
<front id="Configuration_advH-450">  //#define FILAMENTCHANGEENABLE</front>
<front id="Configuration_advH-451">  #if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="Configuration_advH-452">    #define FILAMENTCHANGE_XPOS 3</front>
<front id="Configuration_advH-453">    #define FILAMENTCHANGE_YPOS 3</front>
<front id="Configuration_advH-454">    #define FILAMENTCHANGE_ZADD 10</front>
<front id="Configuration_advH-455">    #define FILAMENTCHANGE_FIRSTRETRACT -2</front>
<front id="Configuration_advH-456">    #define FILAMENTCHANGE_FINALRETRACT -100</front>
<front id="Configuration_advH-457">    #define AUTO_FILAMENT_CHANGE                //This extrude filament until you press the button on LCD</front>
<front id="Configuration_advH-458">    #define AUTO_FILAMENT_CHANGE_LENGTH 0.04    //Extrusion length on automatic extrusion loop</front>
<front id="Configuration_advH-459">    #define AUTO_FILAMENT_CHANGE_FEEDRATE 300   //Extrusion feedrate (mm/min) on automatic extrusion loop</front>
<front id="Configuration_advH-460">  #endif</front>
<front id="Configuration_advH-461">#endif</front>
<front id="Configuration_advH-462"></front>
<front id="Configuration_advH-463">/******************************************************************************\</front>
<front id="Configuration_advH-464"> * enable this section if you have TMC26X motor drivers. </front>
<front id="Configuration_advH-465"> * you need to import the TMC26XStepper library into the arduino IDE for this</front>
<front id="Configuration_advH-466"> ******************************************************************************/</front>
<front id="Configuration_advH-467"></front>
<front id="Configuration_advH-468">// @section tmc</front>
<front id="Configuration_advH-469"></front>
<front id="Configuration_advH-470">//#define HAVE_TMCDRIVER</front>
<front id="Configuration_advH-471">#if ENABLED(HAVE_TMCDRIVER)</front>
<front id="Configuration_advH-472"></front>
<front id="Configuration_advH-473">//  #define X_IS_TMC</front>
<front id="Configuration_advH-474">  #define X_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-475">  #define X_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-476">  #define X_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-477">  </front>
<front id="Configuration_advH-478">//  #define X2_IS_TMC</front>
<front id="Configuration_advH-479">  #define X2_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-480">  #define X2_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-481">  #define X2_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-482">  </front>
<front id="Configuration_advH-483">//  #define Y_IS_TMC</front>
<front id="Configuration_advH-484">  #define Y_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-485">  #define Y_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-486">  #define Y_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-487">  </front>
<front id="Configuration_advH-488">//  #define Y2_IS_TMC</front>
<front id="Configuration_advH-489">  #define Y2_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-490">  #define Y2_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-491">  #define Y2_MICROSTEPS 16     //number of microsteps </front>
<front id="Configuration_advH-492">  </front>
<front id="Configuration_advH-493">//  #define Z_IS_TMC</front>
<front id="Configuration_advH-494">  #define Z_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-495">  #define Z_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-496">  #define Z_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-497">  </front>
<front id="Configuration_advH-498">//  #define Z2_IS_TMC</front>
<front id="Configuration_advH-499">  #define Z2_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-500">  #define Z2_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-501">  #define Z2_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-502">  </front>
<front id="Configuration_advH-503">//  #define E0_IS_TMC</front>
<front id="Configuration_advH-504">  #define E0_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-505">  #define E0_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-506">  #define E0_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-507">  </front>
<front id="Configuration_advH-508">//  #define E1_IS_TMC</front>
<front id="Configuration_advH-509">  #define E1_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-510">  #define E1_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-511">  #define E1_MICROSTEPS 16     //number of microsteps </front>
<front id="Configuration_advH-512">  </front>
<front id="Configuration_advH-513">//  #define E2_IS_TMC</front>
<front id="Configuration_advH-514">  #define E2_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-515">  #define E2_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-516">  #define E2_MICROSTEPS 16     //number of microsteps </front>
<front id="Configuration_advH-517">  </front>
<front id="Configuration_advH-518">//  #define E3_IS_TMC</front>
<front id="Configuration_advH-519">  #define E3_MAX_CURRENT 1000  //in mA</front>
<front id="Configuration_advH-520">  #define E3_SENSE_RESISTOR 91 //in mOhms</front>
<front id="Configuration_advH-521">  #define E3_MICROSTEPS 16     //number of microsteps   </front>
<front id="Configuration_advH-522"></front>
<front id="Configuration_advH-523">#endif</front>
<front id="Configuration_advH-524"></front>
<front id="Configuration_advH-525">/******************************************************************************\</front>
<front id="Configuration_advH-526"> * enable this section if you have L6470  motor drivers. </front>
<front id="Configuration_advH-527"> * you need to import the L6470 library into the arduino IDE for this</front>
<front id="Configuration_advH-528"> ******************************************************************************/</front>
<front id="Configuration_advH-529"></front>
<front id="Configuration_advH-530">// @section l6470</front>
<front id="Configuration_advH-531"></front>
<front id="Configuration_advH-532">//#define HAVE_L6470DRIVER</front>
<front id="Configuration_advH-533">#if ENABLED(HAVE_L6470DRIVER)</front>
<front id="Configuration_advH-534"></front>
<front id="Configuration_advH-535">//  #define X_IS_L6470</front>
<front id="Configuration_advH-536">  #define X_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-537">  #define X_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-538">  #define X_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-539">  #define X_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-540">  </front>
<front id="Configuration_advH-541">//  #define X2_IS_L6470</front>
<front id="Configuration_advH-542">  #define X2_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-543">  #define X2_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-544">  #define X2_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-545">  #define X2_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-546">  </front>
<front id="Configuration_advH-547">//  #define Y_IS_L6470</front>
<front id="Configuration_advH-548">  #define Y_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-549">  #define Y_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-550">  #define Y_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-551">  #define Y_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-552">  </front>
<front id="Configuration_advH-553">//  #define Y2_IS_L6470</front>
<front id="Configuration_advH-554">  #define Y2_MICROSTEPS 16     //number of microsteps </front>
<front id="Configuration_advH-555">  #define Y2_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-556">  #define Y2_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-557">  #define Y2_STALLCURRENT 1500 //current in mA where the driver will detect a stall </front>
<front id="Configuration_advH-558">  </front>
<front id="Configuration_advH-559">//  #define Z_IS_L6470</front>
<front id="Configuration_advH-560">  #define Z_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-561">  #define Z_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-562">  #define Z_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-563">  #define Z_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-564">  </front>
<front id="Configuration_advH-565">//  #define Z2_IS_L6470</front>
<front id="Configuration_advH-566">  #define Z2_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-567">  #define Z2_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-568">  #define Z2_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-569">  #define Z2_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-570">  </front>
<front id="Configuration_advH-571">//  #define E0_IS_L6470</front>
<front id="Configuration_advH-572">  #define E0_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-573">  #define E0_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-574">  #define E0_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-575">  #define E0_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-576">  </front>
<front id="Configuration_advH-577">//  #define E1_IS_L6470</front>
<front id="Configuration_advH-578">  #define E1_MICROSTEPS 16     //number of microsteps </front>
<front id="Configuration_advH-579">  #define E1_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-580">  #define E1_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-581">  #define E1_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-582">  #define E1_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-583">  </front>
<front id="Configuration_advH-584">//  #define E2_IS_L6470</front>
<front id="Configuration_advH-585">  #define E2_MICROSTEPS 16     //number of microsteps </front>
<front id="Configuration_advH-586">  #define E2_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-587">  #define E2_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-588">  #define E2_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-589">  #define E2_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-590">  </front>
<front id="Configuration_advH-591">//  #define E3_IS_L6470</front>
<front id="Configuration_advH-592">  #define E3_MICROSTEPS 16     //number of microsteps   </front>
<front id="Configuration_advH-593">  #define E3_MICROSTEPS 16     //number of microsteps</front>
<front id="Configuration_advH-594">  #define E3_K_VAL 50          // 0 - 255, Higher values, are higher power. Be carefull not to go too high    </front>
<front id="Configuration_advH-595">  #define E3_OVERCURRENT 2000  //maxc current in mA. If the current goes over this value, the driver will switch off</front>
<front id="Configuration_advH-596">  #define E3_STALLCURRENT 1500 //current in mA where the driver will detect a stall</front>
<front id="Configuration_advH-597">  </front>
<front id="Configuration_advH-598">#endif</front>
<front id="Configuration_advH-599"></front>
<front id="Configuration_advH-600">#include "Conditionals.h"</front>
<front id="Configuration_advH-601">#include "SanityCheck.h"</front>
<front id="Configuration_advH-602"></front>
<front id="Configuration_advH-603">#endif //CONFIGURATION_ADV_H</front>
 </pre>
<h1 id="configuration_storeCPPtitle" >configuration_store.cpp</h1>
<pre id="configuration_storeCPP"  class="prettyprint linenums"><front id="configuration_storeCPP-1">/**</front>
<front id="configuration_storeCPP-2"> * configuration_store.cpp</front>
<front id="configuration_storeCPP-3"> *</front>
<front id="configuration_storeCPP-4"> * Configuration and EEPROM storage</front>
<front id="configuration_storeCPP-5"> *</front>
<front id="configuration_storeCPP-6"> * IMPORTANT:  Whenever there are changes made to the variables stored in EEPROM</front>
<front id="configuration_storeCPP-7"> * in the functions below, also increment the version number. This makes sure that</front>
<front id="configuration_storeCPP-8"> * the default values are used whenever there is a change to the data, to prevent</front>
<front id="configuration_storeCPP-9"> * wrong data being written to the variables.</front>
<front id="configuration_storeCPP-10"> *</front>
<front id="configuration_storeCPP-11"> * ALSO: Variables in the Store and Retrieve sections must be in the same order.</front>
<front id="configuration_storeCPP-12"> *       If a feature is disabled, some data must still be written that, when read,</front>
<front id="configuration_storeCPP-13"> *       either sets a Sane Default, or results in No Change to the existing value.</front>
<front id="configuration_storeCPP-14"> *</front>
<front id="configuration_storeCPP-15"> */</front>
<front id="configuration_storeCPP-16"></front>
<front id="configuration_storeCPP-17">#define EEPROM_VERSION "V21"</front>
<front id="configuration_storeCPP-18"></front>
<front id="configuration_storeCPP-19">/**</front>
<front id="configuration_storeCPP-20"> * V19 EEPROM Layout:</front>
<front id="configuration_storeCPP-21"> *</front>
<front id="configuration_storeCPP-22"> *  ver</front>
<front id="configuration_storeCPP-23"> *  M92 XYZE  axis_steps_per_unit (x4)</front>
<front id="configuration_storeCPP-24"> *  M203 XYZE max_feedrate (x4)</front>
<front id="configuration_storeCPP-25"> *  M201 XYZE max_acceleration_units_per_sq_second (x4)</front>
<front id="configuration_storeCPP-26"> *  M204 P    acceleration</front>
<front id="configuration_storeCPP-27"> *  M204 R    retract_acceleration</front>
<front id="configuration_storeCPP-28"> *  M204 T    travel_acceleration</front>
<front id="configuration_storeCPP-29"> *  M205 S    minimumfeedrate</front>
<front id="configuration_storeCPP-30"> *  M205 T    mintravelfeedrate</front>
<front id="configuration_storeCPP-31"> *  M205 B    minsegmenttime</front>
<front id="configuration_storeCPP-32"> *  M205 X    max_xy_jerk</front>
<front id="configuration_storeCPP-33"> *  M205 Z    max_z_jerk</front>
<front id="configuration_storeCPP-34"> *  M205 E    max_e_jerk</front>
<front id="configuration_storeCPP-35"> *  M206 XYZ  home_offset (x3)</front>
<front id="configuration_storeCPP-36"> *</front>
<front id="configuration_storeCPP-37"> * Mesh bed leveling:</front>
<front id="configuration_storeCPP-38"> *  M420 S    active</front>
<front id="configuration_storeCPP-39"> *            mesh_num_x (set in firmware)</front>
<front id="configuration_storeCPP-40"> *            mesh_num_y (set in firmware)</front>
<front id="configuration_storeCPP-41"> *  M421 XYZ  z_values[][]</front>
<front id="configuration_storeCPP-42"> *  M851      zprobe_zoffset</front>
<front id="configuration_storeCPP-43"> *</front>
<front id="configuration_storeCPP-44"> * DELTA:</front>
<front id="configuration_storeCPP-45"> *  M666 XYZ  endstop_adj (x3)</front>
<front id="configuration_storeCPP-46"> *  M665 R    delta_radius</front>
<front id="configuration_storeCPP-47"> *  M665 L    delta_diagonal_rod</front>
<front id="configuration_storeCPP-48"> *  M665 S    delta_segments_per_second</front>
<front id="configuration_storeCPP-49"> *</front>
<front id="configuration_storeCPP-50"> * ULTIPANEL:</front>
<front id="configuration_storeCPP-51"> *  M145 S0 H plaPreheatHotendTemp</front>
<front id="configuration_storeCPP-52"> *  M145 S0 B plaPreheatHPBTemp</front>
<front id="configuration_storeCPP-53"> *  M145 S0 F plaPreheatFanSpeed</front>
<front id="configuration_storeCPP-54"> *  M145 S1 H absPreheatHotendTemp</front>
<front id="configuration_storeCPP-55"> *  M145 S1 B absPreheatHPBTemp</front>
<front id="configuration_storeCPP-56"> *  M145 S1 F absPreheatFanSpeed</front>
<front id="configuration_storeCPP-57"> *</front>
<front id="configuration_storeCPP-58"> * PIDTEMP:</front>
<front id="configuration_storeCPP-59"> *  M301 E0 PIDC  Kp[0], Ki[0], Kd[0], Kc[0]</front>
<front id="configuration_storeCPP-60"> *  M301 E1 PIDC  Kp[1], Ki[1], Kd[1], Kc[1]</front>
<front id="configuration_storeCPP-61"> *  M301 E2 PIDC  Kp[2], Ki[2], Kd[2], Kc[2]</front>
<front id="configuration_storeCPP-62"> *  M301 E3 PIDC  Kp[3], Ki[3], Kd[3], Kc[3]</front>
<front id="configuration_storeCPP-63"> *  M301 L        lpq_len</front>
<front id="configuration_storeCPP-64"> *</front>
<front id="configuration_storeCPP-65"> * PIDTEMPBED:</front>
<front id="configuration_storeCPP-66"> *  M304 PID  bedKp, bedKi, bedKd</front>
<front id="configuration_storeCPP-67"> *</front>
<front id="configuration_storeCPP-68"> * DOGLCD:</front>
<front id="configuration_storeCPP-69"> *  M250 C    lcd_contrast</front>
<front id="configuration_storeCPP-70"> *</front>
<front id="configuration_storeCPP-71"> * SCARA:</front>
<front id="configuration_storeCPP-72"> *  M365 XYZ  axis_scaling (x3)</front>
<front id="configuration_storeCPP-73"> *</front>
<front id="configuration_storeCPP-74"> * FWRETRACT:</front>
<front id="configuration_storeCPP-75"> *  M209 S    autoretract_enabled</front>
<front id="configuration_storeCPP-76"> *  M207 S    retract_length</front>
<front id="configuration_storeCPP-77"> *  M207 W    retract_length_swap</front>
<front id="configuration_storeCPP-78"> *  M207 F    retract_feedrate</front>
<front id="configuration_storeCPP-79"> *  M207 Z    retract_zlift</front>
<front id="configuration_storeCPP-80"> *  M208 S    retract_recover_length</front>
<front id="configuration_storeCPP-81"> *  M208 W    retract_recover_length_swap</front>
<front id="configuration_storeCPP-82"> *  M208 F    retract_recover_feedrate</front>
<front id="configuration_storeCPP-83"> *</front>
<front id="configuration_storeCPP-84"> *  M200 D    volumetric_enabled (D&gt;0 makes this enabled)</front>
<front id="configuration_storeCPP-85"> *</front>
<front id="configuration_storeCPP-86"> *  M200 T D  filament_size (x4) (T0..3)</front>
<front id="configuration_storeCPP-87"> *</front>
<front id="configuration_storeCPP-88"> * Z_DUAL_ENDSTOPS:</front>
<front id="configuration_storeCPP-89"> *  M666 Z    z_endstop_adj</front>
<front id="configuration_storeCPP-90"> *</front>
<front id="configuration_storeCPP-91"> */</front>
<front id="configuration_storeCPP-92">#include "Marlin.h"</front>
<front id="configuration_storeCPP-93">#include "language.h"</front>
<front id="configuration_storeCPP-94">#include "planner.h"</front>
<front id="configuration_storeCPP-95">#include "temperature.h"</front>
<front id="configuration_storeCPP-96">#include "ultralcd.h"</front>
<front id="configuration_storeCPP-97">#include "configuration_store.h"</front>
<front id="configuration_storeCPP-98"></front>
<front id="configuration_storeCPP-99">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="configuration_storeCPP-100">  #include "mesh_bed_leveling.h"</front>
<front id="configuration_storeCPP-101">#endif</front>
<front id="configuration_storeCPP-102"></front>
<front id="configuration_storeCPP-103">void _EEPROM_writeData(int &pos, uint8_t* value, uint8_t size) {</front>
<front id="configuration_storeCPP-104">  uint8_t c;</front>
<front id="configuration_storeCPP-105">  while(size--) {</front>
<front id="configuration_storeCPP-106">    eeprom_write_byte((unsigned char*)pos, *value);</front>
<front id="configuration_storeCPP-107">    c = eeprom_read_byte((unsigned char*)pos);</front>
<front id="configuration_storeCPP-108">    if (c != *value) {</front>
<front id="configuration_storeCPP-109">      SERIAL_ECHO_START;</front>
<front id="configuration_storeCPP-110">      SERIAL_ECHOLNPGM(MSG_ERR_EEPROM_WRITE);</front>
<front id="configuration_storeCPP-111">    }</front>
<front id="configuration_storeCPP-112">    pos++;</front>
<front id="configuration_storeCPP-113">    value++;</front>
<front id="configuration_storeCPP-114">  };</front>
<front id="configuration_storeCPP-115">}</front>
<front id="configuration_storeCPP-116">void _EEPROM_readData(int &pos, uint8_t* value, uint8_t size) {</front>
<front id="configuration_storeCPP-117">  do {</front>
<front id="configuration_storeCPP-118">    *value = eeprom_read_byte((unsigned char*)pos);</front>
<front id="configuration_storeCPP-119">    pos++;</front>
<front id="configuration_storeCPP-120">    value++;</front>
<front id="configuration_storeCPP-121">  } while (--size);</front>
<front id="configuration_storeCPP-122">}</front>
<front id="configuration_storeCPP-123">#define EEPROM_WRITE_VAR(pos, value) _EEPROM_writeData(pos, (uint8_t*)&value, sizeof(value))</front>
<front id="configuration_storeCPP-124">#define EEPROM_READ_VAR(pos, value) _EEPROM_readData(pos, (uint8_t*)&value, sizeof(value))</front>
<front id="configuration_storeCPP-125"></front>
<front id="configuration_storeCPP-126">/**</front>
<front id="configuration_storeCPP-127"> * Store Configuration Settings - M500</front>
<front id="configuration_storeCPP-128"> */</front>
<front id="configuration_storeCPP-129"></front>
<front id="configuration_storeCPP-130">#define DUMMY_PID_VALUE 3000.0f</front>
<front id="configuration_storeCPP-131"></front>
<front id="configuration_storeCPP-132">#define EEPROM_OFFSET 100</front>
<front id="configuration_storeCPP-133"></front>
<front id="configuration_storeCPP-134">#if ENABLED(EEPROM_SETTINGS)</front>
<front id="configuration_storeCPP-135"></front>
<front id="configuration_storeCPP-136">void Config_StoreSettings()  {</front>
<front id="configuration_storeCPP-137">  float dummy = 0.0f;</front>
<front id="configuration_storeCPP-138">  char ver[4] = "000";</front>
<front id="configuration_storeCPP-139">  int i = EEPROM_OFFSET;</front>
<front id="configuration_storeCPP-140">  EEPROM_WRITE_VAR(i, ver); // invalidate data first</front>
<front id="configuration_storeCPP-141">  EEPROM_WRITE_VAR(i, axis_steps_per_unit);</front>
<front id="configuration_storeCPP-142">  EEPROM_WRITE_VAR(i, max_feedrate);</front>
<front id="configuration_storeCPP-143">  EEPROM_WRITE_VAR(i, max_acceleration_units_per_sq_second);</front>
<front id="configuration_storeCPP-144">  EEPROM_WRITE_VAR(i, acceleration);</front>
<front id="configuration_storeCPP-145">  EEPROM_WRITE_VAR(i, retract_acceleration);</front>
<front id="configuration_storeCPP-146">  EEPROM_WRITE_VAR(i, travel_acceleration);</front>
<front id="configuration_storeCPP-147">  EEPROM_WRITE_VAR(i, minimumfeedrate);</front>
<front id="configuration_storeCPP-148">  EEPROM_WRITE_VAR(i, mintravelfeedrate);</front>
<front id="configuration_storeCPP-149">  EEPROM_WRITE_VAR(i, minsegmenttime);</front>
<front id="configuration_storeCPP-150">  EEPROM_WRITE_VAR(i, max_xy_jerk);</front>
<front id="configuration_storeCPP-151">  EEPROM_WRITE_VAR(i, max_z_jerk);</front>
<front id="configuration_storeCPP-152">  EEPROM_WRITE_VAR(i, max_e_jerk);</front>
<front id="configuration_storeCPP-153">  EEPROM_WRITE_VAR(i, home_offset);</front>
<front id="configuration_storeCPP-154"></front>
<front id="configuration_storeCPP-155">  uint8_t mesh_num_x = 3;</front>
<front id="configuration_storeCPP-156">  uint8_t mesh_num_y = 3;</front>
<front id="configuration_storeCPP-157">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="configuration_storeCPP-158">    // Compile time test that sizeof(mbl.z_values) is as expected</front>
<front id="configuration_storeCPP-159">    typedef char c_assert[(sizeof(mbl.z_values) == MESH_NUM_X_POINTS*MESH_NUM_Y_POINTS*sizeof(dummy)) ? 1 : -1];</front>
<front id="configuration_storeCPP-160">    mesh_num_x = MESH_NUM_X_POINTS;</front>
<front id="configuration_storeCPP-161">    mesh_num_y = MESH_NUM_Y_POINTS;</front>
<front id="configuration_storeCPP-162">    EEPROM_WRITE_VAR(i, mbl.active);</front>
<front id="configuration_storeCPP-163">    EEPROM_WRITE_VAR(i, mesh_num_x);</front>
<front id="configuration_storeCPP-164">    EEPROM_WRITE_VAR(i, mesh_num_y);</front>
<front id="configuration_storeCPP-165">    EEPROM_WRITE_VAR(i, mbl.z_values);</front>
<front id="configuration_storeCPP-166">  #else</front>
<front id="configuration_storeCPP-167">    uint8_t dummy_uint8 = 0;</front>
<front id="configuration_storeCPP-168">    EEPROM_WRITE_VAR(i, dummy_uint8);</front>
<front id="configuration_storeCPP-169">    EEPROM_WRITE_VAR(i, mesh_num_x);</front>
<front id="configuration_storeCPP-170">    EEPROM_WRITE_VAR(i, mesh_num_y);</front>
<front id="configuration_storeCPP-171">    dummy = 0.0f;</front>
<front id="configuration_storeCPP-172">    for (uint8_t q=0; q&lt;mesh_num_x*mesh_num_y; q++) EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-173">  #endif // MESH_BED_LEVELING</front>
<front id="configuration_storeCPP-174"></front>
<front id="configuration_storeCPP-175">  #if DISABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="configuration_storeCPP-176">    float zprobe_zoffset = 0;</front>
<front id="configuration_storeCPP-177">  #endif</front>
<front id="configuration_storeCPP-178">  EEPROM_WRITE_VAR(i, zprobe_zoffset);</front>
<front id="configuration_storeCPP-179"></front>
<front id="configuration_storeCPP-180">  #if ENABLED(DELTA)</front>
<front id="configuration_storeCPP-181">    EEPROM_WRITE_VAR(i, endstop_adj);               // 3 floats</front>
<front id="configuration_storeCPP-182">    EEPROM_WRITE_VAR(i, delta_radius);              // 1 float</front>
<front id="configuration_storeCPP-183">    EEPROM_WRITE_VAR(i, delta_diagonal_rod);        // 1 float</front>
<front id="configuration_storeCPP-184">    EEPROM_WRITE_VAR(i, delta_segments_per_second); // 1 float</front>
<front id="configuration_storeCPP-185">  #elif ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="configuration_storeCPP-186">    EEPROM_WRITE_VAR(i, z_endstop_adj);            // 1 floats</front>
<front id="configuration_storeCPP-187">    dummy = 0.0f;</front>
<front id="configuration_storeCPP-188">    for (int q=5; q--;) EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-189">  #else</front>
<front id="configuration_storeCPP-190">    dummy = 0.0f;</front>
<front id="configuration_storeCPP-191">    for (int q=6; q--;) EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-192">  #endif</front>
<front id="configuration_storeCPP-193"></front>
<front id="configuration_storeCPP-194">  #if DISABLED(ULTIPANEL)</front>
<front id="configuration_storeCPP-195">    int plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP, plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP, plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED,</front>
<front id="configuration_storeCPP-196">        absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP, absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP, absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;</front>
<front id="configuration_storeCPP-197">  #endif // !ULTIPANEL</front>
<front id="configuration_storeCPP-198"></front>
<front id="configuration_storeCPP-199">  EEPROM_WRITE_VAR(i, plaPreheatHotendTemp);</front>
<front id="configuration_storeCPP-200">  EEPROM_WRITE_VAR(i, plaPreheatHPBTemp);</front>
<front id="configuration_storeCPP-201">  EEPROM_WRITE_VAR(i, plaPreheatFanSpeed);</front>
<front id="configuration_storeCPP-202">  EEPROM_WRITE_VAR(i, absPreheatHotendTemp);</front>
<front id="configuration_storeCPP-203">  EEPROM_WRITE_VAR(i, absPreheatHPBTemp);</front>
<front id="configuration_storeCPP-204">  EEPROM_WRITE_VAR(i, absPreheatFanSpeed);</front>
<front id="configuration_storeCPP-205"></front>
<front id="configuration_storeCPP-206">  for (int e = 0; e &lt; 4; e++) {</front>
<front id="configuration_storeCPP-207"></front>
<front id="configuration_storeCPP-208">    #if ENABLED(PIDTEMP)</front>
<front id="configuration_storeCPP-209">      if (e &lt; EXTRUDERS) {</front>
<front id="configuration_storeCPP-210">        EEPROM_WRITE_VAR(i, PID_PARAM(Kp, e));</front>
<front id="configuration_storeCPP-211">        EEPROM_WRITE_VAR(i, PID_PARAM(Ki, e));</front>
<front id="configuration_storeCPP-212">        EEPROM_WRITE_VAR(i, PID_PARAM(Kd, e));</front>
<front id="configuration_storeCPP-213">        #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-214">          EEPROM_WRITE_VAR(i, PID_PARAM(Kc, e));</front>
<front id="configuration_storeCPP-215">        #else</front>
<front id="configuration_storeCPP-216">          dummy = 1.0f; // 1.0 = default kc</front>
<front id="configuration_storeCPP-217">          EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-218">        #endif</front>
<front id="configuration_storeCPP-219">      }</front>
<front id="configuration_storeCPP-220">      else</front>
<front id="configuration_storeCPP-221">    #endif // !PIDTEMP</front>
<front id="configuration_storeCPP-222">      {</front>
<front id="configuration_storeCPP-223">        dummy = DUMMY_PID_VALUE; // When read, will not change the existing value</front>
<front id="configuration_storeCPP-224">        EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-225">        dummy = 0.0f;</front>
<front id="configuration_storeCPP-226">        for (int q = 3; q--;) EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-227">      }</front>
<front id="configuration_storeCPP-228"></front>
<front id="configuration_storeCPP-229">  } // Extruders Loop</front>
<front id="configuration_storeCPP-230"></front>
<front id="configuration_storeCPP-231">  #if DISABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-232">    int lpq_len = 20;</front>
<front id="configuration_storeCPP-233">  #endif</front>
<front id="configuration_storeCPP-234">  EEPROM_WRITE_VAR(i, lpq_len);</front>
<front id="configuration_storeCPP-235"></front>
<front id="configuration_storeCPP-236">  #if DISABLED(PIDTEMPBED)</front>
<front id="configuration_storeCPP-237">    float bedKp = DUMMY_PID_VALUE, bedKi = DUMMY_PID_VALUE, bedKd = DUMMY_PID_VALUE;</front>
<front id="configuration_storeCPP-238">  #endif</front>
<front id="configuration_storeCPP-239"></front>
<front id="configuration_storeCPP-240">  EEPROM_WRITE_VAR(i, bedKp);</front>
<front id="configuration_storeCPP-241">  EEPROM_WRITE_VAR(i, bedKi);</front>
<front id="configuration_storeCPP-242">  EEPROM_WRITE_VAR(i, bedKd);</front>
<front id="configuration_storeCPP-243"></front>
<front id="configuration_storeCPP-244">  #if DISABLED(HAS_LCD_CONTRAST)</front>
<front id="configuration_storeCPP-245">    const int lcd_contrast = 32;</front>
<front id="configuration_storeCPP-246">  #endif</front>
<front id="configuration_storeCPP-247">  EEPROM_WRITE_VAR(i, lcd_contrast);</front>
<front id="configuration_storeCPP-248"></front>
<front id="configuration_storeCPP-249">  #if ENABLED(SCARA)</front>
<front id="configuration_storeCPP-250">    EEPROM_WRITE_VAR(i, axis_scaling); // 3 floats</front>
<front id="configuration_storeCPP-251">  #else</front>
<front id="configuration_storeCPP-252">    dummy = 1.0f;</front>
<front id="configuration_storeCPP-253">    EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-254">  #endif</front>
<front id="configuration_storeCPP-255"></front>
<front id="configuration_storeCPP-256">  #if ENABLED(FWRETRACT)</front>
<front id="configuration_storeCPP-257">    EEPROM_WRITE_VAR(i, autoretract_enabled);</front>
<front id="configuration_storeCPP-258">    EEPROM_WRITE_VAR(i, retract_length);</front>
<front id="configuration_storeCPP-259">    #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-260">      EEPROM_WRITE_VAR(i, retract_length_swap);</front>
<front id="configuration_storeCPP-261">    #else</front>
<front id="configuration_storeCPP-262">      dummy = 0.0f;</front>
<front id="configuration_storeCPP-263">      EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-264">    #endif</front>
<front id="configuration_storeCPP-265">    EEPROM_WRITE_VAR(i, retract_feedrate);</front>
<front id="configuration_storeCPP-266">    EEPROM_WRITE_VAR(i, retract_zlift);</front>
<front id="configuration_storeCPP-267">    EEPROM_WRITE_VAR(i, retract_recover_length);</front>
<front id="configuration_storeCPP-268">    #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-269">      EEPROM_WRITE_VAR(i, retract_recover_length_swap);</front>
<front id="configuration_storeCPP-270">    #else</front>
<front id="configuration_storeCPP-271">      dummy = 0.0f;</front>
<front id="configuration_storeCPP-272">      EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-273">    #endif</front>
<front id="configuration_storeCPP-274">    EEPROM_WRITE_VAR(i, retract_recover_feedrate);</front>
<front id="configuration_storeCPP-275">  #endif // FWRETRACT</front>
<front id="configuration_storeCPP-276"></front>
<front id="configuration_storeCPP-277">  EEPROM_WRITE_VAR(i, volumetric_enabled);</front>
<front id="configuration_storeCPP-278"></front>
<front id="configuration_storeCPP-279">  // Save filament sizes</front>
<front id="configuration_storeCPP-280">  for (int q = 0; q &lt; 4; q++) {</front>
<front id="configuration_storeCPP-281">    if (q &lt; EXTRUDERS) dummy = filament_size[q];</front>
<front id="configuration_storeCPP-282">    EEPROM_WRITE_VAR(i, dummy);</front>
<front id="configuration_storeCPP-283">  }</front>
<front id="configuration_storeCPP-284"></front>
<front id="configuration_storeCPP-285">  char ver2[4] = EEPROM_VERSION;</front>
<front id="configuration_storeCPP-286">  int j = EEPROM_OFFSET;</front>
<front id="configuration_storeCPP-287">  EEPROM_WRITE_VAR(j, ver2); // validate data</front>
<front id="configuration_storeCPP-288"></front>
<front id="configuration_storeCPP-289">  // Report storage size</front>
<front id="configuration_storeCPP-290">  SERIAL_ECHO_START;</front>
<front id="configuration_storeCPP-291">  SERIAL_ECHOPAIR("Settings Stored (", (unsigned long)i);</front>
<front id="configuration_storeCPP-292">  SERIAL_ECHOLNPGM(" bytes)");</front>
<front id="configuration_storeCPP-293">}</front>
<front id="configuration_storeCPP-294"></front>
<front id="configuration_storeCPP-295">/**</front>
<front id="configuration_storeCPP-296"> * Retrieve Configuration Settings - M501</front>
<front id="configuration_storeCPP-297"> */</front>
<front id="configuration_storeCPP-298"></front>
<front id="configuration_storeCPP-299">void Config_RetrieveSettings() {</front>
<front id="configuration_storeCPP-300"></front>
<front id="configuration_storeCPP-301">  int i = EEPROM_OFFSET;</front>
<front id="configuration_storeCPP-302">  char stored_ver[4];</front>
<front id="configuration_storeCPP-303">  char ver[4] = EEPROM_VERSION;</front>
<front id="configuration_storeCPP-304">  EEPROM_READ_VAR(i, stored_ver); //read stored version</front>
<front id="configuration_storeCPP-305">  //  SERIAL_ECHOLN("Version: [" &lt;&lt; ver &lt;&lt; "] Stored version: [" &lt;&lt; stored_ver &lt;&lt; "]");</front>
<front id="configuration_storeCPP-306"></front>
<front id="configuration_storeCPP-307">  if (strncmp(ver, stored_ver, 3) != 0) {</front>
<front id="configuration_storeCPP-308">    Config_ResetDefault();</front>
<front id="configuration_storeCPP-309">  }</front>
<front id="configuration_storeCPP-310">  else {</front>
<front id="configuration_storeCPP-311">    float dummy = 0;</front>
<front id="configuration_storeCPP-312"></front>
<front id="configuration_storeCPP-313">    // version number match</front>
<front id="configuration_storeCPP-314">    EEPROM_READ_VAR(i, axis_steps_per_unit);</front>
<front id="configuration_storeCPP-315">    EEPROM_READ_VAR(i, max_feedrate);</front>
<front id="configuration_storeCPP-316">    EEPROM_READ_VAR(i, max_acceleration_units_per_sq_second);</front>
<front id="configuration_storeCPP-317"></front>
<front id="configuration_storeCPP-318">    // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</front>
<front id="configuration_storeCPP-319">    reset_acceleration_rates();</front>
<front id="configuration_storeCPP-320"></front>
<front id="configuration_storeCPP-321">    EEPROM_READ_VAR(i, acceleration);</front>
<front id="configuration_storeCPP-322">    EEPROM_READ_VAR(i, retract_acceleration);</front>
<front id="configuration_storeCPP-323">    EEPROM_READ_VAR(i, travel_acceleration);</front>
<front id="configuration_storeCPP-324">    EEPROM_READ_VAR(i, minimumfeedrate);</front>
<front id="configuration_storeCPP-325">    EEPROM_READ_VAR(i, mintravelfeedrate);</front>
<front id="configuration_storeCPP-326">    EEPROM_READ_VAR(i, minsegmenttime);</front>
<front id="configuration_storeCPP-327">    EEPROM_READ_VAR(i, max_xy_jerk);</front>
<front id="configuration_storeCPP-328">    EEPROM_READ_VAR(i, max_z_jerk);</front>
<front id="configuration_storeCPP-329">    EEPROM_READ_VAR(i, max_e_jerk);</front>
<front id="configuration_storeCPP-330">    EEPROM_READ_VAR(i, home_offset);</front>
<front id="configuration_storeCPP-331"></front>
<front id="configuration_storeCPP-332">    uint8_t dummy_uint8 = 0, mesh_num_x = 0, mesh_num_y = 0;</front>
<front id="configuration_storeCPP-333">    EEPROM_READ_VAR(i, dummy_uint8);</front>
<front id="configuration_storeCPP-334">    EEPROM_READ_VAR(i, mesh_num_x);</front>
<front id="configuration_storeCPP-335">    EEPROM_READ_VAR(i, mesh_num_y);</front>
<front id="configuration_storeCPP-336">    #if ENABLED(MESH_BED_LEVELING)</front>
<front id="configuration_storeCPP-337">      mbl.active = dummy_uint8;</front>
<front id="configuration_storeCPP-338">      if (mesh_num_x == MESH_NUM_X_POINTS && mesh_num_y == MESH_NUM_Y_POINTS) {</front>
<front id="configuration_storeCPP-339">        EEPROM_READ_VAR(i, mbl.z_values);</front>
<front id="configuration_storeCPP-340">      } else {</front>
<front id="configuration_storeCPP-341">        mbl.reset();</front>
<front id="configuration_storeCPP-342">        for (int q = 0; q &lt; mesh_num_x * mesh_num_y; q++) EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-343">      }</front>
<front id="configuration_storeCPP-344">    #else</front>
<front id="configuration_storeCPP-345">      for (int q = 0; q &lt; mesh_num_x * mesh_num_y; q++) EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-346">    #endif // MESH_BED_LEVELING</front>
<front id="configuration_storeCPP-347"></front>
<front id="configuration_storeCPP-348">    #if DISABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="configuration_storeCPP-349">      float zprobe_zoffset = 0;</front>
<front id="configuration_storeCPP-350">    #endif</front>
<front id="configuration_storeCPP-351">    EEPROM_READ_VAR(i, zprobe_zoffset);</front>
<front id="configuration_storeCPP-352"></front>
<front id="configuration_storeCPP-353">    #if ENABLED(DELTA)</front>
<front id="configuration_storeCPP-354">      EEPROM_READ_VAR(i, endstop_adj);                // 3 floats</front>
<front id="configuration_storeCPP-355">      EEPROM_READ_VAR(i, delta_radius);               // 1 float</front>
<front id="configuration_storeCPP-356">      EEPROM_READ_VAR(i, delta_diagonal_rod);         // 1 float</front>
<front id="configuration_storeCPP-357">      EEPROM_READ_VAR(i, delta_segments_per_second);  // 1 float</front>
<front id="configuration_storeCPP-358">    #elif ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="configuration_storeCPP-359">      EEPROM_READ_VAR(i, z_endstop_adj);</front>
<front id="configuration_storeCPP-360">      dummy = 0.0f;</front>
<front id="configuration_storeCPP-361">      for (int q=5; q--;) EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-362">    #else</front>
<front id="configuration_storeCPP-363">      dummy = 0.0f;</front>
<front id="configuration_storeCPP-364">      for (int q=6; q--;) EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-365">    #endif</front>
<front id="configuration_storeCPP-366"></front>
<front id="configuration_storeCPP-367">    #if DISABLED(ULTIPANEL)</front>
<front id="configuration_storeCPP-368">      int plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed,</front>
<front id="configuration_storeCPP-369">          absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed;</front>
<front id="configuration_storeCPP-370">    #endif</front>
<front id="configuration_storeCPP-371"></front>
<front id="configuration_storeCPP-372">    EEPROM_READ_VAR(i, plaPreheatHotendTemp);</front>
<front id="configuration_storeCPP-373">    EEPROM_READ_VAR(i, plaPreheatHPBTemp);</front>
<front id="configuration_storeCPP-374">    EEPROM_READ_VAR(i, plaPreheatFanSpeed);</front>
<front id="configuration_storeCPP-375">    EEPROM_READ_VAR(i, absPreheatHotendTemp);</front>
<front id="configuration_storeCPP-376">    EEPROM_READ_VAR(i, absPreheatHPBTemp);</front>
<front id="configuration_storeCPP-377">    EEPROM_READ_VAR(i, absPreheatFanSpeed);</front>
<front id="configuration_storeCPP-378"></front>
<front id="configuration_storeCPP-379">    #if ENABLED(PIDTEMP)</front>
<front id="configuration_storeCPP-380">      for (int e = 0; e &lt; 4; e++) { // 4 = max extruders currently supported by Marlin</front>
<front id="configuration_storeCPP-381">        EEPROM_READ_VAR(i, dummy); // Kp</front>
<front id="configuration_storeCPP-382">        if (e &lt; EXTRUDERS && dummy != DUMMY_PID_VALUE) {</front>
<front id="configuration_storeCPP-383">          // do not need to scale PID values as the values in EEPROM are already scaled</front>
<front id="configuration_storeCPP-384">          PID_PARAM(Kp, e) = dummy;</front>
<front id="configuration_storeCPP-385">          EEPROM_READ_VAR(i, PID_PARAM(Ki, e));</front>
<front id="configuration_storeCPP-386">          EEPROM_READ_VAR(i, PID_PARAM(Kd, e));</front>
<front id="configuration_storeCPP-387">          #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-388">            EEPROM_READ_VAR(i, PID_PARAM(Kc, e));</front>
<front id="configuration_storeCPP-389">          #else</front>
<front id="configuration_storeCPP-390">            EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-391">          #endif</front>
<front id="configuration_storeCPP-392">        }</front>
<front id="configuration_storeCPP-393">        else {</front>
<front id="configuration_storeCPP-394">          for (int q=3; q--;) EEPROM_READ_VAR(i, dummy); // Ki, Kd, Kc</front>
<front id="configuration_storeCPP-395">        }</front>
<front id="configuration_storeCPP-396">      }</front>
<front id="configuration_storeCPP-397">    #else // !PIDTEMP</front>
<front id="configuration_storeCPP-398">      // 4 x 4 = 16 slots for PID parameters</front>
<front id="configuration_storeCPP-399">      for (int q=16; q--;) EEPROM_READ_VAR(i, dummy);  // 4x Kp, Ki, Kd, Kc</front>
<front id="configuration_storeCPP-400">    #endif // !PIDTEMP</front>
<front id="configuration_storeCPP-401"></front>
<front id="configuration_storeCPP-402">    #if DISABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-403">      int lpq_len;</front>
<front id="configuration_storeCPP-404">    #endif</front>
<front id="configuration_storeCPP-405">    EEPROM_READ_VAR(i, lpq_len);</front>
<front id="configuration_storeCPP-406"></front>
<front id="configuration_storeCPP-407">    #if DISABLED(PIDTEMPBED)</front>
<front id="configuration_storeCPP-408">      float bedKp, bedKi, bedKd;</front>
<front id="configuration_storeCPP-409">    #endif</front>
<front id="configuration_storeCPP-410"></front>
<front id="configuration_storeCPP-411">    EEPROM_READ_VAR(i, dummy); // bedKp</front>
<front id="configuration_storeCPP-412">    if (dummy != DUMMY_PID_VALUE) {</front>
<front id="configuration_storeCPP-413">      bedKp = dummy;</front>
<front id="configuration_storeCPP-414">      EEPROM_READ_VAR(i, bedKi);</front>
<front id="configuration_storeCPP-415">      EEPROM_READ_VAR(i, bedKd);</front>
<front id="configuration_storeCPP-416">    }</front>
<front id="configuration_storeCPP-417">    else {</front>
<front id="configuration_storeCPP-418">      for (int q=2; q--;) EEPROM_READ_VAR(i, dummy); // bedKi, bedKd</front>
<front id="configuration_storeCPP-419">    }</front>
<front id="configuration_storeCPP-420"></front>
<front id="configuration_storeCPP-421">    #if DISABLED(HAS_LCD_CONTRAST)</front>
<front id="configuration_storeCPP-422">      int lcd_contrast;</front>
<front id="configuration_storeCPP-423">    #endif</front>
<front id="configuration_storeCPP-424">    EEPROM_READ_VAR(i, lcd_contrast);</front>
<front id="configuration_storeCPP-425"></front>
<front id="configuration_storeCPP-426">    #if ENABLED(SCARA)</front>
<front id="configuration_storeCPP-427">      EEPROM_READ_VAR(i, axis_scaling);  // 3 floats</front>
<front id="configuration_storeCPP-428">    #else</front>
<front id="configuration_storeCPP-429">      EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-430">    #endif</front>
<front id="configuration_storeCPP-431"></front>
<front id="configuration_storeCPP-432">    #if ENABLED(FWRETRACT)</front>
<front id="configuration_storeCPP-433">      EEPROM_READ_VAR(i, autoretract_enabled);</front>
<front id="configuration_storeCPP-434">      EEPROM_READ_VAR(i, retract_length);</front>
<front id="configuration_storeCPP-435">      #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-436">        EEPROM_READ_VAR(i, retract_length_swap);</front>
<front id="configuration_storeCPP-437">      #else</front>
<front id="configuration_storeCPP-438">        EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-439">      #endif</front>
<front id="configuration_storeCPP-440">      EEPROM_READ_VAR(i, retract_feedrate);</front>
<front id="configuration_storeCPP-441">      EEPROM_READ_VAR(i, retract_zlift);</front>
<front id="configuration_storeCPP-442">      EEPROM_READ_VAR(i, retract_recover_length);</front>
<front id="configuration_storeCPP-443">      #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-444">        EEPROM_READ_VAR(i, retract_recover_length_swap);</front>
<front id="configuration_storeCPP-445">      #else</front>
<front id="configuration_storeCPP-446">        EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-447">      #endif</front>
<front id="configuration_storeCPP-448">      EEPROM_READ_VAR(i, retract_recover_feedrate);</front>
<front id="configuration_storeCPP-449">    #endif // FWRETRACT</front>
<front id="configuration_storeCPP-450"></front>
<front id="configuration_storeCPP-451">    EEPROM_READ_VAR(i, volumetric_enabled);</front>
<front id="configuration_storeCPP-452"></front>
<front id="configuration_storeCPP-453">    for (int q = 0; q &lt; 4; q++) {</front>
<front id="configuration_storeCPP-454">      EEPROM_READ_VAR(i, dummy);</front>
<front id="configuration_storeCPP-455">      if (q &lt; EXTRUDERS) filament_size[q] = dummy;</front>
<front id="configuration_storeCPP-456">    }</front>
<front id="configuration_storeCPP-457"></front>
<front id="configuration_storeCPP-458">    calculate_volumetric_multipliers();</front>
<front id="configuration_storeCPP-459">    // Call updatePID (similar to when we have processed M301)</front>
<front id="configuration_storeCPP-460">    updatePID();</front>
<front id="configuration_storeCPP-461"></front>
<front id="configuration_storeCPP-462">    // Report settings retrieved and length</front>
<front id="configuration_storeCPP-463">    SERIAL_ECHO_START;</front>
<front id="configuration_storeCPP-464">    SERIAL_ECHO(ver);</front>
<front id="configuration_storeCPP-465">    SERIAL_ECHOPAIR(" stored settings retrieved (", (unsigned long)i);</front>
<front id="configuration_storeCPP-466">    SERIAL_ECHOLNPGM(" bytes)");</front>
<front id="configuration_storeCPP-467">  }</front>
<front id="configuration_storeCPP-468"></front>
<front id="configuration_storeCPP-469">  #if ENABLED(EEPROM_CHITCHAT)</front>
<front id="configuration_storeCPP-470">    Config_PrintSettings();</front>
<front id="configuration_storeCPP-471">  #endif</front>
<front id="configuration_storeCPP-472">}</front>
<front id="configuration_storeCPP-473"></front>
<front id="configuration_storeCPP-474">#endif // EEPROM_SETTINGS</front>
<front id="configuration_storeCPP-475"></front>
<front id="configuration_storeCPP-476">/**</front>
<front id="configuration_storeCPP-477"> * Reset Configuration Settings - M502</front>
<front id="configuration_storeCPP-478"> */</front>
<front id="configuration_storeCPP-479"></front>
<front id="configuration_storeCPP-480">void Config_ResetDefault() {</front>
<front id="configuration_storeCPP-481">  float tmp1[] = DEFAULT_AXIS_STEPS_PER_UNIT;</front>
<front id="configuration_storeCPP-482">  float tmp2[] = DEFAULT_MAX_FEEDRATE;</front>
<front id="configuration_storeCPP-483">  long tmp3[] = DEFAULT_MAX_ACCELERATION;</front>
<front id="configuration_storeCPP-484">  for (uint8_t i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="configuration_storeCPP-485">    axis_steps_per_unit[i] = tmp1[i];</front>
<front id="configuration_storeCPP-486">    max_feedrate[i] = tmp2[i];</front>
<front id="configuration_storeCPP-487">    max_acceleration_units_per_sq_second[i] = tmp3[i];</front>
<front id="configuration_storeCPP-488">    #if ENABLED(SCARA)</front>
<front id="configuration_storeCPP-489">      if (i &lt; COUNT(axis_scaling))</front>
<front id="configuration_storeCPP-490">        axis_scaling[i] = 1;</front>
<front id="configuration_storeCPP-491">    #endif</front>
<front id="configuration_storeCPP-492">  }</front>
<front id="configuration_storeCPP-493"></front>
<front id="configuration_storeCPP-494">  // steps per sq second need to be updated to agree with the units per sq second</front>
<front id="configuration_storeCPP-495">  reset_acceleration_rates();</front>
<front id="configuration_storeCPP-496"></front>
<front id="configuration_storeCPP-497">  acceleration = DEFAULT_ACCELERATION;</front>
<front id="configuration_storeCPP-498">  retract_acceleration = DEFAULT_RETRACT_ACCELERATION;</front>
<front id="configuration_storeCPP-499">  travel_acceleration = DEFAULT_TRAVEL_ACCELERATION;</front>
<front id="configuration_storeCPP-500">  minimumfeedrate = DEFAULT_MINIMUMFEEDRATE;</front>
<front id="configuration_storeCPP-501">  minsegmenttime = DEFAULT_MINSEGMENTTIME;</front>
<front id="configuration_storeCPP-502">  mintravelfeedrate = DEFAULT_MINTRAVELFEEDRATE;</front>
<front id="configuration_storeCPP-503">  max_xy_jerk = DEFAULT_XYJERK;</front>
<front id="configuration_storeCPP-504">  max_z_jerk = DEFAULT_ZJERK;</front>
<front id="configuration_storeCPP-505">  max_e_jerk = DEFAULT_EJERK;</front>
<front id="configuration_storeCPP-506">  home_offset[X_AXIS] = home_offset[Y_AXIS] = home_offset[Z_AXIS] = 0;</front>
<front id="configuration_storeCPP-507"></front>
<front id="configuration_storeCPP-508">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="configuration_storeCPP-509">    mbl.active = 0;</front>
<front id="configuration_storeCPP-510">  #endif</front>
<front id="configuration_storeCPP-511"></front>
<front id="configuration_storeCPP-512">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="configuration_storeCPP-513">    zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="configuration_storeCPP-514">  #endif</front>
<front id="configuration_storeCPP-515"></front>
<front id="configuration_storeCPP-516">  #if ENABLED(DELTA)</front>
<front id="configuration_storeCPP-517">    endstop_adj[X_AXIS] = endstop_adj[Y_AXIS] = endstop_adj[Z_AXIS] = 0;</front>
<front id="configuration_storeCPP-518">    delta_radius =  DELTA_RADIUS;</front>
<front id="configuration_storeCPP-519">    delta_diagonal_rod =  DELTA_DIAGONAL_ROD;</front>
<front id="configuration_storeCPP-520">    delta_segments_per_second =  DELTA_SEGMENTS_PER_SECOND;</front>
<front id="configuration_storeCPP-521">    recalc_delta_settings(delta_radius, delta_diagonal_rod);</front>
<front id="configuration_storeCPP-522">  #elif ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="configuration_storeCPP-523">    z_endstop_adj = 0;</front>
<front id="configuration_storeCPP-524">  #endif</front>
<front id="configuration_storeCPP-525"></front>
<front id="configuration_storeCPP-526">  #if ENABLED(ULTIPANEL)</front>
<front id="configuration_storeCPP-527">    plaPreheatHotendTemp = PLA_PREHEAT_HOTEND_TEMP;</front>
<front id="configuration_storeCPP-528">    plaPreheatHPBTemp = PLA_PREHEAT_HPB_TEMP;</front>
<front id="configuration_storeCPP-529">    plaPreheatFanSpeed = PLA_PREHEAT_FAN_SPEED;</front>
<front id="configuration_storeCPP-530">    absPreheatHotendTemp = ABS_PREHEAT_HOTEND_TEMP;</front>
<front id="configuration_storeCPP-531">    absPreheatHPBTemp = ABS_PREHEAT_HPB_TEMP;</front>
<front id="configuration_storeCPP-532">    absPreheatFanSpeed = ABS_PREHEAT_FAN_SPEED;</front>
<front id="configuration_storeCPP-533">  #endif</front>
<front id="configuration_storeCPP-534"></front>
<front id="configuration_storeCPP-535">  #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="configuration_storeCPP-536">    lcd_contrast = DEFAULT_LCD_CONTRAST;</front>
<front id="configuration_storeCPP-537">  #endif</front>
<front id="configuration_storeCPP-538"></front>
<front id="configuration_storeCPP-539">  #if ENABLED(PIDTEMP)</front>
<front id="configuration_storeCPP-540">    #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="configuration_storeCPP-541">      for (int e = 0; e &lt; EXTRUDERS; e++)</front>
<front id="configuration_storeCPP-542">    #else</front>
<front id="configuration_storeCPP-543">      int e = 0; // only need to write once</front>
<front id="configuration_storeCPP-544">    #endif</front>
<front id="configuration_storeCPP-545">    {</front>
<front id="configuration_storeCPP-546">      PID_PARAM(Kp, e) = DEFAULT_Kp;</front>
<front id="configuration_storeCPP-547">      PID_PARAM(Ki, e) = scalePID_i(DEFAULT_Ki);</front>
<front id="configuration_storeCPP-548">      PID_PARAM(Kd, e) = scalePID_d(DEFAULT_Kd);</front>
<front id="configuration_storeCPP-549">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-550">        PID_PARAM(Kc, e) = DEFAULT_Kc;</front>
<front id="configuration_storeCPP-551">      #endif</front>
<front id="configuration_storeCPP-552">    }</front>
<front id="configuration_storeCPP-553">    #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-554">      lpq_len = 20; // default last-position-queue size</front>
<front id="configuration_storeCPP-555">    #endif</front>
<front id="configuration_storeCPP-556">    // call updatePID (similar to when we have processed M301)</front>
<front id="configuration_storeCPP-557">    updatePID();</front>
<front id="configuration_storeCPP-558">  #endif // PIDTEMP</front>
<front id="configuration_storeCPP-559"></front>
<front id="configuration_storeCPP-560">  #if ENABLED(PIDTEMPBED)</front>
<front id="configuration_storeCPP-561">    bedKp = DEFAULT_bedKp;</front>
<front id="configuration_storeCPP-562">    bedKi = scalePID_i(DEFAULT_bedKi);</front>
<front id="configuration_storeCPP-563">    bedKd = scalePID_d(DEFAULT_bedKd);</front>
<front id="configuration_storeCPP-564">  #endif</front>
<front id="configuration_storeCPP-565"></front>
<front id="configuration_storeCPP-566">  #if ENABLED(FWRETRACT)</front>
<front id="configuration_storeCPP-567">    autoretract_enabled = false;</front>
<front id="configuration_storeCPP-568">    retract_length = RETRACT_LENGTH;</front>
<front id="configuration_storeCPP-569">    #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-570">      retract_length_swap = RETRACT_LENGTH_SWAP;</front>
<front id="configuration_storeCPP-571">    #endif</front>
<front id="configuration_storeCPP-572">    retract_feedrate = RETRACT_FEEDRATE;</front>
<front id="configuration_storeCPP-573">    retract_zlift = RETRACT_ZLIFT;</front>
<front id="configuration_storeCPP-574">    retract_recover_length = RETRACT_RECOVER_LENGTH;</front>
<front id="configuration_storeCPP-575">    #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-576">      retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;</front>
<front id="configuration_storeCPP-577">    #endif</front>
<front id="configuration_storeCPP-578">    retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;</front>
<front id="configuration_storeCPP-579">  #endif</front>
<front id="configuration_storeCPP-580"></front>
<front id="configuration_storeCPP-581">  volumetric_enabled = false;</front>
<front id="configuration_storeCPP-582">  for (uint8_t q=0; q&lt;COUNT(filament_size); q++)</front>
<front id="configuration_storeCPP-583">    filament_size[q] = DEFAULT_NOMINAL_FILAMENT_DIA;</front>
<front id="configuration_storeCPP-584">  calculate_volumetric_multipliers();</front>
<front id="configuration_storeCPP-585"></front>
<front id="configuration_storeCPP-586">  SERIAL_ECHO_START;</front>
<front id="configuration_storeCPP-587">  SERIAL_ECHOLNPGM("Hardcoded Default Settings Loaded");</front>
<front id="configuration_storeCPP-588">}</front>
<front id="configuration_storeCPP-589"></front>
<front id="configuration_storeCPP-590">#if DISABLED(DISABLE_M503)</front>
<front id="configuration_storeCPP-591"></front>
<front id="configuration_storeCPP-592">/**</front>
<front id="configuration_storeCPP-593"> * Print Configuration Settings - M503</front>
<front id="configuration_storeCPP-594"> */</front>
<front id="configuration_storeCPP-595"></front>
<front id="configuration_storeCPP-596">#define CONFIG_ECHO_START do{ if (!forReplay) SERIAL_ECHO_START; }while(0)</front>
<front id="configuration_storeCPP-597"></front>
<front id="configuration_storeCPP-598">void Config_PrintSettings(bool forReplay) {</front>
<front id="configuration_storeCPP-599">  // Always have this function, even with EEPROM_SETTINGS disabled, the current values will be shown</front>
<front id="configuration_storeCPP-600"></front>
<front id="configuration_storeCPP-601">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-602"></front>
<front id="configuration_storeCPP-603">  if (!forReplay) {</front>
<front id="configuration_storeCPP-604">    SERIAL_ECHOLNPGM("Steps per unit:");</front>
<front id="configuration_storeCPP-605">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-606">  }</front>
<front id="configuration_storeCPP-607">  SERIAL_ECHOPAIR("  M92 X", axis_steps_per_unit[X_AXIS]);</front>
<front id="configuration_storeCPP-608">  SERIAL_ECHOPAIR(" Y", axis_steps_per_unit[Y_AXIS]);</front>
<front id="configuration_storeCPP-609">  SERIAL_ECHOPAIR(" Z", axis_steps_per_unit[Z_AXIS]);</front>
<front id="configuration_storeCPP-610">  SERIAL_ECHOPAIR(" E", axis_steps_per_unit[E_AXIS]);</front>
<front id="configuration_storeCPP-611">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-612"></front>
<front id="configuration_storeCPP-613">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-614"></front>
<front id="configuration_storeCPP-615">  #if ENABLED(SCARA)</front>
<front id="configuration_storeCPP-616">    if (!forReplay) {</front>
<front id="configuration_storeCPP-617">      SERIAL_ECHOLNPGM("Scaling factors:");</front>
<front id="configuration_storeCPP-618">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-619">    }</front>
<front id="configuration_storeCPP-620">    SERIAL_ECHOPAIR("  M365 X", axis_scaling[X_AXIS]);</front>
<front id="configuration_storeCPP-621">    SERIAL_ECHOPAIR(" Y", axis_scaling[Y_AXIS]);</front>
<front id="configuration_storeCPP-622">    SERIAL_ECHOPAIR(" Z", axis_scaling[Z_AXIS]);</front>
<front id="configuration_storeCPP-623">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-624">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-625">  #endif // SCARA</front>
<front id="configuration_storeCPP-626"></front>
<front id="configuration_storeCPP-627">  if (!forReplay) {</front>
<front id="configuration_storeCPP-628">    SERIAL_ECHOLNPGM("Maximum feedrates (mm/s):");</front>
<front id="configuration_storeCPP-629">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-630">  }</front>
<front id="configuration_storeCPP-631">  SERIAL_ECHOPAIR("  M203 X", max_feedrate[X_AXIS]);</front>
<front id="configuration_storeCPP-632">  SERIAL_ECHOPAIR(" Y", max_feedrate[Y_AXIS]);</front>
<front id="configuration_storeCPP-633">  SERIAL_ECHOPAIR(" Z", max_feedrate[Z_AXIS]);</front>
<front id="configuration_storeCPP-634">  SERIAL_ECHOPAIR(" E", max_feedrate[E_AXIS]);</front>
<front id="configuration_storeCPP-635">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-636"></front>
<front id="configuration_storeCPP-637">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-638">  if (!forReplay) {</front>
<front id="configuration_storeCPP-639">    SERIAL_ECHOLNPGM("Maximum Acceleration (mm/s2):");</front>
<front id="configuration_storeCPP-640">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-641">  }</front>
<front id="configuration_storeCPP-642">  SERIAL_ECHOPAIR("  M201 X", max_acceleration_units_per_sq_second[X_AXIS]);</front>
<front id="configuration_storeCPP-643">  SERIAL_ECHOPAIR(" Y", max_acceleration_units_per_sq_second[Y_AXIS]);</front>
<front id="configuration_storeCPP-644">  SERIAL_ECHOPAIR(" Z", max_acceleration_units_per_sq_second[Z_AXIS]);</front>
<front id="configuration_storeCPP-645">  SERIAL_ECHOPAIR(" E", max_acceleration_units_per_sq_second[E_AXIS]);</front>
<front id="configuration_storeCPP-646">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-647">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-648">  if (!forReplay) {</front>
<front id="configuration_storeCPP-649">    SERIAL_ECHOLNPGM("Accelerations: P=printing, R=retract and T=travel");</front>
<front id="configuration_storeCPP-650">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-651">  }</front>
<front id="configuration_storeCPP-652">  SERIAL_ECHOPAIR("  M204 P", acceleration);</front>
<front id="configuration_storeCPP-653">  SERIAL_ECHOPAIR(" R", retract_acceleration);</front>
<front id="configuration_storeCPP-654">  SERIAL_ECHOPAIR(" T", travel_acceleration);</front>
<front id="configuration_storeCPP-655">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-656"></front>
<front id="configuration_storeCPP-657">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-658">  if (!forReplay) {</front>
<front id="configuration_storeCPP-659">    SERIAL_ECHOLNPGM("Advanced variables: S=Min feedrate (mm/s), T=Min travel feedrate (mm/s), B=minimum segment time (ms), X=maximum XY jerk (mm/s),  Z=maximum Z jerk (mm/s),  E=maximum E jerk (mm/s)");</front>
<front id="configuration_storeCPP-660">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-661">  }</front>
<front id="configuration_storeCPP-662">  SERIAL_ECHOPAIR("  M205 S", minimumfeedrate);</front>
<front id="configuration_storeCPP-663">  SERIAL_ECHOPAIR(" T", mintravelfeedrate);</front>
<front id="configuration_storeCPP-664">  SERIAL_ECHOPAIR(" B", minsegmenttime);</front>
<front id="configuration_storeCPP-665">  SERIAL_ECHOPAIR(" X", max_xy_jerk);</front>
<front id="configuration_storeCPP-666">  SERIAL_ECHOPAIR(" Z", max_z_jerk);</front>
<front id="configuration_storeCPP-667">  SERIAL_ECHOPAIR(" E", max_e_jerk);</front>
<front id="configuration_storeCPP-668">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-669"></front>
<front id="configuration_storeCPP-670">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-671">  if (!forReplay) {</front>
<front id="configuration_storeCPP-672">    SERIAL_ECHOLNPGM("Home offset (mm):");</front>
<front id="configuration_storeCPP-673">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-674">  }</front>
<front id="configuration_storeCPP-675">  SERIAL_ECHOPAIR("  M206 X", home_offset[X_AXIS]);</front>
<front id="configuration_storeCPP-676">  SERIAL_ECHOPAIR(" Y", home_offset[Y_AXIS]);</front>
<front id="configuration_storeCPP-677">  SERIAL_ECHOPAIR(" Z", home_offset[Z_AXIS]);</front>
<front id="configuration_storeCPP-678">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-679"></front>
<front id="configuration_storeCPP-680">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="configuration_storeCPP-681">    if (!forReplay) {</front>
<front id="configuration_storeCPP-682">      SERIAL_ECHOLNPGM("Mesh bed leveling:");</front>
<front id="configuration_storeCPP-683">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-684">    }</front>
<front id="configuration_storeCPP-685">    SERIAL_ECHOPAIR("  M420 S", (unsigned long)mbl.active);</front>
<front id="configuration_storeCPP-686">    SERIAL_ECHOPAIR(" X", (unsigned long)MESH_NUM_X_POINTS);</front>
<front id="configuration_storeCPP-687">    SERIAL_ECHOPAIR(" Y", (unsigned long)MESH_NUM_Y_POINTS);</front>
<front id="configuration_storeCPP-688">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-689">    for (int y=0; y&lt;MESH_NUM_Y_POINTS; y++) {</front>
<front id="configuration_storeCPP-690">      for (int x=0; x&lt;MESH_NUM_X_POINTS; x++) {</front>
<front id="configuration_storeCPP-691">        CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-692">        SERIAL_ECHOPAIR("  M421 X", mbl.get_x(x));</front>
<front id="configuration_storeCPP-693">        SERIAL_ECHOPAIR(" Y", mbl.get_y(y));</front>
<front id="configuration_storeCPP-694">        SERIAL_ECHOPAIR(" Z", mbl.z_values[y][x]);</front>
<front id="configuration_storeCPP-695">        SERIAL_EOL;</front>
<front id="configuration_storeCPP-696">      }</front>
<front id="configuration_storeCPP-697">    }</front>
<front id="configuration_storeCPP-698">  #endif</front>
<front id="configuration_storeCPP-699"></front>
<front id="configuration_storeCPP-700">  #if ENABLED(DELTA)</front>
<front id="configuration_storeCPP-701">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-702">    if (!forReplay) {</front>
<front id="configuration_storeCPP-703">      SERIAL_ECHOLNPGM("Endstop adjustment (mm):");</front>
<front id="configuration_storeCPP-704">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-705">    }</front>
<front id="configuration_storeCPP-706">    SERIAL_ECHOPAIR("  M666 X", endstop_adj[X_AXIS]);</front>
<front id="configuration_storeCPP-707">    SERIAL_ECHOPAIR(" Y", endstop_adj[Y_AXIS]);</front>
<front id="configuration_storeCPP-708">    SERIAL_ECHOPAIR(" Z", endstop_adj[Z_AXIS]);</front>
<front id="configuration_storeCPP-709">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-710">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-711">    SERIAL_ECHOLNPGM("Delta settings: L=delta_diagonal_rod, R=delta_radius, S=delta_segments_per_second");</front>
<front id="configuration_storeCPP-712">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-713">    SERIAL_ECHOPAIR("  M665 L", delta_diagonal_rod);</front>
<front id="configuration_storeCPP-714">    SERIAL_ECHOPAIR(" R", delta_radius);</front>
<front id="configuration_storeCPP-715">    SERIAL_ECHOPAIR(" S", delta_segments_per_second);</front>
<front id="configuration_storeCPP-716">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-717">  #elif ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="configuration_storeCPP-718">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-719">    if (!forReplay) {</front>
<front id="configuration_storeCPP-720">      SERIAL_ECHOLNPGM("Z2 Endstop adjustment (mm):");</front>
<front id="configuration_storeCPP-721">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-722">    }</front>
<front id="configuration_storeCPP-723">    SERIAL_ECHOPAIR("  M666 Z", z_endstop_adj);</front>
<front id="configuration_storeCPP-724">    SERIAL_EOL;  </front>
<front id="configuration_storeCPP-725">  #endif // DELTA</front>
<front id="configuration_storeCPP-726"></front>
<front id="configuration_storeCPP-727">  #if ENABLED(ULTIPANEL)</front>
<front id="configuration_storeCPP-728">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-729">    if (!forReplay) {</front>
<front id="configuration_storeCPP-730">      SERIAL_ECHOLNPGM("Material heatup parameters:");</front>
<front id="configuration_storeCPP-731">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-732">    }</front>
<front id="configuration_storeCPP-733">    SERIAL_ECHOPAIR("  M145 M0 H", (unsigned long)plaPreheatHotendTemp);</front>
<front id="configuration_storeCPP-734">    SERIAL_ECHOPAIR(" B", (unsigned long)plaPreheatHPBTemp);</front>
<front id="configuration_storeCPP-735">    SERIAL_ECHOPAIR(" F", (unsigned long)plaPreheatFanSpeed);</front>
<front id="configuration_storeCPP-736">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-737">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-738">    SERIAL_ECHOPAIR("  M145 M1 H", (unsigned long)absPreheatHotendTemp);</front>
<front id="configuration_storeCPP-739">    SERIAL_ECHOPAIR(" B", (unsigned long)absPreheatHPBTemp);</front>
<front id="configuration_storeCPP-740">    SERIAL_ECHOPAIR(" F", (unsigned long)absPreheatFanSpeed);</front>
<front id="configuration_storeCPP-741">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-742">  #endif // ULTIPANEL</front>
<front id="configuration_storeCPP-743"></front>
<front id="configuration_storeCPP-744">  #if ENABLED(PIDTEMP) || ENABLED(PIDTEMPBED)</front>
<front id="configuration_storeCPP-745"></front>
<front id="configuration_storeCPP-746">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-747">    if (!forReplay) {</front>
<front id="configuration_storeCPP-748">      SERIAL_ECHOLNPGM("PID settings:");</front>
<front id="configuration_storeCPP-749">    }</front>
<front id="configuration_storeCPP-750">    #if ENABLED(PIDTEMP)</front>
<front id="configuration_storeCPP-751">      #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-752">        if (forReplay) {</front>
<front id="configuration_storeCPP-753">          for (uint8_t i = 0; i &lt; EXTRUDERS; i++) {</front>
<front id="configuration_storeCPP-754">            CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-755">            SERIAL_ECHOPAIR("  M301 E", (unsigned long)i);</front>
<front id="configuration_storeCPP-756">            SERIAL_ECHOPAIR(" P", PID_PARAM(Kp, i));</front>
<front id="configuration_storeCPP-757">            SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, i)));</front>
<front id="configuration_storeCPP-758">            SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, i)));</front>
<front id="configuration_storeCPP-759">            #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-760">              SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, i));</front>
<front id="configuration_storeCPP-761">              if (i == 0) SERIAL_ECHOPAIR(" L", lpq_len);</front>
<front id="configuration_storeCPP-762">            #endif</front>
<front id="configuration_storeCPP-763">            SERIAL_EOL;</front>
<front id="configuration_storeCPP-764">          }</front>
<front id="configuration_storeCPP-765">        }</front>
<front id="configuration_storeCPP-766">        else</front>
<front id="configuration_storeCPP-767">      #endif // EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-768">      // !forReplay || EXTRUDERS == 1</front>
<front id="configuration_storeCPP-769">      {</front>
<front id="configuration_storeCPP-770">        CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-771">        SERIAL_ECHOPAIR("  M301 P", PID_PARAM(Kp, 0)); // for compatibility with hosts, only echo values for E0</front>
<front id="configuration_storeCPP-772">        SERIAL_ECHOPAIR(" I", unscalePID_i(PID_PARAM(Ki, 0)));</front>
<front id="configuration_storeCPP-773">        SERIAL_ECHOPAIR(" D", unscalePID_d(PID_PARAM(Kd, 0)));</front>
<front id="configuration_storeCPP-774">        #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="configuration_storeCPP-775">          SERIAL_ECHOPAIR(" C", PID_PARAM(Kc, 0));</front>
<front id="configuration_storeCPP-776">          SERIAL_ECHOPAIR(" L", lpq_len);</front>
<front id="configuration_storeCPP-777">        #endif</front>
<front id="configuration_storeCPP-778">        SERIAL_EOL;</front>
<front id="configuration_storeCPP-779">      }</front>
<front id="configuration_storeCPP-780">    #endif // PIDTEMP</front>
<front id="configuration_storeCPP-781"></front>
<front id="configuration_storeCPP-782">    #if ENABLED(PIDTEMPBED)</front>
<front id="configuration_storeCPP-783">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-784">      SERIAL_ECHOPAIR("  M304 P", bedKp);</front>
<front id="configuration_storeCPP-785">      SERIAL_ECHOPAIR(" I", unscalePID_i(bedKi));</front>
<front id="configuration_storeCPP-786">      SERIAL_ECHOPAIR(" D", unscalePID_d(bedKd));</front>
<front id="configuration_storeCPP-787">      SERIAL_EOL;</front>
<front id="configuration_storeCPP-788">    #endif</front>
<front id="configuration_storeCPP-789"></front>
<front id="configuration_storeCPP-790">  #endif // PIDTEMP || PIDTEMPBED</front>
<front id="configuration_storeCPP-791"></front>
<front id="configuration_storeCPP-792">  #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="configuration_storeCPP-793">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-794">    if (!forReplay) {</front>
<front id="configuration_storeCPP-795">      SERIAL_ECHOLNPGM("LCD Contrast:");</front>
<front id="configuration_storeCPP-796">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-797">    }</front>
<front id="configuration_storeCPP-798">    SERIAL_ECHOPAIR("  M250 C", (unsigned long)lcd_contrast);</front>
<front id="configuration_storeCPP-799">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-800">  #endif</front>
<front id="configuration_storeCPP-801"></front>
<front id="configuration_storeCPP-802">  #if ENABLED(FWRETRACT)</front>
<front id="configuration_storeCPP-803"></front>
<front id="configuration_storeCPP-804">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-805">    if (!forReplay) {</front>
<front id="configuration_storeCPP-806">      SERIAL_ECHOLNPGM("Retract: S=Length (mm) F:Speed (mm/m) Z: ZLift (mm)");</front>
<front id="configuration_storeCPP-807">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-808">    }</front>
<front id="configuration_storeCPP-809">    SERIAL_ECHOPAIR("  M207 S", retract_length);</front>
<front id="configuration_storeCPP-810">    #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-811">      SERIAL_ECHOPAIR(" W", retract_length_swap);</front>
<front id="configuration_storeCPP-812">    #endif</front>
<front id="configuration_storeCPP-813">    SERIAL_ECHOPAIR(" F", retract_feedrate*60);</front>
<front id="configuration_storeCPP-814">    SERIAL_ECHOPAIR(" Z", retract_zlift);</front>
<front id="configuration_storeCPP-815">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-816">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-817">    if (!forReplay) {</front>
<front id="configuration_storeCPP-818">      SERIAL_ECHOLNPGM("Recover: S=Extra length (mm) F:Speed (mm/m)");</front>
<front id="configuration_storeCPP-819">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-820">    }</front>
<front id="configuration_storeCPP-821">    SERIAL_ECHOPAIR("  M208 S", retract_recover_length);</front>
<front id="configuration_storeCPP-822">    #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-823">      SERIAL_ECHOPAIR(" W", retract_recover_length_swap);</front>
<front id="configuration_storeCPP-824">    #endif</front>
<front id="configuration_storeCPP-825">    SERIAL_ECHOPAIR(" F", retract_recover_feedrate*60);</front>
<front id="configuration_storeCPP-826">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-827">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-828">    if (!forReplay) {</front>
<front id="configuration_storeCPP-829">      SERIAL_ECHOLNPGM("Auto-Retract: S=0 to disable, 1 to interpret extrude-only moves as retracts or recoveries");</front>
<front id="configuration_storeCPP-830">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-831">    }</front>
<front id="configuration_storeCPP-832">    SERIAL_ECHOPAIR("  M209 S", (unsigned long)(autoretract_enabled ? 1 : 0));</front>
<front id="configuration_storeCPP-833">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-834"></front>
<front id="configuration_storeCPP-835">  #endif // FWRETRACT</front>
<front id="configuration_storeCPP-836"></front>
<front id="configuration_storeCPP-837">  /**</front>
<front id="configuration_storeCPP-838">   * Volumetric extrusion M200</front>
<front id="configuration_storeCPP-839">   */</front>
<front id="configuration_storeCPP-840">  if (!forReplay) {</front>
<front id="configuration_storeCPP-841">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-842">    SERIAL_ECHOPGM("Filament settings:");</front>
<front id="configuration_storeCPP-843">    if (volumetric_enabled)</front>
<front id="configuration_storeCPP-844">      SERIAL_EOL;</front>
<front id="configuration_storeCPP-845">    else</front>
<front id="configuration_storeCPP-846">      SERIAL_ECHOLNPGM(" Disabled");</front>
<front id="configuration_storeCPP-847">  }</front>
<front id="configuration_storeCPP-848"></front>
<front id="configuration_storeCPP-849">  CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-850">  SERIAL_ECHOPAIR("  M200 D", filament_size[0]);</front>
<front id="configuration_storeCPP-851">  SERIAL_EOL;</front>
<front id="configuration_storeCPP-852">  #if EXTRUDERS &gt; 1</front>
<front id="configuration_storeCPP-853">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-854">    SERIAL_ECHOPAIR("  M200 T1 D", filament_size[1]);</front>
<front id="configuration_storeCPP-855">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-856">    #if EXTRUDERS &gt; 2</front>
<front id="configuration_storeCPP-857">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-858">      SERIAL_ECHOPAIR("  M200 T2 D", filament_size[2]);</front>
<front id="configuration_storeCPP-859">      SERIAL_EOL;</front>
<front id="configuration_storeCPP-860">      #if EXTRUDERS &gt; 3</front>
<front id="configuration_storeCPP-861">        CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-862">        SERIAL_ECHOPAIR("  M200 T3 D", filament_size[3]);</front>
<front id="configuration_storeCPP-863">        SERIAL_EOL;</front>
<front id="configuration_storeCPP-864">      #endif</front>
<front id="configuration_storeCPP-865">    #endif</front>
<front id="configuration_storeCPP-866">  #endif</front>
<front id="configuration_storeCPP-867"></front>
<front id="configuration_storeCPP-868">  if (!volumetric_enabled) {</front>
<front id="configuration_storeCPP-869">    CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-870">    SERIAL_ECHOLNPGM("  M200 D0");</front>
<front id="configuration_storeCPP-871">  }</front>
<front id="configuration_storeCPP-872"></front>
<front id="configuration_storeCPP-873">  /**</front>
<front id="configuration_storeCPP-874">   * Auto Bed Leveling</front>
<front id="configuration_storeCPP-875">   */</front>
<front id="configuration_storeCPP-876">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="configuration_storeCPP-877">    #if ENABLED(CUSTOM_M_CODES)</front>
<front id="configuration_storeCPP-878">      if (!forReplay) {</front>
<front id="configuration_storeCPP-879">        CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-880">        SERIAL_ECHOLNPGM("Z-Probe Offset (mm):");</front>
<front id="configuration_storeCPP-881">      }</front>
<front id="configuration_storeCPP-882">      CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-883">      SERIAL_ECHOPAIR("  M" STRINGIFY(CUSTOM_M_CODE_SET_Z_PROBE_OFFSET) " Z", zprobe_zoffset);</front>
<front id="configuration_storeCPP-884">    #else</front>
<front id="configuration_storeCPP-885">      if (!forReplay) {</front>
<front id="configuration_storeCPP-886">        CONFIG_ECHO_START;</front>
<front id="configuration_storeCPP-887">        SERIAL_ECHOPAIR("Z-Probe Offset (mm):", zprobe_zoffset);</front>
<front id="configuration_storeCPP-888">      }</front>
<front id="configuration_storeCPP-889">    #endif</front>
<front id="configuration_storeCPP-890">    SERIAL_EOL;</front>
<front id="configuration_storeCPP-891">  #endif</front>
<front id="configuration_storeCPP-892">}</front>
<front id="configuration_storeCPP-893"></front>
<front id="configuration_storeCPP-894">#endif // !DISABLE_M503</front>
 </pre>
<h1 id="configuration_storeHtitle" >configuration_store.h</h1>
<pre id="configuration_storeH"  class="prettyprint linenums"><front id="configuration_storeH-1">#ifndef CONFIGURATION_STORE_H</front>
<front id="configuration_storeH-2">#define CONFIGURATION_STORE_H</front>
<front id="configuration_storeH-3"></front>
<front id="configuration_storeH-4">#include "Configuration.h"</front>
<front id="configuration_storeH-5"></front>
<front id="configuration_storeH-6">void Config_ResetDefault();</front>
<front id="configuration_storeH-7"></front>
<front id="configuration_storeH-8">#if DISABLED(DISABLE_M503)</front>
<front id="configuration_storeH-9">  void Config_PrintSettings(bool forReplay=false);</front>
<front id="configuration_storeH-10">#else</front>
<front id="configuration_storeH-11">  FORCE_INLINE void Config_PrintSettings(bool forReplay=false) {}</front>
<front id="configuration_storeH-12">#endif</front>
<front id="configuration_storeH-13"></front>
<front id="configuration_storeH-14">#if ENABLED(EEPROM_SETTINGS)</front>
<front id="configuration_storeH-15">  void Config_StoreSettings();</front>
<front id="configuration_storeH-16">  void Config_RetrieveSettings();</front>
<front id="configuration_storeH-17">#else</front>
<front id="configuration_storeH-18">  FORCE_INLINE void Config_StoreSettings() {}</front>
<front id="configuration_storeH-19">  FORCE_INLINE void Config_RetrieveSettings() { Config_ResetDefault(); Config_PrintSettings(); }</front>
<front id="configuration_storeH-20">#endif</front>
<front id="configuration_storeH-21"></front>
<front id="configuration_storeH-22">#endif //CONFIGURATION_STORE_H</front>
 </pre>
<h1 id="Default_VersionHtitle" >Default_Version.h</h1>
<pre id="Default_VersionH"  class="prettyprint linenums"><front id="Default_VersionH-1">/*</front>
<front id="Default_VersionH-2"> * This file is a placeholder for a file which could be distributed in an archive</front>
<front id="Default_VersionH-3"> * It takes the place of an automatically created "_Version.h" which is generated during the build process</front>
<front id="Default_VersionH-4"> */</front>
<front id="Default_VersionH-5"></front>
<front id="Default_VersionH-6">// #error "You must specify the following parameters related to your distribution"</front>
<front id="Default_VersionH-7"></front>
<front id="Default_VersionH-8">#if true</front>
<front id="Default_VersionH-9">  #define SHORT_BUILD_VERSION "1.1.0 dev"</front>
<front id="Default_VersionH-10">  #define DETAILED_BUILD_VERSION "1.1.0 Development From Archive"</front>
<front id="Default_VersionH-11">  #define STRING_DISTRIBUTION_DATE "2015-08-00 12:00"</front>
<front id="Default_VersionH-12">  // It might also be appropriate to define a location where additional information can be found</front>
<front id="Default_VersionH-13">  #define SOURCE_CODE_URL  "http:// ..."</front>
<front id="Default_VersionH-14">#endif</front>
 </pre>
<h1 id="digipot_mcp4451CPPtitle" >digipot_mcp4451.cpp</h1>
<pre id="digipot_mcp4451CPP"  class="prettyprint linenums"><front id="digipot_mcp4451CPP-1">#include "Configuration.h"</front>
<front id="digipot_mcp4451CPP-2"></front>
<front id="digipot_mcp4451CPP-3">#if ENABLED(DIGIPOT_I2C)</front>
<front id="digipot_mcp4451CPP-4"></front>
<front id="digipot_mcp4451CPP-5">#include "Stream.h"</front>
<front id="digipot_mcp4451CPP-6">#include "utility/twi.h"</front>
<front id="digipot_mcp4451CPP-7">#include "Wire.h"</front>
<front id="digipot_mcp4451CPP-8"></front>
<front id="digipot_mcp4451CPP-9">// Settings for the I2C based DIGIPOT (MCP4451) on Azteeg X3 Pro</front>
<front id="digipot_mcp4451CPP-10">#if MB(5DPRINT)</front>
<front id="digipot_mcp4451CPP-11">  #define DIGIPOT_I2C_FACTOR 117.96</front>
<front id="digipot_mcp4451CPP-12">  #define DIGIPOT_I2C_MAX_CURRENT 1.736</front>
<front id="digipot_mcp4451CPP-13">#else</front>
<front id="digipot_mcp4451CPP-14">  #define DIGIPOT_I2C_FACTOR 106.7</front>
<front id="digipot_mcp4451CPP-15">  #define DIGIPOT_I2C_MAX_CURRENT 2.5</front>
<front id="digipot_mcp4451CPP-16">#endif</front>
<front id="digipot_mcp4451CPP-17"></front>
<front id="digipot_mcp4451CPP-18">static byte current_to_wiper(float current) {</front>
<front id="digipot_mcp4451CPP-19">  return byte(ceil(float((DIGIPOT_I2C_FACTOR*current))));</front>
<front id="digipot_mcp4451CPP-20">}</front>
<front id="digipot_mcp4451CPP-21"></front>
<front id="digipot_mcp4451CPP-22">static void i2c_send(byte addr, byte a, byte b) {</front>
<front id="digipot_mcp4451CPP-23">  Wire.beginTransmission(addr);</front>
<front id="digipot_mcp4451CPP-24">  Wire.write(a);</front>
<front id="digipot_mcp4451CPP-25">  Wire.write(b);</front>
<front id="digipot_mcp4451CPP-26">  Wire.endTransmission();</front>
<front id="digipot_mcp4451CPP-27">}</front>
<front id="digipot_mcp4451CPP-28"></front>
<front id="digipot_mcp4451CPP-29">// This is for the MCP4451 I2C based digipot</front>
<front id="digipot_mcp4451CPP-30">void digipot_i2c_set_current(int channel, float current) {</front>
<front id="digipot_mcp4451CPP-31">  current = min( (float) max( current, 0.0f ), DIGIPOT_I2C_MAX_CURRENT);</front>
<front id="digipot_mcp4451CPP-32">  // these addresses are specific to Azteeg X3 Pro, can be set to others,</front>
<front id="digipot_mcp4451CPP-33">  // In this case first digipot is at address A0=0, A1= 0, second one is at A0=0, A1= 1</front>
<front id="digipot_mcp4451CPP-34">  byte addr = 0x2C; // channel 0-3</front>
<front id="digipot_mcp4451CPP-35">  if (channel &gt;= 4) {</front>
<front id="digipot_mcp4451CPP-36">  	addr = 0x2E; // channel 4-7</front>
<front id="digipot_mcp4451CPP-37">  	channel -= 4;</front>
<front id="digipot_mcp4451CPP-38">  }</front>
<front id="digipot_mcp4451CPP-39"></front>
<front id="digipot_mcp4451CPP-40">  // Initial setup</front>
<front id="digipot_mcp4451CPP-41">  i2c_send(addr, 0x40, 0xff);</front>
<front id="digipot_mcp4451CPP-42">  i2c_send(addr, 0xA0, 0xff);</front>
<front id="digipot_mcp4451CPP-43"></front>
<front id="digipot_mcp4451CPP-44">  // Set actual wiper value</front>
<front id="digipot_mcp4451CPP-45">  byte addresses[4] = { 0x00, 0x10, 0x60, 0x70 };</front>
<front id="digipot_mcp4451CPP-46">  i2c_send(addr, addresses[channel], current_to_wiper(current));</front>
<front id="digipot_mcp4451CPP-47">}</front>
<front id="digipot_mcp4451CPP-48"></front>
<front id="digipot_mcp4451CPP-49">void digipot_i2c_init() {</front>
<front id="digipot_mcp4451CPP-50">  const float digipot_motor_current[] = DIGIPOT_I2C_MOTOR_CURRENTS;</front>
<front id="digipot_mcp4451CPP-51">  Wire.begin();</front>
<front id="digipot_mcp4451CPP-52">  // setup initial currents as defined in Configuration_adv.h</front>
<front id="digipot_mcp4451CPP-53">  for(int i = 0; i &lt; COUNT(digipot_motor_current); i++) {</front>
<front id="digipot_mcp4451CPP-54">    digipot_i2c_set_current(i, digipot_motor_current[i]);</front>
<front id="digipot_mcp4451CPP-55">  }</front>
<front id="digipot_mcp4451CPP-56">}</front>
<front id="digipot_mcp4451CPP-57"></front>
<front id="digipot_mcp4451CPP-58">#endif //DIGIPOT_I2C</front>
 </pre>
<h1 id="dogm_bitmapsHtitle" >dogm_bitmaps.h</h1>
<pre id="dogm_bitmapsH"  class="prettyprint linenums"><front id="dogm_bitmapsH-1">// BitMap for splashscreen</front>
<front id="dogm_bitmapsH-2">// Generated with: http://www.digole.com/tools/PicturetoC_Hex_converter.php</front>
<front id="dogm_bitmapsH-3">// Please note that using the high-res version takes 402Bytes of PROGMEM. </front>
<front id="dogm_bitmapsH-4">//#define START_BMPHIGH</front>
<front id="dogm_bitmapsH-5"></front>
<front id="dogm_bitmapsH-6">#if ENABLED(SHOW_BOOTSCREEN)</front>
<front id="dogm_bitmapsH-7">  #if ENABLED(START_BMPHIGH)</front>
<front id="dogm_bitmapsH-8">    #define START_BMPWIDTH      112</front>
<front id="dogm_bitmapsH-9">    #define START_BMPHEIGHT      38</front>
<front id="dogm_bitmapsH-10">    #define START_BMPBYTEWIDTH   14</front>
<front id="dogm_bitmapsH-11">    #define START_BMPBYTES      532 // START_BMPWIDTH * START_BMPHEIGHT / 8</front>
<front id="dogm_bitmapsH-12"></front>
<front id="dogm_bitmapsH-13">    const unsigned char start_bmp[START_BMPBYTES] PROGMEM = {</front>
<front id="dogm_bitmapsH-14">       0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff</front>
<front id="dogm_bitmapsH-15">      ,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff</front>
<front id="dogm_bitmapsH-16">      ,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xff,0xff</front>
<front id="dogm_bitmapsH-17">      ,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xff,0xff</front>
<front id="dogm_bitmapsH-18">      ,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xff,0xff</front>
<front id="dogm_bitmapsH-19">      ,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff</front>
<front id="dogm_bitmapsH-20">      ,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0xff</front>
<front id="dogm_bitmapsH-21">      ,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x3f,0xff</front>
<front id="dogm_bitmapsH-22">      ,0xc0,0x0f,0xc0,0xfc,0x00,0x00,0x00,0x00,0x00,0x78,0x18,0x00,0x1f,0xff</front>
<front id="dogm_bitmapsH-23">      ,0xc0,0x3f,0xe1,0xff,0x00,0x00,0x00,0x00,0x00,0x78,0x3c,0x00,0x0f,0xff</front>
<front id="dogm_bitmapsH-24">      ,0xc0,0x7f,0xf3,0xff,0x80,0x00,0x00,0x00,0x00,0x78,0x3c,0x00,0x07,0xff</front>
<front id="dogm_bitmapsH-25">      ,0xc0,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x78,0x3c,0x00,0x03,0xff</front>
<front id="dogm_bitmapsH-26">      ,0xc1,0xf8,0x7f,0x87,0xe0,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x01,0xff</front>
<front id="dogm_bitmapsH-27">      ,0xc1,0xf0,0x3f,0x03,0xe0,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0xff</front>
<front id="dogm_bitmapsH-28">      ,0xc1,0xe0,0x1e,0x01,0xe0,0x1f,0x00,0x03,0xe0,0x78,0x3c,0x03,0xf0,0x7f</front>
<front id="dogm_bitmapsH-29">      ,0xc1,0xe0,0x1e,0x01,0xe0,0x7f,0xc0,0x0f,0xf8,0x78,0x3c,0x07,0xfc,0x3f</front>
<front id="dogm_bitmapsH-30">      ,0xc1,0xe0,0x1e,0x01,0xe1,0xff,0xe0,0x1f,0xfc,0x78,0x3c,0x0f,0xfe,0x1f</front>
<front id="dogm_bitmapsH-31">      ,0xc1,0xe0,0x1e,0x01,0xe3,0xff,0xf0,0x3f,0xfe,0x78,0x3c,0x1f,0xfe,0x0f</front>
<front id="dogm_bitmapsH-32">      ,0xc1,0xe0,0x1e,0x01,0xe3,0xf3,0xf8,0x3f,0x3e,0x78,0x3c,0x3f,0x3f,0x07</front>
<front id="dogm_bitmapsH-33">      ,0xc1,0xe0,0x1e,0x01,0xe7,0xe0,0xfc,0x7c,0x1f,0x78,0x3c,0x3e,0x1f,0x07</front>
<front id="dogm_bitmapsH-34">      ,0xc1,0xe0,0x1e,0x01,0xe7,0xc0,0x7c,0x7c,0x0f,0x78,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-35">      ,0xc1,0xe0,0x1e,0x01,0xe7,0x80,0x7c,0x78,0x0f,0x78,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-36">      ,0xc1,0xe0,0x1e,0x01,0xe7,0x80,0x3c,0x78,0x00,0x78,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-37">      ,0xc1,0xe0,0x1e,0x01,0xe7,0x80,0x3c,0x78,0x00,0x78,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-38">      ,0xc1,0xe0,0x1e,0x01,0xe7,0x80,0x3c,0x78,0x00,0x78,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-39">      ,0xc1,0xe0,0x1e,0x01,0xe7,0xc0,0x3c,0x78,0x00,0x78,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-40">      ,0xc1,0xe0,0x1e,0x01,0xe3,0xe0,0x3c,0x78,0x00,0x7c,0x3c,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-41">      ,0xc1,0xe0,0x1e,0x01,0xe3,0xff,0x3f,0xf8,0x00,0x7f,0xbc,0x3c,0x0f,0x03</front>
<front id="dogm_bitmapsH-42">      ,0xc1,0xe0,0x1e,0x01,0xe1,0xff,0x3f,0xf8,0x00,0x3f,0xbf,0xfc,0x0f,0x03</front>
<front id="dogm_bitmapsH-43">      ,0xc1,0xe0,0x1e,0x01,0xe0,0xff,0x3f,0xf8,0x00,0x1f,0xbf,0xfc,0x0f,0x03</front>
<front id="dogm_bitmapsH-44">      ,0xc1,0xe0,0x1e,0x01,0xe0,0x7f,0x3f,0xf8,0x00,0x0f,0xbf,0xfc,0x0f,0x03</front>
<front id="dogm_bitmapsH-45">      ,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07</front>
<front id="dogm_bitmapsH-46">      ,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06</front>
<front id="dogm_bitmapsH-47">      ,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0e</front>
<front id="dogm_bitmapsH-48">      ,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1c</front>
<front id="dogm_bitmapsH-49">      ,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x78</front>
<front id="dogm_bitmapsH-50">      ,0x0f,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0</front>
<front id="dogm_bitmapsH-51">      ,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80 };</front>
<front id="dogm_bitmapsH-52">  #else</front>
<front id="dogm_bitmapsH-53">    #define START_BMPWIDTH      56</front>
<front id="dogm_bitmapsH-54">    #define START_BMPHEIGHT     19</front>
<front id="dogm_bitmapsH-55">    #define START_BMPBYTEWIDTH  7</front>
<front id="dogm_bitmapsH-56">    #define START_BMPBYTES      133 // START_BMPWIDTH * START_BMPHEIGHT / 8</front>
<front id="dogm_bitmapsH-57"></front>
<front id="dogm_bitmapsH-58">    const unsigned char start_bmp[START_BMPBYTES] PROGMEM = {</front>
<front id="dogm_bitmapsH-59">       0x1f,0xff,0xff,0xff,0xff,0xff,0xff</front>
<front id="dogm_bitmapsH-60">      ,0x60,0x00,0x00,0x00,0x00,0x01,0xff</front>
<front id="dogm_bitmapsH-61">      ,0x40,0x00,0x00,0x00,0x00,0x00,0xff</front>
<front id="dogm_bitmapsH-62">      ,0x80,0x00,0x00,0x00,0x00,0x00,0x7f</front>
<front id="dogm_bitmapsH-63">      ,0x83,0xcf,0x00,0x00,0x0c,0x30,0x3f</front>
<front id="dogm_bitmapsH-64">      ,0x87,0xff,0x80,0x00,0x0c,0x30,0x1f</front>
<front id="dogm_bitmapsH-65">      ,0x86,0x79,0x80,0x00,0x0c,0x00,0x0f</front>
<front id="dogm_bitmapsH-66">      ,0x8c,0x30,0xc7,0x83,0x8c,0x30,0xe7</front>
<front id="dogm_bitmapsH-67">      ,0x8c,0x30,0xcf,0xc7,0xcc,0x31,0xf3</front>
<front id="dogm_bitmapsH-68">      ,0x8c,0x30,0xdc,0xec,0xec,0x33,0xb9</front>
<front id="dogm_bitmapsH-69">      ,0x8c,0x30,0xd8,0x6c,0x6c,0x33,0x19</front>
<front id="dogm_bitmapsH-70">      ,0x8c,0x30,0xd0,0x6c,0x0c,0x33,0x19</front>
<front id="dogm_bitmapsH-71">      ,0x8c,0x30,0xd8,0x6c,0x0c,0x33,0x19</front>
<front id="dogm_bitmapsH-72">      ,0x8c,0x30,0xdc,0x6c,0x0e,0x3b,0x19</front>
<front id="dogm_bitmapsH-73">      ,0x8c,0x30,0xcf,0x7c,0x07,0x9f,0x19</front>
<front id="dogm_bitmapsH-74">      ,0x8c,0x30,0xc7,0x7c,0x03,0x8f,0x19</front>
<front id="dogm_bitmapsH-75">      ,0x40,0x00,0x00,0x00,0x00,0x00,0x02</front>
<front id="dogm_bitmapsH-76">      ,0x60,0x00,0x00,0x00,0x00,0x00,0x06</front>
<front id="dogm_bitmapsH-77">      ,0x1f,0xff,0xff,0xff,0xff,0xff,0xf8 };</front>
<front id="dogm_bitmapsH-78">  #endif</front>
<front id="dogm_bitmapsH-79">#endif</front>
<front id="dogm_bitmapsH-80"></front>
<front id="dogm_bitmapsH-81">// Here comes a compile-time operation to match the extruder symbols </front>
<front id="dogm_bitmapsH-82">// on the info screen to the set number of extruders in configuration.h</front>
<front id="dogm_bitmapsH-83">// </front>
<front id="dogm_bitmapsH-84">// When only one extruder is selected, the "1" on the symbol will not </front>
<front id="dogm_bitmapsH-85">// be displayed.</front>
<front id="dogm_bitmapsH-86"></front>
<front id="dogm_bitmapsH-87">#if EXTRUDERS == 1</front>
<front id="dogm_bitmapsH-88">	#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="dogm_bitmapsH-89">	#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="dogm_bitmapsH-90">	#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="dogm_bitmapsH-91">	const unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="dogm_bitmapsH-92">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-93">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-94">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x0C,0x60,</front>
<front id="dogm_bitmapsH-95">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x0E,0x20,</front>
<front id="dogm_bitmapsH-96">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x0F,0x20,</front>
<front id="dogm_bitmapsH-97">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x0F,0xA0,</front>
<front id="dogm_bitmapsH-98">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,0x07,0xA0,</front>
<front id="dogm_bitmapsH-99">	0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-100">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-101">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-102">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-103">	0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x5E,0x07,0xA0,</front>
<front id="dogm_bitmapsH-104">	0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x5F,0x0F,0xA0,</front>
<front id="dogm_bitmapsH-105">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x4F,0x0F,0x20,</front>
<front id="dogm_bitmapsH-106">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x47,0x0E,0x20,</front>
<front id="dogm_bitmapsH-107">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x63,0x0C,0x60,</front>
<front id="dogm_bitmapsH-108">	0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-109">	0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-110">	0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="dogm_bitmapsH-111">	};</front>
<front id="dogm_bitmapsH-112"></front>
<front id="dogm_bitmapsH-113">	#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="dogm_bitmapsH-114">	#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="dogm_bitmapsH-115">	#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="dogm_bitmapsH-116">	const unsigned char status_screen1_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="dogm_bitmapsH-117">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-118">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-119">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x61,0xF8,0x60,</front>
<front id="dogm_bitmapsH-120">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0xF8,0x20,</front>
<front id="dogm_bitmapsH-121">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-122">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-123">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x01,0xA0,</front>
<front id="dogm_bitmapsH-124">	0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="dogm_bitmapsH-125">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="dogm_bitmapsH-126">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="dogm_bitmapsH-127">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="dogm_bitmapsH-128">	0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x58,0x01,0xA0,</front>
<front id="dogm_bitmapsH-129">	0x7F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-130">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-131">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x41,0xF8,0x20,</front>
<front id="dogm_bitmapsH-132">	0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x61,0xF8,0x60,</front>
<front id="dogm_bitmapsH-133">	0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-134">	0x1E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-135">	0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="dogm_bitmapsH-136">	};</front>
<front id="dogm_bitmapsH-137">#elif EXTRUDERS == 2</front>
<front id="dogm_bitmapsH-138">	#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="dogm_bitmapsH-139">	#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="dogm_bitmapsH-140">	#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="dogm_bitmapsH-141">	const unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="dogm_bitmapsH-142">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-143">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-144">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x0C,0x60,</front>
<front id="dogm_bitmapsH-145">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x0E,0x20,</front>
<front id="dogm_bitmapsH-146">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x0F,0x20,</front>
<front id="dogm_bitmapsH-147">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x0F,0xA0,</front>
<front id="dogm_bitmapsH-148">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,0x07,0xA0,</front>
<front id="dogm_bitmapsH-149">	0x7F,0x80,0x00,0x3F,0xC0,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-150">	0xFB,0xC0,0x00,0x79,0xE0,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-151">	0xF3,0xC0,0x00,0x76,0xE0,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-152">	0xEB,0xC0,0x00,0x7E,0xE0,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-153">	0x7B,0x80,0x00,0x3D,0xC0,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x5E,0x07,0xA0,</front>
<front id="dogm_bitmapsH-154">	0x7B,0x80,0x00,0x3B,0xC0,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x5F,0x0F,0xA0,</front>
<front id="dogm_bitmapsH-155">	0xFB,0xC0,0x00,0x77,0xE0,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x4F,0x0F,0x20,</front>
<front id="dogm_bitmapsH-156">	0xFB,0xC0,0x00,0x70,0xE0,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x47,0x0E,0x20,</front>
<front id="dogm_bitmapsH-157">	0xFF,0xC0,0x00,0x7F,0xE0,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x63,0x0C,0x60,</front>
<front id="dogm_bitmapsH-158">	0x3F,0x00,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-159">	0x1E,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-160">	0x0C,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="dogm_bitmapsH-161">	};</front>
<front id="dogm_bitmapsH-162"></front>
<front id="dogm_bitmapsH-163">	#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="dogm_bitmapsH-164">	#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="dogm_bitmapsH-165">	#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="dogm_bitmapsH-166">	const unsigned char status_screen1_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="dogm_bitmapsH-167">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-168">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-169">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x61,0xF8,0x60,</front>
<front id="dogm_bitmapsH-170">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0xF8,0x20,</front>
<front id="dogm_bitmapsH-171">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-172">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-173">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x01,0xA0,</front>
<front id="dogm_bitmapsH-174">	0x7F,0x80,0x00,0x3F,0xC0,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="dogm_bitmapsH-175">	0xFB,0xC0,0x00,0x79,0xE0,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="dogm_bitmapsH-176">	0xF3,0xC0,0x00,0x76,0xE0,0x00,0x00,0x00,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="dogm_bitmapsH-177">	0xEB,0xC0,0x00,0x7E,0xE0,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="dogm_bitmapsH-178">	0x7B,0x80,0x00,0x3D,0xC0,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x58,0x01,0xA0,</front>
<front id="dogm_bitmapsH-179">	0x7B,0x80,0x00,0x3B,0xC0,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-180">	0xFB,0xC0,0x00,0x77,0xE0,0x00,0x00,0x00,0x01,0x04,0x10,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-181">	0xFB,0xC0,0x00,0x70,0xE0,0x00,0x00,0x00,0x00,0x82,0x08,0x00,0x41,0xF8,0x20,</front>
<front id="dogm_bitmapsH-182">	0xFF,0xC0,0x00,0x7F,0xE0,0x00,0x00,0x00,0x00,0x41,0x04,0x00,0x61,0xF8,0x60,</front>
<front id="dogm_bitmapsH-183">	0x3F,0x00,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-184">	0x1E,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-185">	0x0C,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="dogm_bitmapsH-186">	};</front>
<front id="dogm_bitmapsH-187">#else</front>
<front id="dogm_bitmapsH-188">	#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="dogm_bitmapsH-189">	#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="dogm_bitmapsH-190">	#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="dogm_bitmapsH-191">	const unsigned char status_screen0_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="dogm_bitmapsH-192">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-193">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-194">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x63,0x0C,0x60,</front>
<front id="dogm_bitmapsH-195">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x47,0x0E,0x20,</front>
<front id="dogm_bitmapsH-196">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4F,0x0F,0x20,</front>
<front id="dogm_bitmapsH-197">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x0F,0xA0,</front>
<front id="dogm_bitmapsH-198">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5E,0x07,0xA0,</front>
<front id="dogm_bitmapsH-199">	0x7F,0x80,0x00,0x3F,0xC0,0x00,0x3F,0xC0,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-200">	0xFB,0xC0,0x00,0x79,0xE0,0x00,0x79,0xE0,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-201">	0xF3,0xC0,0x00,0x76,0xE0,0x00,0x76,0xE0,0x00,0x20,0x82,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-202">	0xEB,0xC0,0x00,0x7E,0xE0,0x00,0x7E,0xE0,0x00,0x41,0x04,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-203">	0x7B,0x80,0x00,0x3D,0xC0,0x00,0x39,0xC0,0x00,0x82,0x08,0x00,0x5E,0x07,0xA0,</front>
<front id="dogm_bitmapsH-204">	0x7B,0x80,0x00,0x3B,0xC0,0x00,0x3E,0xC0,0x01,0x04,0x10,0x00,0x5F,0x0F,0xA0,</front>
<front id="dogm_bitmapsH-205">	0xFB,0xC0,0x00,0x77,0xE0,0x00,0x76,0xE0,0x01,0x04,0x10,0x00,0x4F,0x0F,0x20,</front>
<front id="dogm_bitmapsH-206">	0xFB,0xC0,0x00,0x70,0xE0,0x00,0x79,0xE0,0x00,0x82,0x08,0x00,0x47,0x0E,0x20,</front>
<front id="dogm_bitmapsH-207">	0xFF,0xC0,0x00,0x7F,0xE0,0x00,0x7F,0xE0,0x00,0x41,0x04,0x00,0x63,0x0C,0x60,</front>
<front id="dogm_bitmapsH-208">	0x3F,0x00,0x00,0x1F,0x80,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-209">	0x1E,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-210">	0x0C,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="dogm_bitmapsH-211">	};</front>
<front id="dogm_bitmapsH-212"></front>
<front id="dogm_bitmapsH-213">	#define STATUS_SCREENWIDTH 		115	//Width in pixels</front>
<front id="dogm_bitmapsH-214">	#define STATUS_SCREENHEIGHT 	19	//Height in pixels</front>
<front id="dogm_bitmapsH-215">	#define STATUS_SCREENBYTEWIDTH 	15	//Width in bytes</front>
<front id="dogm_bitmapsH-216">	const unsigned char status_screen1_bmp[] PROGMEM = { //AVR-GCC, WinAVR</front>
<front id="dogm_bitmapsH-217">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-218">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-219">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x61,0xF8,0x60,</front>
<front id="dogm_bitmapsH-220">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x41,0xF8,0x20,</front>
<front id="dogm_bitmapsH-221">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-222">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-223">	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x58,0x01,0xA0,</front>
<front id="dogm_bitmapsH-224">	0x7F,0x80,0x00,0x3F,0xC0,0x00,0x3F,0xC0,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="dogm_bitmapsH-225">	0xFB,0xC0,0x00,0x79,0xE0,0x00,0x79,0xE0,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="dogm_bitmapsH-226">	0xF3,0xC0,0x00,0x76,0xE0,0x00,0x76,0xE0,0x00,0x20,0x82,0x00,0x5E,0xF7,0xA0,</front>
<front id="dogm_bitmapsH-227">	0xEB,0xC0,0x00,0x7E,0xE0,0x00,0x7E,0xE0,0x00,0x41,0x04,0x00,0x5C,0x63,0xA0,</front>
<front id="dogm_bitmapsH-228">	0x7B,0x80,0x00,0x3D,0xC0,0x00,0x39,0xC0,0x00,0x82,0x08,0x00,0x58,0x01,0xA0,</front>
<front id="dogm_bitmapsH-229">	0x7B,0x80,0x00,0x3B,0xC0,0x00,0x3E,0xC0,0x01,0x04,0x10,0x00,0x40,0x60,0x20,</front>
<front id="dogm_bitmapsH-230">	0xFB,0xC0,0x00,0x77,0xE0,0x00,0x76,0xE0,0x01,0x04,0x10,0x00,0x40,0xF0,0x20,</front>
<front id="dogm_bitmapsH-231">	0xFB,0xC0,0x00,0x70,0xE0,0x00,0x79,0xE0,0x00,0x82,0x08,0x00,0x41,0xF8,0x20,</front>
<front id="dogm_bitmapsH-232">	0xFF,0xC0,0x00,0x7F,0xE0,0x00,0x7F,0xE0,0x00,0x41,0x04,0x00,0x61,0xF8,0x60,</front>
<front id="dogm_bitmapsH-233">	0x3F,0x00,0x00,0x1F,0x80,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x70,0x00,0xE0,</front>
<front id="dogm_bitmapsH-234">	0x1E,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x01,0xFF,0xFF,0x80,0x7F,0xFF,0xE0,</front>
<front id="dogm_bitmapsH-235">	0x0C,0x00,0x00,0x06,0x00,0x00,0x06,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00</front>
<front id="dogm_bitmapsH-236">	};</front>
<front id="dogm_bitmapsH-237">#endif // Extruders </front>
<front id="dogm_bitmapsH-238"></front>
<front id="dogm_bitmapsH-239"></front>
 </pre>
<h1 id="dogm_font_data_6x9_marlinHtitle" >dogm_font_data_6x9_marlin.h</h1>
<pre id="dogm_font_data_6x9_marlinH"  class="prettyprint linenums"><front id="dogm_font_data_6x9_marlinH-1">/*</front>
<front id="dogm_font_data_6x9_marlinH-2">  Fontname: -Misc-Fixed-Medium-R-Normal--9-90-75-75-C-60-ISO10646-1</front>
<front id="dogm_font_data_6x9_marlinH-3">  Copyright: Public domain font.  Share and enjoy.</front>
<front id="dogm_font_data_6x9_marlinH-4">  Capital A Height: 6, '1' Height: 6</front>
<front id="dogm_font_data_6x9_marlinH-5">  Calculated Max Values w= 6 h= 9 x= 2 y= 7 dx= 6 dy= 0 ascent= 7 len= 9</front>
<front id="dogm_font_data_6x9_marlinH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_6x9_marlinH-7">  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0</front>
<front id="dogm_font_data_6x9_marlinH-8">  Pure Font   ascent = 6 descent=-2</front>
<front id="dogm_font_data_6x9_marlinH-9">  X Font      ascent = 6 descent=-2</front>
<front id="dogm_font_data_6x9_marlinH-10">  Max Font    ascent = 7 descent=-2</front>
<front id="dogm_font_data_6x9_marlinH-11">*/</front>
<front id="dogm_font_data_6x9_marlinH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_6x9_marlinH-13">const u8g_fntpgm_uint8_t u8g_font_6x9[2300] U8G_SECTION(".progmem.u8g_font_6x9") = {</front>
<front id="dogm_font_data_6x9_marlinH-14">  0,6,9,0,254,6,1,137,2,254,32,255,254,7,254,6,</front>
<front id="dogm_font_data_6x9_marlinH-15">  254,0,0,0,6,0,7,1,6,6,6,2,0,128,128,128,</front>
<front id="dogm_font_data_6x9_marlinH-16">  128,0,128,3,3,3,6,1,3,160,160,160,5,7,7,6,</front>
<front id="dogm_font_data_6x9_marlinH-17">  0,255,80,80,248,80,248,80,80,5,9,9,6,0,254,32,</front>
<front id="dogm_font_data_6x9_marlinH-18">  112,168,160,112,40,168,112,32,6,8,8,6,0,255,64,168,</front>
<front id="dogm_font_data_6x9_marlinH-19">  72,16,32,72,84,8,5,7,7,6,0,255,96,144,144,96,</front>
<front id="dogm_font_data_6x9_marlinH-20">  152,144,104,1,3,3,6,2,3,128,128,128,2,7,7,6,</front>
<front id="dogm_font_data_6x9_marlinH-21">  2,255,64,128,128,128,128,128,64,2,7,7,6,2,255,128,</front>
<front id="dogm_font_data_6x9_marlinH-22">  64,64,64,64,64,128,5,5,5,6,0,0,136,80,248,80,</front>
<front id="dogm_font_data_6x9_marlinH-23">  136,5,5,5,6,0,0,32,32,248,32,32,2,4,4,6,</front>
<front id="dogm_font_data_6x9_marlinH-24">  2,254,192,64,64,128,5,1,1,6,0,2,248,2,2,2,</front>
<front id="dogm_font_data_6x9_marlinH-25">  6,2,0,192,192,4,6,6,6,1,0,16,16,32,64,128,</front>
<front id="dogm_font_data_6x9_marlinH-26">  128,4,6,6,6,1,0,96,144,144,144,144,96,3,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-27">  6,1,0,64,192,64,64,64,224,4,6,6,6,1,0,96,</front>
<front id="dogm_font_data_6x9_marlinH-28">  144,16,32,64,240,4,6,6,6,1,0,240,32,96,16,16,</front>
<front id="dogm_font_data_6x9_marlinH-29">  224,5,6,6,6,0,0,16,48,80,144,248,16,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-30">  6,1,0,240,128,224,16,16,224,4,6,6,6,1,0,96,</front>
<front id="dogm_font_data_6x9_marlinH-31">  128,224,144,144,96,4,6,6,6,1,0,240,16,16,32,64,</front>
<front id="dogm_font_data_6x9_marlinH-32">  64,4,6,6,6,1,0,96,144,96,144,144,96,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-33">  6,1,0,96,144,144,112,16,96,2,5,5,6,2,0,192,</front>
<front id="dogm_font_data_6x9_marlinH-34">  192,0,192,192,2,7,7,6,2,254,192,192,0,192,64,64,</front>
<front id="dogm_font_data_6x9_marlinH-35">  128,5,5,5,6,0,0,24,96,128,96,24,5,3,3,6,</front>
<front id="dogm_font_data_6x9_marlinH-36">  0,1,248,0,248,5,5,5,6,0,0,192,48,8,48,192,</front>
<front id="dogm_font_data_6x9_marlinH-37">  4,7,7,6,1,0,96,144,16,96,64,0,64,5,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-38">  6,0,0,112,144,168,176,128,112,5,6,6,6,0,0,32,</front>
<front id="dogm_font_data_6x9_marlinH-39">  80,136,248,136,136,5,6,6,6,0,0,240,136,240,136,136,</front>
<front id="dogm_font_data_6x9_marlinH-40">  240,4,6,6,6,1,0,96,144,128,128,144,96,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-41">  6,1,0,224,144,144,144,144,224,4,6,6,6,1,0,240,</front>
<front id="dogm_font_data_6x9_marlinH-42">  128,224,128,128,240,4,6,6,6,1,0,240,128,224,128,128,</front>
<front id="dogm_font_data_6x9_marlinH-43">  128,4,6,6,6,1,0,96,144,128,176,144,96,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-44">  6,1,0,144,144,240,144,144,144,3,6,6,6,1,0,224,</front>
<front id="dogm_font_data_6x9_marlinH-45">  64,64,64,64,224,5,6,6,6,0,0,56,16,16,16,144,</front>
<front id="dogm_font_data_6x9_marlinH-46">  96,4,6,6,6,1,0,144,160,192,160,144,144,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-47">  6,1,0,128,128,128,128,128,240,5,6,6,6,0,0,136,</front>
<front id="dogm_font_data_6x9_marlinH-48">  216,168,168,136,136,4,6,6,6,1,0,144,208,176,144,144,</front>
<front id="dogm_font_data_6x9_marlinH-49">  144,5,6,6,6,0,0,112,136,136,136,136,112,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-50">  6,1,0,224,144,144,224,128,128,4,7,7,6,1,255,96,</front>
<front id="dogm_font_data_6x9_marlinH-51">  144,144,208,176,96,16,4,6,6,6,1,0,224,144,144,224,</front>
<front id="dogm_font_data_6x9_marlinH-52">  144,144,4,6,6,6,1,0,96,144,64,32,144,96,5,6,</front>
<front id="dogm_font_data_6x9_marlinH-53">  6,6,0,0,248,32,32,32,32,32,4,6,6,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-54">  144,144,144,144,144,96,4,6,6,6,1,0,144,144,144,240,</front>
<front id="dogm_font_data_6x9_marlinH-55">  96,96,5,6,6,6,0,0,136,136,168,168,216,136,5,6,</front>
<front id="dogm_font_data_6x9_marlinH-56">  6,6,0,0,136,80,32,32,80,136,5,6,6,6,0,0,</front>
<front id="dogm_font_data_6x9_marlinH-57">  136,136,80,32,32,32,4,6,6,6,1,0,240,16,32,64,</front>
<front id="dogm_font_data_6x9_marlinH-58">  128,240,3,6,6,6,1,0,224,128,128,128,128,224,4,6,</front>
<front id="dogm_font_data_6x9_marlinH-59">  6,6,1,0,128,128,64,32,16,16,3,6,6,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-60">  224,32,32,32,32,224,5,3,3,6,0,3,32,80,136,5,</front>
<front id="dogm_font_data_6x9_marlinH-61">  1,1,6,0,254,248,2,2,2,6,2,4,128,64,4,4,</front>
<front id="dogm_font_data_6x9_marlinH-62">  4,6,1,0,112,144,144,112,4,6,6,6,1,0,128,128,</front>
<front id="dogm_font_data_6x9_marlinH-63">  224,144,144,224,4,4,4,6,1,0,112,128,128,112,4,6,</front>
<front id="dogm_font_data_6x9_marlinH-64">  6,6,1,0,16,16,112,144,144,112,4,4,4,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-65">  96,176,192,112,4,6,6,6,1,0,32,80,64,224,64,64,</front>
<front id="dogm_font_data_6x9_marlinH-66">  4,6,6,6,1,254,96,144,144,112,16,96,4,6,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-67">  1,0,128,128,224,144,144,144,3,6,6,6,1,0,64,0,</front>
<front id="dogm_font_data_6x9_marlinH-68">  192,64,64,224,3,8,8,6,1,254,32,0,96,32,32,32,</front>
<front id="dogm_font_data_6x9_marlinH-69">  160,64,4,6,6,6,1,0,128,128,160,192,160,144,3,6,</front>
<front id="dogm_font_data_6x9_marlinH-70">  6,6,1,0,192,64,64,64,64,224,5,4,4,6,0,0,</front>
<front id="dogm_font_data_6x9_marlinH-71">  208,168,168,136,4,4,4,6,1,0,224,144,144,144,4,4,</front>
<front id="dogm_font_data_6x9_marlinH-72">  4,6,1,0,96,144,144,96,4,6,6,6,1,254,224,144,</front>
<front id="dogm_font_data_6x9_marlinH-73">  144,224,128,128,4,6,6,6,1,254,112,144,144,112,16,16,</front>
<front id="dogm_font_data_6x9_marlinH-74">  4,4,4,6,1,0,160,208,128,128,4,4,4,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-75">  112,192,48,224,4,6,6,6,1,0,64,64,224,64,80,32,</front>
<front id="dogm_font_data_6x9_marlinH-76">  4,4,4,6,1,0,144,144,144,112,4,4,4,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-77">  144,144,96,96,5,4,4,6,0,0,136,168,168,80,4,4,</front>
<front id="dogm_font_data_6x9_marlinH-78">  4,6,1,0,144,96,96,144,4,6,6,6,1,254,144,144,</front>
<front id="dogm_font_data_6x9_marlinH-79">  144,112,144,96,4,4,4,6,1,0,240,32,64,240,3,7,</front>
<front id="dogm_font_data_6x9_marlinH-80">  7,6,1,0,32,64,64,128,64,64,32,1,7,7,6,2,</front>
<front id="dogm_font_data_6x9_marlinH-81">  255,128,128,128,128,128,128,128,3,7,7,6,1,0,128,64,</front>
<front id="dogm_font_data_6x9_marlinH-82">  64,32,64,64,128,4,2,2,6,1,3,80,160,255,255,255,</front>
<front id="dogm_font_data_6x9_marlinH-83">  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,</front>
<front id="dogm_font_data_6x9_marlinH-84">  255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,</front>
<front id="dogm_font_data_6x9_marlinH-85">  0,6,0,7,1,6,6,6,2,0,128,0,128,128,128,128,</front>
<front id="dogm_font_data_6x9_marlinH-86">  4,6,6,6,1,255,32,112,160,160,112,32,5,7,7,6,</front>
<front id="dogm_font_data_6x9_marlinH-87">  0,255,48,72,64,240,64,64,248,5,5,5,6,0,0,168,</front>
<front id="dogm_font_data_6x9_marlinH-88">  80,136,80,168,5,6,6,6,0,0,136,80,248,32,248,32,</front>
<front id="dogm_font_data_6x9_marlinH-89">  1,7,7,6,2,255,128,128,128,0,128,128,128,4,7,7,</front>
<front id="dogm_font_data_6x9_marlinH-90">  6,1,255,112,128,96,144,96,16,224,3,1,1,6,1,5,</front>
<front id="dogm_font_data_6x9_marlinH-91">  160,6,7,7,6,0,0,120,132,148,164,148,132,120,3,5,</front>
<front id="dogm_font_data_6x9_marlinH-92">  5,6,1,1,96,160,96,0,224,5,5,5,6,0,0,40,</front>
<front id="dogm_font_data_6x9_marlinH-93">  80,160,80,40,4,3,3,6,1,0,240,16,16,4,1,1,</front>
<front id="dogm_font_data_6x9_marlinH-94">  6,1,2,240,6,7,7,6,0,0,120,132,180,164,164,132,</front>
<front id="dogm_font_data_6x9_marlinH-95">  120,4,1,1,6,1,5,240,4,3,3,6,1,2,96,144,</front>
<front id="dogm_font_data_6x9_marlinH-96">  96,5,7,7,6,0,255,32,32,248,32,32,0,248,3,5,</front>
<front id="dogm_font_data_6x9_marlinH-97">  5,6,1,1,64,160,32,64,224,3,5,5,6,1,1,192,</front>
<front id="dogm_font_data_6x9_marlinH-98">  32,64,32,192,2,2,2,6,2,4,64,128,4,5,5,6,</front>
<front id="dogm_font_data_6x9_marlinH-99">  1,255,144,144,176,208,128,5,6,6,6,0,0,120,232,232,</front>
<front id="dogm_font_data_6x9_marlinH-100">  104,40,40,1,1,1,6,2,2,128,2,2,2,6,2,254,</front>
<front id="dogm_font_data_6x9_marlinH-101">  64,128,3,5,5,6,1,1,64,192,64,64,224,3,5,5,</front>
<front id="dogm_font_data_6x9_marlinH-102">  6,1,1,64,160,64,0,224,5,5,5,6,0,0,160,80,</front>
<front id="dogm_font_data_6x9_marlinH-103">  40,80,160,5,8,8,6,0,255,64,192,64,80,112,48,120,</front>
<front id="dogm_font_data_6x9_marlinH-104">  16,5,8,8,6,0,255,64,192,64,80,104,8,16,56,5,</front>
<front id="dogm_font_data_6x9_marlinH-105">  8,8,6,0,255,192,32,64,48,240,48,120,16,4,7,7,</front>
<front id="dogm_font_data_6x9_marlinH-106">  6,1,0,32,0,32,96,128,144,96,5,7,7,6,0,0,</front>
<front id="dogm_font_data_6x9_marlinH-107">  64,32,32,80,112,136,136,5,7,7,6,0,0,16,32,32,</front>
<front id="dogm_font_data_6x9_marlinH-108">  80,112,136,136,5,7,7,6,0,0,32,80,32,80,112,136,</front>
<front id="dogm_font_data_6x9_marlinH-109">  136,5,7,7,6,0,0,40,80,32,80,112,136,136,5,7,</front>
<front id="dogm_font_data_6x9_marlinH-110">  7,6,0,0,80,0,32,80,112,136,136,5,7,7,6,0,</front>
<front id="dogm_font_data_6x9_marlinH-111">  0,32,80,32,80,112,136,136,5,6,6,6,0,0,120,160,</front>
<front id="dogm_font_data_6x9_marlinH-112">  240,160,160,184,4,8,8,6,1,254,96,144,128,128,144,96,</front>
<front id="dogm_font_data_6x9_marlinH-113">  32,64,4,7,7,6,1,0,64,32,240,128,224,128,240,4,</front>
<front id="dogm_font_data_6x9_marlinH-114">  7,7,6,1,0,32,64,240,128,224,128,240,4,7,7,6,</front>
<front id="dogm_font_data_6x9_marlinH-115">  1,0,32,80,240,128,224,128,240,4,7,7,6,1,0,80,</front>
<front id="dogm_font_data_6x9_marlinH-116">  0,240,128,224,128,240,3,7,7,6,1,0,128,64,224,64,</front>
<front id="dogm_font_data_6x9_marlinH-117">  64,64,224,3,7,7,6,1,0,32,64,224,64,64,64,224,</front>
<front id="dogm_font_data_6x9_marlinH-118">  3,7,7,6,1,0,64,160,224,64,64,64,224,3,7,7,</front>
<front id="dogm_font_data_6x9_marlinH-119">  6,1,0,160,0,224,64,64,64,224,5,6,6,6,0,0,</front>
<front id="dogm_font_data_6x9_marlinH-120">  112,72,232,72,72,112,4,7,7,6,1,0,80,160,144,208,</front>
<front id="dogm_font_data_6x9_marlinH-121">  176,144,144,4,7,7,6,1,0,64,32,96,144,144,144,96,</front>
<front id="dogm_font_data_6x9_marlinH-122">  4,7,7,6,1,0,32,64,96,144,144,144,96,4,7,7,</front>
<front id="dogm_font_data_6x9_marlinH-123">  6,1,0,32,80,96,144,144,144,96,4,7,7,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-124">  80,160,96,144,144,144,96,4,7,7,6,1,0,80,0,96,</front>
<front id="dogm_font_data_6x9_marlinH-125">  144,144,144,96,5,5,5,6,0,0,136,80,32,80,136,4,</front>
<front id="dogm_font_data_6x9_marlinH-126">  8,8,6,1,255,16,112,176,176,208,208,224,128,4,7,7,</front>
<front id="dogm_font_data_6x9_marlinH-127">  6,1,0,64,32,144,144,144,144,96,4,7,7,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-128">  32,64,144,144,144,144,96,4,7,7,6,1,0,32,80,144,</front>
<front id="dogm_font_data_6x9_marlinH-129">  144,144,144,96,4,7,7,6,1,0,80,0,144,144,144,144,</front>
<front id="dogm_font_data_6x9_marlinH-130">  96,5,7,7,6,0,0,16,32,136,80,32,32,32,4,6,</front>
<front id="dogm_font_data_6x9_marlinH-131">  6,6,1,0,128,224,144,144,224,128,4,6,6,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-132">  96,144,160,160,144,160,4,7,7,6,1,0,64,32,0,112,</front>
<front id="dogm_font_data_6x9_marlinH-133">  144,144,112,4,7,7,6,1,0,32,64,0,112,144,144,112,</front>
<front id="dogm_font_data_6x9_marlinH-134">  4,7,7,6,1,0,32,80,0,112,144,144,112,4,7,7,</front>
<front id="dogm_font_data_6x9_marlinH-135">  6,1,0,80,160,0,112,144,144,112,4,6,6,6,1,0,</front>
<front id="dogm_font_data_6x9_marlinH-136">  80,0,112,144,144,112,4,7,7,6,1,0,32,80,32,112,</front>
<front id="dogm_font_data_6x9_marlinH-137">  144,144,112,5,4,4,6,0,0,112,168,176,120,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-138">  6,1,254,112,128,128,112,32,64,4,7,7,6,1,0,64,</front>
<front id="dogm_font_data_6x9_marlinH-139">  32,0,96,176,192,112,4,7,7,6,1,0,32,64,0,96,</front>
<front id="dogm_font_data_6x9_marlinH-140">  176,192,112,4,7,7,6,1,0,32,80,0,96,176,192,112,</front>
<front id="dogm_font_data_6x9_marlinH-141">  4,6,6,6,1,0,80,0,96,176,192,112,3,7,7,6,</front>
<front id="dogm_font_data_6x9_marlinH-142">  1,0,128,64,0,192,64,64,224,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_6x9_marlinH-143">  64,0,192,64,64,224,3,7,7,6,1,0,64,160,0,192,</front>
<front id="dogm_font_data_6x9_marlinH-144">  64,64,224,3,6,6,6,1,0,160,0,192,64,64,224,4,</front>
<front id="dogm_font_data_6x9_marlinH-145">  7,7,6,1,0,48,96,16,112,144,144,96,4,7,7,6,</front>
<front id="dogm_font_data_6x9_marlinH-146">  1,0,80,160,0,224,144,144,144,4,7,7,6,1,0,64,</front>
<front id="dogm_font_data_6x9_marlinH-147">  32,0,96,144,144,96,4,7,7,6,1,0,32,64,0,96,</front>
<front id="dogm_font_data_6x9_marlinH-148">  144,144,96,4,7,7,6,1,0,32,80,0,96,144,144,96,</front>
<front id="dogm_font_data_6x9_marlinH-149">  4,7,7,6,1,0,80,160,0,96,144,144,96,4,6,6,</front>
<front id="dogm_font_data_6x9_marlinH-150">  6,1,0,80,0,96,144,144,96,5,5,5,6,0,0,32,</front>
<front id="dogm_font_data_6x9_marlinH-151">  0,248,0,32,4,4,4,6,1,0,112,176,208,224,4,7,</front>
<front id="dogm_font_data_6x9_marlinH-152">  7,6,1,0,64,32,0,144,144,144,112,4,7,7,6,1,</front>
<front id="dogm_font_data_6x9_marlinH-153">  0,32,64,0,144,144,144,112,4,7,7,6,1,0,32,80,</front>
<front id="dogm_font_data_6x9_marlinH-154">  0,144,144,144,112,4,6,6,6,1,0,80,0,144,144,144,</front>
<front id="dogm_font_data_6x9_marlinH-155">  112,4,9,9,6,1,254,32,64,0,144,144,144,112,144,96,</front>
<front id="dogm_font_data_6x9_marlinH-156">  4,8,8,6,1,254,128,128,224,144,144,224,128,128,4,8,</front>
<front id="dogm_font_data_6x9_marlinH-157">  8,6,1,254,80,0,144,144,144,112,144,96};</front>
 </pre>
<h1 id="dogm_font_data_HD44780_CHtitle" >dogm_font_data_HD44780_C.h</h1>
<pre id="dogm_font_data_HD44780_CH"  class="prettyprint linenums"><front id="dogm_font_data_HD44780_CH-1">/*</front>
<front id="dogm_font_data_HD44780_CH-2">  Fontname: HD44780_C v1.2</front>
<front id="dogm_font_data_HD44780_CH-3">  Copyright: A. Hardtung, public domain</front>
<front id="dogm_font_data_HD44780_CH-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_HD44780_CH-5">  Calculated Max Values w= 5 h= 8 x= 2 y= 7 dx= 6 dy= 0 ascent= 8 len= 8</front>
<front id="dogm_font_data_HD44780_CH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_HD44780_CH-7">  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0</front>
<front id="dogm_font_data_HD44780_CH-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_HD44780_CH-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_HD44780_CH-10">  Max Font    ascent = 8 descent=-1</front>
<front id="dogm_font_data_HD44780_CH-11">*/</front>
<front id="dogm_font_data_HD44780_CH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_HD44780_CH-13">const u8g_fntpgm_uint8_t HD44780_C_5x7[2522] U8G_SECTION(".progmem.HD44780_C_5x7") = {</front>
<front id="dogm_font_data_HD44780_CH-14">  0,6,9,0,254,7,1,145,3,34,32,255,255,8,255,7,</front>
<front id="dogm_font_data_HD44780_CH-15">  255,0,0,0,6,0,0,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_HD44780_CH-16">  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_CH-17">  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_HD44780_CH-18">  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,</front>
<front id="dogm_font_data_HD44780_CH-19">  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,</front>
<front id="dogm_font_data_HD44780_CH-20">  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_HD44780_CH-21">  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,</front>
<front id="dogm_font_data_HD44780_CH-22">  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,</front>
<front id="dogm_font_data_HD44780_CH-23">  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,</front>
<front id="dogm_font_data_HD44780_CH-24">  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,</front>
<front id="dogm_font_data_HD44780_CH-25">  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_CH-26">  0,0,112,136,152,168,200,136,112,3,7,7,6,1,0,64,</front>
<front id="dogm_font_data_HD44780_CH-27">  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,</front>
<front id="dogm_font_data_HD44780_CH-28">  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,</front>
<front id="dogm_font_data_HD44780_CH-29">  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-30">  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-31">  48,64,128,240,136,136,112,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_HD44780_CH-32">  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,</front>
<front id="dogm_font_data_HD44780_CH-33">  112,5,7,7,6,0,0,112,136,136,120,8,16,96,2,5,</front>
<front id="dogm_font_data_HD44780_CH-34">  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,</front>
<front id="dogm_font_data_HD44780_CH-35">  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,</front>
<front id="dogm_font_data_HD44780_CH-36">  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,1,</front>
<front id="dogm_font_data_HD44780_CH-37">  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_HD44780_CH-38">  8,16,32,0,32,5,6,6,6,0,0,112,136,8,104,168,</front>
<front id="dogm_font_data_HD44780_CH-39">  112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,7,</front>
<front id="dogm_font_data_HD44780_CH-40">  7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_CH-41">  0,112,136,128,128,128,136,112,5,7,7,6,0,0,224,144,</front>
<front id="dogm_font_data_HD44780_CH-42">  136,136,136,144,224,5,7,7,6,0,0,248,128,128,240,128,</front>
<front id="dogm_font_data_HD44780_CH-43">  128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,5,</front>
<front id="dogm_font_data_HD44780_CH-44">  7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_CH-45">  0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,128,</front>
<front id="dogm_font_data_HD44780_CH-46">  128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,16,</front>
<front id="dogm_font_data_HD44780_CH-47">  16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,136,</front>
<front id="dogm_font_data_HD44780_CH-48">  5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-49">  6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-50">  136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,136,</front>
<front id="dogm_font_data_HD44780_CH-51">  136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,128,</front>
<front id="dogm_font_data_HD44780_CH-52">  128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,7,</front>
<front id="dogm_font_data_HD44780_CH-53">  7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_CH-54">  0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,32,</front>
<front id="dogm_font_data_HD44780_CH-55">  32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,136,</front>
<front id="dogm_font_data_HD44780_CH-56">  136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,5,</front>
<front id="dogm_font_data_HD44780_CH-57">  7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_CH-58">  0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,136,</front>
<front id="dogm_font_data_HD44780_CH-59">  136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,32,</front>
<front id="dogm_font_data_HD44780_CH-60">  64,128,248,3,7,7,6,1,0,224,128,128,128,128,128,224,</front>
<front id="dogm_font_data_HD44780_CH-61">  5,7,7,6,0,0,32,112,160,160,168,112,32,3,7,7,</front>
<front id="dogm_font_data_HD44780_CH-62">  6,1,0,224,32,32,32,32,32,224,5,3,3,6,0,4,</front>
<front id="dogm_font_data_HD44780_CH-63">  32,80,136,5,1,1,6,0,0,248,2,2,2,6,2,5,</front>
<front id="dogm_font_data_HD44780_CH-64">  128,64,5,5,5,6,0,0,112,8,120,136,120,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-65">  6,0,0,128,128,176,200,136,136,240,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-66">  112,128,128,136,112,5,7,7,6,0,0,8,8,104,152,136,</front>
<front id="dogm_font_data_HD44780_CH-67">  136,120,5,5,5,6,0,0,112,136,248,128,112,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-68">  6,0,0,48,72,224,64,64,64,64,5,6,6,6,0,255,</front>
<front id="dogm_font_data_HD44780_CH-69">  112,136,136,120,8,112,5,7,7,6,0,0,128,128,176,200,</front>
<front id="dogm_font_data_HD44780_CH-70">  136,136,136,1,7,7,6,2,0,128,0,128,128,128,128,128,</front>
<front id="dogm_font_data_HD44780_CH-71">  3,8,8,6,1,255,32,0,32,32,32,32,160,64,4,7,</front>
<front id="dogm_font_data_HD44780_CH-72">  7,6,0,0,128,128,144,160,192,160,144,3,7,7,6,1,</front>
<front id="dogm_font_data_HD44780_CH-73">  0,192,64,64,64,64,64,224,5,5,5,6,0,0,208,168,</front>
<front id="dogm_font_data_HD44780_CH-74">  168,168,168,5,5,5,6,0,0,176,200,136,136,136,5,5,</front>
<front id="dogm_font_data_HD44780_CH-75">  5,6,0,0,112,136,136,136,112,5,6,6,6,0,255,240,</front>
<front id="dogm_font_data_HD44780_CH-76">  136,136,240,128,128,5,6,6,6,0,255,120,136,136,120,8,</front>
<front id="dogm_font_data_HD44780_CH-77">  8,5,5,5,6,0,0,176,200,128,128,128,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_CH-78">  0,0,112,128,112,8,240,5,7,7,6,0,0,64,64,224,</front>
<front id="dogm_font_data_HD44780_CH-79">  64,64,72,48,5,5,5,6,0,0,136,136,136,152,104,5,</front>
<front id="dogm_font_data_HD44780_CH-80">  5,5,6,0,0,136,136,136,80,32,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-81">  136,136,168,168,80,5,5,5,6,0,0,136,80,32,80,136,</front>
<front id="dogm_font_data_HD44780_CH-82">  5,6,6,6,0,255,136,136,136,120,8,112,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_CH-83">  0,0,248,16,32,64,248,5,5,5,6,0,2,184,168,168,</front>
<front id="dogm_font_data_HD44780_CH-84">  168,184,5,5,5,6,0,2,184,136,184,160,184,5,5,5,</front>
<front id="dogm_font_data_HD44780_CH-85">  6,0,2,184,160,184,136,184,5,6,6,6,0,1,8,40,</front>
<front id="dogm_font_data_HD44780_CH-86">  72,248,64,32,5,5,5,6,0,0,56,112,224,136,240,0,</front>
<front id="dogm_font_data_HD44780_CH-87">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_HD44780_CH-88">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-89">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-90">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_HD44780_CH-91">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-92">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-93">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_HD44780_CH-94">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-95">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-96">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_HD44780_CH-97">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_HD44780_CH-98">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,5,</front>
<front id="dogm_font_data_HD44780_CH-99">  7,7,6,0,0,248,136,128,240,136,136,240,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_CH-100">  0,0,248,136,128,128,128,128,128,5,7,7,6,0,0,80,</front>
<front id="dogm_font_data_HD44780_CH-101">  0,248,128,240,128,248,5,7,7,6,0,0,168,168,168,112,</front>
<front id="dogm_font_data_HD44780_CH-102">  168,168,168,5,7,7,6,0,0,240,8,8,112,8,8,240,</front>
<front id="dogm_font_data_HD44780_CH-103">  5,7,7,6,0,0,136,136,152,168,200,136,136,5,8,8,</front>
<front id="dogm_font_data_HD44780_CH-104">  6,0,0,80,32,136,152,168,168,200,136,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_CH-105">  0,120,40,40,40,40,168,72,5,7,7,6,0,0,248,136,</front>
<front id="dogm_font_data_HD44780_CH-106">  136,136,136,136,136,5,7,7,6,0,0,136,136,136,80,32,</front>
<front id="dogm_font_data_HD44780_CH-107">  64,128,5,7,7,6,0,0,32,112,168,168,168,112,32,5,</front>
<front id="dogm_font_data_HD44780_CH-108">  7,7,6,0,0,136,136,136,120,8,8,8,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_CH-109">  0,0,168,168,168,168,168,168,248,5,7,7,6,0,0,192,</front>
<front id="dogm_font_data_HD44780_CH-110">  64,64,112,72,72,112,5,7,7,6,0,0,136,136,136,200,</front>
<front id="dogm_font_data_HD44780_CH-111">  168,168,200,5,7,7,6,0,0,112,136,8,56,8,136,112,</front>
<front id="dogm_font_data_HD44780_CH-112">  5,7,7,6,0,0,144,168,168,232,168,168,144,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-113">  6,0,0,120,136,136,120,40,72,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-114">  24,96,128,240,136,136,112,4,5,5,6,0,0,224,144,224,</front>
<front id="dogm_font_data_HD44780_CH-115">  144,224,5,5,5,6,0,0,248,136,128,128,128,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-116">  6,0,0,80,0,112,136,248,128,112,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-117">  168,168,112,168,168,5,5,5,6,0,0,240,8,48,8,240,</front>
<front id="dogm_font_data_HD44780_CH-118">  5,5,5,6,0,0,136,152,168,200,136,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_CH-119">  0,80,32,136,152,168,200,136,4,5,5,6,0,0,144,160,</front>
<front id="dogm_font_data_HD44780_CH-120">  192,160,144,5,5,5,6,0,0,248,40,40,168,72,5,5,</front>
<front id="dogm_font_data_HD44780_CH-121">  5,6,0,0,136,216,168,136,136,5,5,5,6,0,0,136,</front>
<front id="dogm_font_data_HD44780_CH-122">  136,248,136,136,5,5,5,6,0,0,248,136,136,136,136,5,</front>
<front id="dogm_font_data_HD44780_CH-123">  5,5,6,0,0,248,32,32,32,32,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-124">  136,136,120,8,8,5,5,5,6,0,0,168,168,168,168,248,</front>
<front id="dogm_font_data_HD44780_CH-125">  5,5,5,6,0,0,192,64,112,72,112,5,5,5,6,0,</front>
<front id="dogm_font_data_HD44780_CH-126">  0,136,136,200,168,200,4,5,5,6,0,0,128,128,224,144,</front>
<front id="dogm_font_data_HD44780_CH-127">  224,5,5,5,6,0,0,112,136,56,136,112,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_CH-128">  0,0,144,168,232,168,144,5,5,5,6,0,0,120,136,120,</front>
<front id="dogm_font_data_HD44780_CH-129">  40,72,5,5,5,6,0,1,32,72,144,72,32,5,5,5,</front>
<front id="dogm_font_data_HD44780_CH-130">  6,0,1,32,144,72,144,32,5,3,3,6,0,0,72,144,</front>
<front id="dogm_font_data_HD44780_CH-131">  216,5,3,3,6,0,4,216,72,144,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-132">  144,208,176,144,56,40,56,5,7,7,6,0,0,32,0,32,</front>
<front id="dogm_font_data_HD44780_CH-133">  64,128,136,112,5,7,7,6,0,0,24,32,32,112,32,32,</front>
<front id="dogm_font_data_HD44780_CH-134">  192,5,7,7,6,0,0,32,80,64,240,64,64,120,1,2,</front>
<front id="dogm_font_data_HD44780_CH-135">  2,6,2,0,128,128,1,4,4,6,2,0,128,128,128,128,</front>
<front id="dogm_font_data_HD44780_CH-136">  3,5,5,6,1,0,160,160,160,0,224,3,5,5,6,1,</front>
<front id="dogm_font_data_HD44780_CH-137">  0,160,160,160,0,160,5,7,7,6,0,0,160,0,232,16,</front>
<front id="dogm_font_data_HD44780_CH-138">  32,64,128,5,5,5,6,0,1,216,112,32,112,216,5,7,</front>
<front id="dogm_font_data_HD44780_CH-139">  7,6,0,0,160,64,168,16,32,64,128,3,6,6,6,1,</front>
<front id="dogm_font_data_HD44780_CH-140">  1,224,64,64,64,64,224,5,6,6,6,0,1,248,80,80,</front>
<front id="dogm_font_data_HD44780_CH-141">  80,80,248,5,7,7,6,0,0,32,112,168,32,32,32,32,</front>
<front id="dogm_font_data_HD44780_CH-142">  5,7,7,6,0,0,32,32,32,32,168,112,32,5,7,7,</front>
<front id="dogm_font_data_HD44780_CH-143">  6,0,0,128,144,176,248,176,144,128,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_CH-144">  8,72,104,248,104,72,8,5,7,7,6,0,0,128,136,168,</front>
<front id="dogm_font_data_HD44780_CH-145">  248,168,136,128,5,7,7,6,0,0,128,224,136,16,32,64,</front>
<front id="dogm_font_data_HD44780_CH-146">  128,2,2,2,6,2,2,192,192,5,8,8,6,0,255,120,</front>
<front id="dogm_font_data_HD44780_CH-147">  40,40,40,72,136,248,136,5,8,8,6,0,255,136,136,136,</front>
<front id="dogm_font_data_HD44780_CH-148">  136,136,136,248,8,5,8,8,6,0,255,168,168,168,168,168,</front>
<front id="dogm_font_data_HD44780_CH-149">  168,248,8,5,6,6,6,0,255,120,40,72,136,248,136,5,</front>
<front id="dogm_font_data_HD44780_CH-150">  7,7,6,0,255,32,32,112,168,168,112,32,5,6,6,6,</front>
<front id="dogm_font_data_HD44780_CH-151">  0,255,136,136,136,136,248,8,5,6,6,6,0,255,168,168,</front>
<front id="dogm_font_data_HD44780_CH-152">  168,168,248,8,2,2,2,6,2,6,64,128,3,1,1,6,</front>
<front id="dogm_font_data_HD44780_CH-153">  1,7,160,5,2,2,6,0,6,72,176,5,8,8,6,0,</front>
<front id="dogm_font_data_HD44780_CH-154">  0,16,32,0,112,136,248,128,112,5,6,6,6,0,255,112,</front>
<front id="dogm_font_data_HD44780_CH-155">  128,136,112,32,96,3,7,7,6,1,0,160,0,160,160,160,</front>
<front id="dogm_font_data_HD44780_CH-156">  32,192,5,6,6,6,0,1,32,112,112,112,248,32,5,5,</front>
<front id="dogm_font_data_HD44780_CH-157">  5,6,0,1,80,0,136,0,80,5,5,5,6,0,1,112,</front>
<front id="dogm_font_data_HD44780_CH-158">  136,136,136,112,5,7,7,6,0,0,136,144,168,88,184,8,</front>
<front id="dogm_font_data_HD44780_CH-159">  8,5,7,7,6,0,0,136,144,184,72,184,8,56,5,7,</front>
<front id="dogm_font_data_HD44780_CH-160">  7,6,0,0,136,144,184,72,152,32,56,5,8,8,6,0,</front>
<front id="dogm_font_data_HD44780_CH-161">  0,192,64,192,72,216,56,8,8,5,7,7,6,0,0,136,</front>
<front id="dogm_font_data_HD44780_CH-162">  248,136,248,136,248,136,4,5,5,6,0,2,192,0,48,0,</front>
<front id="dogm_font_data_HD44780_CH-163">  96,5,8,8,6,0,0,64,160,224,168,8,40,120,32,5,</front>
<front id="dogm_font_data_HD44780_CH-164">  8,8,6,0,0,64,112,64,120,64,112,64,224,5,8,8,</front>
<front id="dogm_font_data_HD44780_CH-165">  6,0,0,32,112,32,248,32,112,32,112,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_CH-166">  0,104,0,232,0,104,16,56,5,8,8,6,0,0,16,112,</front>
<front id="dogm_font_data_HD44780_CH-167">  16,240,16,112,16,56,5,7,7,6,0,1,32,112,32,248,</front>
<front id="dogm_font_data_HD44780_CH-168">  32,112,32,5,8,8,6,0,0,16,144,80,48,80,144,16,</front>
<front id="dogm_font_data_HD44780_CH-169">  56,5,8,8,6,0,0,48,72,32,80,80,32,144,96,5,</front>
<front id="dogm_font_data_HD44780_CH-170">  7,7,6,0,0,120,168,168,120,40,40,40,5,8,8,6,</front>
<front id="dogm_font_data_HD44780_CH-171">  0,0,248,248,248,248,248,248,248,248};</front>
 </pre>
<h1 id="dogm_font_data_HD44780_JHtitle" >dogm_font_data_HD44780_J.h</h1>
<pre id="dogm_font_data_HD44780_JH"  class="prettyprint linenums"><front id="dogm_font_data_HD44780_JH-1">/*</front>
<front id="dogm_font_data_HD44780_JH-2">  Fontname: HD44780_J</front>
<front id="dogm_font_data_HD44780_JH-3">  Copyright: A. Hardtung, public domain</front>
<front id="dogm_font_data_HD44780_JH-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_HD44780_JH-5">  Calculated Max Values w= 6 h=10 x= 2 y= 8 dx= 6 dy= 0 ascent= 8 len= 8</front>
<front id="dogm_font_data_HD44780_JH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_HD44780_JH-7">  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0</front>
<front id="dogm_font_data_HD44780_JH-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_HD44780_JH-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_HD44780_JH-10">  Max Font    ascent = 8 descent=-2</front>
<front id="dogm_font_data_HD44780_JH-11">*/</front>
<front id="dogm_font_data_HD44780_JH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_HD44780_JH-13">const u8g_fntpgm_uint8_t HD44780_J_5x7[2491] U8G_SECTION(".progmem.HD44780_J_5x7") = {</front>
<front id="dogm_font_data_HD44780_JH-14">  0,6,9,0,254,7,1,145,3,34,32,255,255,8,254,7,</front>
<front id="dogm_font_data_HD44780_JH-15">  255,0,0,0,6,0,8,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_HD44780_JH-16">  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_JH-17">  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_HD44780_JH-18">  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,</front>
<front id="dogm_font_data_HD44780_JH-19">  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,</front>
<front id="dogm_font_data_HD44780_JH-20">  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_HD44780_JH-21">  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,</front>
<front id="dogm_font_data_HD44780_JH-22">  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,</front>
<front id="dogm_font_data_HD44780_JH-23">  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,</front>
<front id="dogm_font_data_HD44780_JH-24">  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,</front>
<front id="dogm_font_data_HD44780_JH-25">  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_JH-26">  0,0,112,136,152,168,200,136,112,3,7,7,6,1,0,64,</front>
<front id="dogm_font_data_HD44780_JH-27">  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,</front>
<front id="dogm_font_data_HD44780_JH-28">  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,</front>
<front id="dogm_font_data_HD44780_JH-29">  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,</front>
<front id="dogm_font_data_HD44780_JH-30">  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-31">  48,64,128,240,136,136,112,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_HD44780_JH-32">  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,</front>
<front id="dogm_font_data_HD44780_JH-33">  112,5,7,7,6,0,0,112,136,136,120,8,16,96,2,5,</front>
<front id="dogm_font_data_HD44780_JH-34">  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,</front>
<front id="dogm_font_data_HD44780_JH-35">  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,</front>
<front id="dogm_font_data_HD44780_JH-36">  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,1,</front>
<front id="dogm_font_data_HD44780_JH-37">  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_HD44780_JH-38">  8,16,32,0,32,5,6,6,6,0,0,112,136,8,104,168,</front>
<front id="dogm_font_data_HD44780_JH-39">  112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,7,</front>
<front id="dogm_font_data_HD44780_JH-40">  7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-41">  0,112,136,128,128,128,136,112,5,7,7,6,0,0,224,144,</front>
<front id="dogm_font_data_HD44780_JH-42">  136,136,136,144,224,5,7,7,6,0,0,248,128,128,240,128,</front>
<front id="dogm_font_data_HD44780_JH-43">  128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,5,</front>
<front id="dogm_font_data_HD44780_JH-44">  7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_JH-45">  0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,128,</front>
<front id="dogm_font_data_HD44780_JH-46">  128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,16,</front>
<front id="dogm_font_data_HD44780_JH-47">  16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,136,</front>
<front id="dogm_font_data_HD44780_JH-48">  5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,7,</front>
<front id="dogm_font_data_HD44780_JH-49">  6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-50">  136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,136,</front>
<front id="dogm_font_data_HD44780_JH-51">  136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,128,</front>
<front id="dogm_font_data_HD44780_JH-52">  128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,7,</front>
<front id="dogm_font_data_HD44780_JH-53">  7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-54">  0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,32,</front>
<front id="dogm_font_data_HD44780_JH-55">  32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,136,</front>
<front id="dogm_font_data_HD44780_JH-56">  136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,5,</front>
<front id="dogm_font_data_HD44780_JH-57">  7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_JH-58">  0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,136,</front>
<front id="dogm_font_data_HD44780_JH-59">  136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,32,</front>
<front id="dogm_font_data_HD44780_JH-60">  64,128,248,3,7,7,6,1,0,224,128,128,128,128,128,224,</front>
<front id="dogm_font_data_HD44780_JH-61">  5,7,7,6,0,0,136,80,248,32,248,32,32,3,7,7,</front>
<front id="dogm_font_data_HD44780_JH-62">  6,1,0,224,32,32,32,32,32,224,5,3,3,6,0,4,</front>
<front id="dogm_font_data_HD44780_JH-63">  32,80,136,5,1,1,6,0,0,248,2,2,2,6,2,5,</front>
<front id="dogm_font_data_HD44780_JH-64">  128,64,5,5,5,6,0,0,112,8,120,136,120,5,7,7,</front>
<front id="dogm_font_data_HD44780_JH-65">  6,0,0,128,128,176,200,136,136,240,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-66">  112,128,128,136,112,5,7,7,6,0,0,8,8,104,152,136,</front>
<front id="dogm_font_data_HD44780_JH-67">  136,120,5,5,5,6,0,0,112,136,248,128,112,5,7,7,</front>
<front id="dogm_font_data_HD44780_JH-68">  6,0,0,48,72,224,64,64,64,64,5,6,6,6,0,255,</front>
<front id="dogm_font_data_HD44780_JH-69">  112,136,136,120,8,112,5,7,7,6,0,0,128,128,176,200,</front>
<front id="dogm_font_data_HD44780_JH-70">  136,136,136,1,7,7,6,2,0,128,0,128,128,128,128,128,</front>
<front id="dogm_font_data_HD44780_JH-71">  3,8,8,6,1,255,32,0,32,32,32,32,160,64,4,7,</front>
<front id="dogm_font_data_HD44780_JH-72">  7,6,0,0,128,128,144,160,192,160,144,3,7,7,6,1,</front>
<front id="dogm_font_data_HD44780_JH-73">  0,192,64,64,64,64,64,224,5,5,5,6,0,0,208,168,</front>
<front id="dogm_font_data_HD44780_JH-74">  168,168,168,5,5,5,6,0,0,176,200,136,136,136,5,5,</front>
<front id="dogm_font_data_HD44780_JH-75">  5,6,0,0,112,136,136,136,112,5,6,6,6,0,255,240,</front>
<front id="dogm_font_data_HD44780_JH-76">  136,136,240,128,128,5,6,6,6,0,255,120,136,136,120,8,</front>
<front id="dogm_font_data_HD44780_JH-77">  8,5,5,5,6,0,0,176,200,128,128,128,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_JH-78">  0,0,112,128,112,8,240,5,7,7,6,0,0,64,64,224,</front>
<front id="dogm_font_data_HD44780_JH-79">  64,64,72,48,5,5,5,6,0,0,136,136,136,152,104,5,</front>
<front id="dogm_font_data_HD44780_JH-80">  5,5,6,0,0,136,136,136,80,32,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-81">  136,136,168,168,80,5,5,5,6,0,0,136,80,32,80,136,</front>
<front id="dogm_font_data_HD44780_JH-82">  5,6,6,6,0,255,136,136,136,120,8,112,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_JH-83">  0,0,248,16,32,64,248,3,7,7,6,1,0,32,64,64,</front>
<front id="dogm_font_data_HD44780_JH-84">  128,64,64,32,1,7,7,6,2,0,128,128,128,128,128,128,</front>
<front id="dogm_font_data_HD44780_JH-85">  128,3,7,7,6,1,0,128,64,64,32,64,64,128,5,5,</front>
<front id="dogm_font_data_HD44780_JH-86">  5,6,0,1,32,16,248,16,32,5,5,5,6,0,1,32,</front>
<front id="dogm_font_data_HD44780_JH-87">  64,248,64,32,0,0,0,6,0,8,0,0,0,6,0,8,</front>
<front id="dogm_font_data_HD44780_JH-88">  0,0,0,6,0,8,0,0,0,6,0,8,0,0,0,6,</front>
<front id="dogm_font_data_HD44780_JH-89">  0,8,0,0,0,6,0,8,0,0,0,6,0,8,0,0,</front>
<front id="dogm_font_data_HD44780_JH-90">  0,6,0,8,0,0,0,6,0,8,0,0,0,6,0,8,</front>
<front id="dogm_font_data_HD44780_JH-91">  0,0,0,6,0,8,0,0,0,6,0,8,0,0,0,6,</front>
<front id="dogm_font_data_HD44780_JH-92">  0,8,0,0,0,6,0,8,0,0,0,6,0,8,0,0,</front>
<front id="dogm_font_data_HD44780_JH-93">  0,6,0,8,0,0,0,6,0,8,0,0,0,6,0,8,</front>
<front id="dogm_font_data_HD44780_JH-94">  0,0,0,6,0,8,0,0,0,6,0,8,0,0,0,6,</front>
<front id="dogm_font_data_HD44780_JH-95">  0,8,0,0,0,6,0,8,0,0,0,6,0,8,0,0,</front>
<front id="dogm_font_data_HD44780_JH-96">  0,6,0,8,0,0,0,6,0,8,0,0,0,6,0,8,</front>
<front id="dogm_font_data_HD44780_JH-97">  0,0,0,6,0,8,0,0,0,6,0,8,0,0,0,6,</front>
<front id="dogm_font_data_HD44780_JH-98">  0,8,0,0,0,6,0,8,0,0,0,6,0,8,0,0,</front>
<front id="dogm_font_data_HD44780_JH-99">  0,6,0,8,0,0,0,6,0,8,3,3,3,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-100">  224,160,224,3,4,4,6,2,3,224,128,128,128,3,4,4,</front>
<front id="dogm_font_data_HD44780_JH-101">  6,0,0,32,32,32,224,3,3,3,6,0,0,128,64,32,</front>
<front id="dogm_font_data_HD44780_JH-102">  2,2,2,6,1,2,192,192,5,6,6,6,0,0,248,8,</front>
<front id="dogm_font_data_HD44780_JH-103">  248,8,16,32,5,5,5,6,0,0,248,8,48,32,64,4,</front>
<front id="dogm_font_data_HD44780_JH-104">  5,5,6,0,0,16,32,96,160,32,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-105">  32,248,136,8,48,5,4,4,6,0,0,248,32,32,248,5,</front>
<front id="dogm_font_data_HD44780_JH-106">  5,5,6,0,0,16,248,48,80,144,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-107">  64,248,72,80,64,5,4,4,6,0,0,112,16,16,248,4,</front>
<front id="dogm_font_data_HD44780_JH-108">  5,5,6,0,0,240,16,240,16,240,5,4,4,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-109">  168,168,8,48,5,1,1,6,0,4,248,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-110">  0,248,8,40,48,32,32,64,5,7,7,6,0,0,8,16,</front>
<front id="dogm_font_data_HD44780_JH-111">  32,96,160,32,32,5,7,7,6,0,0,32,248,136,136,8,</front>
<front id="dogm_font_data_HD44780_JH-112">  16,32,5,6,6,6,0,0,248,32,32,32,32,248,5,7,</front>
<front id="dogm_font_data_HD44780_JH-113">  7,6,0,0,16,248,16,48,80,144,16,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-114">  0,64,248,72,72,72,72,144,5,7,7,6,0,0,32,248,</front>
<front id="dogm_font_data_HD44780_JH-115">  32,248,32,32,32,5,6,6,6,0,0,120,72,136,8,16,</front>
<front id="dogm_font_data_HD44780_JH-116">  96,5,7,7,6,0,0,64,120,144,16,16,16,32,5,6,</front>
<front id="dogm_font_data_HD44780_JH-117">  6,6,0,0,248,8,8,8,8,248,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-118">  80,248,80,80,16,32,64,5,6,6,6,0,0,192,8,200,</front>
<front id="dogm_font_data_HD44780_JH-119">  8,16,224,5,6,6,6,0,0,248,8,16,32,80,136,5,</front>
<front id="dogm_font_data_HD44780_JH-120">  7,7,6,0,0,64,248,72,80,64,64,56,5,6,6,6,</front>
<front id="dogm_font_data_HD44780_JH-121">  0,0,136,136,72,8,16,96,5,6,6,6,0,0,120,72,</front>
<front id="dogm_font_data_HD44780_JH-122">  168,24,16,96,5,7,7,6,0,0,16,224,32,248,32,32,</front>
<front id="dogm_font_data_HD44780_JH-123">  64,5,6,6,6,0,0,168,168,168,8,16,32,5,7,7,</front>
<front id="dogm_font_data_HD44780_JH-124">  6,0,0,112,0,248,32,32,32,64,3,7,7,6,1,0,</front>
<front id="dogm_font_data_HD44780_JH-125">  128,128,128,192,160,128,128,5,7,7,6,0,0,32,32,248,</front>
<front id="dogm_font_data_HD44780_JH-126">  32,32,64,128,5,6,6,6,0,0,112,0,0,0,0,248,</front>
<front id="dogm_font_data_HD44780_JH-127">  5,6,6,6,0,0,248,8,80,32,80,128,5,6,6,6,</front>
<front id="dogm_font_data_HD44780_JH-128">  0,1,32,248,16,32,112,168,3,7,7,6,1,0,32,32,</front>
<front id="dogm_font_data_HD44780_JH-129">  32,32,32,64,128,5,6,6,6,0,0,32,16,136,136,136,</front>
<front id="dogm_font_data_HD44780_JH-130">  136,5,7,7,6,0,0,128,128,248,128,128,128,120,5,6,</front>
<front id="dogm_font_data_HD44780_JH-131">  6,6,0,0,248,8,8,8,16,96,5,5,5,6,0,1,</front>
<front id="dogm_font_data_HD44780_JH-132">  64,160,16,8,8,5,7,7,6,0,0,32,248,32,32,168,</front>
<front id="dogm_font_data_HD44780_JH-133">  168,32,5,6,6,6,0,0,248,8,8,80,32,16,4,6,</front>
<front id="dogm_font_data_HD44780_JH-134">  6,6,1,0,224,0,224,0,224,16,5,6,6,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-135">  32,64,128,136,248,8,5,6,6,6,0,0,8,8,80,32,</front>
<front id="dogm_font_data_HD44780_JH-136">  80,128,5,6,6,6,0,0,248,64,248,64,64,56,5,7,</front>
<front id="dogm_font_data_HD44780_JH-137">  7,6,0,0,64,64,248,72,80,64,64,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-138">  0,112,16,16,16,16,16,248,5,6,6,6,0,0,248,8,</front>
<front id="dogm_font_data_HD44780_JH-139">  248,8,8,248,5,7,7,6,0,0,112,0,248,8,8,16,</front>
<front id="dogm_font_data_HD44780_JH-140">  32,4,7,7,6,0,0,144,144,144,144,16,32,64,5,6,</front>
<front id="dogm_font_data_HD44780_JH-141">  6,6,0,0,32,160,160,168,168,176,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-142">  128,128,128,136,144,160,192,5,6,6,6,0,0,248,136,136,</front>
<front id="dogm_font_data_HD44780_JH-143">  136,136,248,5,6,6,6,0,0,248,136,136,8,16,32,5,</front>
<front id="dogm_font_data_HD44780_JH-144">  6,6,6,0,0,192,0,8,8,16,224,4,3,3,6,0,</front>
<front id="dogm_font_data_HD44780_JH-145">  4,32,144,64,3,3,3,6,0,4,224,160,224,5,5,5,</front>
<front id="dogm_font_data_HD44780_JH-146">  6,0,1,72,168,144,144,104,5,7,7,6,0,0,80,0,</front>
<front id="dogm_font_data_HD44780_JH-147">  112,8,120,136,120,4,8,8,6,1,255,96,144,144,224,144,</front>
<front id="dogm_font_data_HD44780_JH-148">  144,224,128,5,5,5,6,0,0,112,128,96,136,112,5,6,</front>
<front id="dogm_font_data_HD44780_JH-149">  6,6,0,255,136,136,152,232,136,128,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_JH-150">  120,160,144,136,112,5,7,7,6,0,254,48,72,136,136,240,</front>
<front id="dogm_font_data_HD44780_JH-151">  128,128,5,8,8,6,0,254,120,136,136,136,120,8,8,112,</front>
<front id="dogm_font_data_HD44780_JH-152">  5,5,5,6,0,1,56,32,32,160,64,4,3,3,6,0,</front>
<front id="dogm_font_data_HD44780_JH-153">  3,16,208,16,4,8,8,6,0,255,16,0,48,16,16,16,</front>
<front id="dogm_font_data_HD44780_JH-154">  144,96,3,3,3,6,0,4,160,64,160,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-155">  0,32,112,160,160,168,112,32,5,7,7,6,0,0,64,64,</front>
<front id="dogm_font_data_HD44780_JH-156">  224,64,224,64,120,5,7,7,6,0,0,112,0,176,200,136,</front>
<front id="dogm_font_data_HD44780_JH-157">  136,136,5,7,7,6,0,0,80,0,112,136,136,136,112,5,</front>
<front id="dogm_font_data_HD44780_JH-158">  7,7,6,0,255,176,200,136,136,240,128,128,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_JH-159">  0,255,104,152,136,136,120,8,8,5,6,6,6,0,0,112,</front>
<front id="dogm_font_data_HD44780_JH-160">  136,248,136,136,112,5,3,3,6,0,2,88,168,208,5,5,</front>
<front id="dogm_font_data_HD44780_JH-161">  5,6,0,0,112,136,136,80,216,5,7,7,6,0,0,80,</front>
<front id="dogm_font_data_HD44780_JH-162">  0,136,136,136,152,104,5,7,7,6,0,0,248,128,64,32,</front>
<front id="dogm_font_data_HD44780_JH-163">  64,128,248,5,5,5,6,0,0,248,80,80,80,152,5,7,</front>
<front id="dogm_font_data_HD44780_JH-164">  7,6,0,0,248,0,136,80,32,80,136,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_JH-165">  255,136,136,136,136,120,8,112,5,6,6,6,0,1,8,240,</front>
<front id="dogm_font_data_HD44780_JH-166">  32,248,32,32,5,5,5,6,0,0,248,64,120,72,136,5,</front>
<front id="dogm_font_data_HD44780_JH-167">  5,5,6,0,0,248,168,248,136,136,5,5,5,6,0,1,</front>
<front id="dogm_font_data_HD44780_JH-168">  32,0,248,0,32,0,0,0,6,0,8,6,10,10,6,0,</front>
<front id="dogm_font_data_HD44780_JH-169">  254,252,252,252,252,252,252,252,252,252,252};</front>
 </pre>
<h1 id="dogm_font_data_HD44780_WHtitle" >dogm_font_data_HD44780_W.h</h1>
<pre id="dogm_font_data_HD44780_WH"  class="prettyprint linenums"><front id="dogm_font_data_HD44780_WH-1">/*</front>
<front id="dogm_font_data_HD44780_WH-2">  Fontname: HD44780_W</front>
<front id="dogm_font_data_HD44780_WH-3">  Copyright: A.Hardtung, public domain</front>
<front id="dogm_font_data_HD44780_WH-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_HD44780_WH-5">  Calculated Max Values w= 5 h= 9 x= 2 y= 5 dx= 6 dy= 0 ascent= 8 len= 9</front>
<front id="dogm_font_data_HD44780_WH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_HD44780_WH-7">  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0</front>
<front id="dogm_font_data_HD44780_WH-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_HD44780_WH-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_HD44780_WH-10">  Max Font    ascent = 8 descent=-1</front>
<front id="dogm_font_data_HD44780_WH-11">*/</front>
<front id="dogm_font_data_HD44780_WH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_HD44780_WH-13">const u8g_fntpgm_uint8_t HD44780_W_5x7[3034] U8G_SECTION(".progmem.HD44780_W_5x7") = {</front>
<front id="dogm_font_data_HD44780_WH-14">  0,6,9,0,254,7,2,79,3,222,16,255,255,8,255,7,</front>
<front id="dogm_font_data_HD44780_WH-15">  255,4,7,7,6,0,0,16,48,112,240,112,48,16,4,7,</front>
<front id="dogm_font_data_HD44780_WH-16">  7,6,1,0,128,192,224,240,224,192,128,5,3,3,6,0,</front>
<front id="dogm_font_data_HD44780_WH-17">  4,216,72,144,5,3,3,6,0,4,216,144,72,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-18">  6,0,0,32,112,248,0,32,112,248,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-19">  248,112,32,0,248,112,32,5,5,5,6,0,1,112,248,248,</front>
<front id="dogm_font_data_HD44780_WH-20">  248,112,5,7,7,6,0,0,8,8,40,72,248,64,32,5,</front>
<front id="dogm_font_data_HD44780_WH-21">  7,7,6,0,0,32,112,168,32,32,32,32,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-22">  0,0,32,32,32,32,168,112,32,5,5,5,6,0,1,32,</front>
<front id="dogm_font_data_HD44780_WH-23">  64,248,64,32,5,5,5,6,0,1,32,16,248,16,32,5,</front>
<front id="dogm_font_data_HD44780_WH-24">  7,7,6,0,0,16,32,64,32,16,0,248,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-25">  0,0,64,32,16,32,64,0,248,5,5,5,6,0,1,32,</front>
<front id="dogm_font_data_HD44780_WH-26">  32,112,112,248,5,5,5,6,0,0,248,112,112,32,32,0,</front>
<front id="dogm_font_data_HD44780_WH-27">  0,0,6,0,0,1,7,7,6,2,0,128,128,128,128,128,</front>
<front id="dogm_font_data_HD44780_WH-28">  0,128,3,2,2,6,1,5,160,160,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-29">  80,80,248,80,248,80,80,5,7,7,6,0,0,32,120,160,</front>
<front id="dogm_font_data_HD44780_WH-30">  112,40,240,32,5,7,7,6,0,0,192,200,16,32,64,152,</front>
<front id="dogm_font_data_HD44780_WH-31">  24,5,7,7,6,0,0,96,144,160,64,168,144,104,2,3,</front>
<front id="dogm_font_data_HD44780_WH-32">  3,6,1,4,192,64,128,3,7,7,6,1,0,32,64,128,</front>
<front id="dogm_font_data_HD44780_WH-33">  128,128,64,32,3,7,7,6,1,0,128,64,32,32,32,64,</front>
<front id="dogm_font_data_HD44780_WH-34">  128,5,5,5,6,0,1,32,168,112,168,32,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_WH-35">  0,1,32,32,248,32,32,2,3,3,6,2,255,192,64,128,</front>
<front id="dogm_font_data_HD44780_WH-36">  5,1,1,6,0,3,248,2,2,2,6,2,0,192,192,5,</front>
<front id="dogm_font_data_HD44780_WH-37">  5,5,6,0,1,8,16,32,64,128,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-38">  112,136,152,168,200,136,112,3,7,7,6,1,0,64,192,64,</front>
<front id="dogm_font_data_HD44780_WH-39">  64,64,64,224,5,7,7,6,0,0,112,136,8,112,128,128,</front>
<front id="dogm_font_data_HD44780_WH-40">  248,5,7,7,6,0,0,248,16,32,16,8,8,240,5,7,</front>
<front id="dogm_font_data_HD44780_WH-41">  7,6,0,0,16,48,80,144,248,16,16,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_WH-42">  0,248,128,240,8,8,136,112,5,7,7,6,0,0,48,64,</front>
<front id="dogm_font_data_HD44780_WH-43">  128,240,136,136,112,5,7,7,6,0,0,248,8,16,32,32,</front>
<front id="dogm_font_data_HD44780_WH-44">  32,32,5,7,7,6,0,0,112,136,136,112,136,136,112,5,</front>
<front id="dogm_font_data_HD44780_WH-45">  7,7,6,0,0,112,136,136,120,8,16,96,2,5,5,6,</front>
<front id="dogm_font_data_HD44780_WH-46">  2,0,192,192,0,192,192,2,6,6,6,2,255,192,192,0,</front>
<front id="dogm_font_data_HD44780_WH-47">  192,64,128,4,7,7,6,0,0,16,32,64,128,64,32,16,</front>
<front id="dogm_font_data_HD44780_WH-48">  5,3,3,6,0,2,248,0,248,4,7,7,6,1,0,128,</front>
<front id="dogm_font_data_HD44780_WH-49">  64,32,16,32,64,128,5,7,7,6,0,0,112,136,8,16,</front>
<front id="dogm_font_data_HD44780_WH-50">  32,0,32,5,6,6,6,0,0,112,136,8,104,168,112,5,</front>
<front id="dogm_font_data_HD44780_WH-51">  7,7,6,0,0,112,136,136,248,136,136,136,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-52">  0,0,240,136,136,240,136,136,240,5,7,7,6,0,0,112,</front>
<front id="dogm_font_data_HD44780_WH-53">  136,128,128,128,136,112,5,7,7,6,0,0,224,144,136,136,</front>
<front id="dogm_font_data_HD44780_WH-54">  136,144,224,5,7,7,6,0,0,248,128,128,240,128,128,248,</front>
<front id="dogm_font_data_HD44780_WH-55">  5,7,7,6,0,0,248,128,128,240,128,128,128,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-56">  6,0,0,112,136,128,184,136,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-57">  136,136,136,248,136,136,136,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_HD44780_WH-58">  128,128,128,128,5,7,7,6,0,0,56,16,16,16,16,144,</front>
<front id="dogm_font_data_HD44780_WH-59">  96,5,7,7,6,0,0,136,144,160,192,160,144,136,5,7,</front>
<front id="dogm_font_data_HD44780_WH-60">  7,6,0,0,128,128,128,128,128,128,248,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_WH-61">  0,136,216,168,136,136,136,136,5,7,7,6,0,0,136,136,</front>
<front id="dogm_font_data_HD44780_WH-62">  200,168,152,136,136,5,7,7,6,0,0,112,136,136,136,136,</front>
<front id="dogm_font_data_HD44780_WH-63">  136,112,5,7,7,6,0,0,240,136,136,240,128,128,128,5,</front>
<front id="dogm_font_data_HD44780_WH-64">  7,7,6,0,0,112,136,136,136,168,144,104,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-65">  0,0,240,136,136,240,160,144,136,5,7,7,6,0,0,120,</front>
<front id="dogm_font_data_HD44780_WH-66">  128,128,112,8,8,240,5,7,7,6,0,0,248,32,32,32,</front>
<front id="dogm_font_data_HD44780_WH-67">  32,32,32,5,7,7,6,0,0,136,136,136,136,136,136,112,</front>
<front id="dogm_font_data_HD44780_WH-68">  5,7,7,6,0,0,136,136,136,136,136,80,32,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-69">  6,0,0,136,136,136,136,136,168,80,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-70">  136,136,80,32,80,136,136,5,7,7,6,0,0,136,136,136,</front>
<front id="dogm_font_data_HD44780_WH-71">  80,32,32,32,5,7,7,6,0,0,248,8,16,32,64,128,</front>
<front id="dogm_font_data_HD44780_WH-72">  248,3,7,7,6,1,0,224,128,128,128,128,128,224,5,5,</front>
<front id="dogm_font_data_HD44780_WH-73">  5,6,0,1,128,64,32,16,8,3,7,7,6,1,0,224,</front>
<front id="dogm_font_data_HD44780_WH-74">  32,32,32,32,32,224,5,3,3,6,0,4,32,80,136,5,</front>
<front id="dogm_font_data_HD44780_WH-75">  1,1,6,0,0,248,2,2,2,6,2,5,128,64,5,5,</front>
<front id="dogm_font_data_HD44780_WH-76">  5,6,0,0,112,8,120,136,120,5,7,7,6,0,0,128,</front>
<front id="dogm_font_data_HD44780_WH-77">  128,176,200,136,136,240,5,5,5,6,0,0,112,128,128,136,</front>
<front id="dogm_font_data_HD44780_WH-78">  112,5,7,7,6,0,0,8,8,104,152,136,136,120,5,5,</front>
<front id="dogm_font_data_HD44780_WH-79">  5,6,0,0,112,136,248,128,112,5,7,7,6,0,0,48,</front>
<front id="dogm_font_data_HD44780_WH-80">  72,224,64,64,64,64,5,6,6,6,0,255,112,136,136,120,</front>
<front id="dogm_font_data_HD44780_WH-81">  8,112,5,7,7,6,0,0,128,128,176,200,136,136,136,1,</front>
<front id="dogm_font_data_HD44780_WH-82">  7,7,6,2,0,128,0,128,128,128,128,128,3,8,8,6,</front>
<front id="dogm_font_data_HD44780_WH-83">  1,255,32,0,32,32,32,32,160,64,4,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-84">  128,128,144,160,192,160,144,3,7,7,6,1,0,192,64,64,</front>
<front id="dogm_font_data_HD44780_WH-85">  64,64,64,224,5,5,5,6,0,0,208,168,168,168,168,5,</front>
<front id="dogm_font_data_HD44780_WH-86">  5,5,6,0,0,176,200,136,136,136,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-87">  112,136,136,136,112,5,6,6,6,0,255,240,136,136,240,128,</front>
<front id="dogm_font_data_HD44780_WH-88">  128,5,6,6,6,0,255,120,136,136,120,8,8,5,5,5,</front>
<front id="dogm_font_data_HD44780_WH-89">  6,0,0,176,200,128,128,128,5,5,5,6,0,0,112,128,</front>
<front id="dogm_font_data_HD44780_WH-90">  112,8,240,5,7,7,6,0,0,64,64,224,64,64,72,48,</front>
<front id="dogm_font_data_HD44780_WH-91">  5,5,5,6,0,0,136,136,136,152,104,5,5,5,6,0,</front>
<front id="dogm_font_data_HD44780_WH-92">  0,136,136,136,80,32,5,5,5,6,0,0,136,136,168,168,</front>
<front id="dogm_font_data_HD44780_WH-93">  80,5,5,5,6,0,0,136,80,32,80,136,5,6,6,6,</front>
<front id="dogm_font_data_HD44780_WH-94">  0,255,136,136,136,120,8,112,5,5,5,6,0,0,248,16,</front>
<front id="dogm_font_data_HD44780_WH-95">  32,64,248,3,7,7,6,1,0,32,64,64,128,64,64,32,</front>
<front id="dogm_font_data_HD44780_WH-96">  1,7,7,6,2,0,128,128,128,128,128,128,128,3,7,7,</front>
<front id="dogm_font_data_HD44780_WH-97">  6,1,0,128,64,64,32,64,64,128,5,6,6,6,0,1,</front>
<front id="dogm_font_data_HD44780_WH-98">  8,40,72,248,64,32,5,7,7,6,0,0,32,80,136,136,</front>
<front id="dogm_font_data_HD44780_WH-99">  136,136,248,5,7,7,6,0,0,248,136,128,240,136,136,240,</front>
<front id="dogm_font_data_HD44780_WH-100">  5,8,8,6,0,255,120,40,40,40,72,136,248,136,5,7,</front>
<front id="dogm_font_data_HD44780_WH-101">  7,6,0,0,168,168,168,112,168,168,168,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_WH-102">  0,240,8,8,112,8,8,240,5,7,7,6,0,0,136,136,</front>
<front id="dogm_font_data_HD44780_WH-103">  152,168,200,136,136,5,8,8,6,0,0,80,32,136,152,168,</front>
<front id="dogm_font_data_HD44780_WH-104">  168,200,136,5,7,7,6,0,0,120,40,40,40,40,168,72,</front>
<front id="dogm_font_data_HD44780_WH-105">  5,7,7,6,0,0,248,136,136,136,136,136,136,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-106">  6,0,0,136,136,136,80,32,64,128,5,8,8,6,0,255,</front>
<front id="dogm_font_data_HD44780_WH-107">  136,136,136,136,136,136,248,8,5,7,7,6,0,0,136,136,</front>
<front id="dogm_font_data_HD44780_WH-108">  136,120,8,8,8,5,7,7,6,0,0,168,168,168,168,168,</front>
<front id="dogm_font_data_HD44780_WH-109">  168,248,5,8,8,6,0,255,168,168,168,168,168,168,248,8,</front>
<front id="dogm_font_data_HD44780_WH-110">  5,7,7,6,0,0,192,64,64,112,72,72,112,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-111">  6,0,0,136,136,136,200,168,168,200,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-112">  112,136,40,80,8,136,112,5,5,5,6,0,0,64,160,144,</front>
<front id="dogm_font_data_HD44780_WH-113">  144,104,5,7,7,6,0,0,32,48,40,40,32,224,224,5,</front>
<front id="dogm_font_data_HD44780_WH-114">  7,7,6,0,0,248,136,128,128,128,128,128,5,5,5,6,</front>
<front id="dogm_font_data_HD44780_WH-115">  0,0,248,80,80,80,152,5,7,7,6,0,0,248,128,64,</front>
<front id="dogm_font_data_HD44780_WH-116">  32,64,128,248,5,5,5,6,0,0,120,144,144,144,96,5,</front>
<front id="dogm_font_data_HD44780_WH-117">  7,7,6,0,0,48,40,56,40,200,216,24,5,6,6,6,</front>
<front id="dogm_font_data_HD44780_WH-118">  0,0,8,112,160,32,32,16,5,6,6,6,0,1,32,112,</front>
<front id="dogm_font_data_HD44780_WH-119">  112,112,248,32,5,7,7,6,0,0,112,136,136,248,136,136,</front>
<front id="dogm_font_data_HD44780_WH-120">  112,5,5,5,6,0,0,112,136,136,80,216,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-121">  0,0,48,72,32,80,136,136,112,5,3,3,6,0,2,88,</front>
<front id="dogm_font_data_HD44780_WH-122">  168,208,5,6,6,6,0,0,80,248,248,248,112,32,5,5,</front>
<front id="dogm_font_data_HD44780_WH-123">  5,6,0,0,112,128,96,136,112,5,7,7,6,0,0,112,</front>
<front id="dogm_font_data_HD44780_WH-124">  136,136,136,136,136,136,5,7,7,6,0,0,216,216,216,216,</front>
<front id="dogm_font_data_HD44780_WH-125">  216,216,216,1,7,7,6,2,0,128,0,128,128,128,128,128,</front>
<front id="dogm_font_data_HD44780_WH-126">  5,7,7,6,0,0,32,112,160,160,168,112,32,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-127">  6,0,0,48,64,64,224,64,80,168,5,5,5,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-128">  136,112,80,112,136,5,7,7,6,0,0,136,80,248,32,248,</front>
<front id="dogm_font_data_HD44780_WH-129">  32,32,1,7,7,6,2,0,128,128,128,0,128,128,128,5,</front>
<front id="dogm_font_data_HD44780_WH-130">  8,8,6,0,0,48,72,32,80,80,32,144,96,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-131">  6,0,0,24,32,32,112,32,32,192,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-132">  248,136,184,184,184,136,248,5,7,7,6,0,0,112,8,120,</front>
<front id="dogm_font_data_HD44780_WH-133">  136,120,0,248,5,5,5,6,0,1,40,80,160,80,40,5,</front>
<front id="dogm_font_data_HD44780_WH-134">  7,7,6,0,0,144,168,168,232,168,168,144,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-135">  0,0,120,136,136,120,40,72,136,5,7,7,6,0,0,248,</front>
<front id="dogm_font_data_HD44780_WH-136">  136,168,136,152,168,248,2,3,3,6,2,4,64,128,192,4,</front>
<front id="dogm_font_data_HD44780_WH-137">  5,5,6,0,3,96,144,144,144,96,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-138">  32,32,248,32,32,0,248,4,5,5,6,0,3,96,144,32,</front>
<front id="dogm_font_data_HD44780_WH-139">  64,240,3,5,5,6,0,3,224,32,224,32,224,5,8,8,</front>
<front id="dogm_font_data_HD44780_WH-140">  6,0,0,224,144,224,128,144,184,144,24,5,8,8,6,0,</front>
<front id="dogm_font_data_HD44780_WH-141">  255,136,136,136,136,152,232,128,128,5,7,7,6,0,0,120,</front>
<front id="dogm_font_data_HD44780_WH-142">  152,152,120,24,24,24,2,2,2,6,2,2,192,192,5,5,</front>
<front id="dogm_font_data_HD44780_WH-143">  5,6,0,0,80,136,168,168,80,3,5,5,6,0,3,64,</front>
<front id="dogm_font_data_HD44780_WH-144">  192,64,64,224,5,7,7,6,0,0,112,136,136,136,112,0,</front>
<front id="dogm_font_data_HD44780_WH-145">  248,5,5,5,6,0,1,160,80,40,80,160,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-146">  0,0,136,144,168,88,184,8,8,5,7,7,6,0,0,136,</front>
<front id="dogm_font_data_HD44780_WH-147">  144,184,72,152,32,56,5,8,8,6,0,0,192,64,192,72,</front>
<front id="dogm_font_data_HD44780_WH-148">  216,56,8,8,5,7,7,6,0,0,32,0,32,64,128,136,</front>
<front id="dogm_font_data_HD44780_WH-149">  112,5,8,8,6,0,0,64,32,32,80,136,248,136,136,5,</front>
<front id="dogm_font_data_HD44780_WH-150">  8,8,6,0,0,16,32,32,80,136,248,136,136,5,8,8,</front>
<front id="dogm_font_data_HD44780_WH-151">  6,0,0,32,80,0,112,136,248,136,136,5,8,8,6,0,</front>
<front id="dogm_font_data_HD44780_WH-152">  0,104,144,0,112,136,248,136,136,5,8,8,6,0,0,80,</front>
<front id="dogm_font_data_HD44780_WH-153">  0,32,80,136,248,136,136,5,8,8,6,0,0,32,80,32,</front>
<front id="dogm_font_data_HD44780_WH-154">  112,136,248,136,136,5,7,7,6,0,0,56,96,160,184,224,</front>
<front id="dogm_font_data_HD44780_WH-155">  160,184,5,8,8,6,0,255,112,136,128,128,136,112,32,96,</front>
<front id="dogm_font_data_HD44780_WH-156">  5,8,8,6,0,0,64,32,0,248,128,240,128,248,5,8,</front>
<front id="dogm_font_data_HD44780_WH-157">  8,6,0,0,8,16,0,248,128,240,128,248,5,8,8,6,</front>
<front id="dogm_font_data_HD44780_WH-158">  0,0,32,80,0,248,128,240,128,248,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-159">  80,0,248,128,240,128,248,3,8,8,6,1,0,128,64,0,</front>
<front id="dogm_font_data_HD44780_WH-160">  224,64,64,64,224,3,8,8,6,1,0,32,64,0,224,64,</front>
<front id="dogm_font_data_HD44780_WH-161">  64,64,224,3,8,8,6,1,0,64,160,0,224,64,64,64,</front>
<front id="dogm_font_data_HD44780_WH-162">  224,3,7,7,6,1,0,160,0,224,64,64,64,224,5,7,</front>
<front id="dogm_font_data_HD44780_WH-163">  7,6,0,0,112,72,72,232,72,72,112,5,8,8,6,0,</front>
<front id="dogm_font_data_HD44780_WH-164">  0,104,144,0,136,200,168,152,136,5,8,8,6,0,0,64,</front>
<front id="dogm_font_data_HD44780_WH-165">  32,112,136,136,136,136,112,5,8,8,6,0,0,16,32,112,</front>
<front id="dogm_font_data_HD44780_WH-166">  136,136,136,136,112,5,8,8,6,0,0,32,80,0,112,136,</front>
<front id="dogm_font_data_HD44780_WH-167">  136,136,112,5,8,8,6,0,0,104,144,0,112,136,136,136,</front>
<front id="dogm_font_data_HD44780_WH-168">  112,5,8,8,6,0,0,80,0,112,136,136,136,136,112,5,</front>
<front id="dogm_font_data_HD44780_WH-169">  5,5,6,0,1,136,80,32,80,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-170">  112,32,112,168,112,32,112,5,8,8,6,0,0,64,32,136,</front>
<front id="dogm_font_data_HD44780_WH-171">  136,136,136,136,112,5,8,8,6,0,0,16,32,136,136,136,</front>
<front id="dogm_font_data_HD44780_WH-172">  136,136,112,5,8,8,6,0,0,32,80,0,136,136,136,136,</front>
<front id="dogm_font_data_HD44780_WH-173">  112,5,8,8,6,0,0,80,0,136,136,136,136,136,112,5,</front>
<front id="dogm_font_data_HD44780_WH-174">  8,8,6,0,0,16,32,136,80,32,32,32,32,5,8,8,</front>
<front id="dogm_font_data_HD44780_WH-175">  6,0,0,192,64,112,72,72,112,64,224,5,7,7,6,0,</front>
<front id="dogm_font_data_HD44780_WH-176">  0,48,72,72,112,72,72,176,5,8,8,6,0,0,64,32,</front>
<front id="dogm_font_data_HD44780_WH-177">  0,112,8,120,136,120,5,8,8,6,0,0,16,32,0,112,</front>
<front id="dogm_font_data_HD44780_WH-178">  8,120,136,120,5,8,8,6,0,0,32,80,0,112,8,120,</front>
<front id="dogm_font_data_HD44780_WH-179">  136,120,5,8,8,6,0,0,104,144,0,112,8,120,136,120,</front>
<front id="dogm_font_data_HD44780_WH-180">  5,7,7,6,0,0,80,0,112,8,120,136,120,5,8,8,</front>
<front id="dogm_font_data_HD44780_WH-181">  6,0,0,32,80,32,112,8,120,136,120,5,6,6,6,0,</front>
<front id="dogm_font_data_HD44780_WH-182">  0,208,40,120,160,168,80,5,6,6,6,0,255,112,128,136,</front>
<front id="dogm_font_data_HD44780_WH-183">  112,32,96,5,8,8,6,0,0,64,32,0,112,136,248,128,</front>
<front id="dogm_font_data_HD44780_WH-184">  112,5,8,8,6,0,0,16,32,0,112,136,248,128,112,5,</front>
<front id="dogm_font_data_HD44780_WH-185">  8,8,6,0,0,32,80,0,112,136,248,128,112,5,7,7,</front>
<front id="dogm_font_data_HD44780_WH-186">  6,0,0,80,0,112,136,248,128,112,3,8,8,6,1,0,</front>
<front id="dogm_font_data_HD44780_WH-187">  128,64,0,64,192,64,64,224,3,8,8,6,1,0,32,64,</front>
<front id="dogm_font_data_HD44780_WH-188">  0,64,192,64,64,224,3,8,8,6,1,0,64,160,0,64,</front>
<front id="dogm_font_data_HD44780_WH-189">  192,64,64,224,3,7,7,6,1,0,160,0,64,192,64,64,</front>
<front id="dogm_font_data_HD44780_WH-190">  224,5,7,7,6,0,0,160,64,160,16,120,136,112,5,8,</front>
<front id="dogm_font_data_HD44780_WH-191">  8,6,0,0,104,144,0,176,200,136,136,136,5,8,8,6,</front>
<front id="dogm_font_data_HD44780_WH-192">  0,0,64,32,0,112,136,136,136,112,5,8,8,6,0,0,</front>
<front id="dogm_font_data_HD44780_WH-193">  16,32,0,112,136,136,136,112,5,8,8,6,0,0,32,80,</front>
<front id="dogm_font_data_HD44780_WH-194">  0,112,136,136,136,112,5,8,8,6,0,0,104,144,0,112,</front>
<front id="dogm_font_data_HD44780_WH-195">  136,136,136,112,5,7,7,6,0,0,80,0,112,136,136,136,</front>
<front id="dogm_font_data_HD44780_WH-196">  112,5,5,5,6,0,1,32,0,248,0,32,5,7,7,6,</front>
<front id="dogm_font_data_HD44780_WH-197">  0,0,16,32,112,168,112,32,64,5,8,8,6,0,0,64,</front>
<front id="dogm_font_data_HD44780_WH-198">  32,0,136,136,136,152,104,5,8,8,6,0,0,16,32,0,</front>
<front id="dogm_font_data_HD44780_WH-199">  136,136,136,152,104,5,8,8,6,0,0,32,80,0,136,136,</front>
<front id="dogm_font_data_HD44780_WH-200">  136,152,104,5,7,7,6,0,0,80,0,136,136,136,152,104,</front>
<front id="dogm_font_data_HD44780_WH-201">  5,9,9,6,0,255,16,32,0,136,136,136,248,8,112,4,</front>
<front id="dogm_font_data_HD44780_WH-202">  7,7,6,1,0,192,64,96,80,96,64,224,5,8,8,6,</front>
<front id="dogm_font_data_HD44780_WH-203">  0,255,80,0,136,136,136,248,8,112};</front>
 </pre>
<h1 id="dogm_font_data_ISO10646_1Htitle" >dogm_font_data_ISO10646_1.h</h1>
<pre id="dogm_font_data_ISO10646_1H"  class="prettyprint linenums"><front id="dogm_font_data_ISO10646_1H-1">/*</front>
<front id="dogm_font_data_ISO10646_1H-2">  Fontname: ISO10646-1</front>
<front id="dogm_font_data_ISO10646_1H-3">  Copyright: A.Hardtung, public domain</front>
<front id="dogm_font_data_ISO10646_1H-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_ISO10646_1H-5">  Calculated Max Values w= 5 h= 9 x= 2 y= 7 dx= 6 dy= 0 ascent= 8 len= 9</front>
<front id="dogm_font_data_ISO10646_1H-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_ISO10646_1H-7">  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0</front>
<front id="dogm_font_data_ISO10646_1H-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_1H-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_1H-10">  Max Font    ascent = 8 descent=-1</front>
<front id="dogm_font_data_ISO10646_1H-11">*/</front>
<front id="dogm_font_data_ISO10646_1H-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_ISO10646_1H-13">const u8g_fntpgm_uint8_t ISO10646_1_5x7[2592] U8G_SECTION(".progmem.ISO10646_1_5x7") = {</front>
<front id="dogm_font_data_ISO10646_1H-14">  0,6,9,0,254,7,1,146,3,33,32,255,255,8,255,7,</front>
<front id="dogm_font_data_ISO10646_1H-15">  255,0,0,0,6,0,0,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_ISO10646_1H-16">  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-17">  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_ISO10646_1H-18">  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,</front>
<front id="dogm_font_data_ISO10646_1H-19">  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,</front>
<front id="dogm_font_data_ISO10646_1H-20">  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_ISO10646_1H-21">  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,</front>
<front id="dogm_font_data_ISO10646_1H-22">  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,</front>
<front id="dogm_font_data_ISO10646_1H-23">  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_1H-24">  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,</front>
<front id="dogm_font_data_ISO10646_1H-25">  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-26">  0,0,112,136,136,136,136,136,112,3,7,7,6,1,0,64,</front>
<front id="dogm_font_data_ISO10646_1H-27">  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,</front>
<front id="dogm_font_data_ISO10646_1H-28">  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,</front>
<front id="dogm_font_data_ISO10646_1H-29">  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,</front>
<front id="dogm_font_data_ISO10646_1H-30">  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-31">  112,128,128,240,136,136,112,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_ISO10646_1H-32">  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-33">  112,5,7,7,6,0,0,112,136,136,120,8,8,112,2,5,</front>
<front id="dogm_font_data_ISO10646_1H-34">  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_1H-35">  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,</front>
<front id="dogm_font_data_ISO10646_1H-36">  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,1,</front>
<front id="dogm_font_data_ISO10646_1H-37">  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_ISO10646_1H-38">  8,16,32,0,32,5,7,7,6,0,0,112,136,8,104,168,</front>
<front id="dogm_font_data_ISO10646_1H-39">  168,112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,</front>
<front id="dogm_font_data_ISO10646_1H-40">  7,7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-41">  0,0,112,136,128,128,128,136,112,5,7,7,6,0,0,240,</front>
<front id="dogm_font_data_ISO10646_1H-42">  136,136,136,136,136,240,5,7,7,6,0,0,248,128,128,240,</front>
<front id="dogm_font_data_ISO10646_1H-43">  128,128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,</front>
<front id="dogm_font_data_ISO10646_1H-44">  5,7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,</front>
<front id="dogm_font_data_ISO10646_1H-45">  6,0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,</front>
<front id="dogm_font_data_ISO10646_1H-46">  128,128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,</front>
<front id="dogm_font_data_ISO10646_1H-47">  16,16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,</front>
<front id="dogm_font_data_ISO10646_1H-48">  136,5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,</front>
<front id="dogm_font_data_ISO10646_1H-49">  7,6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-50">  0,136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_ISO10646_1H-51">  136,136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,</front>
<front id="dogm_font_data_ISO10646_1H-52">  128,128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,</front>
<front id="dogm_font_data_ISO10646_1H-53">  7,7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-54">  0,0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,</front>
<front id="dogm_font_data_ISO10646_1H-55">  32,32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-56">  136,136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,</front>
<front id="dogm_font_data_ISO10646_1H-57">  5,7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,</front>
<front id="dogm_font_data_ISO10646_1H-58">  6,0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-59">  136,136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_ISO10646_1H-60">  32,64,128,248,3,7,7,6,1,0,224,128,128,128,128,128,</front>
<front id="dogm_font_data_ISO10646_1H-61">  224,5,5,5,6,0,1,128,64,32,16,8,3,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-62">  1,0,224,32,32,32,32,32,224,5,3,3,6,0,4,32,</front>
<front id="dogm_font_data_ISO10646_1H-63">  80,136,5,1,1,6,0,0,248,2,2,2,6,2,5,128,</front>
<front id="dogm_font_data_ISO10646_1H-64">  64,5,5,5,6,0,0,112,8,120,136,120,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-65">  0,0,128,128,176,200,136,136,240,5,5,5,6,0,0,112,</front>
<front id="dogm_font_data_ISO10646_1H-66">  128,128,136,112,5,7,7,6,0,0,8,8,104,152,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-67">  120,5,5,5,6,0,0,112,136,248,128,112,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-68">  0,0,48,72,224,64,64,64,64,5,6,6,6,0,255,112,</front>
<front id="dogm_font_data_ISO10646_1H-69">  136,136,120,8,112,5,7,7,6,0,0,128,128,176,200,136,</front>
<front id="dogm_font_data_ISO10646_1H-70">  136,136,1,7,7,6,2,0,128,0,128,128,128,128,128,3,</front>
<front id="dogm_font_data_ISO10646_1H-71">  8,8,6,1,255,32,0,32,32,32,32,160,64,4,7,7,</front>
<front id="dogm_font_data_ISO10646_1H-72">  6,0,0,128,128,144,160,192,160,144,3,7,7,6,1,0,</front>
<front id="dogm_font_data_ISO10646_1H-73">  192,64,64,64,64,64,224,5,5,5,6,0,0,208,168,168,</front>
<front id="dogm_font_data_ISO10646_1H-74">  168,168,5,5,5,6,0,0,176,200,136,136,136,5,5,5,</front>
<front id="dogm_font_data_ISO10646_1H-75">  6,0,0,112,136,136,136,112,5,6,6,6,0,255,240,136,</front>
<front id="dogm_font_data_ISO10646_1H-76">  136,240,128,128,5,6,6,6,0,255,120,136,136,120,8,8,</front>
<front id="dogm_font_data_ISO10646_1H-77">  5,5,5,6,0,0,176,200,128,128,128,5,5,5,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-78">  0,112,128,112,8,240,4,7,7,6,0,0,64,64,224,64,</front>
<front id="dogm_font_data_ISO10646_1H-79">  64,64,48,5,5,5,6,0,0,136,136,136,152,104,5,5,</front>
<front id="dogm_font_data_ISO10646_1H-80">  5,6,0,0,136,136,136,80,32,5,5,5,6,0,0,136,</front>
<front id="dogm_font_data_ISO10646_1H-81">  136,168,168,80,5,5,5,6,0,0,136,80,32,80,136,5,</front>
<front id="dogm_font_data_ISO10646_1H-82">  6,6,6,0,255,136,136,136,120,8,112,5,5,5,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-83">  0,248,16,32,64,248,3,7,7,6,1,0,32,64,64,128,</front>
<front id="dogm_font_data_ISO10646_1H-84">  64,64,32,1,7,7,6,2,0,128,128,128,128,128,128,128,</front>
<front id="dogm_font_data_ISO10646_1H-85">  3,7,7,6,1,0,128,64,64,32,64,64,128,5,2,2,</front>
<front id="dogm_font_data_ISO10646_1H-86">  6,0,2,104,144,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-87">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-88">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-89">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-90">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-91">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-92">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-93">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-94">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-95">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-96">  0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-97">  6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-98">  0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-99">  0,1,7,7,6,2,0,128,0,128,128,128,128,128,5,7,</front>
<front id="dogm_font_data_ISO10646_1H-100">  7,6,0,0,32,112,168,160,168,112,32,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-101">  0,48,64,64,224,64,80,168,5,5,5,6,0,0,136,112,</front>
<front id="dogm_font_data_ISO10646_1H-102">  80,112,136,5,7,7,6,0,0,136,80,32,248,32,248,32,</front>
<front id="dogm_font_data_ISO10646_1H-103">  1,7,7,6,2,0,128,128,128,0,128,128,128,5,8,8,</front>
<front id="dogm_font_data_ISO10646_1H-104">  6,0,0,48,72,32,80,80,32,144,96,3,1,1,6,1,</front>
<front id="dogm_font_data_ISO10646_1H-105">  7,160,5,7,7,6,0,0,248,136,184,184,184,136,248,5,</front>
<front id="dogm_font_data_ISO10646_1H-106">  7,7,6,0,1,112,8,120,136,120,0,248,5,5,5,6,</front>
<front id="dogm_font_data_ISO10646_1H-107">  0,1,40,80,160,80,40,5,3,3,6,0,1,248,8,8,</front>
<front id="dogm_font_data_ISO10646_1H-108">  2,2,2,6,2,6,64,128,5,7,7,6,0,0,248,136,</front>
<front id="dogm_font_data_ISO10646_1H-109">  168,136,152,168,248,5,1,1,6,0,6,248,4,4,4,6,</front>
<front id="dogm_font_data_ISO10646_1H-110">  0,3,96,144,144,96,5,7,7,6,0,0,32,32,248,32,</front>
<front id="dogm_font_data_ISO10646_1H-111">  32,0,248,4,5,5,6,0,3,96,144,32,64,240,3,5,</front>
<front id="dogm_font_data_ISO10646_1H-112">  5,6,0,3,224,32,224,32,224,2,2,2,6,2,6,64,</front>
<front id="dogm_font_data_ISO10646_1H-113">  128,5,8,8,6,0,255,136,136,136,136,152,232,128,128,5,</front>
<front id="dogm_font_data_ISO10646_1H-114">  7,7,6,0,0,120,152,152,120,24,24,24,2,2,2,6,</front>
<front id="dogm_font_data_ISO10646_1H-115">  2,2,192,192,2,2,2,6,2,255,64,128,3,5,5,6,</front>
<front id="dogm_font_data_ISO10646_1H-116">  0,3,64,192,64,64,224,5,7,7,6,0,1,112,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-117">  136,112,0,248,5,5,5,6,0,1,160,80,40,80,160,5,</front>
<front id="dogm_font_data_ISO10646_1H-118">  7,7,6,0,0,136,144,168,88,184,8,8,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_1H-119">  0,0,136,144,184,72,152,32,56,5,8,8,6,0,0,192,</front>
<front id="dogm_font_data_ISO10646_1H-120">  64,192,72,216,56,8,8,5,7,7,6,0,0,32,0,32,</front>
<front id="dogm_font_data_ISO10646_1H-121">  64,128,136,112,5,8,8,6,0,0,64,32,0,112,136,248,</front>
<front id="dogm_font_data_ISO10646_1H-122">  136,136,5,8,8,6,0,0,16,32,0,112,136,248,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-123">  5,8,8,6,0,0,32,80,0,112,136,248,136,136,5,8,</front>
<front id="dogm_font_data_ISO10646_1H-124">  8,6,0,0,104,144,0,112,136,248,136,136,5,8,8,6,</front>
<front id="dogm_font_data_ISO10646_1H-125">  0,0,80,0,112,136,136,248,136,136,5,8,8,6,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-126">  32,80,32,112,136,248,136,136,5,7,7,6,0,0,56,96,</front>
<front id="dogm_font_data_ISO10646_1H-127">  160,184,224,160,184,5,8,8,6,0,255,112,136,128,128,136,</front>
<front id="dogm_font_data_ISO10646_1H-128">  112,32,96,5,8,8,6,0,0,64,32,0,248,128,240,128,</front>
<front id="dogm_font_data_ISO10646_1H-129">  248,5,8,8,6,0,0,8,16,0,248,128,240,128,248,5,</front>
<front id="dogm_font_data_ISO10646_1H-130">  8,8,6,0,0,32,80,0,248,128,240,128,248,5,7,7,</front>
<front id="dogm_font_data_ISO10646_1H-131">  6,0,0,80,0,248,128,240,128,248,3,8,8,6,1,0,</front>
<front id="dogm_font_data_ISO10646_1H-132">  128,64,0,224,64,64,64,224,3,8,8,6,1,0,32,64,</front>
<front id="dogm_font_data_ISO10646_1H-133">  0,224,64,64,64,224,3,8,8,6,1,0,64,160,0,224,</front>
<front id="dogm_font_data_ISO10646_1H-134">  64,64,64,224,3,7,7,6,1,0,160,0,224,64,64,64,</front>
<front id="dogm_font_data_ISO10646_1H-135">  224,5,7,7,6,0,0,112,72,72,232,72,72,112,5,8,</front>
<front id="dogm_font_data_ISO10646_1H-136">  8,6,0,0,104,144,0,136,200,168,152,136,5,8,8,6,</front>
<front id="dogm_font_data_ISO10646_1H-137">  0,0,64,32,112,136,136,136,136,112,5,8,8,6,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-138">  16,32,112,136,136,136,136,112,5,8,8,6,0,0,32,80,</front>
<front id="dogm_font_data_ISO10646_1H-139">  0,112,136,136,136,112,5,8,8,6,0,0,104,144,0,112,</front>
<front id="dogm_font_data_ISO10646_1H-140">  136,136,136,112,5,8,8,6,0,0,80,0,112,136,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-141">  136,112,5,5,5,6,0,1,136,80,32,80,136,5,8,8,</front>
<front id="dogm_font_data_ISO10646_1H-142">  6,0,255,16,112,168,168,168,168,112,64,5,8,8,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-143">  0,64,32,136,136,136,136,136,112,5,8,8,6,0,0,16,</front>
<front id="dogm_font_data_ISO10646_1H-144">  32,136,136,136,136,136,112,5,8,8,6,0,0,32,80,0,</front>
<front id="dogm_font_data_ISO10646_1H-145">  136,136,136,136,112,5,8,8,6,0,0,80,0,136,136,136,</front>
<front id="dogm_font_data_ISO10646_1H-146">  136,136,112,5,8,8,6,0,0,16,32,136,80,32,32,32,</front>
<front id="dogm_font_data_ISO10646_1H-147">  32,5,9,9,6,0,255,192,64,112,72,72,112,64,64,224,</front>
<front id="dogm_font_data_ISO10646_1H-148">  4,8,8,6,1,255,96,144,144,160,144,144,224,128,5,8,</front>
<front id="dogm_font_data_ISO10646_1H-149">  8,6,0,0,64,32,0,112,8,120,136,120,5,8,8,6,</front>
<front id="dogm_font_data_ISO10646_1H-150">  0,0,16,32,0,112,8,120,136,120,5,8,8,6,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-151">  32,80,0,112,8,120,136,120,5,8,8,6,0,0,104,144,</front>
<front id="dogm_font_data_ISO10646_1H-152">  0,112,8,120,136,120,5,7,7,6,0,0,80,0,112,8,</front>
<front id="dogm_font_data_ISO10646_1H-153">  120,136,120,5,8,8,6,0,0,32,80,32,112,8,120,136,</front>
<front id="dogm_font_data_ISO10646_1H-154">  120,5,6,6,6,0,0,208,40,120,160,168,80,5,6,6,</front>
<front id="dogm_font_data_ISO10646_1H-155">  6,0,255,112,128,136,112,32,96,5,8,8,6,0,0,64,</front>
<front id="dogm_font_data_ISO10646_1H-156">  32,0,112,136,248,128,112,5,8,8,6,0,0,16,32,0,</front>
<front id="dogm_font_data_ISO10646_1H-157">  112,136,248,128,112,5,8,8,6,0,0,32,80,0,112,136,</front>
<front id="dogm_font_data_ISO10646_1H-158">  248,128,112,5,7,7,6,0,0,80,0,112,136,248,128,112,</front>
<front id="dogm_font_data_ISO10646_1H-159">  3,8,8,6,1,0,128,64,0,64,192,64,64,224,3,8,</front>
<front id="dogm_font_data_ISO10646_1H-160">  8,6,1,0,32,64,0,64,192,64,64,224,3,8,8,6,</front>
<front id="dogm_font_data_ISO10646_1H-161">  1,0,64,160,0,64,192,64,64,224,3,7,7,6,1,0,</front>
<front id="dogm_font_data_ISO10646_1H-162">  160,0,64,192,64,64,224,5,7,7,6,0,0,160,64,160,</front>
<front id="dogm_font_data_ISO10646_1H-163">  16,120,136,112,5,8,8,6,0,0,104,144,0,176,200,136,</front>
<front id="dogm_font_data_ISO10646_1H-164">  136,136,5,8,8,6,0,0,64,32,0,112,136,136,136,112,</front>
<front id="dogm_font_data_ISO10646_1H-165">  5,8,8,6,0,0,16,32,0,112,136,136,136,112,5,8,</front>
<front id="dogm_font_data_ISO10646_1H-166">  8,6,0,0,32,80,0,112,136,136,136,112,5,8,8,6,</front>
<front id="dogm_font_data_ISO10646_1H-167">  0,0,104,144,0,112,136,136,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_1H-168">  80,0,112,136,136,136,112,5,5,5,6,0,1,32,0,248,</front>
<front id="dogm_font_data_ISO10646_1H-169">  0,32,5,7,7,6,0,255,16,112,168,168,168,112,64,5,</front>
<front id="dogm_font_data_ISO10646_1H-170">  8,8,6,0,0,64,32,0,136,136,136,152,104,5,8,8,</front>
<front id="dogm_font_data_ISO10646_1H-171">  6,0,0,16,32,0,136,136,136,152,104,5,8,8,6,0,</front>
<front id="dogm_font_data_ISO10646_1H-172">  0,32,80,0,136,136,136,152,104,5,7,7,6,0,0,80,</front>
<front id="dogm_font_data_ISO10646_1H-173">  0,136,136,136,152,104,5,9,9,6,0,255,16,32,0,136,</front>
<front id="dogm_font_data_ISO10646_1H-174">  136,136,248,8,112,4,7,7,6,1,255,192,64,96,80,96,</front>
<front id="dogm_font_data_ISO10646_1H-175">  64,224,5,8,8,6,0,255,80,0,136,136,136,120,8,112</front>
<front id="dogm_font_data_ISO10646_1H-176">  };</front>
 </pre>
<h1 id="dogm_font_data_ISO10646_5_CyrillicHtitle" >dogm_font_data_ISO10646_5_Cyrillic.h</h1>
<pre id="dogm_font_data_ISO10646_5_CyrillicH"  class="prettyprint linenums"><front id="dogm_font_data_ISO10646_5_CyrillicH-1">/*</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-2">  Fontname: ISO10646_5_Cyrillic</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-3">  Copyright: A. Hardtung, public domain</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-5">  Calculated Max Values w= 5 h= 9 x= 2 y= 5 dx= 6 dy= 0 ascent= 8 len= 9</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-7">  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-10">  Max Font    ascent = 8 descent=-1</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-11">*/</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-13">const u8g_fntpgm_uint8_t ISO10646_5_Cyrillic_5x7[2560] U8G_SECTION(".progmem.ISO10646_5_Cyrillic_5x7") = {</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-14">  0,6,9,0,254,7,1,145,3,32,32,255,255,8,255,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-15">  255,0,0,0,6,0,0,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-16">  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-17">  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-18">  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-19">  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-20">  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-21">  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-22">  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-23">  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-24">  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-25">  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-26">  0,0,112,136,152,168,200,136,112,3,7,7,6,1,0,64,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-27">  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-28">  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-29">  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-30">  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-31">  48,64,128,240,136,136,112,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-32">  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-33">  112,5,7,7,6,0,0,112,136,136,120,8,16,96,2,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-34">  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-35">  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-36">  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,1,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-37">  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-38">  8,16,32,0,32,5,6,6,6,0,0,112,136,8,104,168,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-39">  112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-40">  7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-41">  0,112,136,128,128,128,136,112,5,7,7,6,0,0,224,144,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-42">  136,136,136,144,224,5,7,7,6,0,0,248,128,128,240,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-43">  128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-44">  7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-45">  0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-46">  128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,16,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-47">  16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-48">  5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-49">  6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-50">  136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-51">  136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-52">  128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-53">  7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-54">  0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-55">  32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-56">  136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-57">  7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-58">  0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-59">  136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-60">  64,128,248,3,7,7,6,1,0,224,128,128,128,128,128,224,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-61">  5,5,5,6,0,1,128,64,32,16,8,3,7,7,6,1,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-62">  0,224,32,32,32,32,32,224,5,3,3,6,0,4,32,80,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-63">  136,5,1,1,6,0,0,248,2,2,2,6,2,5,128,64,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-64">  5,5,5,6,0,0,112,8,120,136,120,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-65">  0,128,128,176,200,136,136,240,5,5,5,6,0,0,112,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-66">  128,136,112,5,7,7,6,0,0,8,8,104,152,136,136,120,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-67">  5,5,5,6,0,0,112,136,248,128,112,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-68">  0,48,72,224,64,64,64,64,5,6,6,6,0,255,112,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-69">  136,120,8,112,5,7,7,6,0,0,128,128,176,200,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-70">  136,1,7,7,6,2,0,128,0,128,128,128,128,128,3,8,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-71">  8,6,1,255,32,0,32,32,32,32,160,64,4,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-72">  0,0,128,128,144,160,192,160,144,3,7,7,6,1,0,192,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-73">  64,64,64,64,64,224,5,5,5,6,0,0,208,168,168,168,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-74">  168,5,5,5,6,0,0,176,200,136,136,136,5,5,5,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-75">  0,0,112,136,136,136,112,5,6,6,6,0,255,240,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-76">  240,128,128,5,6,6,6,0,255,120,136,136,120,8,8,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-77">  5,5,6,0,0,176,200,128,128,128,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-78">  112,128,112,8,240,5,7,7,6,0,0,64,64,224,64,64,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-79">  72,48,5,5,5,6,0,0,136,136,136,152,104,5,5,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-80">  6,0,0,136,136,136,80,32,5,5,5,6,0,0,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-81">  168,168,80,5,5,5,6,0,0,136,80,32,80,136,5,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-82">  6,6,0,255,136,136,136,120,8,112,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-83">  248,16,32,64,248,3,7,7,6,1,0,32,64,64,128,64,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-84">  64,32,1,7,7,6,2,0,128,128,128,128,128,128,128,3,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-85">  7,7,6,1,0,128,64,64,32,64,64,128,5,2,2,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-86">  0,3,104,144,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-87">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-88">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-89">  0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-90">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-91">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-92">  0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-93">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-94">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-95">  0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-96">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-97">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-98">  0,6,0,0,0,0,0,6,0,0,5,8,8,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-99">  64,248,128,128,240,128,128,248,5,8,8,6,0,0,80,248,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-100">  128,128,240,128,128,248,5,7,7,6,0,0,224,64,64,112,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-101">  72,72,112,5,8,8,6,0,0,16,32,248,136,128,128,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-102">  128,5,7,7,6,0,0,48,72,128,224,128,72,48,5,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-103">  7,6,0,0,112,136,128,112,8,136,112,3,7,7,6,1,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-104">  0,224,64,64,64,64,64,224,3,8,8,6,1,0,160,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-105">  224,64,64,64,64,224,5,7,7,6,0,0,56,16,16,16,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-106">  16,144,96,5,7,7,6,0,0,160,160,160,184,168,168,184,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-107">  5,7,7,6,0,0,160,160,160,248,168,168,184,4,7,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-108">  6,0,0,224,64,112,80,80,80,80,5,8,8,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-109">  16,32,136,144,160,224,144,136,5,8,8,6,0,0,64,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-110">  136,152,168,200,136,136,5,9,9,6,0,255,80,32,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-111">  136,80,32,32,32,5,8,8,6,0,255,136,136,136,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-112">  136,248,32,5,7,7,6,0,0,112,136,136,248,136,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-113">  5,7,7,6,0,0,248,128,128,240,136,136,240,5,7,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-114">  6,0,0,240,136,136,240,136,136,240,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-115">  248,136,128,128,128,128,128,5,8,8,6,0,255,120,40,40,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-116">  40,72,136,248,136,5,7,7,6,0,0,248,128,128,240,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-117">  128,248,5,7,7,6,0,0,168,168,168,112,168,168,168,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-118">  7,7,6,0,0,240,8,8,112,8,8,240,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-119">  0,0,136,136,152,168,200,136,136,5,8,8,6,0,0,80,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-120">  32,136,152,168,168,200,136,5,7,7,6,0,0,136,144,160,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-121">  192,160,144,136,5,7,7,6,0,0,120,40,40,40,40,168,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-122">  72,5,7,7,6,0,0,136,216,168,136,136,136,136,5,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-123">  7,6,0,0,136,136,136,248,136,136,136,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-124">  0,112,136,136,136,136,136,112,5,7,7,6,0,0,248,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-125">  136,136,136,136,136,5,7,7,6,0,0,240,136,136,240,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-126">  128,128,5,7,7,6,0,0,112,136,128,128,128,136,112,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-127">  7,7,6,0,0,248,32,32,32,32,32,32,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-128">  0,0,136,136,136,80,32,64,128,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-129">  112,168,168,168,112,32,5,7,7,6,0,0,136,136,80,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-130">  80,136,136,5,8,8,6,0,255,136,136,136,136,136,136,248,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-131">  8,5,7,7,6,0,0,136,136,136,152,104,8,8,5,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-132">  7,6,0,0,168,168,168,168,168,168,248,5,8,8,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-133">  255,168,168,168,168,168,168,248,8,5,7,7,6,0,0,192,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-134">  64,64,112,72,72,112,5,7,7,6,0,0,136,136,136,200,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-135">  168,168,200,5,7,7,6,0,0,128,128,128,240,136,136,240,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-136">  5,7,7,6,0,0,112,136,8,56,8,136,112,5,7,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-137">  6,0,0,144,168,168,232,168,168,144,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-138">  120,136,136,120,40,72,136,5,5,5,6,0,0,112,8,120,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-139">  136,120,5,7,7,6,0,0,24,96,128,240,136,136,112,4,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-140">  5,5,6,0,0,224,144,224,144,224,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-141">  248,136,128,128,128,5,6,6,6,0,255,120,40,72,136,248,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-142">  136,5,5,5,6,0,0,112,136,248,128,112,5,5,5,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-143">  0,0,168,168,112,168,168,5,5,5,6,0,0,240,8,48,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-144">  8,240,5,5,5,6,0,0,136,152,168,200,136,5,7,7,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-145">  6,0,0,80,32,136,152,168,200,136,4,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-146">  144,160,192,160,144,5,5,5,6,0,0,248,40,40,168,72,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-147">  5,5,5,6,0,0,136,216,168,136,136,5,5,5,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-148">  0,136,136,248,136,136,5,5,5,6,0,0,112,136,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-149">  112,5,5,5,6,0,0,248,136,136,136,136,5,6,6,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-150">  0,255,240,136,136,240,128,128,5,5,5,6,0,0,112,128,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-151">  128,136,112,5,5,5,6,0,0,248,32,32,32,32,5,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-152">  6,6,0,255,136,136,136,120,8,112,5,6,6,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-153">  32,112,168,168,112,32,5,5,5,6,0,0,136,80,32,80,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-154">  136,5,6,6,6,0,255,136,136,136,136,248,8,5,5,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-155">  6,0,0,136,136,248,8,8,5,5,5,6,0,0,168,168,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-156">  168,168,248,5,6,6,6,0,255,168,168,168,168,248,8,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-157">  5,5,6,0,0,192,64,112,72,112,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-158">  136,136,200,168,200,3,5,5,6,1,0,128,128,192,160,192,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-159">  5,5,5,6,0,0,112,136,56,136,112,5,5,5,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-160">  0,144,168,232,168,144,5,5,5,6,0,0,120,136,120,40,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-161">  72,5,8,8,6,0,0,64,32,0,112,136,248,128,112,5,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-162">  7,7,6,0,0,80,0,112,136,248,128,112,5,9,9,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-163">  0,255,64,224,64,64,120,72,72,72,16,5,8,8,6,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-164">  0,16,32,0,248,136,128,128,128,5,5,5,6,0,0,112,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-165">  136,96,136,112,5,5,5,6,0,0,112,128,112,8,240,1,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-166">  7,7,6,2,0,128,0,128,128,128,128,128,3,7,7,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-167">  1,0,160,0,64,64,64,64,64,3,8,8,6,1,255,32,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-168">  0,32,32,32,32,160,64,5,5,5,6,0,0,160,160,184,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-169">  168,184,5,5,5,6,0,0,160,160,248,168,184,5,6,6,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-170">  6,0,0,64,224,64,120,72,72,4,8,8,6,0,0,16,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-171">  32,0,144,160,192,160,144,5,8,8,6,0,0,64,32,0,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-172">  136,152,168,200,136,5,9,9,6,0,255,80,32,0,136,136,</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-173">  136,120,8,112,5,6,6,6,0,255,136,136,136,136,248,32</front>
<front id="dogm_font_data_ISO10646_5_CyrillicH-174">  };</front>
 </pre>
<h1 id="dogm_font_data_ISO10646_CNHtitle" >dogm_font_data_ISO10646_CN.h</h1>
<pre id="dogm_font_data_ISO10646_CNH"  class="prettyprint linenums"><front id="dogm_font_data_ISO10646_CNH-1">/*</front>
<front id="dogm_font_data_ISO10646_CNH-2">  Fontname: ISO10646_CN</front>
<front id="dogm_font_data_ISO10646_CNH-3">  Copyright: A. Hardtung, public domain</front>
<front id="dogm_font_data_ISO10646_CNH-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_ISO10646_CNH-5">  Calculated Max Values w=11 h=11 x= 2 y=10 dx=12 dy= 0 ascent=10 len=22</front>
<front id="dogm_font_data_ISO10646_CNH-6">  Font Bounding box     w=12 h=11 x= 0 y=-2</front>
<front id="dogm_font_data_ISO10646_CNH-7">  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0</front>
<front id="dogm_font_data_ISO10646_CNH-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_CNH-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_CNH-10">  Max Font    ascent =10 descent=-1</front>
<front id="dogm_font_data_ISO10646_CNH-11">*/</front>
<front id="dogm_font_data_ISO10646_CNH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_ISO10646_CNH-13">const u8g_fntpgm_uint8_t ISO10646_CN[4105] U8G_SECTION(".progmem.ISO10646_CN") = {</front>
<front id="dogm_font_data_ISO10646_CNH-14">  0,12,11,0,254,7,1,146,3,33,32,255,255,10,255,7,</front>
<front id="dogm_font_data_ISO10646_CNH-15">  255,0,0,0,6,0,10,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_ISO10646_CNH-16">  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-17">  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_ISO10646_CNH-18">  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,</front>
<front id="dogm_font_data_ISO10646_CNH-19">  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,</front>
<front id="dogm_font_data_ISO10646_CNH-20">  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_ISO10646_CNH-21">  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,</front>
<front id="dogm_font_data_ISO10646_CNH-22">  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,</front>
<front id="dogm_font_data_ISO10646_CNH-23">  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_CNH-24">  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,</front>
<front id="dogm_font_data_ISO10646_CNH-25">  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-26">  0,0,112,136,152,168,200,136,112,3,7,7,6,1,0,64,</front>
<front id="dogm_font_data_ISO10646_CNH-27">  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,</front>
<front id="dogm_font_data_ISO10646_CNH-28">  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,</front>
<front id="dogm_font_data_ISO10646_CNH-29">  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,</front>
<front id="dogm_font_data_ISO10646_CNH-30">  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_CNH-31">  112,128,128,240,136,136,112,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_ISO10646_CNH-32">  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,</front>
<front id="dogm_font_data_ISO10646_CNH-33">  112,5,7,7,6,0,0,112,136,136,120,8,8,112,2,5,</front>
<front id="dogm_font_data_ISO10646_CNH-34">  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_CNH-35">  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,</front>
<front id="dogm_font_data_ISO10646_CNH-36">  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_CNH-37">  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_ISO10646_CNH-38">  8,16,32,0,32,5,7,7,6,0,0,112,136,8,104,168,</front>
<front id="dogm_font_data_ISO10646_CNH-39">  168,112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,</front>
<front id="dogm_font_data_ISO10646_CNH-40">  7,7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-41">  0,0,112,136,128,128,128,136,112,5,7,7,6,0,0,240,</front>
<front id="dogm_font_data_ISO10646_CNH-42">  136,136,136,136,136,240,5,7,7,6,0,0,248,128,128,240,</front>
<front id="dogm_font_data_ISO10646_CNH-43">  128,128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,</front>
<front id="dogm_font_data_ISO10646_CNH-44">  5,7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,</front>
<front id="dogm_font_data_ISO10646_CNH-45">  6,0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,</front>
<front id="dogm_font_data_ISO10646_CNH-46">  128,128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,</front>
<front id="dogm_font_data_ISO10646_CNH-47">  16,16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,</front>
<front id="dogm_font_data_ISO10646_CNH-48">  136,5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,</front>
<front id="dogm_font_data_ISO10646_CNH-49">  7,6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_CNH-50">  0,136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_ISO10646_CNH-51">  136,136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,</front>
<front id="dogm_font_data_ISO10646_CNH-52">  128,128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,</front>
<front id="dogm_font_data_ISO10646_CNH-53">  7,7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-54">  0,0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,</front>
<front id="dogm_font_data_ISO10646_CNH-55">  32,32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,</front>
<front id="dogm_font_data_ISO10646_CNH-56">  136,136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,</front>
<front id="dogm_font_data_ISO10646_CNH-57">  5,7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,</front>
<front id="dogm_font_data_ISO10646_CNH-58">  6,0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_CNH-59">  136,136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_ISO10646_CNH-60">  32,64,128,248,3,7,7,6,0,0,224,128,128,128,128,128,</front>
<front id="dogm_font_data_ISO10646_CNH-61">  224,5,5,5,6,0,1,128,64,32,16,8,3,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-62">  0,0,224,32,32,32,32,32,224,5,3,3,6,0,4,32,</front>
<front id="dogm_font_data_ISO10646_CNH-63">  80,136,5,1,1,6,0,0,248,2,2,2,6,2,5,128,</front>
<front id="dogm_font_data_ISO10646_CNH-64">  64,5,5,5,6,0,0,112,8,120,136,120,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-65">  0,0,128,128,176,200,136,136,240,5,5,5,6,0,0,112,</front>
<front id="dogm_font_data_ISO10646_CNH-66">  128,128,136,112,5,7,7,6,0,0,8,8,104,152,136,136,</front>
<front id="dogm_font_data_ISO10646_CNH-67">  120,5,5,5,6,0,0,112,136,248,128,112,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_CNH-68">  0,0,48,72,224,64,64,64,64,5,6,6,6,0,255,112,</front>
<front id="dogm_font_data_ISO10646_CNH-69">  136,136,120,8,112,5,7,7,6,0,0,128,128,176,200,136,</front>
<front id="dogm_font_data_ISO10646_CNH-70">  136,136,1,7,7,6,2,0,128,0,128,128,128,128,128,3,</front>
<front id="dogm_font_data_ISO10646_CNH-71">  8,8,6,1,255,32,0,32,32,32,32,160,64,4,7,7,</front>
<front id="dogm_font_data_ISO10646_CNH-72">  6,1,0,128,128,144,160,192,160,144,3,7,7,6,1,0,</front>
<front id="dogm_font_data_ISO10646_CNH-73">  192,64,64,64,64,64,224,5,5,5,6,0,0,208,168,168,</front>
<front id="dogm_font_data_ISO10646_CNH-74">  168,168,5,5,5,6,0,0,176,200,136,136,136,5,5,5,</front>
<front id="dogm_font_data_ISO10646_CNH-75">  6,0,0,112,136,136,136,112,5,6,6,6,0,255,240,136,</front>
<front id="dogm_font_data_ISO10646_CNH-76">  136,240,128,128,5,6,6,6,0,255,120,136,136,120,8,8,</front>
<front id="dogm_font_data_ISO10646_CNH-77">  5,5,5,6,0,0,176,200,128,128,128,5,5,5,6,0,</front>
<front id="dogm_font_data_ISO10646_CNH-78">  0,112,128,112,8,240,4,7,7,6,0,0,64,64,224,64,</front>
<front id="dogm_font_data_ISO10646_CNH-79">  64,64,48,5,5,5,6,0,0,136,136,136,152,104,5,5,</front>
<front id="dogm_font_data_ISO10646_CNH-80">  5,6,0,0,136,136,136,80,32,5,5,5,6,0,0,136,</front>
<front id="dogm_font_data_ISO10646_CNH-81">  136,168,168,80,5,5,5,6,0,0,136,80,32,80,136,5,</front>
<front id="dogm_font_data_ISO10646_CNH-82">  6,6,6,0,255,136,136,136,120,8,112,5,5,5,6,0,</front>
<front id="dogm_font_data_ISO10646_CNH-83">  0,248,16,32,64,248,3,7,7,6,1,0,32,64,64,128,</front>
<front id="dogm_font_data_ISO10646_CNH-84">  64,64,32,1,7,7,6,2,0,128,128,128,128,128,128,128,</front>
<front id="dogm_font_data_ISO10646_CNH-85">  3,7,7,6,1,0,128,64,64,32,64,64,128,5,2,2,</front>
<front id="dogm_font_data_ISO10646_CNH-86">  6,0,3,104,144,0,0,0,6,0,10,0,0,0,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-87">  10,0,0,0,12,0,10,0,0,0,12,0,10,0,0,0,</front>
<front id="dogm_font_data_ISO10646_CNH-88">  12,0,10,0,0,0,12,0,10,0,0,0,12,0,10,0,</front>
<front id="dogm_font_data_ISO10646_CNH-89">  0,0,12,0,10,0,0,0,12,0,10,0,0,0,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-90">  10,0,0,0,12,0,10,0,0,0,12,0,10,0,0,0,</front>
<front id="dogm_font_data_ISO10646_CNH-91">  12,0,10,0,0,0,12,0,10,0,0,0,12,0,10,0,</front>
<front id="dogm_font_data_ISO10646_CNH-92">  0,0,12,0,10,0,0,0,12,0,10,0,0,0,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-93">  10,0,0,0,12,0,10,0,0,0,12,0,10,0,0,0,</front>
<front id="dogm_font_data_ISO10646_CNH-94">  12,0,10,0,0,0,12,0,10,0,0,0,12,0,10,0,</front>
<front id="dogm_font_data_ISO10646_CNH-95">  0,0,12,0,10,0,0,0,12,0,10,0,0,0,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-96">  10,0,0,0,12,0,10,0,0,0,12,0,10,0,0,0,</front>
<front id="dogm_font_data_ISO10646_CNH-97">  12,0,10,0,0,0,12,0,10,11,11,22,12,0,255,255,</front>
<front id="dogm_font_data_ISO10646_CNH-98">  224,2,0,2,0,4,0,13,0,20,128,36,64,196,32,4,</front>
<front id="dogm_font_data_ISO10646_CNH-99">  0,4,0,4,0,11,11,22,12,0,255,249,0,138,0,171,</front>
<front id="dogm_font_data_ISO10646_CNH-100">  224,172,64,170,64,170,64,170,64,170,128,33,0,82,128,140,</front>
<front id="dogm_font_data_ISO10646_CNH-101">  96,11,11,22,12,0,255,36,0,36,0,63,128,68,0,132,</front>
<front id="dogm_font_data_ISO10646_CNH-102">  0,4,0,255,224,10,0,17,0,32,128,192,96,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-103">  12,0,255,36,0,36,0,63,192,68,0,4,0,255,224,9,</front>
<front id="dogm_font_data_ISO10646_CNH-104">  0,9,0,17,32,33,32,64,224,11,11,22,12,0,255,32,</front>
<front id="dogm_font_data_ISO10646_CNH-105">  0,61,224,81,32,145,32,17,32,255,32,17,32,41,32,37,</front>
<front id="dogm_font_data_ISO10646_CNH-106">  224,69,32,128,0,11,11,22,12,0,255,32,128,127,192,8,</front>
<front id="dogm_font_data_ISO10646_CNH-107">  64,255,224,17,0,32,128,95,64,128,32,63,128,0,0,127,</front>
<front id="dogm_font_data_ISO10646_CNH-108">  192,11,11,22,12,0,255,34,64,71,224,148,128,228,128,47,</front>
<front id="dogm_font_data_ISO10646_CNH-109">  224,68,128,244,128,7,224,52,128,196,128,7,224,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-110">  12,0,255,4,128,143,224,73,0,25,0,47,192,9,0,9,</front>
<front id="dogm_font_data_ISO10646_CNH-111">  0,47,192,73,0,137,0,15,224,11,11,22,12,0,255,16,</front>
<front id="dogm_font_data_ISO10646_CNH-112">  0,63,128,81,0,14,0,49,128,192,96,63,128,36,128,63,</front>
<front id="dogm_font_data_ISO10646_CNH-113">  128,36,128,63,128,11,11,22,12,0,255,34,128,250,64,7,</front>
<front id="dogm_font_data_ISO10646_CNH-114">  224,250,128,138,128,138,128,250,128,34,128,178,128,170,160,100,</front>
<front id="dogm_font_data_ISO10646_CNH-115">  224,11,11,22,12,0,255,34,32,71,64,146,128,239,224,34,</front>
<front id="dogm_font_data_ISO10646_CNH-116">  0,71,192,236,64,7,192,52,64,199,192,4,64,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-117">  12,0,255,8,0,15,192,8,0,8,0,255,224,8,0,14,</front>
<front id="dogm_font_data_ISO10646_CNH-118">  0,9,128,8,64,8,0,8,0,10,11,22,12,0,255,255,</front>
<front id="dogm_font_data_ISO10646_CNH-119">  128,0,128,0,128,128,128,128,128,255,128,128,0,128,0,128,</front>
<front id="dogm_font_data_ISO10646_CNH-120">  64,128,64,127,192,11,11,22,12,0,255,71,192,65,0,239,</front>
<front id="dogm_font_data_ISO10646_CNH-121">  224,65,0,69,0,105,96,201,32,77,96,73,32,79,224,200,</front>
<front id="dogm_font_data_ISO10646_CNH-122">  32,11,11,22,12,0,255,8,0,4,0,4,0,10,0,10,</front>
<front id="dogm_font_data_ISO10646_CNH-123">  0,10,0,17,0,17,0,32,128,64,64,128,32,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-124">  12,0,255,34,64,34,0,247,224,34,0,35,224,53,32,229,</front>
<front id="dogm_font_data_ISO10646_CNH-125">  32,37,64,40,128,41,64,114,32,11,10,20,12,0,0,68,</front>
<front id="dogm_font_data_ISO10646_CNH-126">  64,68,64,68,64,127,192,4,0,4,0,132,32,132,32,132,</front>
<front id="dogm_font_data_ISO10646_CNH-127">  32,255,224,11,11,22,12,0,255,4,0,0,0,127,192,4,</front>
<front id="dogm_font_data_ISO10646_CNH-128">  0,4,0,4,0,127,192,4,0,4,0,4,0,255,224,11,</front>
<front id="dogm_font_data_ISO10646_CNH-129">  11,22,12,0,255,255,224,17,0,1,192,254,0,72,128,37,</front>
<front id="dogm_font_data_ISO10646_CNH-130">  0,4,0,255,224,21,0,36,128,196,96,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-131">  255,17,0,127,192,68,64,127,192,68,64,127,192,4,0,255,</front>
<front id="dogm_font_data_ISO10646_CNH-132">  224,4,0,4,0,4,0,9,11,22,12,0,255,16,0,255,</front>
<front id="dogm_font_data_ISO10646_CNH-133">  128,128,128,128,128,255,128,128,128,128,128,255,128,128,128,128,</front>
<front id="dogm_font_data_ISO10646_CNH-134">  128,255,128,11,11,22,12,0,255,113,0,1,0,3,224,249,</front>
<front id="dogm_font_data_ISO10646_CNH-135">  32,33,32,65,32,81,32,137,32,250,32,2,32,4,192,11,</front>
<front id="dogm_font_data_ISO10646_CNH-136">  11,22,12,0,255,127,192,17,0,17,0,17,0,17,0,255,</front>
<front id="dogm_font_data_ISO10646_CNH-137">  224,17,0,17,0,33,0,33,0,65,0,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-138">  255,33,0,34,0,244,64,87,224,80,32,87,192,148,64,84,</front>
<front id="dogm_font_data_ISO10646_CNH-139">  64,36,64,87,192,148,64,11,11,22,12,0,255,17,0,10,</front>
<front id="dogm_font_data_ISO10646_CNH-140">  0,127,192,4,0,4,0,255,224,4,0,10,0,17,0,32,</front>
<front id="dogm_font_data_ISO10646_CNH-141">  128,192,96,10,11,22,12,0,255,95,192,0,64,132,64,132,</front>
<front id="dogm_font_data_ISO10646_CNH-142">  64,191,64,132,64,140,64,148,64,164,64,140,64,129,192,11,</front>
<front id="dogm_font_data_ISO10646_CNH-143">  11,22,12,0,255,36,0,39,192,36,0,36,0,255,224,0,</front>
<front id="dogm_font_data_ISO10646_CNH-144">  0,20,64,36,128,71,0,12,0,112,0,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-145">  255,36,128,4,128,15,192,228,128,36,128,63,224,36,128,36,</front>
<front id="dogm_font_data_ISO10646_CNH-146">  128,40,128,80,0,143,224,11,11,22,12,0,255,8,0,8,</front>
<front id="dogm_font_data_ISO10646_CNH-147">  0,255,128,136,128,136,128,255,128,136,128,136,128,255,160,136,</front>
<front id="dogm_font_data_ISO10646_CNH-148">  32,7,224,11,11,22,12,0,255,39,128,36,128,244,128,36,</front>
<front id="dogm_font_data_ISO10646_CNH-149">  128,116,128,108,128,164,128,36,128,36,160,40,160,48,96,10,</front>
<front id="dogm_font_data_ISO10646_CNH-150">  11,22,12,0,255,255,192,128,64,128,64,158,64,146,64,146,</front>
<front id="dogm_font_data_ISO10646_CNH-151">  64,158,64,128,64,128,64,255,192,128,64,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-152">  255,127,192,68,0,95,192,80,64,95,192,80,64,95,192,66,</front>
<front id="dogm_font_data_ISO10646_CNH-153">  0,74,128,82,64,166,32,11,11,22,12,0,255,4,0,7,</front>
<front id="dogm_font_data_ISO10646_CNH-154">  224,4,0,127,192,64,64,64,64,64,64,127,192,0,0,82,</front>
<front id="dogm_font_data_ISO10646_CNH-155">  64,137,32,11,11,22,12,0,255,71,128,36,128,4,128,4,</front>
<front id="dogm_font_data_ISO10646_CNH-156">  128,232,96,32,0,47,192,36,64,34,128,49,0,38,192,11,</front>
<front id="dogm_font_data_ISO10646_CNH-157">  11,22,12,0,255,127,192,74,64,127,192,4,0,255,224,4,</front>
<front id="dogm_font_data_ISO10646_CNH-158">  0,63,128,32,128,36,128,36,128,255,224,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-159">  255,34,0,79,224,72,32,79,224,200,0,79,224,74,160,90,</front>
<front id="dogm_font_data_ISO10646_CNH-160">  160,111,224,74,160,72,96,11,11,22,12,0,255,243,192,36,</front>
<front id="dogm_font_data_ISO10646_CNH-161">  64,42,128,241,0,34,128,101,224,114,32,165,64,32,128,35,</front>
<front id="dogm_font_data_ISO10646_CNH-162">  0,44,0,11,11,22,12,0,255,4,0,255,224,128,32,0,</front>
<front id="dogm_font_data_ISO10646_CNH-163">  0,255,224,4,0,36,0,39,192,36,0,84,0,143,224,11,</front>
<front id="dogm_font_data_ISO10646_CNH-164">  11,22,12,0,255,115,224,16,128,81,0,35,224,250,32,42,</front>
<front id="dogm_font_data_ISO10646_CNH-165">  160,34,160,34,160,32,128,33,64,98,32,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-166">  255,34,0,247,128,34,128,54,128,226,160,37,160,36,96,104,</front>
<front id="dogm_font_data_ISO10646_CNH-167">  32,0,0,82,64,137,32,11,11,22,12,0,255,115,192,66,</front>
<front id="dogm_font_data_ISO10646_CNH-168">  0,66,0,123,224,74,64,74,64,122,64,74,64,66,64,68,</front>
<front id="dogm_font_data_ISO10646_CNH-169">  64,136,64,11,11,22,12,0,255,8,0,255,224,8,0,31,</front>
<front id="dogm_font_data_ISO10646_CNH-170">  192,48,64,95,192,144,64,31,192,16,64,16,64,16,192,11,</front>
<front id="dogm_font_data_ISO10646_CNH-171">  11,22,12,0,255,2,0,127,224,66,0,66,0,95,192,66,</front>
<front id="dogm_font_data_ISO10646_CNH-172">  0,71,0,74,128,82,64,98,32,130,0,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-173">  255,243,192,150,64,145,128,166,96,161,0,151,192,145,0,149,</front>
<front id="dogm_font_data_ISO10646_CNH-174">  0,231,224,129,0,129,0,11,11,22,12,0,255,15,128,136,</front>
<front id="dogm_font_data_ISO10646_CNH-175">  128,79,128,8,128,143,128,64,0,31,192,53,64,85,64,149,</front>
<front id="dogm_font_data_ISO10646_CNH-176">  64,63,224,11,11,22,12,0,255,39,224,32,128,248,128,32,</front>
<front id="dogm_font_data_ISO10646_CNH-177">  128,32,128,56,128,224,128,32,128,32,128,32,128,97,128,11,</front>
<front id="dogm_font_data_ISO10646_CNH-178">  11,22,12,0,255,31,224,145,0,87,192,20,64,23,192,148,</front>
<front id="dogm_font_data_ISO10646_CNH-179">  64,87,192,17,0,85,64,153,32,35,0,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-180">  255,32,128,39,224,242,64,33,128,34,64,52,32,226,64,34,</front>
<front id="dogm_font_data_ISO10646_CNH-181">  64,34,64,34,64,100,64,11,11,22,12,0,255,65,0,65,</front>
<front id="dogm_font_data_ISO10646_CNH-182">  0,79,224,233,32,73,32,73,32,111,224,201,32,73,32,73,</front>
<front id="dogm_font_data_ISO10646_CNH-183">  32,207,224,11,11,22,12,0,255,33,0,241,0,79,224,169,</front>
<front id="dogm_font_data_ISO10646_CNH-184">  32,249,32,47,224,57,32,233,32,41,32,47,224,40,32,11,</front>
<front id="dogm_font_data_ISO10646_CNH-185">  11,22,12,0,255,143,224,73,32,9,32,203,160,73,32,79,</front>
<front id="dogm_font_data_ISO10646_CNH-186">  224,72,32,75,160,74,160,107,160,80,224,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-187">  255,127,192,4,0,68,64,36,64,36,128,4,0,255,224,4,</front>
<front id="dogm_font_data_ISO10646_CNH-188">  0,4,0,4,0,4,0,11,11,22,12,0,255,130,0,66,</front>
<front id="dogm_font_data_ISO10646_CNH-189">  0,31,224,194,0,95,192,82,64,95,192,71,0,74,128,82,</front>
<front id="dogm_font_data_ISO10646_CNH-190">  64,191,224,11,11,22,12,0,255,4,0,127,224,72,128,127,</front>
<front id="dogm_font_data_ISO10646_CNH-191">  224,72,128,79,128,64,0,95,192,72,64,71,128,152,96,11,</front>
<front id="dogm_font_data_ISO10646_CNH-192">  11,22,12,0,255,1,0,239,224,161,0,164,64,175,224,164,</front>
<front id="dogm_font_data_ISO10646_CNH-193">  64,175,224,169,32,233,32,2,128,12,96,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-194">  255,20,192,246,160,188,96,167,128,168,128,191,224,169,32,239,</front>
<front id="dogm_font_data_ISO10646_CNH-195">  224,9,32,15,224,9,32,11,11,22,12,0,255,127,128,64,</front>
<front id="dogm_font_data_ISO10646_CNH-196">  128,66,128,98,128,84,128,72,128,72,128,84,160,98,160,64,</front>
<front id="dogm_font_data_ISO10646_CNH-197">  96,128,32,11,11,22,12,0,255,4,0,127,224,64,32,127,</front>
<front id="dogm_font_data_ISO10646_CNH-198">  224,64,0,125,224,84,32,76,160,84,96,100,160,141,96,11,</front>
<front id="dogm_font_data_ISO10646_CNH-199">  11,22,12,0,255,130,0,95,224,4,0,8,64,159,224,64,</front>
<front id="dogm_font_data_ISO10646_CNH-200">  32,10,128,10,128,74,160,146,160,34,96,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-201">  255,65,0,79,224,232,32,66,128,68,64,104,32,199,192,65,</front>
<front id="dogm_font_data_ISO10646_CNH-202">  0,65,0,65,0,207,224,11,11,22,12,0,255,80,32,125,</front>
<front id="dogm_font_data_ISO10646_CNH-203">  32,145,32,255,32,17,32,125,32,85,32,85,32,84,32,92,</front>
<front id="dogm_font_data_ISO10646_CNH-204">  32,16,224,11,11,22,12,0,255,63,128,32,128,63,128,32,</front>
<front id="dogm_font_data_ISO10646_CNH-205">  128,255,224,72,0,123,192,73,64,121,64,72,128,251,96,11,</front>
<front id="dogm_font_data_ISO10646_CNH-206">  11,22,12,0,255,4,0,4,0,4,0,36,128,36,64,68,</front>
<front id="dogm_font_data_ISO10646_CNH-207">  64,68,32,132,32,4,0,4,0,28,0,11,11,22,12,0,</front>
<front id="dogm_font_data_ISO10646_CNH-208">  255,4,0,4,0,4,0,255,224,4,0,10,0,10,0,17,</front>
<front id="dogm_font_data_ISO10646_CNH-209">  0,17,0,32,128,192,96,9,10,20,10,0,0,136,128,73,</front>
<front id="dogm_font_data_ISO10646_CNH-210">  0,8,0,255,128,0,128,0,128,127,128,0,128,0,128,255,</front>
<front id="dogm_font_data_ISO10646_CNH-211">  128,11,11,22,12,0,255,33,0,18,0,255,224,0,0,120,</front>
<front id="dogm_font_data_ISO10646_CNH-212">  128,74,128,122,128,74,128,122,128,72,128,89,128,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-213">  12,0,255,39,192,0,0,0,0,239,224,33,0,34,0,36,</front>
<front id="dogm_font_data_ISO10646_CNH-214">  64,47,224,32,32,80,0,143,224,11,11,22,12,0,255,32,</front>
<front id="dogm_font_data_ISO10646_CNH-215">  128,39,0,249,0,33,192,119,0,33,0,249,224,39,0,113,</front>
<front id="dogm_font_data_ISO10646_CNH-216">  32,169,32,32,224,11,11,22,12,0,255,16,64,16,64,253,</front>
<front id="dogm_font_data_ISO10646_CNH-217">  224,16,64,56,192,53,64,82,64,148,64,16,64,16,64,16,</front>
<front id="dogm_font_data_ISO10646_CNH-218">  192,11,11,22,12,0,255,0,64,248,64,11,224,8,64,136,</front>
<front id="dogm_font_data_ISO10646_CNH-219">  64,82,64,81,64,33,64,80,64,72,64,137,192,10,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-220">  12,0,255,132,0,132,64,132,128,245,0,134,0,132,0,132,</front>
<front id="dogm_font_data_ISO10646_CNH-221">  0,148,0,164,64,196,64,131,192,11,11,22,12,0,255,17,</front>
<front id="dogm_font_data_ISO10646_CNH-222">  32,125,0,17,0,255,224,41,0,253,64,73,64,124,128,8,</front>
<front id="dogm_font_data_ISO10646_CNH-223">  160,253,96,10,32,11,11,22,12,0,255,23,192,36,64,36,</front>
<front id="dogm_font_data_ISO10646_CNH-224">  64,103,192,161,0,47,224,33,0,35,128,37,64,41,32,33,</front>
<front id="dogm_font_data_ISO10646_CNH-225">  0,11,11,22,12,0,255,8,0,255,224,16,0,39,192,32,</front>
<front id="dogm_font_data_ISO10646_CNH-226">  128,97,0,175,224,33,0,33,0,33,0,35,0,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-227">  12,0,255,36,0,47,224,180,0,164,128,164,160,170,192,42,</front>
<front id="dogm_font_data_ISO10646_CNH-228">  128,40,128,41,64,50,64,36,32,11,11,22,12,0,255,127,</front>
<front id="dogm_font_data_ISO10646_CNH-229">  224,128,0,63,192,32,64,63,192,16,0,31,192,16,64,40,</front>
<front id="dogm_font_data_ISO10646_CNH-230">  128,71,0,56,224,11,11,22,12,0,255,127,224,64,0,64,</front>
<front id="dogm_font_data_ISO10646_CNH-231">  0,64,0,64,0,64,0,64,0,64,0,64,0,64,0,128,</front>
<front id="dogm_font_data_ISO10646_CNH-232">  0,11,11,22,12,0,255,255,224,4,0,127,192,68,64,127,</front>
<front id="dogm_font_data_ISO10646_CNH-233">  192,68,64,127,192,68,0,36,0,24,0,231,224,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-234">  12,0,255,17,224,253,0,69,0,41,224,253,64,17,64,125,</front>
<front id="dogm_font_data_ISO10646_CNH-235">  64,17,64,85,64,146,64,52,64,11,11,22,12,0,255,33,</front>
<front id="dogm_font_data_ISO10646_CNH-236">  0,95,224,64,0,207,192,64,0,79,192,64,0,79,192,72,</front>
<front id="dogm_font_data_ISO10646_CNH-237">  64,79,192,72,64,11,11,22,12,0,255,4,0,127,192,64,</front>
<front id="dogm_font_data_ISO10646_CNH-238">  64,127,192,64,64,127,192,64,64,127,192,4,64,82,32,191,</front>
<front id="dogm_font_data_ISO10646_CNH-239">  160,11,11,22,12,0,255,127,192,68,64,127,192,68,64,127,</front>
<front id="dogm_font_data_ISO10646_CNH-240">  192,4,0,27,0,224,224,17,0,17,0,97,0,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-241">  12,0,255,255,224,4,0,8,0,127,224,73,32,79,32,73,</front>
<front id="dogm_font_data_ISO10646_CNH-242">  32,79,32,73,32,73,32,127,224,11,11,22,12,0,255,253,</front>
<front id="dogm_font_data_ISO10646_CNH-243">  224,86,64,121,64,56,128,85,64,146,32,255,224,4,0,39,</front>
<front id="dogm_font_data_ISO10646_CNH-244">  192,36,0,255,224,11,11,22,12,0,255,251,128,82,0,123,</front>
<front id="dogm_font_data_ISO10646_CNH-245">  224,18,64,250,64,20,64,63,128,32,128,63,128,32,128,63,</front>
<front id="dogm_font_data_ISO10646_CNH-246">  128,11,11,22,12,0,255,31,224,32,0,39,192,100,64,167,</front>
<front id="dogm_font_data_ISO10646_CNH-247">  192,32,0,47,224,40,32,39,192,33,0,35,0,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-248">  12,0,255,243,224,130,32,130,32,250,32,130,32,130,32,138,</front>
<front id="dogm_font_data_ISO10646_CNH-249">  32,178,32,194,224,2,0,2,0,11,11,22,12,0,255,36,</front>
<front id="dogm_font_data_ISO10646_CNH-250">  128,70,160,149,192,228,128,39,224,68,128,245,192,6,160,52,</front>
<front id="dogm_font_data_ISO10646_CNH-251">  128,196,128,7,224,11,11,22,12,0,255,39,192,65,0,135,</front>
<front id="dogm_font_data_ISO10646_CNH-252">  224,224,32,34,128,69,128,242,128,15,224,48,128,193,64,2,</front>
<front id="dogm_font_data_ISO10646_CNH-253">  32,11,11,22,12,0,255,2,0,2,0,34,0,35,192,34,</front>
<front id="dogm_font_data_ISO10646_CNH-254">  0,34,0,34,0,34,0,34,0,34,0,255,224,9,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-255">  12,0,255,8,0,8,0,255,128,136,128,136,128,136,128,255,</front>
<front id="dogm_font_data_ISO10646_CNH-256">  128,136,128,136,128,136,128,255,128,11,11,22,12,0,255,33,</front>
<front id="dogm_font_data_ISO10646_CNH-257">  0,83,160,65,0,247,224,81,0,83,192,86,64,83,192,90,</front>
<front id="dogm_font_data_ISO10646_CNH-258">  64,83,192,66,64,11,11,22,12,0,255,127,192,4,0,4,</front>
<front id="dogm_font_data_ISO10646_CNH-259">  0,4,0,255,224,10,0,10,0,18,0,34,32,66,32,129,</front>
<front id="dogm_font_data_ISO10646_CNH-260">  224,11,11,22,12,0,255,17,0,33,0,47,224,97,0,163,</front>
<front id="dogm_font_data_ISO10646_CNH-261">  128,35,128,37,64,37,64,41,32,33,0,33,0,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-262">  12,0,255,247,224,148,32,244,32,151,224,148,128,244,128,151,</front>
<front id="dogm_font_data_ISO10646_CNH-263">  224,148,128,244,160,150,96,4,32,11,11,22,12,0,255,123,</front>
<front id="dogm_font_data_ISO10646_CNH-264">  224,148,128,4,0,127,192,4,0,255,224,1,0,255,224,33,</front>
<front id="dogm_font_data_ISO10646_CNH-265">  0,17,0,7,0,11,11,22,12,0,255,33,0,71,192,145,</front>
<front id="dogm_font_data_ISO10646_CNH-266">  0,47,224,96,128,175,224,32,128,36,128,34,128,32,128,35,</front>
<front id="dogm_font_data_ISO10646_CNH-267">  128,11,11,22,12,0,255,39,192,36,64,247,192,46,224,42,</front>
<front id="dogm_font_data_ISO10646_CNH-268">  160,62,224,225,0,47,224,35,128,37,64,105,32,11,11,22,</front>
<front id="dogm_font_data_ISO10646_CNH-269">  12,0,255,20,0,39,224,42,0,98,0,163,192,34,0,34,</front>
<front id="dogm_font_data_ISO10646_CNH-270">  0,35,224,34,0,34,0,34,0};</front>
 </pre>
<h1 id="dogm_font_data_ISO10646_KanaHtitle" >dogm_font_data_ISO10646_Kana.h</h1>
<pre id="dogm_font_data_ISO10646_KanaH"  class="prettyprint linenums"><front id="dogm_font_data_ISO10646_KanaH-1">/*</front>
<front id="dogm_font_data_ISO10646_KanaH-2">  Fontname: ISO10646_Kana</front>
<front id="dogm_font_data_ISO10646_KanaH-3">  Copyright: A. Hardtung, public domain</front>
<front id="dogm_font_data_ISO10646_KanaH-4">  Capital A Height: 7, '1' Height: 7</front>
<front id="dogm_font_data_ISO10646_KanaH-5">  Calculated Max Values w= 5 h= 9 x= 2 y= 5 dx= 6 dy= 0 ascent= 8 len= 9</front>
<front id="dogm_font_data_ISO10646_KanaH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_ISO10646_KanaH-7">  Calculated Min Values           x= 0 y=-1 dx= 0 dy= 0</front>
<front id="dogm_font_data_ISO10646_KanaH-8">  Pure Font   ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_KanaH-9">  X Font      ascent = 7 descent=-1</front>
<front id="dogm_font_data_ISO10646_KanaH-10">  Max Font    ascent = 8 descent=-1</front>
<front id="dogm_font_data_ISO10646_KanaH-11">*/</front>
<front id="dogm_font_data_ISO10646_KanaH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_ISO10646_KanaH-13">const u8g_fntpgm_uint8_t ISO10646_Kana_5x7[2549] U8G_SECTION(".progmem.ISO10646_Kana_5x7") = {</front>
<front id="dogm_font_data_ISO10646_KanaH-14">  0,6,9,0,254,7,1,145,3,32,32,255,255,8,255,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-15">  255,0,0,0,6,0,0,1,7,7,6,2,0,128,128,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-16">  128,128,0,128,3,2,2,6,1,5,160,160,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-17">  0,0,80,80,248,80,248,80,80,5,7,7,6,0,0,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-18">  120,160,112,40,240,32,5,7,7,6,0,0,192,200,16,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-19">  64,152,24,5,7,7,6,0,0,96,144,160,64,168,144,104,</front>
<front id="dogm_font_data_ISO10646_KanaH-20">  2,3,3,6,1,4,192,64,128,3,7,7,6,1,0,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-21">  64,128,128,128,64,32,3,7,7,6,1,0,128,64,32,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-22">  32,64,128,5,5,5,6,0,1,32,168,112,168,32,5,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-23">  5,6,0,1,32,32,248,32,32,2,3,3,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_KanaH-24">  64,128,5,1,1,6,0,3,248,2,2,2,6,2,0,192,</front>
<front id="dogm_font_data_ISO10646_KanaH-25">  192,5,5,5,6,0,1,8,16,32,64,128,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-26">  0,0,112,136,152,168,200,136,112,3,7,7,6,1,0,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-27">  192,64,64,64,64,224,5,7,7,6,0,0,112,136,8,112,</front>
<front id="dogm_font_data_ISO10646_KanaH-28">  128,128,248,5,7,7,6,0,0,248,16,32,16,8,8,240,</front>
<front id="dogm_font_data_ISO10646_KanaH-29">  5,7,7,6,0,0,16,48,80,144,248,16,16,5,7,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-30">  6,0,0,248,128,240,8,8,136,112,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-31">  48,64,128,240,136,136,112,5,7,7,6,0,0,248,8,16,</front>
<front id="dogm_font_data_ISO10646_KanaH-32">  32,32,32,32,5,7,7,6,0,0,112,136,136,112,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-33">  112,5,7,7,6,0,0,112,136,136,120,8,16,96,2,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-34">  5,6,2,0,192,192,0,192,192,2,6,6,6,2,255,192,</front>
<front id="dogm_font_data_ISO10646_KanaH-35">  192,0,192,64,128,4,7,7,6,0,0,16,32,64,128,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-36">  32,16,5,3,3,6,0,2,248,0,248,4,7,7,6,1,</front>
<front id="dogm_font_data_ISO10646_KanaH-37">  0,128,64,32,16,32,64,128,5,7,7,6,0,0,112,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-38">  8,16,32,0,32,5,6,6,6,0,0,112,136,8,104,168,</front>
<front id="dogm_font_data_ISO10646_KanaH-39">  112,5,7,7,6,0,0,112,136,136,248,136,136,136,5,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-40">  7,6,0,0,240,136,136,240,136,136,240,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-41">  0,112,136,128,128,128,136,112,5,7,7,6,0,0,224,144,</front>
<front id="dogm_font_data_ISO10646_KanaH-42">  136,136,136,144,224,5,7,7,6,0,0,248,128,128,240,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-43">  128,248,5,7,7,6,0,0,248,128,128,240,128,128,128,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-44">  7,7,6,0,0,112,136,128,184,136,136,112,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-45">  0,0,136,136,136,248,136,136,136,1,7,7,6,2,0,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-46">  128,128,128,128,128,128,5,7,7,6,0,0,56,16,16,16,</front>
<front id="dogm_font_data_ISO10646_KanaH-47">  16,144,96,5,7,7,6,0,0,136,144,160,192,160,144,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-48">  5,7,7,6,0,0,128,128,128,128,128,128,248,5,7,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-49">  6,0,0,136,216,168,136,136,136,136,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-50">  136,136,200,168,152,136,136,5,7,7,6,0,0,112,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-51">  136,136,136,112,5,7,7,6,0,0,240,136,136,240,128,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-52">  128,5,7,7,6,0,0,112,136,136,136,168,144,104,5,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-53">  7,6,0,0,240,136,136,240,160,144,136,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-54">  0,120,128,128,112,8,8,240,5,7,7,6,0,0,248,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-55">  32,32,32,32,32,5,7,7,6,0,0,136,136,136,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-56">  136,112,5,7,7,6,0,0,136,136,136,136,136,80,32,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-57">  7,7,6,0,0,136,136,136,136,136,168,80,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-58">  0,0,136,136,80,32,80,136,136,5,7,7,6,0,0,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-59">  136,136,80,32,32,32,5,7,7,6,0,0,248,8,16,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-60">  64,128,248,3,7,7,6,1,0,224,128,128,128,128,128,224,</front>
<front id="dogm_font_data_ISO10646_KanaH-61">  5,5,5,6,0,1,128,64,32,16,8,3,7,7,6,1,</front>
<front id="dogm_font_data_ISO10646_KanaH-62">  0,224,32,32,32,32,32,224,5,3,3,6,0,4,32,80,</front>
<front id="dogm_font_data_ISO10646_KanaH-63">  136,5,1,1,6,0,0,248,2,2,2,6,2,5,128,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-64">  5,5,5,6,0,0,112,8,120,136,120,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-65">  0,128,128,176,200,136,136,240,5,5,5,6,0,0,112,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-66">  128,136,112,5,7,7,6,0,0,8,8,104,152,136,136,120,</front>
<front id="dogm_font_data_ISO10646_KanaH-67">  5,5,5,6,0,0,112,136,248,128,112,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-68">  0,48,72,224,64,64,64,64,5,6,6,6,0,255,112,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-69">  136,120,8,112,5,7,7,6,0,0,128,128,176,200,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-70">  136,1,7,7,6,2,0,128,0,128,128,128,128,128,3,8,</front>
<front id="dogm_font_data_ISO10646_KanaH-71">  8,6,1,255,32,0,32,32,32,32,160,64,4,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-72">  0,0,128,128,144,160,192,160,144,3,7,7,6,1,0,192,</front>
<front id="dogm_font_data_ISO10646_KanaH-73">  64,64,64,64,64,224,5,5,5,6,0,0,208,168,168,168,</front>
<front id="dogm_font_data_ISO10646_KanaH-74">  168,5,5,5,6,0,0,176,200,136,136,136,5,5,5,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-75">  0,0,112,136,136,136,112,5,6,6,6,0,255,240,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-76">  240,128,128,5,6,6,6,0,255,120,136,136,120,8,8,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-77">  5,5,6,0,0,176,200,128,128,128,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-78">  112,128,112,8,240,5,7,7,6,0,0,64,64,224,64,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-79">  72,48,5,5,5,6,0,0,136,136,136,152,104,5,5,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-80">  6,0,0,136,136,136,80,32,5,5,5,6,0,0,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-81">  168,168,80,5,5,5,6,0,0,136,80,32,80,136,5,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-82">  6,6,0,255,136,136,136,120,8,112,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-83">  248,16,32,64,248,3,7,7,6,1,0,32,64,64,128,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-84">  64,32,1,7,7,6,2,0,128,128,128,128,128,128,128,3,</front>
<front id="dogm_font_data_ISO10646_KanaH-85">  7,7,6,1,0,128,64,64,32,64,64,128,5,2,2,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-86">  0,3,104,144,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-87">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-88">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-89">  0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-90">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-91">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-92">  0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-93">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-94">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-95">  0,6,0,0,0,0,0,6,0,0,0,0,0,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-96">  0,0,0,6,0,0,0,0,0,6,0,0,0,0,0,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-97">  0,0,0,0,0,6,0,0,0,0,0,6,0,0,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-98">  0,6,0,0,0,0,0,6,0,0,5,3,3,6,0,2,</front>
<front id="dogm_font_data_ISO10646_KanaH-99">  248,0,248,5,6,6,6,0,0,248,8,40,48,32,64,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-100">  7,7,6,0,0,248,8,40,48,32,32,64,4,5,5,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-101">  0,0,16,32,96,160,32,5,7,7,6,0,0,8,16,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-102">  96,160,32,32,5,5,5,6,0,0,32,248,136,8,48,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-103">  7,7,6,0,0,32,248,136,136,8,16,32,5,4,4,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-104">  0,0,248,32,32,248,5,6,6,6,0,0,248,32,32,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-105">  32,248,5,5,5,6,0,0,16,248,48,80,144,5,7,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-106">  6,0,0,16,248,16,48,80,144,16,5,5,5,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-107">  64,248,72,80,64,5,7,7,6,0,0,40,0,64,248,72,</front>
<front id="dogm_font_data_ISO10646_KanaH-108">  80,64,5,7,7,6,0,0,32,248,32,248,32,32,32,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-109">  8,8,6,0,0,40,0,32,248,32,248,32,32,4,6,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-110">  6,0,0,64,112,144,16,16,32,5,8,8,6,0,0,40,</front>
<front id="dogm_font_data_ISO10646_KanaH-111">  0,64,112,144,16,16,32,5,6,6,6,0,0,64,120,144,</front>
<front id="dogm_font_data_ISO10646_KanaH-112">  16,16,32,5,8,8,6,0,0,40,0,64,120,144,16,16,</front>
<front id="dogm_font_data_ISO10646_KanaH-113">  32,5,5,5,6,0,0,248,8,8,8,248,5,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-114">  0,0,40,0,248,8,8,8,248,5,7,7,6,0,255,80,</front>
<front id="dogm_font_data_ISO10646_KanaH-115">  248,80,80,16,32,64,5,9,9,6,0,255,40,0,80,248,</front>
<front id="dogm_font_data_ISO10646_KanaH-116">  80,80,16,32,64,5,6,6,6,0,0,192,8,200,8,16,</front>
<front id="dogm_font_data_ISO10646_KanaH-117">  224,5,8,8,6,0,0,40,0,192,8,200,8,16,224,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-118">  6,6,6,0,0,248,8,16,32,80,136,5,8,8,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-119">  0,40,0,248,8,16,32,80,136,5,6,6,6,0,0,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-120">  248,72,80,64,120,5,8,8,6,0,0,40,0,64,248,72,</front>
<front id="dogm_font_data_ISO10646_KanaH-121">  80,64,120,4,4,4,6,0,1,16,208,16,224,5,7,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-122">  6,0,0,40,0,8,200,8,16,224,5,7,7,6,0,255,</front>
<front id="dogm_font_data_ISO10646_KanaH-123">  32,120,136,40,16,40,64,5,9,9,6,0,255,40,0,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-124">  120,136,40,16,40,64,5,6,6,6,0,0,240,32,248,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-125">  64,128,5,8,8,6,0,0,40,0,240,32,248,32,64,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-126">  4,5,5,6,0,1,192,16,208,16,224,5,6,6,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-127">  0,192,8,200,8,16,224,5,8,8,6,0,0,40,0,192,</front>
<front id="dogm_font_data_ISO10646_KanaH-128">  8,200,8,16,224,5,6,6,6,0,0,112,0,248,32,32,</front>
<front id="dogm_font_data_ISO10646_KanaH-129">  64,5,8,8,6,0,0,40,0,112,0,248,32,32,64,3,</front>
<front id="dogm_font_data_ISO10646_KanaH-130">  7,7,6,1,0,128,128,128,192,160,128,128,4,8,8,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-131">  1,0,80,0,128,128,192,160,128,128,5,7,7,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-132">  32,32,248,32,32,64,128,5,6,6,6,0,0,112,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-133">  0,0,248,5,6,6,6,0,0,248,8,80,32,80,128,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-134">  7,7,6,0,255,32,248,8,16,32,112,168,3,7,7,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-135">  1,0,32,32,32,32,32,64,128,5,5,5,6,0,0,16,</front>
<front id="dogm_font_data_ISO10646_KanaH-136">  136,136,136,136,5,7,7,6,0,0,40,0,16,136,136,136,</front>
<front id="dogm_font_data_ISO10646_KanaH-137">  136,5,8,8,6,0,0,24,24,0,16,136,136,136,136,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-138">  7,7,6,0,0,128,128,248,128,128,128,120,5,8,8,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-139">  0,0,40,128,128,248,128,128,128,120,5,8,8,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-140">  24,152,128,248,128,128,128,120,5,6,6,6,0,0,248,8,</front>
<front id="dogm_font_data_ISO10646_KanaH-141">  8,8,16,96,5,8,8,6,0,0,40,0,248,8,8,8,</front>
<front id="dogm_font_data_ISO10646_KanaH-142">  16,96,5,8,8,6,0,0,24,24,248,8,8,8,16,96,</front>
<front id="dogm_font_data_ISO10646_KanaH-143">  5,5,5,6,0,1,64,160,16,8,8,5,7,7,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-144">  1,40,0,64,160,16,8,8,5,7,7,6,0,1,24,24,</front>
<front id="dogm_font_data_ISO10646_KanaH-145">  64,160,16,8,8,5,6,6,6,0,0,32,248,32,32,168,</front>
<front id="dogm_font_data_ISO10646_KanaH-146">  168,5,8,8,6,0,0,40,0,32,248,32,32,168,168,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-147">  8,8,6,0,0,24,24,32,248,32,32,168,168,5,6,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-148">  6,0,0,248,8,8,80,32,16,4,6,6,6,1,0,224,</front>
<front id="dogm_font_data_ISO10646_KanaH-149">  0,224,0,224,16,5,6,6,6,0,0,32,64,128,144,248,</front>
<front id="dogm_font_data_ISO10646_KanaH-150">  8,5,6,6,6,0,0,8,8,80,32,80,128,5,6,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-151">  6,0,0,120,32,248,32,32,56,5,7,7,6,0,0,64,</front>
<front id="dogm_font_data_ISO10646_KanaH-152">  64,248,72,80,64,64,5,7,7,6,0,0,64,248,72,80,</front>
<front id="dogm_font_data_ISO10646_KanaH-153">  64,64,64,5,5,5,6,0,0,112,16,16,16,248,5,7,</front>
<front id="dogm_font_data_ISO10646_KanaH-154">  7,6,0,0,112,16,16,16,16,16,248,4,5,5,6,1,</front>
<front id="dogm_font_data_ISO10646_KanaH-155">  0,240,16,240,16,240,5,7,7,6,0,0,248,8,8,248,</front>
<front id="dogm_font_data_ISO10646_KanaH-156">  8,8,248,5,6,6,6,0,0,112,0,248,8,16,32,3,</front>
<front id="dogm_font_data_ISO10646_KanaH-157">  6,6,6,1,0,160,160,160,160,32,64,5,6,6,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-158">  0,80,80,80,80,88,144,4,6,6,6,1,0,128,128,128,</front>
<front id="dogm_font_data_ISO10646_KanaH-159">  144,160,192,5,6,6,6,0,0,248,136,136,136,248,136,5,</front>
<front id="dogm_font_data_ISO10646_KanaH-160">  5,5,6,0,0,248,136,8,16,96,5,6,6,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-161">  248,136,8,8,16,96,5,6,6,6,0,0,16,248,80,80,</front>
<front id="dogm_font_data_ISO10646_KanaH-162">  248,16,5,6,6,6,0,0,248,8,80,96,64,248,5,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-163">  6,6,0,0,248,8,248,8,16,32,5,6,6,6,0,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-164">  128,64,8,8,16,224,5,8,8,6,0,0,40,0,32,248,</front>
<front id="dogm_font_data_ISO10646_KanaH-165">  136,8,24,32,5,6,6,6,0,0,64,248,72,72,136,144,</front>
<front id="dogm_font_data_ISO10646_KanaH-166">  4,5,5,6,1,0,128,240,160,32,32,5,8,8,6,0,</front>
<front id="dogm_font_data_ISO10646_KanaH-167">  0,40,0,248,136,8,8,16,96,5,8,8,6,0,0,40,</front>
<front id="dogm_font_data_ISO10646_KanaH-168">  0,16,248,80,80,248,16,5,7,7,6,0,0,40,0,248,</front>
<front id="dogm_font_data_ISO10646_KanaH-169">  16,32,32,248,5,8,8,6,0,0,40,0,248,8,248,8,</front>
<front id="dogm_font_data_ISO10646_KanaH-170">  16,32,2,2,2,6,2,2,192,192,5,1,1,6,0,3,</front>
<front id="dogm_font_data_ISO10646_KanaH-171">  248,5,5,5,6,0,1,128,64,32,16,8,5,6,6,6,</front>
<front id="dogm_font_data_ISO10646_KanaH-172">  0,1,40,128,64,32,16,8,5,7,7,6,0,0,248,8,</front>
<front id="dogm_font_data_ISO10646_KanaH-173">  8,8,8,8,8};</front>
 </pre>
<h1 id="dogm_font_data_Marlin_symbolsHtitle" >dogm_font_data_Marlin_symbols.h</h1>
<pre id="dogm_font_data_Marlin_symbolsH"  class="prettyprint linenums"><front id="dogm_font_data_Marlin_symbolsH-1">/*</front>
<front id="dogm_font_data_Marlin_symbolsH-2">  Fontname: Marlin_symbols</front>
<front id="dogm_font_data_Marlin_symbolsH-3">  Copyright: Created with Fony 1.4.7</front>
<front id="dogm_font_data_Marlin_symbolsH-4">  Capital A Height: 0, '1' Height: 0</front>
<front id="dogm_font_data_Marlin_symbolsH-5">  Calculated Max Values w= 5 h=10 x= 0 y= 3 dx= 6 dy= 0 ascent= 8 len=10</front>
<front id="dogm_font_data_Marlin_symbolsH-6">  Font Bounding box     w= 6 h= 9 x= 0 y=-2</front>
<front id="dogm_font_data_Marlin_symbolsH-7">  Calculated Min Values           x= 0 y=-2 dx= 0 dy= 0</front>
<front id="dogm_font_data_Marlin_symbolsH-8">  Pure Font   ascent = 0 descent= 0</front>
<front id="dogm_font_data_Marlin_symbolsH-9">  X Font      ascent = 0 descent= 0</front>
<front id="dogm_font_data_Marlin_symbolsH-10">  Max Font    ascent = 8 descent=-2</front>
<front id="dogm_font_data_Marlin_symbolsH-11">*/</front>
<front id="dogm_font_data_Marlin_symbolsH-12">#include &lt;U8glib.h&gt;</front>
<front id="dogm_font_data_Marlin_symbolsH-13">const u8g_fntpgm_uint8_t Marlin_symbols[140] U8G_SECTION(".progmem.Marlin_symbols") = {</front>
<front id="dogm_font_data_Marlin_symbolsH-14">  0,6,9,0,254,0,0,0,0,0,1,9,0,8,254,0,</front>
<front id="dogm_font_data_Marlin_symbolsH-15">  0,5,8,8,6,0,0,64,240,200,136,136,152,120,16,5,</front>
<front id="dogm_font_data_Marlin_symbolsH-16">  8,8,6,0,0,192,248,136,136,136,136,136,248,5,5,5,</front>
<front id="dogm_font_data_Marlin_symbolsH-17">  6,0,1,32,48,248,48,32,5,8,8,6,0,0,32,112,</front>
<front id="dogm_font_data_Marlin_symbolsH-18">  248,32,32,32,32,224,5,9,9,6,0,255,32,112,168,168,</front>
<front id="dogm_font_data_Marlin_symbolsH-19">  184,136,136,112,32,5,9,9,6,0,255,224,128,192,176,168,</front>
<front id="dogm_font_data_Marlin_symbolsH-20">  40,48,40,40,5,9,9,6,0,255,248,168,136,136,136,136,</front>
<front id="dogm_font_data_Marlin_symbolsH-21">  136,168,248,5,10,10,6,0,254,32,80,80,80,80,136,168,</front>
<front id="dogm_font_data_Marlin_symbolsH-22">  168,136,112,3,3,3,6,0,3,64,160,64};</front>
 </pre>
<h1 id="dogm_lcd_implementationHtitle" >dogm_lcd_implementation.h</h1>
<pre id="dogm_lcd_implementationH"  class="prettyprint linenums"><front id="dogm_lcd_implementationH-1">/**</front>
<front id="dogm_lcd_implementationH-2"> * dogm_lcd_implementation.h</front>
<front id="dogm_lcd_implementationH-3"> *</front>
<front id="dogm_lcd_implementationH-4"> * Graphics LCD implementation for 128x64 pixel LCDs by STB for ErikZalm/Marlin</front>
<front id="dogm_lcd_implementationH-5"> * Demonstrator: http://www.reprap.org/wiki/STB_Electronics</front>
<front id="dogm_lcd_implementationH-6"> * License: http://opensource.org/licenses/BSD-3-Clause</front>
<front id="dogm_lcd_implementationH-7"> *</front>
<front id="dogm_lcd_implementationH-8"> * With the use of:</front>
<front id="dogm_lcd_implementationH-9"> * u8glib by Oliver Kraus</front>
<front id="dogm_lcd_implementationH-10"> * http://code.google.com/p/u8glib/</front>
<front id="dogm_lcd_implementationH-11"> * License: http://opensource.org/licenses/BSD-3-Clause</front>
<front id="dogm_lcd_implementationH-12"> */</front>
<front id="dogm_lcd_implementationH-13"></front>
<front id="dogm_lcd_implementationH-14">#ifndef DOGM_LCD_IMPLEMENTATION_H</front>
<front id="dogm_lcd_implementationH-15">#define DOGM_LCD_IMPLEMENTATION_H</front>
<front id="dogm_lcd_implementationH-16"></front>
<front id="dogm_lcd_implementationH-17">/**</front>
<front id="dogm_lcd_implementationH-18"> * Implementation of the LCD display routines for a DOGM128 graphic display. These are common LCD 128x64 pixel graphic displays.</front>
<front id="dogm_lcd_implementationH-19"> */</front>
<front id="dogm_lcd_implementationH-20"></front>
<front id="dogm_lcd_implementationH-21">#if ENABLED(ULTIPANEL)</front>
<front id="dogm_lcd_implementationH-22">  #define BLEN_A 0</front>
<front id="dogm_lcd_implementationH-23">  #define BLEN_B 1</front>
<front id="dogm_lcd_implementationH-24">  #define BLEN_C 2</front>
<front id="dogm_lcd_implementationH-25">  #define EN_A BIT(BLEN_A)</front>
<front id="dogm_lcd_implementationH-26">  #define EN_B BIT(BLEN_B)</front>
<front id="dogm_lcd_implementationH-27">  #define EN_C BIT(BLEN_C)</front>
<front id="dogm_lcd_implementationH-28">  #define LCD_CLICKED (buttons&EN_C)</front>
<front id="dogm_lcd_implementationH-29">#endif</front>
<front id="dogm_lcd_implementationH-30"></front>
<front id="dogm_lcd_implementationH-31">#include &lt;U8glib.h&gt;</front>
<front id="dogm_lcd_implementationH-32">#include "dogm_bitmaps.h"</front>
<front id="dogm_lcd_implementationH-33"></front>
<front id="dogm_lcd_implementationH-34">#include "ultralcd.h"</front>
<front id="dogm_lcd_implementationH-35">#include "ultralcd_st7920_u8glib_rrd.h"</front>
<front id="dogm_lcd_implementationH-36">#include "Configuration.h"</front>
<front id="dogm_lcd_implementationH-37"></front>
<front id="dogm_lcd_implementationH-38">#if DISABLED(MAPPER_C2C3) && DISABLED(MAPPER_NON) && ENABLED(USE_BIG_EDIT_FONT)</front>
<front id="dogm_lcd_implementationH-39">   #undef USE_BIG_EDIT_FONT</front>
<front id="dogm_lcd_implementationH-40">#endif</front>
<front id="dogm_lcd_implementationH-41"></front>
<front id="dogm_lcd_implementationH-42"></front>
<front id="dogm_lcd_implementationH-43">#if ENABLED(USE_SMALL_INFOFONT)</front>
<front id="dogm_lcd_implementationH-44">  #include "dogm_font_data_6x9_marlin.h"</front>
<front id="dogm_lcd_implementationH-45">  #define FONT_STATUSMENU_NAME u8g_font_6x9</front>
<front id="dogm_lcd_implementationH-46">#else</front>
<front id="dogm_lcd_implementationH-47">  #define FONT_STATUSMENU_NAME FONT_MENU_NAME</front>
<front id="dogm_lcd_implementationH-48">#endif</front>
<front id="dogm_lcd_implementationH-49"></front>
<front id="dogm_lcd_implementationH-50">#include "dogm_font_data_Marlin_symbols.h"   // The Marlin special symbols</front>
<front id="dogm_lcd_implementationH-51">#define FONT_SPECIAL_NAME Marlin_symbols</front>
<front id="dogm_lcd_implementationH-52"></front>
<front id="dogm_lcd_implementationH-53">#if DISABLED(SIMULATE_ROMFONT)</front>
<front id="dogm_lcd_implementationH-54">  #if ENABLED(DISPLAY_CHARSET_ISO10646_1)</front>
<front id="dogm_lcd_implementationH-55">    #include "dogm_font_data_ISO10646_1.h"</front>
<front id="dogm_lcd_implementationH-56">    #define FONT_MENU_NAME ISO10646_1_5x7</front>
<front id="dogm_lcd_implementationH-57">  #elif ENABLED(DISPLAY_CHARSET_ISO10646_5)</front>
<front id="dogm_lcd_implementationH-58">    #include "dogm_font_data_ISO10646_5_Cyrillic.h"</front>
<front id="dogm_lcd_implementationH-59">    #define FONT_MENU_NAME ISO10646_5_Cyrillic_5x7</front>
<front id="dogm_lcd_implementationH-60">  #elif ENABLED(DISPLAY_CHARSET_ISO10646_KANA)</front>
<front id="dogm_lcd_implementationH-61">    #include "dogm_font_data_ISO10646_Kana.h"</front>
<front id="dogm_lcd_implementationH-62">    #define FONT_MENU_NAME ISO10646_Kana_5x7</front>
<front id="dogm_lcd_implementationH-63">  #elif ENABLED(DISPLAY_CHARSET_ISO10646_CN)</front>
<front id="dogm_lcd_implementationH-64">    #include "dogm_font_data_ISO10646_CN.h"</front>
<front id="dogm_lcd_implementationH-65">    #define FONT_MENU_NAME ISO10646_CN</front>
<front id="dogm_lcd_implementationH-66">    #define TALL_FONT_CORRECTION 1</front>
<front id="dogm_lcd_implementationH-67">  #else // fall-back</front>
<front id="dogm_lcd_implementationH-68">    #include "dogm_font_data_ISO10646_1.h"</front>
<front id="dogm_lcd_implementationH-69">    #define FONT_MENU_NAME ISO10646_1_5x7</front>
<front id="dogm_lcd_implementationH-70">  #endif</front>
<front id="dogm_lcd_implementationH-71">#else // SIMULATE_ROMFONT</front>
<front id="dogm_lcd_implementationH-72">  #if ENABLED(DISPLAY_CHARSET_HD44780_JAPAN)</front>
<front id="dogm_lcd_implementationH-73">    #include "dogm_font_data_HD44780_J.h"</front>
<front id="dogm_lcd_implementationH-74">    #define FONT_MENU_NAME HD44780_J_5x7</front>
<front id="dogm_lcd_implementationH-75">  #elif ENABLED(DISPLAY_CHARSET_HD44780_WESTERN)</front>
<front id="dogm_lcd_implementationH-76">    #include "dogm_font_data_HD44780_W.h"</front>
<front id="dogm_lcd_implementationH-77">    #define FONT_MENU_NAME HD44780_W_5x7</front>
<front id="dogm_lcd_implementationH-78">  #elif ENABLED(DISPLAY_CHARSET_HD44780_CYRILLIC)</front>
<front id="dogm_lcd_implementationH-79">    #include "dogm_font_data_HD44780_C.h"</front>
<front id="dogm_lcd_implementationH-80">    #define FONT_MENU_NAME HD44780_C_5x7</front>
<front id="dogm_lcd_implementationH-81">  #else // fall-back</front>
<front id="dogm_lcd_implementationH-82">    #include "dogm_font_data_ISO10646_1.h"</front>
<front id="dogm_lcd_implementationH-83">    #define FONT_MENU_NAME ISO10646_1_5x7</front>
<front id="dogm_lcd_implementationH-84">  #endif</front>
<front id="dogm_lcd_implementationH-85">#endif // SIMULATE_ROMFONT</front>
<front id="dogm_lcd_implementationH-86"></front>
<front id="dogm_lcd_implementationH-87">//#define FONT_STATUSMENU_NAME FONT_MENU_NAME</front>
<front id="dogm_lcd_implementationH-88"></front>
<front id="dogm_lcd_implementationH-89">#define FONT_STATUSMENU 1</front>
<front id="dogm_lcd_implementationH-90">#define FONT_SPECIAL 2</front>
<front id="dogm_lcd_implementationH-91">#define FONT_MENU_EDIT 3</front>
<front id="dogm_lcd_implementationH-92">#define FONT_MENU 4</front>
<front id="dogm_lcd_implementationH-93"></front>
<front id="dogm_lcd_implementationH-94">// DOGM parameters (size in pixels)</front>
<front id="dogm_lcd_implementationH-95">#define DOG_CHAR_WIDTH         6</front>
<front id="dogm_lcd_implementationH-96">#define DOG_CHAR_HEIGHT        12</front>
<front id="dogm_lcd_implementationH-97">#if ENABLED(USE_BIG_EDIT_FONT)</front>
<front id="dogm_lcd_implementationH-98">  #define FONT_MENU_EDIT_NAME u8g_font_9x18</front>
<front id="dogm_lcd_implementationH-99">  #define DOG_CHAR_WIDTH_EDIT  9</front>
<front id="dogm_lcd_implementationH-100">  #define DOG_CHAR_HEIGHT_EDIT 18</front>
<front id="dogm_lcd_implementationH-101">  #define LCD_WIDTH_EDIT       14</front>
<front id="dogm_lcd_implementationH-102">#else</front>
<front id="dogm_lcd_implementationH-103">  #define FONT_MENU_EDIT_NAME FONT_MENU_NAME</front>
<front id="dogm_lcd_implementationH-104">  #define DOG_CHAR_WIDTH_EDIT  6</front>
<front id="dogm_lcd_implementationH-105">  #define DOG_CHAR_HEIGHT_EDIT 12</front>
<front id="dogm_lcd_implementationH-106">  #define LCD_WIDTH_EDIT       22</front>
<front id="dogm_lcd_implementationH-107">#endif</front>
<front id="dogm_lcd_implementationH-108"></front>
<front id="dogm_lcd_implementationH-109">#ifndef TALL_FONT_CORRECTION</front>
<front id="dogm_lcd_implementationH-110">  #define TALL_FONT_CORRECTION 0</front>
<front id="dogm_lcd_implementationH-111">#endif</front>
<front id="dogm_lcd_implementationH-112"></front>
<front id="dogm_lcd_implementationH-113">#define START_ROW              0</front>
<front id="dogm_lcd_implementationH-114"></front>
<front id="dogm_lcd_implementationH-115">// LCD selection</front>
<front id="dogm_lcd_implementationH-116">#if ENABLED(U8GLIB_ST7920)</front>
<front id="dogm_lcd_implementationH-117">  //U8GLIB_ST7920_128X64_RRD u8g(0,0,0);</front>
<front id="dogm_lcd_implementationH-118">  U8GLIB_ST7920_128X64_RRD u8g(0);</front>
<front id="dogm_lcd_implementationH-119">#elif ENABLED(MAKRPANEL)</front>
<front id="dogm_lcd_implementationH-120">  // The MaKrPanel display, ST7565 controller as well</front>
<front id="dogm_lcd_implementationH-121">  U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);</front>
<front id="dogm_lcd_implementationH-122">#elif ENABLED(VIKI2) || ENABLED(miniVIKI)</front>
<front id="dogm_lcd_implementationH-123">  // Mini Viki and Viki 2.0 LCD, ST7565 controller as well</front>
<front id="dogm_lcd_implementationH-124">  U8GLIB_NHD_C12864 u8g(DOGLCD_CS, DOGLCD_A0);</front>
<front id="dogm_lcd_implementationH-125">#elif ENABLED(U8GLIB_LM6059_AF)</front>
<front id="dogm_lcd_implementationH-126">  // Based on the Adafruit ST7565 (http://www.adafruit.com/products/250)</front>
<front id="dogm_lcd_implementationH-127">  U8GLIB_LM6059 u8g(DOGLCD_CS, DOGLCD_A0);</front>
<front id="dogm_lcd_implementationH-128">#elif ENABLED(U8GLIB_SSD1306)</front>
<front id="dogm_lcd_implementationH-129">  // Generic support for SSD1306 OLED I2C LCDs</front>
<front id="dogm_lcd_implementationH-130">  U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_NONE);</front>
<front id="dogm_lcd_implementationH-131">#elif ENABLED(MINIPANEL)</front>
<front id="dogm_lcd_implementationH-132">  // The MINIPanel display</front>
<front id="dogm_lcd_implementationH-133">  U8GLIB_MINI12864 u8g(DOGLCD_CS, DOGLCD_A0);</front>
<front id="dogm_lcd_implementationH-134">#else</front>
<front id="dogm_lcd_implementationH-135">  // for regular DOGM128 display with HW-SPI</front>
<front id="dogm_lcd_implementationH-136">  U8GLIB_DOGM128 u8g(DOGLCD_CS, DOGLCD_A0);  // HW-SPI Com: CS, A0</front>
<front id="dogm_lcd_implementationH-137">#endif</front>
<front id="dogm_lcd_implementationH-138"></front>
<front id="dogm_lcd_implementationH-139">#ifndef LCD_PIXEL_WIDTH</front>
<front id="dogm_lcd_implementationH-140">  #define LCD_PIXEL_WIDTH 128</front>
<front id="dogm_lcd_implementationH-141">#endif</front>
<front id="dogm_lcd_implementationH-142">#ifndef LCD_PIXEL_HEIGHT</front>
<front id="dogm_lcd_implementationH-143">  #define LCD_PIXEL_HEIGHT 64</front>
<front id="dogm_lcd_implementationH-144">#endif</front>
<front id="dogm_lcd_implementationH-145"></front>
<front id="dogm_lcd_implementationH-146">#include "utf_mapper.h"</front>
<front id="dogm_lcd_implementationH-147"></front>
<front id="dogm_lcd_implementationH-148">int lcd_contrast;</front>
<front id="dogm_lcd_implementationH-149">static unsigned char blink = 0; // Variable for visualization of fan rotation in GLCD</front>
<front id="dogm_lcd_implementationH-150">static char currentfont = 0;</front>
<front id="dogm_lcd_implementationH-151"></front>
<front id="dogm_lcd_implementationH-152">static void lcd_setFont(char font_nr) {</front>
<front id="dogm_lcd_implementationH-153">  switch(font_nr) {</front>
<front id="dogm_lcd_implementationH-154">    case FONT_STATUSMENU : {u8g.setFont(FONT_STATUSMENU_NAME); currentfont = FONT_STATUSMENU;}; break;</front>
<front id="dogm_lcd_implementationH-155">    case FONT_MENU       : {u8g.setFont(FONT_MENU_NAME); currentfont = FONT_MENU;}; break;</front>
<front id="dogm_lcd_implementationH-156">    case FONT_SPECIAL    : {u8g.setFont(FONT_SPECIAL_NAME); currentfont = FONT_SPECIAL;}; break;</front>
<front id="dogm_lcd_implementationH-157">    case FONT_MENU_EDIT  : {u8g.setFont(FONT_MENU_EDIT_NAME); currentfont = FONT_MENU_EDIT;}; break;</front>
<front id="dogm_lcd_implementationH-158">    break;</front>
<front id="dogm_lcd_implementationH-159">  }</front>
<front id="dogm_lcd_implementationH-160">}</front>
<front id="dogm_lcd_implementationH-161"></front>
<front id="dogm_lcd_implementationH-162">char lcd_print(char c) {</front>
<front id="dogm_lcd_implementationH-163">  if ((c &gt; 0) && (c &lt;= LCD_STR_SPECIAL_MAX)) {</front>
<front id="dogm_lcd_implementationH-164">    u8g.setFont(FONT_SPECIAL_NAME);</front>
<front id="dogm_lcd_implementationH-165">    u8g.print(c);</front>
<front id="dogm_lcd_implementationH-166">    lcd_setFont(currentfont);</front>
<front id="dogm_lcd_implementationH-167">    return 1;</front>
<front id="dogm_lcd_implementationH-168">  } else {</front>
<front id="dogm_lcd_implementationH-169">    return charset_mapper(c);</front>
<front id="dogm_lcd_implementationH-170">  }</front>
<front id="dogm_lcd_implementationH-171">}</front>
<front id="dogm_lcd_implementationH-172"></front>
<front id="dogm_lcd_implementationH-173">char lcd_print(char* str) {</front>
<front id="dogm_lcd_implementationH-174">  char c;</front>
<front id="dogm_lcd_implementationH-175">  int i = 0;</front>
<front id="dogm_lcd_implementationH-176">  char n = 0;</front>
<front id="dogm_lcd_implementationH-177">  while ((c = str[i++])) {</front>
<front id="dogm_lcd_implementationH-178">    n += lcd_print(c);</front>
<front id="dogm_lcd_implementationH-179">  }</front>
<front id="dogm_lcd_implementationH-180">  return n;</front>
<front id="dogm_lcd_implementationH-181">}</front>
<front id="dogm_lcd_implementationH-182"></front>
<front id="dogm_lcd_implementationH-183">/* Arduino &lt; 1.0.0 is missing a function to print PROGMEM strings, so we need to implement our own */</front>
<front id="dogm_lcd_implementationH-184">char lcd_printPGM(const char* str) {</front>
<front id="dogm_lcd_implementationH-185">  char c;</front>
<front id="dogm_lcd_implementationH-186">  char n = 0;</front>
<front id="dogm_lcd_implementationH-187">  while ((c = pgm_read_byte(str++))) {</front>
<front id="dogm_lcd_implementationH-188">    n += lcd_print(c);</front>
<front id="dogm_lcd_implementationH-189">  }</front>
<front id="dogm_lcd_implementationH-190">  return n;</front>
<front id="dogm_lcd_implementationH-191">}</front>
<front id="dogm_lcd_implementationH-192"></front>
<front id="dogm_lcd_implementationH-193">#if ENABLED(SHOW_BOOTSCREEN)</front>
<front id="dogm_lcd_implementationH-194">  static bool show_bootscreen = true;</front>
<front id="dogm_lcd_implementationH-195">#endif</front>
<front id="dogm_lcd_implementationH-196"></front>
<front id="dogm_lcd_implementationH-197">/* Warning: This function is called from interrupt context */</front>
<front id="dogm_lcd_implementationH-198">static void lcd_implementation_init() {</front>
<front id="dogm_lcd_implementationH-199"></front>
<front id="dogm_lcd_implementationH-200">  #if ENABLED(LCD_PIN_BL) // Enable LCD backlight</front>
<front id="dogm_lcd_implementationH-201">    pinMode(LCD_PIN_BL, OUTPUT);</front>
<front id="dogm_lcd_implementationH-202">    digitalWrite(LCD_PIN_BL, HIGH);</front>
<front id="dogm_lcd_implementationH-203">  #endif</front>
<front id="dogm_lcd_implementationH-204"></front>
<front id="dogm_lcd_implementationH-205">  #if ENABLED(LCD_PIN_RESET)</front>
<front id="dogm_lcd_implementationH-206">    pinMode(LCD_PIN_RESET, OUTPUT);           </front>
<front id="dogm_lcd_implementationH-207">    digitalWrite(LCD_PIN_RESET, HIGH);</front>
<front id="dogm_lcd_implementationH-208">  #endif</front>
<front id="dogm_lcd_implementationH-209">  #if DISABLED(MINIPANEL) // setContrast not working for Mini Panel</front>
<front id="dogm_lcd_implementationH-210">    u8g.setContrast(lcd_contrast);	</front>
<front id="dogm_lcd_implementationH-211">  #endif</front>
<front id="dogm_lcd_implementationH-212">  // FIXME: remove this workaround</front>
<front id="dogm_lcd_implementationH-213">  // Uncomment this if you have the first generation (V1.10) of STBs board</front>
<front id="dogm_lcd_implementationH-214">  // pinMode(17, OUTPUT); // Enable LCD backlight</front>
<front id="dogm_lcd_implementationH-215">  // digitalWrite(17, HIGH);</front>
<front id="dogm_lcd_implementationH-216"></front>
<front id="dogm_lcd_implementationH-217">  #if ENABLED(LCD_SCREEN_ROT_90)</front>
<front id="dogm_lcd_implementationH-218">    u8g.setRot90();   // Rotate screen by 90</front>
<front id="dogm_lcd_implementationH-219">  #elif ENABLED(LCD_SCREEN_ROT_180)</front>
<front id="dogm_lcd_implementationH-220">    u8g.setRot180();  // Rotate screen by 180</front>
<front id="dogm_lcd_implementationH-221">  #elif ENABLED(LCD_SCREEN_ROT_270)</front>
<front id="dogm_lcd_implementationH-222">    u8g.setRot270();  // Rotate screen by 270</front>
<front id="dogm_lcd_implementationH-223">  #endif</front>
<front id="dogm_lcd_implementationH-224"></front>
<front id="dogm_lcd_implementationH-225">  #if ENABLED(SHOW_BOOTSCREEN)</front>
<front id="dogm_lcd_implementationH-226">    int offx = (u8g.getWidth() - START_BMPWIDTH) / 2;</front>
<front id="dogm_lcd_implementationH-227">    #if ENABLED(START_BMPHIGH)</front>
<front id="dogm_lcd_implementationH-228">      int offy = 0;</front>
<front id="dogm_lcd_implementationH-229">    #else</front>
<front id="dogm_lcd_implementationH-230">      int offy = DOG_CHAR_HEIGHT;</front>
<front id="dogm_lcd_implementationH-231">    #endif</front>
<front id="dogm_lcd_implementationH-232"></front>
<front id="dogm_lcd_implementationH-233">    int txt1X = (u8g.getWidth() - (sizeof(STRING_SPLASH_LINE1) - 1)*DOG_CHAR_WIDTH) / 2;</front>
<front id="dogm_lcd_implementationH-234"></front>
<front id="dogm_lcd_implementationH-235">    u8g.firstPage();</front>
<front id="dogm_lcd_implementationH-236">    do {</front>
<front id="dogm_lcd_implementationH-237">      if (show_bootscreen) {</front>
<front id="dogm_lcd_implementationH-238">        u8g.drawBitmapP(offx, offy, START_BMPBYTEWIDTH, START_BMPHEIGHT, start_bmp);</front>
<front id="dogm_lcd_implementationH-239">        lcd_setFont(FONT_MENU);</front>
<front id="dogm_lcd_implementationH-240">        #ifndef STRING_SPLASH_LINE2</front>
<front id="dogm_lcd_implementationH-241">          u8g.drawStr(txt1X, u8g.getHeight() - DOG_CHAR_HEIGHT, STRING_SPLASH_LINE1);</front>
<front id="dogm_lcd_implementationH-242">        #else</front>
<front id="dogm_lcd_implementationH-243">          int txt2X = (u8g.getWidth() - (sizeof(STRING_SPLASH_LINE2) - 1)*DOG_CHAR_WIDTH) / 2;</front>
<front id="dogm_lcd_implementationH-244">          u8g.drawStr(txt1X, u8g.getHeight() - DOG_CHAR_HEIGHT*3/2, STRING_SPLASH_LINE1);</front>
<front id="dogm_lcd_implementationH-245">          u8g.drawStr(txt2X, u8g.getHeight() - DOG_CHAR_HEIGHT*1/2, STRING_SPLASH_LINE2);</front>
<front id="dogm_lcd_implementationH-246">        #endif</front>
<front id="dogm_lcd_implementationH-247">      }</front>
<front id="dogm_lcd_implementationH-248">    } while (u8g.nextPage());</front>
<front id="dogm_lcd_implementationH-249"></front>
<front id="dogm_lcd_implementationH-250">    if (show_bootscreen) {</front>
<front id="dogm_lcd_implementationH-251">      delay(1000);</front>
<front id="dogm_lcd_implementationH-252">      show_bootscreen = false;</front>
<front id="dogm_lcd_implementationH-253">    }</front>
<front id="dogm_lcd_implementationH-254">  #endif</front>
<front id="dogm_lcd_implementationH-255">}</front>
<front id="dogm_lcd_implementationH-256"></front>
<front id="dogm_lcd_implementationH-257">static void lcd_implementation_clear() { } // Automatically cleared by Picture Loop</front>
<front id="dogm_lcd_implementationH-258"></front>
<front id="dogm_lcd_implementationH-259">static void _draw_heater_status(int x, int heater) {</front>
<front id="dogm_lcd_implementationH-260">  bool isBed = heater &lt; 0;</front>
<front id="dogm_lcd_implementationH-261">  int y = 17 + (isBed ? 1 : 0);</front>
<front id="dogm_lcd_implementationH-262"></front>
<front id="dogm_lcd_implementationH-263">  lcd_setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-264">  u8g.setPrintPos(x,7);</front>
<front id="dogm_lcd_implementationH-265">  lcd_print(itostr3(int((heater &gt;= 0 ? degTargetHotend(heater) : degTargetBed()) + 0.5)));</front>
<front id="dogm_lcd_implementationH-266">  lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-267">  u8g.setPrintPos(x,28);</front>
<front id="dogm_lcd_implementationH-268">  lcd_print(itostr3(int(heater &gt;= 0 ? degHotend(heater) : degBed()) + 0.5));</front>
<front id="dogm_lcd_implementationH-269"></front>
<front id="dogm_lcd_implementationH-270">  lcd_printPGM(PSTR(LCD_STR_DEGREE " "));</front>
<front id="dogm_lcd_implementationH-271">  if (!isHeatingHotend(0)) {</front>
<front id="dogm_lcd_implementationH-272">    u8g.drawBox(x+7,y,2,2);</front>
<front id="dogm_lcd_implementationH-273">  }</front>
<front id="dogm_lcd_implementationH-274">  else {</front>
<front id="dogm_lcd_implementationH-275">    u8g.setColorIndex(0); // white on black</front>
<front id="dogm_lcd_implementationH-276">    u8g.drawBox(x+7,y,2,2);</front>
<front id="dogm_lcd_implementationH-277">    u8g.setColorIndex(1); // black on white</front>
<front id="dogm_lcd_implementationH-278">  }</front>
<front id="dogm_lcd_implementationH-279">}</front>
<front id="dogm_lcd_implementationH-280"></front>
<front id="dogm_lcd_implementationH-281">static void lcd_implementation_status_screen() {</front>
<front id="dogm_lcd_implementationH-282">  u8g.setColorIndex(1); // black on white</front>
<front id="dogm_lcd_implementationH-283"></front>
<front id="dogm_lcd_implementationH-284">  // Symbols menu graphics, animated fan</front>
<front id="dogm_lcd_implementationH-285">  u8g.drawBitmapP(9,1,STATUS_SCREENBYTEWIDTH,STATUS_SCREENHEIGHT, (blink % 2) && fanSpeed ? status_screen0_bmp : status_screen1_bmp);</front>
<front id="dogm_lcd_implementationH-286"> </front>
<front id="dogm_lcd_implementationH-287">  #if ENABLED(SDSUPPORT)</front>
<front id="dogm_lcd_implementationH-288">    // SD Card Symbol</front>
<front id="dogm_lcd_implementationH-289">    u8g.drawBox(42, 42 - TALL_FONT_CORRECTION, 8, 7);</front>
<front id="dogm_lcd_implementationH-290">    u8g.drawBox(50, 44 - TALL_FONT_CORRECTION, 2, 5);</front>
<front id="dogm_lcd_implementationH-291">    u8g.drawFrame(42, 49 - TALL_FONT_CORRECTION, 10, 4);</front>
<front id="dogm_lcd_implementationH-292">    u8g.drawPixel(50, 43 - TALL_FONT_CORRECTION);</front>
<front id="dogm_lcd_implementationH-293"></front>
<front id="dogm_lcd_implementationH-294">    // Progress bar frame</front>
<front id="dogm_lcd_implementationH-295">    u8g.drawFrame(54, 49, 73, 4 - TALL_FONT_CORRECTION);</front>
<front id="dogm_lcd_implementationH-296"></front>
<front id="dogm_lcd_implementationH-297">    // SD Card Progress bar and clock</front>
<front id="dogm_lcd_implementationH-298">    lcd_setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-299"> </front>
<front id="dogm_lcd_implementationH-300">    if (IS_SD_PRINTING) {</front>
<front id="dogm_lcd_implementationH-301">      // Progress bar solid part</front>
<front id="dogm_lcd_implementationH-302">      u8g.drawBox(55, 50, (unsigned int)(71.f * card.percentDone() / 100.f), 2 - TALL_FONT_CORRECTION);</front>
<front id="dogm_lcd_implementationH-303">    }</front>
<front id="dogm_lcd_implementationH-304"></front>
<front id="dogm_lcd_implementationH-305">    u8g.setPrintPos(80,48);</front>
<front id="dogm_lcd_implementationH-306">    if (print_job_start_ms != 0) {</front>
<front id="dogm_lcd_implementationH-307">      uint16_t time = (millis() - print_job_start_ms) / 60000;</front>
<front id="dogm_lcd_implementationH-308">      lcd_print(itostr2(time/60));</front>
<front id="dogm_lcd_implementationH-309">      lcd_print(':');</front>
<front id="dogm_lcd_implementationH-310">      lcd_print(itostr2(time%60));</front>
<front id="dogm_lcd_implementationH-311">    }</front>
<front id="dogm_lcd_implementationH-312">    else {</front>
<front id="dogm_lcd_implementationH-313">      lcd_printPGM(PSTR("--:--"));</front>
<front id="dogm_lcd_implementationH-314">    }</front>
<front id="dogm_lcd_implementationH-315">  #endif</front>
<front id="dogm_lcd_implementationH-316"></front>
<front id="dogm_lcd_implementationH-317">  // Extruders</front>
<front id="dogm_lcd_implementationH-318">  for (int i=0; i&lt;EXTRUDERS; i++) _draw_heater_status(6 + i * 25, i);</front>
<front id="dogm_lcd_implementationH-319"></front>
<front id="dogm_lcd_implementationH-320">  // Heatbed</front>
<front id="dogm_lcd_implementationH-321">  if (EXTRUDERS &lt; 4) _draw_heater_status(81, -1);</front>
<front id="dogm_lcd_implementationH-322"></front>
<front id="dogm_lcd_implementationH-323">  // Fan</front>
<front id="dogm_lcd_implementationH-324">  lcd_setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-325">  u8g.setPrintPos(104,27);</front>
<front id="dogm_lcd_implementationH-326">  #if HAS_FAN</front>
<front id="dogm_lcd_implementationH-327">    int per = ((fanSpeed + 1) * 100) / 256;</front>
<front id="dogm_lcd_implementationH-328">    if (per) {</front>
<front id="dogm_lcd_implementationH-329">      lcd_print(itostr3(per));</front>
<front id="dogm_lcd_implementationH-330">      lcd_print('%');</front>
<front id="dogm_lcd_implementationH-331">    }</front>
<front id="dogm_lcd_implementationH-332">    else</front>
<front id="dogm_lcd_implementationH-333">  #endif</front>
<front id="dogm_lcd_implementationH-334">    {</front>
<front id="dogm_lcd_implementationH-335">      lcd_printPGM(PSTR("---"));</front>
<front id="dogm_lcd_implementationH-336">    }</front>
<front id="dogm_lcd_implementationH-337"></front>
<front id="dogm_lcd_implementationH-338">  // X, Y, Z-Coordinates</front>
<front id="dogm_lcd_implementationH-339">  #define XYZ_BASELINE 38</front>
<front id="dogm_lcd_implementationH-340">  lcd_setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-341"></front>
<front id="dogm_lcd_implementationH-342">  #if ENABLED(USE_SMALL_INFOFONT)</front>
<front id="dogm_lcd_implementationH-343">    u8g.drawBox(0,30,LCD_PIXEL_WIDTH,10);</front>
<front id="dogm_lcd_implementationH-344">  #else</front>
<front id="dogm_lcd_implementationH-345">    u8g.drawBox(0,30,LCD_PIXEL_WIDTH,9);</front>
<front id="dogm_lcd_implementationH-346">  #endif</front>
<front id="dogm_lcd_implementationH-347">  u8g.setColorIndex(0); // white on black</front>
<front id="dogm_lcd_implementationH-348">  u8g.setPrintPos(2,XYZ_BASELINE);</front>
<front id="dogm_lcd_implementationH-349">  lcd_print('X');</front>
<front id="dogm_lcd_implementationH-350">  u8g.drawPixel(8,XYZ_BASELINE - 5);</front>
<front id="dogm_lcd_implementationH-351">  u8g.drawPixel(8,XYZ_BASELINE - 3);</front>
<front id="dogm_lcd_implementationH-352">  u8g.setPrintPos(10,XYZ_BASELINE);</front>
<front id="dogm_lcd_implementationH-353">  if (axis_known_position[X_AXIS])</front>
<front id="dogm_lcd_implementationH-354">    lcd_print(ftostr31ns(current_position[X_AXIS]));</front>
<front id="dogm_lcd_implementationH-355">  else</front>
<front id="dogm_lcd_implementationH-356">    lcd_printPGM(PSTR("---"));</front>
<front id="dogm_lcd_implementationH-357">  u8g.setPrintPos(43,XYZ_BASELINE);</front>
<front id="dogm_lcd_implementationH-358">  lcd_print('Y');</front>
<front id="dogm_lcd_implementationH-359">  u8g.drawPixel(49,XYZ_BASELINE - 5);</front>
<front id="dogm_lcd_implementationH-360">  u8g.drawPixel(49,XYZ_BASELINE - 3);</front>
<front id="dogm_lcd_implementationH-361">  u8g.setPrintPos(51,XYZ_BASELINE);</front>
<front id="dogm_lcd_implementationH-362">  if (axis_known_position[Y_AXIS])</front>
<front id="dogm_lcd_implementationH-363">    lcd_print(ftostr31ns(current_position[Y_AXIS]));</front>
<front id="dogm_lcd_implementationH-364">  else</front>
<front id="dogm_lcd_implementationH-365">    lcd_printPGM(PSTR("---"));</front>
<front id="dogm_lcd_implementationH-366">  u8g.setPrintPos(83,XYZ_BASELINE);</front>
<front id="dogm_lcd_implementationH-367">  lcd_print('Z');</front>
<front id="dogm_lcd_implementationH-368">  u8g.drawPixel(89,XYZ_BASELINE - 5);</front>
<front id="dogm_lcd_implementationH-369">  u8g.drawPixel(89,XYZ_BASELINE - 3);</front>
<front id="dogm_lcd_implementationH-370">  u8g.setPrintPos(91,XYZ_BASELINE);</front>
<front id="dogm_lcd_implementationH-371">  if (axis_known_position[Z_AXIS])</front>
<front id="dogm_lcd_implementationH-372">    lcd_print(ftostr32sp(current_position[Z_AXIS]));</front>
<front id="dogm_lcd_implementationH-373">  else</front>
<front id="dogm_lcd_implementationH-374">    lcd_printPGM(PSTR("---.--"));</front>
<front id="dogm_lcd_implementationH-375">  u8g.setColorIndex(1); // black on white</front>
<front id="dogm_lcd_implementationH-376"> </front>
<front id="dogm_lcd_implementationH-377">  // Feedrate</front>
<front id="dogm_lcd_implementationH-378">  lcd_setFont(FONT_MENU);</front>
<front id="dogm_lcd_implementationH-379">  u8g.setPrintPos(3,49);</front>
<front id="dogm_lcd_implementationH-380">  lcd_print(LCD_STR_FEEDRATE[0]);</front>
<front id="dogm_lcd_implementationH-381">  lcd_setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-382">  u8g.setPrintPos(12,49);</front>
<front id="dogm_lcd_implementationH-383">  lcd_print(itostr3(feedrate_multiplier));</front>
<front id="dogm_lcd_implementationH-384">  lcd_print('%');</front>
<front id="dogm_lcd_implementationH-385"></front>
<front id="dogm_lcd_implementationH-386">  // Status line</front>
<front id="dogm_lcd_implementationH-387">  lcd_setFont(FONT_STATUSMENU);</front>
<front id="dogm_lcd_implementationH-388">  #if ENABLED(USE_SMALL_INFOFONT)</front>
<front id="dogm_lcd_implementationH-389">    u8g.setPrintPos(0,62);</front>
<front id="dogm_lcd_implementationH-390">  #else</front>
<front id="dogm_lcd_implementationH-391">    u8g.setPrintPos(0,63);</front>
<front id="dogm_lcd_implementationH-392">  #endif</front>
<front id="dogm_lcd_implementationH-393">  #if DISABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="dogm_lcd_implementationH-394">    lcd_print(lcd_status_message);</front>
<front id="dogm_lcd_implementationH-395">  #else</front>
<front id="dogm_lcd_implementationH-396">    if (millis() &lt; previous_lcd_status_ms + 5000) {  //Display both Status message line and Filament display on the last line</front>
<front id="dogm_lcd_implementationH-397">      lcd_print(lcd_status_message);</front>
<front id="dogm_lcd_implementationH-398">    }</front>
<front id="dogm_lcd_implementationH-399">    else {</front>
<front id="dogm_lcd_implementationH-400">      lcd_printPGM(PSTR("dia:"));</front>
<front id="dogm_lcd_implementationH-401">      lcd_print(ftostr12ns(filament_width_meas));</front>
<front id="dogm_lcd_implementationH-402">      lcd_printPGM(PSTR(" factor:"));</front>
<front id="dogm_lcd_implementationH-403">      lcd_print(itostr3(100.0 * volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]));</front>
<front id="dogm_lcd_implementationH-404">      lcd_print('%');</front>
<front id="dogm_lcd_implementationH-405">    }</front>
<front id="dogm_lcd_implementationH-406">  #endif</front>
<front id="dogm_lcd_implementationH-407">}</front>
<front id="dogm_lcd_implementationH-408"></front>
<front id="dogm_lcd_implementationH-409">static void lcd_implementation_mark_as_selected(uint8_t row, bool isSelected) {</front>
<front id="dogm_lcd_implementationH-410">  if (isSelected) {</front>
<front id="dogm_lcd_implementationH-411">    u8g.setColorIndex(1);  // black on white</front>
<front id="dogm_lcd_implementationH-412">    u8g.drawBox(0, row * DOG_CHAR_HEIGHT + 3 - TALL_FONT_CORRECTION, LCD_PIXEL_WIDTH, DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-413">    u8g.setColorIndex(0);  // following text must be white on black</front>
<front id="dogm_lcd_implementationH-414">  }</front>
<front id="dogm_lcd_implementationH-415">  else {</front>
<front id="dogm_lcd_implementationH-416">    u8g.setColorIndex(1); // unmarked text is black on white</front>
<front id="dogm_lcd_implementationH-417">  }</front>
<front id="dogm_lcd_implementationH-418">  u8g.setPrintPos(START_ROW * DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-419">}</front>
<front id="dogm_lcd_implementationH-420"></front>
<front id="dogm_lcd_implementationH-421">static void lcd_implementation_drawmenu_generic(bool isSelected, uint8_t row, const char* pstr, char pre_char, char post_char) {</front>
<front id="dogm_lcd_implementationH-422">  char c;</front>
<front id="dogm_lcd_implementationH-423">  uint8_t n = LCD_WIDTH - 2;</front>
<front id="dogm_lcd_implementationH-424"></front>
<front id="dogm_lcd_implementationH-425">  lcd_implementation_mark_as_selected(row, isSelected);</front>
<front id="dogm_lcd_implementationH-426"></front>
<front id="dogm_lcd_implementationH-427">  while (c = pgm_read_byte(pstr)) {</front>
<front id="dogm_lcd_implementationH-428">    n -= lcd_print(c);</front>
<front id="dogm_lcd_implementationH-429">    pstr++;</front>
<front id="dogm_lcd_implementationH-430">  }</front>
<front id="dogm_lcd_implementationH-431">  while (n--) lcd_print(' ');</front>
<front id="dogm_lcd_implementationH-432">    u8g.setPrintPos(LCD_PIXEL_WIDTH - DOG_CHAR_WIDTH, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-433">  lcd_print(post_char);</front>
<front id="dogm_lcd_implementationH-434">  lcd_print(' ');</front>
<front id="dogm_lcd_implementationH-435">}</front>
<front id="dogm_lcd_implementationH-436"></front>
<front id="dogm_lcd_implementationH-437">static void _drawmenu_setting_edit_generic(bool isSelected, uint8_t row, const char* pstr, const char* data, bool pgm) {</front>
<front id="dogm_lcd_implementationH-438">  char c;</front>
<front id="dogm_lcd_implementationH-439">  uint8_t vallen = (pgm ? lcd_strlen_P(data) : (lcd_strlen((char*)data)));</front>
<front id="dogm_lcd_implementationH-440">  uint8_t n = LCD_WIDTH - 2 - vallen;</front>
<front id="dogm_lcd_implementationH-441"></front>
<front id="dogm_lcd_implementationH-442">  lcd_implementation_mark_as_selected(row, isSelected);</front>
<front id="dogm_lcd_implementationH-443"></front>
<front id="dogm_lcd_implementationH-444">  while (c = pgm_read_byte(pstr)) {</front>
<front id="dogm_lcd_implementationH-445">    n -= lcd_print(c);</front>
<front id="dogm_lcd_implementationH-446">    pstr++;</front>
<front id="dogm_lcd_implementationH-447">  }</front>
<front id="dogm_lcd_implementationH-448">  lcd_print(':');</front>
<front id="dogm_lcd_implementationH-449">  while (n--) lcd_print(' ');</front>
<front id="dogm_lcd_implementationH-450">  u8g.setPrintPos(LCD_PIXEL_WIDTH - DOG_CHAR_WIDTH * vallen, (row + 1) * DOG_CHAR_HEIGHT);</front>
<front id="dogm_lcd_implementationH-451">  if (pgm) { lcd_printPGM(data); } else { lcd_print((char *)data); }</front>
<front id="dogm_lcd_implementationH-452">}</front>
<front id="dogm_lcd_implementationH-453"></front>
<front id="dogm_lcd_implementationH-454">#define lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, data) _drawmenu_setting_edit_generic(sel, row, pstr, data, false)</front>
<front id="dogm_lcd_implementationH-455">#define lcd_implementation_drawmenu_setting_edit_generic_P(sel, row, pstr, data) _drawmenu_setting_edit_generic(sel, row, pstr, data, true)</front>
<front id="dogm_lcd_implementationH-456"></front>
<front id="dogm_lcd_implementationH-457">#define lcd_implementation_drawmenu_setting_edit_int3(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, itostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-458">#define lcd_implementation_drawmenu_setting_edit_float3(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-459">#define lcd_implementation_drawmenu_setting_edit_float32(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr32(*(data)))</front>
<front id="dogm_lcd_implementationH-460">#define lcd_implementation_drawmenu_setting_edit_float43(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr43(*(data)))</front>
<front id="dogm_lcd_implementationH-461">#define lcd_implementation_drawmenu_setting_edit_float5(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-462">#define lcd_implementation_drawmenu_setting_edit_float52(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr52(*(data)))</front>
<front id="dogm_lcd_implementationH-463">#define lcd_implementation_drawmenu_setting_edit_float51(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr51(*(data)))</front>
<front id="dogm_lcd_implementationH-464">#define lcd_implementation_drawmenu_setting_edit_long5(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-465">#define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(sel, row, pstr, (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="dogm_lcd_implementationH-466"></front>
<front id="dogm_lcd_implementationH-467">//Add version for callback functions</front>
<front id="dogm_lcd_implementationH-468">#define lcd_implementation_drawmenu_setting_edit_callback_int3(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, itostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-469">#define lcd_implementation_drawmenu_setting_edit_callback_float3(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr3(*(data)))</front>
<front id="dogm_lcd_implementationH-470">#define lcd_implementation_drawmenu_setting_edit_callback_float32(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr32(*(data)))</front>
<front id="dogm_lcd_implementationH-471">#define lcd_implementation_drawmenu_setting_edit_callback_float43(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr43(*(data)))</front>
<front id="dogm_lcd_implementationH-472">#define lcd_implementation_drawmenu_setting_edit_callback_float5(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-473">#define lcd_implementation_drawmenu_setting_edit_callback_float52(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr52(*(data)))</front>
<front id="dogm_lcd_implementationH-474">#define lcd_implementation_drawmenu_setting_edit_callback_float51(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr51(*(data)))</front>
<front id="dogm_lcd_implementationH-475">#define lcd_implementation_drawmenu_setting_edit_callback_long5(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, ftostr5(*(data)))</front>
<front id="dogm_lcd_implementationH-476">#define lcd_implementation_drawmenu_setting_edit_callback_bool(sel, row, pstr, pstr2, data, callback) lcd_implementation_drawmenu_setting_edit_generic_P(sel, row, pstr, (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="dogm_lcd_implementationH-477"></front>
<front id="dogm_lcd_implementationH-478">void lcd_implementation_drawedit(const char* pstr, char* value) {</front>
<front id="dogm_lcd_implementationH-479">  uint8_t rows = 1;</front>
<front id="dogm_lcd_implementationH-480">  uint8_t lcd_width = LCD_WIDTH, char_width = DOG_CHAR_WIDTH;</front>
<front id="dogm_lcd_implementationH-481">  uint8_t vallen = lcd_strlen(value);</front>
<front id="dogm_lcd_implementationH-482"></front>
<front id="dogm_lcd_implementationH-483">  #if ENABLED(USE_BIG_EDIT_FONT)</front>
<front id="dogm_lcd_implementationH-484">    if (lcd_strlen_P(pstr) &lt;= LCD_WIDTH_EDIT - 1) {</front>
<front id="dogm_lcd_implementationH-485">      lcd_setFont(FONT_MENU_EDIT);</front>
<front id="dogm_lcd_implementationH-486">      lcd_width = LCD_WIDTH_EDIT + 1;</front>
<front id="dogm_lcd_implementationH-487">      char_width = DOG_CHAR_WIDTH_EDIT;</front>
<front id="dogm_lcd_implementationH-488">      if (lcd_strlen_P(pstr) &gt;= LCD_WIDTH_EDIT - vallen) rows = 2;</front>
<front id="dogm_lcd_implementationH-489">    }</front>
<front id="dogm_lcd_implementationH-490">    else {</front>
<front id="dogm_lcd_implementationH-491">      lcd_setFont(FONT_MENU);</front>
<front id="dogm_lcd_implementationH-492">    }</front>
<front id="dogm_lcd_implementationH-493">  #endif</front>
<front id="dogm_lcd_implementationH-494"></front>
<front id="dogm_lcd_implementationH-495">  if (lcd_strlen_P(pstr) &gt; LCD_WIDTH - 2 - vallen) rows = 2;</front>
<front id="dogm_lcd_implementationH-496"></front>
<front id="dogm_lcd_implementationH-497">  const float kHalfChar = DOG_CHAR_HEIGHT_EDIT / 2;</front>
<front id="dogm_lcd_implementationH-498">  float rowHeight = u8g.getHeight() / (rows + 1); // 1/(rows+1) = 1/2 or 1/3</front>
<front id="dogm_lcd_implementationH-499"></front>
<front id="dogm_lcd_implementationH-500">  u8g.setPrintPos(0, rowHeight + kHalfChar);</front>
<front id="dogm_lcd_implementationH-501">  lcd_printPGM(pstr);</front>
<front id="dogm_lcd_implementationH-502">  lcd_print(':');</front>
<front id="dogm_lcd_implementationH-503">  u8g.setPrintPos((lcd_width - 1 - vallen) * char_width, rows * rowHeight + kHalfChar);</front>
<front id="dogm_lcd_implementationH-504">  lcd_print(value);</front>
<front id="dogm_lcd_implementationH-505">}</front>
<front id="dogm_lcd_implementationH-506"></front>
<front id="dogm_lcd_implementationH-507">#if ENABLED(SDSUPPORT)</front>
<front id="dogm_lcd_implementationH-508"></front>
<front id="dogm_lcd_implementationH-509">  static void _drawmenu_sd(bool isSelected, uint8_t row, const char* pstr, const char* filename, char * const longFilename, bool isDir) {</front>
<front id="dogm_lcd_implementationH-510">    char c;</front>
<front id="dogm_lcd_implementationH-511">    uint8_t n = LCD_WIDTH - 1;</front>
<front id="dogm_lcd_implementationH-512"></front>
<front id="dogm_lcd_implementationH-513">    if (longFilename[0]) {</front>
<front id="dogm_lcd_implementationH-514">      filename = longFilename;</front>
<front id="dogm_lcd_implementationH-515">      longFilename[n] = '\0';</front>
<front id="dogm_lcd_implementationH-516">    }</front>
<front id="dogm_lcd_implementationH-517"></front>
<front id="dogm_lcd_implementationH-518">    lcd_implementation_mark_as_selected(row, isSelected);</front>
<front id="dogm_lcd_implementationH-519"></front>
<front id="dogm_lcd_implementationH-520">    if (isDir) lcd_print(LCD_STR_FOLDER[0]);</front>
<front id="dogm_lcd_implementationH-521">    while ((c = *filename)) {</front>
<front id="dogm_lcd_implementationH-522">      n -= lcd_print(c);</front>
<front id="dogm_lcd_implementationH-523">      filename++;</front>
<front id="dogm_lcd_implementationH-524">    }</front>
<front id="dogm_lcd_implementationH-525">    while (n--) lcd_print(' ');</front>
<front id="dogm_lcd_implementationH-526">  }</front>
<front id="dogm_lcd_implementationH-527"></front>
<front id="dogm_lcd_implementationH-528">  #define lcd_implementation_drawmenu_sdfile(sel, row, pstr, filename, longFilename) _drawmenu_sd(sel, row, pstr, filename, longFilename, false)</front>
<front id="dogm_lcd_implementationH-529">  #define lcd_implementation_drawmenu_sddirectory(sel, row, pstr, filename, longFilename) _drawmenu_sd(sel, row, pstr, filename, longFilename, true)</front>
<front id="dogm_lcd_implementationH-530"></front>
<front id="dogm_lcd_implementationH-531">#endif //SDSUPPORT</front>
<front id="dogm_lcd_implementationH-532"></front>
<front id="dogm_lcd_implementationH-533">#define lcd_implementation_drawmenu_back(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])</front>
<front id="dogm_lcd_implementationH-534">#define lcd_implementation_drawmenu_submenu(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '&gt;', LCD_STR_ARROW_RIGHT[0])</front>
<front id="dogm_lcd_implementationH-535">#define lcd_implementation_drawmenu_gcode(sel, row, pstr, gcode) lcd_implementation_drawmenu_generic(sel, row, pstr, '&gt;', ' ')</front>
<front id="dogm_lcd_implementationH-536">#define lcd_implementation_drawmenu_function(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '&gt;', ' ')</front>
<front id="dogm_lcd_implementationH-537"></front>
<front id="dogm_lcd_implementationH-538">#endif //__DOGM_LCD_IMPLEMENTATION_H</front>
 </pre>
<h1 id="fastioHtitle" >fastio.h</h1>
<pre id="fastioH"  class="prettyprint linenums"><front id="fastioH-1">/*</front>
<front id="fastioH-2">  This code contributed by Triffid_Hunter and modified by Kliment</front>
<front id="fastioH-3">  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html</front>
<front id="fastioH-4">*/</front>
<front id="fastioH-5"></front>
<front id="fastioH-6">#ifndef	_FASTIO_ARDUINO_H</front>
<front id="fastioH-7">#define	_FASTIO_ARDUINO_H</front>
<front id="fastioH-8"></front>
<front id="fastioH-9">#include &lt;avr/io.h&gt;</front>
<front id="fastioH-10"></front>
<front id="fastioH-11">/*</front>
<front id="fastioH-12">  utility functions</front>
<front id="fastioH-13">*/</front>
<front id="fastioH-14"></front>
<front id="fastioH-15">#ifndef MASK</front>
<front id="fastioH-16">  #define MASK(PIN)  (1 &lt;&lt; PIN)</front>
<front id="fastioH-17">#endif</front>
<front id="fastioH-18"></front>
<front id="fastioH-19">/*</front>
<front id="fastioH-20">  magic I/O routines</front>
<front id="fastioH-21">  now you can simply SET_OUTPUT(STEP); WRITE(STEP, 1); WRITE(STEP, 0);</front>
<front id="fastioH-22">*/</front>
<front id="fastioH-23"></front>
<front id="fastioH-24">/// Read a pin</front>
<front id="fastioH-25">#define _READ(IO) ((bool)(DIO ## IO ## _RPORT & MASK(DIO ## IO ## _PIN)))</front>
<front id="fastioH-26">/// write to a pin</front>
<front id="fastioH-27">// On some boards pins &gt; 0x100 are used. These are not converted to atomic actions. An critical section is needed.</front>
<front id="fastioH-28"></front>
<front id="fastioH-29">#define _WRITE_NC(IO, v)  do { if (v) {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); } else {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }; } while (0)</front>
<front id="fastioH-30"></front>
<front id="fastioH-31">#define _WRITE_C(IO, v)   do { if (v) { \</front>
<front id="fastioH-32">                                         CRITICAL_SECTION_START; \</front>
<front id="fastioH-33">                                         {DIO ##  IO ## _WPORT |= MASK(DIO ## IO ## _PIN); }\</front>
<front id="fastioH-34">                                         CRITICAL_SECTION_END; \</front>
<front id="fastioH-35">                                       }\</front>
<front id="fastioH-36">                                       else {\</front>
<front id="fastioH-37">                                         CRITICAL_SECTION_START; \</front>
<front id="fastioH-38">                                         {DIO ##  IO ## _WPORT &= ~MASK(DIO ## IO ## _PIN); }\</front>
<front id="fastioH-39">                                         CRITICAL_SECTION_END; \</front>
<front id="fastioH-40">                                       }\</front>
<front id="fastioH-41">                                     }\</front>
<front id="fastioH-42">                                     while (0)</front>
<front id="fastioH-43"></front>
<front id="fastioH-44">#define _WRITE(IO, v)  do {  if (&(DIO ##  IO ## _RPORT) &gt;= (uint8_t *)0x100) {_WRITE_C(IO, v); } else {_WRITE_NC(IO, v); }; } while (0)</front>
<front id="fastioH-45"></front>
<front id="fastioH-46">/// toggle a pin</front>
<front id="fastioH-47">#define _TOGGLE(IO)  do {DIO ##  IO ## _RPORT = MASK(DIO ## IO ## _PIN); } while (0)</front>
<front id="fastioH-48"></front>
<front id="fastioH-49">/// set pin as input</front>
<front id="fastioH-50">#define	_SET_INPUT(IO) do {DIO ##  IO ## _DDR &= ~MASK(DIO ## IO ## _PIN); } while (0)</front>
<front id="fastioH-51">/// set pin as output</front>
<front id="fastioH-52">#define	_SET_OUTPUT(IO) do {DIO ##  IO ## _DDR |=  MASK(DIO ## IO ## _PIN); } while (0)</front>
<front id="fastioH-53"></front>
<front id="fastioH-54">/// check if pin is an input</front>
<front id="fastioH-55">#define	_GET_INPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) == 0)</front>
<front id="fastioH-56">/// check if pin is an output</front>
<front id="fastioH-57">#define	_GET_OUTPUT(IO)  ((DIO ## IO ## _DDR & MASK(DIO ## IO ## _PIN)) != 0)</front>
<front id="fastioH-58"></front>
<front id="fastioH-59">/// check if pin is an timer</front>
<front id="fastioH-60">#define	_GET_TIMER(IO)  ((DIO ## IO ## _PWM)</front>
<front id="fastioH-61"></front>
<front id="fastioH-62">//  why double up on these macros? see http://gcc.gnu.org/onlinedocs/cpp/Stringification.html</front>
<front id="fastioH-63"></front>
<front id="fastioH-64">/// Read a pin wrapper</front>
<front id="fastioH-65">#define READ(IO)  _READ(IO)</front>
<front id="fastioH-66">/// Write to a pin wrapper</front>
<front id="fastioH-67">#define WRITE(IO, v)  _WRITE(IO, v)</front>
<front id="fastioH-68"></front>
<front id="fastioH-69">/// toggle a pin wrapper</front>
<front id="fastioH-70">#define TOGGLE(IO)  _TOGGLE(IO)</front>
<front id="fastioH-71"></front>
<front id="fastioH-72">/// set pin as input wrapper</front>
<front id="fastioH-73">#define SET_INPUT(IO)  _SET_INPUT(IO)</front>
<front id="fastioH-74">/// set pin as output wrapper</front>
<front id="fastioH-75">#define SET_OUTPUT(IO)  _SET_OUTPUT(IO)</front>
<front id="fastioH-76"></front>
<front id="fastioH-77">/// check if pin is an input wrapper</front>
<front id="fastioH-78">#define GET_INPUT(IO)  _GET_INPUT(IO)</front>
<front id="fastioH-79">/// check if pin is an output wrapper</front>
<front id="fastioH-80">#define GET_OUTPUT(IO)  _GET_OUTPUT(IO)</front>
<front id="fastioH-81"></front>
<front id="fastioH-82">/// check if pin is an timer wrapper</front>
<front id="fastioH-83">#define GET_TIMER(IO)  _GET_TIMER(IO)</front>
<front id="fastioH-84"></front>
<front id="fastioH-85">// Shorthand</front>
<front id="fastioH-86">#define OUT_WRITE(IO, v) { SET_OUTPUT(IO); WRITE(IO, v); }</front>
<front id="fastioH-87"></front>
<front id="fastioH-88">/*</front>
<front id="fastioH-89">	ports and functions</front>
<front id="fastioH-90"></front>
<front id="fastioH-91">	added as necessary or if I feel like it- not a comprehensive list!</front>
<front id="fastioH-92">*/</front>
<front id="fastioH-93"></front>
<front id="fastioH-94">#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328__) || defined(__AVR_ATmega328P__)</front>
<front id="fastioH-95">// UART</front>
<front id="fastioH-96">#define	RXD					DIO0</front>
<front id="fastioH-97">#define	TXD					DIO1</front>
<front id="fastioH-98"></front>
<front id="fastioH-99">// SPI</front>
<front id="fastioH-100">#define	SCK					DIO13</front>
<front id="fastioH-101">#define	MISO				DIO12</front>
<front id="fastioH-102">#define	MOSI				DIO11</front>
<front id="fastioH-103">#define	SS					DIO10</front>
<front id="fastioH-104"></front>
<front id="fastioH-105">// TWI (I2C)</front>
<front id="fastioH-106">#define	SCL					AIO5</front>
<front id="fastioH-107">#define	SDA					AIO4</front>
<front id="fastioH-108"></front>
<front id="fastioH-109">// timers and PWM</front>
<front id="fastioH-110">#define	OC0A				DIO6</front>
<front id="fastioH-111">#define	OC0B				DIO5</front>
<front id="fastioH-112">#define	OC1A				DIO9</front>
<front id="fastioH-113">#define	OC1B				DIO10</front>
<front id="fastioH-114">#define	OC2A				DIO11</front>
<front id="fastioH-115">#define	OC2B				DIO3</front>
<front id="fastioH-116"></front>
<front id="fastioH-117">#define	DEBUG_LED		AIO5</front>
<front id="fastioH-118"></front>
<front id="fastioH-119">/*</front>
<front id="fastioH-120">pins</front>
<front id="fastioH-121">*/</front>
<front id="fastioH-122"></front>
<front id="fastioH-123">#define DIO0_PIN		PIND0</front>
<front id="fastioH-124">#define DIO0_RPORT	PIND</front>
<front id="fastioH-125">#define DIO0_WPORT	PORTD</front>
<front id="fastioH-126">#define DIO0_DDR		DDRD</front>
<front id="fastioH-127">#define DIO0_PWM		NULL</front>
<front id="fastioH-128"></front>
<front id="fastioH-129">#define DIO1_PIN		PIND1</front>
<front id="fastioH-130">#define DIO1_RPORT	PIND</front>
<front id="fastioH-131">#define DIO1_WPORT	PORTD</front>
<front id="fastioH-132">#define DIO1_DDR		DDRD</front>
<front id="fastioH-133">#define DIO1_PWM		NULL</front>
<front id="fastioH-134"></front>
<front id="fastioH-135">#define DIO2_PIN		PIND2</front>
<front id="fastioH-136">#define DIO2_RPORT	PIND</front>
<front id="fastioH-137">#define DIO2_WPORT	PORTD</front>
<front id="fastioH-138">#define DIO2_DDR		DDRD</front>
<front id="fastioH-139">#define DIO2_PWM		NULL</front>
<front id="fastioH-140"></front>
<front id="fastioH-141">#define DIO3_PIN		PIND3</front>
<front id="fastioH-142">#define DIO3_RPORT	PIND</front>
<front id="fastioH-143">#define DIO3_WPORT	PORTD</front>
<front id="fastioH-144">#define DIO3_DDR		DDRD</front>
<front id="fastioH-145">#define DIO3_PWM		&OCR2B</front>
<front id="fastioH-146"></front>
<front id="fastioH-147">#define DIO4_PIN		PIND4</front>
<front id="fastioH-148">#define DIO4_RPORT	PIND</front>
<front id="fastioH-149">#define DIO4_WPORT	PORTD</front>
<front id="fastioH-150">#define DIO4_DDR		DDRD</front>
<front id="fastioH-151">#define DIO4_PWM		NULL</front>
<front id="fastioH-152"></front>
<front id="fastioH-153">#define DIO5_PIN		PIND5</front>
<front id="fastioH-154">#define DIO5_RPORT	PIND</front>
<front id="fastioH-155">#define DIO5_WPORT	PORTD</front>
<front id="fastioH-156">#define DIO5_DDR		DDRD</front>
<front id="fastioH-157">#define DIO5_PWM		&OCR0B</front>
<front id="fastioH-158"></front>
<front id="fastioH-159">#define DIO6_PIN		PIND6</front>
<front id="fastioH-160">#define DIO6_RPORT	PIND</front>
<front id="fastioH-161">#define DIO6_WPORT	PORTD</front>
<front id="fastioH-162">#define DIO6_DDR		DDRD</front>
<front id="fastioH-163">#define DIO6_PWM		&OCR0A</front>
<front id="fastioH-164"></front>
<front id="fastioH-165">#define DIO7_PIN		PIND7</front>
<front id="fastioH-166">#define DIO7_RPORT	PIND</front>
<front id="fastioH-167">#define DIO7_WPORT	PORTD</front>
<front id="fastioH-168">#define DIO7_DDR		DDRD</front>
<front id="fastioH-169">#define DIO7_PWM		NULL</front>
<front id="fastioH-170"></front>
<front id="fastioH-171">#define DIO8_PIN		PINB0</front>
<front id="fastioH-172">#define DIO8_RPORT	PINB</front>
<front id="fastioH-173">#define DIO8_WPORT	PORTB</front>
<front id="fastioH-174">#define DIO8_DDR		DDRB</front>
<front id="fastioH-175">#define DIO8_PWM		NULL</front>
<front id="fastioH-176"></front>
<front id="fastioH-177">#define DIO9_PIN		PINB1</front>
<front id="fastioH-178">#define DIO9_RPORT	PINB</front>
<front id="fastioH-179">#define DIO9_WPORT	PORTB</front>
<front id="fastioH-180">#define DIO9_DDR		DDRB</front>
<front id="fastioH-181">#define DIO9_PWM		NULL</front>
<front id="fastioH-182"></front>
<front id="fastioH-183">#define DIO10_PIN		PINB2</front>
<front id="fastioH-184">#define DIO10_RPORT	PINB</front>
<front id="fastioH-185">#define DIO10_WPORT	PORTB</front>
<front id="fastioH-186">#define DIO10_DDR		DDRB</front>
<front id="fastioH-187">#define DIO10_PWM		NULL</front>
<front id="fastioH-188"></front>
<front id="fastioH-189">#define DIO11_PIN		PINB3</front>
<front id="fastioH-190">#define DIO11_RPORT	PINB</front>
<front id="fastioH-191">#define DIO11_WPORT	PORTB</front>
<front id="fastioH-192">#define DIO11_DDR		DDRB</front>
<front id="fastioH-193">#define DIO11_PWM		&OCR2A</front>
<front id="fastioH-194"></front>
<front id="fastioH-195">#define DIO12_PIN		PINB4</front>
<front id="fastioH-196">#define DIO12_RPORT	PINB</front>
<front id="fastioH-197">#define DIO12_WPORT	PORTB</front>
<front id="fastioH-198">#define DIO12_DDR		DDRB</front>
<front id="fastioH-199">#define DIO12_PWM		NULL</front>
<front id="fastioH-200"></front>
<front id="fastioH-201">#define DIO13_PIN		PINB5</front>
<front id="fastioH-202">#define DIO13_RPORT	PINB</front>
<front id="fastioH-203">#define DIO13_WPORT	PORTB</front>
<front id="fastioH-204">#define DIO13_DDR		DDRB</front>
<front id="fastioH-205">#define DIO13_PWM		NULL</front>
<front id="fastioH-206"></front>
<front id="fastioH-207"></front>
<front id="fastioH-208">#define DIO14_PIN		PINC0</front>
<front id="fastioH-209">#define DIO14_RPORT	PINC</front>
<front id="fastioH-210">#define DIO14_WPORT	PORTC</front>
<front id="fastioH-211">#define DIO14_DDR		DDRC</front>
<front id="fastioH-212">#define DIO14_PWM		NULL</front>
<front id="fastioH-213"></front>
<front id="fastioH-214">#define DIO15_PIN		PINC1</front>
<front id="fastioH-215">#define DIO15_RPORT	PINC</front>
<front id="fastioH-216">#define DIO15_WPORT	PORTC</front>
<front id="fastioH-217">#define DIO15_DDR		DDRC</front>
<front id="fastioH-218">#define DIO15_PWM		NULL</front>
<front id="fastioH-219"></front>
<front id="fastioH-220">#define DIO16_PIN		PINC2</front>
<front id="fastioH-221">#define DIO16_RPORT	PINC</front>
<front id="fastioH-222">#define DIO16_WPORT	PORTC</front>
<front id="fastioH-223">#define DIO16_DDR		DDRC</front>
<front id="fastioH-224">#define DIO16_PWM		NULL</front>
<front id="fastioH-225"></front>
<front id="fastioH-226">#define DIO17_PIN		PINC3</front>
<front id="fastioH-227">#define DIO17_RPORT	PINC</front>
<front id="fastioH-228">#define DIO17_WPORT	PORTC</front>
<front id="fastioH-229">#define DIO17_DDR		DDRC</front>
<front id="fastioH-230">#define DIO17_PWM		NULL</front>
<front id="fastioH-231"></front>
<front id="fastioH-232">#define DIO18_PIN		PINC4</front>
<front id="fastioH-233">#define DIO18_RPORT	PINC</front>
<front id="fastioH-234">#define DIO18_WPORT	PORTC</front>
<front id="fastioH-235">#define DIO18_DDR		DDRC</front>
<front id="fastioH-236">#define DIO18_PWM		NULL</front>
<front id="fastioH-237"></front>
<front id="fastioH-238">#define DIO19_PIN		PINC5</front>
<front id="fastioH-239">#define DIO19_RPORT	PINC</front>
<front id="fastioH-240">#define DIO19_WPORT	PORTC</front>
<front id="fastioH-241">#define DIO19_DDR		DDRC</front>
<front id="fastioH-242">#define DIO19_PWM		NULL</front>
<front id="fastioH-243"></front>
<front id="fastioH-244">#define DIO20_PIN		PINC6</front>
<front id="fastioH-245">#define DIO20_RPORT	PINC</front>
<front id="fastioH-246">#define DIO20_WPORT	PORTC</front>
<front id="fastioH-247">#define DIO20_DDR		DDRC</front>
<front id="fastioH-248">#define DIO20_PWM		NULL</front>
<front id="fastioH-249"></front>
<front id="fastioH-250">#define DIO21_PIN		PINC7</front>
<front id="fastioH-251">#define DIO21_RPORT	PINC</front>
<front id="fastioH-252">#define DIO21_WPORT	PORTC</front>
<front id="fastioH-253">#define DIO21_DDR		DDRC</front>
<front id="fastioH-254">#define DIO21_PWM		NULL</front>
<front id="fastioH-255"></front>
<front id="fastioH-256"></front>
<front id="fastioH-257"></front>
<front id="fastioH-258">#undef PB0</front>
<front id="fastioH-259">#define PB0_PIN			PINB0</front>
<front id="fastioH-260">#define PB0_RPORT		PINB</front>
<front id="fastioH-261">#define PB0_WPORT		PORTB</front>
<front id="fastioH-262">#define PB0_DDR			DDRB</front>
<front id="fastioH-263">#define PB0_PWM			NULL</front>
<front id="fastioH-264"></front>
<front id="fastioH-265">#undef PB1</front>
<front id="fastioH-266">#define PB1_PIN			PINB1</front>
<front id="fastioH-267">#define PB1_RPORT		PINB</front>
<front id="fastioH-268">#define PB1_WPORT		PORTB</front>
<front id="fastioH-269">#define PB1_DDR			DDRB</front>
<front id="fastioH-270">#define PB1_PWM			NULL</front>
<front id="fastioH-271"></front>
<front id="fastioH-272">#undef PB2</front>
<front id="fastioH-273">#define PB2_PIN			PINB2</front>
<front id="fastioH-274">#define PB2_RPORT		PINB</front>
<front id="fastioH-275">#define PB2_WPORT		PORTB</front>
<front id="fastioH-276">#define PB2_DDR			DDRB</front>
<front id="fastioH-277">#define PB2_PWM			NULL</front>
<front id="fastioH-278"></front>
<front id="fastioH-279">#undef PB3</front>
<front id="fastioH-280">#define PB3_PIN			PINB3</front>
<front id="fastioH-281">#define PB3_RPORT		PINB</front>
<front id="fastioH-282">#define PB3_WPORT		PORTB</front>
<front id="fastioH-283">#define PB3_DDR			DDRB</front>
<front id="fastioH-284">#define PB3_PWM			&OCR2A</front>
<front id="fastioH-285"></front>
<front id="fastioH-286">#undef PB4</front>
<front id="fastioH-287">#define PB4_PIN			PINB4</front>
<front id="fastioH-288">#define PB4_RPORT		PINB</front>
<front id="fastioH-289">#define PB4_WPORT		PORTB</front>
<front id="fastioH-290">#define PB4_DDR			DDRB</front>
<front id="fastioH-291">#define PB4_PWM			NULL</front>
<front id="fastioH-292"></front>
<front id="fastioH-293">#undef PB5</front>
<front id="fastioH-294">#define PB5_PIN			PINB5</front>
<front id="fastioH-295">#define PB5_RPORT		PINB</front>
<front id="fastioH-296">#define PB5_WPORT		PORTB</front>
<front id="fastioH-297">#define PB5_DDR			DDRB</front>
<front id="fastioH-298">#define PB5_PWM			NULL</front>
<front id="fastioH-299"></front>
<front id="fastioH-300">#undef PB6</front>
<front id="fastioH-301">#define PB6_PIN			PINB6</front>
<front id="fastioH-302">#define PB6_RPORT		PINB</front>
<front id="fastioH-303">#define PB6_WPORT		PORTB</front>
<front id="fastioH-304">#define PB6_DDR			DDRB</front>
<front id="fastioH-305">#define PB6_PWM			NULL</front>
<front id="fastioH-306"></front>
<front id="fastioH-307">#undef PB7</front>
<front id="fastioH-308">#define PB7_PIN			PINB7</front>
<front id="fastioH-309">#define PB7_RPORT		PINB</front>
<front id="fastioH-310">#define PB7_WPORT		PORTB</front>
<front id="fastioH-311">#define PB7_DDR			DDRB</front>
<front id="fastioH-312">#define PB7_PWM			NULL</front>
<front id="fastioH-313"></front>
<front id="fastioH-314"></front>
<front id="fastioH-315">#undef PC0</front>
<front id="fastioH-316">#define PC0_PIN			PINC0</front>
<front id="fastioH-317">#define PC0_RPORT		PINC</front>
<front id="fastioH-318">#define PC0_WPORT		PORTC</front>
<front id="fastioH-319">#define PC0_DDR			DDRC</front>
<front id="fastioH-320">#define PC0_PWM			NULL</front>
<front id="fastioH-321"></front>
<front id="fastioH-322">#undef PC1</front>
<front id="fastioH-323">#define PC1_PIN			PINC1</front>
<front id="fastioH-324">#define PC1_RPORT		PINC</front>
<front id="fastioH-325">#define PC1_WPORT		PORTC</front>
<front id="fastioH-326">#define PC1_DDR			DDRC</front>
<front id="fastioH-327">#define PC1_PWM			NULL</front>
<front id="fastioH-328"></front>
<front id="fastioH-329">#undef PC2</front>
<front id="fastioH-330">#define PC2_PIN			PINC2</front>
<front id="fastioH-331">#define PC2_RPORT		PINC</front>
<front id="fastioH-332">#define PC2_WPORT		PORTC</front>
<front id="fastioH-333">#define PC2_DDR			DDRC</front>
<front id="fastioH-334">#define PC2_PWM			NULL</front>
<front id="fastioH-335"></front>
<front id="fastioH-336">#undef PC3</front>
<front id="fastioH-337">#define PC3_PIN			PINC3</front>
<front id="fastioH-338">#define PC3_RPORT		PINC</front>
<front id="fastioH-339">#define PC3_WPORT		PORTC</front>
<front id="fastioH-340">#define PC3_DDR			DDRC</front>
<front id="fastioH-341">#define PC3_PWM			NULL</front>
<front id="fastioH-342"></front>
<front id="fastioH-343">#undef PC4</front>
<front id="fastioH-344">#define PC4_PIN			PINC4</front>
<front id="fastioH-345">#define PC4_RPORT		PINC</front>
<front id="fastioH-346">#define PC4_WPORT		PORTC</front>
<front id="fastioH-347">#define PC4_DDR			DDRC</front>
<front id="fastioH-348">#define PC4_PWM			NULL</front>
<front id="fastioH-349"></front>
<front id="fastioH-350">#undef PC5</front>
<front id="fastioH-351">#define PC5_PIN			PINC5</front>
<front id="fastioH-352">#define PC5_RPORT		PINC</front>
<front id="fastioH-353">#define PC5_WPORT		PORTC</front>
<front id="fastioH-354">#define PC5_DDR			DDRC</front>
<front id="fastioH-355">#define PC5_PWM			NULL</front>
<front id="fastioH-356"></front>
<front id="fastioH-357">#undef PC6</front>
<front id="fastioH-358">#define PC6_PIN			PINC6</front>
<front id="fastioH-359">#define PC6_RPORT		PINC</front>
<front id="fastioH-360">#define PC6_WPORT		PORTC</front>
<front id="fastioH-361">#define PC6_DDR			DDRC</front>
<front id="fastioH-362">#define PC6_PWM			NULL</front>
<front id="fastioH-363"></front>
<front id="fastioH-364">#undef PC7</front>
<front id="fastioH-365">#define PC7_PIN			PINC7</front>
<front id="fastioH-366">#define PC7_RPORT		PINC</front>
<front id="fastioH-367">#define PC7_WPORT		PORTC</front>
<front id="fastioH-368">#define PC7_DDR			DDRC</front>
<front id="fastioH-369">#define PC7_PWM			NULL</front>
<front id="fastioH-370"></front>
<front id="fastioH-371"></front>
<front id="fastioH-372">#undef PD0</front>
<front id="fastioH-373">#define PD0_PIN			PIND0</front>
<front id="fastioH-374">#define PD0_RPORT		PIND</front>
<front id="fastioH-375">#define PD0_WPORT		PORTD</front>
<front id="fastioH-376">#define PD0_DDR			DDRD</front>
<front id="fastioH-377">#define PD0_PWM			NULL</front>
<front id="fastioH-378"></front>
<front id="fastioH-379">#undef PD1</front>
<front id="fastioH-380">#define PD1_PIN			PIND1</front>
<front id="fastioH-381">#define PD1_RPORT		PIND</front>
<front id="fastioH-382">#define PD1_WPORT		PORTD</front>
<front id="fastioH-383">#define PD1_DDR			DDRD</front>
<front id="fastioH-384">#define PD1_PWM			NULL</front>
<front id="fastioH-385"></front>
<front id="fastioH-386">#undef PD2</front>
<front id="fastioH-387">#define PD2_PIN			PIND2</front>
<front id="fastioH-388">#define PD2_RPORT		PIND</front>
<front id="fastioH-389">#define PD2_WPORT		PORTD</front>
<front id="fastioH-390">#define PD2_DDR			DDRD</front>
<front id="fastioH-391">#define PD2_PWM			NULL</front>
<front id="fastioH-392"></front>
<front id="fastioH-393">#undef PD3</front>
<front id="fastioH-394">#define PD3_PIN			PIND3</front>
<front id="fastioH-395">#define PD3_RPORT		PIND</front>
<front id="fastioH-396">#define PD3_WPORT		PORTD</front>
<front id="fastioH-397">#define PD3_DDR			DDRD</front>
<front id="fastioH-398">#define PD3_PWM			&OCR2B</front>
<front id="fastioH-399"></front>
<front id="fastioH-400">#undef PD4</front>
<front id="fastioH-401">#define PD4_PIN			PIND4</front>
<front id="fastioH-402">#define PD4_RPORT		PIND</front>
<front id="fastioH-403">#define PD4_WPORT		PORTD</front>
<front id="fastioH-404">#define PD4_DDR			DDRD</front>
<front id="fastioH-405">#define PD4_PWM			NULL</front>
<front id="fastioH-406"></front>
<front id="fastioH-407">#undef PD5</front>
<front id="fastioH-408">#define PD5_PIN			PIND5</front>
<front id="fastioH-409">#define PD5_RPORT		PIND</front>
<front id="fastioH-410">#define PD5_WPORT		PORTD</front>
<front id="fastioH-411">#define PD5_DDR			DDRD</front>
<front id="fastioH-412">#define PD5_PWM			&OCR0B</front>
<front id="fastioH-413"></front>
<front id="fastioH-414">#undef PD6</front>
<front id="fastioH-415">#define PD6_PIN			PIND6</front>
<front id="fastioH-416">#define PD6_RPORT		PIND</front>
<front id="fastioH-417">#define PD6_WPORT		PORTD</front>
<front id="fastioH-418">#define PD6_DDR			DDRD</front>
<front id="fastioH-419">#define PD6_PWM			&OCR0A</front>
<front id="fastioH-420"></front>
<front id="fastioH-421">#undef PD7</front>
<front id="fastioH-422">#define PD7_PIN			PIND7</front>
<front id="fastioH-423">#define PD7_RPORT		PIND</front>
<front id="fastioH-424">#define PD7_WPORT		PORTD</front>
<front id="fastioH-425">#define PD7_DDR			DDRD</front>
<front id="fastioH-426">#define PD7_PWM			NULL</front>
<front id="fastioH-427">#endif	/*	_AVR_ATmega{168,328,328P}__ */</front>
<front id="fastioH-428"></front>
<front id="fastioH-429">#if defined(__AVR_ATmega644__) || defined(__AVR_ATmega644P__) || defined(__AVR_ATmega644PA__) || defined(__AVR_ATmega1284P__)</front>
<front id="fastioH-430">// UART</front>
<front id="fastioH-431">#define	RXD					DIO8</front>
<front id="fastioH-432">#define	TXD					DIO9</front>
<front id="fastioH-433">#define	RXD0				DIO8</front>
<front id="fastioH-434">#define	TXD0				DIO9</front>
<front id="fastioH-435"></front>
<front id="fastioH-436">#define	RXD1				DIO10</front>
<front id="fastioH-437">#define	TXD1				DIO11</front>
<front id="fastioH-438"></front>
<front id="fastioH-439">// SPI</front>
<front id="fastioH-440">#define	SCK					DIO7</front>
<front id="fastioH-441">#define	MISO				DIO6</front>
<front id="fastioH-442">#define	MOSI				DIO5</front>
<front id="fastioH-443">#define	SS					DIO4</front>
<front id="fastioH-444"></front>
<front id="fastioH-445">// TWI (I2C)</front>
<front id="fastioH-446">#define	SCL					DIO16</front>
<front id="fastioH-447">#define	SDA					DIO17</front>
<front id="fastioH-448"></front>
<front id="fastioH-449">// timers and PWM</front>
<front id="fastioH-450">#define	OC0A				DIO3</front>
<front id="fastioH-451">#define	OC0B				DIO4</front>
<front id="fastioH-452">#define	OC1A				DIO13</front>
<front id="fastioH-453">#define	OC1B				DIO12</front>
<front id="fastioH-454">#define	OC2A				DIO15</front>
<front id="fastioH-455">#define	OC2B				DIO14</front>
<front id="fastioH-456"></front>
<front id="fastioH-457">#define	DEBUG_LED		DIO0</front>
<front id="fastioH-458">/*</front>
<front id="fastioH-459">pins</front>
<front id="fastioH-460">*/</front>
<front id="fastioH-461"></front>
<front id="fastioH-462">#define DIO0_PIN		PINB0</front>
<front id="fastioH-463">#define DIO0_RPORT	PINB</front>
<front id="fastioH-464">#define DIO0_WPORT	PORTB</front>
<front id="fastioH-465">#define DIO0_DDR		DDRB</front>
<front id="fastioH-466">#define DIO0_PWM		NULL</front>
<front id="fastioH-467"></front>
<front id="fastioH-468">#define DIO1_PIN		PINB1</front>
<front id="fastioH-469">#define DIO1_RPORT	PINB</front>
<front id="fastioH-470">#define DIO1_WPORT	PORTB</front>
<front id="fastioH-471">#define DIO1_DDR		DDRB</front>
<front id="fastioH-472">#define DIO1_PWM		NULL</front>
<front id="fastioH-473"></front>
<front id="fastioH-474">#define DIO2_PIN		PINB2</front>
<front id="fastioH-475">#define DIO2_RPORT	PINB</front>
<front id="fastioH-476">#define DIO2_WPORT	PORTB</front>
<front id="fastioH-477">#define DIO2_DDR		DDRB</front>
<front id="fastioH-478">#define DIO2_PWM		NULL</front>
<front id="fastioH-479"></front>
<front id="fastioH-480">#define DIO3_PIN		PINB3</front>
<front id="fastioH-481">#define DIO3_RPORT	PINB</front>
<front id="fastioH-482">#define DIO3_WPORT	PORTB</front>
<front id="fastioH-483">#define DIO3_DDR		DDRB</front>
<front id="fastioH-484">#define DIO3_PWM		OCR0A</front>
<front id="fastioH-485"></front>
<front id="fastioH-486">#define DIO4_PIN		PINB4</front>
<front id="fastioH-487">#define DIO4_RPORT	PINB</front>
<front id="fastioH-488">#define DIO4_WPORT	PORTB</front>
<front id="fastioH-489">#define DIO4_DDR		DDRB</front>
<front id="fastioH-490">#define DIO4_PWM		OCR0B</front>
<front id="fastioH-491"></front>
<front id="fastioH-492">#define DIO5_PIN		PINB5</front>
<front id="fastioH-493">#define DIO5_RPORT	PINB</front>
<front id="fastioH-494">#define DIO5_WPORT	PORTB</front>
<front id="fastioH-495">#define DIO5_DDR		DDRB</front>
<front id="fastioH-496">#define DIO5_PWM		NULL</front>
<front id="fastioH-497"></front>
<front id="fastioH-498">#define DIO6_PIN		PINB6</front>
<front id="fastioH-499">#define DIO6_RPORT	PINB</front>
<front id="fastioH-500">#define DIO6_WPORT	PORTB</front>
<front id="fastioH-501">#define DIO6_DDR		DDRB</front>
<front id="fastioH-502">#define DIO6_PWM		NULL</front>
<front id="fastioH-503"></front>
<front id="fastioH-504">#define DIO7_PIN		PINB7</front>
<front id="fastioH-505">#define DIO7_RPORT	PINB</front>
<front id="fastioH-506">#define DIO7_WPORT	PORTB</front>
<front id="fastioH-507">#define DIO7_DDR		DDRB</front>
<front id="fastioH-508">#define DIO7_PWM		NULL</front>
<front id="fastioH-509"></front>
<front id="fastioH-510">#define DIO8_PIN		PIND0</front>
<front id="fastioH-511">#define DIO8_RPORT	PIND</front>
<front id="fastioH-512">#define DIO8_WPORT	PORTD</front>
<front id="fastioH-513">#define DIO8_DDR		DDRD</front>
<front id="fastioH-514">#define DIO8_PWM		NULL</front>
<front id="fastioH-515"></front>
<front id="fastioH-516">#define DIO9_PIN		PIND1</front>
<front id="fastioH-517">#define DIO9_RPORT	PIND</front>
<front id="fastioH-518">#define DIO9_WPORT	PORTD</front>
<front id="fastioH-519">#define DIO9_DDR		DDRD</front>
<front id="fastioH-520">#define DIO9_PWM		NULL</front>
<front id="fastioH-521"></front>
<front id="fastioH-522">#define DIO10_PIN		PIND2</front>
<front id="fastioH-523">#define DIO10_RPORT	PIND</front>
<front id="fastioH-524">#define DIO10_WPORT	PORTD</front>
<front id="fastioH-525">#define DIO10_DDR		DDRD</front>
<front id="fastioH-526">#define DIO10_PWM		NULL</front>
<front id="fastioH-527"></front>
<front id="fastioH-528">#define DIO11_PIN		PIND3</front>
<front id="fastioH-529">#define DIO11_RPORT	PIND</front>
<front id="fastioH-530">#define DIO11_WPORT	PORTD</front>
<front id="fastioH-531">#define DIO11_DDR		DDRD</front>
<front id="fastioH-532">#define DIO11_PWM		NULL</front>
<front id="fastioH-533"></front>
<front id="fastioH-534">#define DIO12_PIN		PIND4</front>
<front id="fastioH-535">#define DIO12_RPORT	PIND</front>
<front id="fastioH-536">#define DIO12_WPORT	PORTD</front>
<front id="fastioH-537">#define DIO12_DDR		DDRD</front>
<front id="fastioH-538">#define DIO12_PWM		OCR1B</front>
<front id="fastioH-539"></front>
<front id="fastioH-540">#define DIO13_PIN		PIND5</front>
<front id="fastioH-541">#define DIO13_RPORT	PIND</front>
<front id="fastioH-542">#define DIO13_WPORT	PORTD</front>
<front id="fastioH-543">#define DIO13_DDR		DDRD</front>
<front id="fastioH-544">#define DIO13_PWM		OCR1A</front>
<front id="fastioH-545"></front>
<front id="fastioH-546">#define DIO14_PIN		PIND6</front>
<front id="fastioH-547">#define DIO14_RPORT	PIND</front>
<front id="fastioH-548">#define DIO14_WPORT	PORTD</front>
<front id="fastioH-549">#define DIO14_DDR		DDRD</front>
<front id="fastioH-550">#define DIO14_PWM		OCR2B</front>
<front id="fastioH-551"></front>
<front id="fastioH-552">#define DIO15_PIN		PIND7</front>
<front id="fastioH-553">#define DIO15_RPORT	PIND</front>
<front id="fastioH-554">#define DIO15_WPORT	PORTD</front>
<front id="fastioH-555">#define DIO15_DDR		DDRD</front>
<front id="fastioH-556">#define DIO15_PWM		OCR2A</front>
<front id="fastioH-557"></front>
<front id="fastioH-558">#define DIO16_PIN		PINC0</front>
<front id="fastioH-559">#define DIO16_RPORT	PINC</front>
<front id="fastioH-560">#define DIO16_WPORT	PORTC</front>
<front id="fastioH-561">#define DIO16_DDR		DDRC</front>
<front id="fastioH-562">#define DIO16_PWM		NULL</front>
<front id="fastioH-563"></front>
<front id="fastioH-564">#define DIO17_PIN		PINC1</front>
<front id="fastioH-565">#define DIO17_RPORT	PINC</front>
<front id="fastioH-566">#define DIO17_WPORT	PORTC</front>
<front id="fastioH-567">#define DIO17_DDR		DDRC</front>
<front id="fastioH-568">#define DIO17_PWM		NULL</front>
<front id="fastioH-569"></front>
<front id="fastioH-570">#define DIO18_PIN		PINC2</front>
<front id="fastioH-571">#define DIO18_RPORT	PINC</front>
<front id="fastioH-572">#define DIO18_WPORT	PORTC</front>
<front id="fastioH-573">#define DIO18_DDR		DDRC</front>
<front id="fastioH-574">#define DIO18_PWM		NULL</front>
<front id="fastioH-575"></front>
<front id="fastioH-576">#define DIO19_PIN		PINC3</front>
<front id="fastioH-577">#define DIO19_RPORT	PINC</front>
<front id="fastioH-578">#define DIO19_WPORT	PORTC</front>
<front id="fastioH-579">#define DIO19_DDR		DDRC</front>
<front id="fastioH-580">#define DIO19_PWM		NULL</front>
<front id="fastioH-581"></front>
<front id="fastioH-582">#define DIO20_PIN		PINC4</front>
<front id="fastioH-583">#define DIO20_RPORT	PINC</front>
<front id="fastioH-584">#define DIO20_WPORT	PORTC</front>
<front id="fastioH-585">#define DIO20_DDR		DDRC</front>
<front id="fastioH-586">#define DIO20_PWM		NULL</front>
<front id="fastioH-587"></front>
<front id="fastioH-588">#define DIO21_PIN		PINC5</front>
<front id="fastioH-589">#define DIO21_RPORT	PINC</front>
<front id="fastioH-590">#define DIO21_WPORT	PORTC</front>
<front id="fastioH-591">#define DIO21_DDR		DDRC</front>
<front id="fastioH-592">#define DIO21_PWM		NULL</front>
<front id="fastioH-593"></front>
<front id="fastioH-594">#define DIO22_PIN		PINC6</front>
<front id="fastioH-595">#define DIO22_RPORT	PINC</front>
<front id="fastioH-596">#define DIO22_WPORT	PORTC</front>
<front id="fastioH-597">#define DIO22_DDR		DDRC</front>
<front id="fastioH-598">#define DIO22_PWM		NULL</front>
<front id="fastioH-599"></front>
<front id="fastioH-600">#define DIO23_PIN		PINC7</front>
<front id="fastioH-601">#define DIO23_RPORT	PINC</front>
<front id="fastioH-602">#define DIO23_WPORT	PORTC</front>
<front id="fastioH-603">#define DIO23_DDR		DDRC</front>
<front id="fastioH-604">#define DIO23_PWM		NULL</front>
<front id="fastioH-605"></front>
<front id="fastioH-606">#define DIO24_PIN		PINA7</front>
<front id="fastioH-607">#define DIO24_RPORT	PINA</front>
<front id="fastioH-608">#define DIO24_WPORT	PORTA</front>
<front id="fastioH-609">#define DIO24_DDR		DDRA</front>
<front id="fastioH-610">#define DIO24_PWM		NULL</front>
<front id="fastioH-611"></front>
<front id="fastioH-612">#define DIO25_PIN		PINA6</front>
<front id="fastioH-613">#define DIO25_RPORT	PINA</front>
<front id="fastioH-614">#define DIO25_WPORT	PORTA</front>
<front id="fastioH-615">#define DIO25_DDR		DDRA</front>
<front id="fastioH-616">#define DIO25_PWM		NULL</front>
<front id="fastioH-617"></front>
<front id="fastioH-618">#define DIO26_PIN		PINA5</front>
<front id="fastioH-619">#define DIO26_RPORT	PINA</front>
<front id="fastioH-620">#define DIO26_WPORT	PORTA</front>
<front id="fastioH-621">#define DIO26_DDR		DDRA</front>
<front id="fastioH-622">#define DIO26_PWM		NULL</front>
<front id="fastioH-623"></front>
<front id="fastioH-624">#define DIO27_PIN		PINA4</front>
<front id="fastioH-625">#define DIO27_RPORT	PINA</front>
<front id="fastioH-626">#define DIO27_WPORT	PORTA</front>
<front id="fastioH-627">#define DIO27_DDR		DDRA</front>
<front id="fastioH-628">#define DIO27_PWM		NULL</front>
<front id="fastioH-629"></front>
<front id="fastioH-630">#define DIO28_PIN		PINA3</front>
<front id="fastioH-631">#define DIO28_RPORT	PINA</front>
<front id="fastioH-632">#define DIO28_WPORT	PORTA</front>
<front id="fastioH-633">#define DIO28_DDR		DDRA</front>
<front id="fastioH-634">#define DIO28_PWM		NULL</front>
<front id="fastioH-635"></front>
<front id="fastioH-636">#define DIO29_PIN		PINA2</front>
<front id="fastioH-637">#define DIO29_RPORT	PINA</front>
<front id="fastioH-638">#define DIO29_WPORT	PORTA</front>
<front id="fastioH-639">#define DIO29_DDR		DDRA</front>
<front id="fastioH-640">#define DIO29_PWM		NULL</front>
<front id="fastioH-641"></front>
<front id="fastioH-642">#define DIO30_PIN		PINA1</front>
<front id="fastioH-643">#define DIO30_RPORT	PINA</front>
<front id="fastioH-644">#define DIO30_WPORT	PORTA</front>
<front id="fastioH-645">#define DIO30_DDR		DDRA</front>
<front id="fastioH-646">#define DIO30_PWM		NULL</front>
<front id="fastioH-647"></front>
<front id="fastioH-648">#define DIO31_PIN		PINA0</front>
<front id="fastioH-649">#define DIO31_RPORT	PINA</front>
<front id="fastioH-650">#define DIO31_WPORT	PORTA</front>
<front id="fastioH-651">#define DIO31_DDR		DDRA</front>
<front id="fastioH-652">#define DIO31_PWM		NULL</front>
<front id="fastioH-653"></front>
<front id="fastioH-654">#define AIO0_PIN		PINA0</front>
<front id="fastioH-655">#define AIO0_RPORT	PINA</front>
<front id="fastioH-656">#define AIO0_WPORT	PORTA</front>
<front id="fastioH-657">#define AIO0_DDR		DDRA</front>
<front id="fastioH-658">#define AIO0_PWM		NULL</front>
<front id="fastioH-659"></front>
<front id="fastioH-660">#define AIO1_PIN		PINA1</front>
<front id="fastioH-661">#define AIO1_RPORT	PINA</front>
<front id="fastioH-662">#define AIO1_WPORT	PORTA</front>
<front id="fastioH-663">#define AIO1_DDR		DDRA</front>
<front id="fastioH-664">#define AIO1_PWM		NULL</front>
<front id="fastioH-665"></front>
<front id="fastioH-666">#define AIO2_PIN		PINA2</front>
<front id="fastioH-667">#define AIO2_RPORT	PINA</front>
<front id="fastioH-668">#define AIO2_WPORT	PORTA</front>
<front id="fastioH-669">#define AIO2_DDR		DDRA</front>
<front id="fastioH-670">#define AIO2_PWM		NULL</front>
<front id="fastioH-671"></front>
<front id="fastioH-672">#define AIO3_PIN		PINA3</front>
<front id="fastioH-673">#define AIO3_RPORT	PINA</front>
<front id="fastioH-674">#define AIO3_WPORT	PORTA</front>
<front id="fastioH-675">#define AIO3_DDR		DDRA</front>
<front id="fastioH-676">#define AIO3_PWM		NULL</front>
<front id="fastioH-677"></front>
<front id="fastioH-678">#define AIO4_PIN		PINA4</front>
<front id="fastioH-679">#define AIO4_RPORT	PINA</front>
<front id="fastioH-680">#define AIO4_WPORT	PORTA</front>
<front id="fastioH-681">#define AIO4_DDR		DDRA</front>
<front id="fastioH-682">#define AIO4_PWM		NULL</front>
<front id="fastioH-683"></front>
<front id="fastioH-684">#define AIO5_PIN		PINA5</front>
<front id="fastioH-685">#define AIO5_RPORT	PINA</front>
<front id="fastioH-686">#define AIO5_WPORT	PORTA</front>
<front id="fastioH-687">#define AIO5_DDR		DDRA</front>
<front id="fastioH-688">#define AIO5_PWM		NULL</front>
<front id="fastioH-689"></front>
<front id="fastioH-690">#define AIO6_PIN		PINA6</front>
<front id="fastioH-691">#define AIO6_RPORT	PINA</front>
<front id="fastioH-692">#define AIO6_WPORT	PORTA</front>
<front id="fastioH-693">#define AIO6_DDR		DDRA</front>
<front id="fastioH-694">#define AIO6_PWM		NULL</front>
<front id="fastioH-695"></front>
<front id="fastioH-696">#define AIO7_PIN		PINA7</front>
<front id="fastioH-697">#define AIO7_RPORT	PINA</front>
<front id="fastioH-698">#define AIO7_WPORT	PORTA</front>
<front id="fastioH-699">#define AIO7_DDR		DDRA</front>
<front id="fastioH-700">#define AIO7_PWM		NULL</front>
<front id="fastioH-701"></front>
<front id="fastioH-702"></front>
<front id="fastioH-703"></front>
<front id="fastioH-704">#undef PA0</front>
<front id="fastioH-705">#define PA0_PIN			PINA0</front>
<front id="fastioH-706">#define PA0_RPORT		PINA</front>
<front id="fastioH-707">#define PA0_WPORT		PORTA</front>
<front id="fastioH-708">#define PA0_DDR			DDRA</front>
<front id="fastioH-709">#define PA0_PWM			NULL</front>
<front id="fastioH-710"></front>
<front id="fastioH-711">#undef PA1</front>
<front id="fastioH-712">#define PA1_PIN			PINA1</front>
<front id="fastioH-713">#define PA1_RPORT		PINA</front>
<front id="fastioH-714">#define PA1_WPORT		PORTA</front>
<front id="fastioH-715">#define PA1_DDR			DDRA</front>
<front id="fastioH-716">#define PA1_PWM			NULL</front>
<front id="fastioH-717"></front>
<front id="fastioH-718">#undef PA2</front>
<front id="fastioH-719">#define PA2_PIN			PINA2</front>
<front id="fastioH-720">#define PA2_RPORT		PINA</front>
<front id="fastioH-721">#define PA2_WPORT		PORTA</front>
<front id="fastioH-722">#define PA2_DDR			DDRA</front>
<front id="fastioH-723">#define PA2_PWM			NULL</front>
<front id="fastioH-724"></front>
<front id="fastioH-725">#undef PA3</front>
<front id="fastioH-726">#define PA3_PIN			PINA3</front>
<front id="fastioH-727">#define PA3_RPORT		PINA</front>
<front id="fastioH-728">#define PA3_WPORT		PORTA</front>
<front id="fastioH-729">#define PA3_DDR			DDRA</front>
<front id="fastioH-730">#define PA3_PWM			NULL</front>
<front id="fastioH-731"></front>
<front id="fastioH-732">#undef PA4</front>
<front id="fastioH-733">#define PA4_PIN			PINA4</front>
<front id="fastioH-734">#define PA4_RPORT		PINA</front>
<front id="fastioH-735">#define PA4_WPORT		PORTA</front>
<front id="fastioH-736">#define PA4_DDR			DDRA</front>
<front id="fastioH-737">#define PA4_PWM			NULL</front>
<front id="fastioH-738"></front>
<front id="fastioH-739">#undef PA5</front>
<front id="fastioH-740">#define PA5_PIN			PINA5</front>
<front id="fastioH-741">#define PA5_RPORT		PINA</front>
<front id="fastioH-742">#define PA5_WPORT		PORTA</front>
<front id="fastioH-743">#define PA5_DDR			DDRA</front>
<front id="fastioH-744">#define PA5_PWM			NULL</front>
<front id="fastioH-745"></front>
<front id="fastioH-746">#undef PA6</front>
<front id="fastioH-747">#define PA6_PIN			PINA6</front>
<front id="fastioH-748">#define PA6_RPORT		PINA</front>
<front id="fastioH-749">#define PA6_WPORT		PORTA</front>
<front id="fastioH-750">#define PA6_DDR			DDRA</front>
<front id="fastioH-751">#define PA6_PWM			NULL</front>
<front id="fastioH-752"></front>
<front id="fastioH-753">#undef PA7</front>
<front id="fastioH-754">#define PA7_PIN			PINA7</front>
<front id="fastioH-755">#define PA7_RPORT		PINA</front>
<front id="fastioH-756">#define PA7_WPORT		PORTA</front>
<front id="fastioH-757">#define PA7_DDR			DDRA</front>
<front id="fastioH-758">#define PA7_PWM			NULL</front>
<front id="fastioH-759"></front>
<front id="fastioH-760"></front>
<front id="fastioH-761">#undef PB0</front>
<front id="fastioH-762">#define PB0_PIN			PINB0</front>
<front id="fastioH-763">#define PB0_RPORT		PINB</front>
<front id="fastioH-764">#define PB0_WPORT		PORTB</front>
<front id="fastioH-765">#define PB0_DDR			DDRB</front>
<front id="fastioH-766">#define PB0_PWM			NULL</front>
<front id="fastioH-767"></front>
<front id="fastioH-768">#undef PB1</front>
<front id="fastioH-769">#define PB1_PIN			PINB1</front>
<front id="fastioH-770">#define PB1_RPORT		PINB</front>
<front id="fastioH-771">#define PB1_WPORT		PORTB</front>
<front id="fastioH-772">#define PB1_DDR			DDRB</front>
<front id="fastioH-773">#define PB1_PWM			NULL</front>
<front id="fastioH-774"></front>
<front id="fastioH-775">#undef PB2</front>
<front id="fastioH-776">#define PB2_PIN			PINB2</front>
<front id="fastioH-777">#define PB2_RPORT		PINB</front>
<front id="fastioH-778">#define PB2_WPORT		PORTB</front>
<front id="fastioH-779">#define PB2_DDR			DDRB</front>
<front id="fastioH-780">#define PB2_PWM			NULL</front>
<front id="fastioH-781"></front>
<front id="fastioH-782">#undef PB3</front>
<front id="fastioH-783">#define PB3_PIN			PINB3</front>
<front id="fastioH-784">#define PB3_RPORT		PINB</front>
<front id="fastioH-785">#define PB3_WPORT		PORTB</front>
<front id="fastioH-786">#define PB3_DDR			DDRB</front>
<front id="fastioH-787">#define PB3_PWM			OCR0A</front>
<front id="fastioH-788"></front>
<front id="fastioH-789">#undef PB4</front>
<front id="fastioH-790">#define PB4_PIN			PINB4</front>
<front id="fastioH-791">#define PB4_RPORT		PINB</front>
<front id="fastioH-792">#define PB4_WPORT		PORTB</front>
<front id="fastioH-793">#define PB4_DDR			DDRB</front>
<front id="fastioH-794">#define PB4_PWM			OCR0B</front>
<front id="fastioH-795"></front>
<front id="fastioH-796">#undef PB5</front>
<front id="fastioH-797">#define PB5_PIN			PINB5</front>
<front id="fastioH-798">#define PB5_RPORT		PINB</front>
<front id="fastioH-799">#define PB5_WPORT		PORTB</front>
<front id="fastioH-800">#define PB5_DDR			DDRB</front>
<front id="fastioH-801">#define PB5_PWM			NULL</front>
<front id="fastioH-802"></front>
<front id="fastioH-803">#undef PB6</front>
<front id="fastioH-804">#define PB6_PIN			PINB6</front>
<front id="fastioH-805">#define PB6_RPORT		PINB</front>
<front id="fastioH-806">#define PB6_WPORT		PORTB</front>
<front id="fastioH-807">#define PB6_DDR			DDRB</front>
<front id="fastioH-808">#define PB6_PWM			NULL</front>
<front id="fastioH-809"></front>
<front id="fastioH-810">#undef PB7</front>
<front id="fastioH-811">#define PB7_PIN			PINB7</front>
<front id="fastioH-812">#define PB7_RPORT		PINB</front>
<front id="fastioH-813">#define PB7_WPORT		PORTB</front>
<front id="fastioH-814">#define PB7_DDR			DDRB</front>
<front id="fastioH-815">#define PB7_PWM			NULL</front>
<front id="fastioH-816"></front>
<front id="fastioH-817"></front>
<front id="fastioH-818">#undef PC0</front>
<front id="fastioH-819">#define PC0_PIN			PINC0</front>
<front id="fastioH-820">#define PC0_RPORT		PINC</front>
<front id="fastioH-821">#define PC0_WPORT		PORTC</front>
<front id="fastioH-822">#define PC0_DDR			DDRC</front>
<front id="fastioH-823">#define PC0_PWM			NULL</front>
<front id="fastioH-824"></front>
<front id="fastioH-825">#undef PC1</front>
<front id="fastioH-826">#define PC1_PIN			PINC1</front>
<front id="fastioH-827">#define PC1_RPORT		PINC</front>
<front id="fastioH-828">#define PC1_WPORT		PORTC</front>
<front id="fastioH-829">#define PC1_DDR			DDRC</front>
<front id="fastioH-830">#define PC1_PWM			NULL</front>
<front id="fastioH-831"></front>
<front id="fastioH-832">#undef PC2</front>
<front id="fastioH-833">#define PC2_PIN			PINC2</front>
<front id="fastioH-834">#define PC2_RPORT		PINC</front>
<front id="fastioH-835">#define PC2_WPORT		PORTC</front>
<front id="fastioH-836">#define PC2_DDR			DDRC</front>
<front id="fastioH-837">#define PC2_PWM			NULL</front>
<front id="fastioH-838"></front>
<front id="fastioH-839">#undef PC3</front>
<front id="fastioH-840">#define PC3_PIN			PINC3</front>
<front id="fastioH-841">#define PC3_RPORT		PINC</front>
<front id="fastioH-842">#define PC3_WPORT		PORTC</front>
<front id="fastioH-843">#define PC3_DDR			DDRC</front>
<front id="fastioH-844">#define PC3_PWM			NULL</front>
<front id="fastioH-845"></front>
<front id="fastioH-846">#undef PC4</front>
<front id="fastioH-847">#define PC4_PIN			PINC4</front>
<front id="fastioH-848">#define PC4_RPORT		PINC</front>
<front id="fastioH-849">#define PC4_WPORT		PORTC</front>
<front id="fastioH-850">#define PC4_DDR			DDRC</front>
<front id="fastioH-851">#define PC4_PWM			NULL</front>
<front id="fastioH-852"></front>
<front id="fastioH-853">#undef PC5</front>
<front id="fastioH-854">#define PC5_PIN			PINC5</front>
<front id="fastioH-855">#define PC5_RPORT		PINC</front>
<front id="fastioH-856">#define PC5_WPORT		PORTC</front>
<front id="fastioH-857">#define PC5_DDR			DDRC</front>
<front id="fastioH-858">#define PC5_PWM			NULL</front>
<front id="fastioH-859"></front>
<front id="fastioH-860">#undef PC6</front>
<front id="fastioH-861">#define PC6_PIN			PINC6</front>
<front id="fastioH-862">#define PC6_RPORT		PINC</front>
<front id="fastioH-863">#define PC6_WPORT		PORTC</front>
<front id="fastioH-864">#define PC6_DDR			DDRC</front>
<front id="fastioH-865">#define PC6_PWM			NULL</front>
<front id="fastioH-866"></front>
<front id="fastioH-867">#undef PC7</front>
<front id="fastioH-868">#define PC7_PIN			PINC7</front>
<front id="fastioH-869">#define PC7_RPORT		PINC</front>
<front id="fastioH-870">#define PC7_WPORT		PORTC</front>
<front id="fastioH-871">#define PC7_DDR			DDRC</front>
<front id="fastioH-872">#define PC7_PWM			NULL</front>
<front id="fastioH-873"></front>
<front id="fastioH-874"></front>
<front id="fastioH-875">#undef PD0</front>
<front id="fastioH-876">#define PD0_PIN			PIND0</front>
<front id="fastioH-877">#define PD0_RPORT		PIND</front>
<front id="fastioH-878">#define PD0_WPORT		PORTD</front>
<front id="fastioH-879">#define PD0_DDR			DDRD</front>
<front id="fastioH-880">#define PD0_PWM			NULL</front>
<front id="fastioH-881"></front>
<front id="fastioH-882">#undef PD1</front>
<front id="fastioH-883">#define PD1_PIN			PIND1</front>
<front id="fastioH-884">#define PD1_RPORT		PIND</front>
<front id="fastioH-885">#define PD1_WPORT		PORTD</front>
<front id="fastioH-886">#define PD1_DDR			DDRD</front>
<front id="fastioH-887">#define PD1_PWM			NULL</front>
<front id="fastioH-888"></front>
<front id="fastioH-889">#undef PD2</front>
<front id="fastioH-890">#define PD2_PIN			PIND2</front>
<front id="fastioH-891">#define PD2_RPORT		PIND</front>
<front id="fastioH-892">#define PD2_WPORT		PORTD</front>
<front id="fastioH-893">#define PD2_DDR			DDRD</front>
<front id="fastioH-894">#define PD2_PWM			NULL</front>
<front id="fastioH-895"></front>
<front id="fastioH-896">#undef PD3</front>
<front id="fastioH-897">#define PD3_PIN			PIND3</front>
<front id="fastioH-898">#define PD3_RPORT		PIND</front>
<front id="fastioH-899">#define PD3_WPORT		PORTD</front>
<front id="fastioH-900">#define PD3_DDR			DDRD</front>
<front id="fastioH-901">#define PD3_PWM			NULL</front>
<front id="fastioH-902"></front>
<front id="fastioH-903">#undef PD4</front>
<front id="fastioH-904">#define PD4_PIN			PIND4</front>
<front id="fastioH-905">#define PD4_RPORT		PIND</front>
<front id="fastioH-906">#define PD4_WPORT		PORTD</front>
<front id="fastioH-907">#define PD4_DDR			DDRD</front>
<front id="fastioH-908">#define PD4_PWM			NULL</front>
<front id="fastioH-909"></front>
<front id="fastioH-910">#undef PD5</front>
<front id="fastioH-911">#define PD5_PIN			PIND5</front>
<front id="fastioH-912">#define PD5_RPORT		PIND</front>
<front id="fastioH-913">#define PD5_WPORT		PORTD</front>
<front id="fastioH-914">#define PD5_DDR			DDRD</front>
<front id="fastioH-915">#define PD5_PWM			NULL</front>
<front id="fastioH-916"></front>
<front id="fastioH-917">#undef PD6</front>
<front id="fastioH-918">#define PD6_PIN			PIND6</front>
<front id="fastioH-919">#define PD6_RPORT		PIND</front>
<front id="fastioH-920">#define PD6_WPORT		PORTD</front>
<front id="fastioH-921">#define PD6_DDR			DDRD</front>
<front id="fastioH-922">#define PD6_PWM			OCR2B</front>
<front id="fastioH-923"></front>
<front id="fastioH-924">#undef PD7</front>
<front id="fastioH-925">#define PD7_PIN			PIND7</front>
<front id="fastioH-926">#define PD7_RPORT		PIND</front>
<front id="fastioH-927">#define PD7_WPORT		PORTD</front>
<front id="fastioH-928">#define PD7_DDR			DDRD</front>
<front id="fastioH-929">#define PD7_PWM			OCR2A</front>
<front id="fastioH-930">#endif	/*	_AVR_ATmega{644,644P,644PA}__ */</front>
<front id="fastioH-931"></front>
<front id="fastioH-932">#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)</front>
<front id="fastioH-933">// UART</front>
<front id="fastioH-934">#define	RXD					DIO0</front>
<front id="fastioH-935">#define	TXD					DIO1</front>
<front id="fastioH-936"></front>
<front id="fastioH-937">// SPI</front>
<front id="fastioH-938">#define	SCK					DIO52</front>
<front id="fastioH-939">#define	MISO				DIO50</front>
<front id="fastioH-940">#define	MOSI				DIO51</front>
<front id="fastioH-941">#define	SS					DIO53</front>
<front id="fastioH-942"></front>
<front id="fastioH-943">// TWI (I2C)</front>
<front id="fastioH-944">#define	SCL					DIO21</front>
<front id="fastioH-945">#define	SDA					DIO20</front>
<front id="fastioH-946"></front>
<front id="fastioH-947">// timers and PWM</front>
<front id="fastioH-948">#define	OC0A				DIO13</front>
<front id="fastioH-949">#define	OC0B				DIO4</front>
<front id="fastioH-950">#define	OC1A				DIO11</front>
<front id="fastioH-951">#define	OC1B				DIO12</front>
<front id="fastioH-952">#define	OC2A				DIO10</front>
<front id="fastioH-953">#define	OC2B				DIO9</front>
<front id="fastioH-954">#define	OC3A				DIO5</front>
<front id="fastioH-955">#define	OC3B				DIO2</front>
<front id="fastioH-956">#define	OC3C				DIO3</front>
<front id="fastioH-957">#define	OC4A				DIO6</front>
<front id="fastioH-958">#define	OC4B				DIO7</front>
<front id="fastioH-959">#define	OC4C				DIO8</front>
<front id="fastioH-960">#define	OC5A				DIO46</front>
<front id="fastioH-961">#define	OC5B				DIO45</front>
<front id="fastioH-962">#define	OC5C				DIO44</front>
<front id="fastioH-963"></front>
<front id="fastioH-964">// change for your board</front>
<front id="fastioH-965">#define	DEBUG_LED		DIO21</front>
<front id="fastioH-966"></front>
<front id="fastioH-967">/*</front>
<front id="fastioH-968">pins</front>
<front id="fastioH-969">*/</front>
<front id="fastioH-970">#define	DIO0_PIN		PINE0</front>
<front id="fastioH-971">#define	DIO0_RPORT	PINE</front>
<front id="fastioH-972">#define	DIO0_WPORT	PORTE</front>
<front id="fastioH-973">#define	DIO0_DDR		DDRE</front>
<front id="fastioH-974">#define DIO0_PWM		NULL</front>
<front id="fastioH-975"></front>
<front id="fastioH-976">#define	DIO1_PIN		PINE1</front>
<front id="fastioH-977">#define	DIO1_RPORT	PINE</front>
<front id="fastioH-978">#define	DIO1_WPORT	PORTE</front>
<front id="fastioH-979">#define	DIO1_DDR		DDRE</front>
<front id="fastioH-980">#define DIO1_PWM		NULL</front>
<front id="fastioH-981"></front>
<front id="fastioH-982">#define	DIO2_PIN		PINE4</front>
<front id="fastioH-983">#define	DIO2_RPORT	PINE</front>
<front id="fastioH-984">#define	DIO2_WPORT	PORTE</front>
<front id="fastioH-985">#define	DIO2_DDR		DDRE</front>
<front id="fastioH-986">#define DIO2_PWM		&OCR3BL</front>
<front id="fastioH-987"></front>
<front id="fastioH-988">#define	DIO3_PIN		PINE5</front>
<front id="fastioH-989">#define	DIO3_RPORT	PINE</front>
<front id="fastioH-990">#define	DIO3_WPORT	PORTE</front>
<front id="fastioH-991">#define	DIO3_DDR		DDRE</front>
<front id="fastioH-992">#define DIO3_PWM		&OCR3CL</front>
<front id="fastioH-993"></front>
<front id="fastioH-994">#define	DIO4_PIN		PING5</front>
<front id="fastioH-995">#define	DIO4_RPORT	PING</front>
<front id="fastioH-996">#define	DIO4_WPORT	PORTG</front>
<front id="fastioH-997">#define	DIO4_DDR		DDRG</front>
<front id="fastioH-998">#define DIO4_PWM		&OCR0B</front>
<front id="fastioH-999"></front>
<front id="fastioH-1000">#define	DIO5_PIN		PINE3</front>
<front id="fastioH-1001">#define	DIO5_RPORT	PINE</front>
<front id="fastioH-1002">#define	DIO5_WPORT	PORTE</front>
<front id="fastioH-1003">#define	DIO5_DDR		DDRE</front>
<front id="fastioH-1004">#define DIO5_PWM		&OCR3AL</front>
<front id="fastioH-1005"></front>
<front id="fastioH-1006">#define	DIO6_PIN		PINH3</front>
<front id="fastioH-1007">#define	DIO6_RPORT	PINH</front>
<front id="fastioH-1008">#define	DIO6_WPORT	PORTH</front>
<front id="fastioH-1009">#define	DIO6_DDR		DDRH</front>
<front id="fastioH-1010">#define DIO6_PWM		&OCR4AL</front>
<front id="fastioH-1011"></front>
<front id="fastioH-1012">#define	DIO7_PIN		PINH4</front>
<front id="fastioH-1013">#define	DIO7_RPORT	PINH</front>
<front id="fastioH-1014">#define	DIO7_WPORT	PORTH</front>
<front id="fastioH-1015">#define	DIO7_DDR		DDRH</front>
<front id="fastioH-1016">#define DIO7_PWM		&OCR4BL</front>
<front id="fastioH-1017"></front>
<front id="fastioH-1018">#define	DIO8_PIN		PINH5</front>
<front id="fastioH-1019">#define	DIO8_RPORT	PINH</front>
<front id="fastioH-1020">#define	DIO8_WPORT	PORTH</front>
<front id="fastioH-1021">#define	DIO8_DDR		DDRH</front>
<front id="fastioH-1022">#define DIO8_PWM		&OCR4CL</front>
<front id="fastioH-1023"></front>
<front id="fastioH-1024">#define	DIO9_PIN		PINH6</front>
<front id="fastioH-1025">#define	DIO9_RPORT	PINH</front>
<front id="fastioH-1026">#define	DIO9_WPORT	PORTH</front>
<front id="fastioH-1027">#define	DIO9_DDR		DDRH</front>
<front id="fastioH-1028">#define DIO9_PWM		&OCR2B</front>
<front id="fastioH-1029"></front>
<front id="fastioH-1030">#define	DIO10_PIN		PINB4</front>
<front id="fastioH-1031">#define	DIO10_RPORT	PINB</front>
<front id="fastioH-1032">#define	DIO10_WPORT	PORTB</front>
<front id="fastioH-1033">#define	DIO10_DDR		DDRB</front>
<front id="fastioH-1034">#define DIO10_PWM		&OCR2A</front>
<front id="fastioH-1035"></front>
<front id="fastioH-1036">#define	DIO11_PIN		PINB5</front>
<front id="fastioH-1037">#define	DIO11_RPORT	PINB</front>
<front id="fastioH-1038">#define	DIO11_WPORT	PORTB</front>
<front id="fastioH-1039">#define	DIO11_DDR		DDRB</front>
<front id="fastioH-1040">#define DIO11_PWM		NULL</front>
<front id="fastioH-1041"></front>
<front id="fastioH-1042">#define	DIO12_PIN		PINB6</front>
<front id="fastioH-1043">#define	DIO12_RPORT	PINB</front>
<front id="fastioH-1044">#define	DIO12_WPORT	PORTB</front>
<front id="fastioH-1045">#define	DIO12_DDR		DDRB</front>
<front id="fastioH-1046">#define DIO12_PWM		NULL</front>
<front id="fastioH-1047"></front>
<front id="fastioH-1048">#define	DIO13_PIN		PINB7</front>
<front id="fastioH-1049">#define	DIO13_RPORT	PINB</front>
<front id="fastioH-1050">#define	DIO13_WPORT	PORTB</front>
<front id="fastioH-1051">#define	DIO13_DDR		DDRB</front>
<front id="fastioH-1052">#define DIO13_PWM		&OCR0A</front>
<front id="fastioH-1053"></front>
<front id="fastioH-1054">#define	DIO14_PIN		PINJ1</front>
<front id="fastioH-1055">#define	DIO14_RPORT	PINJ</front>
<front id="fastioH-1056">#define	DIO14_WPORT	PORTJ</front>
<front id="fastioH-1057">#define	DIO14_DDR		DDRJ</front>
<front id="fastioH-1058">#define DIO14_PWM		NULL</front>
<front id="fastioH-1059"></front>
<front id="fastioH-1060">#define	DIO15_PIN		PINJ0</front>
<front id="fastioH-1061">#define	DIO15_RPORT	PINJ</front>
<front id="fastioH-1062">#define	DIO15_WPORT	PORTJ</front>
<front id="fastioH-1063">#define	DIO15_DDR		DDRJ</front>
<front id="fastioH-1064">#define DIO15_PWM		NULL</front>
<front id="fastioH-1065"></front>
<front id="fastioH-1066">#define	DIO16_PIN		PINH1</front>
<front id="fastioH-1067">#define	DIO16_RPORT	PINH</front>
<front id="fastioH-1068">#define	DIO16_WPORT	PORTH</front>
<front id="fastioH-1069">#define	DIO16_DDR		DDRH</front>
<front id="fastioH-1070">#define DIO16_PWM		NULL</front>
<front id="fastioH-1071"></front>
<front id="fastioH-1072">#define	DIO17_PIN		PINH0</front>
<front id="fastioH-1073">#define	DIO17_RPORT	PINH</front>
<front id="fastioH-1074">#define	DIO17_WPORT	PORTH</front>
<front id="fastioH-1075">#define	DIO17_DDR		DDRH</front>
<front id="fastioH-1076">#define DIO17_PWM		NULL</front>
<front id="fastioH-1077"></front>
<front id="fastioH-1078">#define	DIO18_PIN		PIND3</front>
<front id="fastioH-1079">#define	DIO18_RPORT	PIND</front>
<front id="fastioH-1080">#define	DIO18_WPORT	PORTD</front>
<front id="fastioH-1081">#define	DIO18_DDR		DDRD</front>
<front id="fastioH-1082">#define DIO18_PWM		NULL</front>
<front id="fastioH-1083"></front>
<front id="fastioH-1084">#define	DIO19_PIN		PIND2</front>
<front id="fastioH-1085">#define	DIO19_RPORT	PIND</front>
<front id="fastioH-1086">#define	DIO19_WPORT	PORTD</front>
<front id="fastioH-1087">#define	DIO19_DDR		DDRD</front>
<front id="fastioH-1088">#define DIO19_PWM		NULL</front>
<front id="fastioH-1089"></front>
<front id="fastioH-1090">#define	DIO20_PIN		PIND1</front>
<front id="fastioH-1091">#define	DIO20_RPORT	PIND</front>
<front id="fastioH-1092">#define	DIO20_WPORT	PORTD</front>
<front id="fastioH-1093">#define	DIO20_DDR		DDRD</front>
<front id="fastioH-1094">#define DIO20_PWM		NULL</front>
<front id="fastioH-1095"></front>
<front id="fastioH-1096">#define	DIO21_PIN		PIND0</front>
<front id="fastioH-1097">#define	DIO21_RPORT	PIND</front>
<front id="fastioH-1098">#define	DIO21_WPORT	PORTD</front>
<front id="fastioH-1099">#define	DIO21_DDR		DDRD</front>
<front id="fastioH-1100">#define DIO21_PWM		NULL</front>
<front id="fastioH-1101"></front>
<front id="fastioH-1102">#define	DIO22_PIN		PINA0</front>
<front id="fastioH-1103">#define	DIO22_RPORT	PINA</front>
<front id="fastioH-1104">#define	DIO22_WPORT	PORTA</front>
<front id="fastioH-1105">#define	DIO22_DDR		DDRA</front>
<front id="fastioH-1106">#define DIO22_PWM		NULL</front>
<front id="fastioH-1107"></front>
<front id="fastioH-1108">#define	DIO23_PIN		PINA1</front>
<front id="fastioH-1109">#define	DIO23_RPORT	PINA</front>
<front id="fastioH-1110">#define	DIO23_WPORT	PORTA</front>
<front id="fastioH-1111">#define	DIO23_DDR		DDRA</front>
<front id="fastioH-1112">#define DIO23_PWM		NULL</front>
<front id="fastioH-1113"></front>
<front id="fastioH-1114">#define	DIO24_PIN		PINA2</front>
<front id="fastioH-1115">#define	DIO24_RPORT	PINA</front>
<front id="fastioH-1116">#define	DIO24_WPORT	PORTA</front>
<front id="fastioH-1117">#define	DIO24_DDR		DDRA</front>
<front id="fastioH-1118">#define DIO24_PWM		NULL</front>
<front id="fastioH-1119"></front>
<front id="fastioH-1120">#define	DIO25_PIN		PINA3</front>
<front id="fastioH-1121">#define	DIO25_RPORT	PINA</front>
<front id="fastioH-1122">#define	DIO25_WPORT	PORTA</front>
<front id="fastioH-1123">#define	DIO25_DDR		DDRA</front>
<front id="fastioH-1124">#define DIO25_PWM		NULL</front>
<front id="fastioH-1125"></front>
<front id="fastioH-1126">#define	DIO26_PIN		PINA4</front>
<front id="fastioH-1127">#define	DIO26_RPORT	PINA</front>
<front id="fastioH-1128">#define	DIO26_WPORT	PORTA</front>
<front id="fastioH-1129">#define	DIO26_DDR		DDRA</front>
<front id="fastioH-1130">#define DIO26_PWM		NULL</front>
<front id="fastioH-1131"></front>
<front id="fastioH-1132">#define	DIO27_PIN		PINA5</front>
<front id="fastioH-1133">#define	DIO27_RPORT	PINA</front>
<front id="fastioH-1134">#define	DIO27_WPORT	PORTA</front>
<front id="fastioH-1135">#define	DIO27_DDR		DDRA</front>
<front id="fastioH-1136">#define DIO27_PWM		NULL</front>
<front id="fastioH-1137"></front>
<front id="fastioH-1138">#define	DIO28_PIN		PINA6</front>
<front id="fastioH-1139">#define	DIO28_RPORT	PINA</front>
<front id="fastioH-1140">#define	DIO28_WPORT	PORTA</front>
<front id="fastioH-1141">#define	DIO28_DDR		DDRA</front>
<front id="fastioH-1142">#define DIO28_PWM		NULL</front>
<front id="fastioH-1143"></front>
<front id="fastioH-1144">#define	DIO29_PIN		PINA7</front>
<front id="fastioH-1145">#define	DIO29_RPORT	PINA</front>
<front id="fastioH-1146">#define	DIO29_WPORT	PORTA</front>
<front id="fastioH-1147">#define	DIO29_DDR		DDRA</front>
<front id="fastioH-1148">#define DIO29_PWM		NULL</front>
<front id="fastioH-1149"></front>
<front id="fastioH-1150">#define	DIO30_PIN		PINC7</front>
<front id="fastioH-1151">#define	DIO30_RPORT	PINC</front>
<front id="fastioH-1152">#define	DIO30_WPORT	PORTC</front>
<front id="fastioH-1153">#define	DIO30_DDR		DDRC</front>
<front id="fastioH-1154">#define DIO30_PWM		NULL</front>
<front id="fastioH-1155"></front>
<front id="fastioH-1156">#define	DIO31_PIN		PINC6</front>
<front id="fastioH-1157">#define	DIO31_RPORT	PINC</front>
<front id="fastioH-1158">#define	DIO31_WPORT	PORTC</front>
<front id="fastioH-1159">#define	DIO31_DDR		DDRC</front>
<front id="fastioH-1160">#define DIO31_PWM		NULL</front>
<front id="fastioH-1161"></front>
<front id="fastioH-1162">#define	DIO32_PIN		PINC5</front>
<front id="fastioH-1163">#define	DIO32_RPORT	PINC</front>
<front id="fastioH-1164">#define	DIO32_WPORT	PORTC</front>
<front id="fastioH-1165">#define	DIO32_DDR		DDRC</front>
<front id="fastioH-1166">#define DIO32_PWM		NULL</front>
<front id="fastioH-1167"></front>
<front id="fastioH-1168">#define	DIO33_PIN		PINC4</front>
<front id="fastioH-1169">#define	DIO33_RPORT	PINC</front>
<front id="fastioH-1170">#define	DIO33_WPORT	PORTC</front>
<front id="fastioH-1171">#define	DIO33_DDR		DDRC</front>
<front id="fastioH-1172">#define DIO33_PWM		NULL</front>
<front id="fastioH-1173"></front>
<front id="fastioH-1174">#define	DIO34_PIN		PINC3</front>
<front id="fastioH-1175">#define	DIO34_RPORT	PINC</front>
<front id="fastioH-1176">#define	DIO34_WPORT	PORTC</front>
<front id="fastioH-1177">#define	DIO34_DDR		DDRC</front>
<front id="fastioH-1178">#define DIO34_PWM		NULL</front>
<front id="fastioH-1179"></front>
<front id="fastioH-1180">#define	DIO35_PIN		PINC2</front>
<front id="fastioH-1181">#define	DIO35_RPORT	PINC</front>
<front id="fastioH-1182">#define	DIO35_WPORT	PORTC</front>
<front id="fastioH-1183">#define	DIO35_DDR		DDRC</front>
<front id="fastioH-1184">#define DIO35_PWM		NULL</front>
<front id="fastioH-1185"></front>
<front id="fastioH-1186">#define	DIO36_PIN		PINC1</front>
<front id="fastioH-1187">#define	DIO36_RPORT	PINC</front>
<front id="fastioH-1188">#define	DIO36_WPORT	PORTC</front>
<front id="fastioH-1189">#define	DIO36_DDR		DDRC</front>
<front id="fastioH-1190">#define DIO36_PWM		NULL</front>
<front id="fastioH-1191"></front>
<front id="fastioH-1192">#define	DIO37_PIN		PINC0</front>
<front id="fastioH-1193">#define	DIO37_RPORT	PINC</front>
<front id="fastioH-1194">#define	DIO37_WPORT	PORTC</front>
<front id="fastioH-1195">#define	DIO37_DDR		DDRC</front>
<front id="fastioH-1196">#define DIO37_PWM		NULL</front>
<front id="fastioH-1197"></front>
<front id="fastioH-1198">#define	DIO38_PIN		PIND7</front>
<front id="fastioH-1199">#define	DIO38_RPORT	PIND</front>
<front id="fastioH-1200">#define	DIO38_WPORT	PORTD</front>
<front id="fastioH-1201">#define	DIO38_DDR		DDRD</front>
<front id="fastioH-1202">#define DIO38_PWM		NULL</front>
<front id="fastioH-1203"></front>
<front id="fastioH-1204">#define	DIO39_PIN		PING2</front>
<front id="fastioH-1205">#define	DIO39_RPORT	PING</front>
<front id="fastioH-1206">#define	DIO39_WPORT	PORTG</front>
<front id="fastioH-1207">#define	DIO39_DDR		DDRG</front>
<front id="fastioH-1208">#define DIO39_PWM		NULL</front>
<front id="fastioH-1209"></front>
<front id="fastioH-1210">#define	DIO40_PIN		PING1</front>
<front id="fastioH-1211">#define	DIO40_RPORT	PING</front>
<front id="fastioH-1212">#define	DIO40_WPORT	PORTG</front>
<front id="fastioH-1213">#define	DIO40_DDR		DDRG</front>
<front id="fastioH-1214">#define DIO40_PWM		NULL</front>
<front id="fastioH-1215"></front>
<front id="fastioH-1216">#define	DIO41_PIN		PING0</front>
<front id="fastioH-1217">#define	DIO41_RPORT	PING</front>
<front id="fastioH-1218">#define	DIO41_WPORT	PORTG</front>
<front id="fastioH-1219">#define	DIO41_DDR		DDRG</front>
<front id="fastioH-1220">#define DIO41_PWM		NULL</front>
<front id="fastioH-1221"></front>
<front id="fastioH-1222">#define	DIO42_PIN		PINL7</front>
<front id="fastioH-1223">#define	DIO42_RPORT	PINL</front>
<front id="fastioH-1224">#define	DIO42_WPORT	PORTL</front>
<front id="fastioH-1225">#define	DIO42_DDR		DDRL</front>
<front id="fastioH-1226">#define DIO42_PWM		NULL</front>
<front id="fastioH-1227"></front>
<front id="fastioH-1228">#define	DIO43_PIN		PINL6</front>
<front id="fastioH-1229">#define	DIO43_RPORT	PINL</front>
<front id="fastioH-1230">#define	DIO43_WPORT	PORTL</front>
<front id="fastioH-1231">#define	DIO43_DDR		DDRL</front>
<front id="fastioH-1232">#define DIO43_PWM		NULL</front>
<front id="fastioH-1233"></front>
<front id="fastioH-1234">#define	DIO44_PIN		PINL5</front>
<front id="fastioH-1235">#define	DIO44_RPORT	PINL</front>
<front id="fastioH-1236">#define	DIO44_WPORT	PORTL</front>
<front id="fastioH-1237">#define	DIO44_DDR		DDRL</front>
<front id="fastioH-1238">#define DIO44_PWM		&OCR5CL</front>
<front id="fastioH-1239"></front>
<front id="fastioH-1240">#define	DIO45_PIN		PINL4</front>
<front id="fastioH-1241">#define	DIO45_RPORT	PINL</front>
<front id="fastioH-1242">#define	DIO45_WPORT	PORTL</front>
<front id="fastioH-1243">#define	DIO45_DDR		DDRL</front>
<front id="fastioH-1244">#define DIO45_PWM		&OCR5BL</front>
<front id="fastioH-1245"></front>
<front id="fastioH-1246">#define	DIO46_PIN		PINL3</front>
<front id="fastioH-1247">#define	DIO46_RPORT	PINL</front>
<front id="fastioH-1248">#define	DIO46_WPORT	PORTL</front>
<front id="fastioH-1249">#define	DIO46_DDR		DDRL</front>
<front id="fastioH-1250">#define DIO46_PWM		&OCR5AL</front>
<front id="fastioH-1251"></front>
<front id="fastioH-1252">#define	DIO47_PIN		PINL2</front>
<front id="fastioH-1253">#define	DIO47_RPORT	PINL</front>
<front id="fastioH-1254">#define	DIO47_WPORT	PORTL</front>
<front id="fastioH-1255">#define	DIO47_DDR		DDRL</front>
<front id="fastioH-1256">#define DIO47_PWM		NULL</front>
<front id="fastioH-1257"></front>
<front id="fastioH-1258">#define	DIO48_PIN		PINL1</front>
<front id="fastioH-1259">#define	DIO48_RPORT	PINL</front>
<front id="fastioH-1260">#define	DIO48_WPORT	PORTL</front>
<front id="fastioH-1261">#define	DIO48_DDR		DDRL</front>
<front id="fastioH-1262">#define DIO48_PWM		NULL</front>
<front id="fastioH-1263"></front>
<front id="fastioH-1264">#define	DIO49_PIN		PINL0</front>
<front id="fastioH-1265">#define	DIO49_RPORT	PINL</front>
<front id="fastioH-1266">#define	DIO49_WPORT	PORTL</front>
<front id="fastioH-1267">#define	DIO49_DDR		DDRL</front>
<front id="fastioH-1268">#define DIO49_PWM		NULL</front>
<front id="fastioH-1269"></front>
<front id="fastioH-1270">#define	DIO50_PIN		PINB3</front>
<front id="fastioH-1271">#define	DIO50_RPORT	PINB</front>
<front id="fastioH-1272">#define	DIO50_WPORT	PORTB</front>
<front id="fastioH-1273">#define	DIO50_DDR		DDRB</front>
<front id="fastioH-1274">#define DIO50_PWM		NULL</front>
<front id="fastioH-1275"></front>
<front id="fastioH-1276">#define	DIO51_PIN		PINB2</front>
<front id="fastioH-1277">#define	DIO51_RPORT	PINB</front>
<front id="fastioH-1278">#define	DIO51_WPORT	PORTB</front>
<front id="fastioH-1279">#define	DIO51_DDR		DDRB</front>
<front id="fastioH-1280">#define DIO51_PWM		NULL</front>
<front id="fastioH-1281"></front>
<front id="fastioH-1282">#define	DIO52_PIN		PINB1</front>
<front id="fastioH-1283">#define	DIO52_RPORT	PINB</front>
<front id="fastioH-1284">#define	DIO52_WPORT	PORTB</front>
<front id="fastioH-1285">#define	DIO52_DDR		DDRB</front>
<front id="fastioH-1286">#define DIO52_PWM		NULL</front>
<front id="fastioH-1287"></front>
<front id="fastioH-1288">#define	DIO53_PIN		PINB0</front>
<front id="fastioH-1289">#define	DIO53_RPORT	PINB</front>
<front id="fastioH-1290">#define	DIO53_WPORT	PORTB</front>
<front id="fastioH-1291">#define	DIO53_DDR		DDRB</front>
<front id="fastioH-1292">#define DIO53_PWM		NULL</front>
<front id="fastioH-1293"></front>
<front id="fastioH-1294">#define DIO54_PIN		PINF0</front>
<front id="fastioH-1295">#define DIO54_RPORT	PINF</front>
<front id="fastioH-1296">#define DIO54_WPORT	PORTF</front>
<front id="fastioH-1297">#define DIO54_DDR		DDRF</front>
<front id="fastioH-1298">#define DIO54_PWM		NULL</front>
<front id="fastioH-1299"></front>
<front id="fastioH-1300">#define DIO55_PIN		PINF1</front>
<front id="fastioH-1301">#define DIO55_RPORT	PINF</front>
<front id="fastioH-1302">#define DIO55_WPORT	PORTF</front>
<front id="fastioH-1303">#define DIO55_DDR		DDRF</front>
<front id="fastioH-1304">#define DIO55_PWM		NULL</front>
<front id="fastioH-1305"></front>
<front id="fastioH-1306">#define DIO56_PIN		PINF2</front>
<front id="fastioH-1307">#define DIO56_RPORT	PINF</front>
<front id="fastioH-1308">#define DIO56_WPORT	PORTF</front>
<front id="fastioH-1309">#define DIO56_DDR		DDRF</front>
<front id="fastioH-1310">#define DIO56_PWM		NULL</front>
<front id="fastioH-1311"></front>
<front id="fastioH-1312">#define DIO57_PIN		PINF3</front>
<front id="fastioH-1313">#define DIO57_RPORT	PINF</front>
<front id="fastioH-1314">#define DIO57_WPORT	PORTF</front>
<front id="fastioH-1315">#define DIO57_DDR		DDRF</front>
<front id="fastioH-1316">#define DIO57_PWM		NULL</front>
<front id="fastioH-1317"></front>
<front id="fastioH-1318">#define DIO58_PIN		PINF4</front>
<front id="fastioH-1319">#define DIO58_RPORT	PINF</front>
<front id="fastioH-1320">#define DIO58_WPORT	PORTF</front>
<front id="fastioH-1321">#define DIO58_DDR		DDRF</front>
<front id="fastioH-1322">#define DIO58_PWM		NULL</front>
<front id="fastioH-1323"></front>
<front id="fastioH-1324">#define DIO59_PIN		PINF5</front>
<front id="fastioH-1325">#define DIO59_RPORT	PINF</front>
<front id="fastioH-1326">#define DIO59_WPORT	PORTF</front>
<front id="fastioH-1327">#define DIO59_DDR		DDRF</front>
<front id="fastioH-1328">#define DIO59_PWM		NULL</front>
<front id="fastioH-1329"></front>
<front id="fastioH-1330">#define DIO60_PIN		PINF6</front>
<front id="fastioH-1331">#define DIO60_RPORT	PINF</front>
<front id="fastioH-1332">#define DIO60_WPORT	PORTF</front>
<front id="fastioH-1333">#define DIO60_DDR		DDRF</front>
<front id="fastioH-1334">#define DIO60_PWM		NULL</front>
<front id="fastioH-1335"></front>
<front id="fastioH-1336">#define DIO61_PIN		PINF7</front>
<front id="fastioH-1337">#define DIO61_RPORT	PINF</front>
<front id="fastioH-1338">#define DIO61_WPORT	PORTF</front>
<front id="fastioH-1339">#define DIO61_DDR		DDRF</front>
<front id="fastioH-1340">#define DIO61_PWM		NULL</front>
<front id="fastioH-1341"></front>
<front id="fastioH-1342">#define DIO62_PIN		PINK0</front>
<front id="fastioH-1343">#define DIO62_RPORT	PINK</front>
<front id="fastioH-1344">#define DIO62_WPORT	PORTK</front>
<front id="fastioH-1345">#define DIO62_DDR		DDRK</front>
<front id="fastioH-1346">#define DIO62_PWM		NULL</front>
<front id="fastioH-1347"></front>
<front id="fastioH-1348">#define DIO63_PIN		PINK1</front>
<front id="fastioH-1349">#define DIO63_RPORT	PINK</front>
<front id="fastioH-1350">#define DIO63_WPORT	PORTK</front>
<front id="fastioH-1351">#define DIO63_DDR		DDRK</front>
<front id="fastioH-1352">#define DIO63_PWM		NULL</front>
<front id="fastioH-1353"></front>
<front id="fastioH-1354">#define DIO64_PIN		PINK2</front>
<front id="fastioH-1355">#define DIO64_RPORT	PINK</front>
<front id="fastioH-1356">#define DIO64_WPORT	PORTK</front>
<front id="fastioH-1357">#define DIO64_DDR		DDRK</front>
<front id="fastioH-1358">#define DIO64_PWM		NULL</front>
<front id="fastioH-1359"></front>
<front id="fastioH-1360">#define DIO65_PIN		PINK3</front>
<front id="fastioH-1361">#define DIO65_RPORT	PINK</front>
<front id="fastioH-1362">#define DIO65_WPORT	PORTK</front>
<front id="fastioH-1363">#define DIO65_DDR		DDRK</front>
<front id="fastioH-1364">#define DIO65_PWM		NULL</front>
<front id="fastioH-1365"></front>
<front id="fastioH-1366">#define DIO66_PIN		PINK4</front>
<front id="fastioH-1367">#define DIO66_RPORT	PINK</front>
<front id="fastioH-1368">#define DIO66_WPORT	PORTK</front>
<front id="fastioH-1369">#define DIO66_DDR		DDRK</front>
<front id="fastioH-1370">#define DIO66_PWM		NULL</front>
<front id="fastioH-1371"></front>
<front id="fastioH-1372">#define DIO67_PIN		PINK5</front>
<front id="fastioH-1373">#define DIO67_RPORT	PINK</front>
<front id="fastioH-1374">#define DIO67_WPORT	PORTK</front>
<front id="fastioH-1375">#define DIO67_DDR		DDRK</front>
<front id="fastioH-1376">#define DIO67_PWM		NULL</front>
<front id="fastioH-1377"></front>
<front id="fastioH-1378">#define DIO68_PIN		PINK6</front>
<front id="fastioH-1379">#define DIO68_RPORT	PINK</front>
<front id="fastioH-1380">#define DIO68_WPORT	PORTK</front>
<front id="fastioH-1381">#define DIO68_DDR		DDRK</front>
<front id="fastioH-1382">#define DIO68_PWM		NULL</front>
<front id="fastioH-1383"></front>
<front id="fastioH-1384">#define DIO69_PIN		PINK7</front>
<front id="fastioH-1385">#define DIO69_RPORT	PINK</front>
<front id="fastioH-1386">#define DIO69_WPORT	PORTK</front>
<front id="fastioH-1387">#define DIO69_DDR		DDRK</front>
<front id="fastioH-1388">#define DIO69_PWM		NULL</front>
<front id="fastioH-1389"></front>
<front id="fastioH-1390">#define DIO70_PIN		PING4</front>
<front id="fastioH-1391">#define DIO70_RPORT	PING</front>
<front id="fastioH-1392">#define DIO70_WPORT	PORTG</front>
<front id="fastioH-1393">#define DIO70_DDR		DDRG</front>
<front id="fastioH-1394">#define DIO70_PWM		NULL</front>
<front id="fastioH-1395"></front>
<front id="fastioH-1396">#define DIO71_PIN		PING3</front>
<front id="fastioH-1397">#define DIO71_RPORT	PING</front>
<front id="fastioH-1398">#define DIO71_WPORT	PORTG</front>
<front id="fastioH-1399">#define DIO71_DDR		DDRG</front>
<front id="fastioH-1400">#define DIO71_PWM		NULL</front>
<front id="fastioH-1401"></front>
<front id="fastioH-1402">#define DIO72_PIN		PINJ2</front>
<front id="fastioH-1403">#define DIO72_RPORT	PINJ</front>
<front id="fastioH-1404">#define DIO72_WPORT	PORTJ</front>
<front id="fastioH-1405">#define DIO72_DDR		DDRJ</front>
<front id="fastioH-1406">#define DIO72_PWM		NULL</front>
<front id="fastioH-1407"></front>
<front id="fastioH-1408">#define DIO73_PIN		PINJ3</front>
<front id="fastioH-1409">#define DIO73_RPORT	PINJ</front>
<front id="fastioH-1410">#define DIO73_WPORT	PORTJ</front>
<front id="fastioH-1411">#define DIO73_DDR		DDRJ</front>
<front id="fastioH-1412">#define DIO73_PWM		NULL</front>
<front id="fastioH-1413"></front>
<front id="fastioH-1414">#define DIO74_PIN		PINJ7</front>
<front id="fastioH-1415">#define DIO74_RPORT	PINJ</front>
<front id="fastioH-1416">#define DIO74_WPORT	PORTJ</front>
<front id="fastioH-1417">#define DIO74_DDR		DDRJ</front>
<front id="fastioH-1418">#define DIO74_PWM		NULL</front>
<front id="fastioH-1419"></front>
<front id="fastioH-1420">#define DIO75_PIN		PINJ4</front>
<front id="fastioH-1421">#define DIO75_RPORT	PINJ</front>
<front id="fastioH-1422">#define DIO75_WPORT	PORTJ</front>
<front id="fastioH-1423">#define DIO75_DDR		DDRJ</front>
<front id="fastioH-1424">#define DIO75_PWM		NULL</front>
<front id="fastioH-1425"></front>
<front id="fastioH-1426">#define DIO76_PIN		PINJ5</front>
<front id="fastioH-1427">#define DIO76_RPORT	PINJ</front>
<front id="fastioH-1428">#define DIO76_WPORT	PORTJ</front>
<front id="fastioH-1429">#define DIO76_DDR		DDRJ</front>
<front id="fastioH-1430">#define DIO76_PWM		NULL</front>
<front id="fastioH-1431"></front>
<front id="fastioH-1432">#define DIO77_PIN		PINJ6</front>
<front id="fastioH-1433">#define DIO77_RPORT	PINJ</front>
<front id="fastioH-1434">#define DIO77_WPORT	PORTJ</front>
<front id="fastioH-1435">#define DIO77_DDR		DDRJ</front>
<front id="fastioH-1436">#define DIO77_PWM		NULL</front>
<front id="fastioH-1437"></front>
<front id="fastioH-1438">#define DIO78_PIN		PINE2</front>
<front id="fastioH-1439">#define DIO78_RPORT	PINE</front>
<front id="fastioH-1440">#define DIO78_WPORT	PORTE</front>
<front id="fastioH-1441">#define DIO78_DDR		DDRE</front>
<front id="fastioH-1442">#define DIO78_PWM		NULL</front>
<front id="fastioH-1443"></front>
<front id="fastioH-1444">#define DIO79_PIN		PINE6</front>
<front id="fastioH-1445">#define DIO79_RPORT	PINE</front>
<front id="fastioH-1446">#define DIO79_WPORT	PORTE</front>
<front id="fastioH-1447">#define DIO79_DDR		DDRE</front>
<front id="fastioH-1448">#define DIO79_PWM		NULL</front>
<front id="fastioH-1449"></front>
<front id="fastioH-1450">#define DIO80_PIN		PINE7</front>
<front id="fastioH-1451">#define DIO80_RPORT	PINE</front>
<front id="fastioH-1452">#define DIO80_WPORT	PORTE</front>
<front id="fastioH-1453">#define DIO80_DDR		DDRE</front>
<front id="fastioH-1454">#define DIO80_PWM		NULL</front>
<front id="fastioH-1455"></front>
<front id="fastioH-1456">#define DIO81_PIN		PIND4</front>
<front id="fastioH-1457">#define DIO81_RPORT	PIND</front>
<front id="fastioH-1458">#define DIO81_WPORT	PORTD</front>
<front id="fastioH-1459">#define DIO81_DDR		DDRD</front>
<front id="fastioH-1460">#define DIO81_PWM		NULL</front>
<front id="fastioH-1461"></front>
<front id="fastioH-1462">#define DIO82_PIN		PIND5</front>
<front id="fastioH-1463">#define DIO82_RPORT	PIND</front>
<front id="fastioH-1464">#define DIO82_WPORT	PORTD</front>
<front id="fastioH-1465">#define DIO82_DDR		DDRD</front>
<front id="fastioH-1466">#define DIO82_PWM		NULL</front>
<front id="fastioH-1467"></front>
<front id="fastioH-1468">#define DIO83_PIN		PIND6</front>
<front id="fastioH-1469">#define DIO83_RPORT	PIND</front>
<front id="fastioH-1470">#define DIO83_WPORT	PORTD</front>
<front id="fastioH-1471">#define DIO83_DDR		DDRD</front>
<front id="fastioH-1472">#define DIO83_PWM		NULL</front>
<front id="fastioH-1473"></front>
<front id="fastioH-1474">#define DIO84_PIN		PINH2</front>
<front id="fastioH-1475">#define DIO84_RPORT	PINH</front>
<front id="fastioH-1476">#define DIO84_WPORT	PORTH</front>
<front id="fastioH-1477">#define DIO84_DDR		DDRH</front>
<front id="fastioH-1478">#define DIO84_PWM		NULL</front>
<front id="fastioH-1479"></front>
<front id="fastioH-1480">#define DIO85_PIN		PINH7</front>
<front id="fastioH-1481">#define DIO85_RPORT	PINH</front>
<front id="fastioH-1482">#define DIO85_WPORT	PORTH</front>
<front id="fastioH-1483">#define DIO85_DDR		DDRH</front>
<front id="fastioH-1484">#define DIO85_PWM		NULL</front>
<front id="fastioH-1485"></front>
<front id="fastioH-1486">#undef PA0</front>
<front id="fastioH-1487">#define PA0_PIN			PINA0</front>
<front id="fastioH-1488">#define PA0_RPORT		PINA</front>
<front id="fastioH-1489">#define PA0_WPORT		PORTA</front>
<front id="fastioH-1490">#define PA0_DDR			DDRA</front>
<front id="fastioH-1491">#define PA0_PWM			NULL</front>
<front id="fastioH-1492">#undef PA1</front>
<front id="fastioH-1493">#define PA1_PIN			PINA1</front>
<front id="fastioH-1494">#define PA1_RPORT		PINA</front>
<front id="fastioH-1495">#define PA1_WPORT		PORTA</front>
<front id="fastioH-1496">#define PA1_DDR			DDRA</front>
<front id="fastioH-1497">#define PA1_PWM			NULL</front>
<front id="fastioH-1498">#undef PA2</front>
<front id="fastioH-1499">#define PA2_PIN			PINA2</front>
<front id="fastioH-1500">#define PA2_RPORT		PINA</front>
<front id="fastioH-1501">#define PA2_WPORT		PORTA</front>
<front id="fastioH-1502">#define PA2_DDR			DDRA</front>
<front id="fastioH-1503">#define PA2_PWM			NULL</front>
<front id="fastioH-1504">#undef PA3</front>
<front id="fastioH-1505">#define PA3_PIN			PINA3</front>
<front id="fastioH-1506">#define PA3_RPORT		PINA</front>
<front id="fastioH-1507">#define PA3_WPORT		PORTA</front>
<front id="fastioH-1508">#define PA3_DDR			DDRA</front>
<front id="fastioH-1509">#define PA3_PWM			NULL</front>
<front id="fastioH-1510">#undef PA4</front>
<front id="fastioH-1511">#define PA4_PIN			PINA4</front>
<front id="fastioH-1512">#define PA4_RPORT		PINA</front>
<front id="fastioH-1513">#define PA4_WPORT		PORTA</front>
<front id="fastioH-1514">#define PA4_DDR			DDRA</front>
<front id="fastioH-1515">#define PA4_PWM			NULL</front>
<front id="fastioH-1516">#undef PA5</front>
<front id="fastioH-1517">#define PA5_PIN			PINA5</front>
<front id="fastioH-1518">#define PA5_RPORT		PINA</front>
<front id="fastioH-1519">#define PA5_WPORT		PORTA</front>
<front id="fastioH-1520">#define PA5_DDR			DDRA</front>
<front id="fastioH-1521">#define PA5_PWM			NULL</front>
<front id="fastioH-1522">#undef PA6</front>
<front id="fastioH-1523">#define PA6_PIN			PINA6</front>
<front id="fastioH-1524">#define PA6_RPORT		PINA</front>
<front id="fastioH-1525">#define PA6_WPORT		PORTA</front>
<front id="fastioH-1526">#define PA6_DDR			DDRA</front>
<front id="fastioH-1527">#define PA6_PWM			NULL</front>
<front id="fastioH-1528">#undef PA7</front>
<front id="fastioH-1529">#define PA7_PIN			PINA7</front>
<front id="fastioH-1530">#define PA7_RPORT		PINA</front>
<front id="fastioH-1531">#define PA7_WPORT		PORTA</front>
<front id="fastioH-1532">#define PA7_DDR			DDRA</front>
<front id="fastioH-1533">#define PA7_PWM			NULL</front>
<front id="fastioH-1534"></front>
<front id="fastioH-1535">#undef PB0</front>
<front id="fastioH-1536">#define PB0_PIN			PINB0</front>
<front id="fastioH-1537">#define PB0_RPORT		PINB</front>
<front id="fastioH-1538">#define PB0_WPORT		PORTB</front>
<front id="fastioH-1539">#define PB0_DDR			DDRB</front>
<front id="fastioH-1540">#define PB0_PWM			NULL</front>
<front id="fastioH-1541">#undef PB1</front>
<front id="fastioH-1542">#define PB1_PIN			PINB1</front>
<front id="fastioH-1543">#define PB1_RPORT		PINB</front>
<front id="fastioH-1544">#define PB1_WPORT		PORTB</front>
<front id="fastioH-1545">#define PB1_DDR			DDRB</front>
<front id="fastioH-1546">#define PB1_PWM			NULL</front>
<front id="fastioH-1547">#undef PB2</front>
<front id="fastioH-1548">#define PB2_PIN			PINB2</front>
<front id="fastioH-1549">#define PB2_RPORT		PINB</front>
<front id="fastioH-1550">#define PB2_WPORT		PORTB</front>
<front id="fastioH-1551">#define PB2_DDR			DDRB</front>
<front id="fastioH-1552">#define PB2_PWM			NULL</front>
<front id="fastioH-1553">#undef PB3</front>
<front id="fastioH-1554">#define PB3_PIN			PINB3</front>
<front id="fastioH-1555">#define PB3_RPORT		PINB</front>
<front id="fastioH-1556">#define PB3_WPORT		PORTB</front>
<front id="fastioH-1557">#define PB3_DDR			DDRB</front>
<front id="fastioH-1558">#define PB3_PWM			NULL</front>
<front id="fastioH-1559">#undef PB4</front>
<front id="fastioH-1560">#define PB4_PIN			PINB4</front>
<front id="fastioH-1561">#define PB4_RPORT		PINB</front>
<front id="fastioH-1562">#define PB4_WPORT		PORTB</front>
<front id="fastioH-1563">#define PB4_DDR			DDRB</front>
<front id="fastioH-1564">#define PB4_PWM			&OCR2A</front>
<front id="fastioH-1565">#undef PB5</front>
<front id="fastioH-1566">#define PB5_PIN			PINB5</front>
<front id="fastioH-1567">#define PB5_RPORT		PINB</front>
<front id="fastioH-1568">#define PB5_WPORT		PORTB</front>
<front id="fastioH-1569">#define PB5_DDR			DDRB</front>
<front id="fastioH-1570">#define PB5_PWM			NULL</front>
<front id="fastioH-1571">#undef PB6</front>
<front id="fastioH-1572">#define PB6_PIN			PINB6</front>
<front id="fastioH-1573">#define PB6_RPORT		PINB</front>
<front id="fastioH-1574">#define PB6_WPORT		PORTB</front>
<front id="fastioH-1575">#define PB6_DDR			DDRB</front>
<front id="fastioH-1576">#define PB6_PWM			NULL</front>
<front id="fastioH-1577">#undef PB7</front>
<front id="fastioH-1578">#define PB7_PIN			PINB7</front>
<front id="fastioH-1579">#define PB7_RPORT		PINB</front>
<front id="fastioH-1580">#define PB7_WPORT		PORTB</front>
<front id="fastioH-1581">#define PB7_DDR			DDRB</front>
<front id="fastioH-1582">#define PB7_PWM			&OCR0A</front>
<front id="fastioH-1583"></front>
<front id="fastioH-1584">#undef PC0</front>
<front id="fastioH-1585">#define PC0_PIN			PINC0</front>
<front id="fastioH-1586">#define PC0_RPORT		PINC</front>
<front id="fastioH-1587">#define PC0_WPORT		PORTC</front>
<front id="fastioH-1588">#define PC0_DDR			DDRC</front>
<front id="fastioH-1589">#define PC0_PWM			NULL</front>
<front id="fastioH-1590">#undef PC1</front>
<front id="fastioH-1591">#define PC1_PIN			PINC1</front>
<front id="fastioH-1592">#define PC1_RPORT		PINC</front>
<front id="fastioH-1593">#define PC1_WPORT		PORTC</front>
<front id="fastioH-1594">#define PC1_DDR			DDRC</front>
<front id="fastioH-1595">#define PC1_PWM			NULL</front>
<front id="fastioH-1596">#undef PC2</front>
<front id="fastioH-1597">#define PC2_PIN			PINC2</front>
<front id="fastioH-1598">#define PC2_RPORT		PINC</front>
<front id="fastioH-1599">#define PC2_WPORT		PORTC</front>
<front id="fastioH-1600">#define PC2_DDR			DDRC</front>
<front id="fastioH-1601">#define PC2_PWM			NULL</front>
<front id="fastioH-1602">#undef PC3</front>
<front id="fastioH-1603">#define PC3_PIN			PINC3</front>
<front id="fastioH-1604">#define PC3_RPORT		PINC</front>
<front id="fastioH-1605">#define PC3_WPORT		PORTC</front>
<front id="fastioH-1606">#define PC3_DDR			DDRC</front>
<front id="fastioH-1607">#define PC3_PWM			NULL</front>
<front id="fastioH-1608">#undef PC4</front>
<front id="fastioH-1609">#define PC4_PIN			PINC4</front>
<front id="fastioH-1610">#define PC4_RPORT		PINC</front>
<front id="fastioH-1611">#define PC4_WPORT		PORTC</front>
<front id="fastioH-1612">#define PC4_DDR			DDRC</front>
<front id="fastioH-1613">#define PC4_PWM			NULL</front>
<front id="fastioH-1614">#undef PC5</front>
<front id="fastioH-1615">#define PC5_PIN			PINC5</front>
<front id="fastioH-1616">#define PC5_RPORT		PINC</front>
<front id="fastioH-1617">#define PC5_WPORT		PORTC</front>
<front id="fastioH-1618">#define PC5_DDR			DDRC</front>
<front id="fastioH-1619">#define PC5_PWM			NULL</front>
<front id="fastioH-1620">#undef PC6</front>
<front id="fastioH-1621">#define PC6_PIN			PINC6</front>
<front id="fastioH-1622">#define PC6_RPORT		PINC</front>
<front id="fastioH-1623">#define PC6_WPORT		PORTC</front>
<front id="fastioH-1624">#define PC6_DDR			DDRC</front>
<front id="fastioH-1625">#define PC6_PWM			NULL</front>
<front id="fastioH-1626">#undef PC7</front>
<front id="fastioH-1627">#define PC7_PIN			PINC7</front>
<front id="fastioH-1628">#define PC7_RPORT		PINC</front>
<front id="fastioH-1629">#define PC7_WPORT		PORTC</front>
<front id="fastioH-1630">#define PC7_DDR			DDRC</front>
<front id="fastioH-1631">#define PC7_PWM			NULL</front>
<front id="fastioH-1632"></front>
<front id="fastioH-1633">#undef PD0</front>
<front id="fastioH-1634">#define PD0_PIN			PIND0</front>
<front id="fastioH-1635">#define PD0_RPORT		PIND</front>
<front id="fastioH-1636">#define PD0_WPORT		PORTD</front>
<front id="fastioH-1637">#define PD0_DDR			DDRD</front>
<front id="fastioH-1638">#define PD0_PWM			NULL</front>
<front id="fastioH-1639">#undef PD1</front>
<front id="fastioH-1640">#define PD1_PIN			PIND1</front>
<front id="fastioH-1641">#define PD1_RPORT		PIND</front>
<front id="fastioH-1642">#define PD1_WPORT		PORTD</front>
<front id="fastioH-1643">#define PD1_DDR			DDRD</front>
<front id="fastioH-1644">#define PD1_PWM			NULL</front>
<front id="fastioH-1645">#undef PD2</front>
<front id="fastioH-1646">#define PD2_PIN			PIND2</front>
<front id="fastioH-1647">#define PD2_RPORT		PIND</front>
<front id="fastioH-1648">#define PD2_WPORT		PORTD</front>
<front id="fastioH-1649">#define PD2_DDR			DDRD</front>
<front id="fastioH-1650">#define PD2_PWM			NULL</front>
<front id="fastioH-1651">#undef PD3</front>
<front id="fastioH-1652">#define PD3_PIN			PIND3</front>
<front id="fastioH-1653">#define PD3_RPORT		PIND</front>
<front id="fastioH-1654">#define PD3_WPORT		PORTD</front>
<front id="fastioH-1655">#define PD3_DDR			DDRD</front>
<front id="fastioH-1656">#define PD3_PWM			NULL</front>
<front id="fastioH-1657">#undef PD4</front>
<front id="fastioH-1658">#define PD4_PIN			PIND4</front>
<front id="fastioH-1659">#define PD4_RPORT		PIND</front>
<front id="fastioH-1660">#define PD4_WPORT		PORTD</front>
<front id="fastioH-1661">#define PD4_DDR			DDRD</front>
<front id="fastioH-1662">#define PD4_PWM			NULL</front>
<front id="fastioH-1663">#undef PD5</front>
<front id="fastioH-1664">#define PD5_PIN			PIND5</front>
<front id="fastioH-1665">#define PD5_RPORT		PIND</front>
<front id="fastioH-1666">#define PD5_WPORT		PORTD</front>
<front id="fastioH-1667">#define PD5_DDR			DDRD</front>
<front id="fastioH-1668">#define PD5_PWM			NULL</front>
<front id="fastioH-1669">#undef PD6</front>
<front id="fastioH-1670">#define PD6_PIN			PIND6</front>
<front id="fastioH-1671">#define PD6_RPORT		PIND</front>
<front id="fastioH-1672">#define PD6_WPORT		PORTD</front>
<front id="fastioH-1673">#define PD6_DDR			DDRD</front>
<front id="fastioH-1674">#define PD6_PWM			NULL</front>
<front id="fastioH-1675">#undef PD7</front>
<front id="fastioH-1676">#define PD7_PIN			PIND7</front>
<front id="fastioH-1677">#define PD7_RPORT		PIND</front>
<front id="fastioH-1678">#define PD7_WPORT		PORTD</front>
<front id="fastioH-1679">#define PD7_DDR			DDRD</front>
<front id="fastioH-1680">#define PD7_PWM			NULL</front>
<front id="fastioH-1681"></front>
<front id="fastioH-1682">#undef PE0</front>
<front id="fastioH-1683">#define PE0_PIN			PINE0</front>
<front id="fastioH-1684">#define PE0_RPORT		PINE</front>
<front id="fastioH-1685">#define PE0_WPORT		PORTE</front>
<front id="fastioH-1686">#define PE0_DDR			DDRE</front>
<front id="fastioH-1687">#define PE0_PWM			NULL</front>
<front id="fastioH-1688">#undef PE1</front>
<front id="fastioH-1689">#define PE1_PIN			PINE1</front>
<front id="fastioH-1690">#define PE1_RPORT		PINE</front>
<front id="fastioH-1691">#define PE1_WPORT		PORTE</front>
<front id="fastioH-1692">#define PE1_DDR			DDRE</front>
<front id="fastioH-1693">#define PE1_PWM			NULL</front>
<front id="fastioH-1694">#undef PE2</front>
<front id="fastioH-1695">#define PE2_PIN			PINE2</front>
<front id="fastioH-1696">#define PE2_RPORT		PINE</front>
<front id="fastioH-1697">#define PE2_WPORT		PORTE</front>
<front id="fastioH-1698">#define PE2_DDR			DDRE</front>
<front id="fastioH-1699">#define PE2_PWM			NULL</front>
<front id="fastioH-1700">#undef PE3</front>
<front id="fastioH-1701">#define PE3_PIN			PINE3</front>
<front id="fastioH-1702">#define PE3_RPORT		PINE</front>
<front id="fastioH-1703">#define PE3_WPORT		PORTE</front>
<front id="fastioH-1704">#define PE3_DDR			DDRE</front>
<front id="fastioH-1705">#define PE3_PWM			&OCR3AL</front>
<front id="fastioH-1706">#undef PE4</front>
<front id="fastioH-1707">#define PE4_PIN			PINE4</front>
<front id="fastioH-1708">#define PE4_RPORT		PINE</front>
<front id="fastioH-1709">#define PE4_WPORT		PORTE</front>
<front id="fastioH-1710">#define PE4_DDR			DDRE</front>
<front id="fastioH-1711">#define PE4_PWM			&OCR3BL</front>
<front id="fastioH-1712">#undef PE5</front>
<front id="fastioH-1713">#define PE5_PIN			PINE5</front>
<front id="fastioH-1714">#define PE5_RPORT		PINE</front>
<front id="fastioH-1715">#define PE5_WPORT		PORTE</front>
<front id="fastioH-1716">#define PE5_DDR			DDRE</front>
<front id="fastioH-1717">#define PE5_PWM			&OCR3CL</front>
<front id="fastioH-1718">#undef PE6</front>
<front id="fastioH-1719">#define PE6_PIN			PINE6</front>
<front id="fastioH-1720">#define PE6_RPORT		PINE</front>
<front id="fastioH-1721">#define PE6_WPORT		PORTE</front>
<front id="fastioH-1722">#define PE6_DDR			DDRE</front>
<front id="fastioH-1723">#define PE6_PWM			NULL</front>
<front id="fastioH-1724">#undef PE7</front>
<front id="fastioH-1725">#define PE7_PIN			PINE7</front>
<front id="fastioH-1726">#define PE7_RPORT		PINE</front>
<front id="fastioH-1727">#define PE7_WPORT		PORTE</front>
<front id="fastioH-1728">#define PE7_DDR			DDRE</front>
<front id="fastioH-1729">#define PE7_PWM			NULL</front>
<front id="fastioH-1730"></front>
<front id="fastioH-1731">#undef PF0</front>
<front id="fastioH-1732">#define PF0_PIN			PINF0</front>
<front id="fastioH-1733">#define PF0_RPORT		PINF</front>
<front id="fastioH-1734">#define PF0_WPORT		PORTF</front>
<front id="fastioH-1735">#define PF0_DDR			DDRF</front>
<front id="fastioH-1736">#define PF0_PWM			NULL</front>
<front id="fastioH-1737">#undef PF1</front>
<front id="fastioH-1738">#define PF1_PIN			PINF1</front>
<front id="fastioH-1739">#define PF1_RPORT		PINF</front>
<front id="fastioH-1740">#define PF1_WPORT		PORTF</front>
<front id="fastioH-1741">#define PF1_DDR			DDRF</front>
<front id="fastioH-1742">#define PF1_PWM			NULL</front>
<front id="fastioH-1743">#undef PF2</front>
<front id="fastioH-1744">#define PF2_PIN			PINF2</front>
<front id="fastioH-1745">#define PF2_RPORT		PINF</front>
<front id="fastioH-1746">#define PF2_WPORT		PORTF</front>
<front id="fastioH-1747">#define PF2_DDR			DDRF</front>
<front id="fastioH-1748">#define PF2_PWM			NULL</front>
<front id="fastioH-1749">#undef PF3</front>
<front id="fastioH-1750">#define PF3_PIN			PINF3</front>
<front id="fastioH-1751">#define PF3_RPORT		PINF</front>
<front id="fastioH-1752">#define PF3_WPORT		PORTF</front>
<front id="fastioH-1753">#define PF3_DDR			DDRF</front>
<front id="fastioH-1754">#define PF3_PWM			NULL</front>
<front id="fastioH-1755">#undef PF4</front>
<front id="fastioH-1756">#define PF4_PIN			PINF4</front>
<front id="fastioH-1757">#define PF4_RPORT		PINF</front>
<front id="fastioH-1758">#define PF4_WPORT		PORTF</front>
<front id="fastioH-1759">#define PF4_DDR			DDRF</front>
<front id="fastioH-1760">#define PF4_PWM			NULL</front>
<front id="fastioH-1761">#undef PF5</front>
<front id="fastioH-1762">#define PF5_PIN			PINF5</front>
<front id="fastioH-1763">#define PF5_RPORT		PINF</front>
<front id="fastioH-1764">#define PF5_WPORT		PORTF</front>
<front id="fastioH-1765">#define PF5_DDR			DDRF</front>
<front id="fastioH-1766">#define PF5_PWM			NULL</front>
<front id="fastioH-1767">#undef PF6</front>
<front id="fastioH-1768">#define PF6_PIN			PINF6</front>
<front id="fastioH-1769">#define PF6_RPORT		PINF</front>
<front id="fastioH-1770">#define PF6_WPORT		PORTF</front>
<front id="fastioH-1771">#define PF6_DDR			DDRF</front>
<front id="fastioH-1772">#define PF6_PWM			NULL</front>
<front id="fastioH-1773">#undef PF7</front>
<front id="fastioH-1774">#define PF7_PIN			PINF7</front>
<front id="fastioH-1775">#define PF7_RPORT		PINF</front>
<front id="fastioH-1776">#define PF7_WPORT		PORTF</front>
<front id="fastioH-1777">#define PF7_DDR			DDRF</front>
<front id="fastioH-1778">#define PF7_PWM			NULL</front>
<front id="fastioH-1779"></front>
<front id="fastioH-1780">#undef PG0</front>
<front id="fastioH-1781">#define PG0_PIN			PING0</front>
<front id="fastioH-1782">#define PG0_RPORT		PING</front>
<front id="fastioH-1783">#define PG0_WPORT		PORTG</front>
<front id="fastioH-1784">#define PG0_DDR			DDRG</front>
<front id="fastioH-1785">#define PG0_PWM			NULL</front>
<front id="fastioH-1786">#undef PG1</front>
<front id="fastioH-1787">#define PG1_PIN			PING1</front>
<front id="fastioH-1788">#define PG1_RPORT		PING</front>
<front id="fastioH-1789">#define PG1_WPORT		PORTG</front>
<front id="fastioH-1790">#define PG1_DDR			DDRG</front>
<front id="fastioH-1791">#define PG1_PWM			NULL</front>
<front id="fastioH-1792">#undef PG2</front>
<front id="fastioH-1793">#define PG2_PIN			PING2</front>
<front id="fastioH-1794">#define PG2_RPORT		PING</front>
<front id="fastioH-1795">#define PG2_WPORT		PORTG</front>
<front id="fastioH-1796">#define PG2_DDR			DDRG</front>
<front id="fastioH-1797">#define PG2_PWM			NULL</front>
<front id="fastioH-1798">#undef PG3</front>
<front id="fastioH-1799">#define PG3_PIN			PING3</front>
<front id="fastioH-1800">#define PG3_RPORT		PING</front>
<front id="fastioH-1801">#define PG3_WPORT		PORTG</front>
<front id="fastioH-1802">#define PG3_DDR			DDRG</front>
<front id="fastioH-1803">#define PG3_PWM			NULL</front>
<front id="fastioH-1804">#undef PG4</front>
<front id="fastioH-1805">#define PG4_PIN			PING4</front>
<front id="fastioH-1806">#define PG4_RPORT		PING</front>
<front id="fastioH-1807">#define PG4_WPORT		PORTG</front>
<front id="fastioH-1808">#define PG4_DDR			DDRG</front>
<front id="fastioH-1809">#define PG4_PWM			NULL</front>
<front id="fastioH-1810">#undef PG5</front>
<front id="fastioH-1811">#define PG5_PIN			PING5</front>
<front id="fastioH-1812">#define PG5_RPORT		PING</front>
<front id="fastioH-1813">#define PG5_WPORT		PORTG</front>
<front id="fastioH-1814">#define PG5_DDR			DDRG</front>
<front id="fastioH-1815">#define PG5_PWM			&OCR0B</front>
<front id="fastioH-1816">#undef PG6</front>
<front id="fastioH-1817">#define PG6_PIN			PING6</front>
<front id="fastioH-1818">#define PG6_RPORT		PING</front>
<front id="fastioH-1819">#define PG6_WPORT		PORTG</front>
<front id="fastioH-1820">#define PG6_DDR			DDRG</front>
<front id="fastioH-1821">#define PG6_PWM			NULL</front>
<front id="fastioH-1822">#undef PG7</front>
<front id="fastioH-1823">#define PG7_PIN			PING7</front>
<front id="fastioH-1824">#define PG7_RPORT		PING</front>
<front id="fastioH-1825">#define PG7_WPORT		PORTG</front>
<front id="fastioH-1826">#define PG7_DDR			DDRG</front>
<front id="fastioH-1827">#define PG7_PWM			NULL</front>
<front id="fastioH-1828"></front>
<front id="fastioH-1829">#undef PH0</front>
<front id="fastioH-1830">#define PH0_PIN			PINH0</front>
<front id="fastioH-1831">#define PH0_RPORT		PINH</front>
<front id="fastioH-1832">#define PH0_WPORT		PORTH</front>
<front id="fastioH-1833">#define PH0_DDR			DDRH</front>
<front id="fastioH-1834">#define PH0_PWM			NULL</front>
<front id="fastioH-1835">#undef PH1</front>
<front id="fastioH-1836">#define PH1_PIN			PINH1</front>
<front id="fastioH-1837">#define PH1_RPORT		PINH</front>
<front id="fastioH-1838">#define PH1_WPORT		PORTH</front>
<front id="fastioH-1839">#define PH1_DDR			DDRH</front>
<front id="fastioH-1840">#define PH1_PWM			NULL</front>
<front id="fastioH-1841">#undef PH2</front>
<front id="fastioH-1842">#define PH2_PIN			PINH2</front>
<front id="fastioH-1843">#define PH2_RPORT		PINH</front>
<front id="fastioH-1844">#define PH2_WPORT		PORTH</front>
<front id="fastioH-1845">#define PH2_DDR			DDRH</front>
<front id="fastioH-1846">#define PH2_PWM			NULL</front>
<front id="fastioH-1847">#undef PH3</front>
<front id="fastioH-1848">#define PH3_PIN			PINH3</front>
<front id="fastioH-1849">#define PH3_RPORT		PINH</front>
<front id="fastioH-1850">#define PH3_WPORT		PORTH</front>
<front id="fastioH-1851">#define PH3_DDR			DDRH</front>
<front id="fastioH-1852">#define PH3_PWM			&OCR4AL</front>
<front id="fastioH-1853">#undef PH4</front>
<front id="fastioH-1854">#define PH4_PIN			PINH4</front>
<front id="fastioH-1855">#define PH4_RPORT		PINH</front>
<front id="fastioH-1856">#define PH4_WPORT		PORTH</front>
<front id="fastioH-1857">#define PH4_DDR			DDRH</front>
<front id="fastioH-1858">#define PH4_PWM			&OCR4BL</front>
<front id="fastioH-1859">#undef PH5</front>
<front id="fastioH-1860">#define PH5_PIN			PINH5</front>
<front id="fastioH-1861">#define PH5_RPORT		PINH</front>
<front id="fastioH-1862">#define PH5_WPORT		PORTH</front>
<front id="fastioH-1863">#define PH5_DDR			DDRH</front>
<front id="fastioH-1864">#define PH5_PWM			&OCR4CL</front>
<front id="fastioH-1865">#undef PH6</front>
<front id="fastioH-1866">#define PH6_PIN			PINH6</front>
<front id="fastioH-1867">#define PH6_RPORT		PINH</front>
<front id="fastioH-1868">#define PH6_WPORT		PORTH</front>
<front id="fastioH-1869">#define PH6_DDR			DDRH</front>
<front id="fastioH-1870">#define PH6_PWM			&OCR2B</front>
<front id="fastioH-1871">#undef PH7</front>
<front id="fastioH-1872">#define PH7_PIN			PINH7</front>
<front id="fastioH-1873">#define PH7_RPORT		PINH</front>
<front id="fastioH-1874">#define PH7_WPORT		PORTH</front>
<front id="fastioH-1875">#define PH7_DDR			DDRH</front>
<front id="fastioH-1876">#define PH7_PWM			NULL</front>
<front id="fastioH-1877"></front>
<front id="fastioH-1878">#undef PJ0</front>
<front id="fastioH-1879">#define PJ0_PIN			PINJ0</front>
<front id="fastioH-1880">#define PJ0_RPORT		PINJ</front>
<front id="fastioH-1881">#define PJ0_WPORT		PORTJ</front>
<front id="fastioH-1882">#define PJ0_DDR			DDRJ</front>
<front id="fastioH-1883">#define PJ0_PWM			NULL</front>
<front id="fastioH-1884">#undef PJ1</front>
<front id="fastioH-1885">#define PJ1_PIN			PINJ1</front>
<front id="fastioH-1886">#define PJ1_RPORT		PINJ</front>
<front id="fastioH-1887">#define PJ1_WPORT		PORTJ</front>
<front id="fastioH-1888">#define PJ1_DDR			DDRJ</front>
<front id="fastioH-1889">#define PJ1_PWM			NULL</front>
<front id="fastioH-1890">#undef PJ2</front>
<front id="fastioH-1891">#define PJ2_PIN			PINJ2</front>
<front id="fastioH-1892">#define PJ2_RPORT		PINJ</front>
<front id="fastioH-1893">#define PJ2_WPORT		PORTJ</front>
<front id="fastioH-1894">#define PJ2_DDR			DDRJ</front>
<front id="fastioH-1895">#define PJ2_PWM			NULL</front>
<front id="fastioH-1896">#undef PJ3</front>
<front id="fastioH-1897">#define PJ3_PIN			PINJ3</front>
<front id="fastioH-1898">#define PJ3_RPORT		PINJ</front>
<front id="fastioH-1899">#define PJ3_WPORT		PORTJ</front>
<front id="fastioH-1900">#define PJ3_DDR			DDRJ</front>
<front id="fastioH-1901">#define PJ3_PWM			NULL</front>
<front id="fastioH-1902">#undef PJ4</front>
<front id="fastioH-1903">#define PJ4_PIN			PINJ4</front>
<front id="fastioH-1904">#define PJ4_RPORT		PINJ</front>
<front id="fastioH-1905">#define PJ4_WPORT		PORTJ</front>
<front id="fastioH-1906">#define PJ4_DDR			DDRJ</front>
<front id="fastioH-1907">#define PJ4_PWM			NULL</front>
<front id="fastioH-1908">#undef PJ5</front>
<front id="fastioH-1909">#define PJ5_PIN			PINJ5</front>
<front id="fastioH-1910">#define PJ5_RPORT		PINJ</front>
<front id="fastioH-1911">#define PJ5_WPORT		PORTJ</front>
<front id="fastioH-1912">#define PJ5_DDR			DDRJ</front>
<front id="fastioH-1913">#define PJ5_PWM			NULL</front>
<front id="fastioH-1914">#undef PJ6</front>
<front id="fastioH-1915">#define PJ6_PIN			PINJ6</front>
<front id="fastioH-1916">#define PJ6_RPORT		PINJ</front>
<front id="fastioH-1917">#define PJ6_WPORT		PORTJ</front>
<front id="fastioH-1918">#define PJ6_DDR			DDRJ</front>
<front id="fastioH-1919">#define PJ6_PWM			NULL</front>
<front id="fastioH-1920">#undef PJ7</front>
<front id="fastioH-1921">#define PJ7_PIN			PINJ7</front>
<front id="fastioH-1922">#define PJ7_RPORT		PINJ</front>
<front id="fastioH-1923">#define PJ7_WPORT		PORTJ</front>
<front id="fastioH-1924">#define PJ7_DDR			DDRJ</front>
<front id="fastioH-1925">#define PJ7_PWM			NULL</front>
<front id="fastioH-1926"></front>
<front id="fastioH-1927">#undef PK0</front>
<front id="fastioH-1928">#define PK0_PIN			PINK0</front>
<front id="fastioH-1929">#define PK0_RPORT		PINK</front>
<front id="fastioH-1930">#define PK0_WPORT		PORTK</front>
<front id="fastioH-1931">#define PK0_DDR			DDRK</front>
<front id="fastioH-1932">#define PK0_PWM			NULL</front>
<front id="fastioH-1933">#undef PK1</front>
<front id="fastioH-1934">#define PK1_PIN			PINK1</front>
<front id="fastioH-1935">#define PK1_RPORT		PINK</front>
<front id="fastioH-1936">#define PK1_WPORT		PORTK</front>
<front id="fastioH-1937">#define PK1_DDR			DDRK</front>
<front id="fastioH-1938">#define PK1_PWM			NULL</front>
<front id="fastioH-1939">#undef PK2</front>
<front id="fastioH-1940">#define PK2_PIN			PINK2</front>
<front id="fastioH-1941">#define PK2_RPORT		PINK</front>
<front id="fastioH-1942">#define PK2_WPORT		PORTK</front>
<front id="fastioH-1943">#define PK2_DDR			DDRK</front>
<front id="fastioH-1944">#define PK2_PWM			NULL</front>
<front id="fastioH-1945">#undef PK3</front>
<front id="fastioH-1946">#define PK3_PIN			PINK3</front>
<front id="fastioH-1947">#define PK3_RPORT		PINK</front>
<front id="fastioH-1948">#define PK3_WPORT		PORTK</front>
<front id="fastioH-1949">#define PK3_DDR			DDRK</front>
<front id="fastioH-1950">#define PK3_PWM			NULL</front>
<front id="fastioH-1951">#undef PK4</front>
<front id="fastioH-1952">#define PK4_PIN			PINK4</front>
<front id="fastioH-1953">#define PK4_RPORT		PINK</front>
<front id="fastioH-1954">#define PK4_WPORT		PORTK</front>
<front id="fastioH-1955">#define PK4_DDR			DDRK</front>
<front id="fastioH-1956">#define PK4_PWM			NULL</front>
<front id="fastioH-1957">#undef PK5</front>
<front id="fastioH-1958">#define PK5_PIN			PINK5</front>
<front id="fastioH-1959">#define PK5_RPORT		PINK</front>
<front id="fastioH-1960">#define PK5_WPORT		PORTK</front>
<front id="fastioH-1961">#define PK5_DDR			DDRK</front>
<front id="fastioH-1962">#define PK5_PWM			NULL</front>
<front id="fastioH-1963">#undef PK6</front>
<front id="fastioH-1964">#define PK6_PIN			PINK6</front>
<front id="fastioH-1965">#define PK6_RPORT		PINK</front>
<front id="fastioH-1966">#define PK6_WPORT		PORTK</front>
<front id="fastioH-1967">#define PK6_DDR			DDRK</front>
<front id="fastioH-1968">#define PK6_PWM			NULL</front>
<front id="fastioH-1969">#undef PK7</front>
<front id="fastioH-1970">#define PK7_PIN			PINK7</front>
<front id="fastioH-1971">#define PK7_RPORT		PINK</front>
<front id="fastioH-1972">#define PK7_WPORT		PORTK</front>
<front id="fastioH-1973">#define PK7_DDR			DDRK</front>
<front id="fastioH-1974">#define PK7_PWM			NULL</front>
<front id="fastioH-1975"></front>
<front id="fastioH-1976">#undef PL0</front>
<front id="fastioH-1977">#define PL0_PIN			PINL0</front>
<front id="fastioH-1978">#define PL0_RPORT		PINL</front>
<front id="fastioH-1979">#define PL0_WPORT		PORTL</front>
<front id="fastioH-1980">#define PL0_DDR			DDRL</front>
<front id="fastioH-1981">#define PL0_PWM			NULL</front>
<front id="fastioH-1982">#undef PL1</front>
<front id="fastioH-1983">#define PL1_PIN			PINL1</front>
<front id="fastioH-1984">#define PL1_RPORT		PINL</front>
<front id="fastioH-1985">#define PL1_WPORT		PORTL</front>
<front id="fastioH-1986">#define PL1_DDR			DDRL</front>
<front id="fastioH-1987">#define PL1_PWM			NULL</front>
<front id="fastioH-1988">#undef PL2</front>
<front id="fastioH-1989">#define PL2_PIN			PINL2</front>
<front id="fastioH-1990">#define PL2_RPORT		PINL</front>
<front id="fastioH-1991">#define PL2_WPORT		PORTL</front>
<front id="fastioH-1992">#define PL2_DDR			DDRL</front>
<front id="fastioH-1993">#define PL2_PWM			NULL</front>
<front id="fastioH-1994">#undef PL3</front>
<front id="fastioH-1995">#define PL3_PIN			PINL3</front>
<front id="fastioH-1996">#define PL3_RPORT		PINL</front>
<front id="fastioH-1997">#define PL3_WPORT		PORTL</front>
<front id="fastioH-1998">#define PL3_DDR			DDRL</front>
<front id="fastioH-1999">#define PL3_PWM			&OCR5AL</front>
<front id="fastioH-2000">#undef PL4</front>
<front id="fastioH-2001">#define PL4_PIN			PINL4</front>
<front id="fastioH-2002">#define PL4_RPORT		PINL</front>
<front id="fastioH-2003">#define PL4_WPORT		PORTL</front>
<front id="fastioH-2004">#define PL4_DDR			DDRL</front>
<front id="fastioH-2005">#define PL4_PWM			&OCR5BL</front>
<front id="fastioH-2006">#undef PL5</front>
<front id="fastioH-2007">#define PL5_PIN			PINL5</front>
<front id="fastioH-2008">#define PL5_RPORT		PINL</front>
<front id="fastioH-2009">#define PL5_WPORT		PORTL</front>
<front id="fastioH-2010">#define PL5_DDR			DDRL</front>
<front id="fastioH-2011">#define PL5_PWM			&OCR5CL</front>
<front id="fastioH-2012">#undef PL6</front>
<front id="fastioH-2013">#define PL6_PIN			PINL6</front>
<front id="fastioH-2014">#define PL6_RPORT		PINL</front>
<front id="fastioH-2015">#define PL6_WPORT		PORTL</front>
<front id="fastioH-2016">#define PL6_DDR			DDRL</front>
<front id="fastioH-2017">#define PL6_PWM			NULL</front>
<front id="fastioH-2018">#undef PL7</front>
<front id="fastioH-2019">#define PL7_PIN			PINL7</front>
<front id="fastioH-2020">#define PL7_RPORT		PINL</front>
<front id="fastioH-2021">#define PL7_WPORT		PORTL</front>
<front id="fastioH-2022">#define PL7_DDR			DDRL</front>
<front id="fastioH-2023">#define PL7_PWM			NULL</front>
<front id="fastioH-2024"></front>
<front id="fastioH-2025">#endif</front>
<front id="fastioH-2026"></front>
<front id="fastioH-2027">#if defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__) || defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB647__)</front>
<front id="fastioH-2028">// SPI</front>
<front id="fastioH-2029">#define	SCK					DIO9</front>
<front id="fastioH-2030">#define	MISO				DIO11</front>
<front id="fastioH-2031">#define	MOSI				DIO10</front>
<front id="fastioH-2032">#define	SS					DIO8</front>
<front id="fastioH-2033"></front>
<front id="fastioH-2034">// change for your board</front>
<front id="fastioH-2035">#define	DEBUG_LED		DIO31 /* led D5 red */</front>
<front id="fastioH-2036"></front>
<front id="fastioH-2037">/*</front>
<front id="fastioH-2038">pins</front>
<front id="fastioH-2039">*/</front>
<front id="fastioH-2040"></front>
<front id="fastioH-2041">//#define AT90USBxx_TEENSYPP_ASSIGNMENTS // Use Teensy++ 2.0 assignments </front>
<front id="fastioH-2042">#ifndef AT90USBxx_TEENSYPP_ASSIGNMENTS // Use traditional Marlin pin assignments</front>
<front id="fastioH-2043"></front>
<front id="fastioH-2044">#define DIO0_PIN        PINA0</front>
<front id="fastioH-2045">#define DIO0_RPORT      PINA</front>
<front id="fastioH-2046">#define DIO0_WPORT      PORTA</front>
<front id="fastioH-2047">#define DIO0_PWM			NULL</front>
<front id="fastioH-2048">#define DIO0_DDR        DDRA</front>
<front id="fastioH-2049"></front>
<front id="fastioH-2050">#define DIO1_PIN        PINA1</front>
<front id="fastioH-2051">#define DIO1_RPORT      PINA</front>
<front id="fastioH-2052">#define DIO1_WPORT      PORTA</front>
<front id="fastioH-2053">#define DIO1_PWM			NULL</front>
<front id="fastioH-2054">#define DIO1_DDR        DDRA</front>
<front id="fastioH-2055"></front>
<front id="fastioH-2056">#define DIO2_PIN        PINA2</front>
<front id="fastioH-2057">#define DIO2_RPORT      PINA</front>
<front id="fastioH-2058">#define DIO2_WPORT      PORTA</front>
<front id="fastioH-2059">#define DIO2_PWM			NULL</front>
<front id="fastioH-2060">#define DIO2_DDR        DDRA</front>
<front id="fastioH-2061"></front>
<front id="fastioH-2062">#define DIO3_PIN        PINA3</front>
<front id="fastioH-2063">#define DIO3_RPORT      PINA</front>
<front id="fastioH-2064">#define DIO3_WPORT      PORTA</front>
<front id="fastioH-2065">#define DIO3_PWM			NULL</front>
<front id="fastioH-2066">#define DIO3_DDR        DDRA</front>
<front id="fastioH-2067"></front>
<front id="fastioH-2068">#define DIO4_PIN        PINA4</front>
<front id="fastioH-2069">#define DIO4_RPORT      PINA</front>
<front id="fastioH-2070">#define DIO4_WPORT      PORTA</front>
<front id="fastioH-2071">#define DIO4_PWM			NULL</front>
<front id="fastioH-2072">#define DIO4_DDR        DDRA</front>
<front id="fastioH-2073"></front>
<front id="fastioH-2074">#define DIO5_PIN        PINA5</front>
<front id="fastioH-2075">#define DIO5_RPORT      PINA</front>
<front id="fastioH-2076">#define DIO5_WPORT      PORTA</front>
<front id="fastioH-2077">#define DIO5_PWM			NULL</front>
<front id="fastioH-2078">#define DIO5_DDR        DDRA</front>
<front id="fastioH-2079"></front>
<front id="fastioH-2080">#define DIO6_PIN        PINA6</front>
<front id="fastioH-2081">#define DIO6_RPORT      PINA</front>
<front id="fastioH-2082">#define DIO6_WPORT      PORTA</front>
<front id="fastioH-2083">#define DIO6_PWM			NULL</front>
<front id="fastioH-2084">#define DIO6_DDR        DDRA</front>
<front id="fastioH-2085"></front>
<front id="fastioH-2086">#define DIO7_PIN        PINA7</front>
<front id="fastioH-2087">#define DIO7_RPORT      PINA</front>
<front id="fastioH-2088">#define DIO7_WPORT      PORTA</front>
<front id="fastioH-2089">#define DIO7_PWM			NULL</front>
<front id="fastioH-2090">#define DIO7_DDR        DDRA</front>
<front id="fastioH-2091"></front>
<front id="fastioH-2092">#define DIO8_PIN        PINB0</front>
<front id="fastioH-2093">#define DIO8_RPORT      PINB</front>
<front id="fastioH-2094">#define DIO8_WPORT      PORTB</front>
<front id="fastioH-2095">#define DIO8_PWM			NULL</front>
<front id="fastioH-2096">#define DIO8_DDR        DDRB</front>
<front id="fastioH-2097"></front>
<front id="fastioH-2098">#define DIO9_PIN        PINB1</front>
<front id="fastioH-2099">#define DIO9_RPORT      PINB</front>
<front id="fastioH-2100">#define DIO9_WPORT      PORTB</front>
<front id="fastioH-2101">#define DIO9_PWM			NULL</front>
<front id="fastioH-2102">#define DIO9_DDR        DDRB</front>
<front id="fastioH-2103"></front>
<front id="fastioH-2104">#define DIO10_PIN       PINB2</front>
<front id="fastioH-2105">#define DIO10_RPORT     PINB</front>
<front id="fastioH-2106">#define DIO10_WPORT     PORTB</front>
<front id="fastioH-2107">#define DIO10_PWM			NULL</front>
<front id="fastioH-2108">#define DIO10_DDR       DDRB</front>
<front id="fastioH-2109"></front>
<front id="fastioH-2110">#define DIO11_PIN       PINB3</front>
<front id="fastioH-2111">#define DIO11_RPORT     PINB</front>
<front id="fastioH-2112">#define DIO11_WPORT     PORTB</front>
<front id="fastioH-2113">#define DIO11_PWM			NULL</front>
<front id="fastioH-2114">#define DIO11_DDR       DDRB</front>
<front id="fastioH-2115"></front>
<front id="fastioH-2116">#define DIO12_PIN       PINB4</front>
<front id="fastioH-2117">#define DIO12_RPORT     PINB</front>
<front id="fastioH-2118">#define DIO12_WPORT     PORTB</front>
<front id="fastioH-2119">#define DIO12_PWM			NULL</front>
<front id="fastioH-2120">#define DIO12_DDR       DDRB</front>
<front id="fastioH-2121"></front>
<front id="fastioH-2122">#define DIO13_PIN       PINB5</front>
<front id="fastioH-2123">#define DIO13_RPORT     PINB</front>
<front id="fastioH-2124">#define DIO13_WPORT     PORTB</front>
<front id="fastioH-2125">#define DIO13_PWM			NULL</front>
<front id="fastioH-2126">#define DIO13_DDR       DDRB</front>
<front id="fastioH-2127"></front>
<front id="fastioH-2128">#define DIO14_PIN       PINB6</front>
<front id="fastioH-2129">#define DIO14_RPORT     PINB</front>
<front id="fastioH-2130">#define DIO14_WPORT     PORTB</front>
<front id="fastioH-2131">#define DIO14_PWM			NULL</front>
<front id="fastioH-2132">#define DIO14_DDR       DDRB</front>
<front id="fastioH-2133"></front>
<front id="fastioH-2134">#define DIO15_PIN       PINB7</front>
<front id="fastioH-2135">#define DIO15_RPORT     PINB</front>
<front id="fastioH-2136">#define DIO15_WPORT     PORTB</front>
<front id="fastioH-2137">#define DIO15_PWM			NULL</front>
<front id="fastioH-2138">#define DIO15_DDR       DDRB</front>
<front id="fastioH-2139"></front>
<front id="fastioH-2140">#define DIO16_PIN       PINC0</front>
<front id="fastioH-2141">#define DIO16_RPORT     PINC</front>
<front id="fastioH-2142">#define DIO16_WPORT     PORTC</front>
<front id="fastioH-2143">#define DIO16_PWM			NULL</front>
<front id="fastioH-2144">#define DIO16_DDR       DDRC</front>
<front id="fastioH-2145"></front>
<front id="fastioH-2146">#define DIO17_PIN       PINC1</front>
<front id="fastioH-2147">#define DIO17_RPORT     PINC</front>
<front id="fastioH-2148">#define DIO17_WPORT     PORTC</front>
<front id="fastioH-2149">#define DIO17_PWM			NULL</front>
<front id="fastioH-2150">#define DIO17_DDR       DDRC</front>
<front id="fastioH-2151"></front>
<front id="fastioH-2152">#define DIO18_PIN       PINC2</front>
<front id="fastioH-2153">#define DIO18_RPORT     PINC</front>
<front id="fastioH-2154">#define DIO18_WPORT     PORTC</front>
<front id="fastioH-2155">#define DIO18_PWM			NULL</front>
<front id="fastioH-2156">#define DIO18_DDR       DDRC</front>
<front id="fastioH-2157"></front>
<front id="fastioH-2158">#define DIO19_PIN       PINC3</front>
<front id="fastioH-2159">#define DIO19_RPORT     PINC</front>
<front id="fastioH-2160">#define DIO19_WPORT     PORTC</front>
<front id="fastioH-2161">#define DIO19_PWM			NULL</front>
<front id="fastioH-2162">#define DIO19_DDR       DDRC</front>
<front id="fastioH-2163"></front>
<front id="fastioH-2164">#define DIO20_PIN       PINC4</front>
<front id="fastioH-2165">#define DIO20_RPORT     PINC</front>
<front id="fastioH-2166">#define DIO20_WPORT     PORTC</front>
<front id="fastioH-2167">#define DIO20_PWM			NULL</front>
<front id="fastioH-2168">#define DIO20_DDR       DDRC</front>
<front id="fastioH-2169"></front>
<front id="fastioH-2170">#define DIO21_PIN       PINC5</front>
<front id="fastioH-2171">#define DIO21_RPORT     PINC</front>
<front id="fastioH-2172">#define DIO21_WPORT     PORTC</front>
<front id="fastioH-2173">#define DIO21_PWM			NULL</front>
<front id="fastioH-2174">#define DIO21_DDR       DDRC</front>
<front id="fastioH-2175"></front>
<front id="fastioH-2176">#define DIO22_PIN       PINC6</front>
<front id="fastioH-2177">#define DIO22_RPORT     PINC</front>
<front id="fastioH-2178">#define DIO22_WPORT     PORTC</front>
<front id="fastioH-2179">#define DIO22_PWM			NULL</front>
<front id="fastioH-2180">#define DIO22_DDR       DDRC</front>
<front id="fastioH-2181"></front>
<front id="fastioH-2182">#define DIO23_PIN       PINC7</front>
<front id="fastioH-2183">#define DIO23_RPORT     PINC</front>
<front id="fastioH-2184">#define DIO23_WPORT     PORTC</front>
<front id="fastioH-2185">#define DIO23_PWM			NULL</front>
<front id="fastioH-2186">#define DIO23_DDR       DDRC</front>
<front id="fastioH-2187"></front>
<front id="fastioH-2188">#define DIO24_PIN       PIND0</front>
<front id="fastioH-2189">#define DIO24_RPORT     PIND</front>
<front id="fastioH-2190">#define DIO24_WPORT     PORTD</front>
<front id="fastioH-2191">#define DIO24_PWM			NULL</front>
<front id="fastioH-2192">#define DIO24_DDR       DDRD</front>
<front id="fastioH-2193"></front>
<front id="fastioH-2194">#define DIO25_PIN       PIND1</front>
<front id="fastioH-2195">#define DIO25_RPORT     PIND</front>
<front id="fastioH-2196">#define DIO25_WPORT     PORTD</front>
<front id="fastioH-2197">#define DIO25_PWM			NULL</front>
<front id="fastioH-2198">#define DIO25_DDR       DDRD</front>
<front id="fastioH-2199"></front>
<front id="fastioH-2200">#define DIO26_PIN       PIND2</front>
<front id="fastioH-2201">#define DIO26_RPORT     PIND</front>
<front id="fastioH-2202">#define DIO26_WPORT     PORTD</front>
<front id="fastioH-2203">#define DIO26_PWM			NULL</front>
<front id="fastioH-2204">#define DIO26_DDR       DDRD</front>
<front id="fastioH-2205"></front>
<front id="fastioH-2206">#define DIO27_PIN       PIND3</front>
<front id="fastioH-2207">#define DIO27_RPORT     PIND</front>
<front id="fastioH-2208">#define DIO27_WPORT     PORTD</front>
<front id="fastioH-2209">#define DIO27_PWM			NULL</front>
<front id="fastioH-2210">#define DIO27_DDR       DDRD</front>
<front id="fastioH-2211"></front>
<front id="fastioH-2212">#define DIO28_PIN       PIND4</front>
<front id="fastioH-2213">#define DIO28_RPORT     PIND</front>
<front id="fastioH-2214">#define DIO28_WPORT     PORTD</front>
<front id="fastioH-2215">#define DIO28_PWM			NULL</front>
<front id="fastioH-2216">#define DIO28_DDR       DDRD</front>
<front id="fastioH-2217"></front>
<front id="fastioH-2218">#define DIO29_PIN       PIND5</front>
<front id="fastioH-2219">#define DIO29_RPORT     PIND</front>
<front id="fastioH-2220">#define DIO29_WPORT     PORTD</front>
<front id="fastioH-2221">#define DIO29_PWM			NULL</front>
<front id="fastioH-2222">#define DIO29_DDR       DDRD</front>
<front id="fastioH-2223"></front>
<front id="fastioH-2224">#define DIO30_PIN       PIND6</front>
<front id="fastioH-2225">#define DIO30_RPORT     PIND</front>
<front id="fastioH-2226">#define DIO30_WPORT     PORTD</front>
<front id="fastioH-2227">#define DIO30_PWM			NULL</front>
<front id="fastioH-2228">#define DIO30_DDR       DDRD</front>
<front id="fastioH-2229"></front>
<front id="fastioH-2230">#define DIO31_PIN       PIND7</front>
<front id="fastioH-2231">#define DIO31_RPORT     PIND</front>
<front id="fastioH-2232">#define DIO31_WPORT     PORTD</front>
<front id="fastioH-2233">#define DIO31_PWM			NULL</front>
<front id="fastioH-2234">#define DIO31_DDR       DDRD</front>
<front id="fastioH-2235"></front>
<front id="fastioH-2236"></front>
<front id="fastioH-2237">#define DIO32_PIN       PINE0</front>
<front id="fastioH-2238">#define DIO32_RPORT     PINE</front>
<front id="fastioH-2239">#define DIO32_WPORT     PORTE</front>
<front id="fastioH-2240">#define DIO32_PWM			NULL</front>
<front id="fastioH-2241">#define DIO32_DDR       DDRE</front>
<front id="fastioH-2242"></front>
<front id="fastioH-2243">#define DIO33_PIN       PINE1</front>
<front id="fastioH-2244">#define DIO33_RPORT     PINE</front>
<front id="fastioH-2245">#define DIO33_WPORT     PORTE</front>
<front id="fastioH-2246">#define DIO33_PWM			NULL</front>
<front id="fastioH-2247">#define DIO33_DDR       DDRE</front>
<front id="fastioH-2248"></front>
<front id="fastioH-2249">#define DIO34_PIN       PINE2</front>
<front id="fastioH-2250">#define DIO34_RPORT     PINE</front>
<front id="fastioH-2251">#define DIO34_WPORT     PORTE</front>
<front id="fastioH-2252">#define DIO34_PWM			NULL</front>
<front id="fastioH-2253">#define DIO34_DDR       DDRE</front>
<front id="fastioH-2254"></front>
<front id="fastioH-2255">#define DIO35_PIN       PINE3</front>
<front id="fastioH-2256">#define DIO35_RPORT     PINE</front>
<front id="fastioH-2257">#define DIO35_WPORT     PORTE</front>
<front id="fastioH-2258">#define DIO35_PWM			NULL</front>
<front id="fastioH-2259">#define DIO35_DDR       DDRE</front>
<front id="fastioH-2260"></front>
<front id="fastioH-2261">#define DIO36_PIN       PINE4</front>
<front id="fastioH-2262">#define DIO36_RPORT     PINE</front>
<front id="fastioH-2263">#define DIO36_WPORT     PORTE</front>
<front id="fastioH-2264">#define DIO36_PWM			NULL</front>
<front id="fastioH-2265">#define DIO36_DDR       DDRE</front>
<front id="fastioH-2266"></front>
<front id="fastioH-2267">#define DIO37_PIN       PINE5</front>
<front id="fastioH-2268">#define DIO37_RPORT     PINE</front>
<front id="fastioH-2269">#define DIO37_WPORT     PORTE</front>
<front id="fastioH-2270">#define DIO37_PWM			NULL</front>
<front id="fastioH-2271">#define DIO37_DDR       DDRE</front>
<front id="fastioH-2272"></front>
<front id="fastioH-2273">#define DIO38_PIN       PINE6</front>
<front id="fastioH-2274">#define DIO38_RPORT     PINE</front>
<front id="fastioH-2275">#define DIO38_WPORT     PORTE</front>
<front id="fastioH-2276">#define DIO38_PWM			NULL</front>
<front id="fastioH-2277">#define DIO38_DDR       DDRE</front>
<front id="fastioH-2278"></front>
<front id="fastioH-2279">#define DIO39_PIN       PINE7</front>
<front id="fastioH-2280">#define DIO39_RPORT     PINE</front>
<front id="fastioH-2281">#define DIO39_WPORT     PORTE</front>
<front id="fastioH-2282">#define DIO39_PWM			NULL</front>
<front id="fastioH-2283">#define DIO39_DDR       DDRE</front>
<front id="fastioH-2284"></front>
<front id="fastioH-2285">#define AIO0_PIN PINF0</front>
<front id="fastioH-2286">#define AIO0_RPORT PINF</front>
<front id="fastioH-2287">#define AIO0_WPORT PORTF</front>
<front id="fastioH-2288">#define AIO0_PWM			NULL</front>
<front id="fastioH-2289">#define AIO0_DDR DDRF</front>
<front id="fastioH-2290"></front>
<front id="fastioH-2291">#define AIO1_PIN PINF1</front>
<front id="fastioH-2292">#define AIO1_RPORT PINF</front>
<front id="fastioH-2293">#define AIO1_WPORT PORTF</front>
<front id="fastioH-2294">#define AIO1_PWM			NULL</front>
<front id="fastioH-2295">#define AIO1_DDR DDRF</front>
<front id="fastioH-2296"></front>
<front id="fastioH-2297">#define AIO2_PIN PINF2</front>
<front id="fastioH-2298">#define AIO2_RPORT PINF</front>
<front id="fastioH-2299">#define AIO2_WPORT PORTF</front>
<front id="fastioH-2300">#define AIO2_PWM			NULL</front>
<front id="fastioH-2301">#define AIO2_DDR DDRF</front>
<front id="fastioH-2302"></front>
<front id="fastioH-2303">#define AIO3_PIN PINF3</front>
<front id="fastioH-2304">#define AIO3_RPORT PINF</front>
<front id="fastioH-2305">#define AIO3_WPORT PORTF</front>
<front id="fastioH-2306">#define AIO3_PWM			NULL</front>
<front id="fastioH-2307">#define AIO3_DDR DDRF</front>
<front id="fastioH-2308"></front>
<front id="fastioH-2309">#define AIO4_PIN PINF4</front>
<front id="fastioH-2310">#define AIO4_RPORT PINF</front>
<front id="fastioH-2311">#define AIO4_WPORT PORTF</front>
<front id="fastioH-2312">#define AIO4_PWM			NULL</front>
<front id="fastioH-2313">#define AIO4_DDR DDRF</front>
<front id="fastioH-2314"></front>
<front id="fastioH-2315">#define AIO5_PIN PINF5</front>
<front id="fastioH-2316">#define AIO5_RPORT PINF</front>
<front id="fastioH-2317">#define AIO5_WPORT PORTF</front>
<front id="fastioH-2318">#define AIO5_PWM			NULL</front>
<front id="fastioH-2319">#define AIO5_DDR DDRF</front>
<front id="fastioH-2320"></front>
<front id="fastioH-2321">#define AIO6_PIN PINF6</front>
<front id="fastioH-2322">#define AIO6_RPORT PINF</front>
<front id="fastioH-2323">#define AIO6_WPORT PORTF</front>
<front id="fastioH-2324">#define AIO6_PWM			NULL</front>
<front id="fastioH-2325">#define AIO6_DDR DDRF</front>
<front id="fastioH-2326"></front>
<front id="fastioH-2327">#define AIO7_PIN PINF7</front>
<front id="fastioH-2328">#define AIO7_RPORT PINF</front>
<front id="fastioH-2329">#define AIO7_WPORT PORTF</front>
<front id="fastioH-2330">#define AIO7_PWM			NULL</front>
<front id="fastioH-2331">#define AIO7_DDR DDRF</front>
<front id="fastioH-2332"></front>
<front id="fastioH-2333">#define DIO40_PIN       PINF0</front>
<front id="fastioH-2334">#define DIO40_RPORT     PINF</front>
<front id="fastioH-2335">#define DIO40_WPORT     PORTF</front>
<front id="fastioH-2336">#define DIO40_PWM			NULL</front>
<front id="fastioH-2337">#define DIO40_DDR       DDRF</front>
<front id="fastioH-2338"></front>
<front id="fastioH-2339">#define DIO41_PIN       PINF1</front>
<front id="fastioH-2340">#define DIO41_RPORT     PINF</front>
<front id="fastioH-2341">#define DIO41_WPORT     PORTF</front>
<front id="fastioH-2342">#define DIO41_PWM			NULL</front>
<front id="fastioH-2343">#define DIO41_DDR       DDRF</front>
<front id="fastioH-2344"></front>
<front id="fastioH-2345">#define DIO42_PIN       PINF2</front>
<front id="fastioH-2346">#define DIO42_RPORT     PINF</front>
<front id="fastioH-2347">#define DIO42_WPORT     PORTF</front>
<front id="fastioH-2348">#define DIO42_PWM			NULL</front>
<front id="fastioH-2349">#define DIO42_DDR       DDRF</front>
<front id="fastioH-2350"></front>
<front id="fastioH-2351">#define DIO43_PIN       PINF3</front>
<front id="fastioH-2352">#define DIO43_RPORT     PINF</front>
<front id="fastioH-2353">#define DIO43_WPORT     PORTF</front>
<front id="fastioH-2354">#define DIO43_PWM			NULL</front>
<front id="fastioH-2355">#define DIO43_DDR       DDRF</front>
<front id="fastioH-2356"></front>
<front id="fastioH-2357">#define DIO44_PIN       PINF4</front>
<front id="fastioH-2358">#define DIO44_RPORT     PINF</front>
<front id="fastioH-2359">#define DIO44_WPORT     PORTF</front>
<front id="fastioH-2360">#define DIO44_PWM			NULL</front>
<front id="fastioH-2361">#define DIO44_DDR       DDRF</front>
<front id="fastioH-2362"></front>
<front id="fastioH-2363">#define DIO45_PIN       PINF5</front>
<front id="fastioH-2364">#define DIO45_RPORT     PINF</front>
<front id="fastioH-2365">#define DIO45_WPORT     PORTF</front>
<front id="fastioH-2366">#define DIO45_PWM			NULL</front>
<front id="fastioH-2367">#define DIO45_DDR       DDRF</front>
<front id="fastioH-2368"></front>
<front id="fastioH-2369">#define DIO46_PIN       PINF6</front>
<front id="fastioH-2370">#define DIO46_RPORT     PINF</front>
<front id="fastioH-2371">#define DIO46_WPORT     PORTF</front>
<front id="fastioH-2372">#define DIO46_PWM			NULL</front>
<front id="fastioH-2373">#define DIO46_DDR       DDRF</front>
<front id="fastioH-2374"></front>
<front id="fastioH-2375">#define DIO47_PIN       PINF7</front>
<front id="fastioH-2376">#define DIO47_RPORT     PINF</front>
<front id="fastioH-2377">#define DIO47_WPORT     PORTF</front>
<front id="fastioH-2378">#define DIO47_PWM			NULL</front>
<front id="fastioH-2379">#define DIO47_DDR       DDRF</front>
<front id="fastioH-2380"></front>
<front id="fastioH-2381"></front>
<front id="fastioH-2382"></front>
<front id="fastioH-2383">#undef PA0</front>
<front id="fastioH-2384">#define PA0_PIN			PINA0</front>
<front id="fastioH-2385">#define PA0_RPORT		PINA</front>
<front id="fastioH-2386">#define PA0_WPORT		PORTA</front>
<front id="fastioH-2387">#define PA0_PWM			NULL</front>
<front id="fastioH-2388">#define PA0_DDR			DDRA</front>
<front id="fastioH-2389">#undef PA1</front>
<front id="fastioH-2390">#define PA1_PIN			PINA1</front>
<front id="fastioH-2391">#define PA1_RPORT		PINA</front>
<front id="fastioH-2392">#define PA1_WPORT		PORTA</front>
<front id="fastioH-2393">#define PA1_PWM			NULL</front>
<front id="fastioH-2394">#define PA1_DDR			DDRA</front>
<front id="fastioH-2395">#undef PA2</front>
<front id="fastioH-2396">#define PA2_PIN			PINA2</front>
<front id="fastioH-2397">#define PA2_RPORT		PINA</front>
<front id="fastioH-2398">#define PA2_WPORT		PORTA</front>
<front id="fastioH-2399">#define PA2_PWM			NULL</front>
<front id="fastioH-2400">#define PA2_DDR			DDRA</front>
<front id="fastioH-2401">#undef PA3</front>
<front id="fastioH-2402">#define PA3_PIN			PINA3</front>
<front id="fastioH-2403">#define PA3_RPORT		PINA</front>
<front id="fastioH-2404">#define PA3_WPORT		PORTA</front>
<front id="fastioH-2405">#define PA3_PWM			NULL</front>
<front id="fastioH-2406">#define PA3_DDR			DDRA</front>
<front id="fastioH-2407">#undef PA4</front>
<front id="fastioH-2408">#define PA4_PIN			PINA4</front>
<front id="fastioH-2409">#define PA4_RPORT		PINA</front>
<front id="fastioH-2410">#define PA4_WPORT		PORTA</front>
<front id="fastioH-2411">#define PA4_PWM			NULL</front>
<front id="fastioH-2412">#define PA4_DDR			DDRA</front>
<front id="fastioH-2413">#undef PA5</front>
<front id="fastioH-2414">#define PA5_PIN			PINA5</front>
<front id="fastioH-2415">#define PA5_RPORT		PINA</front>
<front id="fastioH-2416">#define PA5_WPORT		PORTA</front>
<front id="fastioH-2417">#define PA5_PWM			NULL</front>
<front id="fastioH-2418">#define PA5_DDR			DDRA</front>
<front id="fastioH-2419">#undef PA6</front>
<front id="fastioH-2420">#define PA6_PIN			PINA6</front>
<front id="fastioH-2421">#define PA6_RPORT		PINA</front>
<front id="fastioH-2422">#define PA6_WPORT		PORTA</front>
<front id="fastioH-2423">#define PA6_PWM			NULL</front>
<front id="fastioH-2424">#define PA6_DDR			DDRA</front>
<front id="fastioH-2425">#undef PA7</front>
<front id="fastioH-2426">#define PA7_PIN			PINA7</front>
<front id="fastioH-2427">#define PA7_RPORT		PINA</front>
<front id="fastioH-2428">#define PA7_WPORT		PORTA</front>
<front id="fastioH-2429">#define PA7_PWM			NULL</front>
<front id="fastioH-2430">#define PA7_DDR			DDRA</front>
<front id="fastioH-2431"></front>
<front id="fastioH-2432">#undef PB0</front>
<front id="fastioH-2433">#define PB0_PIN			PINB0</front>
<front id="fastioH-2434">#define PB0_RPORT		PINB</front>
<front id="fastioH-2435">#define PB0_WPORT		PORTB</front>
<front id="fastioH-2436">#define PB0_PWM			NULL</front>
<front id="fastioH-2437">#define PB0_DDR			DDRB</front>
<front id="fastioH-2438">#undef PB1</front>
<front id="fastioH-2439">#define PB1_PIN			PINB1</front>
<front id="fastioH-2440">#define PB1_RPORT		PINB</front>
<front id="fastioH-2441">#define PB1_WPORT		PORTB</front>
<front id="fastioH-2442">#define PB1_PWM			NULL</front>
<front id="fastioH-2443">#define PB1_DDR			DDRB</front>
<front id="fastioH-2444">#undef PB2</front>
<front id="fastioH-2445">#define PB2_PIN			PINB2</front>
<front id="fastioH-2446">#define PB2_RPORT		PINB</front>
<front id="fastioH-2447">#define PB2_WPORT		PORTB</front>
<front id="fastioH-2448">#define PB2_PWM			NULL</front>
<front id="fastioH-2449">#define PB2_DDR			DDRB</front>
<front id="fastioH-2450">#undef PB3</front>
<front id="fastioH-2451">#define PB3_PIN			PINB3</front>
<front id="fastioH-2452">#define PB3_RPORT		PINB</front>
<front id="fastioH-2453">#define PB3_WPORT		PORTB</front>
<front id="fastioH-2454">#define PB3_PWM			NULL</front>
<front id="fastioH-2455">#define PB3_DDR			DDRB</front>
<front id="fastioH-2456">#undef PB4</front>
<front id="fastioH-2457">#define PB4_PIN			PINB4</front>
<front id="fastioH-2458">#define PB4_RPORT		PINB</front>
<front id="fastioH-2459">#define PB4_WPORT		PORTB</front>
<front id="fastioH-2460">#define PB4_PWM			NULL</front>
<front id="fastioH-2461">#define PB4_DDR			DDRB</front>
<front id="fastioH-2462">#undef PB5</front>
<front id="fastioH-2463">#define PB5_PIN			PINB5</front>
<front id="fastioH-2464">#define PB5_RPORT		PINB</front>
<front id="fastioH-2465">#define PB5_WPORT		PORTB</front>
<front id="fastioH-2466">#define PB5_PWM			NULL</front>
<front id="fastioH-2467">#define PB5_DDR			DDRB</front>
<front id="fastioH-2468">#undef PB6</front>
<front id="fastioH-2469">#define PB6_PIN			PINB6</front>
<front id="fastioH-2470">#define PB6_RPORT		PINB</front>
<front id="fastioH-2471">#define PB6_WPORT		PORTB</front>
<front id="fastioH-2472">#define PB6_PWM			NULL</front>
<front id="fastioH-2473">#define PB6_DDR			DDRB</front>
<front id="fastioH-2474">#undef PB7</front>
<front id="fastioH-2475">#define PB7_PIN			PINB7</front>
<front id="fastioH-2476">#define PB7_RPORT		PINB</front>
<front id="fastioH-2477">#define PB7_WPORT		PORTB</front>
<front id="fastioH-2478">#define PB7_PWM			NULL</front>
<front id="fastioH-2479">#define PB7_DDR			DDRB</front>
<front id="fastioH-2480"></front>
<front id="fastioH-2481">#undef PC0</front>
<front id="fastioH-2482">#define PC0_PIN			PINC0</front>
<front id="fastioH-2483">#define PC0_RPORT		PINC</front>
<front id="fastioH-2484">#define PC0_WPORT		PORTC</front>
<front id="fastioH-2485">#define PC0_PWM			NULL</front>
<front id="fastioH-2486">#define PC0_DDR			DDRC</front>
<front id="fastioH-2487">#undef PC1</front>
<front id="fastioH-2488">#define PC1_PIN			PINC1</front>
<front id="fastioH-2489">#define PC1_RPORT		PINC</front>
<front id="fastioH-2490">#define PC1_WPORT		PORTC</front>
<front id="fastioH-2491">#define PC1_PWM			NULL</front>
<front id="fastioH-2492">#define PC1_DDR			DDRC</front>
<front id="fastioH-2493">#undef PC2</front>
<front id="fastioH-2494">#define PC2_PIN			PINC2</front>
<front id="fastioH-2495">#define PC2_RPORT		PINC</front>
<front id="fastioH-2496">#define PC2_WPORT		PORTC</front>
<front id="fastioH-2497">#define PC2_PWM			NULL</front>
<front id="fastioH-2498">#define PC2_DDR			DDRC</front>
<front id="fastioH-2499">#undef PC3</front>
<front id="fastioH-2500">#define PC3_PIN			PINC3</front>
<front id="fastioH-2501">#define PC3_RPORT		PINC</front>
<front id="fastioH-2502">#define PC3_WPORT		PORTC</front>
<front id="fastioH-2503">#define PC3_PWM			NULL</front>
<front id="fastioH-2504">#define PC3_DDR			DDRC</front>
<front id="fastioH-2505">#undef PC4</front>
<front id="fastioH-2506">#define PC4_PIN			PINC4</front>
<front id="fastioH-2507">#define PC4_RPORT		PINC</front>
<front id="fastioH-2508">#define PC4_WPORT		PORTC</front>
<front id="fastioH-2509">#define PC4_PWM			NULL</front>
<front id="fastioH-2510">#define PC4_DDR			DDRC</front>
<front id="fastioH-2511">#undef PC5</front>
<front id="fastioH-2512">#define PC5_PIN			PINC5</front>
<front id="fastioH-2513">#define PC5_RPORT		PINC</front>
<front id="fastioH-2514">#define PC5_WPORT		PORTC</front>
<front id="fastioH-2515">#define PC5_PWM			NULL</front>
<front id="fastioH-2516">#define PC5_DDR			DDRC</front>
<front id="fastioH-2517">#undef PC6</front>
<front id="fastioH-2518">#define PC6_PIN			PINC6</front>
<front id="fastioH-2519">#define PC6_RPORT		PINC</front>
<front id="fastioH-2520">#define PC6_WPORT		PORTC</front>
<front id="fastioH-2521">#define PC6_PWM			NULL</front>
<front id="fastioH-2522">#define PC6_DDR			DDRC</front>
<front id="fastioH-2523">#undef PC7</front>
<front id="fastioH-2524">#define PC7_PIN			PINC7</front>
<front id="fastioH-2525">#define PC7_RPORT		PINC</front>
<front id="fastioH-2526">#define PC7_WPORT		PORTC</front>
<front id="fastioH-2527">#define PC7_PWM			NULL</front>
<front id="fastioH-2528">#define PC7_DDR			DDRC</front>
<front id="fastioH-2529"></front>
<front id="fastioH-2530">#undef PD0</front>
<front id="fastioH-2531">#define PD0_PIN			PIND0</front>
<front id="fastioH-2532">#define PD0_RPORT		PIND</front>
<front id="fastioH-2533">#define PD0_WPORT		PORTD</front>
<front id="fastioH-2534">#define PD0_PWM			NULL</front>
<front id="fastioH-2535">#define PD0_DDR			DDRD</front>
<front id="fastioH-2536">#undef PD1</front>
<front id="fastioH-2537">#define PD1_PIN			PIND1</front>
<front id="fastioH-2538">#define PD1_RPORT		PIND</front>
<front id="fastioH-2539">#define PD1_WPORT		PORTD</front>
<front id="fastioH-2540">#define PD1_PWM			NULL</front>
<front id="fastioH-2541">#define PD1_DDR			DDRD</front>
<front id="fastioH-2542">#undef PD2</front>
<front id="fastioH-2543">#define PD2_PIN			PIND2</front>
<front id="fastioH-2544">#define PD2_RPORT		PIND</front>
<front id="fastioH-2545">#define PD2_WPORT		PORTD</front>
<front id="fastioH-2546">#define PD2_PWM			NULL</front>
<front id="fastioH-2547">#define PD2_DDR			DDRD</front>
<front id="fastioH-2548">#undef PD3</front>
<front id="fastioH-2549">#define PD3_PIN			PIND3</front>
<front id="fastioH-2550">#define PD3_RPORT		PIND</front>
<front id="fastioH-2551">#define PD3_WPORT		PORTD</front>
<front id="fastioH-2552">#define PD3_PWM			NULL</front>
<front id="fastioH-2553">#define PD3_DDR			DDRD</front>
<front id="fastioH-2554">#undef PD4</front>
<front id="fastioH-2555">#define PD4_PIN			PIND4</front>
<front id="fastioH-2556">#define PD4_RPORT		PIND</front>
<front id="fastioH-2557">#define PD4_WPORT		PORTD</front>
<front id="fastioH-2558">#define PD4_PWM			NULL</front>
<front id="fastioH-2559">#define PD4_DDR			DDRD</front>
<front id="fastioH-2560">#undef PD5</front>
<front id="fastioH-2561">#define PD5_PIN			PIND5</front>
<front id="fastioH-2562">#define PD5_RPORT		PIND</front>
<front id="fastioH-2563">#define PD5_WPORT		PORTD</front>
<front id="fastioH-2564">#define PD5_PWM			NULL</front>
<front id="fastioH-2565">#define PD5_DDR			DDRD</front>
<front id="fastioH-2566">#undef PD6</front>
<front id="fastioH-2567">#define PD6_PIN			PIND6</front>
<front id="fastioH-2568">#define PD6_RPORT		PIND</front>
<front id="fastioH-2569">#define PD6_WPORT		PORTD</front>
<front id="fastioH-2570">#define PD6_PWM			NULL</front>
<front id="fastioH-2571">#define PD6_DDR			DDRD</front>
<front id="fastioH-2572">#undef PD7</front>
<front id="fastioH-2573">#define PD7_PIN			PIND7</front>
<front id="fastioH-2574">#define PD7_RPORT		PIND</front>
<front id="fastioH-2575">#define PD7_WPORT		PORTD</front>
<front id="fastioH-2576">#define PD7_PWM			NULL</front>
<front id="fastioH-2577">#define PD7_DDR			DDRD</front>
<front id="fastioH-2578"></front>
<front id="fastioH-2579">#undef PE0</front>
<front id="fastioH-2580">#define PE0_PIN			PINE0</front>
<front id="fastioH-2581">#define PE0_RPORT		PINE</front>
<front id="fastioH-2582">#define PE0_WPORT		PORTE</front>
<front id="fastioH-2583">#define PE0_PWM			NULL</front>
<front id="fastioH-2584">#define PE0_DDR			DDRE</front>
<front id="fastioH-2585">#undef PE1</front>
<front id="fastioH-2586">#define PE1_PIN			PINE1</front>
<front id="fastioH-2587">#define PE1_RPORT		PINE</front>
<front id="fastioH-2588">#define PE1_WPORT		PORTE</front>
<front id="fastioH-2589">#define PE1_PWM			NULL</front>
<front id="fastioH-2590">#define PE1_DDR			DDRE</front>
<front id="fastioH-2591">#undef PE2</front>
<front id="fastioH-2592">#define PE2_PIN			PINE2</front>
<front id="fastioH-2593">#define PE2_RPORT		PINE</front>
<front id="fastioH-2594">#define PE2_WPORT		PORTE</front>
<front id="fastioH-2595">#define PE2_PWM			NULL</front>
<front id="fastioH-2596">#define PE2_DDR			DDRE</front>
<front id="fastioH-2597">#undef PE3</front>
<front id="fastioH-2598">#define PE3_PIN			PINE3</front>
<front id="fastioH-2599">#define PE3_RPORT		PINE</front>
<front id="fastioH-2600">#define PE3_WPORT		PORTE</front>
<front id="fastioH-2601">#define PE3_PWM			NULL</front>
<front id="fastioH-2602">#define PE3_DDR			DDRE</front>
<front id="fastioH-2603">#undef PE4</front>
<front id="fastioH-2604">#define PE4_PIN			PINE4</front>
<front id="fastioH-2605">#define PE4_RPORT		PINE</front>
<front id="fastioH-2606">#define PE4_WPORT		PORTE</front>
<front id="fastioH-2607">#define PE4_PWM			NULL</front>
<front id="fastioH-2608">#define PE4_DDR			DDRE</front>
<front id="fastioH-2609">#undef PE5</front>
<front id="fastioH-2610">#define PE5_PIN			PINE5</front>
<front id="fastioH-2611">#define PE5_RPORT		PINE</front>
<front id="fastioH-2612">#define PE5_WPORT		PORTE</front>
<front id="fastioH-2613">#define PE5_PWM			NULL</front>
<front id="fastioH-2614">#define PE5_DDR			DDRE</front>
<front id="fastioH-2615">#undef PE6</front>
<front id="fastioH-2616">#define PE6_PIN			PINE6</front>
<front id="fastioH-2617">#define PE6_RPORT		PINE</front>
<front id="fastioH-2618">#define PE6_WPORT		PORTE</front>
<front id="fastioH-2619">#define PE6_PWM			NULL</front>
<front id="fastioH-2620">#define PE6_DDR			DDRE</front>
<front id="fastioH-2621">#undef PE7</front>
<front id="fastioH-2622">#define PE7_PIN			PINE7</front>
<front id="fastioH-2623">#define PE7_RPORT		PINE</front>
<front id="fastioH-2624">#define PE7_WPORT		PORTE</front>
<front id="fastioH-2625">#define PE7_PWM			NULL</front>
<front id="fastioH-2626">#define PE7_DDR			DDRE</front>
<front id="fastioH-2627"></front>
<front id="fastioH-2628">#undef PF0</front>
<front id="fastioH-2629">#define PF0_PIN			PINF0</front>
<front id="fastioH-2630">#define PF0_RPORT		PINF</front>
<front id="fastioH-2631">#define PF0_WPORT		PORTF</front>
<front id="fastioH-2632">#define PF0_PWM			NULL</front>
<front id="fastioH-2633">#define PF0_DDR			DDRF</front>
<front id="fastioH-2634">#undef PF1</front>
<front id="fastioH-2635">#define PF1_PIN			PINF1</front>
<front id="fastioH-2636">#define PF1_RPORT		PINF</front>
<front id="fastioH-2637">#define PF1_WPORT		PORTF</front>
<front id="fastioH-2638">#define PF1_PWM			NULL</front>
<front id="fastioH-2639">#define PF1_DDR			DDRF</front>
<front id="fastioH-2640">#undef PF2</front>
<front id="fastioH-2641">#define PF2_PIN			PINF2</front>
<front id="fastioH-2642">#define PF2_RPORT		PINF</front>
<front id="fastioH-2643">#define PF2_WPORT		PORTF</front>
<front id="fastioH-2644">#define PF2_PWM			NULL</front>
<front id="fastioH-2645">#define PF2_DDR			DDRF</front>
<front id="fastioH-2646">#undef PF3</front>
<front id="fastioH-2647">#define PF3_PIN			PINF3</front>
<front id="fastioH-2648">#define PF3_RPORT		PINF</front>
<front id="fastioH-2649">#define PF3_WPORT		PORTF</front>
<front id="fastioH-2650">#define PF3_PWM			NULL</front>
<front id="fastioH-2651">#define PF3_DDR			DDRF</front>
<front id="fastioH-2652">#undef PF4</front>
<front id="fastioH-2653">#define PF4_PIN			PINF4</front>
<front id="fastioH-2654">#define PF4_RPORT		PINF</front>
<front id="fastioH-2655">#define PF4_WPORT		PORTF</front>
<front id="fastioH-2656">#define PF4_PWM			NULL</front>
<front id="fastioH-2657">#define PF4_DDR			DDRF</front>
<front id="fastioH-2658">#undef PF5</front>
<front id="fastioH-2659">#define PF5_PIN			PINF5</front>
<front id="fastioH-2660">#define PF5_RPORT		PINF</front>
<front id="fastioH-2661">#define PF5_WPORT		PORTF</front>
<front id="fastioH-2662">#define PF5_PWM			NULL</front>
<front id="fastioH-2663">#define PF5_DDR			DDRF</front>
<front id="fastioH-2664">#undef PF6</front>
<front id="fastioH-2665">#define PF6_PIN			PINF6</front>
<front id="fastioH-2666">#define PF6_RPORT		PINF</front>
<front id="fastioH-2667">#define PF6_WPORT		PORTF</front>
<front id="fastioH-2668">#define PF6_PWM			NULL</front>
<front id="fastioH-2669">#define PF6_DDR			DDRF</front>
<front id="fastioH-2670">#undef PF7</front>
<front id="fastioH-2671">#define PF7_PIN			PINF7</front>
<front id="fastioH-2672">#define PF7_RPORT		PINF</front>
<front id="fastioH-2673">#define PF7_WPORT		PORTF</front>
<front id="fastioH-2674">#define PF7_PWM			NULL</front>
<front id="fastioH-2675">#define PF7_DDR			DDRF</front>
<front id="fastioH-2676"></front>
<front id="fastioH-2677">#else // AT90USBxx_TEENSYPP_ASSIGNMENTS -- Use Teensyduino Teensy++2.0 assignments.</front>
<front id="fastioH-2678"></front>
<front id="fastioH-2679">/*</front>
<front id="fastioH-2680"></front>
<front id="fastioH-2681">AT90USB  51 50 49 48 47 46 45 44 10 11 12 13 14 15 16 17 35 36 37 38 39 40 41 42 25 26 27 28 29 30 31 32 33 34 43 09 18 19 01 02 61 60 59 58 57 56 55 54 </front>
<front id="fastioH-2682">Port     A0 A1 A2 A3 A4 A5 A6 A7 B0 B1 B2 B3 B4 B5 B6 B7 C0 C1 C2 C3 C4 C5 C6 C7 D0 D1 D2 D3 D4 D5 D6 D7 E0 E1 E2 E3 E4 E5 E6 E7 F0 F1 F2 F3 F4 F5 F6 F7 </front>
<front id="fastioH-2683">Marlin   00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47</front>
<front id="fastioH-2684">Teensy   28 29 30 31 32 33 34 35 20 21 22 23 24 25 26 27 10 11 12 13 14 15 16 17 00 01 02 03 04 05 06 07 08 09(46*47)36 37 18 19 38 39 40 41 42 43 44 45</front>
<front id="fastioH-2685">         The pins 46 and 47 are not supported by Teensyduino, but are supported below.</front>
<front id="fastioH-2686">*/</front>
<front id="fastioH-2687"></front>
<front id="fastioH-2688">#define DIO0_PIN PIND0</front>
<front id="fastioH-2689">#define DIO0_RPORT PIND</front>
<front id="fastioH-2690">#define DIO0_WPORT PORTD</front>
<front id="fastioH-2691">#define DIO0_PWM NULL</front>
<front id="fastioH-2692">#define DIO0_DDR DDRD</front>
<front id="fastioH-2693"></front>
<front id="fastioH-2694">#define DIO1_PIN PIND1</front>
<front id="fastioH-2695">#define DIO1_RPORT PIND</front>
<front id="fastioH-2696">#define DIO1_WPORT PORTD</front>
<front id="fastioH-2697">#define DIO1_PWM NULL</front>
<front id="fastioH-2698">#define DIO1_DDR DDRD</front>
<front id="fastioH-2699"></front>
<front id="fastioH-2700">#define DIO2_PIN PIND2</front>
<front id="fastioH-2701">#define DIO2_RPORT PIND</front>
<front id="fastioH-2702">#define DIO2_WPORT PORTD</front>
<front id="fastioH-2703">#define DIO2_PWM NULL</front>
<front id="fastioH-2704">#define DIO2_DDR DDRD</front>
<front id="fastioH-2705"></front>
<front id="fastioH-2706">#define DIO3_PIN PIND3</front>
<front id="fastioH-2707">#define DIO3_RPORT PIND</front>
<front id="fastioH-2708">#define DIO3_WPORT PORTD</front>
<front id="fastioH-2709">#define DIO3_PWM NULL</front>
<front id="fastioH-2710">#define DIO3_DDR DDRD</front>
<front id="fastioH-2711"></front>
<front id="fastioH-2712">#define DIO4_PIN PIND4</front>
<front id="fastioH-2713">#define DIO4_RPORT PIND</front>
<front id="fastioH-2714">#define DIO4_WPORT PORTD</front>
<front id="fastioH-2715">#define DIO4_PWM NULL</front>
<front id="fastioH-2716">#define DIO4_DDR DDRD</front>
<front id="fastioH-2717"></front>
<front id="fastioH-2718">#define DIO5_PIN PIND5</front>
<front id="fastioH-2719">#define DIO5_RPORT PIND</front>
<front id="fastioH-2720">#define DIO5_WPORT PORTD</front>
<front id="fastioH-2721">#define DIO5_PWM NULL</front>
<front id="fastioH-2722">#define DIO5_DDR DDRD</front>
<front id="fastioH-2723"></front>
<front id="fastioH-2724">#define DIO6_PIN PIND6</front>
<front id="fastioH-2725">#define DIO6_RPORT PIND</front>
<front id="fastioH-2726">#define DIO6_WPORT PORTD</front>
<front id="fastioH-2727">#define DIO6_PWM NULL</front>
<front id="fastioH-2728">#define DIO6_DDR DDRD</front>
<front id="fastioH-2729"></front>
<front id="fastioH-2730">#define DIO7_PIN PIND7</front>
<front id="fastioH-2731">#define DIO7_RPORT PIND</front>
<front id="fastioH-2732">#define DIO7_WPORT PORTD</front>
<front id="fastioH-2733">#define DIO7_PWM NULL</front>
<front id="fastioH-2734">#define DIO7_DDR DDRD</front>
<front id="fastioH-2735"></front>
<front id="fastioH-2736">#define DIO8_PIN PINE0</front>
<front id="fastioH-2737">#define DIO8_RPORT PINE</front>
<front id="fastioH-2738">#define DIO8_WPORT PORTE</front>
<front id="fastioH-2739">#define DIO8_PWM NULL</front>
<front id="fastioH-2740">#define DIO8_DDR DDRE</front>
<front id="fastioH-2741"></front>
<front id="fastioH-2742">#define DIO9_PIN PINE1</front>
<front id="fastioH-2743">#define DIO9_RPORT PINE</front>
<front id="fastioH-2744">#define DIO9_WPORT PORTE</front>
<front id="fastioH-2745">#define DIO9_PWM NULL</front>
<front id="fastioH-2746">#define DIO9_DDR DDRE</front>
<front id="fastioH-2747"></front>
<front id="fastioH-2748">#define DIO10_PIN PINC0</front>
<front id="fastioH-2749">#define DIO10_RPORT PINC</front>
<front id="fastioH-2750">#define DIO10_WPORT PORTC</front>
<front id="fastioH-2751">#define DIO10_PWM NULL</front>
<front id="fastioH-2752">#define DIO10_DDR DDRC</front>
<front id="fastioH-2753"></front>
<front id="fastioH-2754">#define DIO11_PIN PINC1</front>
<front id="fastioH-2755">#define DIO11_RPORT PINC</front>
<front id="fastioH-2756">#define DIO11_WPORT PORTC</front>
<front id="fastioH-2757">#define DIO11_PWM NULL</front>
<front id="fastioH-2758">#define DIO11_DDR DDRC</front>
<front id="fastioH-2759"></front>
<front id="fastioH-2760">#define DIO12_PIN PINC2</front>
<front id="fastioH-2761">#define DIO12_RPORT PINC</front>
<front id="fastioH-2762">#define DIO12_WPORT PORTC</front>
<front id="fastioH-2763">#define DIO12_PWM NULL</front>
<front id="fastioH-2764">#define DIO12_DDR DDRC</front>
<front id="fastioH-2765"></front>
<front id="fastioH-2766">#define DIO13_PIN PINC3</front>
<front id="fastioH-2767">#define DIO13_RPORT PINC</front>
<front id="fastioH-2768">#define DIO13_WPORT PORTC</front>
<front id="fastioH-2769">#define DIO13_PWM NULL</front>
<front id="fastioH-2770">#define DIO13_DDR DDRC</front>
<front id="fastioH-2771"></front>
<front id="fastioH-2772">#define DIO14_PIN PINC4</front>
<front id="fastioH-2773">#define DIO14_RPORT PINC</front>
<front id="fastioH-2774">#define DIO14_WPORT PORTC</front>
<front id="fastioH-2775">#define DIO14_PWM NULL</front>
<front id="fastioH-2776">#define DIO14_DDR DDRC</front>
<front id="fastioH-2777"></front>
<front id="fastioH-2778">#define DIO15_PIN PINC5</front>
<front id="fastioH-2779">#define DIO15_RPORT PINC</front>
<front id="fastioH-2780">#define DIO15_WPORT PORTC</front>
<front id="fastioH-2781">#define DIO15_PWM NULL</front>
<front id="fastioH-2782">#define DIO15_DDR DDRC</front>
<front id="fastioH-2783"></front>
<front id="fastioH-2784">#define DIO16_PIN PINC6</front>
<front id="fastioH-2785">#define DIO16_RPORT PINC</front>
<front id="fastioH-2786">#define DIO16_WPORT PORTC</front>
<front id="fastioH-2787">#define DIO16_PWM NULL</front>
<front id="fastioH-2788">#define DIO16_DDR DDRC</front>
<front id="fastioH-2789"></front>
<front id="fastioH-2790">#define DIO17_PIN PINC7</front>
<front id="fastioH-2791">#define DIO17_RPORT PINC</front>
<front id="fastioH-2792">#define DIO17_WPORT PORTC</front>
<front id="fastioH-2793">#define DIO17_PWM NULL</front>
<front id="fastioH-2794">#define DIO17_DDR DDRC</front>
<front id="fastioH-2795"></front>
<front id="fastioH-2796">#define DIO18_PIN PINE6</front>
<front id="fastioH-2797">#define DIO18_RPORT PINE</front>
<front id="fastioH-2798">#define DIO18_WPORT PORTE</front>
<front id="fastioH-2799">#define DIO18_PWM NULL</front>
<front id="fastioH-2800">#define DIO18_DDR DDRE</front>
<front id="fastioH-2801"></front>
<front id="fastioH-2802">#define DIO19_PIN PINE7</front>
<front id="fastioH-2803">#define DIO19_RPORT PINE</front>
<front id="fastioH-2804">#define DIO19_WPORT PORTE</front>
<front id="fastioH-2805">#define DIO19_PWM NULL</front>
<front id="fastioH-2806">#define DIO19_DDR DDRE</front>
<front id="fastioH-2807"></front>
<front id="fastioH-2808">#define DIO20_PIN PINB0</front>
<front id="fastioH-2809">#define DIO20_RPORT PINB</front>
<front id="fastioH-2810">#define DIO20_WPORT PORTB</front>
<front id="fastioH-2811">#define DIO20_PWM NULL</front>
<front id="fastioH-2812">#define DIO20_DDR DDRB</front>
<front id="fastioH-2813"></front>
<front id="fastioH-2814">#define DIO21_PIN PINB1</front>
<front id="fastioH-2815">#define DIO21_RPORT PINB</front>
<front id="fastioH-2816">#define DIO21_WPORT PORTB</front>
<front id="fastioH-2817">#define DIO21_PWM NULL</front>
<front id="fastioH-2818">#define DIO21_DDR DDRB</front>
<front id="fastioH-2819"></front>
<front id="fastioH-2820">#define DIO22_PIN PINB2</front>
<front id="fastioH-2821">#define DIO22_RPORT PINB</front>
<front id="fastioH-2822">#define DIO22_WPORT PORTB</front>
<front id="fastioH-2823">#define DIO22_PWM NULL</front>
<front id="fastioH-2824">#define DIO22_DDR DDRB</front>
<front id="fastioH-2825"></front>
<front id="fastioH-2826">#define DIO23_PIN PINB3</front>
<front id="fastioH-2827">#define DIO23_RPORT PINB</front>
<front id="fastioH-2828">#define DIO23_WPORT PORTB</front>
<front id="fastioH-2829">#define DIO23_PWM NULL</front>
<front id="fastioH-2830">#define DIO23_DDR DDRB</front>
<front id="fastioH-2831"></front>
<front id="fastioH-2832">#define DIO24_PIN PINB4</front>
<front id="fastioH-2833">#define DIO24_RPORT PINB</front>
<front id="fastioH-2834">#define DIO24_WPORT PORTB</front>
<front id="fastioH-2835">#define DIO24_PWM NULL</front>
<front id="fastioH-2836">#define DIO24_DDR DDRB</front>
<front id="fastioH-2837"></front>
<front id="fastioH-2838">#define DIO25_PIN PINB5</front>
<front id="fastioH-2839">#define DIO25_RPORT PINB</front>
<front id="fastioH-2840">#define DIO25_WPORT PORTB</front>
<front id="fastioH-2841">#define DIO25_PWM NULL</front>
<front id="fastioH-2842">#define DIO25_DDR DDRB</front>
<front id="fastioH-2843"></front>
<front id="fastioH-2844">#define DIO26_PIN PINB6</front>
<front id="fastioH-2845">#define DIO26_RPORT PINB</front>
<front id="fastioH-2846">#define DIO26_WPORT PORTB</front>
<front id="fastioH-2847">#define DIO26_PWM NULL</front>
<front id="fastioH-2848">#define DIO26_DDR DDRB</front>
<front id="fastioH-2849"></front>
<front id="fastioH-2850">#define DIO27_PIN PINB7</front>
<front id="fastioH-2851">#define DIO27_RPORT PINB</front>
<front id="fastioH-2852">#define DIO27_WPORT PORTB</front>
<front id="fastioH-2853">#define DIO27_PWM NULL</front>
<front id="fastioH-2854">#define DIO27_DDR DDRB</front>
<front id="fastioH-2855"></front>
<front id="fastioH-2856">#define DIO28_PIN PINA0</front>
<front id="fastioH-2857">#define DIO28_RPORT PINA</front>
<front id="fastioH-2858">#define DIO28_WPORT PORTA</front>
<front id="fastioH-2859">#define DIO28_PWM NULL</front>
<front id="fastioH-2860">#define DIO28_DDR DDRA</front>
<front id="fastioH-2861"></front>
<front id="fastioH-2862">#define DIO29_PIN PINA1</front>
<front id="fastioH-2863">#define DIO29_RPORT PINA</front>
<front id="fastioH-2864">#define DIO29_WPORT PORTA</front>
<front id="fastioH-2865">#define DIO29_PWM NULL</front>
<front id="fastioH-2866">#define DIO29_DDR DDRA</front>
<front id="fastioH-2867"></front>
<front id="fastioH-2868">#define DIO30_PIN PINA2</front>
<front id="fastioH-2869">#define DIO30_RPORT PINA</front>
<front id="fastioH-2870">#define DIO30_WPORT PORTA</front>
<front id="fastioH-2871">#define DIO30_PWM NULL</front>
<front id="fastioH-2872">#define DIO30_DDR DDRA</front>
<front id="fastioH-2873"></front>
<front id="fastioH-2874">#define DIO31_PIN PINA3</front>
<front id="fastioH-2875">#define DIO31_RPORT PINA</front>
<front id="fastioH-2876">#define DIO31_WPORT PORTA</front>
<front id="fastioH-2877">#define DIO31_PWM NULL</front>
<front id="fastioH-2878">#define DIO31_DDR DDRA</front>
<front id="fastioH-2879"></front>
<front id="fastioH-2880">#define DIO32_PIN PINA4</front>
<front id="fastioH-2881">#define DIO32_RPORT PINA</front>
<front id="fastioH-2882">#define DIO32_WPORT PORTA</front>
<front id="fastioH-2883">#define DIO32_PWM NULL</front>
<front id="fastioH-2884">#define DIO32_DDR DDRA</front>
<front id="fastioH-2885"></front>
<front id="fastioH-2886">#define DIO33_PIN PINA5</front>
<front id="fastioH-2887">#define DIO33_RPORT PINA</front>
<front id="fastioH-2888">#define DIO33_WPORT PORTA</front>
<front id="fastioH-2889">#define DIO33_PWM NULL</front>
<front id="fastioH-2890">#define DIO33_DDR DDRA</front>
<front id="fastioH-2891"></front>
<front id="fastioH-2892">#define DIO34_PIN PINA6</front>
<front id="fastioH-2893">#define DIO34_RPORT PINA</front>
<front id="fastioH-2894">#define DIO34_WPORT PORTA</front>
<front id="fastioH-2895">#define DIO34_PWM NULL</front>
<front id="fastioH-2896">#define DIO34_DDR DDRA</front>
<front id="fastioH-2897"></front>
<front id="fastioH-2898">#define DIO35_PIN PINA7</front>
<front id="fastioH-2899">#define DIO35_RPORT PINA</front>
<front id="fastioH-2900">#define DIO35_WPORT PORTA</front>
<front id="fastioH-2901">#define DIO35_PWM NULL</front>
<front id="fastioH-2902">#define DIO35_DDR DDRA</front>
<front id="fastioH-2903"></front>
<front id="fastioH-2904">#define DIO36_PIN PINE4</front>
<front id="fastioH-2905">#define DIO36_RPORT PINE</front>
<front id="fastioH-2906">#define DIO36_WPORT PORTE</front>
<front id="fastioH-2907">#define DIO36_PWM NULL</front>
<front id="fastioH-2908">#define DIO36_DDR DDRE</front>
<front id="fastioH-2909"></front>
<front id="fastioH-2910">#define DIO37_PIN PINE5</front>
<front id="fastioH-2911">#define DIO37_RPORT PINE</front>
<front id="fastioH-2912">#define DIO37_WPORT PORTE</front>
<front id="fastioH-2913">#define DIO37_PWM NULL</front>
<front id="fastioH-2914">#define DIO37_DDR DDRE</front>
<front id="fastioH-2915"></front>
<front id="fastioH-2916">#define DIO38_PIN PINF0</front>
<front id="fastioH-2917">#define DIO38_RPORT PINF</front>
<front id="fastioH-2918">#define DIO38_WPORT PORTF</front>
<front id="fastioH-2919">#define DIO38_PWM NULL</front>
<front id="fastioH-2920">#define DIO38_DDR DDRF</front>
<front id="fastioH-2921"></front>
<front id="fastioH-2922">#define DIO39_PIN PINF1</front>
<front id="fastioH-2923">#define DIO39_RPORT PINF</front>
<front id="fastioH-2924">#define DIO39_WPORT PORTF</front>
<front id="fastioH-2925">#define DIO39_PWM NULL</front>
<front id="fastioH-2926">#define DIO39_DDR DDRF</front>
<front id="fastioH-2927"></front>
<front id="fastioH-2928">#define DIO40_PIN PINF2</front>
<front id="fastioH-2929">#define DIO40_RPORT PINF</front>
<front id="fastioH-2930">#define DIO40_WPORT PORTF</front>
<front id="fastioH-2931">#define DIO40_PWM NULL</front>
<front id="fastioH-2932">#define DIO40_DDR DDRF</front>
<front id="fastioH-2933"></front>
<front id="fastioH-2934">#define DIO41_PIN PINF3</front>
<front id="fastioH-2935">#define DIO41_RPORT PINF</front>
<front id="fastioH-2936">#define DIO41_WPORT PORTF</front>
<front id="fastioH-2937">#define DIO41_PWM NULL</front>
<front id="fastioH-2938">#define DIO41_DDR DDRF</front>
<front id="fastioH-2939"></front>
<front id="fastioH-2940">#define DIO42_PIN PINF4</front>
<front id="fastioH-2941">#define DIO42_RPORT PINF</front>
<front id="fastioH-2942">#define DIO42_WPORT PORTF</front>
<front id="fastioH-2943">#define DIO42_PWM NULL</front>
<front id="fastioH-2944">#define DIO42_DDR DDRF</front>
<front id="fastioH-2945"></front>
<front id="fastioH-2946">#define DIO43_PIN PINF5</front>
<front id="fastioH-2947">#define DIO43_RPORT PINF</front>
<front id="fastioH-2948">#define DIO43_WPORT PORTF</front>
<front id="fastioH-2949">#define DIO43_PWM NULL</front>
<front id="fastioH-2950">#define DIO43_DDR DDRF</front>
<front id="fastioH-2951"></front>
<front id="fastioH-2952">#define DIO44_PIN PINF6</front>
<front id="fastioH-2953">#define DIO44_RPORT PINF</front>
<front id="fastioH-2954">#define DIO44_WPORT PORTF</front>
<front id="fastioH-2955">#define DIO44_PWM NULL</front>
<front id="fastioH-2956">#define DIO44_DDR DDRF</front>
<front id="fastioH-2957"></front>
<front id="fastioH-2958">#define DIO45_PIN PINF7</front>
<front id="fastioH-2959">#define DIO45_RPORT PINF</front>
<front id="fastioH-2960">#define DIO45_WPORT PORTF</front>
<front id="fastioH-2961">#define DIO45_PWM NULL</front>
<front id="fastioH-2962">#define DIO45_DDR DDRF</front>
<front id="fastioH-2963"></front>
<front id="fastioH-2964">#define AIO0_PIN PINF0</front>
<front id="fastioH-2965">#define AIO0_RPORT PINF</front>
<front id="fastioH-2966">#define AIO0_WPORT PORTF</front>
<front id="fastioH-2967">#define AIO0_PWM NULL</front>
<front id="fastioH-2968">#define AIO0_DDR DDRF</front>
<front id="fastioH-2969"></front>
<front id="fastioH-2970">#define AIO1_PIN PINF1</front>
<front id="fastioH-2971">#define AIO1_RPORT PINF</front>
<front id="fastioH-2972">#define AIO1_WPORT PORTF</front>
<front id="fastioH-2973">#define AIO1_PWM NULL</front>
<front id="fastioH-2974">#define AIO1_DDR DDRF</front>
<front id="fastioH-2975"></front>
<front id="fastioH-2976">#define AIO2_PIN PINF2</front>
<front id="fastioH-2977">#define AIO2_RPORT PINF</front>
<front id="fastioH-2978">#define AIO2_WPORT PORTF</front>
<front id="fastioH-2979">#define AIO2_PWM NULL</front>
<front id="fastioH-2980">#define AIO2_DDR DDRF</front>
<front id="fastioH-2981"></front>
<front id="fastioH-2982">#define AIO3_PIN PINF3</front>
<front id="fastioH-2983">#define AIO3_RPORT PINF</front>
<front id="fastioH-2984">#define AIO3_WPORT PORTF</front>
<front id="fastioH-2985">#define AIO3_PWM NULL</front>
<front id="fastioH-2986">#define AIO3_DDR DDRF</front>
<front id="fastioH-2987"></front>
<front id="fastioH-2988">#define AIO4_PIN PINF4</front>
<front id="fastioH-2989">#define AIO4_RPORT PINF</front>
<front id="fastioH-2990">#define AIO4_WPORT PORTF</front>
<front id="fastioH-2991">#define AIO4_PWM NULL</front>
<front id="fastioH-2992">#define AIO4_DDR DDRF</front>
<front id="fastioH-2993"></front>
<front id="fastioH-2994">#define AIO5_PIN PINF5</front>
<front id="fastioH-2995">#define AIO5_RPORT PINF</front>
<front id="fastioH-2996">#define AIO5_WPORT PORTF</front>
<front id="fastioH-2997">#define AIO5_PWM NULL</front>
<front id="fastioH-2998">#define AIO5_DDR DDRF</front>
<front id="fastioH-2999"></front>
<front id="fastioH-3000">#define AIO6_PIN PINF6</front>
<front id="fastioH-3001">#define AIO6_RPORT PINF</front>
<front id="fastioH-3002">#define AIO6_WPORT PORTF</front>
<front id="fastioH-3003">#define AIO6_PWM NULL</front>
<front id="fastioH-3004">#define AIO6_DDR DDRF</front>
<front id="fastioH-3005"></front>
<front id="fastioH-3006">#define AIO7_PIN PINF7</front>
<front id="fastioH-3007">#define AIO7_RPORT PINF</front>
<front id="fastioH-3008">#define AIO7_WPORT PORTF</front>
<front id="fastioH-3009">#define AIO7_PWM NULL</front>
<front id="fastioH-3010">#define AIO7_DDR DDRF</front>
<front id="fastioH-3011"></front>
<front id="fastioH-3012">//-- Begin not supported by Teensyduino</front>
<front id="fastioH-3013">//-- don't use Arduino functions on these pins pinMode/digitalWrite/etc</front>
<front id="fastioH-3014">#define DIO46_PIN PINE2</front>
<front id="fastioH-3015">#define DIO46_RPORT PINE</front>
<front id="fastioH-3016">#define DIO46_WPORT PORTE</front>
<front id="fastioH-3017">#define DIO46_PWM NULL</front>
<front id="fastioH-3018">#define DIO46_DDR DDRE</front>
<front id="fastioH-3019"></front>
<front id="fastioH-3020">#define DIO47_PIN PINE3</front>
<front id="fastioH-3021">#define DIO47_RPORT PINE</front>
<front id="fastioH-3022">#define DIO47_WPORT PORTE</front>
<front id="fastioH-3023">#define DIO47_PWM NULL</front>
<front id="fastioH-3024">#define DIO47_DDR DDRE</front>
<front id="fastioH-3025">//-- end not supported by Teensyduino</front>
<front id="fastioH-3026"></front>
<front id="fastioH-3027">#undef PA0</front>
<front id="fastioH-3028">#define PA0_PIN PINA0</front>
<front id="fastioH-3029">#define PA0_RPORT PINA</front>
<front id="fastioH-3030">#define PA0_WPORT PORTA</front>
<front id="fastioH-3031">#define PA0_PWM NULL</front>
<front id="fastioH-3032">#define PA0_DDR DDRA</front>
<front id="fastioH-3033">#undef PA1</front>
<front id="fastioH-3034">#define PA1_PIN PINA1</front>
<front id="fastioH-3035">#define PA1_RPORT PINA</front>
<front id="fastioH-3036">#define PA1_WPORT PORTA</front>
<front id="fastioH-3037">#define PA1_PWM NULL</front>
<front id="fastioH-3038">#define PA1_DDR DDRA</front>
<front id="fastioH-3039">#undef PA2</front>
<front id="fastioH-3040">#define PA2_PIN PINA2</front>
<front id="fastioH-3041">#define PA2_RPORT PINA</front>
<front id="fastioH-3042">#define PA2_WPORT PORTA</front>
<front id="fastioH-3043">#define PA2_PWM NULL</front>
<front id="fastioH-3044">#define PA2_DDR DDRA</front>
<front id="fastioH-3045">#undef PA3</front>
<front id="fastioH-3046">#define PA3_PIN PINA3</front>
<front id="fastioH-3047">#define PA3_RPORT PINA</front>
<front id="fastioH-3048">#define PA3_WPORT PORTA</front>
<front id="fastioH-3049">#define PA3_PWM NULL</front>
<front id="fastioH-3050">#define PA3_DDR DDRA</front>
<front id="fastioH-3051">#undef PA4</front>
<front id="fastioH-3052">#define PA4_PIN PINA4</front>
<front id="fastioH-3053">#define PA4_RPORT PINA</front>
<front id="fastioH-3054">#define PA4_WPORT PORTA</front>
<front id="fastioH-3055">#define PA4_PWM NULL</front>
<front id="fastioH-3056">#define PA4_DDR DDRA</front>
<front id="fastioH-3057">#undef PA5</front>
<front id="fastioH-3058">#define PA5_PIN PINA5</front>
<front id="fastioH-3059">#define PA5_RPORT PINA</front>
<front id="fastioH-3060">#define PA5_WPORT PORTA</front>
<front id="fastioH-3061">#define PA5_PWM NULL</front>
<front id="fastioH-3062">#define PA5_DDR DDRA</front>
<front id="fastioH-3063">#undef PA6</front>
<front id="fastioH-3064">#define PA6_PIN PINA6</front>
<front id="fastioH-3065">#define PA6_RPORT PINA</front>
<front id="fastioH-3066">#define PA6_WPORT PORTA</front>
<front id="fastioH-3067">#define PA6_PWM NULL</front>
<front id="fastioH-3068">#define PA6_DDR DDRA</front>
<front id="fastioH-3069">#undef PA7</front>
<front id="fastioH-3070">#define PA7_PIN PINA7</front>
<front id="fastioH-3071">#define PA7_RPORT PINA</front>
<front id="fastioH-3072">#define PA7_WPORT PORTA</front>
<front id="fastioH-3073">#define PA7_PWM NULL</front>
<front id="fastioH-3074">#define PA7_DDR DDRA</front>
<front id="fastioH-3075"></front>
<front id="fastioH-3076">#undef PB0</front>
<front id="fastioH-3077">#define PB0_PIN PINB0</front>
<front id="fastioH-3078">#define PB0_RPORT PINB</front>
<front id="fastioH-3079">#define PB0_WPORT PORTB</front>
<front id="fastioH-3080">#define PB0_PWM NULL</front>
<front id="fastioH-3081">#define PB0_DDR DDRB</front>
<front id="fastioH-3082">#undef PB1</front>
<front id="fastioH-3083">#define PB1_PIN PINB1</front>
<front id="fastioH-3084">#define PB1_RPORT PINB</front>
<front id="fastioH-3085">#define PB1_WPORT PORTB</front>
<front id="fastioH-3086">#define PB1_PWM NULL</front>
<front id="fastioH-3087">#define PB1_DDR DDRB</front>
<front id="fastioH-3088">#undef PB2</front>
<front id="fastioH-3089">#define PB2_PIN PINB2</front>
<front id="fastioH-3090">#define PB2_RPORT PINB</front>
<front id="fastioH-3091">#define PB2_WPORT PORTB</front>
<front id="fastioH-3092">#define PB2_PWM NULL</front>
<front id="fastioH-3093">#define PB2_DDR DDRB</front>
<front id="fastioH-3094">#undef PB3</front>
<front id="fastioH-3095">#define PB3_PIN PINB3</front>
<front id="fastioH-3096">#define PB3_RPORT PINB</front>
<front id="fastioH-3097">#define PB3_WPORT PORTB</front>
<front id="fastioH-3098">#define PB3_PWM NULL</front>
<front id="fastioH-3099">#define PB3_DDR DDRB</front>
<front id="fastioH-3100">#undef PB4</front>
<front id="fastioH-3101">#define PB4_PIN PINB4</front>
<front id="fastioH-3102">#define PB4_RPORT PINB</front>
<front id="fastioH-3103">#define PB4_WPORT PORTB</front>
<front id="fastioH-3104">#define PB4_PWM NULL</front>
<front id="fastioH-3105">#define PB4_DDR DDRB</front>
<front id="fastioH-3106">#undef PB5</front>
<front id="fastioH-3107">#define PB5_PIN PINB5</front>
<front id="fastioH-3108">#define PB5_RPORT PINB</front>
<front id="fastioH-3109">#define PB5_WPORT PORTB</front>
<front id="fastioH-3110">#define PB5_PWM NULL</front>
<front id="fastioH-3111">#define PB5_DDR DDRB</front>
<front id="fastioH-3112">#undef PB6</front>
<front id="fastioH-3113">#define PB6_PIN PINB6</front>
<front id="fastioH-3114">#define PB6_RPORT PINB</front>
<front id="fastioH-3115">#define PB6_WPORT PORTB</front>
<front id="fastioH-3116">#define PB6_PWM NULL</front>
<front id="fastioH-3117">#define PB6_DDR DDRB</front>
<front id="fastioH-3118">#undef PB7</front>
<front id="fastioH-3119">#define PB7_PIN PINB7</front>
<front id="fastioH-3120">#define PB7_RPORT PINB</front>
<front id="fastioH-3121">#define PB7_WPORT PORTB</front>
<front id="fastioH-3122">#define PB7_PWM NULL</front>
<front id="fastioH-3123">#define PB7_DDR DDRB</front>
<front id="fastioH-3124"></front>
<front id="fastioH-3125">#undef PC0</front>
<front id="fastioH-3126">#define PC0_PIN PINC0</front>
<front id="fastioH-3127">#define PC0_RPORT PINC</front>
<front id="fastioH-3128">#define PC0_WPORT PORTC</front>
<front id="fastioH-3129">#define PC0_PWM NULL</front>
<front id="fastioH-3130">#define PC0_DDR DDRC</front>
<front id="fastioH-3131">#undef PC1</front>
<front id="fastioH-3132">#define PC1_PIN PINC1</front>
<front id="fastioH-3133">#define PC1_RPORT PINC</front>
<front id="fastioH-3134">#define PC1_WPORT PORTC</front>
<front id="fastioH-3135">#define PC1_PWM NULL</front>
<front id="fastioH-3136">#define PC1_DDR DDRC</front>
<front id="fastioH-3137">#undef PC2</front>
<front id="fastioH-3138">#define PC2_PIN PINC2</front>
<front id="fastioH-3139">#define PC2_RPORT PINC</front>
<front id="fastioH-3140">#define PC2_WPORT PORTC</front>
<front id="fastioH-3141">#define PC2_PWM NULL</front>
<front id="fastioH-3142">#define PC2_DDR DDRC</front>
<front id="fastioH-3143">#undef PC3</front>
<front id="fastioH-3144">#define PC3_PIN PINC3</front>
<front id="fastioH-3145">#define PC3_RPORT PINC</front>
<front id="fastioH-3146">#define PC3_WPORT PORTC</front>
<front id="fastioH-3147">#define PC3_PWM NULL</front>
<front id="fastioH-3148">#define PC3_DDR DDRC</front>
<front id="fastioH-3149">#undef PC4</front>
<front id="fastioH-3150">#define PC4_PIN PINC4</front>
<front id="fastioH-3151">#define PC4_RPORT PINC</front>
<front id="fastioH-3152">#define PC4_WPORT PORTC</front>
<front id="fastioH-3153">#define PC4_PWM NULL</front>
<front id="fastioH-3154">#define PC4_DDR DDRC</front>
<front id="fastioH-3155">#undef PC5</front>
<front id="fastioH-3156">#define PC5_PIN PINC5</front>
<front id="fastioH-3157">#define PC5_RPORT PINC</front>
<front id="fastioH-3158">#define PC5_WPORT PORTC</front>
<front id="fastioH-3159">#define PC5_PWM NULL</front>
<front id="fastioH-3160">#define PC5_DDR DDRC</front>
<front id="fastioH-3161">#undef PC6</front>
<front id="fastioH-3162">#define PC6_PIN PINC6</front>
<front id="fastioH-3163">#define PC6_RPORT PINC</front>
<front id="fastioH-3164">#define PC6_WPORT PORTC</front>
<front id="fastioH-3165">#define PC6_PWM NULL</front>
<front id="fastioH-3166">#define PC6_DDR DDRC</front>
<front id="fastioH-3167">#undef PC7</front>
<front id="fastioH-3168">#define PC7_PIN PINC7</front>
<front id="fastioH-3169">#define PC7_RPORT PINC</front>
<front id="fastioH-3170">#define PC7_WPORT PORTC</front>
<front id="fastioH-3171">#define PC7_PWM NULL</front>
<front id="fastioH-3172">#define PC7_DDR DDRC</front>
<front id="fastioH-3173"></front>
<front id="fastioH-3174">#undef PD0</front>
<front id="fastioH-3175">#define PD0_PIN PIND0</front>
<front id="fastioH-3176">#define PD0_RPORT PIND</front>
<front id="fastioH-3177">#define PD0_WPORT PORTD</front>
<front id="fastioH-3178">#define PD0_PWM NULL</front>
<front id="fastioH-3179">#define PD0_DDR DDRD</front>
<front id="fastioH-3180">#undef PD1</front>
<front id="fastioH-3181">#define PD1_PIN PIND1</front>
<front id="fastioH-3182">#define PD1_RPORT PIND</front>
<front id="fastioH-3183">#define PD1_WPORT PORTD</front>
<front id="fastioH-3184">#define PD1_PWM NULL</front>
<front id="fastioH-3185">#define PD1_DDR DDRD</front>
<front id="fastioH-3186">#undef PD2</front>
<front id="fastioH-3187">#define PD2_PIN PIND2</front>
<front id="fastioH-3188">#define PD2_RPORT PIND</front>
<front id="fastioH-3189">#define PD2_WPORT PORTD</front>
<front id="fastioH-3190">#define PD2_PWM NULL</front>
<front id="fastioH-3191">#define PD2_DDR DDRD</front>
<front id="fastioH-3192">#undef PD3</front>
<front id="fastioH-3193">#define PD3_PIN PIND3</front>
<front id="fastioH-3194">#define PD3_RPORT PIND</front>
<front id="fastioH-3195">#define PD3_WPORT PORTD</front>
<front id="fastioH-3196">#define PD3_PWM NULL</front>
<front id="fastioH-3197">#define PD3_DDR DDRD</front>
<front id="fastioH-3198">#undef PD4</front>
<front id="fastioH-3199">#define PD4_PIN PIND4</front>
<front id="fastioH-3200">#define PD4_RPORT PIND</front>
<front id="fastioH-3201">#define PD4_WPORT PORTD</front>
<front id="fastioH-3202">#define PD4_PWM NULL</front>
<front id="fastioH-3203">#define PD4_DDR DDRD</front>
<front id="fastioH-3204">#undef PD5</front>
<front id="fastioH-3205">#define PD5_PIN PIND5</front>
<front id="fastioH-3206">#define PD5_RPORT PIND</front>
<front id="fastioH-3207">#define PD5_WPORT PORTD</front>
<front id="fastioH-3208">#define PD5_PWM NULL</front>
<front id="fastioH-3209">#define PD5_DDR DDRD</front>
<front id="fastioH-3210">#undef PD6</front>
<front id="fastioH-3211">#define PD6_PIN PIND6</front>
<front id="fastioH-3212">#define PD6_RPORT PIND</front>
<front id="fastioH-3213">#define PD6_WPORT PORTD</front>
<front id="fastioH-3214">#define PD6_PWM NULL</front>
<front id="fastioH-3215">#define PD6_DDR DDRD</front>
<front id="fastioH-3216">#undef PD7</front>
<front id="fastioH-3217">#define PD7_PIN PIND7</front>
<front id="fastioH-3218">#define PD7_RPORT PIND</front>
<front id="fastioH-3219">#define PD7_WPORT PORTD</front>
<front id="fastioH-3220">#define PD7_PWM NULL</front>
<front id="fastioH-3221">#define PD7_DDR DDRD</front>
<front id="fastioH-3222"></front>
<front id="fastioH-3223">#undef PE0</front>
<front id="fastioH-3224">#define PE0_PIN PINE0</front>
<front id="fastioH-3225">#define PE0_RPORT PINE</front>
<front id="fastioH-3226">#define PE0_WPORT PORTE</front>
<front id="fastioH-3227">#define PE0_PWM NULL</front>
<front id="fastioH-3228">#define PE0_DDR DDRE</front>
<front id="fastioH-3229">#undef PE1</front>
<front id="fastioH-3230">#define PE1_PIN PINE1</front>
<front id="fastioH-3231">#define PE1_RPORT PINE</front>
<front id="fastioH-3232">#define PE1_WPORT PORTE</front>
<front id="fastioH-3233">#define PE1_PWM NULL</front>
<front id="fastioH-3234">#define PE1_DDR DDRE</front>
<front id="fastioH-3235">#undef PE2</front>
<front id="fastioH-3236">#define PE2_PIN PINE2</front>
<front id="fastioH-3237">#define PE2_RPORT PINE</front>
<front id="fastioH-3238">#define PE2_WPORT PORTE</front>
<front id="fastioH-3239">#define PE2_PWM NULL</front>
<front id="fastioH-3240">#define PE2_DDR DDRE</front>
<front id="fastioH-3241">#undef PE3</front>
<front id="fastioH-3242">#define PE3_PIN PINE3</front>
<front id="fastioH-3243">#define PE3_RPORT PINE</front>
<front id="fastioH-3244">#define PE3_WPORT PORTE</front>
<front id="fastioH-3245">#define PE3_PWM NULL</front>
<front id="fastioH-3246">#define PE3_DDR DDRE</front>
<front id="fastioH-3247">#undef PE4</front>
<front id="fastioH-3248">#define PE4_PIN PINE4</front>
<front id="fastioH-3249">#define PE4_RPORT PINE</front>
<front id="fastioH-3250">#define PE4_WPORT PORTE</front>
<front id="fastioH-3251">#define PE4_PWM NULL</front>
<front id="fastioH-3252">#define PE4_DDR DDRE</front>
<front id="fastioH-3253">#undef PE5</front>
<front id="fastioH-3254">#define PE5_PIN PINE5</front>
<front id="fastioH-3255">#define PE5_RPORT PINE</front>
<front id="fastioH-3256">#define PE5_WPORT PORTE</front>
<front id="fastioH-3257">#define PE5_PWM NULL</front>
<front id="fastioH-3258">#define PE5_DDR DDRE</front>
<front id="fastioH-3259">#undef PE6</front>
<front id="fastioH-3260">#define PE6_PIN PINE6</front>
<front id="fastioH-3261">#define PE6_RPORT PINE</front>
<front id="fastioH-3262">#define PE6_WPORT PORTE</front>
<front id="fastioH-3263">#define PE6_PWM NULL</front>
<front id="fastioH-3264">#define PE6_DDR DDRE</front>
<front id="fastioH-3265">#undef PE7</front>
<front id="fastioH-3266">#define PE7_PIN PINE7</front>
<front id="fastioH-3267">#define PE7_RPORT PINE</front>
<front id="fastioH-3268">#define PE7_WPORT PORTE</front>
<front id="fastioH-3269">#define PE7_PWM NULL</front>
<front id="fastioH-3270">#define PE7_DDR DDRE</front>
<front id="fastioH-3271"></front>
<front id="fastioH-3272">#undef PF0</front>
<front id="fastioH-3273">#define PF0_PIN PINF0</front>
<front id="fastioH-3274">#define PF0_RPORT PINF</front>
<front id="fastioH-3275">#define PF0_WPORT PORTF</front>
<front id="fastioH-3276">#define PF0_PWM NULL</front>
<front id="fastioH-3277">#define PF0_DDR DDRF</front>
<front id="fastioH-3278">#undef PF1</front>
<front id="fastioH-3279">#define PF1_PIN PINF1</front>
<front id="fastioH-3280">#define PF1_RPORT PINF</front>
<front id="fastioH-3281">#define PF1_WPORT PORTF</front>
<front id="fastioH-3282">#define PF1_PWM NULL</front>
<front id="fastioH-3283">#define PF1_DDR DDRF</front>
<front id="fastioH-3284">#undef PF2</front>
<front id="fastioH-3285">#define PF2_PIN PINF2</front>
<front id="fastioH-3286">#define PF2_RPORT PINF</front>
<front id="fastioH-3287">#define PF2_WPORT PORTF</front>
<front id="fastioH-3288">#define PF2_PWM NULL</front>
<front id="fastioH-3289">#define PF2_DDR DDRF</front>
<front id="fastioH-3290">#undef PF3</front>
<front id="fastioH-3291">#define PF3_PIN PINF3</front>
<front id="fastioH-3292">#define PF3_RPORT PINF</front>
<front id="fastioH-3293">#define PF3_WPORT PORTF</front>
<front id="fastioH-3294">#define PF3_PWM NULL</front>
<front id="fastioH-3295">#define PF3_DDR DDRF</front>
<front id="fastioH-3296">#undef PF4</front>
<front id="fastioH-3297">#define PF4_PIN PINF4</front>
<front id="fastioH-3298">#define PF4_RPORT PINF</front>
<front id="fastioH-3299">#define PF4_WPORT PORTF</front>
<front id="fastioH-3300">#define PF4_PWM NULL</front>
<front id="fastioH-3301">#define PF4_DDR DDRF</front>
<front id="fastioH-3302">#undef PF5</front>
<front id="fastioH-3303">#define PF5_PIN PINF5</front>
<front id="fastioH-3304">#define PF5_RPORT PINF</front>
<front id="fastioH-3305">#define PF5_WPORT PORTF</front>
<front id="fastioH-3306">#define PF5_PWM NULL</front>
<front id="fastioH-3307">#define PF5_DDR DDRF</front>
<front id="fastioH-3308">#undef PF6</front>
<front id="fastioH-3309">#define PF6_PIN PINF6</front>
<front id="fastioH-3310">#define PF6_RPORT PINF</front>
<front id="fastioH-3311">#define PF6_WPORT PORTF</front>
<front id="fastioH-3312">#define PF6_PWM NULL</front>
<front id="fastioH-3313">#define PF6_DDR DDRF</front>
<front id="fastioH-3314">#undef PF7</front>
<front id="fastioH-3315">#define PF7_PIN PINF7</front>
<front id="fastioH-3316">#define PF7_RPORT PINF</front>
<front id="fastioH-3317">#define PF7_WPORT PORTF</front>
<front id="fastioH-3318">#define PF7_PWM NULL</front>
<front id="fastioH-3319">#define PF7_DDR DDRF</front>
<front id="fastioH-3320"></front>
<front id="fastioH-3321">#endif // AT90USBxx_TEENSYPP_ASSIGNMENTS Teensyduino assignments</front>
<front id="fastioH-3322">#endif // __AVR_AT90usbxxx__</front>
<front id="fastioH-3323"></front>
<front id="fastioH-3324"></front>
<front id="fastioH-3325">#if defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)</front>
<front id="fastioH-3326">// UART</front>
<front id="fastioH-3327">#define	RXD					DIO0</front>
<front id="fastioH-3328">#define	TXD					DIO1</front>
<front id="fastioH-3329"></front>
<front id="fastioH-3330">// SPI</front>
<front id="fastioH-3331">#define	SCK					DIO10</front>
<front id="fastioH-3332">#define	MISO				DIO12</front>
<front id="fastioH-3333">#define	MOSI				DIO11</front>
<front id="fastioH-3334">#define	SS					DIO16</front>
<front id="fastioH-3335"></front>
<front id="fastioH-3336">// TWI (I2C)</front>
<front id="fastioH-3337">#define	SCL					DIO17</front>
<front id="fastioH-3338">#define	SDA					DIO18</front>
<front id="fastioH-3339"></front>
<front id="fastioH-3340">// timers and PWM</front>
<front id="fastioH-3341">#define	OC0A				DIO9</front>
<front id="fastioH-3342">#define	OC0B				DIO4</front>
<front id="fastioH-3343">#define	OC1A				DIO7</front>
<front id="fastioH-3344">#define	OC1B				DIO8</front>
<front id="fastioH-3345">#define	OC2A				DIO6</front>
<front id="fastioH-3346">#define	OC3A				DIO5</front>
<front id="fastioH-3347">#define	OC3B				DIO2</front>
<front id="fastioH-3348">#define	OC3C				DIO3</front>
<front id="fastioH-3349"></front>
<front id="fastioH-3350"></front>
<front id="fastioH-3351">// change for your board</front>
<front id="fastioH-3352">#define	DEBUG_LED		DIO46</front>
<front id="fastioH-3353"></front>
<front id="fastioH-3354">/*</front>
<front id="fastioH-3355">pins</front>
<front id="fastioH-3356">*/</front>
<front id="fastioH-3357">#define	DIO0_PIN		PINE0</front>
<front id="fastioH-3358">#define	DIO0_RPORT	PINE</front>
<front id="fastioH-3359">#define	DIO0_WPORT	PORTE</front>
<front id="fastioH-3360">#define	DIO0_DDR		DDRE</front>
<front id="fastioH-3361">#define DIO0_PWM		NULL</front>
<front id="fastioH-3362"></front>
<front id="fastioH-3363">#define	DIO1_PIN		PINE1</front>
<front id="fastioH-3364">#define	DIO1_RPORT	PINE</front>
<front id="fastioH-3365">#define	DIO1_WPORT	PORTE</front>
<front id="fastioH-3366">#define	DIO1_DDR		DDRE</front>
<front id="fastioH-3367">#define DIO1_PWM		NULL</front>
<front id="fastioH-3368"></front>
<front id="fastioH-3369">#define	DIO2_PIN		PINE4</front>
<front id="fastioH-3370">#define	DIO2_RPORT	PINE</front>
<front id="fastioH-3371">#define	DIO2_WPORT	PORTE</front>
<front id="fastioH-3372">#define	DIO2_DDR		DDRE</front>
<front id="fastioH-3373">#define DIO2_PWM		&OCR3BL</front>
<front id="fastioH-3374"></front>
<front id="fastioH-3375">#define	DIO3_PIN		PINE5</front>
<front id="fastioH-3376">#define	DIO3_RPORT	PINE</front>
<front id="fastioH-3377">#define	DIO3_WPORT	PORTE</front>
<front id="fastioH-3378">#define	DIO3_DDR		DDRE</front>
<front id="fastioH-3379">#define DIO3_PWM		&OCR3CL</front>
<front id="fastioH-3380"></front>
<front id="fastioH-3381">#define	DIO4_PIN		PING5</front>
<front id="fastioH-3382">#define	DIO4_RPORT	PING</front>
<front id="fastioH-3383">#define	DIO4_WPORT	PORTG</front>
<front id="fastioH-3384">#define	DIO4_DDR		DDRG</front>
<front id="fastioH-3385">#define DIO4_PWM		&OCR0B</front>
<front id="fastioH-3386"></front>
<front id="fastioH-3387">#define	DIO5_PIN		PINE3</front>
<front id="fastioH-3388">#define	DIO5_RPORT	PINE</front>
<front id="fastioH-3389">#define	DIO5_WPORT	PORTE</front>
<front id="fastioH-3390">#define	DIO5_DDR		DDRE</front>
<front id="fastioH-3391">#define DIO5_PWM		&OCR3AL</front>
<front id="fastioH-3392"></front>
<front id="fastioH-3393">#define	DIO6_PIN		PINB4</front>
<front id="fastioH-3394">#define	DIO6_RPORT	PINB</front>
<front id="fastioH-3395">#define	DIO6_WPORT	PORTB</front>
<front id="fastioH-3396">#define	DIO6_DDR		DDRB</front>
<front id="fastioH-3397">#define DIO6_PWM		&OCR2AL</front>
<front id="fastioH-3398"></front>
<front id="fastioH-3399">#define	DIO7_PIN		PINB5</front>
<front id="fastioH-3400">#define	DIO7_RPORT	PINB</front>
<front id="fastioH-3401">#define	DIO7_WPORT	PORTB</front>
<front id="fastioH-3402">#define	DIO7_DDR		DDRB</front>
<front id="fastioH-3403">#define DIO7_PWM		&OCR1AL</front>
<front id="fastioH-3404"></front>
<front id="fastioH-3405">#define	DIO8_PIN		PINB6</front>
<front id="fastioH-3406">#define	DIO8_RPORT	PINB</front>
<front id="fastioH-3407">#define	DIO8_WPORT	PORTB</front>
<front id="fastioH-3408">#define	DIO8_DDR		DDRB</front>
<front id="fastioH-3409">#define DIO8_PWM		&OCR1BL</front>
<front id="fastioH-3410"></front>
<front id="fastioH-3411">#define	DIO9_PIN		PINB7</front>
<front id="fastioH-3412">#define	DIO9_RPORT	PINB</front>
<front id="fastioH-3413">#define	DIO9_WPORT	PORTB</front>
<front id="fastioH-3414">#define	DIO9_DDR		DDRB</front>
<front id="fastioH-3415">#define DIO9_PWM		&OCR0AL</front>
<front id="fastioH-3416"></front>
<front id="fastioH-3417">#define	DIO10_PIN		PINB1</front>
<front id="fastioH-3418">#define	DIO10_RPORT	PINB</front>
<front id="fastioH-3419">#define	DIO10_WPORT	PORTB</front>
<front id="fastioH-3420">#define	DIO10_DDR		DDRB</front>
<front id="fastioH-3421">#define DIO10_PWM		NULL</front>
<front id="fastioH-3422"></front>
<front id="fastioH-3423">#define	DIO11_PIN		PINB2</front>
<front id="fastioH-3424">#define	DIO11_RPORT	PINB</front>
<front id="fastioH-3425">#define	DIO11_WPORT	PORTB</front>
<front id="fastioH-3426">#define	DIO11_DDR		DDRB</front>
<front id="fastioH-3427">#define DIO11_PWM		NULL</front>
<front id="fastioH-3428"></front>
<front id="fastioH-3429">#define	DIO12_PIN		PINB3</front>
<front id="fastioH-3430">#define	DIO12_RPORT	PINB</front>
<front id="fastioH-3431">#define	DIO12_WPORT	PORTB</front>
<front id="fastioH-3432">#define	DIO12_DDR		DDRB</front>
<front id="fastioH-3433">#define DIO12_PWM		NULL</front>
<front id="fastioH-3434"></front>
<front id="fastioH-3435">#define	DIO13_PIN		PINE2</front>
<front id="fastioH-3436">#define	DIO13_RPORT	PINE</front>
<front id="fastioH-3437">#define	DIO13_WPORT	PORTE</front>
<front id="fastioH-3438">#define	DIO13_DDR		DDRE</front>
<front id="fastioH-3439">#define DIO13_PWM		NULL</front>
<front id="fastioH-3440"></front>
<front id="fastioH-3441">#define	DIO14_PIN		PINE6</front>
<front id="fastioH-3442">#define	DIO14_RPORT	PINE</front>
<front id="fastioH-3443">#define	DIO14_WPORT	PORTE</front>
<front id="fastioH-3444">#define	DIO14_DDR		DDRE</front>
<front id="fastioH-3445">#define DIO14_PWM		NULL</front>
<front id="fastioH-3446"></front>
<front id="fastioH-3447">#define	DIO15_PIN		PINE7</front>
<front id="fastioH-3448">#define	DIO15_RPORT	PINE</front>
<front id="fastioH-3449">#define	DIO15_WPORT	PORTE</front>
<front id="fastioH-3450">#define	DIO15_DDR		DDRE</front>
<front id="fastioH-3451">#define DIO15_PWM		NULL</front>
<front id="fastioH-3452"></front>
<front id="fastioH-3453">#define	DIO16_PIN		PINB0</front>
<front id="fastioH-3454">#define	DIO16_RPORT	PINB</front>
<front id="fastioH-3455">#define	DIO16_WPORT	PORTB</front>
<front id="fastioH-3456">#define	DIO16_DDR		DDRB</front>
<front id="fastioH-3457">#define DIO16_PWM		NULL</front>
<front id="fastioH-3458"></front>
<front id="fastioH-3459">#define	DIO17_PIN		PIND0</front>
<front id="fastioH-3460">#define	DIO17_RPORT	PIND</front>
<front id="fastioH-3461">#define	DIO17_WPORT	PORTD</front>
<front id="fastioH-3462">#define	DIO17_DDR		DDRD</front>
<front id="fastioH-3463">#define DIO17_PWM		NULL</front>
<front id="fastioH-3464"></front>
<front id="fastioH-3465">#define	DIO18_PIN		PIND1</front>
<front id="fastioH-3466">#define	DIO18_RPORT	PIND</front>
<front id="fastioH-3467">#define	DIO18_WPORT	PORTD</front>
<front id="fastioH-3468">#define	DIO18_DDR		DDRD</front>
<front id="fastioH-3469">#define DIO18_PWM		NULL</front>
<front id="fastioH-3470"></front>
<front id="fastioH-3471">#define	DIO19_PIN		PIND2</front>
<front id="fastioH-3472">#define	DIO19_RPORT	PIND</front>
<front id="fastioH-3473">#define	DIO19_WPORT	PORTD</front>
<front id="fastioH-3474">#define	DIO19_DDR		DDRD</front>
<front id="fastioH-3475">#define DIO19_PWM		NULL</front>
<front id="fastioH-3476"></front>
<front id="fastioH-3477">#define	DIO20_PIN		PIND3</front>
<front id="fastioH-3478">#define	DIO20_RPORT	PIND</front>
<front id="fastioH-3479">#define	DIO20_WPORT	PORTD</front>
<front id="fastioH-3480">#define	DIO20_DDR		DDRD</front>
<front id="fastioH-3481">#define DIO20_PWM		NULL</front>
<front id="fastioH-3482"></front>
<front id="fastioH-3483">#define	DIO21_PIN		PIND4</front>
<front id="fastioH-3484">#define	DIO21_RPORT	PIND</front>
<front id="fastioH-3485">#define	DIO21_WPORT	PORTD</front>
<front id="fastioH-3486">#define	DIO21_DDR		DDRD</front>
<front id="fastioH-3487">#define DIO21_PWM		NULL</front>
<front id="fastioH-3488"></front>
<front id="fastioH-3489">#define	DIO22_PIN		PIND5</front>
<front id="fastioH-3490">#define	DIO22_RPORT	PIND</front>
<front id="fastioH-3491">#define	DIO22_WPORT	PORTD</front>
<front id="fastioH-3492">#define	DIO22_DDR		DDRD</front>
<front id="fastioH-3493">#define DIO22_PWM		NULL</front>
<front id="fastioH-3494"></front>
<front id="fastioH-3495">#define	DIO23_PIN		PIND6</front>
<front id="fastioH-3496">#define	DIO23_RPORT	PIND</front>
<front id="fastioH-3497">#define	DIO23_WPORT	PORTD</front>
<front id="fastioH-3498">#define	DIO23_DDR		DDRD</front>
<front id="fastioH-3499">#define DIO23_PWM		NULL</front>
<front id="fastioH-3500"></front>
<front id="fastioH-3501">#define	DIO24_PIN		PIND7</front>
<front id="fastioH-3502">#define	DIO24_RPORT	PIND</front>
<front id="fastioH-3503">#define	DIO24_WPORT	PORTD</front>
<front id="fastioH-3504">#define	DIO24_DDR		DDRD</front>
<front id="fastioH-3505">#define DIO24_PWM		NULL</front>
<front id="fastioH-3506"></front>
<front id="fastioH-3507">#define	DIO25_PIN		PING0</front>
<front id="fastioH-3508">#define	DIO25_RPORT	PING</front>
<front id="fastioH-3509">#define	DIO25_WPORT	PORTG</front>
<front id="fastioH-3510">#define	DIO25_DDR		DDRG</front>
<front id="fastioH-3511">#define DIO25_PWM		NULL</front>
<front id="fastioH-3512"></front>
<front id="fastioH-3513">#define	DIO26_PIN		PING1</front>
<front id="fastioH-3514">#define	DIO26_RPORT	PING</front>
<front id="fastioH-3515">#define	DIO26_WPORT	PORTG</front>
<front id="fastioH-3516">#define	DIO26_DDR		DDRG</front>
<front id="fastioH-3517">#define DIO26_PWM		NULL</front>
<front id="fastioH-3518"></front>
<front id="fastioH-3519">#define	DIO27_PIN		PING2</front>
<front id="fastioH-3520">#define	DIO27_RPORT	PING</front>
<front id="fastioH-3521">#define	DIO27_WPORT	PORTG</front>
<front id="fastioH-3522">#define	DIO27_DDR		DDRG</front>
<front id="fastioH-3523">#define DIO27_PWM		NULL</front>
<front id="fastioH-3524"></front>
<front id="fastioH-3525">#define	DIO28_PIN		PING3</front>
<front id="fastioH-3526">#define	DIO28_RPORT	PING</front>
<front id="fastioH-3527">#define	DIO28_WPORT	PORTG</front>
<front id="fastioH-3528">#define	DIO28_DDR		DDRG</front>
<front id="fastioH-3529">#define DIO28_PWM		NULL</front>
<front id="fastioH-3530"></front>
<front id="fastioH-3531">#define	DIO29_PIN		PING4</front>
<front id="fastioH-3532">#define	DIO29_RPORT	PING</front>
<front id="fastioH-3533">#define	DIO29_WPORT	PORTG</front>
<front id="fastioH-3534">#define	DIO29_DDR		DDRG</front>
<front id="fastioH-3535">#define DIO29_PWM		NULL</front>
<front id="fastioH-3536"></front>
<front id="fastioH-3537">#define	DIO30_PIN		PINC0</front>
<front id="fastioH-3538">#define	DIO30_RPORT	PINC</front>
<front id="fastioH-3539">#define	DIO30_WPORT	PORTC</front>
<front id="fastioH-3540">#define	DIO30_DDR		DDRC</front>
<front id="fastioH-3541">#define DIO30_PWM		NULL</front>
<front id="fastioH-3542"></front>
<front id="fastioH-3543">#define	DIO31_PIN		PINC1</front>
<front id="fastioH-3544">#define	DIO31_RPORT	PINC</front>
<front id="fastioH-3545">#define	DIO31_WPORT	PORTC</front>
<front id="fastioH-3546">#define	DIO31_DDR		DDRC</front>
<front id="fastioH-3547">#define DIO31_PWM		NULL</front>
<front id="fastioH-3548"></front>
<front id="fastioH-3549">#define	DIO32_PIN		PINC2</front>
<front id="fastioH-3550">#define	DIO32_RPORT	PINC</front>
<front id="fastioH-3551">#define	DIO32_WPORT	PORTC</front>
<front id="fastioH-3552">#define	DIO32_DDR		DDRC</front>
<front id="fastioH-3553">#define DIO32_PWM		NULL</front>
<front id="fastioH-3554"></front>
<front id="fastioH-3555">#define	DIO33_PIN		PINC3</front>
<front id="fastioH-3556">#define	DIO33_RPORT	PINC</front>
<front id="fastioH-3557">#define	DIO33_WPORT	PORTC</front>
<front id="fastioH-3558">#define	DIO33_DDR		DDRC</front>
<front id="fastioH-3559">#define DIO33_PWM		NULL</front>
<front id="fastioH-3560"></front>
<front id="fastioH-3561">#define	DIO34_PIN		PINC4</front>
<front id="fastioH-3562">#define	DIO34_RPORT	PINC</front>
<front id="fastioH-3563">#define	DIO34_WPORT	PORTC</front>
<front id="fastioH-3564">#define	DIO34_DDR		DDRC</front>
<front id="fastioH-3565">#define DIO34_PWM		NULL</front>
<front id="fastioH-3566"></front>
<front id="fastioH-3567">#define	DIO35_PIN		PINC5</front>
<front id="fastioH-3568">#define	DIO35_RPORT	PINC</front>
<front id="fastioH-3569">#define	DIO35_WPORT	PORTC</front>
<front id="fastioH-3570">#define	DIO35_DDR		DDRC</front>
<front id="fastioH-3571">#define DIO35_PWM		NULL</front>
<front id="fastioH-3572"></front>
<front id="fastioH-3573">#define	DIO36_PIN		PINC6</front>
<front id="fastioH-3574">#define	DIO36_RPORT	PINC</front>
<front id="fastioH-3575">#define	DIO36_WPORT	PORTC</front>
<front id="fastioH-3576">#define	DIO36_DDR		DDRC</front>
<front id="fastioH-3577">#define DIO36_PWM		NULL</front>
<front id="fastioH-3578"></front>
<front id="fastioH-3579">#define	DIO37_PIN		PINC7</front>
<front id="fastioH-3580">#define	DIO37_RPORT	PINC</front>
<front id="fastioH-3581">#define	DIO37_WPORT	PORTC</front>
<front id="fastioH-3582">#define	DIO37_DDR		DDRC</front>
<front id="fastioH-3583">#define DIO37_PWM		NULL</front>
<front id="fastioH-3584"></front>
<front id="fastioH-3585">#define	DIO38_PIN		PINA0</front>
<front id="fastioH-3586">#define	DIO38_RPORT	PINA</front>
<front id="fastioH-3587">#define	DIO38_WPORT	PORTA</front>
<front id="fastioH-3588">#define	DIO38_DDR		DDRA</front>
<front id="fastioH-3589">#define DIO38_PWM		NULL</front>
<front id="fastioH-3590"></front>
<front id="fastioH-3591">#define	DIO39_PIN		PINA1</front>
<front id="fastioH-3592">#define	DIO39_RPORT	PINA</front>
<front id="fastioH-3593">#define	DIO39_WPORT	PORTA</front>
<front id="fastioH-3594">#define	DIO39_DDR		DDRA</front>
<front id="fastioH-3595">#define DIO39_PWM		NULL</front>
<front id="fastioH-3596"></front>
<front id="fastioH-3597">#define	DIO40_PIN		PINA2</front>
<front id="fastioH-3598">#define	DIO40_RPORT	PINA</front>
<front id="fastioH-3599">#define	DIO40_WPORT	PORTA</front>
<front id="fastioH-3600">#define	DIO40_DDR		DDRA</front>
<front id="fastioH-3601">#define DIO40_PWM		NULL</front>
<front id="fastioH-3602"></front>
<front id="fastioH-3603">#define	DIO41_PIN		PINA3</front>
<front id="fastioH-3604">#define	DIO41_RPORT	PINA</front>
<front id="fastioH-3605">#define	DIO41_WPORT	PORTA</front>
<front id="fastioH-3606">#define	DIO41_DDR		DDRA</front>
<front id="fastioH-3607">#define DIO41_PWM		NULL</front>
<front id="fastioH-3608"></front>
<front id="fastioH-3609">#define	DIO42_PIN		PINA4</front>
<front id="fastioH-3610">#define	DIO42_RPORT	PINA</front>
<front id="fastioH-3611">#define	DIO42_WPORT	PORTA</front>
<front id="fastioH-3612">#define	DIO42_DDR		DDRA</front>
<front id="fastioH-3613">#define DIO42_PWM		NULL</front>
<front id="fastioH-3614"></front>
<front id="fastioH-3615">#define	DIO43_PIN		PINA5</front>
<front id="fastioH-3616">#define	DIO43_RPORT	PINA</front>
<front id="fastioH-3617">#define	DIO43_WPORT	PORTA</front>
<front id="fastioH-3618">#define	DIO43_DDR		DDRA</front>
<front id="fastioH-3619">#define DIO43_PWM		NULL</front>
<front id="fastioH-3620"></front>
<front id="fastioH-3621">#define	DIO44_PIN		PINA6</front>
<front id="fastioH-3622">#define	DIO44_RPORT	PINA</front>
<front id="fastioH-3623">#define	DIO44_WPORT	PORTA</front>
<front id="fastioH-3624">#define	DIO44_DDR		DDRA</front>
<front id="fastioH-3625">#define DIO44_PWM		NULL</front>
<front id="fastioH-3626"></front>
<front id="fastioH-3627">#define	DIO45_PIN		PINA7</front>
<front id="fastioH-3628">#define	DIO45_RPORT	PINA</front>
<front id="fastioH-3629">#define	DIO45_WPORT	PORTA</front>
<front id="fastioH-3630">#define	DIO45_DDR		DDRA</front>
<front id="fastioH-3631">#define DIO45_PWM		NULL</front>
<front id="fastioH-3632"></front>
<front id="fastioH-3633">#define	DIO46_PIN		PINF0</front>
<front id="fastioH-3634">#define	DIO46_RPORT	PINF</front>
<front id="fastioH-3635">#define	DIO46_WPORT	PORTF</front>
<front id="fastioH-3636">#define	DIO46_DDR		DDRF</front>
<front id="fastioH-3637">#define DIO46_PWM		NULL</front>
<front id="fastioH-3638"></front>
<front id="fastioH-3639">#define	DIO47_PIN		PINF1</front>
<front id="fastioH-3640">#define	DIO47_RPORT	PINF</front>
<front id="fastioH-3641">#define	DIO47_WPORT	PORTF</front>
<front id="fastioH-3642">#define	DIO47_DDR		DDRF</front>
<front id="fastioH-3643">#define DIO47_PWM		NULL</front>
<front id="fastioH-3644"></front>
<front id="fastioH-3645">#define	DIO48_PIN		PINF2</front>
<front id="fastioH-3646">#define	DIO48_RPORT	PINF</front>
<front id="fastioH-3647">#define	DIO48_WPORT	PORTF</front>
<front id="fastioH-3648">#define	DIO48_DDR		DDRF</front>
<front id="fastioH-3649">#define DIO48_PWM		NULL</front>
<front id="fastioH-3650"></front>
<front id="fastioH-3651">#define	DIO49_PIN		PINF3</front>
<front id="fastioH-3652">#define	DIO49_RPORT	PINF</front>
<front id="fastioH-3653">#define	DIO49_WPORT	PORTF</front>
<front id="fastioH-3654">#define	DIO49_DDR		DDRF</front>
<front id="fastioH-3655">#define DIO49_PWM		NULL</front>
<front id="fastioH-3656"></front>
<front id="fastioH-3657">#define	DIO50_PIN		PINF4</front>
<front id="fastioH-3658">#define	DIO50_RPORT	PINF</front>
<front id="fastioH-3659">#define	DIO50_WPORT	PORTF</front>
<front id="fastioH-3660">#define	DIO50_DDR		DDRF</front>
<front id="fastioH-3661">#define DIO50_PWM		NULL</front>
<front id="fastioH-3662"></front>
<front id="fastioH-3663">#define	DIO51_PIN		PINF5</front>
<front id="fastioH-3664">#define	DIO51_RPORT	PINF</front>
<front id="fastioH-3665">#define	DIO51_WPORT	PORTF</front>
<front id="fastioH-3666">#define	DIO51_DDR		DDRF</front>
<front id="fastioH-3667">#define DIO51_PWM		NULL</front>
<front id="fastioH-3668"></front>
<front id="fastioH-3669">#define	DIO52_PIN		PINF6</front>
<front id="fastioH-3670">#define	DIO52_RPORT	PINF</front>
<front id="fastioH-3671">#define	DIO52_WPORT	PORTF</front>
<front id="fastioH-3672">#define	DIO52_DDR		DDRF</front>
<front id="fastioH-3673">#define DIO52_PWM		NULL</front>
<front id="fastioH-3674"></front>
<front id="fastioH-3675">#define	DIO53_PIN		PINF7</front>
<front id="fastioH-3676">#define	DIO53_RPORT	PINF</front>
<front id="fastioH-3677">#define	DIO53_WPORT	PORTF</front>
<front id="fastioH-3678">#define	DIO53_DDR		DDRF</front>
<front id="fastioH-3679">#define DIO53_PWM		NULL</front>
<front id="fastioH-3680"></front>
<front id="fastioH-3681"></front>
<front id="fastioH-3682"></front>
<front id="fastioH-3683"></front>
<front id="fastioH-3684">#undef PA0</front>
<front id="fastioH-3685">#define PA0_PIN			PINA0</front>
<front id="fastioH-3686">#define PA0_RPORT		PINA</front>
<front id="fastioH-3687">#define PA0_WPORT		PORTA</front>
<front id="fastioH-3688">#define PA0_DDR			DDRA</front>
<front id="fastioH-3689">#define PA0_PWM			NULL</front>
<front id="fastioH-3690">#undef PA1</front>
<front id="fastioH-3691">#define PA1_PIN			PINA1</front>
<front id="fastioH-3692">#define PA1_RPORT		PINA</front>
<front id="fastioH-3693">#define PA1_WPORT		PORTA</front>
<front id="fastioH-3694">#define PA1_DDR			DDRA</front>
<front id="fastioH-3695">#define PA1_PWM			NULL</front>
<front id="fastioH-3696">#undef PA2</front>
<front id="fastioH-3697">#define PA2_PIN			PINA2</front>
<front id="fastioH-3698">#define PA2_RPORT		PINA</front>
<front id="fastioH-3699">#define PA2_WPORT		PORTA</front>
<front id="fastioH-3700">#define PA2_DDR			DDRA</front>
<front id="fastioH-3701">#define PA2_PWM			NULL</front>
<front id="fastioH-3702">#undef PA3</front>
<front id="fastioH-3703">#define PA3_PIN			PINA3</front>
<front id="fastioH-3704">#define PA3_RPORT		PINA</front>
<front id="fastioH-3705">#define PA3_WPORT		PORTA</front>
<front id="fastioH-3706">#define PA3_DDR			DDRA</front>
<front id="fastioH-3707">#define PA3_PWM			NULL</front>
<front id="fastioH-3708">#undef PA4</front>
<front id="fastioH-3709">#define PA4_PIN			PINA4</front>
<front id="fastioH-3710">#define PA4_RPORT		PINA</front>
<front id="fastioH-3711">#define PA4_WPORT		PORTA</front>
<front id="fastioH-3712">#define PA4_DDR			DDRA</front>
<front id="fastioH-3713">#define PA4_PWM			NULL</front>
<front id="fastioH-3714">#undef PA5</front>
<front id="fastioH-3715">#define PA5_PIN			PINA5</front>
<front id="fastioH-3716">#define PA5_RPORT		PINA</front>
<front id="fastioH-3717">#define PA5_WPORT		PORTA</front>
<front id="fastioH-3718">#define PA5_DDR			DDRA</front>
<front id="fastioH-3719">#define PA5_PWM			NULL</front>
<front id="fastioH-3720">#undef PA6</front>
<front id="fastioH-3721">#define PA6_PIN			PINA6</front>
<front id="fastioH-3722">#define PA6_RPORT		PINA</front>
<front id="fastioH-3723">#define PA6_WPORT		PORTA</front>
<front id="fastioH-3724">#define PA6_DDR			DDRA</front>
<front id="fastioH-3725">#define PA6_PWM			NULL</front>
<front id="fastioH-3726">#undef PA7</front>
<front id="fastioH-3727">#define PA7_PIN			PINA7</front>
<front id="fastioH-3728">#define PA7_RPORT		PINA</front>
<front id="fastioH-3729">#define PA7_WPORT		PORTA</front>
<front id="fastioH-3730">#define PA7_DDR			DDRA</front>
<front id="fastioH-3731">#define PA7_PWM			NULL</front>
<front id="fastioH-3732"></front>
<front id="fastioH-3733">#undef PB0</front>
<front id="fastioH-3734">#define PB0_PIN			PINB0</front>
<front id="fastioH-3735">#define PB0_RPORT		PINB</front>
<front id="fastioH-3736">#define PB0_WPORT		PORTB</front>
<front id="fastioH-3737">#define PB0_DDR			DDRB</front>
<front id="fastioH-3738">#define PB0_PWM			NULL</front>
<front id="fastioH-3739">#undef PB1</front>
<front id="fastioH-3740">#define PB1_PIN			PINB1</front>
<front id="fastioH-3741">#define PB1_RPORT		PINB</front>
<front id="fastioH-3742">#define PB1_WPORT		PORTB</front>
<front id="fastioH-3743">#define PB1_DDR			DDRB</front>
<front id="fastioH-3744">#define PB1_PWM			NULL</front>
<front id="fastioH-3745">#undef PB2</front>
<front id="fastioH-3746">#define PB2_PIN			PINB2</front>
<front id="fastioH-3747">#define PB2_RPORT		PINB</front>
<front id="fastioH-3748">#define PB2_WPORT		PORTB</front>
<front id="fastioH-3749">#define PB2_DDR			DDRB</front>
<front id="fastioH-3750">#define PB2_PWM			NULL</front>
<front id="fastioH-3751">#undef PB3</front>
<front id="fastioH-3752">#define PB3_PIN			PINB3</front>
<front id="fastioH-3753">#define PB3_RPORT		PINB</front>
<front id="fastioH-3754">#define PB3_WPORT		PORTB</front>
<front id="fastioH-3755">#define PB3_DDR			DDRB</front>
<front id="fastioH-3756">#define PB3_PWM			NULL</front>
<front id="fastioH-3757">#undef PB4</front>
<front id="fastioH-3758">#define PB4_PIN			PINB4</front>
<front id="fastioH-3759">#define PB4_RPORT		PINB</front>
<front id="fastioH-3760">#define PB4_WPORT		PORTB</front>
<front id="fastioH-3761">#define PB4_DDR			DDRB</front>
<front id="fastioH-3762">#define PB4_PWM			&OCR2A</front>
<front id="fastioH-3763">#undef PB5</front>
<front id="fastioH-3764">#define PB5_PIN			PINB5</front>
<front id="fastioH-3765">#define PB5_RPORT		PINB</front>
<front id="fastioH-3766">#define PB5_WPORT		PORTB</front>
<front id="fastioH-3767">#define PB5_DDR			DDRB</front>
<front id="fastioH-3768">#define PB5_PWM			NULL</front>
<front id="fastioH-3769">#undef PB6</front>
<front id="fastioH-3770">#define PB6_PIN			PINB6</front>
<front id="fastioH-3771">#define PB6_RPORT		PINB</front>
<front id="fastioH-3772">#define PB6_WPORT		PORTB</front>
<front id="fastioH-3773">#define PB6_DDR			DDRB</front>
<front id="fastioH-3774">#define PB6_PWM			NULL</front>
<front id="fastioH-3775">#undef PB7</front>
<front id="fastioH-3776">#define PB7_PIN			PINB7</front>
<front id="fastioH-3777">#define PB7_RPORT		PINB</front>
<front id="fastioH-3778">#define PB7_WPORT		PORTB</front>
<front id="fastioH-3779">#define PB7_DDR			DDRB</front>
<front id="fastioH-3780">#define PB7_PWM			&OCR0A</front>
<front id="fastioH-3781"></front>
<front id="fastioH-3782">#undef PC0</front>
<front id="fastioH-3783">#define PC0_PIN			PINC0</front>
<front id="fastioH-3784">#define PC0_RPORT		PINC</front>
<front id="fastioH-3785">#define PC0_WPORT		PORTC</front>
<front id="fastioH-3786">#define PC0_DDR			DDRC</front>
<front id="fastioH-3787">#define PC0_PWM			NULL</front>
<front id="fastioH-3788">#undef PC1</front>
<front id="fastioH-3789">#define PC1_PIN			PINC1</front>
<front id="fastioH-3790">#define PC1_RPORT		PINC</front>
<front id="fastioH-3791">#define PC1_WPORT		PORTC</front>
<front id="fastioH-3792">#define PC1_DDR			DDRC</front>
<front id="fastioH-3793">#define PC1_PWM			NULL</front>
<front id="fastioH-3794">#undef PC2</front>
<front id="fastioH-3795">#define PC2_PIN			PINC2</front>
<front id="fastioH-3796">#define PC2_RPORT		PINC</front>
<front id="fastioH-3797">#define PC2_WPORT		PORTC</front>
<front id="fastioH-3798">#define PC2_DDR			DDRC</front>
<front id="fastioH-3799">#define PC2_PWM			NULL</front>
<front id="fastioH-3800">#undef PC3</front>
<front id="fastioH-3801">#define PC3_PIN			PINC3</front>
<front id="fastioH-3802">#define PC3_RPORT		PINC</front>
<front id="fastioH-3803">#define PC3_WPORT		PORTC</front>
<front id="fastioH-3804">#define PC3_DDR			DDRC</front>
<front id="fastioH-3805">#define PC3_PWM			NULL</front>
<front id="fastioH-3806">#undef PC4</front>
<front id="fastioH-3807">#define PC4_PIN			PINC4</front>
<front id="fastioH-3808">#define PC4_RPORT		PINC</front>
<front id="fastioH-3809">#define PC4_WPORT		PORTC</front>
<front id="fastioH-3810">#define PC4_DDR			DDRC</front>
<front id="fastioH-3811">#define PC4_PWM			NULL</front>
<front id="fastioH-3812">#undef PC5</front>
<front id="fastioH-3813">#define PC5_PIN			PINC5</front>
<front id="fastioH-3814">#define PC5_RPORT		PINC</front>
<front id="fastioH-3815">#define PC5_WPORT		PORTC</front>
<front id="fastioH-3816">#define PC5_DDR			DDRC</front>
<front id="fastioH-3817">#define PC5_PWM			NULL</front>
<front id="fastioH-3818">#undef PC6</front>
<front id="fastioH-3819">#define PC6_PIN			PINC6</front>
<front id="fastioH-3820">#define PC6_RPORT		PINC</front>
<front id="fastioH-3821">#define PC6_WPORT		PORTC</front>
<front id="fastioH-3822">#define PC6_DDR			DDRC</front>
<front id="fastioH-3823">#define PC6_PWM			NULL</front>
<front id="fastioH-3824">#undef PC7</front>
<front id="fastioH-3825">#define PC7_PIN			PINC7</front>
<front id="fastioH-3826">#define PC7_RPORT		PINC</front>
<front id="fastioH-3827">#define PC7_WPORT		PORTC</front>
<front id="fastioH-3828">#define PC7_DDR			DDRC</front>
<front id="fastioH-3829">#define PC7_PWM			NULL</front>
<front id="fastioH-3830"></front>
<front id="fastioH-3831">#undef PD0</front>
<front id="fastioH-3832">#define PD0_PIN			PIND0</front>
<front id="fastioH-3833">#define PD0_RPORT		PIND</front>
<front id="fastioH-3834">#define PD0_WPORT		PORTD</front>
<front id="fastioH-3835">#define PD0_DDR			DDRD</front>
<front id="fastioH-3836">#define PD0_PWM			NULL</front>
<front id="fastioH-3837">#undef PD1</front>
<front id="fastioH-3838">#define PD1_PIN			PIND1</front>
<front id="fastioH-3839">#define PD1_RPORT		PIND</front>
<front id="fastioH-3840">#define PD1_WPORT		PORTD</front>
<front id="fastioH-3841">#define PD1_DDR			DDRD</front>
<front id="fastioH-3842">#define PD1_PWM			NULL</front>
<front id="fastioH-3843">#undef PD2</front>
<front id="fastioH-3844">#define PD2_PIN			PIND2</front>
<front id="fastioH-3845">#define PD2_RPORT		PIND</front>
<front id="fastioH-3846">#define PD2_WPORT		PORTD</front>
<front id="fastioH-3847">#define PD2_DDR			DDRD</front>
<front id="fastioH-3848">#define PD2_PWM			NULL</front>
<front id="fastioH-3849">#undef PD3</front>
<front id="fastioH-3850">#define PD3_PIN			PIND3</front>
<front id="fastioH-3851">#define PD3_RPORT		PIND</front>
<front id="fastioH-3852">#define PD3_WPORT		PORTD</front>
<front id="fastioH-3853">#define PD3_DDR			DDRD</front>
<front id="fastioH-3854">#define PD3_PWM			NULL</front>
<front id="fastioH-3855">#undef PD4</front>
<front id="fastioH-3856">#define PD4_PIN			PIND4</front>
<front id="fastioH-3857">#define PD4_RPORT		PIND</front>
<front id="fastioH-3858">#define PD4_WPORT		PORTD</front>
<front id="fastioH-3859">#define PD4_DDR			DDRD</front>
<front id="fastioH-3860">#define PD4_PWM			NULL</front>
<front id="fastioH-3861">#undef PD5</front>
<front id="fastioH-3862">#define PD5_PIN			PIND5</front>
<front id="fastioH-3863">#define PD5_RPORT		PIND</front>
<front id="fastioH-3864">#define PD5_WPORT		PORTD</front>
<front id="fastioH-3865">#define PD5_DDR			DDRD</front>
<front id="fastioH-3866">#define PD5_PWM			NULL</front>
<front id="fastioH-3867">#undef PD6</front>
<front id="fastioH-3868">#define PD6_PIN			PIND6</front>
<front id="fastioH-3869">#define PD6_RPORT		PIND</front>
<front id="fastioH-3870">#define PD6_WPORT		PORTD</front>
<front id="fastioH-3871">#define PD6_DDR			DDRD</front>
<front id="fastioH-3872">#define PD6_PWM			NULL</front>
<front id="fastioH-3873">#undef PD7</front>
<front id="fastioH-3874">#define PD7_PIN			PIND7</front>
<front id="fastioH-3875">#define PD7_RPORT		PIND</front>
<front id="fastioH-3876">#define PD7_WPORT		PORTD</front>
<front id="fastioH-3877">#define PD7_DDR			DDRD</front>
<front id="fastioH-3878">#define PD7_PWM			NULL</front>
<front id="fastioH-3879"></front>
<front id="fastioH-3880">#undef PE0</front>
<front id="fastioH-3881">#define PE0_PIN			PINE0</front>
<front id="fastioH-3882">#define PE0_RPORT		PINE</front>
<front id="fastioH-3883">#define PE0_WPORT		PORTE</front>
<front id="fastioH-3884">#define PE0_DDR			DDRE</front>
<front id="fastioH-3885">#define PE0_PWM			NULL</front>
<front id="fastioH-3886">#undef PE1</front>
<front id="fastioH-3887">#define PE1_PIN			PINE1</front>
<front id="fastioH-3888">#define PE1_RPORT		PINE</front>
<front id="fastioH-3889">#define PE1_WPORT		PORTE</front>
<front id="fastioH-3890">#define PE1_DDR			DDRE</front>
<front id="fastioH-3891">#define PE1_PWM			NULL</front>
<front id="fastioH-3892">#undef PE2</front>
<front id="fastioH-3893">#define PE2_PIN			PINE2</front>
<front id="fastioH-3894">#define PE2_RPORT		PINE</front>
<front id="fastioH-3895">#define PE2_WPORT		PORTE</front>
<front id="fastioH-3896">#define PE2_DDR			DDRE</front>
<front id="fastioH-3897">#define PE2_PWM			NULL</front>
<front id="fastioH-3898">#undef PE3</front>
<front id="fastioH-3899">#define PE3_PIN			PINE3</front>
<front id="fastioH-3900">#define PE3_RPORT		PINE</front>
<front id="fastioH-3901">#define PE3_WPORT		PORTE</front>
<front id="fastioH-3902">#define PE3_DDR			DDRE</front>
<front id="fastioH-3903">#define PE3_PWM			&OCR3AL</front>
<front id="fastioH-3904">#undef PE4</front>
<front id="fastioH-3905">#define PE4_PIN			PINE4</front>
<front id="fastioH-3906">#define PE4_RPORT		PINE</front>
<front id="fastioH-3907">#define PE4_WPORT		PORTE</front>
<front id="fastioH-3908">#define PE4_DDR			DDRE</front>
<front id="fastioH-3909">#define PE4_PWM			&OCR3BL</front>
<front id="fastioH-3910">#undef PE5</front>
<front id="fastioH-3911">#define PE5_PIN			PINE5</front>
<front id="fastioH-3912">#define PE5_RPORT		PINE</front>
<front id="fastioH-3913">#define PE5_WPORT		PORTE</front>
<front id="fastioH-3914">#define PE5_DDR			DDRE</front>
<front id="fastioH-3915">#define PE5_PWM			&OCR3CL</front>
<front id="fastioH-3916">#undef PE6</front>
<front id="fastioH-3917">#define PE6_PIN			PINE6</front>
<front id="fastioH-3918">#define PE6_RPORT		PINE</front>
<front id="fastioH-3919">#define PE6_WPORT		PORTE</front>
<front id="fastioH-3920">#define PE6_DDR			DDRE</front>
<front id="fastioH-3921">#define PE6_PWM			NULL</front>
<front id="fastioH-3922">#undef PE7</front>
<front id="fastioH-3923">#define PE7_PIN			PINE7</front>
<front id="fastioH-3924">#define PE7_RPORT		PINE</front>
<front id="fastioH-3925">#define PE7_WPORT		PORTE</front>
<front id="fastioH-3926">#define PE7_DDR			DDRE</front>
<front id="fastioH-3927">#define PE7_PWM			NULL</front>
<front id="fastioH-3928"></front>
<front id="fastioH-3929">#undef PF0</front>
<front id="fastioH-3930">#define PF0_PIN			PINF0</front>
<front id="fastioH-3931">#define PF0_RPORT		PINF</front>
<front id="fastioH-3932">#define PF0_WPORT		PORTF</front>
<front id="fastioH-3933">#define PF0_DDR			DDRF</front>
<front id="fastioH-3934">#define PF0_PWM			NULL</front>
<front id="fastioH-3935">#undef PF1</front>
<front id="fastioH-3936">#define PF1_PIN			PINF1</front>
<front id="fastioH-3937">#define PF1_RPORT		PINF</front>
<front id="fastioH-3938">#define PF1_WPORT		PORTF</front>
<front id="fastioH-3939">#define PF1_DDR			DDRF</front>
<front id="fastioH-3940">#define PF1_PWM			NULL</front>
<front id="fastioH-3941">#undef PF2</front>
<front id="fastioH-3942">#define PF2_PIN			PINF2</front>
<front id="fastioH-3943">#define PF2_RPORT		PINF</front>
<front id="fastioH-3944">#define PF2_WPORT		PORTF</front>
<front id="fastioH-3945">#define PF2_DDR			DDRF</front>
<front id="fastioH-3946">#define PF2_PWM			NULL</front>
<front id="fastioH-3947">#undef PF3</front>
<front id="fastioH-3948">#define PF3_PIN			PINF3</front>
<front id="fastioH-3949">#define PF3_RPORT		PINF</front>
<front id="fastioH-3950">#define PF3_WPORT		PORTF</front>
<front id="fastioH-3951">#define PF3_DDR			DDRF</front>
<front id="fastioH-3952">#define PF3_PWM			NULL</front>
<front id="fastioH-3953">#undef PF4</front>
<front id="fastioH-3954">#define PF4_PIN			PINF4</front>
<front id="fastioH-3955">#define PF4_RPORT		PINF</front>
<front id="fastioH-3956">#define PF4_WPORT		PORTF</front>
<front id="fastioH-3957">#define PF4_DDR			DDRF</front>
<front id="fastioH-3958">#define PF4_PWM			NULL</front>
<front id="fastioH-3959">#undef PF5</front>
<front id="fastioH-3960">#define PF5_PIN			PINF5</front>
<front id="fastioH-3961">#define PF5_RPORT		PINF</front>
<front id="fastioH-3962">#define PF5_WPORT		PORTF</front>
<front id="fastioH-3963">#define PF5_DDR			DDRF</front>
<front id="fastioH-3964">#define PF5_PWM			NULL</front>
<front id="fastioH-3965">#undef PF6</front>
<front id="fastioH-3966">#define PF6_PIN			PINF6</front>
<front id="fastioH-3967">#define PF6_RPORT		PINF</front>
<front id="fastioH-3968">#define PF6_WPORT		PORTF</front>
<front id="fastioH-3969">#define PF6_DDR			DDRF</front>
<front id="fastioH-3970">#define PF6_PWM			NULL</front>
<front id="fastioH-3971">#undef PF7</front>
<front id="fastioH-3972">#define PF7_PIN			PINF7</front>
<front id="fastioH-3973">#define PF7_RPORT		PINF</front>
<front id="fastioH-3974">#define PF7_WPORT		PORTF</front>
<front id="fastioH-3975">#define PF7_DDR			DDRF</front>
<front id="fastioH-3976">#define PF7_PWM			NULL</front>
<front id="fastioH-3977"></front>
<front id="fastioH-3978">#undef PG0</front>
<front id="fastioH-3979">#define PG0_PIN			PING0</front>
<front id="fastioH-3980">#define PG0_RPORT		PING</front>
<front id="fastioH-3981">#define PG0_WPORT		PORTG</front>
<front id="fastioH-3982">#define PG0_DDR			DDRG</front>
<front id="fastioH-3983">#define PG0_PWM			NULL</front>
<front id="fastioH-3984">#undef PG1</front>
<front id="fastioH-3985">#define PG1_PIN			PING1</front>
<front id="fastioH-3986">#define PG1_RPORT		PING</front>
<front id="fastioH-3987">#define PG1_WPORT		PORTG</front>
<front id="fastioH-3988">#define PG1_DDR			DDRG</front>
<front id="fastioH-3989">#define PG1_PWM			NULL</front>
<front id="fastioH-3990">#undef PG2</front>
<front id="fastioH-3991">#define PG2_PIN			PING2</front>
<front id="fastioH-3992">#define PG2_RPORT		PING</front>
<front id="fastioH-3993">#define PG2_WPORT		PORTG</front>
<front id="fastioH-3994">#define PG2_DDR			DDRG</front>
<front id="fastioH-3995">#define PG2_PWM			NULL</front>
<front id="fastioH-3996">#undef PG3</front>
<front id="fastioH-3997">#define PG3_PIN			PING3</front>
<front id="fastioH-3998">#define PG3_RPORT		PING</front>
<front id="fastioH-3999">#define PG3_WPORT		PORTG</front>
<front id="fastioH-4000">#define PG3_DDR			DDRG</front>
<front id="fastioH-4001">#define PG3_PWM			NULL</front>
<front id="fastioH-4002">#undef PG4</front>
<front id="fastioH-4003">#define PG4_PIN			PING4</front>
<front id="fastioH-4004">#define PG4_RPORT		PING</front>
<front id="fastioH-4005">#define PG4_WPORT		PORTG</front>
<front id="fastioH-4006">#define PG4_DDR			DDRG</front>
<front id="fastioH-4007">#define PG4_PWM			NULL</front>
<front id="fastioH-4008">#undef PG5</front>
<front id="fastioH-4009">#define PG5_PIN			PING5</front>
<front id="fastioH-4010">#define PG5_RPORT		PING</front>
<front id="fastioH-4011">#define PG5_WPORT		PORTG</front>
<front id="fastioH-4012">#define PG5_DDR			DDRG</front>
<front id="fastioH-4013">#define PG5_PWM			&OCR0B</front>
<front id="fastioH-4014"></front>
<front id="fastioH-4015"></front>
<front id="fastioH-4016">#endif</front>
<front id="fastioH-4017"></front>
<front id="fastioH-4018">#ifndef	DIO0_PIN</front>
<front id="fastioH-4019">#error pins for this chip not defined in arduino.h! If you write an appropriate pin definition and have this firmware work on your chip, please submit a pull request</front>
<front id="fastioH-4020">#endif</front>
<front id="fastioH-4021"></front>
<front id="fastioH-4022">#endif /* _FASTIO_ARDUINO_H */</front>
 </pre>
<h1 id="languageHtitle" >language.h</h1>
<pre id="languageH"  class="prettyprint linenums"><front id="languageH-1">#ifndef LANGUAGE_H</front>
<front id="languageH-2">#define LANGUAGE_H</front>
<front id="languageH-3"></front>
<front id="languageH-4">#include "Configuration.h"</front>
<front id="languageH-5"></front>
<front id="languageH-6">#define LANGUAGE_CONCAT(M)       #M</front>
<front id="languageH-7">#define GENERATE_LANGUAGE_INCLUDE(M)  LANGUAGE_CONCAT(language_##M.h)</front>
<front id="languageH-8"></front>
<front id="languageH-9"></front>
<front id="languageH-10">// NOTE: IF YOU CHANGE LANGUAGE FILES OR MERGE A FILE WITH CHANGES</front>
<front id="languageH-11">//</front>
<front id="languageH-12">//   ==&gt; ALWAYS TRY TO COMPILE MARLIN WITH/WITHOUT "ULTIPANEL" / "ULTRALCD" / "SDSUPPORT" #define IN "Configuration.h"</front>
<front id="languageH-13">//   ==&gt; ALSO TRY ALL AVAILABLE LANGUAGE OPTIONS</front>
<front id="languageH-14">// See also documentation/LCDLanguageFont.md</front>
<front id="languageH-15"></front>
<front id="languageH-16">// Languages</front>
<front id="languageH-17">// en       English</front>
<front id="languageH-18">// pl       Polish</front>
<front id="languageH-19">// fr       French</front>
<front id="languageH-20">// de       German</front>
<front id="languageH-21">// es       Spanish</front>
<front id="languageH-22">// ru       Russian</front>
<front id="languageH-23">// bg       Bulgarian</front>
<front id="languageH-24">// it       Italian</front>
<front id="languageH-25">// pt       Portuguese</front>
<front id="languageH-26">// pt-br    Portuguese (Brazil)</front>
<front id="languageH-27">// fi       Finnish</front>
<front id="languageH-28">// an       Aragonese</front>
<front id="languageH-29">// nl       Dutch</front>
<front id="languageH-30">// ca       Catalan</front>
<front id="languageH-31">// eu       Basque-Euskera</front>
<front id="languageH-32">// kana     Japanese</front>
<front id="languageH-33">// kana_utf Japanese</front>
<front id="languageH-34">// cn       Chinese</front>
<front id="languageH-35">// cz       Czech</front>
<front id="languageH-36"></front>
<front id="languageH-37">// fallback if no language is set, don't change</front>
<front id="languageH-38">#ifndef LANGUAGE_INCLUDE</front>
<front id="languageH-39">  #define LANGUAGE_INCLUDE GENERATE_LANGUAGE_INCLUDE(en)</front>
<front id="languageH-40">#endif</front>
<front id="languageH-41"></front>
<front id="languageH-42">#if ENABLED(USE_AUTOMATIC_VERSIONING)</front>
<front id="languageH-43">  #include "_Version.h"</front>
<front id="languageH-44">#else</front>
<front id="languageH-45">  #include "Default_Version.h"</front>
<front id="languageH-46">#endif</front>
<front id="languageH-47"></front>
<front id="languageH-48">#define PROTOCOL_VERSION "1.0"</front>
<front id="languageH-49"></front>
<front id="languageH-50">#if MB(ULTIMAKER)|| MB(ULTIMAKER_OLD)|| MB(ULTIMAIN_2)</front>
<front id="languageH-51">  #define MACHINE_NAME "Ultimaker"</front>
<front id="languageH-52">  #define SOURCE_CODE_URL "https://github.com/Ultimaker/Marlin"</front>
<front id="languageH-53">#elif MB(RUMBA)</front>
<front id="languageH-54">  #define MACHINE_NAME "Rumba"</front>
<front id="languageH-55">#elif MB(3DRAG)</front>
<front id="languageH-56">  #define MACHINE_NAME "3Drag"</front>
<front id="languageH-57">  #define SOURCE_CODE_URL "http://3dprint.elettronicain.it/"</front>
<front id="languageH-58">#elif MB(K8200)</front>
<front id="languageH-59">  #define MACHINE_NAME "K8200"</front>
<front id="languageH-60">  #define SOURCE_CODE_URL "https://github.com/CONSULitAS/Marlin-K8200"</front>
<front id="languageH-61">#elif MB(5DPRINT)</front>
<front id="languageH-62">  #define MACHINE_NAME "Makibox"</front>
<front id="languageH-63">#elif MB(SAV_MKI)</front>
<front id="languageH-64">  #define MACHINE_NAME "SAV MkI"</front>
<front id="languageH-65">  #define SOURCE_CODE_URL "https://github.com/fmalpartida/Marlin/tree/SAV-MkI-config"</front>
<front id="languageH-66">#elif !defined(MACHINE_NAME)</front>
<front id="languageH-67">  #define MACHINE_NAME "3D Printer"</front>
<front id="languageH-68">#endif</front>
<front id="languageH-69"></front>
<front id="languageH-70">#ifdef CUSTOM_MACHINE_NAME</front>
<front id="languageH-71">  #undef MACHINE_NAME</front>
<front id="languageH-72">  #define MACHINE_NAME CUSTOM_MACHINE_NAME</front>
<front id="languageH-73">#endif</front>
<front id="languageH-74"></front>
<front id="languageH-75">#ifndef SOURCE_CODE_URL</front>
<front id="languageH-76">  #define SOURCE_CODE_URL "https://github.com/MarlinFirmware/Marlin"</front>
<front id="languageH-77">#endif</front>
<front id="languageH-78"></front>
<front id="languageH-79">#ifndef DETAILED_BUILD_VERSION</front>
<front id="languageH-80">  #error BUILD_VERSION Information must be specified</front>
<front id="languageH-81">#endif</front>
<front id="languageH-82"></front>
<front id="languageH-83">#ifndef MACHINE_UUID</front>
<front id="languageH-84">   #define MACHINE_UUID "00000000-0000-0000-0000-000000000000"</front>
<front id="languageH-85">#endif</front>
<front id="languageH-86"></front>
<front id="languageH-87"></front>
<front id="languageH-88">#define STRINGIFY_(n) #n</front>
<front id="languageH-89">#define STRINGIFY(n) STRINGIFY_(n)</front>
<front id="languageH-90"></front>
<front id="languageH-91"></front>
<front id="languageH-92">// Common LCD messages</front>
<front id="languageH-93"></front>
<front id="languageH-94">  /* nothing here yet */</front>
<front id="languageH-95"></front>
<front id="languageH-96">// Common serial messages</front>
<front id="languageH-97">#define MSG_MARLIN "Marlin"</front>
<front id="languageH-98"></front>
<front id="languageH-99">// Serial Console Messages (do not translate those!)</front>
<front id="languageH-100"></front>
<front id="languageH-101">#define MSG_Enqueueing                      "enqueueing \""</front>
<front id="languageH-102">#define MSG_POWERUP                         "PowerUp"</front>
<front id="languageH-103">#define MSG_EXTERNAL_RESET                  " External Reset"</front>
<front id="languageH-104">#define MSG_BROWNOUT_RESET                  " Brown out Reset"</front>
<front id="languageH-105">#define MSG_WATCHDOG_RESET                  " Watchdog Reset"</front>
<front id="languageH-106">#define MSG_SOFTWARE_RESET                  " Software Reset"</front>
<front id="languageH-107">#define MSG_AUTHOR                          " | Author: "</front>
<front id="languageH-108">#define MSG_CONFIGURATION_VER               " Last Updated: "</front>
<front id="languageH-109">#define MSG_FREE_MEMORY                     " Free Memory: "</front>
<front id="languageH-110">#define MSG_PLANNER_BUFFER_BYTES            "  PlannerBufferBytes: "</front>
<front id="languageH-111">#define MSG_OK                              "ok"</front>
<front id="languageH-112">#define MSG_WAIT                            "wait"</front>
<front id="languageH-113">#define MSG_FILE_SAVED                      "Done saving file."</front>
<front id="languageH-114">#define MSG_ERR_LINE_NO                     "Line Number is not Last Line Number+1, Last Line: "</front>
<front id="languageH-115">#define MSG_ERR_CHECKSUM_MISMATCH           "checksum mismatch, Last Line: "</front>
<front id="languageH-116">#define MSG_ERR_NO_CHECKSUM                 "No Checksum with line number, Last Line: "</front>
<front id="languageH-117">#define MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM "No Line Number with checksum, Last Line: "</front>
<front id="languageH-118">#define MSG_FILE_PRINTED                    "Done printing file"</front>
<front id="languageH-119">#define MSG_BEGIN_FILE_LIST                 "Begin file list"</front>
<front id="languageH-120">#define MSG_END_FILE_LIST                   "End file list"</front>
<front id="languageH-121">#define MSG_INVALID_EXTRUDER                "Invalid extruder"</front>
<front id="languageH-122">#define MSG_INVALID_SOLENOID                "Invalid solenoid"</front>
<front id="languageH-123">#define MSG_ERR_NO_THERMISTORS              "No thermistors - no temperature"</front>
<front id="languageH-124">#define MSG_M115_REPORT                     "FIRMWARE_NAME:Marlin " DETAILED_BUILD_VERSION " SOURCE_CODE_URL:" SOURCE_CODE_URL " PROTOCOL_VERSION:" PROTOCOL_VERSION " MACHINE_TYPE:" MACHINE_NAME " EXTRUDER_COUNT:" STRINGIFY(EXTRUDERS) " UUID:" MACHINE_UUID "\n"</front>
<front id="languageH-125">#define MSG_COUNT_X                         " Count X: "</front>
<front id="languageH-126">#define MSG_ERR_KILLED                      "Printer halted. kill() called!"</front>
<front id="languageH-127">#define MSG_ERR_STOPPED                     "Printer stopped due to errors. Fix the error and use M999 to restart. (Temperature is reset. Set it after restarting)"</front>
<front id="languageH-128">#define MSG_RESEND                          "Resend: "</front>
<front id="languageH-129">#define MSG_UNKNOWN_COMMAND                 "Unknown command: \""</front>
<front id="languageH-130">#define MSG_ACTIVE_EXTRUDER                 "Active Extruder: "</front>
<front id="languageH-131">#define MSG_X_MIN                           "x_min: "</front>
<front id="languageH-132">#define MSG_X_MAX                           "x_max: "</front>
<front id="languageH-133">#define MSG_Y_MIN                           "y_min: "</front>
<front id="languageH-134">#define MSG_Y_MAX                           "y_max: "</front>
<front id="languageH-135">#define MSG_Z_MIN                           "z_min: "</front>
<front id="languageH-136">#define MSG_Z_MAX                           "z_max: "</front>
<front id="languageH-137">#define MSG_Z2_MAX                          "z2_max: "</front>
<front id="languageH-138">#define MSG_Z_PROBE                         "z_probe: "</front>
<front id="languageH-139">#define MSG_ERR_MATERIAL_INDEX              "M145 S&lt;index&gt; out of range (0-1)"</front>
<front id="languageH-140">#define MSG_ERR_M421_REQUIRES_XYZ           "M421 requires XYZ parameters"</front>
<front id="languageH-141">#define MSG_ERR_MESH_INDEX_OOB              "Mesh XY index is out of bounds"</front>
<front id="languageH-142">#define MSG_ERR_M428_TOO_FAR                "Too far from reference point"</front>
<front id="languageH-143">#define MSG_M119_REPORT                     "Reporting endstop status"</front>
<front id="languageH-144">#define MSG_ENDSTOP_HIT                     "TRIGGERED"</front>
<front id="languageH-145">#define MSG_ENDSTOP_OPEN                    "open"</front>
<front id="languageH-146">#define MSG_HOTEND_OFFSET                   "Hotend offsets:"</front>
<front id="languageH-147"></front>
<front id="languageH-148">#define MSG_SD_CANT_OPEN_SUBDIR             "Cannot open subdir"</front>
<front id="languageH-149">#define MSG_SD_INIT_FAIL                    "SD init fail"</front>
<front id="languageH-150">#define MSG_SD_VOL_INIT_FAIL                "volume.init failed"</front>
<front id="languageH-151">#define MSG_SD_OPENROOT_FAIL                "openRoot failed"</front>
<front id="languageH-152">#define MSG_SD_CARD_OK                      "SD card ok"</front>
<front id="languageH-153">#define MSG_SD_WORKDIR_FAIL                 "workDir open failed"</front>
<front id="languageH-154">#define MSG_SD_OPEN_FILE_FAIL               "open failed, File: "</front>
<front id="languageH-155">#define MSG_SD_FILE_OPENED                  "File opened: "</front>
<front id="languageH-156">#define MSG_SD_SIZE                         " Size: "</front>
<front id="languageH-157">#define MSG_SD_FILE_SELECTED                "File selected"</front>
<front id="languageH-158">#define MSG_SD_WRITE_TO_FILE                "Writing to file: "</front>
<front id="languageH-159">#define MSG_SD_PRINTING_BYTE                "SD printing byte "</front>
<front id="languageH-160">#define MSG_SD_NOT_PRINTING                 "Not SD printing"</front>
<front id="languageH-161">#define MSG_SD_ERR_WRITE_TO_FILE            "error writing to file"</front>
<front id="languageH-162">#define MSG_SD_CANT_ENTER_SUBDIR            "Cannot enter subdir: "</front>
<front id="languageH-163"></front>
<front id="languageH-164">#define MSG_STEPPER_TOO_HIGH                "Steprate too high: "</front>
<front id="languageH-165">#define MSG_ENDSTOPS_HIT                    "endstops hit: "</front>
<front id="languageH-166">#define MSG_ERR_COLD_EXTRUDE_STOP           " cold extrusion prevented"</front>
<front id="languageH-167">#define MSG_ERR_LONG_EXTRUDE_STOP           " too long extrusion prevented"</front>
<front id="languageH-168">#define MSG_TOO_COLD_FOR_M600               "M600 Hotend too cold to change filament"</front>
<front id="languageH-169">#define MSG_BABYSTEPPING_X                  "Babystepping X"</front>
<front id="languageH-170">#define MSG_BABYSTEPPING_Y                  "Babystepping Y"</front>
<front id="languageH-171">#define MSG_BABYSTEPPING_Z                  "Babystepping Z"</front>
<front id="languageH-172">#define MSG_SERIAL_ERROR_MENU_STRUCTURE     "Error in menu structure"</front>
<front id="languageH-173"></front>
<front id="languageH-174">#define MSG_ERR_EEPROM_WRITE                "Error writing to EEPROM!"</front>
<front id="languageH-175"></front>
<front id="languageH-176">// temperature.cpp strings</front>
<front id="languageH-177">#define MSG_PID_AUTOTUNE                    "PID Autotune"</front>
<front id="languageH-178">#define MSG_PID_AUTOTUNE_START              MSG_PID_AUTOTUNE " start"</front>
<front id="languageH-179">#define MSG_PID_AUTOTUNE_FAILED             MSG_PID_AUTOTUNE " failed!"</front>
<front id="languageH-180">#define MSG_PID_BAD_EXTRUDER_NUM            MSG_PID_AUTOTUNE_FAILED " Bad extruder number"</front>
<front id="languageH-181">#define MSG_PID_TEMP_TOO_HIGH               MSG_PID_AUTOTUNE_FAILED " Temperature too high"</front>
<front id="languageH-182">#define MSG_PID_TIMEOUT                     MSG_PID_AUTOTUNE_FAILED " timeout"</front>
<front id="languageH-183">#define MSG_BIAS                            " bias: "</front>
<front id="languageH-184">#define MSG_D                               " d: "</front>
<front id="languageH-185">#define MSG_T_MIN                           " min: "</front>
<front id="languageH-186">#define MSG_T_MAX                           " max: "</front>
<front id="languageH-187">#define MSG_KU                              " Ku: "</front>
<front id="languageH-188">#define MSG_TU                              " Tu: "</front>
<front id="languageH-189">#define MSG_CLASSIC_PID                     " Classic PID "</front>
<front id="languageH-190">#define MSG_KP                              " Kp: "</front>
<front id="languageH-191">#define MSG_KI                              " Ki: "</front>
<front id="languageH-192">#define MSG_KD                              " Kd: "</front>
<front id="languageH-193">#define MSG_B                               "B:"</front>
<front id="languageH-194">#define MSG_T                               "T:"</front>
<front id="languageH-195">#define MSG_AT                              " @:"</front>
<front id="languageH-196">#define MSG_PID_AUTOTUNE_FINISHED           MSG_PID_AUTOTUNE " finished! Put the last Kp, Ki and Kd constants from below into Configuration.h"</front>
<front id="languageH-197">#define MSG_PID_DEBUG                       " PID_DEBUG "</front>
<front id="languageH-198">#define MSG_PID_DEBUG_INPUT                 ": Input "</front>
<front id="languageH-199">#define MSG_PID_DEBUG_OUTPUT                " Output "</front>
<front id="languageH-200">#define MSG_PID_DEBUG_PTERM                 " pTerm "</front>
<front id="languageH-201">#define MSG_PID_DEBUG_ITERM                 " iTerm "</front>
<front id="languageH-202">#define MSG_PID_DEBUG_DTERM                 " dTerm "</front>
<front id="languageH-203">#define MSG_PID_DEBUG_CTERM                 " cTerm "</front>
<front id="languageH-204">#define MSG_INVALID_EXTRUDER_NUM            " - Invalid extruder number !"</front>
<front id="languageH-205"></front>
<front id="languageH-206">#define MSG_HEATER_BED                      "bed"</front>
<front id="languageH-207">#define MSG_STOPPED_HEATER                  ", system stopped! Heater_ID: "</front>
<front id="languageH-208">#define MSG_REDUNDANCY                      "Heater switched off. Temperature difference between temp sensors is too high !"</front>
<front id="languageH-209">#define MSG_T_HEATING_FAILED                "Heating failed"</front>
<front id="languageH-210">#define MSG_T_THERMAL_RUNAWAY               "Thermal Runaway"</front>
<front id="languageH-211">#define MSG_T_MAXTEMP                       "MAXTEMP triggered"</front>
<front id="languageH-212">#define MSG_T_MINTEMP                       "MINTEMP triggered"</front>
<front id="languageH-213"></front>
<front id="languageH-214">// Debug</front>
<front id="languageH-215">#define MSG_DEBUG_ECHO                      "DEBUG ECHO ENABLED"</front>
<front id="languageH-216">#define MSG_DEBUG_INFO                      "DEBUG INFO ENABLED"</front>
<front id="languageH-217">#define MSG_DEBUG_ERRORS                    "DEBUG ERRORS ENABLED"</front>
<front id="languageH-218">#define MSG_DEBUG_DRYRUN                    "DEBUG DRYRUN ENABLED"</front>
<front id="languageH-219">#define MSG_DEBUG_LEVELING                  "DEBUG LEVELING ENABLED"</front>
<front id="languageH-220"></front>
<front id="languageH-221">// LCD Menu Messages</front>
<front id="languageH-222"></front>
<front id="languageH-223">#if DISABLED(DISPLAY_CHARSET_HD44780_JAPAN) && DISABLED(DISPLAY_CHARSET_HD44780_WESTERN) && DISABLED(DISPLAY_CHARSET_HD44780_CYRILLIC)</front>
<front id="languageH-224">  #define DISPLAY_CHARSET_HD44780_JAPAN</front>
<front id="languageH-225">#endif</front>
<front id="languageH-226"></front>
<front id="languageH-227">#include LANGUAGE_INCLUDE</front>
<front id="languageH-228">#include "language_en.h"</front>
<front id="languageH-229"></front>
<front id="languageH-230">#endif //__LANGUAGE_H</front>
 </pre>
<h1 id="language_anHtitle" >language_an.h</h1>
<pre id="language_anH"  class="prettyprint linenums"><front id="language_anH-1">/**</front>
<front id="language_anH-2"> * Aragonese</front>
<front id="language_anH-3"> *</front>
<front id="language_anH-4"> * LCD Menu Messages</front>
<front id="language_anH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_anH-6"> *</front>
<front id="language_anH-7"> */</front>
<front id="language_anH-8">#ifndef LANGUAGE_AN_H</front>
<front id="language_anH-9">#define LANGUAGE_AN_H</front>
<front id="language_anH-10"></front>
<front id="language_anH-11">#define MAPPER_NON</front>
<front id="language_anH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_anH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_anH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_anH-15"></front>
<front id="language_anH-16">#define WELCOME_MSG                         MACHINE_NAME " parada."</front>
<front id="language_anH-17">#define MSG_SD_INSERTED                     "Tarcheta colocada"</front>
<front id="language_anH-18">#define MSG_SD_REMOVED                      "Tarcheta retirada"</front>
<front id="language_anH-19">#define MSG_MAIN                            "Menu prencipal"</front>
<front id="language_anH-20">#define MSG_AUTOSTART                       " Autostart"</front>
<front id="language_anH-21">#define MSG_DISABLE_STEPPERS                "Amortar motors"</front>
<front id="language_anH-22">#define MSG_AUTO_HOME                       "Levar a l'orichen"</front>
<front id="language_anH-23">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_anH-24">#define MSG_SET_ORIGIN                      "Establir zero"</front>
<front id="language_anH-25">#define MSG_PREHEAT_PLA                     "Precalentar PLA"</front>
<front id="language_anH-26">#define MSG_PREHEAT_PLA_N                   "Precalentar PLA "</front>
<front id="language_anH-27">#define MSG_PREHEAT_PLA_ALL                 "Precalentar PLA a"</front>
<front id="language_anH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Prec. PLA Base"</front>
<front id="language_anH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Achustar tem. PLA"</front>
<front id="language_anH-30">#define MSG_PREHEAT_ABS                     "Precalentar ABS"</front>
<front id="language_anH-31">#define MSG_PREHEAT_ABS_N                   "Precalentar ABS "</front>
<front id="language_anH-32">#define MSG_PREHEAT_ABS_ALL                 "Precalentar ABS a"</front>
<front id="language_anH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Prec. ABS Base"</front>
<front id="language_anH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Achustar tem. ABS"</front>
<front id="language_anH-35">#define MSG_COOLDOWN                        "Enfriar"</front>
<front id="language_anH-36">#define MSG_SWITCH_PS_ON                    "Enchegar Fuent"</front>
<front id="language_anH-37">#define MSG_SWITCH_PS_OFF                   "Desenchegar Fuent"</front>
<front id="language_anH-38">#define MSG_EXTRUDE                         "Extruir"</front>
<front id="language_anH-39">#define MSG_RETRACT                         "Retraer"</front>
<front id="language_anH-40">#define MSG_MOVE_AXIS                       "Mover Eixes"</front>
<front id="language_anH-41">#define MSG_MOVE_X                          "Move X"</front>
<front id="language_anH-42">#define MSG_MOVE_Y                          "Move Y"</front>
<front id="language_anH-43">#define MSG_MOVE_Z                          "Move Z"</front>
<front id="language_anH-44">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_anH-45">#define MSG_MOVE_01MM                       "Move 0.1mm"</front>
<front id="language_anH-46">#define MSG_MOVE_1MM                        "Move 1mm"</front>
<front id="language_anH-47">#define MSG_MOVE_10MM                       "Move 10mm"</front>
<front id="language_anH-48">#define MSG_SPEED                           "Velocidat"</front>
<front id="language_anH-49">#define MSG_NOZZLE                          "Nozzle"</front>
<front id="language_anH-50">#define MSG_BED                             "Base"</front>
<front id="language_anH-51">#define MSG_FAN_SPEED                       "Ixoriador"</front>
<front id="language_anH-52">#define MSG_FLOW                            "Fluxo"</front>
<front id="language_anH-53">#define MSG_CONTROL                         "Control"</front>
<front id="language_anH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_anH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_anH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_anH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_anH-58">#define MSG_ON                              "On"</front>
<front id="language_anH-59">#define MSG_OFF                             "Off"</front>
<front id="language_anH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_anH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_anH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_anH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_anH-64">#define MSG_ACC                             "Acel"</front>
<front id="language_anH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_anH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_anH-67">#define MSG_VE_JERK                         "Ves-jerk"</front>
<front id="language_anH-68">#define MSG_VMAX                            "Vmax"</front>
<front id="language_anH-69">#define MSG_X                               "x"</front>
<front id="language_anH-70">#define MSG_Y                               "y"</front>
<front id="language_anH-71">#define MSG_Z                               "z"</front>
<front id="language_anH-72">#define MSG_E                               "y"</front>
<front id="language_anH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_anH-74">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_anH-75">#define MSG_AMAX                            "Amax"</front>
<front id="language_anH-76">#define MSG_A_RETRACT                       "A-retrac."</front>
<front id="language_anH-77">#define MSG_XSTEPS                          "X trangos/mm"</front>
<front id="language_anH-78">#define MSG_YSTEPS                          "Y trangos/mm"</front>
<front id="language_anH-79">#define MSG_ZSTEPS                          "Z trangos/mm"</front>
<front id="language_anH-80">#define MSG_ESTEPS                          "E trangos/mm"</front>
<front id="language_anH-81">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_anH-82">#define MSG_MOTION                          "Movimiento"</front>
<front id="language_anH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_anH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_anH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_anH-86">#define MSG_CONTRAST                        "Contrast"</front>
<front id="language_anH-87">#define MSG_STORE_EPROM                     "Alzar Memoria"</front>
<front id="language_anH-88">#define MSG_LOAD_EPROM                      "Cargar Memoria"</front>
<front id="language_anH-89">#define MSG_RESTORE_FAILSAFE                "Rest. d'emerchen."</front>
<front id="language_anH-90">#define MSG_REFRESH                         "Tornar a cargar"</front>
<front id="language_anH-91">#define MSG_WATCH                           "Monitorizar"</front>
<front id="language_anH-92">#define MSG_PREPARE                         "Preparar"</front>
<front id="language_anH-93">#define MSG_TUNE                            "Achustar"</front>
<front id="language_anH-94">#define MSG_PAUSE_PRINT                     "Pausar impresion"</front>
<front id="language_anH-95">#define MSG_RESUME_PRINT                    "Contin. impresion"</front>
<front id="language_anH-96">#define MSG_STOP_PRINT                      "Detener Impresion"</front>
<front id="language_anH-97">#define MSG_CARD_MENU                       "Menu de SD"</front>
<front id="language_anH-98">#define MSG_NO_CARD                         "No i hai tarcheta"</front>
<front id="language_anH-99">#define MSG_DWELL                           "Reposo..."</front>
<front id="language_anH-100">#define MSG_USERWAIT                        "Asperan. ordines"</front>
<front id="language_anH-101">#define MSG_RESUMING                        "Contin. impresion"</front>
<front id="language_anH-102">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_anH-103">#define MSG_NO_MOVE                         "Sin movimiento"</front>
<front id="language_anH-104">#define MSG_KILLED                          "ATURADA D'EMERCH."</front>
<front id="language_anH-105">#define MSG_STOPPED                         "ATURADA."</front>
<front id="language_anH-106">#define MSG_CONTROL_RETRACT                 "Retraer mm"</front>
<front id="language_anH-107">#define MSG_CONTROL_RETRACT_SWAP            "Swap Retraer mm"</front>
<front id="language_anH-108">#define MSG_CONTROL_RETRACTF                "Retraer  F"</front>
<front id="language_anH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Devantar mm"</front>
<front id="language_anH-110">#define MSG_CONTROL_RETRACT_RECOVER         "DesRet +mm"</front>
<front id="language_anH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Swap DesRet +mm"</front>
<front id="language_anH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "DesRet F"</front>
<front id="language_anH-113">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_anH-114">#define MSG_FILAMENTCHANGE                  "Cambear"</front>
<front id="language_anH-115">#define MSG_INIT_SDCARD                     "Encetan. tarcheta"</front>
<front id="language_anH-116">#define MSG_CNG_SDCARD                      "Cambiar tarcheta"</front>
<front id="language_anH-117">#define MSG_ZPROBE_OUT                      "Z probe out. bed"</front>
<front id="language_anH-118">#define MSG_POSITION_UNKNOWN                "Home X/Y before Z"</front>
<front id="language_anH-119">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_anH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_anH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_anH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_anH-123">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_anH-124">#define MSG_END_HOUR                        "hours"</front>
<front id="language_anH-125">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_anH-126"></front>
<front id="language_anH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_anH-128">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_anH-129">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_anH-130">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_anH-131">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_anH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_anH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_anH-134"></front>
<front id="language_anH-135">#endif // LANGUAGE_AN_H</front>
 </pre>
<h1 id="language_bgHtitle" >language_bg.h</h1>
<pre id="language_bgH"  class="prettyprint linenums"><front id="language_bgH-1">/**</front>
<front id="language_bgH-2"> * Bulgarian</front>
<front id="language_bgH-3"> *</front>
<front id="language_bgH-4"> * LCD Menu Messages</front>
<front id="language_bgH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_bgH-6"> *</front>
<front id="language_bgH-7"> */</front>
<front id="language_bgH-8">#ifndef LANGUAGE_BG_H</front>
<front id="language_bgH-9">#define LANGUAGE_BG_H</front>
<front id="language_bgH-10"></front>
<front id="language_bgH-11">#define MAPPER_D0D1                // For Cyrillic</front>
<front id="language_bgH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_bgH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_bgH-14">#define DISPLAY_CHARSET_ISO10646_5</front>
<front id="language_bgH-15"></front>
<front id="language_bgH-16">#define WELCOME_MSG                         MACHINE_NAME " ."</front>
<front id="language_bgH-17">#define MSG_SD_INSERTED                     "  "</front>
<front id="language_bgH-18">#define MSG_SD_REMOVED                      "  "</front>
<front id="language_bgH-19">#define MSG_MAIN                            ""</front>
<front id="language_bgH-20">#define MSG_AUTOSTART                       ""</front>
<front id="language_bgH-21">#define MSG_DISABLE_STEPPERS                ". "</front>
<front id="language_bgH-22">#define MSG_AUTO_HOME                       ""</front>
<front id="language_bgH-23">#define MSG_SET_HOME_OFFSETS                " "</front>
<front id="language_bgH-24">#define MSG_SET_ORIGIN                      " "</front>
<front id="language_bgH-25">#define MSG_PREHEAT_PLA                     " PLA"</front>
<front id="language_bgH-26">#define MSG_PREHEAT_PLA_N                   " PLA"</front>
<front id="language_bgH-27">#define MSG_PREHEAT_PLA_ALL                 ". PLA "</front>
<front id="language_bgH-28">#define MSG_PREHEAT_PLA_BEDONLY             ". PLA "</front>
<front id="language_bgH-29">#define MSG_PREHEAT_PLA_SETTINGS            " PLA"</front>
<front id="language_bgH-30">#define MSG_PREHEAT_ABS                     " ABS"</front>
<front id="language_bgH-31">#define MSG_PREHEAT_ABS_N                   " ABS"</front>
<front id="language_bgH-32">#define MSG_PREHEAT_ABS_ALL                 ". ABS "</front>
<front id="language_bgH-33">#define MSG_PREHEAT_ABS_BEDONLY             ". ABS "</front>
<front id="language_bgH-34">#define MSG_PREHEAT_ABS_SETTINGS            " ABS"</front>
<front id="language_bgH-35">#define MSG_COOLDOWN                        ""</front>
<front id="language_bgH-36">#define MSG_SWITCH_PS_ON                    ". "</front>
<front id="language_bgH-37">#define MSG_SWITCH_PS_OFF                   ". "</front>
<front id="language_bgH-38">#define MSG_EXTRUDE                         ""</front>
<front id="language_bgH-39">#define MSG_RETRACT                         ""</front>
<front id="language_bgH-40">#define MSG_MOVE_AXIS                       "  "</front>
<front id="language_bgH-41">#define MSG_MOVE_X                          "  X"</front>
<front id="language_bgH-42">#define MSG_MOVE_Y                          "  Y"</front>
<front id="language_bgH-43">#define MSG_MOVE_Z                          "  Z"</front>
<front id="language_bgH-44">#define MSG_MOVE_E                          ""</front>
<front id="language_bgH-45">#define MSG_MOVE_01MM                       "  0.1mm"</front>
<front id="language_bgH-46">#define MSG_MOVE_1MM                        "  1mm"</front>
<front id="language_bgH-47">#define MSG_MOVE_10MM                       "  10mm"</front>
<front id="language_bgH-48">#define MSG_LEVEL_BED                       ""</front>
<front id="language_bgH-49">#define MSG_SPEED                           ""</front>
<front id="language_bgH-50">#define MSG_NOZZLE                          LCD_STR_THERMOMETER " "</front>
<front id="language_bgH-51">#define MSG_BED                             LCD_STR_THERMOMETER " "</front>
<front id="language_bgH-52">#define MSG_FAN_SPEED                       ""</front>
<front id="language_bgH-53">#define MSG_FLOW                            ""</front>
<front id="language_bgH-54">#define MSG_CONTROL                         ""</front>
<front id="language_bgH-55">#define MSG_MIN                             LCD_STR_THERMOMETER " "</front>
<front id="language_bgH-56">#define MSG_MAX                             LCD_STR_THERMOMETER " "</front>
<front id="language_bgH-57">#define MSG_FACTOR                          LCD_STR_THERMOMETER " "</front>
<front id="language_bgH-58">#define MSG_AUTOTEMP                        "-."</front>
<front id="language_bgH-59">#define MSG_ON                              ". "</front>
<front id="language_bgH-60">#define MSG_OFF                             ". "</front>
<front id="language_bgH-61">#define MSG_PID_P                           "PID-P"</front>
<front id="language_bgH-62">#define MSG_PID_I                           "PID-I"</front>
<front id="language_bgH-63">#define MSG_PID_D                           "PID-D"</front>
<front id="language_bgH-64">#define MSG_PID_C                           "PID-C"</front>
<front id="language_bgH-65">#define MSG_ACC                             "Acc"</front>
<front id="language_bgH-66">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_bgH-67">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_bgH-68">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_bgH-69">#define MSG_VMAX                            "Vmax "</front>
<front id="language_bgH-70">#define MSG_X                               "x"</front>
<front id="language_bgH-71">#define MSG_Y                               "y"</front>
<front id="language_bgH-72">#define MSG_Z                               "z"</front>
<front id="language_bgH-73">#define MSG_E                               "e"</front>
<front id="language_bgH-74">#define MSG_VMIN                            "Vmin"</front>
<front id="language_bgH-75">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_bgH-76">#define MSG_AMAX                            "Amax "</front>
<front id="language_bgH-77">#define MSG_A_RETRACT                       "A-"</front>
<front id="language_bgH-78">#define MSG_XSTEPS                          "X /mm"</front>
<front id="language_bgH-79">#define MSG_YSTEPS                          "Y /mm"</front>
<front id="language_bgH-80">#define MSG_ZSTEPS                          "Z /mm"</front>
<front id="language_bgH-81">#define MSG_ESTEPS                          "E /mm"</front>
<front id="language_bgH-82">#define MSG_TEMPERATURE                     ""</front>
<front id="language_bgH-83">#define MSG_MOTION                          ""</front>
<front id="language_bgH-84">#define MSG_VOLUMETRIC                      ""</front>
<front id="language_bgH-85">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_bgH-86">#define MSG_FILAMENT_DIAM                   ". "</front>
<front id="language_bgH-87">#define MSG_CONTRAST                        "LCD "</front>
<front id="language_bgH-88">#define MSG_STORE_EPROM                     "  EPROM"</front>
<front id="language_bgH-89">#define MSG_LOAD_EPROM                      "  EPROM"</front>
<front id="language_bgH-90">#define MSG_RESTORE_FAILSAFE                " "</front>
<front id="language_bgH-91">#define MSG_REFRESH                         LCD_STR_REFRESH ""</front>
<front id="language_bgH-92">#define MSG_WATCH                           ""</front>
<front id="language_bgH-93">#define MSG_PREPARE                         ""</front>
<front id="language_bgH-94">#define MSG_TUNE                            ""</front>
<front id="language_bgH-95">#define MSG_PAUSE_PRINT                     ""</front>
<front id="language_bgH-96">#define MSG_RESUME_PRINT                    " "</front>
<front id="language_bgH-97">#define MSG_STOP_PRINT                      " "</front>
<front id="language_bgH-98">#define MSG_CARD_MENU                       " "</front>
<front id="language_bgH-99">#define MSG_NO_CARD                         " "</front>
<front id="language_bgH-100">#define MSG_DWELL                           "..."</front>
<front id="language_bgH-101">#define MSG_USERWAIT                        ""</front>
<front id="language_bgH-102">#define MSG_RESUMING                        ". "</front>
<front id="language_bgH-103">#define MSG_PRINT_ABORTED                   "  "</front>
<front id="language_bgH-104">#define MSG_NO_MOVE                         " "</front>
<front id="language_bgH-105">#define MSG_KILLED                          "."</front>
<front id="language_bgH-106">#define MSG_STOPPED                         "."</front>
<front id="language_bgH-107">#define MSG_CONTROL_RETRACT                 " mm"</front>
<front id="language_bgH-108">#define MSG_CONTROL_RETRACT_SWAP            "  mm"</front>
<front id="language_bgH-109">#define MSG_CONTROL_RETRACTF                "  V"</front>
<front id="language_bgH-110">#define MSG_CONTROL_RETRACT_ZLIFT           " mm"</front>
<front id="language_bgH-111">#define MSG_CONTROL_RETRACT_RECOVER         " +mm"</front>
<front id="language_bgH-112">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "  +mm"</front>
<front id="language_bgH-113">#define MSG_CONTROL_RETRACT_RECOVERF        "  V"</front>
<front id="language_bgH-114">#define MSG_AUTORETRACT                     "o"</front>
<front id="language_bgH-115">#define MSG_FILAMENTCHANGE                  " "</front>
<front id="language_bgH-116">#define MSG_INIT_SDCARD                     ". SD-"</front>
<front id="language_bgH-117">#define MSG_CNG_SDCARD                      " SD-"</front>
<front id="language_bgH-118">#define MSG_ZPROBE_OUT                      "Z-  "</front>
<front id="language_bgH-119">#define MSG_POSITION_UNKNOWN                " X/Y  Z"</front>
<front id="language_bgH-120">#define MSG_ZPROBE_ZOFFSET                  "Z "</front>
<front id="language_bgH-121">#define MSG_BABYSTEP_X                      " X"</front>
<front id="language_bgH-122">#define MSG_BABYSTEP_Y                      " Y"</front>
<front id="language_bgH-123">#define MSG_BABYSTEP_Z                      " Z"</front>
<front id="language_bgH-124">#define MSG_ENDSTOP_ABORT                   " ."</front>
<front id="language_bgH-125">#define MSG_END_HOUR                        ""</front>
<front id="language_bgH-126">#define MSG_END_MINUTE                      ""</front>
<front id="language_bgH-127"></front>
<front id="language_bgH-128">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_bgH-129">    #define MSG_DELTA_CALIBRATE             " "</front>
<front id="language_bgH-130">    #define MSG_DELTA_CALIBRATE_X           " X"</front>
<front id="language_bgH-131">    #define MSG_DELTA_CALIBRATE_Y           " Y"</front>
<front id="language_bgH-132">    #define MSG_DELTA_CALIBRATE_Z           " Z"</front>
<front id="language_bgH-133">    #define MSG_DELTA_CALIBRATE_CENTER      " "</front>
<front id="language_bgH-134">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_bgH-135"></front>
<front id="language_bgH-136">#endif // LANGUAGE_BG_H</front>
 </pre>
<h1 id="language_caHtitle" >language_ca.h</h1>
<pre id="language_caH"  class="prettyprint linenums"><front id="language_caH-1">/**</front>
<front id="language_caH-2"> * Catalan</front>
<front id="language_caH-3"> *</front>
<front id="language_caH-4"> * LCD Menu Messages</front>
<front id="language_caH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_caH-6"> *</front>
<front id="language_caH-7"> */</front>
<front id="language_caH-8">#ifndef LANGUAGE_CA_H</front>
<front id="language_caH-9">#define LANGUAGE_CA_H</front>
<front id="language_caH-10"></front>
<front id="language_caH-11">//#define MAPPER_NON</front>
<front id="language_caH-12">#define MAPPER_C2C3  // because of ""</front>
<front id="language_caH-13">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_caH-14">//#define SIMULATE_ROMFONT</front>
<front id="language_caH-15">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_caH-16"></front>
<front id="language_caH-17">#define WELCOME_MSG                         MACHINE_NAME " preparada."</front>
<front id="language_caH-18">#define MSG_SD_INSERTED                     "SD detectada."</front>
<front id="language_caH-19">#define MSG_SD_REMOVED                      "SD expulsada."</front>
<front id="language_caH-20">#define MSG_MAIN                            "Menu principal"</front>
<front id="language_caH-21">#define MSG_AUTOSTART                       "Inici automatic"</front>
<front id="language_caH-22">#define MSG_DISABLE_STEPPERS                "Apagar motors"</front>
<front id="language_caH-23">#define MSG_AUTO_HOME                       "Home global"</front>
<front id="language_caH-24">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_caH-25">#define MSG_SET_ORIGIN                      "Establir origen"</front>
<front id="language_caH-26">#define MSG_PREHEAT_PLA                     "Preescalfar PLA"</front>
<front id="language_caH-27">#define MSG_PREHEAT_PLA_N                   "Preescalfar PLA "</front>
<front id="language_caH-28">#define MSG_PREHEAT_PLA_ALL                 "Preesc. tot PLA"</front>
<front id="language_caH-29">#define MSG_PREHEAT_PLA_BEDONLY             "Preesc. llit PLA"</front>
<front id="language_caH-30">#define MSG_PREHEAT_PLA_SETTINGS            "Configuraci PLA"</front>
<front id="language_caH-31">#define MSG_PREHEAT_ABS                     "Preescalfar ABS"</front>
<front id="language_caH-32">#define MSG_PREHEAT_ABS_N                   "Preescalfar ABS "</front>
<front id="language_caH-33">#define MSG_PREHEAT_ABS_ALL                 "Preesc. tot ABS"</front>
<front id="language_caH-34">#define MSG_PREHEAT_ABS_BEDONLY             "Preesc. llit ABS"</front>
<front id="language_caH-35">#define MSG_PREHEAT_ABS_SETTINGS            "Configuraci ABS"</front>
<front id="language_caH-36">#define MSG_COOLDOWN                        "Refredar"</front>
<front id="language_caH-37">#define MSG_SWITCH_PS_ON                    "Switch power on"</front>
<front id="language_caH-38">#define MSG_SWITCH_PS_OFF                   "Switch power off"</front>
<front id="language_caH-39">#define MSG_EXTRUDE                         "Extruir"</front>
<front id="language_caH-40">#define MSG_RETRACT                         "Refredar"</front>
<front id="language_caH-41">#define MSG_MOVE_AXIS                       "Moure eixos"</front>
<front id="language_caH-42">#define MSG_MOVE_X                          "Moure X"</front>
<front id="language_caH-43">#define MSG_MOVE_Y                          "Moure Y"</front>
<front id="language_caH-44">#define MSG_MOVE_Z                          "Moure Z"</front>
<front id="language_caH-45">#define MSG_MOVE_E                          "Extrusor"</front>
<front id="language_caH-46">#define MSG_MOVE_01MM                       "Moure 0.1mm"</front>
<front id="language_caH-47">#define MSG_MOVE_1MM                        "Moure 1mm"</front>
<front id="language_caH-48">#define MSG_MOVE_10MM                       "Moure 10mm"</front>
<front id="language_caH-49">#define MSG_SPEED                           "Velocitat"</front>
<front id="language_caH-50">#define MSG_NOZZLE                          "Nozzle"</front>
<front id="language_caH-51">#define MSG_BED                             "Llit"</front>
<front id="language_caH-52">#define MSG_FAN_SPEED                       "Vel. Ventilador"</front>
<front id="language_caH-53">#define MSG_FLOW                            "Fluxe"</front>
<front id="language_caH-54">#define MSG_CONTROL                         "Control"</front>
<front id="language_caH-55">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_caH-56">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_caH-57">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_caH-58">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_caH-59">#define MSG_ON                              "On "</front>
<front id="language_caH-60">#define MSG_OFF                             "Off"</front>
<front id="language_caH-61">#define MSG_PID_P                           "PID-P"</front>
<front id="language_caH-62">#define MSG_PID_I                           "PID-I"</front>
<front id="language_caH-63">#define MSG_PID_D                           "PID-D"</front>
<front id="language_caH-64">#define MSG_PID_C                           "PID-C"</front>
<front id="language_caH-65">#define MSG_ACC                             "Accel"</front>
<front id="language_caH-66">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_caH-67">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_caH-68">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_caH-69">#define MSG_VMAX                            "Vmax "</front>
<front id="language_caH-70">#define MSG_X                               "x"</front>
<front id="language_caH-71">#define MSG_Y                               "y"</front>
<front id="language_caH-72">#define MSG_Z                               "z"</front>
<front id="language_caH-73">#define MSG_E                               "e"</front>
<front id="language_caH-74">#define MSG_VMIN                            "Vmin"</front>
<front id="language_caH-75">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_caH-76">#define MSG_AMAX                            "Amax "</front>
<front id="language_caH-77">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_caH-78">#define MSG_XSTEPS                          "Xpassos/mm"</front>
<front id="language_caH-79">#define MSG_YSTEPS                          "Ypassos/mm"</front>
<front id="language_caH-80">#define MSG_ZSTEPS                          "Zpassos/mm"</front>
<front id="language_caH-81">#define MSG_ESTEPS                          "Epassos/mm"</front>
<front id="language_caH-82">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_caH-83">#define MSG_MOTION                          "Moviment"</front>
<front id="language_caH-84">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_caH-85">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_caH-86">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_caH-87">#define MSG_CONTRAST                        "Contrast de LCD"</front>
<front id="language_caH-88">#define MSG_STORE_EPROM                     "Desar a memoria"</front>
<front id="language_caH-89">#define MSG_LOAD_EPROM                      "Carregar de mem."</front>
<front id="language_caH-90">#define MSG_RESTORE_FAILSAFE                "Rest. emergencia"</front>
<front id="language_caH-91">#define MSG_REFRESH                         "Refrescar"</front>
<front id="language_caH-92">#define MSG_WATCH                           "Pantalla Info."</front>
<front id="language_caH-93">#define MSG_PREPARE                         "Preparar"</front>
<front id="language_caH-94">#define MSG_TUNE                            "Calibrar"</front>
<front id="language_caH-95">#define MSG_PAUSE_PRINT                     "Pausa imp."</front>
<front id="language_caH-96">#define MSG_RESUME_PRINT                    "Reprendre imp."</front>
<front id="language_caH-97">#define MSG_STOP_PRINT                      "Parar inp."</front>
<front id="language_caH-98">#define MSG_CARD_MENU                       "Imprimir de SD"</front>
<front id="language_caH-99">#define MSG_NO_CARD                         "-Sense targeta SD"</front>
<front id="language_caH-100">#define MSG_DWELL                           "Repos..."</front>
<front id="language_caH-101">#define MSG_USERWAIT                        "Esperant usuari.."</front>
<front id="language_caH-102">#define MSG_RESUMING                        "Reprenent imp."</front>
<front id="language_caH-103">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_caH-104">#define MSG_NO_MOVE                         "Sense moviment."</front>
<front id="language_caH-105">#define MSG_KILLED                          "PARADA DE EMERG. "</front>
<front id="language_caH-106">#define MSG_STOPPED                         "ATURAT. "</front>
<front id="language_caH-107">#define MSG_CONTROL_RETRACT                 "Retreure mm"</front>
<front id="language_caH-108">#define MSG_CONTROL_RETRACT_SWAP            "Swap Retreure mm"</front>
<front id="language_caH-109">#define MSG_CONTROL_RETRACTF                "Retreure  F"</front>
<front id="language_caH-110">#define MSG_CONTROL_RETRACT_ZLIFT           "Aixecar mm"</front>
<front id="language_caH-111">#define MSG_CONTROL_RETRACT_RECOVER         "DesRet +mm"</front>
<front id="language_caH-112">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Swap DesRet +mm"</front>
<front id="language_caH-113">#define MSG_CONTROL_RETRACT_RECOVERF        "DesRet  F"</front>
<front id="language_caH-114">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_caH-115">#define MSG_FILAMENTCHANGE                  "Canviar filament"</front>
<front id="language_caH-116">#define MSG_INIT_SDCARD                     "Iniciant SD"</front>
<front id="language_caH-117">#define MSG_CNG_SDCARD                      "Canviar SD"</front>
<front id="language_caH-118">#define MSG_ZPROBE_OUT                      "Z probe out. bed"</front>
<front id="language_caH-119">#define MSG_POSITION_UNKNOWN                "Home X/Y abans Z"</front>
<front id="language_caH-120">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_caH-121">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_caH-122">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_caH-123">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_caH-124">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_caH-125">#define MSG_END_HOUR                        "hours"</front>
<front id="language_caH-126">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_caH-127"></front>
<front id="language_caH-128">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_caH-129">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_caH-130">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_caH-131">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_caH-132">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_caH-133">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_caH-134">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_caH-135"></front>
<front id="language_caH-136">#endif // LANGUAGE_CA_H</front>
 </pre>
<h1 id="language_cnHtitle" >language_cn.h</h1>
<pre id="language_cnH"  class="prettyprint linenums"><front id="language_cnH-1">/**</front>
<front id="language_cnH-2"> * Chinese</front>
<front id="language_cnH-3"> *</front>
<front id="language_cnH-4"> * LCD Menu Messages</front>
<front id="language_cnH-5"> * Se also documentation/LCDLanguageFont.md</front>
<front id="language_cnH-6"> *</front>
<front id="language_cnH-7"> */</front>
<front id="language_cnH-8">#ifndef LANGUAGE_CN_H</front>
<front id="language_cnH-9">#define LANGUAGE_CN_H</front>
<front id="language_cnH-10"></front>
<front id="language_cnH-11">  #define MAPPER_NON         // For direct asci codes</front>
<front id="language_cnH-12">  #define DISPLAY_CHARSET_ISO10646_CN</front>
<front id="language_cnH-13"></front>
<front id="language_cnH-14">  #define WELCOME_MSG                         "\xa4\xa5\xa6\xa7"</front>
<front id="language_cnH-15">  #define MSG_SD_INSERTED                     "\xa8\xa9\xaa\xab"</front>
<front id="language_cnH-16">  #define MSG_SD_REMOVED                      "\xa8\xa9\xac\xad"</front>
<front id="language_cnH-17">  #define MSG_MAIN                            "\xae\xaf\xb0"</front>
<front id="language_cnH-18">  #define MSG_AUTOSTART                       "\xb1\xb2\xb3\xb4"</front>
<front id="language_cnH-19">  #define MSG_DISABLE_STEPPERS                "\xb5\xb6\xb7\xb8\xb9\xba"</front>
<front id="language_cnH-20">  #define MSG_AUTO_HOME                       "\xbb\xbc\xbd"</front>
<front id="language_cnH-21">  #define MSG_SET_HOME_OFFSETS                "\xbe\xbf\xbb\xbc\xbd\xc0\xc1"</front>
<front id="language_cnH-22">  #define MSG_SET_ORIGIN                      "\xbe\xbf\xbc\xbd"</front>
<front id="language_cnH-23">  #define MSG_PREHEAT_PLA                     "\xc3\xc4 PLA"</front>
<front id="language_cnH-24">  #define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "</front>
<front id="language_cnH-25">  #define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " \xc5\xc6"</front>
<front id="language_cnH-26">  #define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " \xc4\xc7"</front>
<front id="language_cnH-27">  #define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " \xbe\xbf"</front>
<front id="language_cnH-28">  #define MSG_PREHEAT_ABS                     "\xc3\xc4 ABS"</front>
<front id="language_cnH-29">  #define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "</front>
<front id="language_cnH-30">  #define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " \xc5\xc6"</front>
<front id="language_cnH-31">  #define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " \xbe\xc6"</front>
<front id="language_cnH-32">  #define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " \xbe\xbf"</front>
<front id="language_cnH-33">  #define MSG_COOLDOWN                        "\xc8\xc9"</front>
<front id="language_cnH-34">  #define MSG_SWITCH_PS_ON                    "\xb9\xcb\xca\xb3"</front>
<front id="language_cnH-35">  #define MSG_SWITCH_PS_OFF                   "\xb9\xcb\xb5\xb6"</front>
<front id="language_cnH-36">  #define MSG_EXTRUDE                         "\xcc\xad"</front>
<front id="language_cnH-37">  #define MSG_RETRACT                         "\xbb\xcd"</front>
<front id="language_cnH-38">  #define MSG_MOVE_AXIS                       "\xc1\xb2\xce"</front>
<front id="language_cnH-39">  #define MSG_LEVEL_BED                       "\xcf\xe0\xc4\xc7"</front>
<front id="language_cnH-40">  #define MSG_MOVE_X                          "\xc1\xb2 X"</front>
<front id="language_cnH-41">  #define MSG_MOVE_Y                          "\xc1\xb2 Y"</front>
<front id="language_cnH-42">  #define MSG_MOVE_Z                          "\xc1\xb2 Z"</front>
<front id="language_cnH-43">  #define MSG_MOVE_E                          "\xcc\xad\xba"</front>
<front id="language_cnH-44">  #define MSG_MOVE_01MM                       "\xc1\xb2 0.1mm"</front>
<front id="language_cnH-45">  #define MSG_MOVE_1MM                        "\xc1\xb2 1mm"</front>
<front id="language_cnH-46">  #define MSG_MOVE_10MM                       "\xc1\xb2 10mm"</front>
<front id="language_cnH-47">  #define MSG_SPEED                           "\xd1\xd2"</front>
<front id="language_cnH-48">  #define MSG_NOZZLE                          "\xd3\xd4"</front>
<front id="language_cnH-49">  #define MSG_BED                             "\xc4\xc7"</front>
<front id="language_cnH-50">  #define MSG_FAN_SPEED                       "\xd5\xd6\xd1\xd2"</front>
<front id="language_cnH-51">  #define MSG_FLOW                            "\xcc\xad\xd1\xd2"</front>
<front id="language_cnH-52">  #define MSG_CONTROL                         "\xd8\xd9"</front>
<front id="language_cnH-53">  #define MSG_MIN                             LCD_STR_THERMOMETER " \xda\xdb"</front>
<front id="language_cnH-54">  #define MSG_MAX                             LCD_STR_THERMOMETER " \xda\xdc"</front>
<front id="language_cnH-55">  #define MSG_FACTOR                          LCD_STR_THERMOMETER " \xdd\xde"</front>
<front id="language_cnH-56">  #define MSG_AUTOTEMP                        "\xb1\xb2\xd8\xc9"</front>
<front id="language_cnH-57">  #define MSG_ON                              "\xb3 "  // intentional space to shift wide symbol to the left</front>
<front id="language_cnH-58">  #define MSG_OFF                             "\xb5 "  // intentional space to shift wide symbol to the left</front>
<front id="language_cnH-59">  #define MSG_PID_P                           "PID-P"</front>
<front id="language_cnH-60">  #define MSG_PID_I                           "PID-I"</front>
<front id="language_cnH-61">  #define MSG_PID_D                           "PID-D"</front>
<front id="language_cnH-62">  #define MSG_PID_C                           "PID-C"</front>
<front id="language_cnH-63">  #define MSG_ACC                             "Accel"</front>
<front id="language_cnH-64">  #define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_cnH-65">  #define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_cnH-66">  #define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_cnH-67">  #define MSG_VMAX                            "Vmax "</front>
<front id="language_cnH-68">  #define MSG_X                               "x"</front>
<front id="language_cnH-69">  #define MSG_Y                               "y"</front>
<front id="language_cnH-70">  #define MSG_Z                               "z"</front>
<front id="language_cnH-71">  #define MSG_E                               "e"</front>
<front id="language_cnH-72">  #define MSG_VMIN                            "Vmin"</front>
<front id="language_cnH-73">  #define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_cnH-74">  #define MSG_AMAX                            "Amax "</front>
<front id="language_cnH-75">  #define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_cnH-76">  #define MSG_A_TRAVEL                        "A-travel"</front>
<front id="language_cnH-77">  #define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_cnH-78">  #define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_cnH-79">  #define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_cnH-80">  #define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_cnH-81">  #define MSG_TEMPERATURE                     "\xc9\xd2"</front>
<front id="language_cnH-82">  #define MSG_MOTION                          "\xdf\xb2"</front>
<front id="language_cnH-83">  #define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_cnH-84">  #define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_cnH-85">  #define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_cnH-86">  #define MSG_CONTRAST                        "LCD contrast"</front>
<front id="language_cnH-87">  #define MSG_STORE_EPROM                     "Store memory"</front>
<front id="language_cnH-88">  #define MSG_LOAD_EPROM                      "Load memory"</front>
<front id="language_cnH-89">  #define MSG_RESTORE_FAILSAFE                "Restore failsafe"</front>
<front id="language_cnH-90">  #define MSG_REFRESH                         "Refresh"</front>
<front id="language_cnH-91">  #define MSG_WATCH                           "\xec\xed\xee\xef"</front>
<front id="language_cnH-92">  #define MSG_PREPARE                         "\xa4\xa5"</front>
<front id="language_cnH-93">  #define MSG_TUNE                            "\xcf\xf0"</front>
<front id="language_cnH-94">  #define MSG_PAUSE_PRINT                     "\xf1\xf2\xca\xf3"</front>
<front id="language_cnH-95">  #define MSG_RESUME_PRINT                    "\xf4\xf5\xca\xf3"</front>
<front id="language_cnH-96">  #define MSG_STOP_PRINT                      "\xf2\xf6\xca\xf3"</front>
<front id="language_cnH-97">  #define MSG_CARD_MENU                       "\xaf\xb0"</front>
<front id="language_cnH-98">  #define MSG_NO_CARD                         "\xf9\xa8"</front>
<front id="language_cnH-99">  #define MSG_DWELL                           "Sleep..."</front>
<front id="language_cnH-100">  #define MSG_USERWAIT                        "Wait for user..."</front>
<front id="language_cnH-101">  #define MSG_RESUMING                        "Resuming print"</front>
<front id="language_cnH-102">  #define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_cnH-103">  #define MSG_NO_MOVE                         "No move."</front>
<front id="language_cnH-104">  #define MSG_KILLED                          "KILLED. "</front>
<front id="language_cnH-105">  #define MSG_STOPPED                         "STOPPED. "</front>
<front id="language_cnH-106">  #define MSG_CONTROL_RETRACT                 "Retract mm"</front>
<front id="language_cnH-107">  #define MSG_CONTROL_RETRACT_SWAP            "Swap Re.mm"</front>
<front id="language_cnH-108">  #define MSG_CONTROL_RETRACTF                "Retract  V"</front>
<front id="language_cnH-109">  #define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_cnH-110">  #define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_cnH-111">  #define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"</front>
<front id="language_cnH-112">  #define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_cnH-113">  #define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_cnH-114">  #define MSG_FILAMENTCHANGE                  "Change filament"</front>
<front id="language_cnH-115">  #define MSG_INIT_SDCARD                     "Init. SD card"</front>
<front id="language_cnH-116">  #define MSG_CNG_SDCARD                      "Change SD card"</front>
<front id="language_cnH-117">  #define MSG_ZPROBE_OUT                      "Z probe out. bed"</front>
<front id="language_cnH-118">  #define MSG_POSITION_UNKNOWN                "Home X/Y before Z"</front>
<front id="language_cnH-119">  #define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_cnH-120">  #define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_cnH-121">  #define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_cnH-122">  #define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_cnH-123">  #define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_cnH-124">  #define MSG_HEATING_FAILED_LCD              "Heating failed"</front>
<front id="language_cnH-125">  #define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP ERROR"</front>
<front id="language_cnH-126">  #define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"</front>
<front id="language_cnH-127">  #define MSG_ERR_MAXTEMP                     "Err: MAXTEMP"</front>
<front id="language_cnH-128">  #define MSG_ERR_MINTEMP                     "Err: MINTEMP"</front>
<front id="language_cnH-129">  #define MSG_ERR_MAXTEMP_BED                 "Err: MAXTEMP BED"</front>
<front id="language_cnH-130">  #define MSG_END_HOUR                        "hours"</front>
<front id="language_cnH-131">  #define MSG_END_MINUTE                      "minutes"</front>
<front id="language_cnH-132"></front>
<front id="language_cnH-133">  #if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_cnH-134">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_cnH-135">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_cnH-136">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_cnH-137">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_cnH-138">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_cnH-139">  #endif // DELTA_CALIBRATION_MENU</front>
<front id="language_cnH-140"></front>
<front id="language_cnH-141">#endif // LANGUAGE_CN_H</front>
<front id="language_cnH-142"></front>
 </pre>
<h1 id="language_czHtitle" >language_cz.h</h1>
<pre id="language_czH"  class="prettyprint linenums"><front id="language_czH-1">/**</front>
<front id="language_czH-2"> * Czech</front>
<front id="language_czH-3"> *</front>
<front id="language_czH-4"> * LCD Menu Messages</front>
<front id="language_czH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_czH-6"> *</front>
<front id="language_czH-7"> * Translated by Petr Zahradnik, Computer Laboratory</front>
<front id="language_czH-8"> * Blog and video blog Zahradnik se bavi</front>
<front id="language_czH-9"> * http://www.zahradniksebavi.cz</front>
<front id="language_czH-10"> *</front>
<front id="language_czH-11"> */</front>
<front id="language_czH-12">#ifndef LANGUAGE_CZ_H</front>
<front id="language_czH-13">#define LANGUAGE_CZ_H</front>
<front id="language_czH-14"></front>
<front id="language_czH-15">#define MAPPER_NON</front>
<front id="language_czH-16">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_czH-17">//#define SIMULATE_ROMFONT</front>
<front id="language_czH-18">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_czH-19"></front>
<front id="language_czH-20">#define WELCOME_MSG                         MACHINE_NAME " pripraven."</front>
<front id="language_czH-21">#define MSG_SD_INSERTED                     "Karta vlozena"</front>
<front id="language_czH-22">#define MSG_SD_REMOVED                      "Karta vyjmuta"</front>
<front id="language_czH-23">#define MSG_MAIN                            "Hlavni nabidka"</front>
<front id="language_czH-24">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_czH-25">#define MSG_DISABLE_STEPPERS                "Uvolnit motory"</front>
<front id="language_czH-26">#define MSG_AUTO_HOME                       "Domovska pozice"</front>
<front id="language_czH-27">#define MSG_SET_HOME_OFFSETS                "Nastavit ofsety"</front>
<front id="language_czH-28">#define MSG_SET_ORIGIN                      "Nastavit pocatek"</front>
<front id="language_czH-29">#define MSG_PREHEAT_PLA                     "Zahrat PLA"</front>
<front id="language_czH-30">#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "</front>
<front id="language_czH-31">#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " Vse"</front>
<front id="language_czH-32">#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Podloz"</front>
<front id="language_czH-33">#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " Nast"</front>
<front id="language_czH-34">#define MSG_PREHEAT_ABS                     "Zahrat ABS"</front>
<front id="language_czH-35">#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "</front>
<front id="language_czH-36">#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " Vse"</front>
<front id="language_czH-37">#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Podloz"</front>
<front id="language_czH-38">#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " Nast"</front>
<front id="language_czH-39">#define MSG_COOLDOWN                        "Zchladit"</front>
<front id="language_czH-40">#define MSG_SWITCH_PS_ON                    "Zapnout napajeni"</front>
<front id="language_czH-41">#define MSG_SWITCH_PS_OFF                   "Vypnout napajeni"</front>
<front id="language_czH-42">#define MSG_EXTRUDE                         "Vytlacit (extr.)"</front>
<front id="language_czH-43">#define MSG_RETRACT                         "Zatlacit (retr.)"</front>
<front id="language_czH-44">#define MSG_MOVE_AXIS                       "Posunout osy"</front>
<front id="language_czH-45">#define MSG_LEVEL_BED                       "Vyrovnat podlozku"</front>
<front id="language_czH-46">#define MSG_MOVE_X                          "Posunout X"</front>
<front id="language_czH-47">#define MSG_MOVE_Y                          "Posunout Y"</front>
<front id="language_czH-48">#define MSG_MOVE_Z                          "Posunout Z"</front>
<front id="language_czH-49">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_czH-50">#define MSG_MOVE_01MM                       "Posunout o 0,1mm"</front>
<front id="language_czH-51">#define MSG_MOVE_1MM                        "Posunout o 1mm"</front>
<front id="language_czH-52">#define MSG_MOVE_10MM                       "Posunout o 10mm"</front>
<front id="language_czH-53">#define MSG_SPEED                           "Rychlost"</front>
<front id="language_czH-54">#define MSG_NOZZLE                          "Tryska"</front>
<front id="language_czH-55">#define MSG_BED                             "Podlozka"</front>
<front id="language_czH-56">#define MSG_FAN_SPEED                       "Rychlost vent."</front>
<front id="language_czH-57">#define MSG_FLOW                            "Prutok"</front>
<front id="language_czH-58">#define MSG_CONTROL                         "Ovladani"</front>
<front id="language_czH-59">#define MSG_MIN                             " " LCD_STR_THERMOMETER " Min"</front>
<front id="language_czH-60">#define MSG_MAX                             " " LCD_STR_THERMOMETER " Max"</front>
<front id="language_czH-61">#define MSG_FACTOR                          " " LCD_STR_THERMOMETER " Fakt"</front>
<front id="language_czH-62">#define MSG_AUTOTEMP                        "Autoteplota"</front>
<front id="language_czH-63">#define MSG_ON                              "Zap"</front>
<front id="language_czH-64">#define MSG_OFF                             "Vyp"</front>
<front id="language_czH-65">#define MSG_PID_P                           "PID-P"</front>
<front id="language_czH-66">#define MSG_PID_I                           "PID-I"</front>
<front id="language_czH-67">#define MSG_PID_D                           "PID-D"</front>
<front id="language_czH-68">#define MSG_PID_C                           "PID-C"</front>
<front id="language_czH-69">#define MSG_ACC                             "Zrychl"</front>
<front id="language_czH-70">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_czH-71">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_czH-72">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_czH-73">#define MSG_VMAX                            "Vmax "</front>
<front id="language_czH-74">#define MSG_X                               "x"</front>
<front id="language_czH-75">#define MSG_Y                               "y"</front>
<front id="language_czH-76">#define MSG_Z                               "z"</front>
<front id="language_czH-77">#define MSG_E                               "e"</front>
<front id="language_czH-78">#define MSG_VMIN                            "Vmin"</front>
<front id="language_czH-79">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_czH-80">#define MSG_AMAX                            "Amax "</front>
<front id="language_czH-81">#define MSG_A_RETRACT                       "A-retrakt"</front>
<front id="language_czH-82">#define MSG_A_TRAVEL                        "A-prejezd"</front>
<front id="language_czH-83">#define MSG_XSTEPS                          "Xkroku/mm"</front>
<front id="language_czH-84">#define MSG_YSTEPS                          "Ykroku/mm"</front>
<front id="language_czH-85">#define MSG_ZSTEPS                          "Zkroku/mm"</front>
<front id="language_czH-86">#define MSG_ESTEPS                          "Ekroku/mm"</front>
<front id="language_czH-87">#define MSG_TEMPERATURE                     "Teplota"</front>
<front id="language_czH-88">#define MSG_MOTION                          "Pohyb"</front>
<front id="language_czH-89">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_czH-90">#define MSG_VOLUMETRIC_ENABLED              "E na mm3"</front>
<front id="language_czH-91">#define MSG_FILAMENT_DIAM                   "Fil. Prum."</front>
<front id="language_czH-92">#define MSG_CONTRAST                        "Kontrast LCD"</front>
<front id="language_czH-93">#define MSG_STORE_EPROM                     "Ulozit nastaveni"</front>
<front id="language_czH-94">#define MSG_LOAD_EPROM                      "Nacist nastaveni"</front>
<front id="language_czH-95">#define MSG_RESTORE_FAILSAFE                "Obnovit vychozi"</front>
<front id="language_czH-96">#define MSG_REFRESH                         "Obnovit"</front>
<front id="language_czH-97">#define MSG_WATCH                           "Info obrazovka"</front>
<front id="language_czH-98">#define MSG_PREPARE                         "Priprava tisku"</front>
<front id="language_czH-99">#define MSG_TUNE                            "Doladeni tisku"</front>
<front id="language_czH-100">#define MSG_PAUSE_PRINT                     "Pozastavit tisk"</front>
<front id="language_czH-101">#define MSG_RESUME_PRINT                    "Obnovit tisk"</front>
<front id="language_czH-102">#define MSG_STOP_PRINT                      "Zastavit tisk"</front>
<front id="language_czH-103">#define MSG_CARD_MENU                       "Tisknout z SD"</front>
<front id="language_czH-104">#define MSG_NO_CARD                         "Zadna SD karta"</front>
<front id="language_czH-105">#define MSG_DWELL                           "Uspano..."</front>
<front id="language_czH-106">#define MSG_USERWAIT                        "Cekani na uziv..."</front>
<front id="language_czH-107">#define MSG_RESUMING                        "Obnovovani tisku"</front>
<front id="language_czH-108">#define MSG_PRINT_ABORTED                   "Tisk zrusen"</front>
<front id="language_czH-109">#define MSG_NO_MOVE                         "Zadny pohyb."</front>
<front id="language_czH-110">#define MSG_KILLED                          "PRERUSENO. "</front>
<front id="language_czH-111">#define MSG_STOPPED                         "ZASTAVENO. "</front>
<front id="language_czH-112">#define MSG_CONTROL_RETRACT                 "Retrakt mm"</front>
<front id="language_czH-113">#define MSG_CONTROL_RETRACT_SWAP            "Vymena Re.mm"</front>
<front id="language_czH-114">#define MSG_CONTROL_RETRACTF                "Retraktovat  V"</front>
<front id="language_czH-115">#define MSG_CONTROL_RETRACT_ZLIFT           "Zvednuti Z mm"</front>
<front id="language_czH-116">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_czH-117">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"</front>
<front id="language_czH-118">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_czH-119">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_czH-120">#define MSG_FILAMENTCHANGE                  "Vymenit filament"</front>
<front id="language_czH-121">#define MSG_INIT_SDCARD                     "Nacist SD kartu"</front>
<front id="language_czH-122">#define MSG_CNG_SDCARD                      "Vymenit SD kartu"</front>
<front id="language_czH-123">#define MSG_ZPROBE_OUT                      "Sonda Z mimo podl"</front>
<front id="language_czH-124">#define MSG_POSITION_UNKNOWN                "Domu X/Y pred Z"</front>
<front id="language_czH-125">#define MSG_ZPROBE_ZOFFSET                  "Z ofset"</front>
<front id="language_czH-126">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_czH-127">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_czH-128">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_czH-129">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_czH-130">#define MSG_HEATING_FAILED_LCD              "Chyba zahrivani"</front>
<front id="language_czH-131">#define MSG_ERR_REDUNDANT_TEMP              "Chyba: REDUNDANTNI TEPLOTA"</front>
<front id="language_czH-132">#define MSG_THERMAL_RUNAWAY                 "TEPLOTNI SKOK"</front>
<front id="language_czH-133">#define MSG_ERR_MAXTEMP                     "Chyba: VYSOKA TEPLOTA"</front>
<front id="language_czH-134">#define MSG_ERR_MINTEMP                     "Chyba: NIZKA TEPLOTA"</front>
<front id="language_czH-135">#define MSG_ERR_MAXTEMP_BED                 "Chyba: VYSOKA TEPLOTA PODL."</front>
<front id="language_czH-136">#define MSG_ERR_MINTEMP_BED                 "Chyba: NIZKA TEPLOTA PODL."</front>
<front id="language_czH-137">#define MSG_END_HOUR                        "hod"</front>
<front id="language_czH-138">#define MSG_END_MINUTE                      "min"</front>
<front id="language_czH-139">#define MSG_HEATING                         "Zahrivani..."</front>
<front id="language_czH-140">#define MSG_HEATING_COMPLETE                "Zahrati hotovo."</front>
<front id="language_czH-141">#define MSG_BED_HEATING                     "Zahrivani podl."</front>
<front id="language_czH-142">#define MSG_BED_DONE                        "Podlozka hotova."</front>
<front id="language_czH-143"></front>
<front id="language_czH-144">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_czH-145">  #define MSG_DELTA_CALIBRATE             "Delta Kalibrace"</front>
<front id="language_czH-146">  #define MSG_DELTA_CALIBRATE_X           "Kalibrovat X"</front>
<front id="language_czH-147">  #define MSG_DELTA_CALIBRATE_Y           "Kalibrovat Y"</front>
<front id="language_czH-148">  #define MSG_DELTA_CALIBRATE_Z           "Kalibrovat Z"</front>
<front id="language_czH-149">  #define MSG_DELTA_CALIBRATE_CENTER      "Kalibrovat Stred"</front>
<front id="language_czH-150">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_czH-151"></front>
<front id="language_czH-152">#endif // LANGUAGE_CZ_H</front>
 </pre>
<h1 id="language_daHtitle" >language_da.h</h1>
<pre id="language_daH"  class="prettyprint linenums"><front id="language_daH-1">/**</front>
<front id="language_daH-2"> * Danish</front>
<front id="language_daH-3"> *</front>
<front id="language_daH-4"> * LCD Menu Messages</front>
<front id="language_daH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_daH-6"> *</front>
<front id="language_daH-7"> */</front>
<front id="language_daH-8">#ifndef LANGUAGE_DA_H</front>
<front id="language_daH-9">#define LANGUAGE_DA_H</front>
<front id="language_daH-10"></front>
<front id="language_daH-11">#define MAPPER_C2C3</front>
<front id="language_daH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_daH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_daH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_daH-15"></front>
<front id="language_daH-16">#define MSG_MAIN                            "Menu"</front>
<front id="language_daH-17">#define WELCOME_MSG                         MACHINE_NAME " er klar"</front>
<front id="language_daH-18">#define MSG_SD_INSERTED                     "Kort isat"</front>
<front id="language_daH-19">#define MSG_SD_REMOVED                      "Kort fjernet"</front>
<front id="language_daH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_daH-21">#define MSG_AUTO_HOME                       "Home" // G28</front>
<front id="language_daH-22">#define MSG_COOLDOWN                        "Afkl"</front>
<front id="language_daH-23">#define MSG_DISABLE_STEPPERS                "Sl stepper fra"</front>
<front id="language_daH-24">#define MSG_SET_HOME_OFFSETS                "St home offsets"</front>
<front id="language_daH-25">#define MSG_SET_ORIGIN                      "St origin"</front>
<front id="language_daH-26">#define MSG_SWITCH_PS_ON                    "Sl strm til"</front>
<front id="language_daH-27">#define MSG_SWITCH_PS_OFF                   "Sl strm fra"</front>
<front id="language_daH-28">#define MSG_PREHEAT_PLA                     "Forvarm PLA"</front>
<front id="language_daH-29">#define MSG_PREHEAT_PLA_N                   "Forvarm PLA "</front>
<front id="language_daH-30">#define MSG_PREHEAT_PLA_ALL                 "Forvarm PLA Alle"</front>
<front id="language_daH-31">#define MSG_PREHEAT_PLA_BEDONLY             "Forvarm PLA Bed"</front>
<front id="language_daH-32">#define MSG_PREHEAT_PLA_SETTINGS            "Forvarm PLA conf"</front>
<front id="language_daH-33">#define MSG_PREHEAT_ABS                     "Forvarm ABS"</front>
<front id="language_daH-34">#define MSG_PREHEAT_ABS_N                   "Forvarm ABS "</front>
<front id="language_daH-35">#define MSG_PREHEAT_ABS_ALL                 "Forvarm ABS Alle"</front>
<front id="language_daH-36">#define MSG_PREHEAT_ABS_BEDONLY             "Forvarm ABS Bed"</front>
<front id="language_daH-37">#define MSG_PREHEAT_ABS_SETTINGS            "Forvarm ABS conf"</front>
<front id="language_daH-38">#define MSG_EXTRUDE                         "Extruder"</front>
<front id="language_daH-39">#define MSG_RETRACT                         "Retract"</front>
<front id="language_daH-40">#define MSG_MOVE_AXIS                       "Flyt akser"</front>
<front id="language_daH-41">#define MSG_MOVE_X                          "Flyt X"</front>
<front id="language_daH-42">#define MSG_MOVE_Y                          "Flyt Y"</front>
<front id="language_daH-43">#define MSG_MOVE_Z                          "Flyt Z"</front>
<front id="language_daH-44">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_daH-45">#define MSG_MOVE_01MM                       "Flyt 0.1mm"</front>
<front id="language_daH-46">#define MSG_MOVE_1MM                        "Flyt 1mm"</front>
<front id="language_daH-47">#define MSG_MOVE_10MM                       "Flyt 10mm"</front>
<front id="language_daH-48">#define MSG_SPEED                           "Hastighed"</front>
<front id="language_daH-49">#define MSG_NOZZLE                          "Dyse"</front>
<front id="language_daH-50">#define MSG_NOZZLE1                         "Dyse2"</front>
<front id="language_daH-51">#define MSG_NOZZLE2                         "Dyse3"</front>
<front id="language_daH-52">#define MSG_BED                             "Plade"</front>
<front id="language_daH-53">#define MSG_FAN_SPEED                       "Blser hastighed"</front>
<front id="language_daH-54">#define MSG_FLOW                            "Flow"</front>
<front id="language_daH-55">#define MSG_CONTROL                         "Kontrol"</front>
<front id="language_daH-56">#define MSG_MIN                             " \002 Min"</front>
<front id="language_daH-57">#define MSG_MAX                             " \002 Max"</front>
<front id="language_daH-58">#define MSG_FACTOR                          " \002 Fact"</front>
<front id="language_daH-59">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_daH-60">#define MSG_ON                              "On "</front>
<front id="language_daH-61">#define MSG_OFF                             "Off"</front>
<front id="language_daH-62">#define MSG_PID_P                           "PID-P"</front>
<front id="language_daH-63">#define MSG_PID_I                           "PID-I"</front>
<front id="language_daH-64">#define MSG_PID_D                           "PID-D"</front>
<front id="language_daH-65">#define MSG_PID_C                           "PID-C"</front>
<front id="language_daH-66">#define MSG_ACC                             "Accel"</front>
<front id="language_daH-67">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_daH-68">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_daH-69">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_daH-70">#define MSG_VMAX                            "Vmax "</front>
<front id="language_daH-71">#define MSG_X                               "x"</front>
<front id="language_daH-72">#define MSG_Y                               "y"</front>
<front id="language_daH-73">#define MSG_Z                               "z"</front>
<front id="language_daH-74">#define MSG_E                               "e"</front>
<front id="language_daH-75">#define MSG_VMIN                            "Vmin"</front>
<front id="language_daH-76">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_daH-77">#define MSG_AMAX                            "Amax "</front>
<front id="language_daH-78">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_daH-79">#define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_daH-80">#define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_daH-81">#define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_daH-82">#define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_daH-83">#define MSG_TEMPERATURE                     "Temperatur"</front>
<front id="language_daH-84">#define MSG_MOTION                          "Motion"</front>
<front id="language_daH-85">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_daH-86">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_daH-87">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_daH-88">#define MSG_CONTRAST                        "LCD kontrast"</front>
<front id="language_daH-89">#define MSG_STORE_EPROM                     "Gem i EEPROM"</front>
<front id="language_daH-90">#define MSG_LOAD_EPROM                      "Hent fra EEPROM"</front>
<front id="language_daH-91">#define MSG_RESTORE_FAILSAFE                "Gendan failsafe"</front>
<front id="language_daH-92">#define MSG_REFRESH                         "Genopfrisk"</front>
<front id="language_daH-93">#define MSG_WATCH                           "Info skrm"</front>
<front id="language_daH-94">#define MSG_PREPARE                         "Forbered"</front>
<front id="language_daH-95">#define MSG_TUNE                            "Tune"</front>
<front id="language_daH-96">#define MSG_PAUSE_PRINT                     "Pause printet"</front>
<front id="language_daH-97">#define MSG_RESUME_PRINT                    "Forst printet"</front>
<front id="language_daH-98">#define MSG_STOP_PRINT                      "Stop printet"</front>
<front id="language_daH-99">#define MSG_CARD_MENU                       "Print fra SD"</front>
<front id="language_daH-100">#define MSG_NO_CARD                         "Intet SD kort"</front>
<front id="language_daH-101">#define MSG_DWELL                           "Dvale..."</front>
<front id="language_daH-102">#define MSG_USERWAIT                        "Venter p bruger..."</front>
<front id="language_daH-103">#define MSG_RESUMING                        "Forstter printet"</front>
<front id="language_daH-104">#define MSG_PRINT_ABORTED                   "Print annuleret"</front>
<front id="language_daH-105">#define MSG_NO_MOVE                         "No move."</front>
<front id="language_daH-106">#define MSG_KILLED                          "KILLED. "</front>
<front id="language_daH-107">#define MSG_STOPPED                         "STOPPED. "</front>
<front id="language_daH-108">#define MSG_CONTROL_RETRACT                 "Tilbagetraek mm"</front>
<front id="language_daH-109">#define MSG_CONTROL_RETRACT_SWAP            "Skift Re.mm"</front>
<front id="language_daH-110">#define MSG_CONTROL_RETRACTF                "Tilbagetrk V"</front>
<front id="language_daH-111">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_daH-112">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_daH-113">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"</front>
<front id="language_daH-114">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_daH-115">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_daH-116">#define MSG_ZPROBE_OUT                      "Probe udenfor plade"</front>
<front id="language_daH-117">#define MSG_FILAMENTCHANGE                  "Skift filament"</front>
<front id="language_daH-118">#define MSG_INIT_SDCARD                     "Init. SD card"</front>
<front id="language_daH-119">#define MSG_CNG_SDCARD                      "Skift SD kort"</front>
<front id="language_daH-120">#define MSG_POSITION_UNKNOWN                "Home X/Y fr Z"</front>
<front id="language_daH-121">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_daH-122">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_daH-123">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_daH-124">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_daH-125">#define MSG_END_HOUR                        "Timer"</front>
<front id="language_daH-126">#define MSG_END_MINUTE                      "Minutter"</front>
<front id="language_daH-127">#define MSG_HEATING                         "Opvarmer..."</front>
<front id="language_daH-128">#define MSG_HEATING_COMPLETE                "Opvarmet"</front>
<front id="language_daH-129">#define MSG_BED_HEATING                     "Opvarmer plade"</front>
<front id="language_daH-130">#define MSG_BED_DONE                        "Plade opvarmet"</front>
<front id="language_daH-131">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_daH-132"></front>
<front id="language_daH-133">#ifdef DELTA_CALIBRATION_MENU</front>
<front id="language_daH-134">    #define MSG_DELTA_CALIBRATE             "Delta Kalibrering"</front>
<front id="language_daH-135">    #define MSG_DELTA_CALIBRATE_X           "Kalibrer X"</front>
<front id="language_daH-136">    #define MSG_DELTA_CALIBRATE_Y           "Kalibrer Y"</front>
<front id="language_daH-137">    #define MSG_DELTA_CALIBRATE_Z           "Kalibrer Z"</front>
<front id="language_daH-138">    #define MSG_DELTA_CALIBRATE_CENTER      "Kalibrerings Center"</front>
<front id="language_daH-139">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_daH-140"></front>
<front id="language_daH-141">#endif // LANGUAGE_DA_H</front>
 </pre>
<h1 id="language_deHtitle" >language_de.h</h1>
<pre id="language_deH"  class="prettyprint linenums"><front id="language_deH-1">/**</front>
<front id="language_deH-2"> * German</front>
<front id="language_deH-3"> *</front>
<front id="language_deH-4"> * LCD Menu Messages</front>
<front id="language_deH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_deH-6"> *</front>
<front id="language_deH-7"> */</front>
<front id="language_deH-8">#ifndef LANGUAGE_DE_H</front>
<front id="language_deH-9">#define LANGUAGE_DE_H</front>
<front id="language_deH-10"></front>
<front id="language_deH-11">#define MAPPER_C2C3</front>
<front id="language_deH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_deH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_deH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_deH-15"></front>
<front id="language_deH-16">#define WELCOME_MSG                         MACHINE_NAME " bereit."</front>
<front id="language_deH-17">#define MSG_SD_INSERTED                     "SDKarte erkannt."</front>
<front id="language_deH-18">#define MSG_SD_REMOVED                      "SDKarte entfernt."</front>
<front id="language_deH-19">#define MSG_MAIN                            "Hauptmen"</front>
<front id="language_deH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_deH-21">#define MSG_DISABLE_STEPPERS                "Motoren Aus" // M84</front>
<front id="language_deH-22">#define MSG_AUTO_HOME                       "Home" // G28</front>
<front id="language_deH-23">#define MSG_SET_HOME_OFFSETS                "Setze Home hier"</front>
<front id="language_deH-24">#define MSG_SET_ORIGIN                      "Setze Null hier" //"G92 X0 Y0 Z0" commented out in ultralcd.cpp</front>
<front id="language_deH-25">#define MSG_PREHEAT_PLA                     "Vorwrmen PLA"</front>
<front id="language_deH-26">#define MSG_PREHEAT_PLA_N                   "Vorwrmen PLA "</front>
<front id="language_deH-27">#define MSG_PREHEAT_PLA_ALL                 "Vorw. PLA Alle"</front>
<front id="language_deH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Vorw. PLA Bett"</front>
<front id="language_deH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Vorwrm. PLA Ein."</front>
<front id="language_deH-30">#define MSG_PREHEAT_ABS                     "Vorwrmen ABS"</front>
<front id="language_deH-31">#define MSG_PREHEAT_ABS_N                   "Vorwrmen ABS "</front>
<front id="language_deH-32">#define MSG_PREHEAT_ABS_ALL                 "Vorw. ABS Alle"</front>
<front id="language_deH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Vorw. ABS Bett"</front>
<front id="language_deH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Vorwrm. ABS Ein."</front>
<front id="language_deH-35">#define MSG_COOLDOWN                        "Abkhlen"</front>
<front id="language_deH-36">#define MSG_SWITCH_PS_ON                    "Netzteil Ein"</front>
<front id="language_deH-37">#define MSG_SWITCH_PS_OFF                   "Netzteil Aus"</front>
<front id="language_deH-38">#define MSG_RETRACT                         "Retract"</front>
<front id="language_deH-39">#define MSG_MOVE_AXIS                       "Bewegen"</front>
<front id="language_deH-40">#define MSG_MOVE_X                          "X"</front>
<front id="language_deH-41">#define MSG_MOVE_Y                          "Y"</front>
<front id="language_deH-42">#define MSG_MOVE_Z                          "Z"</front>
<front id="language_deH-43">#define MSG_MOVE_E                          "E"</front>
<front id="language_deH-44">#define MSG_MOVE_01MM                       " 0.1 mm"</front>
<front id="language_deH-45">#define MSG_MOVE_1MM                        " 1.0 mm"</front>
<front id="language_deH-46">#define MSG_MOVE_10MM                       "10.0 mm"</front>
<front id="language_deH-47">#define MSG_SPEED                           "Geschw."</front>
<front id="language_deH-48">#define MSG_NOZZLE                          "Dse"</front>
<front id="language_deH-49">#define MSG_BED                             "Bett"</front>
<front id="language_deH-50">#define MSG_FAN_SPEED                       "Lftergeschw."</front>
<front id="language_deH-51">#define MSG_FLOW                            "Fluss"</front>
<front id="language_deH-52">#define MSG_CONTROL                         "Einstellungen"</front>
<front id="language_deH-53">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_deH-54">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_deH-55">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Faktor"</front>
<front id="language_deH-56">#define MSG_AUTOTEMP                        "AutoTemp"</front>
<front id="language_deH-57">#define MSG_ON                              "Ein"</front>
<front id="language_deH-58">#define MSG_OFF                             "Aus"</front>
<front id="language_deH-59">#define MSG_PID_P                           "PID P"</front>
<front id="language_deH-60">#define MSG_PID_I                           "PID I"</front>
<front id="language_deH-61">#define MSG_PID_D                           "PID D"</front>
<front id="language_deH-62">#define MSG_PID_C                           "PID C"</front>
<front id="language_deH-63">#define MSG_ACC                             "A"</front>
<front id="language_deH-64">#define MSG_VXY_JERK                        "V xy Ruck"</front>
<front id="language_deH-65">#define MSG_VZ_JERK                         "V z  Ruck"</front>
<front id="language_deH-66">#define MSG_VE_JERK                         "V e  Ruck"</front>
<front id="language_deH-67">#define MSG_VMAX                            "V max " // space by purpose</front>
<front id="language_deH-68">#define MSG_X                               "x"</front>
<front id="language_deH-69">#define MSG_Y                               "y"</front>
<front id="language_deH-70">#define MSG_Z                               "z"</front>
<front id="language_deH-71">#define MSG_E                               "e"</front>
<front id="language_deH-72">#define MSG_VMIN                            "V min"</front>
<front id="language_deH-73">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_deH-74">#define MSG_AMAX                            "A max " // space by purpose</front>
<front id="language_deH-75">#define MSG_A_RETRACT                       "A Retract"</front>
<front id="language_deH-76">#define MSG_XSTEPS                          "X steps/mm"</front>
<front id="language_deH-77">#define MSG_YSTEPS                          "Y steps/mm"</front>
<front id="language_deH-78">#define MSG_ZSTEPS                          "Z steps/mm"</front>
<front id="language_deH-79">#define MSG_ESTEPS                          "E steps/mm"</front>
<front id="language_deH-80">#define MSG_TEMPERATURE                     "Temperatur"</front>
<front id="language_deH-81">#define MSG_MOTION                          "Bewegung"</front>
<front id="language_deH-82">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_deH-83">#define MSG_VOLUMETRIC_ENABLED              "E in mm"</front>
<front id="language_deH-84">#define MSG_FILAMENT_DIAM                   "Filament D"</front>
<front id="language_deH-85">#define MSG_CONTRAST                        "LCD Kontrast"</front>
<front id="language_deH-86">#define MSG_STORE_EPROM                     "EPROM speichern"</front>
<front id="language_deH-87">#define MSG_LOAD_EPROM                      "EPROM laden"</front>
<front id="language_deH-88">#define MSG_RESTORE_FAILSAFE                "Standardkonfig."</front>
<front id="language_deH-89">#define MSG_REFRESH                         "Aktualisieren"</front>
<front id="language_deH-90">#define MSG_WATCH                           "Info"</front>
<front id="language_deH-91">#define MSG_PREPARE                         "Vorbereitung"</front>
<front id="language_deH-92">#define MSG_TUNE                            "Justierung"</front>
<front id="language_deH-93">#define MSG_PAUSE_PRINT                     "SD-Druck Pause"</front>
<front id="language_deH-94">#define MSG_RESUME_PRINT                    "SD-Druck Weiter"</front>
<front id="language_deH-95">#define MSG_STOP_PRINT                      "SD-Druck Abbruch"</front>
<front id="language_deH-96">#define MSG_CARD_MENU                       "SDKarte"</front>
<front id="language_deH-97">#define MSG_NO_CARD                         "Keine SDKarte"</front>
<front id="language_deH-98">#define MSG_DWELL                           "Warten..."</front>
<front id="language_deH-99">#define MSG_USERWAIT                        "Warte auf Nutzer."</front>
<front id="language_deH-100">#define MSG_RESUMING                        "Druck geht weiter"</front>
<front id="language_deH-101">#define MSG_PRINT_ABORTED                   "Druck abgebrochen"</front>
<front id="language_deH-102">#define MSG_NO_MOVE                         "Motoren Eingesch."</front>
<front id="language_deH-103">#define MSG_KILLED                          "KILLED."</front>
<front id="language_deH-104">#define MSG_STOPPED                         "ANGEHALTEN."</front>
<front id="language_deH-105">#define MSG_CONTROL_RETRACT                 "Retract mm"</front>
<front id="language_deH-106">#define MSG_CONTROL_RETRACT_SWAP            "Wechs. Retract mm"</front>
<front id="language_deH-107">#define MSG_CONTROL_RETRACTF                "Retract  V"</front>
<front id="language_deH-108">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_deH-109">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_deH-110">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Wechs. UnRet +mm"</front>
<front id="language_deH-111">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_deH-112">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_deH-113">#define MSG_FILAMENTCHANGE                  "Filament wechseln"</front>
<front id="language_deH-114">#define MSG_INIT_SDCARD                     "SDKarte erkennen"// Manually initialize the SD-card via user interface</front>
<front id="language_deH-115">#define MSG_CNG_SDCARD                      "SDKarte erkennen"// SD-card changed by user. For machines with no autocarddetect. Both send "M21"</front>
<front id="language_deH-116">#define MSG_ZPROBE_OUT                      "Sensor ausserhalb"</front>
<front id="language_deH-117">#define MSG_POSITION_UNKNOWN                "X/Y vor Z homen."</front>
<front id="language_deH-118">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_deH-119">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_deH-120">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_deH-121">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_deH-122">#define MSG_ENDSTOP_ABORT                   "Endstop Abbr. Ein"</front>
<front id="language_deH-123">#define MSG_END_HOUR                        "Stunden"</front>
<front id="language_deH-124">#define MSG_END_MINUTE                      "Minuten"</front>
<front id="language_deH-125">#define MSG_HEATING                         "Aufheizen..."</front>
<front id="language_deH-126">#define MSG_HEATING_COMPLETE                "Aufgeheizt"</front>
<front id="language_deH-127">#define MSG_BED_HEATING                     "Bett aufheizen"</front>
<front id="language_deH-128">#define MSG_BED_DONE                        "Bett aufgeheizt"</front>
<front id="language_deH-129"></front>
<front id="language_deH-130">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_deH-131">    #define MSG_DELTA_CALIBRATE             "Delta kalibrieren"</front>
<front id="language_deH-132">    #define MSG_DELTA_CALIBRATE_X           "Kalibriere X"</front>
<front id="language_deH-133">    #define MSG_DELTA_CALIBRATE_Y           "Kalibriere Y"</front>
<front id="language_deH-134">    #define MSG_DELTA_CALIBRATE_Z           "Kalibriere Z"</front>
<front id="language_deH-135">    #define MSG_DELTA_CALIBRATE_CENTER      "Kalibriere Mitte"</front>
<front id="language_deH-136">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_deH-137"></front>
<front id="language_deH-138">#endif // LANGUAGE_DE_H</front>
 </pre>
<h1 id="language_enHtitle" >language_en.h</h1>
<pre id="language_enH"  class="prettyprint linenums"><front id="language_enH-1">/**</front>
<front id="language_enH-2"> * English</front>
<front id="language_enH-3"> *</front>
<front id="language_enH-4"> * LCD Menu Messages</front>
<front id="language_enH-5"> * Se also documentation/LCDLanguageFont.md</front>
<front id="language_enH-6"> *</front>
<front id="language_enH-7"> */</front>
<front id="language_enH-8">#ifndef LANGUAGE_EN_H</front>
<front id="language_enH-9">#define LANGUAGE_EN_H</front>
<front id="language_enH-10"></front>
<front id="language_enH-11">#if DISABLED(MAPPER_NON) && DISABLED(MAPPER_C2C3) && DISABLED(MAPPER_D0D1) && DISABLED(MAPPER_D0D1_MOD) && DISABLED(MAPPER_E382E383)</front>
<front id="language_enH-12">  #define MAPPER_NON         // For direct asci codes</front>
<front id="language_enH-13">#endif</front>
<front id="language_enH-14"></front>
<front id="language_enH-15">//#define SIMULATE_ROMFONT //Comment in to see what is seen on the character based displays</front>
<front id="language_enH-16">#if DISABLED(SIMULATE_ROMFONT) && DISABLED(DISPLAY_CHARSET_ISO10646_1) && DISABLED(DISPLAY_CHARSET_ISO10646_5) && DISABLED(DISPLAY_CHARSET_ISO10646_KANA) && DISABLED(DISPLAY_CHARSET_ISO10646_CN)</front>
<front id="language_enH-17">  #define DISPLAY_CHARSET_ISO10646_1 // use the better font on full graphic displays.</front>
<front id="language_enH-18">#endif</front>
<front id="language_enH-19"></front>
<front id="language_enH-20"></front>
<front id="language_enH-21">#ifndef WELCOME_MSG</front>
<front id="language_enH-22">#define WELCOME_MSG                         MACHINE_NAME " ready."</front>
<front id="language_enH-23">#endif</front>
<front id="language_enH-24">#ifndef MSG_SD_INSERTED</front>
<front id="language_enH-25">#define MSG_SD_INSERTED                     "Card inserted"</front>
<front id="language_enH-26">#endif</front>
<front id="language_enH-27">#ifndef MSG_SD_REMOVED</front>
<front id="language_enH-28">#define MSG_SD_REMOVED                      "Card removed"</front>
<front id="language_enH-29">#endif</front>
<front id="language_enH-30">#ifndef MSG_MAIN</front>
<front id="language_enH-31">#define MSG_MAIN                            "Main"</front>
<front id="language_enH-32">#endif</front>
<front id="language_enH-33">#ifndef MSG_AUTOSTART</front>
<front id="language_enH-34">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_enH-35">#endif</front>
<front id="language_enH-36">#ifndef MSG_DISABLE_STEPPERS</front>
<front id="language_enH-37">#define MSG_DISABLE_STEPPERS                "Disable steppers"</front>
<front id="language_enH-38">#endif</front>
<front id="language_enH-39">#ifndef MSG_AUTO_HOME</front>
<front id="language_enH-40">#define MSG_AUTO_HOME                       "Auto home"</front>
<front id="language_enH-41">#endif</front>
<front id="language_enH-42">#ifndef MSG_SET_HOME_OFFSETS</front>
<front id="language_enH-43">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_enH-44">#endif</front>
<front id="language_enH-45">#ifndef MSG_SET_ORIGIN</front>
<front id="language_enH-46">#define MSG_SET_ORIGIN                      "Set origin"</front>
<front id="language_enH-47">#endif</front>
<front id="language_enH-48">#ifndef MSG_PREHEAT_PLA</front>
<front id="language_enH-49">#define MSG_PREHEAT_PLA                     "Preheat PLA"</front>
<front id="language_enH-50">#endif</front>
<front id="language_enH-51">#ifndef MSG_PREHEAT_PLA_N</front>
<front id="language_enH-52">#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "</front>
<front id="language_enH-53">#endif</front>
<front id="language_enH-54">#ifndef MSG_PREHEAT_PLA_ALL</front>
<front id="language_enH-55">#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " All"</front>
<front id="language_enH-56">#endif</front>
<front id="language_enH-57">#ifndef MSG_PREHEAT_PLA_BEDONLY</front>
<front id="language_enH-58">#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " Bed"</front>
<front id="language_enH-59">#endif</front>
<front id="language_enH-60">#ifndef MSG_PREHEAT_PLA_SETTINGS</front>
<front id="language_enH-61">#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " conf"</front>
<front id="language_enH-62">#endif</front>
<front id="language_enH-63">#ifndef MSG_PREHEAT_ABS</front>
<front id="language_enH-64">#define MSG_PREHEAT_ABS                     "Preheat ABS"</front>
<front id="language_enH-65">#endif</front>
<front id="language_enH-66">#ifndef MSG_PREHEAT_ABS_N</front>
<front id="language_enH-67">#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "</front>
<front id="language_enH-68">#endif</front>
<front id="language_enH-69">#ifndef MSG_PREHEAT_ABS_ALL</front>
<front id="language_enH-70">#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " All"</front>
<front id="language_enH-71">#endif</front>
<front id="language_enH-72">#ifndef MSG_PREHEAT_ABS_BEDONLY</front>
<front id="language_enH-73">#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " Bed"</front>
<front id="language_enH-74">#endif</front>
<front id="language_enH-75">#ifndef MSG_PREHEAT_ABS_SETTINGS</front>
<front id="language_enH-76">#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " conf"</front>
<front id="language_enH-77">#endif</front>
<front id="language_enH-78">#ifndef MSG_H1</front>
<front id="language_enH-79">#define MSG_H1                              "1"</front>
<front id="language_enH-80">#endif</front>
<front id="language_enH-81">#ifndef MSG_H2</front>
<front id="language_enH-82">#define MSG_H2                              "2"</front>
<front id="language_enH-83">#endif</front>
<front id="language_enH-84">#ifndef MSG_H3</front>
<front id="language_enH-85">#define MSG_H3                              "3"</front>
<front id="language_enH-86">#endif</front>
<front id="language_enH-87">#ifndef MSG_H4</front>
<front id="language_enH-88">#define MSG_H4                              "4"</front>
<front id="language_enH-89">#endif</front>
<front id="language_enH-90">#ifndef MSG_COOLDOWN</front>
<front id="language_enH-91">#define MSG_COOLDOWN                        "Cooldown"</front>
<front id="language_enH-92">#endif</front>
<front id="language_enH-93">#ifndef MSG_SWITCH_PS_ON</front>
<front id="language_enH-94">#define MSG_SWITCH_PS_ON                    "Switch power on"</front>
<front id="language_enH-95">#endif</front>
<front id="language_enH-96">#ifndef MSG_SWITCH_PS_OFF</front>
<front id="language_enH-97">#define MSG_SWITCH_PS_OFF                   "Switch power off"</front>
<front id="language_enH-98">#endif</front>
<front id="language_enH-99">#ifndef MSG_EXTRUDE</front>
<front id="language_enH-100">#define MSG_EXTRUDE                         "Extrude"</front>
<front id="language_enH-101">#endif</front>
<front id="language_enH-102">#ifndef MSG_RETRACT</front>
<front id="language_enH-103">#define MSG_RETRACT                         "Retract"</front>
<front id="language_enH-104">#endif</front>
<front id="language_enH-105">#ifndef MSG_MOVE_AXIS</front>
<front id="language_enH-106">#define MSG_MOVE_AXIS                       "Move axis"</front>
<front id="language_enH-107">#endif</front>
<front id="language_enH-108">#ifndef MSG_LEVEL_BED</front>
<front id="language_enH-109">#define MSG_LEVEL_BED                       "Level bed"</front>
<front id="language_enH-110">#endif</front>
<front id="language_enH-111">#ifndef MSG_MOVE_X</front>
<front id="language_enH-112">#define MSG_MOVE_X                          "Move X"</front>
<front id="language_enH-113">#endif</front>
<front id="language_enH-114">#ifndef MSG_MOVE_Y</front>
<front id="language_enH-115">#define MSG_MOVE_Y                          "Move Y"</front>
<front id="language_enH-116">#endif</front>
<front id="language_enH-117">#ifndef MSG_MOVE_Z</front>
<front id="language_enH-118">#define MSG_MOVE_Z                          "Move Z"</front>
<front id="language_enH-119">#endif</front>
<front id="language_enH-120">#ifndef MSG_MOVE_E</front>
<front id="language_enH-121">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_enH-122">#endif</front>
<front id="language_enH-123">#ifndef MSG_MOVE_E1</front>
<front id="language_enH-124">#define MSG_MOVE_E1                         "1"</front>
<front id="language_enH-125">#endif</front>
<front id="language_enH-126">#ifndef MSG_MOVE_E2</front>
<front id="language_enH-127">#define MSG_MOVE_E2                         "2"</front>
<front id="language_enH-128">#endif</front>
<front id="language_enH-129">#ifndef MSG_MOVE_E3</front>
<front id="language_enH-130">#define MSG_MOVE_E3                         "3"</front>
<front id="language_enH-131">#endif</front>
<front id="language_enH-132">#ifndef MSG_MOVE_E4</front>
<front id="language_enH-133">#define MSG_MOVE_E4                         "4"</front>
<front id="language_enH-134">#endif</front>
<front id="language_enH-135">#ifndef MSG_MOVE_01MM</front>
<front id="language_enH-136">#define MSG_MOVE_01MM                       "Move 0.1mm"</front>
<front id="language_enH-137">#endif</front>
<front id="language_enH-138">#ifndef MSG_MOVE_1MM</front>
<front id="language_enH-139">#define MSG_MOVE_1MM                        "Move 1mm"</front>
<front id="language_enH-140">#endif</front>
<front id="language_enH-141">#ifndef MSG_MOVE_10MM</front>
<front id="language_enH-142">#define MSG_MOVE_10MM                       "Move 10mm"</front>
<front id="language_enH-143">#endif</front>
<front id="language_enH-144">#ifndef MSG_SPEED</front>
<front id="language_enH-145">#define MSG_SPEED                           "Speed"</front>
<front id="language_enH-146">#endif</front>
<front id="language_enH-147">#ifndef MSG_NOZZLE</front>
<front id="language_enH-148">#define MSG_NOZZLE                          "Nozzle"</front>
<front id="language_enH-149">#endif</front>
<front id="language_enH-150">#ifndef MSG_N1</front>
<front id="language_enH-151">#define MSG_N1                              " 1"</front>
<front id="language_enH-152">#endif</front>
<front id="language_enH-153">#ifndef MSG_N2</front>
<front id="language_enH-154">#define MSG_N2                              " 2"</front>
<front id="language_enH-155">#endif</front>
<front id="language_enH-156">#ifndef MSG_N3</front>
<front id="language_enH-157">#define MSG_N3                              " 3"</front>
<front id="language_enH-158">#endif</front>
<front id="language_enH-159">#ifndef MSG_N4</front>
<front id="language_enH-160">#define MSG_N4                              " 4"</front>
<front id="language_enH-161">#endif</front>
<front id="language_enH-162">#ifndef MSG_BED</front>
<front id="language_enH-163">#define MSG_BED                             "Bed"</front>
<front id="language_enH-164">#endif</front>
<front id="language_enH-165">#ifndef MSG_FAN_SPEED</front>
<front id="language_enH-166">#define MSG_FAN_SPEED                       "Fan speed"</front>
<front id="language_enH-167">#endif</front>
<front id="language_enH-168">#ifndef MSG_FLOW</front>
<front id="language_enH-169">#define MSG_FLOW                            "Flow"</front>
<front id="language_enH-170">#endif</front>
<front id="language_enH-171">#ifndef MSG_LAYER</front>
<front id="language_enH-172">#define MSG_LAYER                           "Layer"</front>
<front id="language_enH-173">#endif</front>
<front id="language_enH-174">#ifndef MSG_F0</front>
<front id="language_enH-175">#define MSG_F0                              " 0"</front>
<front id="language_enH-176">#endif</front>
<front id="language_enH-177">#ifndef MSG_F1</front>
<front id="language_enH-178">#define MSG_F1                              " 1"</front>
<front id="language_enH-179">#endif</front>
<front id="language_enH-180">#ifndef MSG_F2</front>
<front id="language_enH-181">#define MSG_F2                              " 2"</front>
<front id="language_enH-182">#endif</front>
<front id="language_enH-183">#ifndef MSG_F3</front>
<front id="language_enH-184">#define MSG_F3                              " 3"</front>
<front id="language_enH-185">#endif</front>
<front id="language_enH-186">#ifndef MSG_CONTROL</front>
<front id="language_enH-187">#define MSG_CONTROL                         "Control"</front>
<front id="language_enH-188">#endif</front>
<front id="language_enH-189">#ifndef MSG_MIN</front>
<front id="language_enH-190">#define MSG_MIN                             " " LCD_STR_THERMOMETER " Min"</front>
<front id="language_enH-191">#endif</front>
<front id="language_enH-192">#ifndef MSG_MAX</front>
<front id="language_enH-193">#define MSG_MAX                             " " LCD_STR_THERMOMETER " Max"</front>
<front id="language_enH-194">#endif</front>
<front id="language_enH-195">#ifndef MSG_FACTOR</front>
<front id="language_enH-196">#define MSG_FACTOR                          " " LCD_STR_THERMOMETER " Fact"</front>
<front id="language_enH-197">#endif</front>
<front id="language_enH-198">#ifndef MSG_AUTOTEMP</front>
<front id="language_enH-199">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_enH-200">#endif</front>
<front id="language_enH-201">#ifndef MSG_ON</front>
<front id="language_enH-202">#define MSG_ON                              "On "</front>
<front id="language_enH-203">#endif</front>
<front id="language_enH-204">#ifndef MSG_OFF</front>
<front id="language_enH-205">#define MSG_OFF                             "Off"</front>
<front id="language_enH-206">#endif</front>
<front id="language_enH-207">#ifndef MSG_PID_P</front>
<front id="language_enH-208">#define MSG_PID_P                           "PID-P"</front>
<front id="language_enH-209">#endif</front>
<front id="language_enH-210">#ifndef MSG_PID_I</front>
<front id="language_enH-211">#define MSG_PID_I                           "PID-I"</front>
<front id="language_enH-212">#endif</front>
<front id="language_enH-213">#ifndef MSG_PID_D</front>
<front id="language_enH-214">#define MSG_PID_D                           "PID-D"</front>
<front id="language_enH-215">#endif</front>
<front id="language_enH-216">#ifndef MSG_PID_C</front>
<front id="language_enH-217">#define MSG_PID_C                           "PID-C"</front>
<front id="language_enH-218">#endif</front>
<front id="language_enH-219">#ifndef MSG_E1</front>
<front id="language_enH-220">#define MSG_E1                              " E1"</front>
<front id="language_enH-221">#endif</front>
<front id="language_enH-222">#ifndef MSG_E2</front>
<front id="language_enH-223">#define MSG_E2                              " E2"</front>
<front id="language_enH-224">#endif</front>
<front id="language_enH-225">#ifndef MSG_E3</front>
<front id="language_enH-226">#define MSG_E3                              " E3"</front>
<front id="language_enH-227">#endif</front>
<front id="language_enH-228">#ifndef MSG_E4</front>
<front id="language_enH-229">#define MSG_E4                              " E4"</front>
<front id="language_enH-230">#endif</front>
<front id="language_enH-231">#ifndef MSG_ACC</front>
<front id="language_enH-232">#define MSG_ACC                             "Accel"</front>
<front id="language_enH-233">#endif</front>
<front id="language_enH-234">#ifndef MSG_VXY_JERK</front>
<front id="language_enH-235">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_enH-236">#endif</front>
<front id="language_enH-237">#ifndef MSG_VZ_JERK</front>
<front id="language_enH-238">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_enH-239">#endif</front>
<front id="language_enH-240">#ifndef MSG_VE_JERK</front>
<front id="language_enH-241">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_enH-242">#endif</front>
<front id="language_enH-243">#ifndef MSG_VMAX</front>
<front id="language_enH-244">#define MSG_VMAX                            "Vmax "</front>
<front id="language_enH-245">#endif</front>
<front id="language_enH-246">#ifndef MSG_X</front>
<front id="language_enH-247">#define MSG_X                               "x"</front>
<front id="language_enH-248">#endif</front>
<front id="language_enH-249">#ifndef MSG_Y</front>
<front id="language_enH-250">#define MSG_Y                               "y"</front>
<front id="language_enH-251">#endif</front>
<front id="language_enH-252">#ifndef MSG_Z</front>
<front id="language_enH-253">#define MSG_Z                               "z"</front>
<front id="language_enH-254">#endif</front>
<front id="language_enH-255">#ifndef MSG_E</front>
<front id="language_enH-256">#define MSG_E                               "e"</front>
<front id="language_enH-257">#endif</front>
<front id="language_enH-258">#ifndef MSG_VMIN</front>
<front id="language_enH-259">#define MSG_VMIN                            "Vmin"</front>
<front id="language_enH-260">#endif</front>
<front id="language_enH-261">#ifndef MSG_VTRAV_MIN</front>
<front id="language_enH-262">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_enH-263">#endif</front>
<front id="language_enH-264">#ifndef MSG_AMAX</front>
<front id="language_enH-265">#define MSG_AMAX                            "Amax "</front>
<front id="language_enH-266">#endif</front>
<front id="language_enH-267">#ifndef MSG_A_RETRACT</front>
<front id="language_enH-268">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_enH-269">#endif</front>
<front id="language_enH-270">#ifndef MSG_A_TRAVEL</front>
<front id="language_enH-271">#define MSG_A_TRAVEL                        "A-travel"</front>
<front id="language_enH-272">#endif</front>
<front id="language_enH-273">#ifndef MSG_XSTEPS</front>
<front id="language_enH-274">#define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_enH-275">#endif</front>
<front id="language_enH-276">#ifndef MSG_YSTEPS</front>
<front id="language_enH-277">#define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_enH-278">#endif</front>
<front id="language_enH-279">#ifndef MSG_ZSTEPS</front>
<front id="language_enH-280">#define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_enH-281">#endif</front>
<front id="language_enH-282">#ifndef MSG_ESTEPS</front>
<front id="language_enH-283">#define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_enH-284">#endif</front>
<front id="language_enH-285">#ifndef MSG_TEMPERATURE</front>
<front id="language_enH-286">#define MSG_TEMPERATURE                     "Temperature"</front>
<front id="language_enH-287">#endif</front>
<front id="language_enH-288">#ifndef MSG_MOTION</front>
<front id="language_enH-289">#define MSG_MOTION                          "Motion"</front>
<front id="language_enH-290">#endif</front>
<front id="language_enH-291">#ifndef MSG_VOLUMETRIC</front>
<front id="language_enH-292">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_enH-293">#endif</front>
<front id="language_enH-294">#ifndef MSG_VOLUMETRIC_ENABLED</front>
<front id="language_enH-295">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_enH-296">#endif</front>
<front id="language_enH-297">#ifndef MSG_FILAMENT_DIAM</front>
<front id="language_enH-298">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_enH-299">#endif</front>
<front id="language_enH-300">#ifndef MSG_DIAM_E1</front>
<front id="language_enH-301">#define MSG_DIAM_E1                         " 1"</front>
<front id="language_enH-302">#endif</front>
<front id="language_enH-303">#ifndef MSG_DIAM_E2</front>
<front id="language_enH-304">#define MSG_DIAM_E2                         " 2"</front>
<front id="language_enH-305">#endif</front>
<front id="language_enH-306">#ifndef MSG_DIAM_E3</front>
<front id="language_enH-307">#define MSG_DIAM_E3                         " 3"</front>
<front id="language_enH-308">#endif</front>
<front id="language_enH-309">#ifndef MSG_DIAM_E4</front>
<front id="language_enH-310">#define MSG_DIAM_E4                         " 4"</front>
<front id="language_enH-311">#endif</front>
<front id="language_enH-312">#ifndef MSG_CONTRAST</front>
<front id="language_enH-313">#define MSG_CONTRAST                        "LCD contrast"</front>
<front id="language_enH-314">#endif</front>
<front id="language_enH-315">#ifndef MSG_STORE_EPROM</front>
<front id="language_enH-316">#define MSG_STORE_EPROM                     "Store memory"</front>
<front id="language_enH-317">#endif</front>
<front id="language_enH-318">#ifndef MSG_LOAD_EPROM</front>
<front id="language_enH-319">#define MSG_LOAD_EPROM                      "Load memory"</front>
<front id="language_enH-320">#endif</front>
<front id="language_enH-321">#ifndef MSG_RESTORE_FAILSAFE</front>
<front id="language_enH-322">#define MSG_RESTORE_FAILSAFE                "Restore failsafe"</front>
<front id="language_enH-323">#endif</front>
<front id="language_enH-324">#ifndef MSG_REFRESH</front>
<front id="language_enH-325">#define MSG_REFRESH                         "Refresh"</front>
<front id="language_enH-326">#endif</front>
<front id="language_enH-327">#ifndef MSG_WATCH</front>
<front id="language_enH-328">#define MSG_WATCH                           "Info screen"</front>
<front id="language_enH-329">#endif</front>
<front id="language_enH-330">#ifndef MSG_PREPARE</front>
<front id="language_enH-331">#define MSG_PREPARE                         "Prepare"</front>
<front id="language_enH-332">#endif</front>
<front id="language_enH-333">#ifndef MSG_TUNE</front>
<front id="language_enH-334">#define MSG_TUNE                            "Tune"</front>
<front id="language_enH-335">#endif</front>
<front id="language_enH-336">#ifndef MSG_PAUSE_PRINT</front>
<front id="language_enH-337">#define MSG_PAUSE_PRINT                     "Pause print"</front>
<front id="language_enH-338">#endif</front>
<front id="language_enH-339">#ifndef MSG_CARD_RESUME_MENU</front>
<front id="language_enH-340">#define MSG_CARD_RESUME_MENU                "Resume SD from Z"</front>
<front id="language_enH-341">#endif</front>
<front id="language_enH-342">#ifndef MSG_RESUME_PRINT</front>
<front id="language_enH-343">#define MSG_RESUME_PRINT                    "Resume print"</front>
<front id="language_enH-344">#endif</front>
<front id="language_enH-345">#ifndef MSG_STOP_PRINT</front>
<front id="language_enH-346">#define MSG_STOP_PRINT                      "Stop print"</front>
<front id="language_enH-347">#endif</front>
<front id="language_enH-348">#ifndef MSG_CARD_MENU</front>
<front id="language_enH-349">#define MSG_CARD_MENU                       "Print from SD"</front>
<front id="language_enH-350">#endif</front>
<front id="language_enH-351">#ifndef MSG_NO_CARD</front>
<front id="language_enH-352">#define MSG_NO_CARD                         "No SD card"</front>
<front id="language_enH-353">#endif</front>
<front id="language_enH-354">#ifndef MSG_DWELL</front>
<front id="language_enH-355">#define MSG_DWELL                           "Sleep..."</front>
<front id="language_enH-356">#endif</front>
<front id="language_enH-357">#ifndef MSG_USERWAIT</front>
<front id="language_enH-358">#define MSG_USERWAIT                        "Wait for user..."</front>
<front id="language_enH-359">#endif</front>
<front id="language_enH-360">#ifndef MSG_RESUMING</front>
<front id="language_enH-361">#define MSG_RESUMING                        "Resuming print"</front>
<front id="language_enH-362">#endif</front>
<front id="language_enH-363">#ifndef MSG_PRINT_ABORTED</front>
<front id="language_enH-364">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_enH-365">#endif</front>
<front id="language_enH-366">#ifndef MSG_NO_MOVE</front>
<front id="language_enH-367">#define MSG_NO_MOVE                         "No move."</front>
<front id="language_enH-368">#endif</front>
<front id="language_enH-369">#ifndef MSG_KILLED</front>
<front id="language_enH-370">#define MSG_KILLED                          "KILLED. "</front>
<front id="language_enH-371">#endif</front>
<front id="language_enH-372">#ifndef MSG_STOPPED</front>
<front id="language_enH-373">#define MSG_STOPPED                         "STOPPED. "</front>
<front id="language_enH-374">#endif</front>
<front id="language_enH-375">#ifndef MSG_CONTROL_RETRACT</front>
<front id="language_enH-376">#define MSG_CONTROL_RETRACT                 "Retract mm"</front>
<front id="language_enH-377">#endif</front>
<front id="language_enH-378">#ifndef MSG_CONTROL_RETRACT_SWAP</front>
<front id="language_enH-379">#define MSG_CONTROL_RETRACT_SWAP            "Swap Re.mm"</front>
<front id="language_enH-380">#endif</front>
<front id="language_enH-381">#ifndef MSG_CONTROL_RETRACTF</front>
<front id="language_enH-382">#define MSG_CONTROL_RETRACTF                "Retract  V"</front>
<front id="language_enH-383">#endif</front>
<front id="language_enH-384">#ifndef MSG_CONTROL_RETRACT_ZLIFT</front>
<front id="language_enH-385">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_enH-386">#endif</front>
<front id="language_enH-387">#ifndef MSG_CONTROL_RETRACT_RECOVER</front>
<front id="language_enH-388">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_enH-389">#endif</front>
<front id="language_enH-390">#ifndef MSG_CONTROL_RETRACT_RECOVER_SWAP</front>
<front id="language_enH-391">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"</front>
<front id="language_enH-392">#endif</front>
<front id="language_enH-393">#ifndef MSG_CONTROL_RETRACT_RECOVERF</front>
<front id="language_enH-394">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_enH-395">#endif</front>
<front id="language_enH-396">#ifndef MSG_AUTORETRACT</front>
<front id="language_enH-397">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_enH-398">#endif</front>
<front id="language_enH-399">#ifndef MSG_FILAMENTCHANGE</front>
<front id="language_enH-400">#define MSG_FILAMENTCHANGE                  "Change filament"</front>
<front id="language_enH-401">#endif</front>
<front id="language_enH-402">#ifndef MSG_INIT_SDCARD</front>
<front id="language_enH-403">#define MSG_INIT_SDCARD                     "Init. SD card"</front>
<front id="language_enH-404">#endif</front>
<front id="language_enH-405">#ifndef MSG_CNG_SDCARD</front>
<front id="language_enH-406">#define MSG_CNG_SDCARD                      "Change SD card"</front>
<front id="language_enH-407">#endif</front>
<front id="language_enH-408">#ifndef MSG_ZPROBE_OUT</front>
<front id="language_enH-409">#define MSG_ZPROBE_OUT                      "Z probe out. bed"</front>
<front id="language_enH-410">#endif</front>
<front id="language_enH-411">#ifndef MSG_POSITION_UNKNOWN</front>
<front id="language_enH-412">#define MSG_POSITION_UNKNOWN                "Home X/Y before Z"</front>
<front id="language_enH-413">#endif</front>
<front id="language_enH-414">#ifndef MSG_ZPROBE_ZOFFSET</front>
<front id="language_enH-415">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_enH-416">#endif</front>
<front id="language_enH-417">#ifndef MSG_BABYSTEP_X</front>
<front id="language_enH-418">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_enH-419">#endif</front>
<front id="language_enH-420">#ifndef MSG_BABYSTEP_Y</front>
<front id="language_enH-421">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_enH-422">#endif</front>
<front id="language_enH-423">#ifndef MSG_BABYSTEP_Z</front>
<front id="language_enH-424">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_enH-425">#endif</front>
<front id="language_enH-426">#ifndef MSG_ENDSTOP_ABORT</front>
<front id="language_enH-427">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_enH-428">#endif</front>
<front id="language_enH-429">#ifndef MSG_HEATING_FAILED_LCD</front>
<front id="language_enH-430">#define MSG_HEATING_FAILED_LCD              "Heating failed"</front>
<front id="language_enH-431">#endif</front>
<front id="language_enH-432">#ifndef MSG_ERR_REDUNDANT_TEMP</front>
<front id="language_enH-433">#define MSG_ERR_REDUNDANT_TEMP              "Err: REDUNDANT TEMP ERROR"</front>
<front id="language_enH-434">#endif</front>
<front id="language_enH-435">#ifndef MSG_THERMAL_RUNAWAY</front>
<front id="language_enH-436">#define MSG_THERMAL_RUNAWAY                 "THERMAL RUNAWAY"</front>
<front id="language_enH-437">#endif</front>
<front id="language_enH-438">#ifndef MSG_ERR_MAXTEMP</front>
<front id="language_enH-439">#define MSG_ERR_MAXTEMP                     "Err: MAXTEMP"</front>
<front id="language_enH-440">#endif</front>
<front id="language_enH-441">#ifndef MSG_ERR_MINTEMP</front>
<front id="language_enH-442">#define MSG_ERR_MINTEMP                     "Err: MINTEMP"</front>
<front id="language_enH-443">#endif</front>
<front id="language_enH-444">#ifndef MSG_ERR_MAXTEMP_BED</front>
<front id="language_enH-445">#define MSG_ERR_MAXTEMP_BED                 "Err: MAXTEMP BED"</front>
<front id="language_enH-446">#endif</front>
<front id="language_enH-447">#ifndef MSG_ERR_MINTEMP_BED</front>
<front id="language_enH-448">#define MSG_ERR_MINTEMP_BED                 "Err: MINTEMP BED"</front>
<front id="language_enH-449">#endif</front>
<front id="language_enH-450">#ifndef MSG_END_HOUR</front>
<front id="language_enH-451">#define MSG_END_HOUR                        "hours"</front>
<front id="language_enH-452">#endif</front>
<front id="language_enH-453">#ifndef MSG_END_MINUTE</front>
<front id="language_enH-454">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_enH-455">#endif</front>
<front id="language_enH-456">#ifndef MSG_HEATING</front>
<front id="language_enH-457">#define MSG_HEATING                         "Heating..."</front>
<front id="language_enH-458">#endif</front>
<front id="language_enH-459">#ifndef MSG_HEATING_COMPLETE</front>
<front id="language_enH-460">#define MSG_HEATING_COMPLETE                "Heating done."</front>
<front id="language_enH-461">#endif</front>
<front id="language_enH-462">#ifndef MSG_BED_HEATING</front>
<front id="language_enH-463">#define MSG_BED_HEATING                     "Bed Heating."</front>
<front id="language_enH-464">#endif</front>
<front id="language_enH-465">#ifndef MSG_BED_DONE</front>
<front id="language_enH-466">#define MSG_BED_DONE                        "Bed done."</front>
<front id="language_enH-467">#endif</front>
<front id="language_enH-468"></front>
<front id="language_enH-469">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_enH-470">  #ifndef MSG_DELTA_CALIBRATE</front>
<front id="language_enH-471">  #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_enH-472">  #endif</front>
<front id="language_enH-473">  #ifndef MSG_DELTA_CALIBRATE_X</front>
<front id="language_enH-474">  #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_enH-475">  #endif</front>
<front id="language_enH-476">  #ifndef MSG_DELTA_CALIBRATE_Y</front>
<front id="language_enH-477">  #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_enH-478">  #endif</front>
<front id="language_enH-479">  #ifndef MSG_DELTA_CALIBRATE_Z</front>
<front id="language_enH-480">  #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_enH-481">  #endif</front>
<front id="language_enH-482">  #ifndef MSG_DELTA_CALIBRATE_CENTER</front>
<front id="language_enH-483">  #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_enH-484">  #endif</front>
<front id="language_enH-485">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_enH-486"></front>
<front id="language_enH-487">#endif // LANGUAGE_EN_H</front>
 </pre>
<h1 id="language_esHtitle" >language_es.h</h1>
<pre id="language_esH"  class="prettyprint linenums"><front id="language_esH-1">/**</front>
<front id="language_esH-2"> * Spanish</front>
<front id="language_esH-3"> *</front>
<front id="language_esH-4"> * LCD Menu Messages</front>
<front id="language_esH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_esH-6"> *</front>
<front id="language_esH-7"> */</front>
<front id="language_esH-8">#ifndef LANGUAGE_ES_H</front>
<front id="language_esH-9">#define LANGUAGE_ES_H</front>
<front id="language_esH-10"></front>
<front id="language_esH-11">#define MAPPER_NON</front>
<front id="language_esH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_esH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_esH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_esH-15"></front>
<front id="language_esH-16">#define WELCOME_MSG                         MACHINE_NAME " lista."</front>
<front id="language_esH-17">#define MSG_SD_INSERTED                     "Tarjeta colocada"</front>
<front id="language_esH-18">#define MSG_SD_REMOVED                      "Tarjeta retirada"</front>
<front id="language_esH-19">#define MSG_MAIN                            "Menu principal"</front>
<front id="language_esH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_esH-21">#define MSG_DISABLE_STEPPERS                "Apagar motores"</front>
<front id="language_esH-22">#define MSG_AUTO_HOME                       "Llevar al origen"</front>
<front id="language_esH-23">#define MSG_SET_HOME_OFFSETS                "Ajustar offsets"</front>
<front id="language_esH-24">#define MSG_SET_ORIGIN                      "Establecer cero"</front>
<front id="language_esH-25">#define MSG_PREHEAT_PLA                     "Precalentar PLA"</front>
<front id="language_esH-26">#define MSG_PREHEAT_PLA_N                   "Precalentar PLA "</front>
<front id="language_esH-27">#define MSG_PREHEAT_PLA_ALL                 "Precal. PLA Todo"</front>
<front id="language_esH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Precal. PLA Base"</front>
<front id="language_esH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Ajustar temp. PLA"</front>
<front id="language_esH-30">#define MSG_PREHEAT_ABS                     "Precalentar ABS"</front>
<front id="language_esH-31">#define MSG_PREHEAT_ABS_N                   "Precalentar ABS "</front>
<front id="language_esH-32">#define MSG_PREHEAT_ABS_ALL                 "Precal. ABS Todo"</front>
<front id="language_esH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Precal. ABS Base"</front>
<front id="language_esH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Ajustar temp. ABS"</front>
<front id="language_esH-35">#define MSG_COOLDOWN                        "Enfriar"</front>
<front id="language_esH-36">#define MSG_SWITCH_PS_ON                    "Encender"</front>
<front id="language_esH-37">#define MSG_SWITCH_PS_OFF                   "Apagar"</front>
<front id="language_esH-38">#define MSG_EXTRUDE                         "Extruir"</front>
<front id="language_esH-39">#define MSG_RETRACT                         "Retraer"</front>
<front id="language_esH-40">#define MSG_MOVE_AXIS                       "Mover ejes"</front>
<front id="language_esH-41">#define MSG_MOVE_X                          "Mover X"</front>
<front id="language_esH-42">#define MSG_MOVE_Y                          "Mover Y"</front>
<front id="language_esH-43">#define MSG_MOVE_Z                          "Mover Z"</front>
<front id="language_esH-44">#define MSG_MOVE_E                          "Extrusor"</front>
<front id="language_esH-45">#define MSG_MOVE_01MM                       "Mover 0.1mm"</front>
<front id="language_esH-46">#define MSG_MOVE_1MM                        "Mover 1mm"</front>
<front id="language_esH-47">#define MSG_MOVE_10MM                       "Mover 10mm"</front>
<front id="language_esH-48">#define MSG_SPEED                           "Velocidad"</front>
<front id="language_esH-49">#define MSG_NOZZLE                          "Fusor"</front>
<front id="language_esH-50">#define MSG_BED                             "Base"</front>
<front id="language_esH-51">#define MSG_FAN_SPEED                       "Ventilador"</front>
<front id="language_esH-52">#define MSG_FLOW                            "Flujo"</front>
<front id="language_esH-53">#define MSG_CONTROL                         "Control"</front>
<front id="language_esH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_esH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_esH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_esH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_esH-58">#define MSG_ON                              "On"</front>
<front id="language_esH-59">#define MSG_OFF                             "Off"</front>
<front id="language_esH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_esH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_esH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_esH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_esH-64">#define MSG_ACC                             "Acel"</front>
<front id="language_esH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_esH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_esH-67">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_esH-68">#define MSG_VMAX                            "Vmax"</front>
<front id="language_esH-69">#define MSG_X                               "x"</front>
<front id="language_esH-70">#define MSG_Y                               "y"</front>
<front id="language_esH-71">#define MSG_Z                               "z"</front>
<front id="language_esH-72">#define MSG_E                               "e"</front>
<front id="language_esH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_esH-74">#define MSG_VTRAV_MIN                       "Vvacio min"</front>
<front id="language_esH-75">#define MSG_AMAX                            "Amax"</front>
<front id="language_esH-76">#define MSG_A_RETRACT                       "A-retrac."</front>
<front id="language_esH-77">#define MSG_XSTEPS                          "X pasos/mm"</front>
<front id="language_esH-78">#define MSG_YSTEPS                          "Y pasos/mm"</front>
<front id="language_esH-79">#define MSG_ZSTEPS                          "Z pasos/mm"</front>
<front id="language_esH-80">#define MSG_ESTEPS                          "E pasos/mm"</front>
<front id="language_esH-81">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_esH-82">#define MSG_MOTION                          "Movimiento"</front>
<front id="language_esH-83">#define MSG_VOLUMETRIC                      "Filamento"</front>
<front id="language_esH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_esH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_esH-86">#define MSG_CONTRAST                        "Contraste"</front>
<front id="language_esH-87">#define MSG_STORE_EPROM                     "Guardar memoria"</front>
<front id="language_esH-88">#define MSG_LOAD_EPROM                      "Cargar memoria"</front>
<front id="language_esH-89">#define MSG_RESTORE_FAILSAFE                "Rest. de emergen."</front>
<front id="language_esH-90">#define MSG_REFRESH                         "Volver a cargar"</front>
<front id="language_esH-91">#define MSG_WATCH                           "Monitorizar"</front>
<front id="language_esH-92">#define MSG_PREPARE                         "Preparar"</front>
<front id="language_esH-93">#define MSG_TUNE                            "Ajustar"</front>
<front id="language_esH-94">#define MSG_PAUSE_PRINT                     "Pausar impresion"</front>
<front id="language_esH-95">#define MSG_RESUME_PRINT                    "Reanudar impres."</front>
<front id="language_esH-96">#define MSG_STOP_PRINT                      "Detener impresion"</front>
<front id="language_esH-97">#define MSG_CARD_MENU                       "Menu de SD"</front>
<front id="language_esH-98">#define MSG_NO_CARD                         "No hay tarjeta SD"</front>
<front id="language_esH-99">#define MSG_DWELL                           "Reposo..."</front>
<front id="language_esH-100">#define MSG_USERWAIT                        "Esperando ordenes"</front>
<front id="language_esH-101">#define MSG_RESUMING                        "Resumiendo impre."</front>
<front id="language_esH-102">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_esH-103">#define MSG_NO_MOVE                         "Sin movimiento"</front>
<front id="language_esH-104">#define MSG_KILLED                          "PARADA DE EMERG."</front>
<front id="language_esH-105">#define MSG_STOPPED                         "PARADA"</front>
<front id="language_esH-106">#define MSG_CONTROL_RETRACT                 "Retraer mm"</front>
<front id="language_esH-107">#define MSG_CONTROL_RETRACT_SWAP            "Interc. Retraer mm"</front>
<front id="language_esH-108">#define MSG_CONTROL_RETRACTF                "Retraer  V"</front>
<front id="language_esH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Levantar mm"</front>
<front id="language_esH-110">#define MSG_CONTROL_RETRACT_RECOVER         "DesRet +mm"</front>
<front id="language_esH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Interc. DesRet +mm"</front>
<front id="language_esH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "DesRet V"</front>
<front id="language_esH-113">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_esH-114">#define MSG_FILAMENTCHANGE                  "Cambiar filamento"</front>
<front id="language_esH-115">#define MSG_INIT_SDCARD                     "Iniciando tarjeta"</front>
<front id="language_esH-116">#define MSG_CNG_SDCARD                      "Cambiar tarjeta"</front>
<front id="language_esH-117">#define MSG_ZPROBE_OUT                      "Sonda Z fuera"</front>
<front id="language_esH-118">#define MSG_POSITION_UNKNOWN                "Reiniciar X/Y y Z"</front>
<front id="language_esH-119">#define MSG_ZPROBE_ZOFFSET                  "Offset Z"</front>
<front id="language_esH-120">#define MSG_BABYSTEP_X                      "Micropaso X"</front>
<front id="language_esH-121">#define MSG_BABYSTEP_Y                      "Micropaso Y"</front>
<front id="language_esH-122">#define MSG_BABYSTEP_Z                      "Micropaso Z"</front>
<front id="language_esH-123">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_esH-124">#define MSG_END_HOUR                        "horas"</front>
<front id="language_esH-125">#define MSG_END_MINUTE                      "minutos"</front>
<front id="language_esH-126"></front>
<front id="language_esH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_esH-128">    #define MSG_DELTA_CALIBRATE             "Calibracion Delta"</front>
<front id="language_esH-129">    #define MSG_DELTA_CALIBRATE_X           "Calibrar X"</front>
<front id="language_esH-130">    #define MSG_DELTA_CALIBRATE_Y           "Calibrar Y"</front>
<front id="language_esH-131">    #define MSG_DELTA_CALIBRATE_Z           "Calibrar Z"</front>
<front id="language_esH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrar Centro"</front>
<front id="language_esH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_esH-134"></front>
<front id="language_esH-135">#endif // LANGUAGE_ES_H</front>
 </pre>
<h1 id="language_euHtitle" >language_eu.h</h1>
<pre id="language_euH"  class="prettyprint linenums"><front id="language_euH-1">/**</front>
<front id="language_euH-2"> * Basque-Euskera</front>
<front id="language_euH-3"> *</front>
<front id="language_euH-4"> * LCD Menu Messages</front>
<front id="language_euH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_euH-6"> *</front>
<front id="language_euH-7"> */</front>
<front id="language_euH-8">#ifndef LANGUAGE_EU_H</front>
<front id="language_euH-9">#define LANGUAGE_EU_H</front>
<front id="language_euH-10"></front>
<front id="language_euH-11">#define MAPPER_NON</front>
<front id="language_euH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_euH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_euH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_euH-15"></front>
<front id="language_euH-16">#define WELCOME_MSG                         MACHINE_NAME " prest."</front>
<front id="language_euH-17">#define MSG_SD_INSERTED                     "Txartela sartuta"</front>
<front id="language_euH-18">#define MSG_SD_REMOVED                      "Txartela kenduta"</front>
<front id="language_euH-19">#define MSG_MAIN                            "Menu nagusia"</front>
<front id="language_euH-20">#define MSG_AUTOSTART                       "Auto hasiera"</front>
<front id="language_euH-21">#define MSG_DISABLE_STEPPERS                "Itzali motoreak"</front>
<front id="language_euH-22">#define MSG_AUTO_HOME                       "Hasierara joan"</front>
<front id="language_euH-23">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_euH-24">#define MSG_SET_ORIGIN                      "Hasiera ipini"</front>
<front id="language_euH-25">#define MSG_PREHEAT_PLA                     "Aurreberotu PLA"</front>
<front id="language_euH-26">#define MSG_PREHEAT_PLA_N                   "Aurreberotu PLA "</front>
<front id="language_euH-27">#define MSG_PREHEAT_PLA_ALL                 "Berotu PLA Guztia"</front>
<front id="language_euH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Berotu PLA Ohea"</front>
<front id="language_euH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Berotu PLA Konfig"</front>
<front id="language_euH-30">#define MSG_PREHEAT_ABS                     "Aurreberotu ABS"</front>
<front id="language_euH-31">#define MSG_PREHEAT_ABS_N                   "Aurreberotu ABS "</front>
<front id="language_euH-32">#define MSG_PREHEAT_ABS_ALL                 "Berotu ABS Guztia"</front>
<front id="language_euH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Berotu ABS Ohea"</front>
<front id="language_euH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Berotu ABS Konfig"</front>
<front id="language_euH-35">#define MSG_COOLDOWN                        "Hoztu"</front>
<front id="language_euH-36">#define MSG_SWITCH_PS_ON                    "Energia piztu"</front>
<front id="language_euH-37">#define MSG_SWITCH_PS_OFF                   "Energia itzali"</front>
<front id="language_euH-38">#define MSG_EXTRUDE                         "Estruitu"</front>
<front id="language_euH-39">#define MSG_RETRACT                         "Atzera eragin"</front>
<front id="language_euH-40">#define MSG_MOVE_AXIS                       "Ardatzak mugitu"</front>
<front id="language_euH-41">#define MSG_MOVE_X                          "Mugitu X"</front>
<front id="language_euH-42">#define MSG_MOVE_Y                          "Mugitu Y"</front>
<front id="language_euH-43">#define MSG_MOVE_Z                          "Mugitu Z"</front>
<front id="language_euH-44">#define MSG_MOVE_E                          "Estrusorea"</front>
<front id="language_euH-45">#define MSG_MOVE_01MM                       "Mugitu 0.1mm"</front>
<front id="language_euH-46">#define MSG_MOVE_1MM                        "Mugitu 1mm"</front>
<front id="language_euH-47">#define MSG_MOVE_10MM                       "Mugitu 10mm"</front>
<front id="language_euH-48">#define MSG_SPEED                           "Abiadura"</front>
<front id="language_euH-49">#define MSG_NOZZLE                          "Pita"</front>
<front id="language_euH-50">#define MSG_BED                             "Ohea"</front>
<front id="language_euH-51">#define MSG_FAN_SPEED                       "Haizagailua"</front>
<front id="language_euH-52">#define MSG_FLOW                            "Fluxua"</front>
<front id="language_euH-53">#define MSG_CONTROL                         "Kontrola"</front>
<front id="language_euH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_euH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_euH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Faktorea"</front>
<front id="language_euH-57">#define MSG_AUTOTEMP                        "Auto tenperatura"</front>
<front id="language_euH-58">#define MSG_ON                              "On "</front>
<front id="language_euH-59">#define MSG_OFF                             "Off"</front>
<front id="language_euH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_euH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_euH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_euH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_euH-64">#define MSG_ACC                             "Azelerazioa"</front>
<front id="language_euH-65">#define MSG_VXY_JERK                        "Vxy-astindua"</front>
<front id="language_euH-66">#define MSG_VZ_JERK                         "Vz-astindua"</front>
<front id="language_euH-67">#define MSG_VE_JERK                         "Ve-astindua"</front>
<front id="language_euH-68">#define MSG_VMAX                            "Vmax "</front>
<front id="language_euH-69">#define MSG_X                               "x"</front>
<front id="language_euH-70">#define MSG_Y                               "y"</front>
<front id="language_euH-71">#define MSG_Z                               "z"</front>
<front id="language_euH-72">#define MSG_E                               "e"</front>
<front id="language_euH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_euH-74">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_euH-75">#define MSG_AMAX                            "Amax "</front>
<front id="language_euH-76">#define MSG_A_RETRACT                       "A-retrakt"</front>
<front id="language_euH-77">#define MSG_XSTEPS                          "X pausoak/mm"</front>
<front id="language_euH-78">#define MSG_YSTEPS                          "Y pausoak/mm"</front>
<front id="language_euH-79">#define MSG_ZSTEPS                          "Z pausoak/mm"</front>
<front id="language_euH-80">#define MSG_ESTEPS                          "E pausoak/mm"</front>
<front id="language_euH-81">#define MSG_TEMPERATURE                     "Tenperatura"</front>
<front id="language_euH-82">#define MSG_MOTION                          "Mugimendua"</front>
<front id="language_euH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_euH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_euH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_euH-86">#define MSG_CONTRAST                        "LCD kontrastea"</front>
<front id="language_euH-87">#define MSG_STORE_EPROM                     "Gorde memoria"</front>
<front id="language_euH-88">#define MSG_LOAD_EPROM                      "Kargatu memoria"</front>
<front id="language_euH-89">#define MSG_RESTORE_FAILSAFE                "Larri. berriz."</front>
<front id="language_euH-90">#define MSG_REFRESH                         "Berriz kargatu"</front>
<front id="language_euH-91">#define MSG_WATCH                           "Pantaila info"</front>
<front id="language_euH-92">#define MSG_PREPARE                         "Prestatu"</front>
<front id="language_euH-93">#define MSG_TUNE                            "Doitu"</front>
<front id="language_euH-94">#define MSG_PAUSE_PRINT                     "Pausatu inprimak."</front>
<front id="language_euH-95">#define MSG_RESUME_PRINT                    "Jarraitu inprima."</front>
<front id="language_euH-96">#define MSG_STOP_PRINT                      "Gelditu inprima."</front>
<front id="language_euH-97">#define MSG_CARD_MENU                       "SD-tik inprimatu"</front>
<front id="language_euH-98">#define MSG_NO_CARD                         "Ez dago txartelik"</front>
<front id="language_euH-99">#define MSG_DWELL                           "Lo egin..."</front>
<front id="language_euH-100">#define MSG_USERWAIT                        "Aginduak zain..."</front>
<front id="language_euH-101">#define MSG_RESUMING                        "Jarraitzen inpri."</front>
<front id="language_euH-102">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_euH-103">#define MSG_NO_MOVE                         "Mugimendu gabe"</front>
<front id="language_euH-104">#define MSG_KILLED                          "LARRIALDI GELDIA"</front>
<front id="language_euH-105">#define MSG_STOPPED                         "GELDITUTA. "</front>
<front id="language_euH-106">#define MSG_CONTROL_RETRACT                 "Atzera egin mm"</front>
<front id="language_euH-107">#define MSG_CONTROL_RETRACT_SWAP            "Swap Atzera egin mm"</front>
<front id="language_euH-108">#define MSG_CONTROL_RETRACTF                "Atzera egin V"</front>
<front id="language_euH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Igo mm"</front>
<front id="language_euH-110">#define MSG_CONTROL_RETRACT_RECOVER         "Atzera egin +mm"</front>
<front id="language_euH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Swap Atzera egin +mm"</front>
<front id="language_euH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "Atzera egin V"</front>
<front id="language_euH-113">#define MSG_AUTORETRACT                     "Atzera egin"</front>
<front id="language_euH-114">#define MSG_FILAMENTCHANGE                  "Aldatu filament."</front>
<front id="language_euH-115">#define MSG_INIT_SDCARD                     "Hasieratu txartela"</front>
<front id="language_euH-116">#define MSG_CNG_SDCARD                      "Aldatu txartela"</front>
<front id="language_euH-117">#define MSG_ZPROBE_OUT                      "Z ohe hasiera"</front>
<front id="language_euH-118">#define MSG_POSITION_UNKNOWN                "Posizio ezezaguna"</front>
<front id="language_euH-119">#define MSG_ZPROBE_ZOFFSET                  "Z konpentsatu"</front>
<front id="language_euH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_euH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_euH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_euH-123">#define MSG_ENDSTOP_ABORT                   "Endstop deuseztat"</front>
<front id="language_euH-124">#define MSG_END_HOUR                        "hours"</front>
<front id="language_euH-125">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_euH-126"></front>
<front id="language_euH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_euH-128">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_euH-129">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_euH-130">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_euH-131">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_euH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_euH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_euH-134"></front>
<front id="language_euH-135">#endif // LANGUAGE_EU_H</front>
 </pre>
<h1 id="language_fiHtitle" >language_fi.h</h1>
<pre id="language_fiH"  class="prettyprint linenums"><front id="language_fiH-1">/**</front>
<front id="language_fiH-2"> * Finnish</front>
<front id="language_fiH-3"> *</front>
<front id="language_fiH-4"> * LCD Menu Messages</front>
<front id="language_fiH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_fiH-6"> *</front>
<front id="language_fiH-7"> */</front>
<front id="language_fiH-8">#ifndef LANGUAGE_FI_H</front>
<front id="language_fiH-9">#define LANGUAGE_FI_H</front>
<front id="language_fiH-10"></front>
<front id="language_fiH-11">#define MAPPER_C2C3</front>
<front id="language_fiH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_fiH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_fiH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_fiH-15"></front>
<front id="language_fiH-16">#define WELCOME_MSG                         MACHINE_NAME " valmis."</front>
<front id="language_fiH-17">#define MSG_SD_INSERTED                     "Kortti asetettu"</front>
<front id="language_fiH-18">#define MSG_SD_REMOVED                      "Kortti poistettu"</front>
<front id="language_fiH-19">#define MSG_MAIN                            "Palaa"</front>
<front id="language_fiH-20">#define MSG_AUTOSTART                       "Automaatti"</front>
<front id="language_fiH-21">#define MSG_DISABLE_STEPPERS                "Vapauta moottorit"</front>
<front id="language_fiH-22">#define MSG_AUTO_HOME                       "Aja referenssiin"</front>
<front id="language_fiH-23">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_fiH-24">#define MSG_SET_ORIGIN                      "Aseta origo"</front>
<front id="language_fiH-25">#define MSG_PREHEAT_PLA                     "Esilmmit PLA"</front>
<front id="language_fiH-26">#define MSG_PREHEAT_PLA_N                   "Esilmmit PLA "</front>
<front id="language_fiH-27">#define MSG_PREHEAT_PLA_ALL                 "Esil. PLA Kaikki"</front>
<front id="language_fiH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Esil. PLA Alusta"</front>
<front id="language_fiH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Esilmm. PLA konf"</front>
<front id="language_fiH-30">#define MSG_PREHEAT_ABS                     "Esilmmit ABS"</front>
<front id="language_fiH-31">#define MSG_PREHEAT_ABS_N                   "Esilmmit ABS "</front>
<front id="language_fiH-32">#define MSG_PREHEAT_ABS_ALL                 "Esil. ABS Kaikki"</front>
<front id="language_fiH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Esil. ABS Alusta"</front>
<front id="language_fiH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Esilmm. ABS konf"</front>
<front id="language_fiH-35">#define MSG_COOLDOWN                        "Jhdyt"</front>
<front id="language_fiH-36">#define MSG_SWITCH_PS_ON                    "Virta plle"</front>
<front id="language_fiH-37">#define MSG_SWITCH_PS_OFF                   "Virta pois"</front>
<front id="language_fiH-38">#define MSG_EXTRUDE                         "Pursota"</front>
<front id="language_fiH-39">#define MSG_RETRACT                         "Ved takaisin"</front>
<front id="language_fiH-40">#define MSG_MOVE_AXIS                       "Liikuta akseleita"</front>
<front id="language_fiH-41">#define MSG_MOVE_X                          "Liikuta X"</front>
<front id="language_fiH-42">#define MSG_MOVE_Y                          "Liikuta Y"</front>
<front id="language_fiH-43">#define MSG_MOVE_Z                          "Liikuta Z"</front>
<front id="language_fiH-44">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_fiH-45">#define MSG_MOVE_01MM                       "Liikuta 0.1mm"</front>
<front id="language_fiH-46">#define MSG_MOVE_1MM                        "Liikuta 1mm"</front>
<front id="language_fiH-47">#define MSG_MOVE_10MM                       "Liikuta 10mm"</front>
<front id="language_fiH-48">#define MSG_SPEED                           "Nopeus"</front>
<front id="language_fiH-49">#define MSG_NOZZLE                          "Suutin"</front>
<front id="language_fiH-50">#define MSG_BED                             "Alusta"</front>
<front id="language_fiH-51">#define MSG_FAN_SPEED                       "Tuul. nopeus"</front>
<front id="language_fiH-52">#define MSG_FLOW                            "Virtaus"</front>
<front id="language_fiH-53">#define MSG_CONTROL                         "Kontrolli"</front>
<front id="language_fiH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_fiH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_fiH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Kerr"</front>
<front id="language_fiH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_fiH-58">#define MSG_ON                              "On "</front>
<front id="language_fiH-59">#define MSG_OFF                             "Off"</front>
<front id="language_fiH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_fiH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_fiH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_fiH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_fiH-64">#define MSG_ACC                             "Kiihtyv"</front>
<front id="language_fiH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_fiH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_fiH-67">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_fiH-68">#define MSG_VMAX                            "Vmax "</front>
<front id="language_fiH-69">#define MSG_X                               "x"</front>
<front id="language_fiH-70">#define MSG_Y                               "y"</front>
<front id="language_fiH-71">#define MSG_Z                               "z"</front>
<front id="language_fiH-72">#define MSG_E                               "e"</front>
<front id="language_fiH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_fiH-74">#define MSG_VTRAV_MIN                       "VLiike min"</front>
<front id="language_fiH-75">#define MSG_AMAX                            "Amax "</front>
<front id="language_fiH-76">#define MSG_A_RETRACT                       "A-peruuta"</front>
<front id="language_fiH-77">#define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_fiH-78">#define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_fiH-79">#define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_fiH-80">#define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_fiH-81">#define MSG_TEMPERATURE                     "Lmptila"</front>
<front id="language_fiH-82">#define MSG_MOTION                          "Liike"</front>
<front id="language_fiH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_fiH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm"</front>
<front id="language_fiH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_fiH-86">#define MSG_CONTRAST                        "LCD kontrasti"</front>
<front id="language_fiH-87">#define MSG_STORE_EPROM                     "Tallenna muistiin"</front>
<front id="language_fiH-88">#define MSG_LOAD_EPROM                      "Lataa muistista"</front>
<front id="language_fiH-89">#define MSG_RESTORE_FAILSAFE                "Palauta oletus"</front>
<front id="language_fiH-90">#define MSG_REFRESH                         "Pivit"</front>
<front id="language_fiH-91">#define MSG_WATCH                           "Seuraa"</front>
<front id="language_fiH-92">#define MSG_PREPARE                         "Valmistele"</front>
<front id="language_fiH-93">#define MSG_TUNE                            "Sd"</front>
<front id="language_fiH-94">#define MSG_PAUSE_PRINT                     "Keskeyt tulostus"</front>
<front id="language_fiH-95">#define MSG_RESUME_PRINT                    "Jatka tulostusta"</front>
<front id="language_fiH-96">#define MSG_STOP_PRINT                      "Pysyt tulostus"</front>
<front id="language_fiH-97">#define MSG_CARD_MENU                       "Korttivalikko"</front>
<front id="language_fiH-98">#define MSG_NO_CARD                         "Ei korttia"</front>
<front id="language_fiH-99">#define MSG_DWELL                           "Nukkumassa..."</front>
<front id="language_fiH-100">#define MSG_USERWAIT                        "Odotet. valintaa"</front>
<front id="language_fiH-101">#define MSG_RESUMING                        "Jatke. tulostusta"</front>
<front id="language_fiH-102">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_fiH-103">#define MSG_NO_MOVE                         "Ei liiketta."</front>
<front id="language_fiH-104">#define MSG_KILLED                          "KILLED. "</front>
<front id="language_fiH-105">#define MSG_STOPPED                         "STOPPED. "</front>
<front id="language_fiH-106">#define MSG_CONTROL_RETRACT                 "Ved mm"</front>
<front id="language_fiH-107">#define MSG_CONTROL_RETRACT_SWAP            "Va. Ved mm"</front>
<front id="language_fiH-108">#define MSG_CONTROL_RETRACTF                "Ved V"</front>
<front id="language_fiH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Z mm"</front>
<front id="language_fiH-110">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_fiH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Va. UnRet +mm"</front>
<front id="language_fiH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_fiH-113">#define MSG_AUTORETRACT                     "AutoVeto."</front>
<front id="language_fiH-114">#define MSG_FILAMENTCHANGE                  "Change filament"</front>
<front id="language_fiH-115">#define MSG_INIT_SDCARD                     "Init. SD-Card"</front>
<front id="language_fiH-116">#define MSG_CNG_SDCARD                      "Change SD-Card"</front>
<front id="language_fiH-117">#define MSG_ZPROBE_OUT                      "Z probe out. bed"</front>
<front id="language_fiH-118">#define MSG_POSITION_UNKNOWN                "Home X/Y before Z"</front>
<front id="language_fiH-119">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_fiH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_fiH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_fiH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_fiH-123">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_fiH-124">#define MSG_END_HOUR                        "hours"</front>
<front id="language_fiH-125">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_fiH-126"></front>
<front id="language_fiH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_fiH-128">    #define MSG_DELTA_CALIBRATE             "Delta Kalibrointi"</front>
<front id="language_fiH-129">    #define MSG_DELTA_CALIBRATE_X           "Kalibroi X"</front>
<front id="language_fiH-130">    #define MSG_DELTA_CALIBRATE_Y           "Kalibroi Y"</front>
<front id="language_fiH-131">    #define MSG_DELTA_CALIBRATE_Z           "Kalibroi Z"</front>
<front id="language_fiH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Kalibroi Center"</front>
<front id="language_fiH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_fiH-134"></front>
<front id="language_fiH-135">#endif // LANGUAGE_FI_H</front>
 </pre>
<h1 id="language_frHtitle" >language_fr.h</h1>
<pre id="language_frH"  class="prettyprint linenums"><front id="language_frH-1">/**</front>
<front id="language_frH-2"> * French</front>
<front id="language_frH-3"> *</front>
<front id="language_frH-4"> * LCD Menu Messages</front>
<front id="language_frH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_frH-6"> *</front>
<front id="language_frH-7"> */</front>
<front id="language_frH-8">#ifndef LANGUAGE_FR_H</front>
<front id="language_frH-9">#define LANGUAGE_FR_H</front>
<front id="language_frH-10"></front>
<front id="language_frH-11">#define MAPPER_NON</front>
<front id="language_frH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_frH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_frH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_frH-15"></front>
<front id="language_frH-16"></front>
<front id="language_frH-17">#define WELCOME_MSG                         MACHINE_NAME " prete."</front>
<front id="language_frH-18">#define MSG_SD_INSERTED                     "Carte inseree"</front>
<front id="language_frH-19">#define MSG_SD_REMOVED                      "Carte retiree"</front>
<front id="language_frH-20">#define MSG_MAIN                            "Menu principal"</front>
<front id="language_frH-21">#define MSG_AUTOSTART                       "Demarrage auto"</front>
<front id="language_frH-22">#define MSG_DISABLE_STEPPERS                "Arreter moteurs"</front>
<front id="language_frH-23">#define MSG_AUTO_HOME                       "Home auto."</front>
<front id="language_frH-24">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_frH-25">#define MSG_SET_ORIGIN                      "Regler origine"</front>
<front id="language_frH-26">#define MSG_PREHEAT_PLA                     "Prechauffage PLA"</front>
<front id="language_frH-27">#define MSG_PREHEAT_PLA_N                   "Prechauff. PLA "</front>
<front id="language_frH-28">#define MSG_PREHEAT_PLA_ALL                 "Prech. PLA Tout"</front>
<front id="language_frH-29">#define MSG_PREHEAT_PLA_BEDONLY             "Prech. PLA Plateau"</front>
<front id="language_frH-30">#define MSG_PREHEAT_PLA_SETTINGS            "Regl. prech. PLA"</front>
<front id="language_frH-31">#define MSG_PREHEAT_ABS                     "Prechauffage ABS"</front>
<front id="language_frH-32">#define MSG_PREHEAT_ABS_N                   "Prechauff. ABS "</front>
<front id="language_frH-33">#define MSG_PREHEAT_ABS_ALL                 "Prech. ABS Tout"</front>
<front id="language_frH-34">#define MSG_PREHEAT_ABS_BEDONLY             "Prech. ABS Plateau"</front>
<front id="language_frH-35">#define MSG_PREHEAT_ABS_SETTINGS            "Regl. prech. ABS"</front>
<front id="language_frH-36">#define MSG_COOLDOWN                        "Refroidir"</front>
<front id="language_frH-37">#define MSG_SWITCH_PS_ON                    "Allumer alim."</front>
<front id="language_frH-38">#define MSG_SWITCH_PS_OFF                   "Eteindre alim."</front>
<front id="language_frH-39">#define MSG_EXTRUDE                         "Extrusion"</front>
<front id="language_frH-40">#define MSG_RETRACT                         "Retraction"</front>
<front id="language_frH-41">#define MSG_MOVE_AXIS                       "Deplacer un axe"</front>
<front id="language_frH-42">#define MSG_MOVE_X                          "Depl. X"</front>
<front id="language_frH-43">#define MSG_MOVE_Y                          "Depl. Y"</front>
<front id="language_frH-44">#define MSG_MOVE_Z                          "Depl. Z"</front>
<front id="language_frH-45">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_frH-46">#define MSG_MOVE_01MM                       "Depl. 0.1mm"</front>
<front id="language_frH-47">#define MSG_MOVE_1MM                        "Depl. 1mm"</front>
<front id="language_frH-48">#define MSG_MOVE_10MM                       "Depl. 10mm"</front>
<front id="language_frH-49">#define MSG_SPEED                           " Vitesse"</front>
<front id="language_frH-50">#define MSG_NOZZLE                          "Buse"</front>
<front id="language_frH-51">#define MSG_BED                             "Plateau"</front>
<front id="language_frH-52">#define MSG_LEVEL_BED                       "Regl. Niv. Plateau"</front>
<front id="language_frH-53">#define MSG_FAN_SPEED                       "Vite. ventilateur"</front>
<front id="language_frH-54">#define MSG_FLOW                            "Flux"</front>
<front id="language_frH-55">#define MSG_CONTROL                         "Controler"</front>
<front id="language_frH-56">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_frH-57">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_frH-58">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Facteur"</front>
<front id="language_frH-59">#define MSG_AUTOTEMP                        "Temp. Auto."</front>
<front id="language_frH-60">#define MSG_ON                              "Marche "</front>
<front id="language_frH-61">#define MSG_OFF                             "Arret"</front>
<front id="language_frH-62">#define MSG_PID_P                           "PID-P"</front>
<front id="language_frH-63">#define MSG_PID_I                           "PID-I"</front>
<front id="language_frH-64">#define MSG_PID_D                           "PID-D"</front>
<front id="language_frH-65">#define MSG_PID_C                           "PID-C"</front>
<front id="language_frH-66">#define MSG_ACC                             "Accel"</front>
<front id="language_frH-67">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_frH-68">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_frH-69">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_frH-70">#define MSG_VMAX                            "Vmax"</front>
<front id="language_frH-71">#define MSG_X                               "x"</front>
<front id="language_frH-72">#define MSG_Y                               "y"</front>
<front id="language_frH-73">#define MSG_Z                               "z"</front>
<front id="language_frH-74">#define MSG_E                               "e"</front>
<front id="language_frH-75">#define MSG_VMIN                            "Vmin"</front>
<front id="language_frH-76">#define MSG_VTRAV_MIN                       "Vdepl min"</front>
<front id="language_frH-77">#define MSG_AMAX                            "Amax "</front>
<front id="language_frH-78">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_frH-79">#define MSG_XSTEPS                          "Xpas/mm"</front>
<front id="language_frH-80">#define MSG_YSTEPS                          "Ypas/mm"</front>
<front id="language_frH-81">#define MSG_ZSTEPS                          "Zpas/mm"</front>
<front id="language_frH-82">#define MSG_ESTEPS                          "Epas/mm"</front>
<front id="language_frH-83">#define MSG_TEMPERATURE                     "Temperature"</front>
<front id="language_frH-84">#define MSG_MOTION                          "Mouvement"</front>
<front id="language_frH-85">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_frH-86">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_frH-87">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_frH-88">#define MSG_CONTRAST                        "Contraste LCD"</front>
<front id="language_frH-89">#define MSG_STORE_EPROM                     "Sauver config"</front>
<front id="language_frH-90">#define MSG_LOAD_EPROM                      "Lire config"</front>
<front id="language_frH-91">#define MSG_RESTORE_FAILSAFE                "Restaurer defauts"</front>
<front id="language_frH-92">#define MSG_REFRESH                         "Actualiser"</front>
<front id="language_frH-93">#define MSG_WATCH                           "Surveiller"</front>
<front id="language_frH-94">#define MSG_PREPARE                         "Preparer"</front>
<front id="language_frH-95">#define MSG_TUNE                            "Regler"</front>
<front id="language_frH-96">#define MSG_PAUSE_PRINT                     "Interrompre impr."</front>
<front id="language_frH-97">#define MSG_RESUME_PRINT                    "Reprendre impr."</front>
<front id="language_frH-98">#define MSG_STOP_PRINT                      "Arreter impr."</front>
<front id="language_frH-99">#define MSG_CARD_MENU                       "Impr. depuis SD"</front>
<front id="language_frH-100">#define MSG_NO_CARD                         "Pas de carte"</front>
<front id="language_frH-101">#define MSG_DWELL                           "Repos..."</front>
<front id="language_frH-102">#define MSG_USERWAIT                        "Atten. de l'util."</front>
<front id="language_frH-103">#define MSG_RESUMING                        "Repri. de l'impr."</front>
<front id="language_frH-104">#define MSG_PRINT_ABORTED                   "Impr. Annulee"</front>
<front id="language_frH-105">#define MSG_NO_MOVE                         "Aucun mouvement."</front>
<front id="language_frH-106">#define MSG_KILLED                          "MORT."</front>
<front id="language_frH-107">#define MSG_STOPPED                         "STOPPE."</front>
<front id="language_frH-108">#define MSG_CONTROL_RETRACT                 "Retraction mm"</front>
<front id="language_frH-109">#define MSG_CONTROL_RETRACT_SWAP            "Ech. Retr. mm"</front>
<front id="language_frH-110">#define MSG_CONTROL_RETRACTF                "Retraction V"</front>
<front id="language_frH-111">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_frH-112">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_frH-113">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Ech. UnRet +mm"</front>
<front id="language_frH-114">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet V"</front>
<front id="language_frH-115">#define MSG_AUTORETRACT                     "Retract. Auto."</front>
<front id="language_frH-116">#define MSG_FILAMENTCHANGE                  "Changer filament"</front>
<front id="language_frH-117">#define MSG_INIT_SDCARD                     "Init. la carte SD"</front>
<front id="language_frH-118">#define MSG_CNG_SDCARD                      "Changer de carte"</front>
<front id="language_frH-119">#define MSG_ZPROBE_OUT                      "Z sonde exte. lit"</front>
<front id="language_frH-120">#define MSG_POSITION_UNKNOWN                "Rev. dans XY av.Z"</front>
<front id="language_frH-121">#define MSG_ZPROBE_ZOFFSET                  "Offset Z"</front>
<front id="language_frH-122">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_frH-123">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_frH-124">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_frH-125">#define MSG_ENDSTOP_ABORT                   "Butee abandon"</front>
<front id="language_frH-126">#define MSG_END_HOUR                        "heures"</front>
<front id="language_frH-127">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_frH-128"></front>
<front id="language_frH-129">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_frH-130">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_frH-131">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_frH-132">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_frH-133">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_frH-134">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_frH-135">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_frH-136"></front>
<front id="language_frH-137">#endif // LANGUAGE_FR_H</front>
 </pre>
<h1 id="language_itHtitle" >language_it.h</h1>
<pre id="language_itH"  class="prettyprint linenums"><front id="language_itH-1">/**</front>
<front id="language_itH-2"> * Italian</front>
<front id="language_itH-3"> *</front>
<front id="language_itH-4"> * LCD Menu Messages</front>
<front id="language_itH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_itH-6"> *</front>
<front id="language_itH-7"> */</front>
<front id="language_itH-8">#ifndef LANGUAGE_IT_H</front>
<front id="language_itH-9">#define LANGUAGE_IT_H</front>
<front id="language_itH-10"></front>
<front id="language_itH-11">#define MAPPER_NON</front>
<front id="language_itH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_itH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_itH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_itH-15"></front>
<front id="language_itH-16">#define WELCOME_MSG                         MACHINE_NAME " pronto."</front>
<front id="language_itH-17">#define MSG_SD_INSERTED                     "SD Card inserita"</front>
<front id="language_itH-18">#define MSG_SD_REMOVED                      "SD Card rimossa"</front>
<front id="language_itH-19">#define MSG_MAIN                            "Menu principale"</front>
<front id="language_itH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_itH-21">#define MSG_DISABLE_STEPPERS                "Disabilita Motori"</front>
<front id="language_itH-22">#define MSG_AUTO_HOME                       "Auto Home"</front>
<front id="language_itH-23">#define MSG_SET_HOME_OFFSETS                "Setta offset home"</front>
<front id="language_itH-24">#define MSG_SET_ORIGIN                      "Imposta Origine"</front>
<front id="language_itH-25">#define MSG_PREHEAT_PLA                     "Preriscalda PLA"</front>
<front id="language_itH-26">#define MSG_PREHEAT_PLA_N                   "Preriscalda PLA "</front>
<front id="language_itH-27">#define MSG_PREHEAT_PLA_ALL                 "Prer. PLA Tutto"</front>
<front id="language_itH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Prer. PLA Piatto"</front>
<front id="language_itH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Config. prer. PLA"</front>
<front id="language_itH-30">#define MSG_PREHEAT_ABS                     "Preriscalda ABS"</front>
<front id="language_itH-31">#define MSG_PREHEAT_ABS_N                   "Preriscalda ABS "</front>
<front id="language_itH-32">#define MSG_PREHEAT_ABS_ALL                 "Prer. ABS Tutto"</front>
<front id="language_itH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Prer. ABS Piatto"</front>
<front id="language_itH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Config. prer. ABS"</front>
<front id="language_itH-35">#define MSG_COOLDOWN                        "Raffredda"</front>
<front id="language_itH-36">#define MSG_SWITCH_PS_ON                    "Accendi aliment."</front>
<front id="language_itH-37">#define MSG_SWITCH_PS_OFF                   "Spegni aliment."</front>
<front id="language_itH-38">#define MSG_EXTRUDE                         "Estrudi"</front>
<front id="language_itH-39">#define MSG_RETRACT                         "Ritrai"</front>
<front id="language_itH-40">#define MSG_MOVE_AXIS                       "Muovi Asse"</front>
<front id="language_itH-41">#define MSG_MOVE_X                          "Muovi X"</front>
<front id="language_itH-42">#define MSG_MOVE_Y                          "Muovi Y"</front>
<front id="language_itH-43">#define MSG_MOVE_Z                          "Muovi Z"</front>
<front id="language_itH-44">#define MSG_MOVE_E                          "Estrusore"</front>
<front id="language_itH-45">#define MSG_MOVE_01MM                       "Muovi di 0.1mm"</front>
<front id="language_itH-46">#define MSG_MOVE_1MM                        "Muovi di   1mm"</front>
<front id="language_itH-47">#define MSG_MOVE_10MM                       "Muovi di  10mm"</front>
<front id="language_itH-48">#define MSG_SPEED                           "Velcit"</front>
<front id="language_itH-49">#define MSG_NOZZLE                          "Ugello"</front>
<front id="language_itH-50">#define MSG_BED                             "Piatto"</front>
<front id="language_itH-51">#define MSG_FAN_SPEED                       "Ventola"</front>
<front id="language_itH-52">#define MSG_FLOW                            "Flusso"</front>
<front id="language_itH-53">#define MSG_CONTROL                         "Controllo"</front>
<front id="language_itH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_itH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_itH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_itH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_itH-58">#define MSG_ON                              "ON "</front>
<front id="language_itH-59">#define MSG_OFF                             "OFF"</front>
<front id="language_itH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_itH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_itH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_itH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_itH-64">#define MSG_ACC                             "Accel."</front>
<front id="language_itH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_itH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_itH-67">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_itH-68">#define MSG_VMAX                            "Vmax"</front>
<front id="language_itH-69">#define MSG_X                               "x"</front>
<front id="language_itH-70">#define MSG_Y                               "y"</front>
<front id="language_itH-71">#define MSG_Z                               "z"</front>
<front id="language_itH-72">#define MSG_E                               "e"</front>
<front id="language_itH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_itH-74">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_itH-75">#define MSG_AMAX                            "Amax"</front>
<front id="language_itH-76">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_itH-77">#define MSG_XSTEPS                          "Xpassi/mm"</front>
<front id="language_itH-78">#define MSG_YSTEPS                          "Ypassi/mm"</front>
<front id="language_itH-79">#define MSG_ZSTEPS                          "Zpassi/mm"</front>
<front id="language_itH-80">#define MSG_ESTEPS                          "Epassi/mm"</front>
<front id="language_itH-81">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_itH-82">#define MSG_MOTION                          "Movimento"</front>
<front id="language_itH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_itH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm"</front>
<front id="language_itH-85">#define MSG_FILAMENT_DIAM                   "Diam. filo"</front>
<front id="language_itH-86">#define MSG_CONTRAST                        "Contrasto LCD"</front>
<front id="language_itH-87">#define MSG_STORE_EPROM                     "Salva in EEPROM"</front>
<front id="language_itH-88">#define MSG_LOAD_EPROM                      "Carica da EEPROM"</front>
<front id="language_itH-89">#define MSG_RESTORE_FAILSAFE                "Impostaz. default"</front>
<front id="language_itH-90">#define MSG_REFRESH                         "Aggiorna"</front>
<front id="language_itH-91">#define MSG_WATCH                           "Guarda"</front>
<front id="language_itH-92">#define MSG_PREPARE                         "Prepara"</front>
<front id="language_itH-93">#define MSG_TUNE                            "Adatta"</front>
<front id="language_itH-94">#define MSG_PAUSE_PRINT                     "Pausa"</front>
<front id="language_itH-95">#define MSG_RESUME_PRINT                    "Riprendi stampa"</front>
<front id="language_itH-96">#define MSG_STOP_PRINT                      "Arresta stampa"</front>
<front id="language_itH-97">#define MSG_CARD_MENU                       "SD Card Menu"</front>
<front id="language_itH-98">#define MSG_NO_CARD                         "No SD Card"</front>
<front id="language_itH-99">#define MSG_DWELL                           "Sospensione..."</front>
<front id="language_itH-100">#define MSG_USERWAIT                        "Attendi Utente..."</front>
<front id="language_itH-101">#define MSG_RESUMING                        "Riprendi Stampa"</front>
<front id="language_itH-102">#define MSG_PRINT_ABORTED                   "Stampa abortita"</front>
<front id="language_itH-103">#define MSG_NO_MOVE                         "Nessun Movimento"</front>
<front id="language_itH-104">#define MSG_KILLED                          "UCCISO "</front>
<front id="language_itH-105">#define MSG_STOPPED                         "ARRESTATO "</front>
<front id="language_itH-106">#define MSG_CONTROL_RETRACT                 "Ritrai mm"</front>
<front id="language_itH-107">#define MSG_CONTROL_RETRACT_SWAP            "Scamb. Ritrai mm"</front>
<front id="language_itH-108">#define MSG_CONTROL_RETRACTF                "Ritrai  V"</front>
<front id="language_itH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Salta mm"</front>
<front id="language_itH-110">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_itH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Scamb. UnRet +mm"</front>
<front id="language_itH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_itH-113">#define MSG_AUTORETRACT                     "AutoArretramento"</front>
<front id="language_itH-114">#define MSG_FILAMENTCHANGE                  "Cambia filamento"</front>
<front id="language_itH-115">#define MSG_INIT_SDCARD                     "Iniz. SD-Card"</front>
<front id="language_itH-116">#define MSG_CNG_SDCARD                      "Cambia SD-Card"</front>
<front id="language_itH-117">#define MSG_ZPROBE_OUT                      "Z probe out. bed"</front>
<front id="language_itH-118">#define MSG_POSITION_UNKNOWN                "Home X/Y before Z"</front>
<front id="language_itH-119">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_itH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_itH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_itH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_itH-123">#define MSG_ENDSTOP_ABORT                   "Finecorsa abort"</front>
<front id="language_itH-124">#define MSG_END_HOUR                        "ore"</front>
<front id="language_itH-125">#define MSG_END_MINUTE                      "minuti"</front>
<front id="language_itH-126"></front>
<front id="language_itH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_itH-128">    #define MSG_DELTA_CALIBRATE             "Calibraz. Delta"</front>
<front id="language_itH-129">    #define MSG_DELTA_CALIBRATE_X           "Calibra X"</front>
<front id="language_itH-130">    #define MSG_DELTA_CALIBRATE_Y           "Calibra Y"</front>
<front id="language_itH-131">    #define MSG_DELTA_CALIBRATE_Z           "Calibra Z"</front>
<front id="language_itH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibra Center"</front>
<front id="language_itH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_itH-134"></front>
<front id="language_itH-135">#endif // LANGUAGE_IT_H</front>
 </pre>
<h1 id="language_kanaHtitle" >language_kana.h</h1>
<pre id="language_kanaH"  class="prettyprint linenums"><front id="language_kanaH-1">/**</front>
<front id="language_kanaH-2"> * Japanese (Kana)</front>
<front id="language_kanaH-3"> *</front>
<front id="language_kanaH-4"> * LCD Menu Messages</front>
<front id="language_kanaH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_kanaH-6"> *</front>
<front id="language_kanaH-7"> */</front>
<front id="language_kanaH-8"></front>
<front id="language_kanaH-9">#ifndef LANGUAGE_KANA_H</front>
<front id="language_kanaH-10">#define LANGUAGE_KANA_H</front>
<front id="language_kanaH-11"></front>
<front id="language_kanaH-12">#define MAPPER_NON</front>
<front id="language_kanaH-13">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_kanaH-14">#define SIMULATE_ROMFONT</front>
<front id="language_kanaH-15">#define DISPLAY_CHARSET_ISO10646_KANA</front>
<front id="language_kanaH-16"></front>
<front id="language_kanaH-17">// </front>
<front id="language_kanaH-18">#define WELCOME_MSG                         MACHINE_NAME " ready."</front>
<front id="language_kanaH-19">#define MSG_SD_INSERTED                     "\xb6\xb0\xc4\xde\x20\xbf\xb3\xc6\xad\xb3\xbb\xda\xcf\xbc\xc0" // "Card inserted"</front>
<front id="language_kanaH-20">#define MSG_SD_REMOVED                      "\xb6\xb0\xc4\xde\xb6xde\xb1\xd8\xcf\xbe\xdd"                  // "Card removed"</front>
<front id="language_kanaH-21">#define MSG_MAIN                            "\xd2\xb2\xdd"                                                 // "Main"</front>
<front id="language_kanaH-22">#define MSG_AUTOSTART                       "\xbc\xde\xc4\xde\xb3\xb6\xb2\xbc"                             // "Autostart"</front>
<front id="language_kanaH-23">#define MSG_DISABLE_STEPPERS                "\xd3\xb0\xc0\xb0\xc3\xde\xdd\xb9\xde\xdd\x20\xb5\xcc"         // "Disable steppers"</front>
<front id="language_kanaH-24">#define MSG_AUTO_HOME                       "\xb9\xde\xdd\xc3\xdd\xc6\xb2\xc4\xde\xb3"                     // "Auto home"</front>
<front id="language_kanaH-25">#define MSG_SET_HOME_OFFSETS                "\xb7\xbc\xde\xad\xdd\xb5\xcc\xbe\xaf\xc4\xbe\xaf\xc3\xb2"     // "Set home offsets"</front>
<front id="language_kanaH-26">#define MSG_SET_ORIGIN                      "\xb7\xbc\xde\xad\xdd\xbe\xaf\xc4"                             // "Set origin"</front>
<front id="language_kanaH-27">#define MSG_PREHEAT_PLA                     "PLA \xd6\xc8\xc2"                                             // "Preheat PLA"</front>
<front id="language_kanaH-28">#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "</front>
<front id="language_kanaH-29">#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " \xbd\xcd\xde\xc3"                            // " All"</front>
<front id="language_kanaH-30">#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " \xcd\xde\xaf\xc4\xde"                        // "Bed"</front>
<front id="language_kanaH-31">#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " \xbe\xaf\xc3\xb2"                            // "conf"</front>
<front id="language_kanaH-32">#define MSG_PREHEAT_ABS                     "ABS \xd6\xc8\xc2"                                             // "Preheat ABS"</front>
<front id="language_kanaH-33">#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "</front>
<front id="language_kanaH-34">#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " \xbd\xcd\xde\xc3"                            // " All"</front>
<front id="language_kanaH-35">#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " \xcd\xde\xaf\xc4\xde"                        // "Bed"</front>
<front id="language_kanaH-36">#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " \xbe\xaf\xc3\xb2"                            // "conf"</front>
<front id="language_kanaH-37">#define MSG_COOLDOWN                        "\xb6\xc8\xc2\xc3\xb2\xbc"                                     // "Cooldown"</front>
<front id="language_kanaH-38">#define MSG_SWITCH_PS_ON                    "\xc3\xde\xdd\xb9\xdd\xde\x20\xb5\xdd"                         // "Switch power on"</front>
<front id="language_kanaH-39">#define MSG_SWITCH_PS_OFF                   "\xc3\xde\xdd\xb9\xdd\xde\x20\xb5\xcc"                         // "Switch power off"</front>
<front id="language_kanaH-40">#define MSG_EXTRUDE                         "\xb5\xbc\xc0\xde\xbc"                                         // "Extrude"</front>
<front id="language_kanaH-41">#define MSG_RETRACT                         "\xd8\xc4\xd7\xb8\xc4"                                         // "Retract"</front>
<front id="language_kanaH-42">#define MSG_MOVE_AXIS                       "\xbc\xde\xb8\xb2\xc4\xde\xb3"                                 // "Move axis"</front>
<front id="language_kanaH-43">#define MSG_MOVE_X                          "X\xbc\xde\xb8\x20\xb2\xc4\xde\xb3"                            // "Move X"</front>
<front id="language_kanaH-44">#define MSG_MOVE_Y                          "Y\xbc\xde\xb8\x20\xb2\xc4\xde\xb3"                            // "Move Y"</front>
<front id="language_kanaH-45">#define MSG_MOVE_Z                          "Z\xbc\xde\xb8\x20\xb2\xc4\xde\xb3"                            // "Move Z"</front>
<front id="language_kanaH-46">#define MSG_MOVE_E                          "\xb4\xb8\xbd\xc4\xd9\xb0\xc0\xde\xb0"                         // "Extruder"</front>
<front id="language_kanaH-47">#define MSG_MOVE_01MM                       "0.1mm \xb2\xc4\xde\xb3"                                       // "Move 0.1mm"</front>
<front id="language_kanaH-48">#define MSG_MOVE_1MM                        "  1mm \xb2\xc4\xde\xb3"                                       // "Move 1mm"</front>
<front id="language_kanaH-49">#define MSG_MOVE_10MM                       " 10mm \xb2\xc4\xde\xb3"                                       // "Move 10mm"</front>
<front id="language_kanaH-50">#define MSG_SPEED                           "\xbd\xcb\xdf\xb0\xc4\xde"                                     // "Speed"</front>
<front id="language_kanaH-51">#define MSG_NOZZLE                          "\xc9\xbd\xde\xd9"                                             // "Nozzle"</front>
<front id="language_kanaH-52">#define MSG_BED                             "\xcd\xde\xaf\xc4\xde"                                         // "Bed"</front>
<front id="language_kanaH-53">#define MSG_FAN_SPEED                       "\xcc\xa7\xdd\xbf\xb8\xc4\xde"                                 // "Fan speed"</front>
<front id="language_kanaH-54">#define MSG_FLOW                            "\xb5\xb8\xd8\xd8\xae\xb3"                                     // "Flow"</front>
<front id="language_kanaH-55">#define MSG_CONTROL                         "\xba\xdd\xc4\xdb\xb0\xd9"                                     // "Control"</front>
<front id="language_kanaH-56">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_kanaH-57">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_kanaH-58">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_kanaH-59">#define MSG_AUTOTEMP                        "\xbc\xde\xc4\xde\xb3\xb5\xdd\xc4\xde"                         // "Autotemp"</front>
<front id="language_kanaH-60">#define MSG_ON                              "On "</front>
<front id="language_kanaH-61">#define MSG_OFF                             "Off"</front>
<front id="language_kanaH-62">#define MSG_PID_P                           "PID-P"</front>
<front id="language_kanaH-63">#define MSG_PID_I                           "PID-I"</front>
<front id="language_kanaH-64">#define MSG_PID_D                           "PID-D"</front>
<front id="language_kanaH-65">#define MSG_PID_C                           "PID-C"</front>
<front id="language_kanaH-66">#define MSG_ACC                             "\xb6\xbf\xb8\xc4\xde"                                         // "Accel"</front>
<front id="language_kanaH-67">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_kanaH-68">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_kanaH-69">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_kanaH-70">#define MSG_VMAX                            "Vmax "</front>
<front id="language_kanaH-71">#define MSG_X                               "x"</front>
<front id="language_kanaH-72">#define MSG_Y                               "y"</front>
<front id="language_kanaH-73">#define MSG_Z                               "z"</front>
<front id="language_kanaH-74">#define MSG_E                               "e"</front>
<front id="language_kanaH-75">#define MSG_VMIN                            "Vmin"</front>
<front id="language_kanaH-76">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_kanaH-77">#define MSG_AMAX                            "Amax "</front>
<front id="language_kanaH-78">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_kanaH-79">#define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_kanaH-80">#define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_kanaH-81">#define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_kanaH-82">#define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_kanaH-83">#define MSG_TEMPERATURE                     "\xb5\xdd\xc4\xde"                                             // "Temperature"</front>
<front id="language_kanaH-84">#define MSG_MOTION                          "\xb3\xba\xde\xb7\xbe\xaf\xc3\xb2"                             // "Motion"</front>
<front id="language_kanaH-85">#define MSG_VOLUMETRIC                      "\xcc\xa8\xd7\xd2\xdd\xc4"                                     // "Filament"</front>
<front id="language_kanaH-86">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_kanaH-87">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_kanaH-88">#define MSG_CONTRAST                        "LCD\xba\xdd\xc4\xd7\xbd\xc4"                                  // "LCD contrast"</front>
<front id="language_kanaH-89">#define MSG_STORE_EPROM                     "\xd2\xd3\xd8\xcd\xb6\xb8\xc9\xb3"                             // "Store memory"</front>
<front id="language_kanaH-90">#define MSG_LOAD_EPROM                      "\xd2\xd3\xd8\xb6\xd7\xd6\xd0\ba\xd0"                          // "Load memory"</front>
<front id="language_kanaH-91">#define MSG_RESTORE_FAILSAFE                "\xbe\xaf\xc3\xb2\xd8\xbe\xaf\xc4"                             // "Restore failsafe"</front>
<front id="language_kanaH-92">#define MSG_REFRESH                         "\xd8\xcc\xda\xaf\xbc\xad"                                     // "Refresh"</front>
<front id="language_kanaH-93">#define MSG_WATCH                           "\xb2\xdd\xcc\xab"                                             // "Info screen"</front>
<front id="language_kanaH-94">#define MSG_PREPARE                         "\xbc\xde\xad\xdd\xcb\xde\xbe\xaf\xc3\xb2"                     // "Prepare"</front>
<front id="language_kanaH-95">#define MSG_TUNE                            "\xc1\xae\xb3\xbe\xb2"                                         // "Tune"</front>
<front id="language_kanaH-96">#define MSG_PAUSE_PRINT                     "\xb2\xc1\xbc\xde\xc3\xb2\xbc"                                 // "Pause print"</front>
<front id="language_kanaH-97">#define MSG_RESUME_PRINT                    "\xcc\xdf\xd8\xdd\xc4\xbb\xb2\xb6\xb2"                         // "Resume print"</front>
<front id="language_kanaH-98">#define MSG_STOP_PRINT                      "\xcc\xdf\xd8\xdd\xc4\xc3\xb2\xbc"                             // "Stop print"</front>
<front id="language_kanaH-99">#define MSG_CARD_MENU                       "SD\xb6\xb0\xc4\xde\xb6\xd7\xcc\xdf\xd8\xdd\xc4"               // "Print from SD"</front>
<front id="language_kanaH-100">#define MSG_NO_CARD                         "SD\xb6\xb0\xc4\xde\xb6\xde\xb1\xd8\xcf\xbe\xdd"               // "No SD card"</front>
<front id="language_kanaH-101">#define MSG_DWELL                           "\xbd\xd8\xb0\xcc\xdf"                                         // "Sleep..."</front>
<front id="language_kanaH-102">#define MSG_USERWAIT                        "\xbc\xca\xde\xd7\xb9\xb5\xcf\xc1\xb8\xc0\xde\xbb\xb2"         // "Wait for user..."</front>
<front id="language_kanaH-103">#define MSG_RESUMING                        "\xcc\xdf\xd8\xdd\xc4\xbb\xb2\xb6\xb2"                         // "Resuming print"</front>
<front id="language_kanaH-104">#define MSG_PRINT_ABORTED                   "\xcc\xdf\xd8\xdd\xc4\xc1\xad\xb3\xbc\xbb\xda\xcf\xbc\xc0"     // "Print aborted"</front>
<front id="language_kanaH-105">#define MSG_NO_MOVE                         "\xb3\xba\xde\xb7\xcf\xbe\xdd"                                 // "No move."</front>
<front id="language_kanaH-106">#define MSG_KILLED                          "\xbc\xae\xb3\xb7\xae"                                         // "KILLED. "</front>
<front id="language_kanaH-107">#define MSG_STOPPED                         "\xc3\xb2\xbc\xbc\xcf\xbc\xc0"                                 // "STOPPED. "</front>
<front id="language_kanaH-108">#define MSG_CONTROL_RETRACT                 "Retract mm"</front>
<front id="language_kanaH-109">#define MSG_CONTROL_RETRACT_SWAP            "Swap Re.mm"</front>
<front id="language_kanaH-110">#define MSG_CONTROL_RETRACTF                "Retract  V"</front>
<front id="language_kanaH-111">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_kanaH-112">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_kanaH-113">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"</front>
<front id="language_kanaH-114">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_kanaH-115">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_kanaH-116">#define MSG_FILAMENTCHANGE                  "\xcc\xa8\xd7\xd2\xdd\xc4\xba\xb3\xb6\xdd"                     // "Change filament"</front>
<front id="language_kanaH-117">#define MSG_INIT_SDCARD                     "SD\xb6\xb0\xc4\xde\xbb\xb2\xd6\xd0\xba\xd0"                   // "Init. SD card"</front>
<front id="language_kanaH-118">#define MSG_CNG_SDCARD                      "SD\xb6\xb0\xc4\xde\xba\xb3\xb6\xdd"                           // "Change SD card"</front>
<front id="language_kanaH-119">#define MSG_ZPROBE_OUT                      "Z\xcc\xdf\xdb\xb0\xcc\xde \xcd\xde\xaf\xc4\xee\xb6\xde\xb2"   // "Z probe out. bed"</front>
<front id="language_kanaH-120">#define MSG_POSITION_UNKNOWN                "\xb9\xde\xdd\xc3\xdd\xcaXY\xb2\xc4\xde\xb3\xba\xdeZ"           // "Home X/Y before Z"</front>
<front id="language_kanaH-121">#define MSG_ZPROBE_ZOFFSET                  "Z\xb5\xcc\xbe\xaf\xc4"                                        // "Z Offset"</front>
<front id="language_kanaH-122">#define MSG_BABYSTEP_X                      "\xcb\xde\xc4\xde\xb3 X"                                       // "Babystep X"</front>
<front id="language_kanaH-123">#define MSG_BABYSTEP_Y                      "\xcb\xde\xc4\xde\xb3 Y"                                       // "Babystep Y"</front>
<front id="language_kanaH-124">#define MSG_BABYSTEP_Z                      "\xcb\xde\xc4\xde\xb3 Z"                                       // "Babystep Z"</front>
<front id="language_kanaH-125">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_kanaH-126">#define MSG_END_HOUR                        "hours"</front>
<front id="language_kanaH-127">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_kanaH-128"></front>
<front id="language_kanaH-129">/* These are from language.h. PLEASE DON'T TRANSLATE! All translatable messages can be found in language_en.h</front>
<front id="language_kanaH-130">#define MSG_HEATING                         "\xb6\xc8\xc2\xc1\xad\xb3..."                                  // "Heating..."</front>
<front id="language_kanaH-131">#define MSG_HEATING_COMPLETE                "\xb6\xc8\xc2\xb6\xdd\xd8x\xae\xb3"                            // "Heating done."</front>
<front id="language_kanaH-132">#define MSG_BED_HEATING                     "\xcd\xde\xaf\xc4\xde\xb6\xc8\xc2\xc1\xad\xb3"                 // "Bed Heating."</front>
<front id="language_kanaH-133">#define MSG_BED_DONE                        "\xcd\xde\xaf\xc4\xde\xb6\xc8\xc2\xb6\xdd\xd8x\xae\xb3"        // "Bed done."</front>
<front id="language_kanaH-134">#define MSG_ENDSTOPS_HIT                    "endstops hit: "</front>
<front id="language_kanaH-135">                   ^ typho</front>
<front id="language_kanaH-136">*/</front>
<front id="language_kanaH-137"></front>
<front id="language_kanaH-138">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_kanaH-139">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_kanaH-140">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_kanaH-141">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_kanaH-142">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_kanaH-143">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_kanaH-144">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_kanaH-145"></front>
<front id="language_kanaH-146">#endif // LANGUAGE_KANA_H</front>
 </pre>
<h1 id="language_kana_utf8Htitle" >language_kana_utf8.h</h1>
<pre id="language_kana_utf8H"  class="prettyprint linenums"><front id="language_kana_utf8H-1">/**</front>
<front id="language_kana_utf8H-2"> * Japanese (Kana UTF8 version)</front>
<front id="language_kana_utf8H-3"> *</front>
<front id="language_kana_utf8H-4"> * LCD Menu Messages</front>
<front id="language_kana_utf8H-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_kana_utf8H-6"> *</front>
<front id="language_kana_utf8H-7"> */</front>
<front id="language_kana_utf8H-8"></front>
<front id="language_kana_utf8H-9">#ifndef LANGUAGE_KANA_UTF_H</front>
<front id="language_kana_utf8H-10">#define LANGUAGE_KANA_UTF_H</front>
<front id="language_kana_utf8H-11"></front>
<front id="language_kana_utf8H-12">#define MAPPER_E382E383</front>
<front id="language_kana_utf8H-13">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_kana_utf8H-14">//#define SIMULATE_ROMFONT</front>
<front id="language_kana_utf8H-15">#define DISPLAY_CHARSET_ISO10646_KANA</front>
<front id="language_kana_utf8H-16"></front>
<front id="language_kana_utf8H-17">// This is very crude replacement of the codes used in language_kana.h from somebody who really does not know what he is doing.</front>
<front id="language_kana_utf8H-18">// Just to show the potential benefit of unicode.</front>
<front id="language_kana_utf8H-19">// This translation can be improved by using the full charset of unicode codeblock U+30A0 to U+30FF.</front>
<front id="language_kana_utf8H-20"></front>
<front id="language_kana_utf8H-21">// </front>
<front id="language_kana_utf8H-22">#define WELCOME_MSG                         MACHINE_NAME " ready."</front>
<front id="language_kana_utf8H-23">#define MSG_SD_INSERTED                     " "          // "Card inserted"</front>
<front id="language_kana_utf8H-24">#define MSG_SD_REMOVED                      ""               // "Card removed"</front>
<front id="language_kana_utf8H-25">#define MSG_MAIN                            ""                        // "Main"</front>
<front id="language_kana_utf8H-26">#define MSG_AUTOSTART                       ""                   // "Autostart"</front>
<front id="language_kana_utf8H-27">#define MSG_DISABLE_STEPPERS                " "             // "Disable steppers"</front>
<front id="language_kana_utf8H-28">#define MSG_AUTO_HOME                       ""                // "Auto home"</front>
<front id="language_kana_utf8H-29">#define MSG_SET_HOME_OFFSETS                ""         // "Set home offsets"</front>
<front id="language_kana_utf8H-30">#define MSG_SET_ORIGIN                      ""                 // "Set origin"</front>
<front id="language_kana_utf8H-31">#define MSG_PREHEAT_PLA                     "PLA "                    // "Preheat PLA"</front>
<front id="language_kana_utf8H-32">#define MSG_PREHEAT_PLA_N                   MSG_PREHEAT_PLA " "</front>
<front id="language_kana_utf8H-33">#define MSG_PREHEAT_PLA_ALL                 MSG_PREHEAT_PLA " "      // " All"</front>
<front id="language_kana_utf8H-34">#define MSG_PREHEAT_PLA_BEDONLY             MSG_PREHEAT_PLA " "    // "Bed"</front>
<front id="language_kana_utf8H-35">#define MSG_PREHEAT_PLA_SETTINGS            MSG_PREHEAT_PLA " "     // "conf"</front>
<front id="language_kana_utf8H-36">#define MSG_PREHEAT_ABS                     "ABS "                    // "Preheat ABS"</front>
<front id="language_kana_utf8H-37">#define MSG_PREHEAT_ABS_N                   MSG_PREHEAT_ABS " "</front>
<front id="language_kana_utf8H-38">#define MSG_PREHEAT_ABS_ALL                 MSG_PREHEAT_ABS " "      // " All"</front>
<front id="language_kana_utf8H-39">#define MSG_PREHEAT_ABS_BEDONLY             MSG_PREHEAT_ABS " "    // "Bed"</front>
<front id="language_kana_utf8H-40">#define MSG_PREHEAT_ABS_SETTINGS            MSG_PREHEAT_ABS " "    // "conf"</front>
<front id="language_kana_utf8H-41">#define MSG_COOLDOWN                        ""                    // "Cooldown"</front>
<front id="language_kana_utf8H-42">#define MSG_SWITCH_PS_ON                    " "                 // "Switch power on"</front>
<front id="language_kana_utf8H-43">#define MSG_SWITCH_PS_OFF                   " "                 // "Switch power off"</front>
<front id="language_kana_utf8H-44">#define MSG_EXTRUDE                         ""                     // "Extrude"</front>
<front id="language_kana_utf8H-45">#define MSG_RETRACT                         ""                     // "Retract"</front>
<front id="language_kana_utf8H-46">#define MSG_MOVE_AXIS                       ""                   // "Move axis"</front>
<front id="language_kana_utf8H-47">#define MSG_MOVE_X                          "X "                 // "Move X"</front>
<front id="language_kana_utf8H-48">#define MSG_MOVE_Y                          "Y "                 // "Move Y"</front>
<front id="language_kana_utf8H-49">#define MSG_MOVE_Z                          "Z "                 // "Move Z"</front>
<front id="language_kana_utf8H-50">#define MSG_MOVE_E                          ""                // "Extruder"</front>
<front id="language_kana_utf8H-51">#define MSG_MOVE_01MM                       "0.1mm "                 // "Move 0.1mm"</front>
<front id="language_kana_utf8H-52">#define MSG_MOVE_1MM                        "  1mm "                 // "Move 1mm"</front>
<front id="language_kana_utf8H-53">#define MSG_MOVE_10MM                       " 10mm "                 // "Move 10mm"</front>
<front id="language_kana_utf8H-54">#define MSG_SPEED                           ""                     // "Speed"</front>
<front id="language_kana_utf8H-55">#define MSG_NOZZLE                          ""                       // "Nozzle"</front>
<front id="language_kana_utf8H-56">#define MSG_BED                             ""                     // "Bed"</front>
<front id="language_kana_utf8H-57">#define MSG_FAN_SPEED                       ""                    // "Fan speed"</front>
<front id="language_kana_utf8H-58">#define MSG_FLOW                            ""                     // "Flow"</front>
<front id="language_kana_utf8H-59">#define MSG_CONTROL                         ""                    // "Control"</front>
<front id="language_kana_utf8H-60">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_kana_utf8H-61">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_kana_utf8H-62">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_kana_utf8H-63">#define MSG_AUTOTEMP                        ""                  // "Autotemp"</front>
<front id="language_kana_utf8H-64">#define MSG_ON                              "On "</front>
<front id="language_kana_utf8H-65">#define MSG_OFF                             "Off"</front>
<front id="language_kana_utf8H-66">#define MSG_PID_P                           "PID-P"</front>
<front id="language_kana_utf8H-67">#define MSG_PID_I                           "PID-I"</front>
<front id="language_kana_utf8H-68">#define MSG_PID_D                           "PID-D"</front>
<front id="language_kana_utf8H-69">#define MSG_PID_C                           "PID-C"</front>
<front id="language_kana_utf8H-70">#define MSG_ACC                             ""                     // "Accel"</front>
<front id="language_kana_utf8H-71">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_kana_utf8H-72">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_kana_utf8H-73">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_kana_utf8H-74">#define MSG_VMAX                            "Vmax "</front>
<front id="language_kana_utf8H-75">#define MSG_X                               "x"</front>
<front id="language_kana_utf8H-76">#define MSG_Y                               "y"</front>
<front id="language_kana_utf8H-77">#define MSG_Z                               "z"</front>
<front id="language_kana_utf8H-78">#define MSG_E                               "e"</front>
<front id="language_kana_utf8H-79">#define MSG_VMIN                            "Vmin"</front>
<front id="language_kana_utf8H-80">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_kana_utf8H-81">#define MSG_AMAX                            "Amax "</front>
<front id="language_kana_utf8H-82">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_kana_utf8H-83">#define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_kana_utf8H-84">#define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_kana_utf8H-85">#define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_kana_utf8H-86">#define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_kana_utf8H-87">#define MSG_TEMPERATURE                     ""                      // "Temperature"</front>
<front id="language_kana_utf8H-88">#define MSG_MOTION                          ""                // "Motion"</front>
<front id="language_kana_utf8H-89">#define MSG_VOLUMETRIC                      ""                    // "Filament"</front>
<front id="language_kana_utf8H-90">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_kana_utf8H-91">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_kana_utf8H-92">#define MSG_CONTRAST                        "LCD"                 // "LCD contrast"</front>
<front id="language_kana_utf8H-93">#define MSG_STORE_EPROM                     ""                 // "Store memory"</front>
<front id="language_kana_utf8H-94">#define MSG_LOAD_EPROM                      "ba"               // "Load memory"</front>
<front id="language_kana_utf8H-95">#define MSG_RESTORE_FAILSAFE                ""               // "Restore failsafe"</front>
<front id="language_kana_utf8H-96">#define MSG_REFRESH                         ""                  // "Refresh"</front>
<front id="language_kana_utf8H-97">#define MSG_WATCH                           ""                     // "Info screen"</front>
<front id="language_kana_utf8H-98">#define MSG_PREPARE                         ""             //"Prepare"</front>
<front id="language_kana_utf8H-99">#define MSG_TUNE                            ""                    // "Tune"</front>
<front id="language_kana_utf8H-100">#define MSG_PAUSE_PRINT                     ""                  // "Pause print"</front>
<front id="language_kana_utf8H-101">#define MSG_RESUME_PRINT                    ""                // "Resume print"</front>
<front id="language_kana_utf8H-102">#define MSG_STOP_PRINT                      ""                 // "Stop print"</front>
<front id="language_kana_utf8H-103">#define MSG_CARD_MENU                       "SD"            // "Print from SD"</front>
<front id="language_kana_utf8H-104">#define MSG_NO_CARD                         "SD"            // "No SD card"</front>
<front id="language_kana_utf8H-105">#define MSG_DWELL                           ""                     // "Sleep..."</front>
<front id="language_kana_utf8H-106">#define MSG_USERWAIT                        ""           // "Wait for user..."</front>
<front id="language_kana_utf8H-107">#define MSG_RESUMING                        ""                // "Resuming print"</front>
<front id="language_kana_utf8H-108">#define MSG_PRINT_ABORTED                   ""          // "Print aborted"</front>
<front id="language_kana_utf8H-109">#define MSG_NO_MOVE                         ""                  // "No move."</front>
<front id="language_kana_utf8H-110">#define MSG_KILLED                          ""                     // "KILLED. "</front>
<front id="language_kana_utf8H-111">#define MSG_STOPPED                         ""                  // "STOPPED. "</front>
<front id="language_kana_utf8H-112">#define MSG_CONTROL_RETRACT                 "Retract mm"</front>
<front id="language_kana_utf8H-113">#define MSG_CONTROL_RETRACT_SWAP            "Swap Re.mm"</front>
<front id="language_kana_utf8H-114">#define MSG_CONTROL_RETRACTF                "Retract  V"</front>
<front id="language_kana_utf8H-115">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_kana_utf8H-116">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_kana_utf8H-117">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "S UnRet+mm"</front>
<front id="language_kana_utf8H-118">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  V"</front>
<front id="language_kana_utf8H-119">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_kana_utf8H-120">#define MSG_FILAMENTCHANGE                  ""               // "Change filament"</front>
<front id="language_kana_utf8H-121">#define MSG_INIT_SDCARD                     "SD"              // "Init. SD card"</front>
<front id="language_kana_utf8H-122">#define MSG_CNG_SDCARD                      "SD"                // "Change SD card"</front>
<front id="language_kana_utf8H-123">#define MSG_ZPROBE_OUT                      "Z n"         // "Z probe out. bed"</front>
<front id="language_kana_utf8H-124">#define MSG_POSITION_UNKNOWN                "XYZ"           // "Home X/Y before Z"</front>
<front id="language_kana_utf8H-125">#define MSG_ZPROBE_ZOFFSET                  "Z"                   // "Z Offset"</front>
<front id="language_kana_utf8H-126">#define MSG_BABYSTEP_X                      " X"                    // "Babystep X"</front>
<front id="language_kana_utf8H-127">#define MSG_BABYSTEP_Y                      " Y"                    // "Babystep Y"</front>
<front id="language_kana_utf8H-128">#define MSG_BABYSTEP_Z                      " Z"                    // "Babystep Z"</front>
<front id="language_kana_utf8H-129">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_kana_utf8H-130">#define MSG_END_HOUR                        "hours"</front>
<front id="language_kana_utf8H-131">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_kana_utf8H-132"></front>
<front id="language_kana_utf8H-133">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_kana_utf8H-134">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_kana_utf8H-135">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_kana_utf8H-136">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_kana_utf8H-137">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_kana_utf8H-138">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_kana_utf8H-139">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_kana_utf8H-140"></front>
<front id="language_kana_utf8H-141">#endif // LANGUAGE_KANA_UTF_H</front>
 </pre>
<h1 id="language_nlHtitle" >language_nl.h</h1>
<pre id="language_nlH"  class="prettyprint linenums"><front id="language_nlH-1">/**</front>
<front id="language_nlH-2"> * Dutch</front>
<front id="language_nlH-3"> *</front>
<front id="language_nlH-4"> * LCD Menu Messages</front>
<front id="language_nlH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_nlH-6"> *</front>
<front id="language_nlH-7"> */</front>
<front id="language_nlH-8">#ifndef LANGUAGE_NL_H</front>
<front id="language_nlH-9">#define LANGUAGE_NL_H</front>
<front id="language_nlH-10"></front>
<front id="language_nlH-11">#define MAPPER_NON</front>
<front id="language_nlH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_nlH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_nlH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_nlH-15"></front>
<front id="language_nlH-16">#define WELCOME_MSG                         MACHINE_NAME " gereed."</front>
<front id="language_nlH-17">#define MSG_SD_INSERTED                     "Kaart ingestoken"</front>
<front id="language_nlH-18">#define MSG_SD_REMOVED                      "Kaart verwijderd"</front>
<front id="language_nlH-19">#define MSG_MAIN                            "Main"</front>
<front id="language_nlH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_nlH-21">#define MSG_DISABLE_STEPPERS                "Motoren uit"</front>
<front id="language_nlH-22">#define MSG_AUTO_HOME                       "Auto home"</front>
<front id="language_nlH-23">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_nlH-24">#define MSG_SET_ORIGIN                      "Nulpunt instellen"</front>
<front id="language_nlH-25">#define MSG_PREHEAT_PLA                     "PLA voorverwarmen"</front>
<front id="language_nlH-26">#define MSG_PREHEAT_PLA_N                   "PLA voorverw. "</front>
<front id="language_nlH-27">#define MSG_PREHEAT_PLA_ALL                 "PLA voorverw. aan"</front>
<front id="language_nlH-28">#define MSG_PREHEAT_PLA_BEDONLY             "PLA voorverw. Bed"</front>
<front id="language_nlH-29">#define MSG_PREHEAT_PLA_SETTINGS            "PLA verw. conf"</front>
<front id="language_nlH-30">#define MSG_PREHEAT_ABS                     "ABS voorverwarmen"</front>
<front id="language_nlH-31">#define MSG_PREHEAT_ABS_N                   "ABS voorverw. "</front>
<front id="language_nlH-32">#define MSG_PREHEAT_ABS_ALL                 "ABS voorverw. aan"</front>
<front id="language_nlH-33">#define MSG_PREHEAT_ABS_BEDONLY             "ABS voorverw. Bed"</front>
<front id="language_nlH-34">#define MSG_PREHEAT_ABS_SETTINGS            "ABS verw. conf"</front>
<front id="language_nlH-35">#define MSG_COOLDOWN                        "Afkoelen"</front>
<front id="language_nlH-36">#define MSG_SWITCH_PS_ON                    "Stroom aan"</front>
<front id="language_nlH-37">#define MSG_SWITCH_PS_OFF                   "Stroom uit"</front>
<front id="language_nlH-38">#define MSG_EXTRUDE                         "Extrude"</front>
<front id="language_nlH-39">#define MSG_RETRACT                         "Retract"</front>
<front id="language_nlH-40">#define MSG_MOVE_AXIS                       "As verplaatsen"</front>
<front id="language_nlH-41">#define MSG_MOVE_X                          "Verplaats X"</front>
<front id="language_nlH-42">#define MSG_MOVE_Y                          "Verplaats Y"</front>
<front id="language_nlH-43">#define MSG_MOVE_Z                          "Verplaats Z"</front>
<front id="language_nlH-44">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_nlH-45">#define MSG_MOVE_01MM                       "Verplaats 0.1mm"</front>
<front id="language_nlH-46">#define MSG_MOVE_1MM                        "Verplaats 1mm"</front>
<front id="language_nlH-47">#define MSG_MOVE_10MM                       "Verplaats 10mm"</front>
<front id="language_nlH-48">#define MSG_SPEED                           "Snelheid"</front>
<front id="language_nlH-49">#define MSG_NOZZLE                          "Nozzle"</front>
<front id="language_nlH-50">#define MSG_BED                             "Bed"</front>
<front id="language_nlH-51">#define MSG_FAN_SPEED                       "Fan snelheid"</front>
<front id="language_nlH-52">#define MSG_FLOW                            "Flow"</front>
<front id="language_nlH-53">#define MSG_CONTROL                         "Control"</front>
<front id="language_nlH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_nlH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_nlH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_nlH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_nlH-58">#define MSG_ON                              "Aan "</front>
<front id="language_nlH-59">#define MSG_OFF                             "Uit"</front>
<front id="language_nlH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_nlH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_nlH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_nlH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_nlH-64">#define MSG_ACC                             "Versn"</front>
<front id="language_nlH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_nlH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_nlH-67">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_nlH-68">#define MSG_VMAX                            "Vmax "</front>
<front id="language_nlH-69">#define MSG_X                               "x"</front>
<front id="language_nlH-70">#define MSG_Y                               "y"</front>
<front id="language_nlH-71">#define MSG_Z                               "z"</front>
<front id="language_nlH-72">#define MSG_E                               "e"</front>
<front id="language_nlH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_nlH-74">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_nlH-75">#define MSG_AMAX                            "Amax "</front>
<front id="language_nlH-76">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_nlH-77">#define MSG_XSTEPS                          "Xsteps/mm"</front>
<front id="language_nlH-78">#define MSG_YSTEPS                          "Ysteps/mm"</front>
<front id="language_nlH-79">#define MSG_ZSTEPS                          "Zsteps/mm"</front>
<front id="language_nlH-80">#define MSG_ESTEPS                          "Esteps/mm"</front>
<front id="language_nlH-81">#define MSG_TEMPERATURE                     "Temperatuur"</front>
<front id="language_nlH-82">#define MSG_MOTION                          "Beweging"</front>
<front id="language_nlH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_nlH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_nlH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_nlH-86">#define MSG_CONTRAST                        "LCD contrast"</front>
<front id="language_nlH-87">#define MSG_STORE_EPROM                     "Geheugen opslaan"</front>
<front id="language_nlH-88">#define MSG_LOAD_EPROM                      "Geheugen laden"</front>
<front id="language_nlH-89">#define MSG_RESTORE_FAILSAFE                "Noodstop reset"</front>
<front id="language_nlH-90">#define MSG_REFRESH                         "Ververs"</front>
<front id="language_nlH-91">#define MSG_WATCH                           "Info scherm"</front>
<front id="language_nlH-92">#define MSG_PREPARE                         "Voorbereiden"</front>
<front id="language_nlH-93">#define MSG_TUNE                            "Afstellen"</front>
<front id="language_nlH-94">#define MSG_PAUSE_PRINT                     "Print pauzeren"</front>
<front id="language_nlH-95">#define MSG_RESUME_PRINT                    "Print hervatten"</front>
<front id="language_nlH-96">#define MSG_STOP_PRINT                      "Print stoppen"</front>
<front id="language_nlH-97">#define MSG_CARD_MENU                       "Print van SD"</front>
<front id="language_nlH-98">#define MSG_NO_CARD                         "Geen SD kaart"</front>
<front id="language_nlH-99">#define MSG_DWELL                           "Slapen..."</front>
<front id="language_nlH-100">#define MSG_USERWAIT                        "Wachten..."</front>
<front id="language_nlH-101">#define MSG_RESUMING                        "Print hervatten"</front>
<front id="language_nlH-102">#define MSG_PRINT_ABORTED                   "Print afgebroken"</front>
<front id="language_nlH-103">#define MSG_NO_MOVE                         "Geen beweging."</front>
<front id="language_nlH-104">#define MSG_KILLED                          "AFGEBROKEN. "</front>
<front id="language_nlH-105">#define MSG_STOPPED                         "GESTOPT. "</front>
<front id="language_nlH-106">#define MSG_CONTROL_RETRACT                 "Retract mm"</front>
<front id="language_nlH-107">#define MSG_CONTROL_RETRACT_SWAP            "Ruil Retract mm"</front>
<front id="language_nlH-108">#define MSG_CONTROL_RETRACTF                "Retract  F"</front>
<front id="language_nlH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Hop mm"</front>
<front id="language_nlH-110">#define MSG_CONTROL_RETRACT_RECOVER         "UnRet +mm"</front>
<front id="language_nlH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Ruil UnRet +mm"</front>
<front id="language_nlH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "UnRet  F"</front>
<front id="language_nlH-113">#define MSG_AUTORETRACT                     "AutoRetr."</front>
<front id="language_nlH-114">#define MSG_FILAMENTCHANGE                  "Verv. Filament"</front>
<front id="language_nlH-115">#define MSG_INIT_SDCARD                     "Init. SD kaart"</front>
<front id="language_nlH-116">#define MSG_CNG_SDCARD                      "Verv. SD card"</front>
<front id="language_nlH-117">#define MSG_ZPROBE_OUT                      "Z probe uit. bed"</front>
<front id="language_nlH-118">#define MSG_POSITION_UNKNOWN                "Home X/Y voor Z"</front>
<front id="language_nlH-119">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_nlH-120">#define MSG_BABYSTEP_X                      "Babystap X"</front>
<front id="language_nlH-121">#define MSG_BABYSTEP_Y                      "Babystap Y"</front>
<front id="language_nlH-122">#define MSG_BABYSTEP_Z                      "Babystap Z"</front>
<front id="language_nlH-123">#define MSG_ENDSTOP_ABORT                   "Endstop afbr."</front>
<front id="language_nlH-124">#define MSG_END_HOUR                        "hours"</front>
<front id="language_nlH-125">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_nlH-126"></front>
<front id="language_nlH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_nlH-128">    #define MSG_DELTA_CALIBRATE             "Delta Calibratie"</front>
<front id="language_nlH-129">    #define MSG_DELTA_CALIBRATE_X           "Kalibreer X"</front>
<front id="language_nlH-130">    #define MSG_DELTA_CALIBRATE_Y           "Kalibreer Y"</front>
<front id="language_nlH-131">    #define MSG_DELTA_CALIBRATE_Z           "Kalibreer Z"</front>
<front id="language_nlH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Kalibreer Midden"</front>
<front id="language_nlH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_nlH-134"></front>
<front id="language_nlH-135">#endif // LANGUAGE_NL_H</front>
 </pre>
<h1 id="language_plHtitle" >language_pl.h</h1>
<pre id="language_plH"  class="prettyprint linenums"><front id="language_plH-1">/**</front>
<front id="language_plH-2"> * Polish</front>
<front id="language_plH-3"> *</front>
<front id="language_plH-4"> * LCD Menu Messages</front>
<front id="language_plH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_plH-6"> *</front>
<front id="language_plH-7"> */</front>
<front id="language_plH-8">#ifndef LANGUAGE_PL_H</front>
<front id="language_plH-9">#define LANGUAGE_PL_H</front>
<front id="language_plH-10"></front>
<front id="language_plH-11">#define MAPPER_NON</front>
<front id="language_plH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_plH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_plH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_plH-15"></front>
<front id="language_plH-16">#define WELCOME_MSG                         MACHINE_NAME " gotowy."</front>
<front id="language_plH-17">#define MSG_SD_INSERTED                     "Karta wlozona"</front>
<front id="language_plH-18">#define MSG_SD_REMOVED                      "Karta usunieta"</front>
<front id="language_plH-19">#define MSG_MAIN                            "Menu glowne"</front>
<front id="language_plH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_plH-21">#define MSG_DISABLE_STEPPERS                "Wylacz silniki"</front>
<front id="language_plH-22">#define MSG_AUTO_HOME                       "Auto. poz. zerowa"</front>
<front id="language_plH-23">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_plH-24">#define MSG_SET_ORIGIN                      "Ustaw punkt zero"</front>
<front id="language_plH-25">#define MSG_PREHEAT_PLA                     "Rozgrzej PLA"</front>
<front id="language_plH-26">#define MSG_PREHEAT_PLA_N                   "Rozgrzej PLA "</front>
<front id="language_plH-27">#define MSG_PREHEAT_PLA_ALL                 "Roz. PLA Wszystko"</front>
<front id="language_plH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Rozgrzej PLA Loze"</front>
<front id="language_plH-29">#define MSG_PREHEAT_PLA_SETTINGS            "Ustaw. rozg. PLA"</front>
<front id="language_plH-30">#define MSG_PREHEAT_ABS                     "Rozgrzej ABS"</front>
<front id="language_plH-31">#define MSG_PREHEAT_ABS_N                   "Rozgrzej ABS "</front>
<front id="language_plH-32">#define MSG_PREHEAT_ABS_ALL                 "Roz. ABS Wszystko"</front>
<front id="language_plH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Rozgrzej ABS Loze"</front>
<front id="language_plH-34">#define MSG_PREHEAT_ABS_SETTINGS            "Ustaw. rozg. ABS"</front>
<front id="language_plH-35">#define MSG_COOLDOWN                        "Chlodzenie"</front>
<front id="language_plH-36">#define MSG_SWITCH_PS_ON                    "Wlacz zasilacz"</front>
<front id="language_plH-37">#define MSG_SWITCH_PS_OFF                   "Wylacz zasilacz"</front>
<front id="language_plH-38">#define MSG_EXTRUDE                         "Ekstruzja"</front>
<front id="language_plH-39">#define MSG_RETRACT                         "Cofanie"</front>
<front id="language_plH-40">#define MSG_MOVE_AXIS                       "Ruch osi"</front>
<front id="language_plH-41">#define MSG_MOVE_X                          "Przesun w X"</front>
<front id="language_plH-42">#define MSG_MOVE_Y                          "Przesun w Y"</front>
<front id="language_plH-43">#define MSG_MOVE_Z                          "Przesun w Z"</front>
<front id="language_plH-44">#define MSG_MOVE_E                          "Ekstruzja (os E)"</front>
<front id="language_plH-45">#define MSG_MOVE_01MM                       "Przesuwaj co .1mm"</front>
<front id="language_plH-46">#define MSG_MOVE_1MM                        "Przesuwaj co 1mm"</front>
<front id="language_plH-47">#define MSG_MOVE_10MM                       "Przesuwaj co 10mm"</front>
<front id="language_plH-48">#define MSG_SPEED                           "Predkosc"</front>
<front id="language_plH-49">#define MSG_NOZZLE                          "Dysza"</front>
<front id="language_plH-50">#define MSG_BED                             "Loze"</front>
<front id="language_plH-51">#define MSG_FAN_SPEED                       "Obroty wiatraka"</front>
<front id="language_plH-52">#define MSG_FLOW                            "Przeplyw"</front>
<front id="language_plH-53">#define MSG_CONTROL                         "Ustawienia"</front>
<front id="language_plH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_plH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_plH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Mnoznik"</front>
<front id="language_plH-57">#define MSG_AUTOTEMP                        "Auto. temperatura"</front>
<front id="language_plH-58">#define MSG_ON                              "Wl. "</front>
<front id="language_plH-59">#define MSG_OFF                             "Wyl."</front>
<front id="language_plH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_plH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_plH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_plH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_plH-64">#define MSG_ACC                             "Przyspieszenie"</front>
<front id="language_plH-65">#define MSG_VXY_JERK                        "Zryw Vxy"</front>
<front id="language_plH-66">#define MSG_VZ_JERK                         "Zryw Vz"</front>
<front id="language_plH-67">#define MSG_VE_JERK                         "Zryw Ve"</front>
<front id="language_plH-68">#define MSG_VMAX                            "Vmax"</front>
<front id="language_plH-69">#define MSG_X                               "x"</front>
<front id="language_plH-70">#define MSG_Y                               "y"</front>
<front id="language_plH-71">#define MSG_Z                               "z"</front>
<front id="language_plH-72">#define MSG_E                               "e"</front>
<front id="language_plH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_plH-74">#define MSG_VTRAV_MIN                       "Vskok min"</front>
<front id="language_plH-75">#define MSG_AMAX                            "Amax"</front>
<front id="language_plH-76">#define MSG_A_RETRACT                       "A-wycofanie"</front>
<front id="language_plH-77">#define MSG_XSTEPS                          "krokiX/mm"</front>
<front id="language_plH-78">#define MSG_YSTEPS                          "krokiY/mm"</front>
<front id="language_plH-79">#define MSG_ZSTEPS                          "krokiZ/mm"</front>
<front id="language_plH-80">#define MSG_ESTEPS                          "krokiE/mm"</front>
<front id="language_plH-81">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_plH-82">#define MSG_MOTION                          "Ruch"</front>
<front id="language_plH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_plH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_plH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_plH-86">#define MSG_CONTRAST                        "Kontrast LCD"</front>
<front id="language_plH-87">#define MSG_STORE_EPROM                     "Zapisz w pamieci"</front>
<front id="language_plH-88">#define MSG_LOAD_EPROM                      "Wczytaj z pamieci"</front>
<front id="language_plH-89">#define MSG_RESTORE_FAILSAFE                "Ustaw. fabryczne"</front>
<front id="language_plH-90">#define MSG_REFRESH                         LCD_STR_REFRESH " Odswiez"</front>
<front id="language_plH-91">#define MSG_WATCH                           "Ekran glowny"</front>
<front id="language_plH-92">#define MSG_PREPARE                         "Przygotuj"</front>
<front id="language_plH-93">#define MSG_TUNE                            "Strojenie"</front>
<front id="language_plH-94">#define MSG_PAUSE_PRINT                     "Pauza"</front>
<front id="language_plH-95">#define MSG_RESUME_PRINT                    "Wznowienie"</front>
<front id="language_plH-96">#define MSG_STOP_PRINT                      "Stop"</front>
<front id="language_plH-97">#define MSG_CARD_MENU                       "Menu karty SD"</front>
<front id="language_plH-98">#define MSG_NO_CARD                         "Brak karty"</front>
<front id="language_plH-99">#define MSG_DWELL                           "Uspij..."</front>
<front id="language_plH-100">#define MSG_USERWAIT                        "Oczekiwanie..."</front>
<front id="language_plH-101">#define MSG_RESUMING                        "Wznawianie druku"</front>
<front id="language_plH-102">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_plH-103">#define MSG_NO_MOVE                         "Brak ruchu"</front>
<front id="language_plH-104">#define MSG_KILLED                          "Ubity. "</front>
<front id="language_plH-105">#define MSG_STOPPED                         "Zatrzymany. "</front>
<front id="language_plH-106">#define MSG_CONTROL_RETRACT                 "Wycofaj mm"</front>
<front id="language_plH-107">#define MSG_CONTROL_RETRACT_SWAP            "Z Wycof. mm"</front>
<front id="language_plH-108">#define MSG_CONTROL_RETRACTF                "Wycofaj  V"</front>
<front id="language_plH-109">#define MSG_CONTROL_RETRACT_ZLIFT           "Skok Z mm"</front>
<front id="language_plH-110">#define MSG_CONTROL_RETRACT_RECOVER         "Cof. wycof. +mm"</front>
<front id="language_plH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Z Cof. wyc. +mm"</front>
<front id="language_plH-112">#define MSG_CONTROL_RETRACT_RECOVERF        "Cof. wycof.  V"</front>
<front id="language_plH-113">#define MSG_AUTORETRACT                     "Auto. wycofanie"</front>
<front id="language_plH-114">#define MSG_FILAMENTCHANGE                  "Zmien filament"</front>
<front id="language_plH-115">#define MSG_INIT_SDCARD                     "Inicjal. karty SD"</front>
<front id="language_plH-116">#define MSG_CNG_SDCARD                      "Zmiana karty SD"</front>
<front id="language_plH-117">#define MSG_ZPROBE_OUT                      "Sonda Z za lozem"</front>
<front id="language_plH-118">#define MSG_POSITION_UNKNOWN                "Wroc w XY przed Z"</front>
<front id="language_plH-119">#define MSG_ZPROBE_ZOFFSET                  "Offset Z"</front>
<front id="language_plH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_plH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_plH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_plH-123">#define MSG_ENDSTOP_ABORT                   "Blad wyl. kranc."</front>
<front id="language_plH-124">#define MSG_END_HOUR                        "hours"</front>
<front id="language_plH-125">#define MSG_END_MINUTE                      "minutes"</front>
<front id="language_plH-126"></front>
<front id="language_plH-127"></front>
<front id="language_plH-128">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_plH-129">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_plH-130">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_plH-131">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_plH-132">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_plH-133">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_plH-134">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_plH-135"></front>
<front id="language_plH-136">#endif // LANGUAGE_PL_H</front>
 </pre>
<h1 id="language_pt-brHtitle" >language_pt-br.h</h1>
<pre id="language_pt-brH"  class="prettyprint linenums"><front id="language_pt-brH-1">/**</front>
<front id="language_pt-brH-2"> * Portuguese (Brazil)</front>
<front id="language_pt-brH-3"> *</front>
<front id="language_pt-brH-4"> * LCD Menu Messages</front>
<front id="language_pt-brH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_pt-brH-6"> *</front>
<front id="language_pt-brH-7"> */</front>
<front id="language_pt-brH-8">#ifndef LANGUAGE_PT_BR_H</front>
<front id="language_pt-brH-9">#define LANGUAGE_PT_BR_H</front>
<front id="language_pt-brH-10"></front>
<front id="language_pt-brH-11">#define MAPPER_NON</front>
<front id="language_pt-brH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_pt-brH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_pt-brH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_pt-brH-15"></front>
<front id="language_pt-brH-16">#define WELCOME_MSG							MACHINE_NAME " pronto."</front>
<front id="language_pt-brH-17">#define MSG_SD_INSERTED                     "Cartao inserido"</front>
<front id="language_pt-brH-18">#define MSG_SD_REMOVED                      "Cartao removido"</front>
<front id="language_pt-brH-19">#define MSG_MAIN                            " Menu principal"</front>
<front id="language_pt-brH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_pt-brH-21">#define MSG_DISABLE_STEPPERS                " Apagar motores"</front>
<front id="language_pt-brH-22">#define MSG_AUTO_HOME                       "Ir para origen"</front>
<front id="language_pt-brH-23">#define MSG_SET_HOME_OFFSETS                "Set home offsets"</front>
<front id="language_pt-brH-24">#define MSG_SET_ORIGIN                      "Estabelecer orig."</front>
<front id="language_pt-brH-25">#define MSG_PREHEAT_PLA                     "Pre-aquecer PLA"</front>
<front id="language_pt-brH-26">#define MSG_PREHEAT_PLA_N                   "Pre-aquecer PLA "</front>
<front id="language_pt-brH-27">#define MSG_PREHEAT_PLA_ALL                 "Pre-aq. PLA Tudo"</front>
<front id="language_pt-brH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"</front>
<front id="language_pt-brH-29">#define MSG_PREHEAT_PLA_SETTINGS            "PLA setting"</front>
<front id="language_pt-brH-30">#define MSG_PREHEAT_ABS                     "Pre-aquecer ABS"</front>
<front id="language_pt-brH-31">#define MSG_PREHEAT_ABS_N                   "Pre-aquecer ABS "</front>
<front id="language_pt-brH-32">#define MSG_PREHEAT_ABS_ALL                 "Pre-aq. ABS Tudo"</front>
<front id="language_pt-brH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"</front>
<front id="language_pt-brH-34">#define MSG_PREHEAT_ABS_SETTINGS            "ABS setting"</front>
<front id="language_pt-brH-35">#define MSG_COOLDOWN                        "Esfriar"</front>
<front id="language_pt-brH-36">#define MSG_SWITCH_PS_ON                    "Switch Power On"</front>
<front id="language_pt-brH-37">#define MSG_SWITCH_PS_OFF                   "Switch Power Off"</front>
<front id="language_pt-brH-38">#define MSG_EXTRUDE                         "Extrudar"</front>
<front id="language_pt-brH-39">#define MSG_RETRACT                         "Retrair"</front>
<front id="language_pt-brH-40">#define MSG_MOVE_AXIS                       "Mover eixo"</front>
<front id="language_pt-brH-41">#define MSG_MOVE_X                          "Move X"</front>
<front id="language_pt-brH-42">#define MSG_MOVE_Y                          "Move Y"</front>
<front id="language_pt-brH-43">#define MSG_MOVE_Z                          "Move Z"</front>
<front id="language_pt-brH-44">#define MSG_MOVE_E                          "Extruder"</front>
<front id="language_pt-brH-45">#define MSG_MOVE_01MM                       "Move 0.1mm"</front>
<front id="language_pt-brH-46">#define MSG_MOVE_1MM                        "Move 1mm"</front>
<front id="language_pt-brH-47">#define MSG_MOVE_10MM                       "Move 10mm"</front>
<front id="language_pt-brH-48">#define MSG_SPEED                           "Velocidade"</front>
<front id="language_pt-brH-49">#define MSG_NOZZLE                          LCD_STR_THERMOMETER " Nozzle"</front>
<front id="language_pt-brH-50">#define MSG_BED                             LCD_STR_THERMOMETER " Base"</front>
<front id="language_pt-brH-51">#define MSG_FAN_SPEED                       "Velocidade vento."</front>
<front id="language_pt-brH-52">#define MSG_FLOW                            "Fluxo"</front>
<front id="language_pt-brH-53">#define MSG_CONTROL                         "Controle"</front>
<front id="language_pt-brH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_pt-brH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_pt-brH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_pt-brH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_pt-brH-58">#define MSG_ON                              "On "</front>
<front id="language_pt-brH-59">#define MSG_OFF                             "Off"</front>
<front id="language_pt-brH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_pt-brH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_pt-brH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_pt-brH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_pt-brH-64">#define MSG_ACC                             "Acc"</front>
<front id="language_pt-brH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_pt-brH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_pt-brH-67">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_pt-brH-68">#define MSG_VMAX                            " Vmax "</front>
<front id="language_pt-brH-69">#define MSG_X                               "x"</front>
<front id="language_pt-brH-70">#define MSG_Y                               "y"</front>
<front id="language_pt-brH-71">#define MSG_Z                               "z"</front>
<front id="language_pt-brH-72">#define MSG_E                               "e"</front>
<front id="language_pt-brH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_pt-brH-74">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_pt-brH-75">#define MSG_AMAX                            "Amax "</front>
<front id="language_pt-brH-76">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_pt-brH-77">#define MSG_XSTEPS                          "Xpasso/mm"</front>
<front id="language_pt-brH-78">#define MSG_YSTEPS                          "Ypasso/mm"</front>
<front id="language_pt-brH-79">#define MSG_ZSTEPS                          "Zpasso/mm"</front>
<front id="language_pt-brH-80">#define MSG_ESTEPS                          "Epasso/mm"</front>
<front id="language_pt-brH-81">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_pt-brH-82">#define MSG_MOTION                          "Movimento"</front>
<front id="language_pt-brH-83">#define MSG_VOLUMETRIC                      "Filament"</front>
<front id="language_pt-brH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_pt-brH-85">#define MSG_FILAMENT_DIAM                   "Fil. Dia."</front>
<front id="language_pt-brH-86">#define MSG_CONTRAST                        "Contrast"</front>
<front id="language_pt-brH-87">#define MSG_STORE_EPROM                     "Guardar memoria"</front>
<front id="language_pt-brH-88">#define MSG_LOAD_EPROM                      "Carregar memoria"</front>
<front id="language_pt-brH-89">#define MSG_RESTORE_FAILSAFE                "Rest. de emergen."</front>
<front id="language_pt-brH-90">#define MSG_REFRESH                         LCD_STR_REFRESH " Recarregar"</front>
<front id="language_pt-brH-91">#define MSG_WATCH                           "Monitorar"</front>
<front id="language_pt-brH-92">#define MSG_PREPARE                         "Preparar"</front>
<front id="language_pt-brH-93">#define MSG_TUNE                            "Tune"</front>
<front id="language_pt-brH-94">#define MSG_PAUSE_PRINT                     "Pausar impressao"</front>
<front id="language_pt-brH-95">#define MSG_RESUME_PRINT                    "Resumir impressao"</front>
<front id="language_pt-brH-96">#define MSG_STOP_PRINT                      "Parar impressao"</front>
<front id="language_pt-brH-97">#define MSG_CARD_MENU                       "Menu cartao SD"</front>
<front id="language_pt-brH-98">#define MSG_NO_CARD                         "Sem cartao SD"</front>
<front id="language_pt-brH-99">#define MSG_DWELL                           "Repouso..."</front>
<front id="language_pt-brH-100">#define MSG_USERWAIT                        "Esperando ordem"</front>
<front id="language_pt-brH-101">#define MSG_RESUMING                        "Resuming print"</front>
<front id="language_pt-brH-102">#define MSG_PRINT_ABORTED                   "Print aborted"</front>
<front id="language_pt-brH-103">#define MSG_NO_MOVE                         "Sem movimento"</front>
<front id="language_pt-brH-104">#define MSG_KILLED                          "PARADA DE EMERG."</front>
<front id="language_pt-brH-105">#define MSG_STOPPED                         "PARADA. "</front>
<front id="language_pt-brH-106">#define MSG_CONTROL_RETRACT                 " Retrair mm"</front>
<front id="language_pt-brH-107">#define MSG_CONTROL_RETRACT_SWAP            "Troca Retrair mm"</front>
<front id="language_pt-brH-108">#define MSG_CONTROL_RETRACTF                " Retrair  V"</front>
<front id="language_pt-brH-109">#define MSG_CONTROL_RETRACT_ZLIFT           " Levantar mm"</front>
<front id="language_pt-brH-110">#define MSG_CONTROL_RETRACT_RECOVER         " DesRet +mm"</front>
<front id="language_pt-brH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Troca DesRet +mm"</front>
<front id="language_pt-brH-112">#define MSG_CONTROL_RETRACT_RECOVERF        " DesRet  V"</front>
<front id="language_pt-brH-113">#define MSG_AUTORETRACT                     " AutoRetr."</front>
<front id="language_pt-brH-114">#define MSG_FILAMENTCHANGE                  "Change filament"</front>
<front id="language_pt-brH-115">#define MSG_INIT_SDCARD                     "Init. SD-Card"</front>
<front id="language_pt-brH-116">#define MSG_CNG_SDCARD                      "Change SD-Card"</front>
<front id="language_pt-brH-117">#define MSG_ZPROBE_OUT                      "Son. fora da mesa"</front>
<front id="language_pt-brH-118">#define MSG_POSITION_UNKNOWN                "XY antes de Z"</front>
<front id="language_pt-brH-119">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_pt-brH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_pt-brH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_pt-brH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_pt-brH-123">#define MSG_ENDSTOP_ABORT                   "Endstop abort"</front>
<front id="language_pt-brH-124">#define MSG_END_HOUR                        "horas"</front>
<front id="language_pt-brH-125">#define MSG_END_MINUTE                      "minutos"</front>
<front id="language_pt-brH-126"></front>
<front id="language_pt-brH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_pt-brH-128">    #define MSG_DELTA_CALIBRATE             "Delta Calibration"</front>
<front id="language_pt-brH-129">    #define MSG_DELTA_CALIBRATE_X           "Calibrate X"</front>
<front id="language_pt-brH-130">    #define MSG_DELTA_CALIBRATE_Y           "Calibrate Y"</front>
<front id="language_pt-brH-131">    #define MSG_DELTA_CALIBRATE_Z           "Calibrate Z"</front>
<front id="language_pt-brH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrate Center"</front>
<front id="language_pt-brH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_pt-brH-134"></front>
<front id="language_pt-brH-135">#endif // LANGUAGE_PT_BR_H</front>
 </pre>
<h1 id="language_ptHtitle" >language_pt.h</h1>
<pre id="language_ptH"  class="prettyprint linenums"><front id="language_ptH-1">/**</front>
<front id="language_ptH-2"> * Portuguese</front>
<front id="language_ptH-3"> *</front>
<front id="language_ptH-4"> * LCD Menu Messages</front>
<front id="language_ptH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_ptH-6"> *</front>
<front id="language_ptH-7"> */</front>
<front id="language_ptH-8">#ifndef LANGUAGE_PT_H</front>
<front id="language_ptH-9">#define LANGUAGE_PT_H</front>
<front id="language_ptH-10"></front>
<front id="language_ptH-11">#define MAPPER_NON</front>
<front id="language_ptH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_ptH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_ptH-14">#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_ptH-15"></front>
<front id="language_ptH-16">#define WELCOME_MSG                         MACHINE_NAME " pronto."</front>
<front id="language_ptH-17">#define MSG_SD_INSERTED                     "Cartao inserido"</front>
<front id="language_ptH-18">#define MSG_SD_REMOVED                      "Cartao removido"</front>
<front id="language_ptH-19">#define MSG_MAIN                            " Menu principal"</front>
<front id="language_ptH-20">#define MSG_AUTOSTART                       "Autostart"</front>
<front id="language_ptH-21">#define MSG_DISABLE_STEPPERS                " Desligar motores"</front>
<front id="language_ptH-22">#define MSG_AUTO_HOME                       "Ir para home"</front>
<front id="language_ptH-23">#define MSG_SET_HOME_OFFSETS                "Def. home offsets"</front>
<front id="language_ptH-24">#define MSG_SET_ORIGIN                      "Estabelecer orig."</front>
<front id="language_ptH-25">#define MSG_PREHEAT_PLA                     "Pre-aquecer PLA"</front>
<front id="language_ptH-26">#define MSG_PREHEAT_PLA_N                   "Pre-aquecer PLA "</front>
<front id="language_ptH-27">#define MSG_PREHEAT_PLA_ALL                 "Pre-aq. PLA Tudo"</front>
<front id="language_ptH-28">#define MSG_PREHEAT_PLA_BEDONLY             "Pre-aq. PLA " LCD_STR_THERMOMETER "Base"</front>
<front id="language_ptH-29">#define MSG_PREHEAT_PLA_SETTINGS            "PLA definicoes"</front>
<front id="language_ptH-30">#define MSG_PREHEAT_ABS                     "Pre-aquecer ABS"</front>
<front id="language_ptH-31">#define MSG_PREHEAT_ABS_N                   "Pre-aquecer ABS "</front>
<front id="language_ptH-32">#define MSG_PREHEAT_ABS_ALL                 "Pre-aq. ABS Tudo"</front>
<front id="language_ptH-33">#define MSG_PREHEAT_ABS_BEDONLY             "Pre-aq. ABS " LCD_STR_THERMOMETER "Base"</front>
<front id="language_ptH-34">#define MSG_PREHEAT_ABS_SETTINGS            "ABS definicoes"</front>
<front id="language_ptH-35">#define MSG_COOLDOWN                        "Arrefecer"</front>
<front id="language_ptH-36">#define MSG_SWITCH_PS_ON                    "Ligar"</front>
<front id="language_ptH-37">#define MSG_SWITCH_PS_OFF                   "Desligar"</front>
<front id="language_ptH-38">#define MSG_EXTRUDE                         "Extrudir"</front>
<front id="language_ptH-39">#define MSG_RETRACT                         "Retrair"</front>
<front id="language_ptH-40">#define MSG_MOVE_AXIS                       "Mover eixo"</front>
<front id="language_ptH-41">#define MSG_MOVE_X                          "Mover X"</front>
<front id="language_ptH-42">#define MSG_MOVE_Y                          "Mover Y"</front>
<front id="language_ptH-43">#define MSG_MOVE_Z                          "Mover Z"</front>
<front id="language_ptH-44">#define MSG_MOVE_E                          "Extrusor"</front>
<front id="language_ptH-45">#define MSG_MOVE_01MM                       "Mover 0.1mm"</front>
<front id="language_ptH-46">#define MSG_MOVE_1MM                        "Mover 1mm"</front>
<front id="language_ptH-47">#define MSG_MOVE_10MM                       "Mover 10mm"</front>
<front id="language_ptH-48">#define MSG_SPEED                           "Velocidade"</front>
<front id="language_ptH-49">#define MSG_NOZZLE                          LCD_STR_THERMOMETER "Bico"</front>
<front id="language_ptH-50">#define MSG_BED                             LCD_STR_THERMOMETER "Base"</front>
<front id="language_ptH-51">#define MSG_FAN_SPEED                       "Velocidade do ar."</front>
<front id="language_ptH-52">#define MSG_FLOW                            "Fluxo"</front>
<front id="language_ptH-53">#define MSG_CONTROL                         "Controlo"</front>
<front id="language_ptH-54">#define MSG_MIN                             LCD_STR_THERMOMETER " Min"</front>
<front id="language_ptH-55">#define MSG_MAX                             LCD_STR_THERMOMETER " Max"</front>
<front id="language_ptH-56">#define MSG_FACTOR                          LCD_STR_THERMOMETER " Fact"</front>
<front id="language_ptH-57">#define MSG_AUTOTEMP                        "Autotemp"</front>
<front id="language_ptH-58">#define MSG_ON                              "On "</front>
<front id="language_ptH-59">#define MSG_OFF                             "Off"</front>
<front id="language_ptH-60">#define MSG_PID_P                           "PID-P"</front>
<front id="language_ptH-61">#define MSG_PID_I                           "PID-I"</front>
<front id="language_ptH-62">#define MSG_PID_D                           "PID-D"</front>
<front id="language_ptH-63">#define MSG_PID_C                           "PID-C"</front>
<front id="language_ptH-64">#define MSG_ACC                             "Acc"</front>
<front id="language_ptH-65">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_ptH-66">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_ptH-67">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_ptH-68">#define MSG_VMAX                            " Vmax "</front>
<front id="language_ptH-69">#define MSG_X                               "x"</front>
<front id="language_ptH-70">#define MSG_Y                               "y"</front>
<front id="language_ptH-71">#define MSG_Z                               "z"</front>
<front id="language_ptH-72">#define MSG_E                               "e"</front>
<front id="language_ptH-73">#define MSG_VMIN                            "Vmin"</front>
<front id="language_ptH-74">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_ptH-75">#define MSG_AMAX                            "Amax "</front>
<front id="language_ptH-76">#define MSG_A_RETRACT                       "A-retract"</front>
<front id="language_ptH-77">#define MSG_XSTEPS                          "Xpasso/mm"</front>
<front id="language_ptH-78">#define MSG_YSTEPS                          "Ypasso/mm"</front>
<front id="language_ptH-79">#define MSG_ZSTEPS                          "Zpasso/mm"</front>
<front id="language_ptH-80">#define MSG_ESTEPS                          "Epasso/mm"</front>
<front id="language_ptH-81">#define MSG_TEMPERATURE                     "Temperatura"</front>
<front id="language_ptH-82">#define MSG_MOTION                          "Movimento"</front>
<front id="language_ptH-83">#define MSG_VOLUMETRIC                      "Filamento"</front>
<front id="language_ptH-84">#define MSG_VOLUMETRIC_ENABLED              "E in mm3"</front>
<front id="language_ptH-85">#define MSG_FILAMENT_DIAM                   "Fil. Diam."</front>
<front id="language_ptH-86">#define MSG_CONTRAST                        "Contraste"</front>
<front id="language_ptH-87">#define MSG_STORE_EPROM                     "Guardar na memoria"</front>
<front id="language_ptH-88">#define MSG_LOAD_EPROM                      "Carregar da memoria"</front>
<front id="language_ptH-89">#define MSG_RESTORE_FAILSAFE                "Rest. de emergen."</front>
<front id="language_ptH-90">#define MSG_REFRESH                         LCD_STR_REFRESH " Recarregar"</front>
<front id="language_ptH-91">#define MSG_WATCH                           "Monitorar"</front>
<front id="language_ptH-92">#define MSG_PREPARE                         "Preparar"</front>
<front id="language_ptH-93">#define MSG_TUNE                            "Afinar"</front>
<front id="language_ptH-94">#define MSG_PAUSE_PRINT                     "Pausar impressao"</front>
<front id="language_ptH-95">#define MSG_RESUME_PRINT                    "Resumir impressao"</front>
<front id="language_ptH-96">#define MSG_STOP_PRINT                      "Parar impressao"</front>
<front id="language_ptH-97">#define MSG_CARD_MENU                       "Menu cartao SD"</front>
<front id="language_ptH-98">#define MSG_NO_CARD                         "Sem cartao SD"</front>
<front id="language_ptH-99">#define MSG_DWELL                           "Repouso..."</front>
<front id="language_ptH-100">#define MSG_USERWAIT                        "A espera de ordem"</front>
<front id="language_ptH-101">#define MSG_RESUMING                        "Resumir impressao"</front>
<front id="language_ptH-102">#define MSG_PRINT_ABORTED                   "Impr. Cancelada"</front>
<front id="language_ptH-103">#define MSG_NO_MOVE                         "Sem movimento"</front>
<front id="language_ptH-104">#define MSG_KILLED                          "INTRRP. DE EMERG."</front>
<front id="language_ptH-105">#define MSG_STOPPED                         "PARADO. "</front>
<front id="language_ptH-106">#define MSG_CONTROL_RETRACT                 " Retrair mm"</front>
<front id="language_ptH-107">#define MSG_CONTROL_RETRACT_SWAP            "Troca Retrair mm"</front>
<front id="language_ptH-108">#define MSG_CONTROL_RETRACTF                " Retrair  V"</front>
<front id="language_ptH-109">#define MSG_CONTROL_RETRACT_ZLIFT           " Levantar mm"</front>
<front id="language_ptH-110">#define MSG_CONTROL_RETRACT_RECOVER         " DesRet +mm"</front>
<front id="language_ptH-111">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "Troca DesRet +mm"</front>
<front id="language_ptH-112">#define MSG_CONTROL_RETRACT_RECOVERF        " DesRet  V"</front>
<front id="language_ptH-113">#define MSG_AUTORETRACT                     " AutoRetr."</front>
<front id="language_ptH-114">#define MSG_FILAMENTCHANGE                  "Trocar filamento"</front>
<front id="language_ptH-115">#define MSG_INIT_SDCARD                     "Inic. SD-Card"</front>
<front id="language_ptH-116">#define MSG_CNG_SDCARD                      "Trocar SD-Card"</front>
<front id="language_ptH-117">#define MSG_ZPROBE_OUT                      "Sens. fora da Base"</front>
<front id="language_ptH-118">#define MSG_POSITION_UNKNOWN                "XY antes de Z"</front>
<front id="language_ptH-119">#define MSG_ZPROBE_ZOFFSET                  "Z Offset"</front>
<front id="language_ptH-120">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_ptH-121">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_ptH-122">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_ptH-123">#define MSG_ENDSTOP_ABORT                   "Endstop abort."</front>
<front id="language_ptH-124">#define MSG_END_HOUR                        "horas"</front>
<front id="language_ptH-125">#define MSG_END_MINUTE                      "minutos"</front>
<front id="language_ptH-126"></front>
<front id="language_ptH-127">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_ptH-128">    #define MSG_DELTA_CALIBRATE             "Delta Calibracao"</front>
<front id="language_ptH-129">    #define MSG_DELTA_CALIBRATE_X           "Calibrar X"</front>
<front id="language_ptH-130">    #define MSG_DELTA_CALIBRATE_Y           "Calibrar Y"</front>
<front id="language_ptH-131">    #define MSG_DELTA_CALIBRATE_Z           "Calibrar Z"</front>
<front id="language_ptH-132">    #define MSG_DELTA_CALIBRATE_CENTER      "Calibrar Centro"</front>
<front id="language_ptH-133">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_ptH-134"></front>
<front id="language_ptH-135">#endif // LANGUAGE_PT_H</front>
 </pre>
<h1 id="language_ruHtitle" >language_ru.h</h1>
<pre id="language_ruH"  class="prettyprint linenums"><front id="language_ruH-1">/**</front>
<front id="language_ruH-2"> * Russian</front>
<front id="language_ruH-3"> *</front>
<front id="language_ruH-4"> * LCD Menu Messages</front>
<front id="language_ruH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_ruH-6"> *</front>
<front id="language_ruH-7"> */</front>
<front id="language_ruH-8">#ifndef LANGUAGE_RU_H</front>
<front id="language_ruH-9">#define LANGUAGE_RU_H</front>
<front id="language_ruH-10"></front>
<front id="language_ruH-11">#define MAPPER_D0D1                // For Cyrillic</front>
<front id="language_ruH-12">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_ruH-13">//#define SIMULATE_ROMFONT</front>
<front id="language_ruH-14">#define DISPLAY_CHARSET_ISO10646_5</front>
<front id="language_ruH-15"></front>
<front id="language_ruH-16">#define WELCOME_MSG                         MACHINE_NAME " ."</front>
<front id="language_ruH-17">#define MSG_SD_INSERTED                     " "</front>
<front id="language_ruH-18">#define MSG_SD_REMOVED                      " "</front>
<front id="language_ruH-19">#define MSG_MAIN                            ""</front>
<front id="language_ruH-20">#define MSG_AUTOSTART                       ""</front>
<front id="language_ruH-21">#define MSG_DISABLE_STEPPERS                ". "</front>
<front id="language_ruH-22">#define MSG_AUTO_HOME                       ""</front>
<front id="language_ruH-23">#define MSG_SET_HOME_OFFSETS                " "</front>
<front id="language_ruH-24">#define MSG_SET_ORIGIN                      " "</front>
<front id="language_ruH-25">#define MSG_PREHEAT_PLA                     " PLA"</front>
<front id="language_ruH-26">#define MSG_PREHEAT_PLA_N                   " PLA  "</front>
<front id="language_ruH-27">#define MSG_PREHEAT_PLA_ALL                 " PLA "</front>
<front id="language_ruH-28">#define MSG_PREHEAT_PLA_BEDONLY             " PLA "</front>
<front id="language_ruH-29">#define MSG_PREHEAT_PLA_SETTINGS            " PLA"</front>
<front id="language_ruH-30">#define MSG_PREHEAT_ABS                     " ABS"</front>
<front id="language_ruH-31">#define MSG_PREHEAT_ABS_N                   " ABS  "</front>
<front id="language_ruH-32">#define MSG_PREHEAT_ABS_ALL                 " ABS "</front>
<front id="language_ruH-33">#define MSG_PREHEAT_ABS_BEDONLY             " ABS "</front>
<front id="language_ruH-34">#define MSG_PREHEAT_ABS_SETTINGS            " ABS"</front>
<front id="language_ruH-35">#define MSG_COOLDOWN                        ""</front>
<front id="language_ruH-36">#define MSG_SWITCH_PS_ON                    " "</front>
<front id="language_ruH-37">#define MSG_SWITCH_PS_OFF                   " "</front>
<front id="language_ruH-38">#define MSG_EXTRUDE                         ""</front>
<front id="language_ruH-39">#define MSG_RETRACT                         ""</front>
<front id="language_ruH-40">#define MSG_MOVE_AXIS                       "  "</front>
<front id="language_ruH-41">#define MSG_MOVE_X                          "  X"</front>
<front id="language_ruH-42">#define MSG_MOVE_Y                          "  Y"</front>
<front id="language_ruH-43">#define MSG_MOVE_Z                          "  Z"</front>
<front id="language_ruH-44">#define MSG_MOVE_E                          ""</front>
<front id="language_ruH-45">#define MSG_MOVE_01MM                       " XYZ 0.1mm"</front>
<front id="language_ruH-46">#define MSG_MOVE_1MM                        " XYZ 1mm"</front>
<front id="language_ruH-47">#define MSG_MOVE_10MM                       " XY 10mm"</front>
<front id="language_ruH-48">#define MSG_LEVEL_BED                       " "</front>
<front id="language_ruH-49">#define MSG_SPEED                           ""</front>
<front id="language_ruH-50">#define MSG_NOZZLE                          LCD_STR_THERMOMETER " "</front>
<front id="language_ruH-51">#define MSG_BED                             LCD_STR_THERMOMETER " "</front>
<front id="language_ruH-52">#define MSG_FAN_SPEED                       ""</front>
<front id="language_ruH-53">#define MSG_FLOW                            ""</front>
<front id="language_ruH-54">#define MSG_CONTROL                         ""</front>
<front id="language_ruH-55">#define MSG_MIN                             LCD_STR_THERMOMETER " "</front>
<front id="language_ruH-56">#define MSG_MAX                             LCD_STR_THERMOMETER " "</front>
<front id="language_ruH-57">#define MSG_FACTOR                          LCD_STR_THERMOMETER " "</front>
<front id="language_ruH-58">#define MSG_AUTOTEMP                        ""</front>
<front id="language_ruH-59">#define MSG_ON                              ". "</front>
<front id="language_ruH-60">#define MSG_OFF                             ". "</front>
<front id="language_ruH-61">#define MSG_PID_P                           "PID-P"</front>
<front id="language_ruH-62">#define MSG_PID_I                           "PID-I"</front>
<front id="language_ruH-63">#define MSG_PID_D                           "PID-D"</front>
<front id="language_ruH-64">#define MSG_PID_C                           "PID-C"</front>
<front id="language_ruH-65">#define MSG_ACC                             "Acc"</front>
<front id="language_ruH-66">#define MSG_VXY_JERK                        "Vxy-jerk"</front>
<front id="language_ruH-67">#define MSG_VZ_JERK                         "Vz-jerk"</front>
<front id="language_ruH-68">#define MSG_VE_JERK                         "Ve-jerk"</front>
<front id="language_ruH-69">#define MSG_VMAX                            "Vmax "</front>
<front id="language_ruH-70">#define MSG_X                               "x"</front>
<front id="language_ruH-71">#define MSG_Y                               "y"</front>
<front id="language_ruH-72">#define MSG_Z                               "z"</front>
<front id="language_ruH-73">#define MSG_E                               "e"</front>
<front id="language_ruH-74">#define MSG_VMIN                            "Vmin"</front>
<front id="language_ruH-75">#define MSG_VTRAV_MIN                       "VTrav min"</front>
<front id="language_ruH-76">#define MSG_AMAX                            "Amax"</front>
<front id="language_ruH-77">#define MSG_A_RETRACT                       "A-"</front>
<front id="language_ruH-78">#define MSG_XSTEPS                          "X /"</front>
<front id="language_ruH-79">#define MSG_YSTEPS                          "Y /"</front>
<front id="language_ruH-80">#define MSG_ZSTEPS                          "Z /"</front>
<front id="language_ruH-81">#define MSG_ESTEPS                          "E /"</front>
<front id="language_ruH-82">#define MSG_TEMPERATURE                     ""</front>
<front id="language_ruH-83">#define MSG_MOTION                          ""</front>
<front id="language_ruH-84">#define MSG_VOLUMETRIC                      ""</front>
<front id="language_ruH-85">#define MSG_VOLUMETRIC_ENABLED              "E  mm3"</front>
<front id="language_ruH-86">#define MSG_FILAMENT_DIAM                   " "</front>
<front id="language_ruH-87">#define MSG_CONTRAST                        " LCD"</front>
<front id="language_ruH-88">#define MSG_STORE_EPROM                     "  EEPROM"</front>
<front id="language_ruH-89">#define MSG_LOAD_EPROM                      "  EEPROM"</front>
<front id="language_ruH-90">#define MSG_RESTORE_FAILSAFE                " EEPROM"</front>
<front id="language_ruH-91">#define MSG_REFRESH                         ""</front>
<front id="language_ruH-92">#define MSG_WATCH                           ""</front>
<front id="language_ruH-93">#define MSG_PREPARE                         ""</front>
<front id="language_ruH-94">#define MSG_TUNE                            ""</front>
<front id="language_ruH-95">#define MSG_PAUSE_PRINT                     " "</front>
<front id="language_ruH-96">#define MSG_RESUME_PRINT                    " "</front>
<front id="language_ruH-97">#define MSG_STOP_PRINT                      " "</front>
<front id="language_ruH-98">#define MSG_CARD_MENU                       " "</front>
<front id="language_ruH-99">#define MSG_NO_CARD                         " "</front>
<front id="language_ruH-100">#define MSG_DWELL                           "..."</front>
<front id="language_ruH-101">#define MSG_USERWAIT                        ""</front>
<front id="language_ruH-102">#define MSG_RESUMING                        "..."</front>
<front id="language_ruH-103">#define MSG_PRINT_ABORTED                   " "</front>
<front id="language_ruH-104">#define MSG_NO_MOVE                         " ."</front>
<front id="language_ruH-105">#define MSG_KILLED                          "."</front>
<front id="language_ruH-106">#define MSG_STOPPED                         "."</front>
<front id="language_ruH-107">#define MSG_CONTROL_RETRACT                 " mm"</front>
<front id="language_ruH-108">#define MSG_CONTROL_RETRACT_SWAP            ".  mm"</front>
<front id="language_ruH-109">#define MSG_CONTROL_RETRACTF                " V"</front>
<front id="language_ruH-110">#define MSG_CONTROL_RETRACT_ZLIFT           ".  mm"</front>
<front id="language_ruH-111">#define MSG_CONTROL_RETRACT_RECOVER         " +mm"</front>
<front id="language_ruH-112">#define MSG_CONTROL_RETRACT_RECOVER_SWAP    "  +mm"</front>
<front id="language_ruH-113">#define MSG_CONTROL_RETRACT_RECOVERF        "  V"</front>
<front id="language_ruH-114">#define MSG_AUTORETRACT                     " "</front>
<front id="language_ruH-115">#define MSG_FILAMENTCHANGE                  " "</front>
<front id="language_ruH-116">#define MSG_INIT_SDCARD                     ". "</front>
<front id="language_ruH-117">#define MSG_CNG_SDCARD                      " "</front>
<front id="language_ruH-118">#define MSG_ZPROBE_OUT                      "Z   "</front>
<front id="language_ruH-119">#define MSG_POSITION_UNKNOWN                " X/Y  Z"</front>
<front id="language_ruH-120">#define MSG_ZPROBE_ZOFFSET                  " Z"</front>
<front id="language_ruH-121">#define MSG_BABYSTEP_X                      "Babystep X"</front>
<front id="language_ruH-122">#define MSG_BABYSTEP_Y                      "Babystep Y"</front>
<front id="language_ruH-123">#define MSG_BABYSTEP_Z                      "Babystep Z"</front>
<front id="language_ruH-124">#define MSG_ENDSTOP_ABORT                   " "</front>
<front id="language_ruH-125">#define MSG_END_HOUR                        ""</front>
<front id="language_ruH-126">#define MSG_END_MINUTE                      ""</front>
<front id="language_ruH-127"></front>
<front id="language_ruH-128">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="language_ruH-129">    #define MSG_DELTA_CALIBRATE             " Delta"</front>
<front id="language_ruH-130">    #define MSG_DELTA_CALIBRATE_X           " X"</front>
<front id="language_ruH-131">    #define MSG_DELTA_CALIBRATE_Y           " Y"</front>
<front id="language_ruH-132">    #define MSG_DELTA_CALIBRATE_Z           " Z"</front>
<front id="language_ruH-133">    #define MSG_DELTA_CALIBRATE_CENTER      " Center"</front>
<front id="language_ruH-134">#endif // DELTA_CALIBRATION_MENU</front>
<front id="language_ruH-135"></front>
<front id="language_ruH-136">#endif // LANGUAGE_RU_H</front>
 </pre>
<h1 id="language_testHtitle" >language_test.h</h1>
<pre id="language_testH"  class="prettyprint linenums"><front id="language_testH-1">/**</front>
<front id="language_testH-2"> * TEST</front>
<front id="language_testH-3"> *</front>
<front id="language_testH-4"> * LCD Menu Messages</front>
<front id="language_testH-5"> * See also documentation/LCDLanguageFont.md</front>
<front id="language_testH-6"> *</front>
<front id="language_testH-7"> */</front>
<front id="language_testH-8">#ifndef LANGUAGE_TEST_H</front>
<front id="language_testH-9">#define LANGUAGE_TEST_H</front>
<front id="language_testH-10"></front>
<front id="language_testH-11">// Select ONE of the following Mappers.</front>
<front id="language_testH-12">// They decide what to do with a symbol in the area of [0x80:0xFF]. They take a symbol of this language file and make them point</front>
<front id="language_testH-13">// into an array with 128 cells, where they'll find the place of the symbol of the font in use.</front>
<front id="language_testH-14">//</front>
<front id="language_testH-15">// a.)For ASCII coded Language_xx.h files like (en) there are no occurrences of symbols above 0x7F so no mapper is needed.</front>
<front id="language_testH-16">//   If such a symbol appears it is mapped directly into the font. This is the case for the language files we used until now, with all the STR_XX or</front>
<front id="language_testH-17">//   "\xxx" symbols. All Symbols are only one byte long.</front>
<front id="language_testH-18">// b.) For Unicoded Language_xx.h files (currently ru, de and kana_utf8 ) the non ASCII [0x00-0x7F] symbols are represented by more then one byte.</front>
<front id="language_testH-19">//   In the case of two bytes the first is pointing to a 'codepage' and the second to a place in the codepage. These codepages contain 64 symbols.</front>
<front id="language_testH-20">//   So two of them can be mapped. For most of the European languages the necessary symbols are contained in the pages C2 and C3. Cyrillic uses D0</front>
<front id="language_testH-21">//   and D1.</front>
<front id="language_testH-22">// c.) For katakana (one of the Japanese symbol sets) Unicode uses 3 bytes. Here the second byte also points to a codepage and byte 3 to the symbol.</front>
<front id="language_testH-23">//   I hope the pages E282 and E283 are sufficient to write katakana.</front>
<front id="language_testH-24">//   Kanji (an other Japanese symbol set) uses far more than two codepages. So currently I don't see a chance to map the Unicodes. Its not</front>
<front id="language_testH-25">//   impossible to have a close to direct mapping but will need giant conversion tables and fonts (we don't want to have in a embedded system).</front>
<front id="language_testH-26"></front>
<front id="language_testH-27"></front>
<front id="language_testH-28">#define MAPPER_NON         // For direct asci codes ( until now all languages except ru, de, fi, kana_utf8, ... )</front>
<front id="language_testH-29">//#define MAPPER_C2C3        // For most European languages when language file is in utf8</front>
<front id="language_testH-30">//#define MAPPER_D0D1        // For Cyrillic</front>
<front id="language_testH-31">//#define MAPPER_E382E383    // For Katakana</front>
<front id="language_testH-32"></front>
<front id="language_testH-33">// Define SIMULATE_ROMFONT to see what is seen on the character based display defined in Configuration.h</front>
<front id="language_testH-34">//#define SIMULATE_ROMFONT</front>
<front id="language_testH-35"></front>
<front id="language_testH-36">// Select the better font for full graphic displays.</front>
<front id="language_testH-37">//#define DISPLAY_CHARSET_ISO10646_1</front>
<front id="language_testH-38">//#define DISPLAY_CHARSET_ISO10646_5</front>
<front id="language_testH-39">//#define DISPLAY_CHARSET_ISO10646_KANA</front>
<front id="language_testH-40"></front>
<front id="language_testH-41"></front>
<front id="language_testH-42"></front>
<front id="language_testH-43">// next 5 lines select variants in this file only</front>
<front id="language_testH-44">#define DISPLAYTEST</front>
<front id="language_testH-45">//#define WEST</front>
<front id="language_testH-46">//#define CYRIL</front>
<front id="language_testH-47">//#define KANA</front>
<front id="language_testH-48"></front>
<front id="language_testH-49"></front>
<front id="language_testH-50">// TESTSTRINGS</front>
<front id="language_testH-51"></front>
<front id="language_testH-52">#define STRG_ASCII_2 " !\"#$%&'()*+,-./"</front>
<front id="language_testH-53">#define STRG_ASCII_3 "0123456789:;&lt;=&gt;?"</front>
<front id="language_testH-54">#define STRG_ASCII_4 "@ABCDEFGHIJKLMNO"</front>
<front id="language_testH-55">#define STRG_ASCII_5 "PQRSTUVWXYZ[\]^_"</front>
<front id="language_testH-56">#define STRG_ASCII_6 "`abcdefghijklmno"</front>
<front id="language_testH-57">#define STRG_ASCII_7 "pqrstuvwxyz{|}~"</front>
<front id="language_testH-58"></front>
<front id="language_testH-59">#define STRG_C2_8 ""</front>
<front id="language_testH-60">#define STRG_C2_9 ""</front>
<front id="language_testH-61">#define STRG_C2_a ""</front>
<front id="language_testH-62">#define STRG_C2_b ""</front>
<front id="language_testH-63">#define STRG_C3_8 ""</front>
<front id="language_testH-64">#define STRG_C3_9 ""</front>
<front id="language_testH-65">#define STRG_C3_a ""</front>
<front id="language_testH-66">#define STRG_C3_b ""</front>
<front id="language_testH-67"></front>
<front id="language_testH-68">#define STRG_D0_8 ""</front>
<front id="language_testH-69">#define STRG_D0_9 ""</front>
<front id="language_testH-70">#define STRG_D0_a ""</front>
<front id="language_testH-71">#define STRG_D0_b ""</front>
<front id="language_testH-72">#define STRG_D1_8 ""</front>
<front id="language_testH-73">#define STRG_D1_9 ""</front>
<front id="language_testH-74">#define STRG_D1_a ""</front>
<front id="language_testH-75">#define STRG_D1_b ""</front>
<front id="language_testH-76"></front>
<front id="language_testH-77">#define STRG_E382_8 ""</front>
<front id="language_testH-78">#define STRG_E382_9 " "</front>
<front id="language_testH-79">#define STRG_E382_a ""</front>
<front id="language_testH-80">#define STRG_E382_b ""</front>
<front id="language_testH-81">#define STRG_E383_8 ""</front>
<front id="language_testH-82">#define STRG_E383_9 ""</front>
<front id="language_testH-83">#define STRG_E383_a ""</front>
<front id="language_testH-84">#define STRG_E383_b ""</front>
<front id="language_testH-85"></front>
<front id="language_testH-86">#define STRG_OKTAL_0 "\000\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017"</front>
<front id="language_testH-87">#define STRG_OKTAL_1 "\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037"</front>
<front id="language_testH-88">#define STRG_OKTAL_2 "\040\041\042\043\044\045\046\047\050\051\052\053\054\055\056\057"</front>
<front id="language_testH-89">#define STRG_OKTAL_3 "\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077"</front>
<front id="language_testH-90">#define STRG_OKTAL_4 "\100\101\102\103\104\105\106\107\110\111\112\113\114\115\116\117"</front>
<front id="language_testH-91">#define STRG_OKTAL_5 "\120\121\122\123\124\125\126\127\130\131\132\133\134\135\136\137"</front>
<front id="language_testH-92">#define STRG_OKTAL_6 "\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"</front>
<front id="language_testH-93">#define STRG_OKTAL_7 "\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\177"</front>
<front id="language_testH-94">#define STRG_OKTAL_8 "\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217"</front>
<front id="language_testH-95">#define STRG_OKTAL_9 "\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237"</front>
<front id="language_testH-96">#define STRG_OKTAL_a "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257"</front>
<front id="language_testH-97">#define STRG_OKTAL_b "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277"</front>
<front id="language_testH-98">#define STRG_OKTAL_c "\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317"</front>
<front id="language_testH-99">#define STRG_OKTAL_d "\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337"</front>
<front id="language_testH-100">#define STRG_OKTAL_e "\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357"</front>
<front id="language_testH-101">#define STRG_OKTAL_f "\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377"</front>
<front id="language_testH-102"></front>
<front id="language_testH-103">#if ENABLED(DISPLAYTEST)</front>
<front id="language_testH-104">  #define WELCOME_MSG                         "Language TEST"</front>
<front id="language_testH-105"></front>
<front id="language_testH-106">  #define MSG_WATCH                           "Display test"</front>
<front id="language_testH-107">  #define MSG_PREPARE                         STRG_OKTAL_b</front>
<front id="language_testH-108">  #define MSG_CONTROL                         STRG_OKTAL_c</front>
<front id="language_testH-109">#endif</front>
<front id="language_testH-110"></front>
<front id="language_testH-111">#if ENABLED(WEST)</front>
<front id="language_testH-112">  #define WELCOME_MSG                         "Language TEST"</front>
<front id="language_testH-113"></front>
<front id="language_testH-114">  #define MSG_WATCH                           "\001\002\003\004\005\006\007\010\011"</front>
<front id="language_testH-115">  #define MSG_PREPARE                         "UTF8"</front>
<front id="language_testH-116">  #define MSG_CONTROL                         "ASCII"</front>
<front id="language_testH-117"></front>
<front id="language_testH-118">  //#define MSG_MAIN                            ".."</front>
<front id="language_testH-119">  #define MSG_DISABLE_STEPPERS                STRG_C2_8</front>
<front id="language_testH-120">  #define MSG_AUTO_HOME                       STRG_C2_9</front>
<front id="language_testH-121">  #define MSG_SET_HOME_OFFSETS                STRG_C2_a</front>
<front id="language_testH-122">  #define MSG_PREHEAT_PLA                     STRG_C2_b</front>
<front id="language_testH-123">  #define MSG_PREHEAT_ABS                     STRG_C3_8</front>
<front id="language_testH-124">  #define MSG_COOLDOWN                        STRG_C3_9</front>
<front id="language_testH-125">  #define MSG_SWITCH_PS_OFF                   STRG_C3_a</front>
<front id="language_testH-126">  #define MSG_MOVE_AXIS                       STRG_C3_b</front>
<front id="language_testH-127"></front>
<front id="language_testH-128">  #define MSG_MAIN                            STRG_OKTAL_2</front>
<front id="language_testH-129">  #define MSG_TEMPERATURE                     STRG_OKTAL_3</front>
<front id="language_testH-130">  #define MSG_MOTION                          STRG_OKTAL_4</front>
<front id="language_testH-131">  #define MSG_VOLUMETRIC                      STRG_OKTAL_5</front>
<front id="language_testH-132">  #define MSG_CONTRAST                        STRG_OKTAL_6</front>
<front id="language_testH-133">  #define MSG_RESTORE_FAILSAFE                STRG_OKTAL_7</front>
<front id="language_testH-134"></front>
<front id="language_testH-135">  #define MSG_NOZZLE                          STRG_OKTAL_8</front>
<front id="language_testH-136">  #define MSG_FAN_SPEED                       STRG_OKTAL_9</front>
<front id="language_testH-137">  #define MSG_AUTOTEMP                        STRG_OKTAL_a</front>
<front id="language_testH-138">  #define MSG_MIN                             STRG_OKTAL_b</front>
<front id="language_testH-139">  #define MSG_MAX                             STRG_OKTAL_c</front>
<front id="language_testH-140">  #define MSG_FACTOR                          STRG_OKTAL_d</front>
<front id="language_testH-141">  #define MSG_PID_P                           STRG_OKTAL_e</front>
<front id="language_testH-142">  #define MSG_PID_I                           STRG_OKTAL_f</front>
<front id="language_testH-143"></front>
<front id="language_testH-144">#endif</front>
<front id="language_testH-145"></front>
<front id="language_testH-146">#if ENABLED(CYRIL)</front>
<front id="language_testH-147">  #define WELCOME_MSG                         "Language TEST"</front>
<front id="language_testH-148"></front>
<front id="language_testH-149">  #define MSG_WATCH                           "\001\002\003\004\005\006\007\010\011"</front>
<front id="language_testH-150">  #define MSG_PREPARE                         "UTF8"</front>
<front id="language_testH-151">  #define MSG_CONTROL                         "ASCII"</front>
<front id="language_testH-152"></front>
<front id="language_testH-153">  //#define MSG_MAIN                            ".."</front>
<front id="language_testH-154">  #define MSG_DISABLE_STEPPERS                STRG_D0_8</front>
<front id="language_testH-155">  #define MSG_AUTO_HOME                       STRG_D0_9</front>
<front id="language_testH-156">  #define MSG_SET_HOME_OFFSETS                STRG_D0_a</front>
<front id="language_testH-157">  #define MSG_PREHEAT_PLA                     STRG_D0_b</front>
<front id="language_testH-158">  #define MSG_PREHEAT_ABS                     STRG_D1_8</front>
<front id="language_testH-159">  #define MSG_COOLDOWN                        STRG_D1_9</front>
<front id="language_testH-160">  #define MSG_SWITCH_PS_OFF                   STRG_D1_a</front>
<front id="language_testH-161">  #define MSG_MOVE_AXIS                       STRG_D1_b</front>
<front id="language_testH-162"></front>
<front id="language_testH-163">  #define MSG_MAIN                            STRG_OKTAL_2</front>
<front id="language_testH-164">  #define MSG_TEMPERATURE                     STRG_OKTAL_3</front>
<front id="language_testH-165">  #define MSG_MOTION                          STRG_OKTAL_4</front>
<front id="language_testH-166">  #define MSG_VOLUMETRIC                      STRG_OKTAL_5</front>
<front id="language_testH-167">  #define MSG_CONTRAST                        STRG_OKTAL_6</front>
<front id="language_testH-168">  #define MSG_RESTORE_FAILSAFE                STRG_OKTAL_7</front>
<front id="language_testH-169"></front>
<front id="language_testH-170">  #define MSG_NOZZLE                          STRG_OKTAL_8</front>
<front id="language_testH-171">  #define MSG_FAN_SPEED                       STRG_OKTAL_9</front>
<front id="language_testH-172">  #define MSG_AUTOTEMP                        STRG_OKTAL_a</front>
<front id="language_testH-173">  #define MSG_MIN                             STRG_OKTAL_b</front>
<front id="language_testH-174">  #define MSG_MAX                             STRG_OKTAL_c</front>
<front id="language_testH-175">  #define MSG_FACTOR                          STRG_OKTAL_d</front>
<front id="language_testH-176">  #define MSG_PID_P                           STRG_OKTAL_e</front>
<front id="language_testH-177">  #define MSG_PID_I                           STRG_OKTAL_f</front>
<front id="language_testH-178"></front>
<front id="language_testH-179">#endif</front>
<front id="language_testH-180"></front>
<front id="language_testH-181">#if ENABLED(KANA)</front>
<front id="language_testH-182">  #define WELCOME_MSG                         "Language TEST"</front>
<front id="language_testH-183"></front>
<front id="language_testH-184">  #define MSG_WATCH                           "\001\002\003\004\005\006\007\010\011"</front>
<front id="language_testH-185">  #define MSG_PREPARE                         "UTF8"</front>
<front id="language_testH-186">  #define MSG_CONTROL                         "ASCII"</front>
<front id="language_testH-187"></front>
<front id="language_testH-188">  //#define MSG_MAIN                            ".."</front>
<front id="language_testH-189">  #define MSG_DISABLE_STEPPERS                STRG_E382_8</front>
<front id="language_testH-190">  #define MSG_AUTO_HOME                       STRG_E382_9</front>
<front id="language_testH-191">  #define MSG_SET_HOME_OFFSETS                STRG_E382_a</front>
<front id="language_testH-192">  #define MSG_PREHEAT_PLA                     STRG_E382_b</front>
<front id="language_testH-193">  #define MSG_PREHEAT_ABS                     STRG_E383_8</front>
<front id="language_testH-194">  #define MSG_COOLDOWN                        STRG_E383_9</front>
<front id="language_testH-195">  #define MSG_SWITCH_PS_OFF                   STRG_E383_a</front>
<front id="language_testH-196">  #define MSG_MOVE_AXIS                       STRG_E383_b</front>
<front id="language_testH-197"></front>
<front id="language_testH-198">  #define MSG_MAIN                            STRG_OKTAL_2</front>
<front id="language_testH-199">  #define MSG_TEMPERATURE                     STRG_OKTAL_3</front>
<front id="language_testH-200">  #define MSG_MOTION                          STRG_OKTAL_4</front>
<front id="language_testH-201">  #define MSG_VOLUMETRIC                      STRG_OKTAL_5</front>
<front id="language_testH-202">  #define MSG_CONTRAST                        STRG_OKTAL_6</front>
<front id="language_testH-203">  #define MSG_RESTORE_FAILSAFE                STRG_OKTAL_7</front>
<front id="language_testH-204"></front>
<front id="language_testH-205">  #define MSG_NOZZLE                          STRG_OKTAL_8</front>
<front id="language_testH-206">  #define MSG_FAN_SPEED                       STRG_OKTAL_9</front>
<front id="language_testH-207">  #define MSG_AUTOTEMP                        STRG_OKTAL_a</front>
<front id="language_testH-208">  #define MSG_MIN                             STRG_OKTAL_b</front>
<front id="language_testH-209">  #define MSG_MAX                             STRG_OKTAL_c</front>
<front id="language_testH-210">  #define MSG_FACTOR                          STRG_OKTAL_d</front>
<front id="language_testH-211">  #define MSG_PID_P                           STRG_OKTAL_e</front>
<front id="language_testH-212">  #define MSG_PID_I                           STRG_OKTAL_f</front>
<front id="language_testH-213">#endif</front>
<front id="language_testH-214"></front>
<front id="language_testH-215">#endif // LANGUAGE_TEST_H</front>
 </pre>
<h1 id="M100_Free_Mem_ChkCPPtitle" >M100_Free_Mem_Chk.cpp</h1>
<pre id="M100_Free_Mem_ChkCPP"  class="prettyprint linenums"><front id="M100_Free_Mem_ChkCPP-1">#define M100_FREE_MEMORY_DUMPER			// Comment out to remove Dump sub-command</front>
<front id="M100_Free_Mem_ChkCPP-2">#define M100_FREE_MEMORY_CORRUPTOR		// Comment out to remove Corrupt sub-command</front>
<front id="M100_Free_Mem_ChkCPP-3"></front>
<front id="M100_Free_Mem_ChkCPP-4"></front>
<front id="M100_Free_Mem_ChkCPP-5">// M100 Free Memory Watcher</front>
<front id="M100_Free_Mem_ChkCPP-6">//</front>
<front id="M100_Free_Mem_ChkCPP-7">// This code watches the free memory block between the bottom of the heap and the top of the stack.</front>
<front id="M100_Free_Mem_ChkCPP-8">// This memory block is initialized and watched via the M100 command.</front>
<front id="M100_Free_Mem_ChkCPP-9">//</front>
<front id="M100_Free_Mem_ChkCPP-10">// M100 I	Initializes the free memory block and prints vitals statistics about the area</front>
<front id="M100_Free_Mem_ChkCPP-11">// M100 F	Identifies how much of the free memory block remains free and unused.  It also</front>
<front id="M100_Free_Mem_ChkCPP-12">// 		detects and reports any corruption within the free memory block that may have</front>
<front id="M100_Free_Mem_ChkCPP-13">// 		happened due to errant firmware.</front>
<front id="M100_Free_Mem_ChkCPP-14">// M100 D	Does a hex display of the free memory block along with a flag for any errant</front>
<front id="M100_Free_Mem_ChkCPP-15">// 		data that does not match the expected value.</front>
<front id="M100_Free_Mem_ChkCPP-16">// M100 C x	Corrupts x locations within the free memory block.   This is useful to check the</front>
<front id="M100_Free_Mem_ChkCPP-17">// 		correctness of the M100 F and M100 D commands.</front>
<front id="M100_Free_Mem_ChkCPP-18">//</front>
<front id="M100_Free_Mem_ChkCPP-19">// Initial version by Roxy-3DPrintBoard</front>
<front id="M100_Free_Mem_ChkCPP-20">//</front>
<front id="M100_Free_Mem_ChkCPP-21">//</front>
<front id="M100_Free_Mem_ChkCPP-22"></front>
<front id="M100_Free_Mem_ChkCPP-23"></front>
<front id="M100_Free_Mem_ChkCPP-24">#include "Marlin.h"</front>
<front id="M100_Free_Mem_ChkCPP-25"></front>
<front id="M100_Free_Mem_ChkCPP-26">#if ENABLED(M100_FREE_MEMORY_WATCHER)</front>
<front id="M100_Free_Mem_ChkCPP-27">extern void *__brkval;</front>
<front id="M100_Free_Mem_ChkCPP-28">extern size_t  __heap_start, __heap_end, __flp;</front>
<front id="M100_Free_Mem_ChkCPP-29"></front>
<front id="M100_Free_Mem_ChkCPP-30"></front>
<front id="M100_Free_Mem_ChkCPP-31">//</front>
<front id="M100_Free_Mem_ChkCPP-32">// Declare all the functions we need from Marlin_Main.cpp to do the work!</front>
<front id="M100_Free_Mem_ChkCPP-33">//</front>
<front id="M100_Free_Mem_ChkCPP-34"></front>
<front id="M100_Free_Mem_ChkCPP-35">float code_value();</front>
<front id="M100_Free_Mem_ChkCPP-36">long code_value_long();</front>
<front id="M100_Free_Mem_ChkCPP-37">bool code_seen(char );</front>
<front id="M100_Free_Mem_ChkCPP-38">void serial_echopair_P(const char *, float );</front>
<front id="M100_Free_Mem_ChkCPP-39">void serial_echopair_P(const char *, double );</front>
<front id="M100_Free_Mem_ChkCPP-40">void serial_echopair_P(const char *, unsigned long );</front>
<front id="M100_Free_Mem_ChkCPP-41">void serial_echopair_P(const char *, int );</front>
<front id="M100_Free_Mem_ChkCPP-42">void serial_echopair_P(const char *, long );</front>
<front id="M100_Free_Mem_ChkCPP-43"></front>
<front id="M100_Free_Mem_ChkCPP-44"></front>
<front id="M100_Free_Mem_ChkCPP-45"></front>
<front id="M100_Free_Mem_ChkCPP-46"></front>
<front id="M100_Free_Mem_ChkCPP-47">//</front>
<front id="M100_Free_Mem_ChkCPP-48">// Utility functions used by M100 to get its work done.</front>
<front id="M100_Free_Mem_ChkCPP-49">//</front>
<front id="M100_Free_Mem_ChkCPP-50"></front>
<front id="M100_Free_Mem_ChkCPP-51">unsigned char *top_of_stack();</front>
<front id="M100_Free_Mem_ChkCPP-52">void prt_hex_nibble( unsigned int );</front>
<front id="M100_Free_Mem_ChkCPP-53">void prt_hex_byte(unsigned int );</front>
<front id="M100_Free_Mem_ChkCPP-54">void prt_hex_word(unsigned int );</front>
<front id="M100_Free_Mem_ChkCPP-55">int how_many_E5s_are_here( unsigned char *);</front>
<front id="M100_Free_Mem_ChkCPP-56"></front>
<front id="M100_Free_Mem_ChkCPP-57"></front>
<front id="M100_Free_Mem_ChkCPP-58"></front>
<front id="M100_Free_Mem_ChkCPP-59"></front>
<front id="M100_Free_Mem_ChkCPP-60">void gcode_M100()</front>
<front id="M100_Free_Mem_ChkCPP-61">{</front>
<front id="M100_Free_Mem_ChkCPP-62">static int m100_not_initialized=1;</front>
<front id="M100_Free_Mem_ChkCPP-63">unsigned char *sp, *ptr;</front>
<front id="M100_Free_Mem_ChkCPP-64">int i, j, n;</front>
<front id="M100_Free_Mem_ChkCPP-65"></front>
<front id="M100_Free_Mem_ChkCPP-66">//</front>
<front id="M100_Free_Mem_ChkCPP-67">// M100 D dumps the free memory block from __brkval to the stack pointer.</front>
<front id="M100_Free_Mem_ChkCPP-68">// malloc() eats memory from the start of the block and the stack grows</front>
<front id="M100_Free_Mem_ChkCPP-69">// up from the bottom of the block.    Solid 0xE5's indicate nothing has</front>
<front id="M100_Free_Mem_ChkCPP-70">// used that memory yet.   There should not be anything but 0xE5's within</front>
<front id="M100_Free_Mem_ChkCPP-71">// the block of 0xE5's.  If there is, that would indicate memory corruption</front>
<front id="M100_Free_Mem_ChkCPP-72">// probably caused by bad pointers.  Any unexpected values will be flagged in</front>
<front id="M100_Free_Mem_ChkCPP-73">// the right hand column to help spotting them.</front>
<front id="M100_Free_Mem_ChkCPP-74">//</front>
<front id="M100_Free_Mem_ChkCPP-75"></front>
<front id="M100_Free_Mem_ChkCPP-76">#if ENABLED(M100_FREE_MEMORY_DUMPER) // Disable to remove Dump sub-command</front>
<front id="M100_Free_Mem_ChkCPP-77">	if ( code_seen('D') ) {</front>
<front id="M100_Free_Mem_ChkCPP-78"> 		ptr = (unsigned char *) __brkval;</front>
<front id="M100_Free_Mem_ChkCPP-79"></front>
<front id="M100_Free_Mem_ChkCPP-80">//</front>
<front id="M100_Free_Mem_ChkCPP-81">// We want to start and end the dump on a nice 16 byte boundry even though</front>
<front id="M100_Free_Mem_ChkCPP-82">// the values we are using are not 16 byte aligned.</front>
<front id="M100_Free_Mem_ChkCPP-83">//</front>
<front id="M100_Free_Mem_ChkCPP-84">  		SERIAL_ECHOPGM("\n__brkval : ");</front>
<front id="M100_Free_Mem_ChkCPP-85">		prt_hex_word( (unsigned int) ptr );</front>
<front id="M100_Free_Mem_ChkCPP-86">  		ptr = (unsigned char *) ((unsigned long) ptr & 0xfff0);</front>
<front id="M100_Free_Mem_ChkCPP-87"></front>
<front id="M100_Free_Mem_ChkCPP-88">		sp = top_of_stack();</front>
<front id="M100_Free_Mem_ChkCPP-89">  		SERIAL_ECHOPGM("\nStack Pointer : ");</front>
<front id="M100_Free_Mem_ChkCPP-90">		prt_hex_word( (unsigned int) sp );</front>
<front id="M100_Free_Mem_ChkCPP-91">  		SERIAL_ECHOPGM("\n");</front>
<front id="M100_Free_Mem_ChkCPP-92"></front>
<front id="M100_Free_Mem_ChkCPP-93">		sp = (unsigned char *) ((unsigned long) sp | 0x000f);</front>
<front id="M100_Free_Mem_ChkCPP-94">		n = sp - ptr;</front>
<front id="M100_Free_Mem_ChkCPP-95">//</front>
<front id="M100_Free_Mem_ChkCPP-96">// This is the main loop of the Dump command.</front>
<front id="M100_Free_Mem_ChkCPP-97">//</front>
<front id="M100_Free_Mem_ChkCPP-98">		while ( ptr &lt; sp ) {</front>
<front id="M100_Free_Mem_ChkCPP-99">			prt_hex_word( (unsigned int) ptr);	// Print the address</front>
<front id="M100_Free_Mem_ChkCPP-100">  			SERIAL_ECHOPGM(":");</front>
<front id="M100_Free_Mem_ChkCPP-101">			for(i=0; i&lt;16; i++) {			// and 16 data bytes</front>
<front id="M100_Free_Mem_ChkCPP-102">				prt_hex_byte( *(ptr+i));</front>
<front id="M100_Free_Mem_ChkCPP-103">  				SERIAL_ECHOPGM(" ");</front>
<front id="M100_Free_Mem_ChkCPP-104">				delay(2);</front>
<front id="M100_Free_Mem_ChkCPP-105">			}</front>
<front id="M100_Free_Mem_ChkCPP-106"></front>
<front id="M100_Free_Mem_ChkCPP-107">  			SERIAL_ECHO("|");   			// now show where non 0xE5's are</front>
<front id="M100_Free_Mem_ChkCPP-108">			for(i=0; i&lt;16; i++) {</front>
<front id="M100_Free_Mem_ChkCPP-109">				delay(2);</front>
<front id="M100_Free_Mem_ChkCPP-110">				if ( *(ptr+i)==0xe5)</front>
<front id="M100_Free_Mem_ChkCPP-111">  					SERIAL_ECHOPGM(" ");</front>
<front id="M100_Free_Mem_ChkCPP-112">				else</front>
<front id="M100_Free_Mem_ChkCPP-113">  					SERIAL_ECHOPGM("?");</front>
<front id="M100_Free_Mem_ChkCPP-114">			}</front>
<front id="M100_Free_Mem_ChkCPP-115">  			SERIAL_ECHO("\n");</front>
<front id="M100_Free_Mem_ChkCPP-116"></front>
<front id="M100_Free_Mem_ChkCPP-117">			ptr += 16;</front>
<front id="M100_Free_Mem_ChkCPP-118">			delay(2);</front>
<front id="M100_Free_Mem_ChkCPP-119">		}</front>
<front id="M100_Free_Mem_ChkCPP-120">  		SERIAL_ECHOLNPGM("Done.\n");</front>
<front id="M100_Free_Mem_ChkCPP-121">		return;</front>
<front id="M100_Free_Mem_ChkCPP-122">	}</front>
<front id="M100_Free_Mem_ChkCPP-123">#endif</front>
<front id="M100_Free_Mem_ChkCPP-124"></front>
<front id="M100_Free_Mem_ChkCPP-125">//</front>
<front id="M100_Free_Mem_ChkCPP-126">// M100 F   requests the code to return the number of free bytes in the memory pool along with</front>
<front id="M100_Free_Mem_ChkCPP-127">// other vital statistics that define the memory pool.</front>
<front id="M100_Free_Mem_ChkCPP-128">//</front>
<front id="M100_Free_Mem_ChkCPP-129">	if ( code_seen('F') ) {</front>
<front id="M100_Free_Mem_ChkCPP-130">	int max_addr = (int) __brkval;</front>
<front id="M100_Free_Mem_ChkCPP-131">	int max_cnt = 0;</front>
<front id="M100_Free_Mem_ChkCPP-132">	int block_cnt = 0;</front>
<front id="M100_Free_Mem_ChkCPP-133">  		ptr = (unsigned char *) __brkval;</front>
<front id="M100_Free_Mem_ChkCPP-134">		sp = top_of_stack();</front>
<front id="M100_Free_Mem_ChkCPP-135">		n = sp - ptr;</front>
<front id="M100_Free_Mem_ChkCPP-136"></front>
<front id="M100_Free_Mem_ChkCPP-137">// Scan through the range looking for the biggest block of 0xE5's we can find</front>
<front id="M100_Free_Mem_ChkCPP-138"></front>
<front id="M100_Free_Mem_ChkCPP-139">		for(i=0; i&lt;n; i++) {</front>
<front id="M100_Free_Mem_ChkCPP-140">			if ( *(ptr+i) == (unsigned char) 0xe5) {</front>
<front id="M100_Free_Mem_ChkCPP-141">				j = how_many_E5s_are_here( (unsigned char *) ptr+i );</front>
<front id="M100_Free_Mem_ChkCPP-142">				if ( j&gt;8) {</front>
<front id="M100_Free_Mem_ChkCPP-143"> 					SERIAL_ECHOPAIR("Found ", j );</front>
<front id="M100_Free_Mem_ChkCPP-144"> 					SERIAL_ECHOPGM(" bytes free at 0x");</front>
<front id="M100_Free_Mem_ChkCPP-145">					prt_hex_word( (int) ptr+i );</front>
<front id="M100_Free_Mem_ChkCPP-146"> 					SERIAL_ECHOPGM("\n");</front>
<front id="M100_Free_Mem_ChkCPP-147">					i += j;</front>
<front id="M100_Free_Mem_ChkCPP-148">				        block_cnt++;</front>
<front id="M100_Free_Mem_ChkCPP-149">				}</front>
<front id="M100_Free_Mem_ChkCPP-150">				if ( j&gt;max_cnt) {			// We don't do anything with this information yet</front>
<front id="M100_Free_Mem_ChkCPP-151">					max_cnt  = j;			// but we do know where the biggest free memory block is.</front>
<front id="M100_Free_Mem_ChkCPP-152">					max_addr = (int) ptr+i;</front>
<front id="M100_Free_Mem_ChkCPP-153">				}</front>
<front id="M100_Free_Mem_ChkCPP-154">			}</front>
<front id="M100_Free_Mem_ChkCPP-155">		}</front>
<front id="M100_Free_Mem_ChkCPP-156">		if (block_cnt&gt;1)</front>
<front id="M100_Free_Mem_ChkCPP-157">  			SERIAL_ECHOLNPGM("\nMemory Corruption detected in free memory area.\n");</front>
<front id="M100_Free_Mem_ChkCPP-158"></front>
<front id="M100_Free_Mem_ChkCPP-159">  		SERIAL_ECHO("\nDone.\n");</front>
<front id="M100_Free_Mem_ChkCPP-160">		return;</front>
<front id="M100_Free_Mem_ChkCPP-161">	}</front>
<front id="M100_Free_Mem_ChkCPP-162">//</front>
<front id="M100_Free_Mem_ChkCPP-163">// M100 C x  Corrupts x locations in the free memory pool and reports the locations of the corruption.</front>
<front id="M100_Free_Mem_ChkCPP-164">// This is useful to check the correctness of the M100 D and the M100 F commands.</front>
<front id="M100_Free_Mem_ChkCPP-165">//</front>
<front id="M100_Free_Mem_ChkCPP-166">#if ENABLED(M100_FREE_MEMORY_CORRUPTOR)</front>
<front id="M100_Free_Mem_ChkCPP-167">	if ( code_seen('C') ) {</front>
<front id="M100_Free_Mem_ChkCPP-168">		int x;			// x gets the # of locations to corrupt within the memory pool</front>
<front id="M100_Free_Mem_ChkCPP-169">		x = code_value();</front>
<front id="M100_Free_Mem_ChkCPP-170">  		SERIAL_ECHOLNPGM("Corrupting free memory block.\n");</front>
<front id="M100_Free_Mem_ChkCPP-171">  		ptr = (unsigned char *) __brkval;</front>
<front id="M100_Free_Mem_ChkCPP-172">  		SERIAL_ECHOPAIR("\n__brkval : ",(long) ptr );</front>
<front id="M100_Free_Mem_ChkCPP-173">  		ptr += 8;</front>
<front id="M100_Free_Mem_ChkCPP-174"></front>
<front id="M100_Free_Mem_ChkCPP-175">		sp = top_of_stack();</front>
<front id="M100_Free_Mem_ChkCPP-176">  		SERIAL_ECHOPAIR("\nStack Pointer : ",(long) sp );</front>
<front id="M100_Free_Mem_ChkCPP-177">  		SERIAL_ECHOLNPGM("\n");</front>
<front id="M100_Free_Mem_ChkCPP-178"></front>
<front id="M100_Free_Mem_ChkCPP-179">		n = sp - ptr - 64;  	// -64 just to keep us from finding interrupt activity that</front>
<front id="M100_Free_Mem_ChkCPP-180">	       				// has altered the stack.</front>
<front id="M100_Free_Mem_ChkCPP-181">		j = n / (x+1);</front>
<front id="M100_Free_Mem_ChkCPP-182">		for(i=1; i&lt;=x; i++) {</front>
<front id="M100_Free_Mem_ChkCPP-183">			*(ptr+(i*j)) = i;</front>
<front id="M100_Free_Mem_ChkCPP-184">  			SERIAL_ECHO("\nCorrupting address: 0x");</front>
<front id="M100_Free_Mem_ChkCPP-185">		      	prt_hex_word( (unsigned int)  (ptr+(i*j)) );</front>
<front id="M100_Free_Mem_ChkCPP-186">		}</front>
<front id="M100_Free_Mem_ChkCPP-187">  		SERIAL_ECHOLNPGM("\n");</front>
<front id="M100_Free_Mem_ChkCPP-188">		return;</front>
<front id="M100_Free_Mem_ChkCPP-189">	}</front>
<front id="M100_Free_Mem_ChkCPP-190">#endif</front>
<front id="M100_Free_Mem_ChkCPP-191"></front>
<front id="M100_Free_Mem_ChkCPP-192">//</front>
<front id="M100_Free_Mem_ChkCPP-193">// M100 I    Initializes the free memory pool so it can be watched and prints vital</front>
<front id="M100_Free_Mem_ChkCPP-194">// statistics that define the free memory pool.</front>
<front id="M100_Free_Mem_ChkCPP-195">//</front>
<front id="M100_Free_Mem_ChkCPP-196">	if (m100_not_initialized || code_seen('I') ) {				// If no sub-command is specified, the first time</front>
<front id="M100_Free_Mem_ChkCPP-197">  		SERIAL_ECHOLNPGM("Initializing free memory block.\n");   	// this happens, it will Initialize.</front>
<front id="M100_Free_Mem_ChkCPP-198">  		ptr = (unsigned char *) __brkval;				// Repeated M100 with no sub-command will not destroy the</front>
<front id="M100_Free_Mem_ChkCPP-199">  		SERIAL_ECHOPAIR("\n__brkval : ",(long) ptr );			// state of the initialized free memory pool.</front>
<front id="M100_Free_Mem_ChkCPP-200">  		ptr += 8;</front>
<front id="M100_Free_Mem_ChkCPP-201"></front>
<front id="M100_Free_Mem_ChkCPP-202">		sp = top_of_stack();</front>
<front id="M100_Free_Mem_ChkCPP-203">  		SERIAL_ECHOPAIR("\nStack Pointer : ",(long) sp );</front>
<front id="M100_Free_Mem_ChkCPP-204">  		SERIAL_ECHOLNPGM("\n");</front>
<front id="M100_Free_Mem_ChkCPP-205"></front>
<front id="M100_Free_Mem_ChkCPP-206">		n = sp - ptr - 64;  	// -64 just to keep us from finding interrupt activity that</front>
<front id="M100_Free_Mem_ChkCPP-207">	       				// has altered the stack.</front>
<front id="M100_Free_Mem_ChkCPP-208"></front>
<front id="M100_Free_Mem_ChkCPP-209">  		SERIAL_ECHO( n );</front>
<front id="M100_Free_Mem_ChkCPP-210">  		SERIAL_ECHOLNPGM(" bytes of memory initialized.\n");</front>
<front id="M100_Free_Mem_ChkCPP-211"></front>
<front id="M100_Free_Mem_ChkCPP-212">		for(i=0; i&lt;n; i++)</front>
<front id="M100_Free_Mem_ChkCPP-213">			*(ptr+i) = (unsigned char) 0xe5;</front>
<front id="M100_Free_Mem_ChkCPP-214"></front>
<front id="M100_Free_Mem_ChkCPP-215">		for(i=0; i&lt;n; i++) {</front>
<front id="M100_Free_Mem_ChkCPP-216">			if ( *(ptr+i) != (unsigned char) 0xe5 ) {</front>
<front id="M100_Free_Mem_ChkCPP-217">  				SERIAL_ECHOPAIR("? address : ", (unsigned long) ptr+i );</front>
<front id="M100_Free_Mem_ChkCPP-218">  				SERIAL_ECHOPAIR("=", *(ptr+i) );</front>
<front id="M100_Free_Mem_ChkCPP-219">  				SERIAL_ECHOLNPGM("\n");</front>
<front id="M100_Free_Mem_ChkCPP-220">			}</front>
<front id="M100_Free_Mem_ChkCPP-221">		}</front>
<front id="M100_Free_Mem_ChkCPP-222">		m100_not_initialized = 0;</front>
<front id="M100_Free_Mem_ChkCPP-223">  		SERIAL_ECHOLNPGM("Done.\n");</front>
<front id="M100_Free_Mem_ChkCPP-224">		return;</front>
<front id="M100_Free_Mem_ChkCPP-225">	}</front>
<front id="M100_Free_Mem_ChkCPP-226">	return;</front>
<front id="M100_Free_Mem_ChkCPP-227">}</front>
<front id="M100_Free_Mem_ChkCPP-228"></front>
<front id="M100_Free_Mem_ChkCPP-229">// top_of_stack() returns the location of a variable on its stack frame.  The value returned is above</front>
<front id="M100_Free_Mem_ChkCPP-230">// the stack once the function returns to the caller.</front>
<front id="M100_Free_Mem_ChkCPP-231"></front>
<front id="M100_Free_Mem_ChkCPP-232">unsigned char *top_of_stack() {</front>
<front id="M100_Free_Mem_ChkCPP-233">  unsigned char x;</front>
<front id="M100_Free_Mem_ChkCPP-234">  return &x + 1; // x is pulled on return;</front>
<front id="M100_Free_Mem_ChkCPP-235">}</front>
<front id="M100_Free_Mem_ChkCPP-236"></front>
<front id="M100_Free_Mem_ChkCPP-237">//</front>
<front id="M100_Free_Mem_ChkCPP-238">// 3 support routines to print hex numbers.  We can print a nibble, byte and word</front>
<front id="M100_Free_Mem_ChkCPP-239">//</front>
<front id="M100_Free_Mem_ChkCPP-240"></front>
<front id="M100_Free_Mem_ChkCPP-241">void prt_hex_nibble( unsigned int n )</front>
<front id="M100_Free_Mem_ChkCPP-242">{</front>
<front id="M100_Free_Mem_ChkCPP-243">	if ( n &lt;= 9 )</front>
<front id="M100_Free_Mem_ChkCPP-244">		SERIAL_ECHO(n);</front>
<front id="M100_Free_Mem_ChkCPP-245">	else</front>
<front id="M100_Free_Mem_ChkCPP-246">		SERIAL_ECHO( (char) ('A'+n-10) );</front>
<front id="M100_Free_Mem_ChkCPP-247">	delay(2);</front>
<front id="M100_Free_Mem_ChkCPP-248">}</front>
<front id="M100_Free_Mem_ChkCPP-249"></front>
<front id="M100_Free_Mem_ChkCPP-250">void prt_hex_byte(unsigned int b)</front>
<front id="M100_Free_Mem_ChkCPP-251">{</front>
<front id="M100_Free_Mem_ChkCPP-252">	prt_hex_nibble( ( b & 0xf0 ) &gt;&gt; 4 );</front>
<front id="M100_Free_Mem_ChkCPP-253">	prt_hex_nibble(  b & 0x0f );</front>
<front id="M100_Free_Mem_ChkCPP-254">}</front>
<front id="M100_Free_Mem_ChkCPP-255"></front>
<front id="M100_Free_Mem_ChkCPP-256">void prt_hex_word(unsigned int w)</front>
<front id="M100_Free_Mem_ChkCPP-257">{</front>
<front id="M100_Free_Mem_ChkCPP-258">	prt_hex_byte( ( w & 0xff00 ) &gt;&gt; 8 );</front>
<front id="M100_Free_Mem_ChkCPP-259">	prt_hex_byte(  w & 0x0ff );</front>
<front id="M100_Free_Mem_ChkCPP-260">}</front>
<front id="M100_Free_Mem_ChkCPP-261"></front>
<front id="M100_Free_Mem_ChkCPP-262">// how_many_E5s_are_here() is a utility function to easily find out how many 0xE5's are</front>
<front id="M100_Free_Mem_ChkCPP-263">// at the specified location.  Having this logic as a function simplifies the search code.</front>
<front id="M100_Free_Mem_ChkCPP-264">//</front>
<front id="M100_Free_Mem_ChkCPP-265">int how_many_E5s_are_here( unsigned char *p)</front>
<front id="M100_Free_Mem_ChkCPP-266">{</front>
<front id="M100_Free_Mem_ChkCPP-267">int n;</front>
<front id="M100_Free_Mem_ChkCPP-268"></front>
<front id="M100_Free_Mem_ChkCPP-269">	for(n=0; n&lt;32000; n++) {</front>
<front id="M100_Free_Mem_ChkCPP-270">		if ( *(p+n) != (unsigned char) 0xe5)</front>
<front id="M100_Free_Mem_ChkCPP-271">			return n-1;</front>
<front id="M100_Free_Mem_ChkCPP-272">	}</front>
<front id="M100_Free_Mem_ChkCPP-273">	return -1;</front>
<front id="M100_Free_Mem_ChkCPP-274">}</front>
<front id="M100_Free_Mem_ChkCPP-275"></front>
<front id="M100_Free_Mem_ChkCPP-276">#endif</front>
<front id="M100_Free_Mem_ChkCPP-277"></front>
 </pre>
<h1 id="macrosHtitle" >macros.h</h1>
<pre id="macrosH"  class="prettyprint linenums"><front id="macrosH-1">#ifndef MACROS_H</front>
<front id="macrosH-2">#define MACROS_H</front>
<front id="macrosH-3"></front>
<front id="macrosH-4">// Macros for bit masks</front>
<front id="macrosH-5">#define BIT(b) (1&lt;&lt;(b))</front>
<front id="macrosH-6">#define TEST(n,b) (((n)&BIT(b))!=0)</front>
<front id="macrosH-7">#define SET_BIT(n,b,value) (n) ^= ((-value)^(n)) & (BIT(b))</front>
<front id="macrosH-8"></front>
<front id="macrosH-9">// Macros for maths shortcuts</front>
<front id="macrosH-10">#define RADIANS(d) ((d)*M_PI/180.0)</front>
<front id="macrosH-11">#define DEGREES(r) ((r)*180.0/M_PI)</front>
<front id="macrosH-12"></front>
<front id="macrosH-13">// Macros to contrain values</front>
<front id="macrosH-14">#define NOLESS(v,n) do{ if (v &lt; n) v = n; }while(0)</front>
<front id="macrosH-15">#define NOMORE(v,n) do{ if (v &gt; n) v = n; }while(0)</front>
<front id="macrosH-16"></front>
<front id="macrosH-17">// Macros to support option testing</front>
<front id="macrosH-18">#define _CAT(a, ...) a ## __VA_ARGS__</front>
<front id="macrosH-19">#define SWITCH_ENABLED_0 0</front>
<front id="macrosH-20">#define SWITCH_ENABLED_1 1</front>
<front id="macrosH-21">#define SWITCH_ENABLED_  1</front>
<front id="macrosH-22">#define ENABLED(b) _CAT(SWITCH_ENABLED_, b)</front>
<front id="macrosH-23">#define DISABLED(b) (!_CAT(SWITCH_ENABLED_, b))</front>
<front id="macrosH-24"></front>
<front id="macrosH-25">#define COUNT(a) (sizeof(a)/sizeof(*a))</front>
<front id="macrosH-26"></front>
<front id="macrosH-27">#endif //__MACROS_H</front>
 </pre>
<h1 id="MarlinHtitle" >Marlin.h</h1>
<pre id="MarlinH"  class="prettyprint linenums"><front id="MarlinH-1">// Tonokip RepRap firmware rewrite based off of Hydra-mmm firmware.</front>
<front id="MarlinH-2">// License: GPL</front>
<front id="MarlinH-3"></front>
<front id="MarlinH-4">#ifndef MARLIN_H</front>
<front id="MarlinH-5">#define MARLIN_H</front>
<front id="MarlinH-6"></front>
<front id="MarlinH-7">#define  FORCE_INLINE __attribute__((always_inline)) inline</front>
<front id="MarlinH-8">/**</front>
<front id="MarlinH-9"> * Compiler warning on unused varable.</front>
<front id="MarlinH-10"> */</front>
<front id="MarlinH-11">#define UNUSED(x) (void) (x)</front>
<front id="MarlinH-12"></front>
<front id="MarlinH-13">#include &lt;math.h&gt;</front>
<front id="MarlinH-14">#include &lt;stdio.h&gt;</front>
<front id="MarlinH-15">#include &lt;stdlib.h&gt;</front>
<front id="MarlinH-16">#include &lt;string.h&gt;</front>
<front id="MarlinH-17">#include &lt;inttypes.h&gt;</front>
<front id="MarlinH-18"></front>
<front id="MarlinH-19">#include &lt;util/delay.h&gt;</front>
<front id="MarlinH-20">#include &lt;avr/pgmspace.h&gt;</front>
<front id="MarlinH-21">#include &lt;avr/eeprom.h&gt;</front>
<front id="MarlinH-22">#include &lt;avr/interrupt.h&gt;</front>
<front id="MarlinH-23"></front>
<front id="MarlinH-24"></front>
<front id="MarlinH-25">#include "fastio.h"</front>
<front id="MarlinH-26">#include "Configuration.h"</front>
<front id="MarlinH-27">#include "pins.h"</front>
<front id="MarlinH-28"></front>
<front id="MarlinH-29">#ifndef SANITYCHECK_H</front>
<front id="MarlinH-30">  #error Your Configuration.h and Configuration_adv.h files are outdated!</front>
<front id="MarlinH-31">#endif</front>
<front id="MarlinH-32"></front>
<front id="MarlinH-33">#include "Arduino.h"</front>
<front id="MarlinH-34"></front>
<front id="MarlinH-35">typedef unsigned long millis_t;</front>
<front id="MarlinH-36"></front>
<front id="MarlinH-37">// Arduino &lt; 1.0.0 does not define this, so we need to do it ourselves</front>
<front id="MarlinH-38">#ifndef analogInputToDigitalPin</front>
<front id="MarlinH-39">  #define analogInputToDigitalPin(p) ((p) + 0xA0)</front>
<front id="MarlinH-40">#endif</front>
<front id="MarlinH-41"></front>
<front id="MarlinH-42">#ifdef USBCON</front>
<front id="MarlinH-43">  #include "HardwareSerial.h"</front>
<front id="MarlinH-44">#endif</front>
<front id="MarlinH-45"></front>
<front id="MarlinH-46">#include "MarlinSerial.h"</front>
<front id="MarlinH-47"></front>
<front id="MarlinH-48">#ifndef cbi</front>
<front id="MarlinH-49">  #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))</front>
<front id="MarlinH-50">#endif</front>
<front id="MarlinH-51">#ifndef sbi</front>
<front id="MarlinH-52">  #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))</front>
<front id="MarlinH-53">#endif</front>
<front id="MarlinH-54"></front>
<front id="MarlinH-55">#include "WString.h"</front>
<front id="MarlinH-56"></front>
<front id="MarlinH-57">#ifdef USBCON</front>
<front id="MarlinH-58">  #if ENABLED(BLUETOOTH)</front>
<front id="MarlinH-59">    #define MYSERIAL bluetoothSerial</front>
<front id="MarlinH-60">  #else</front>
<front id="MarlinH-61">    #define MYSERIAL Serial</front>
<front id="MarlinH-62">  #endif // BLUETOOTH</front>
<front id="MarlinH-63">#else</front>
<front id="MarlinH-64">  #define MYSERIAL customizedSerial</front>
<front id="MarlinH-65">#endif</front>
<front id="MarlinH-66"></front>
<front id="MarlinH-67">#define SERIAL_CHAR(x) MYSERIAL.write(x)</front>
<front id="MarlinH-68">#define SERIAL_EOL SERIAL_CHAR('\n')</front>
<front id="MarlinH-69"></front>
<front id="MarlinH-70">#define SERIAL_PROTOCOLCHAR(x) SERIAL_CHAR(x)</front>
<front id="MarlinH-71">#define SERIAL_PROTOCOL(x) MYSERIAL.print(x)</front>
<front id="MarlinH-72">#define SERIAL_PROTOCOL_F(x,y) MYSERIAL.print(x,y)</front>
<front id="MarlinH-73">#define SERIAL_PROTOCOLPGM(x) serialprintPGM(PSTR(x))</front>
<front id="MarlinH-74">#define SERIAL_PROTOCOLLN(x) do{ MYSERIAL.print(x); SERIAL_EOL; }while(0)</front>
<front id="MarlinH-75">#define SERIAL_PROTOCOLLNPGM(x) do{ serialprintPGM(PSTR(x)); SERIAL_EOL; }while(0)</front>
<front id="MarlinH-76"></front>
<front id="MarlinH-77"></front>
<front id="MarlinH-78">extern const char errormagic[] PROGMEM;</front>
<front id="MarlinH-79">extern const char echomagic[] PROGMEM;</front>
<front id="MarlinH-80"></front>
<front id="MarlinH-81">#define SERIAL_ERROR_START serialprintPGM(errormagic)</front>
<front id="MarlinH-82">#define SERIAL_ERROR(x) SERIAL_PROTOCOL(x)</front>
<front id="MarlinH-83">#define SERIAL_ERRORPGM(x) SERIAL_PROTOCOLPGM(x)</front>
<front id="MarlinH-84">#define SERIAL_ERRORLN(x) SERIAL_PROTOCOLLN(x)</front>
<front id="MarlinH-85">#define SERIAL_ERRORLNPGM(x) SERIAL_PROTOCOLLNPGM(x)</front>
<front id="MarlinH-86"></front>
<front id="MarlinH-87">#define SERIAL_ECHO_START serialprintPGM(echomagic)</front>
<front id="MarlinH-88">#define SERIAL_ECHO(x) SERIAL_PROTOCOL(x)</front>
<front id="MarlinH-89">#define SERIAL_ECHOPGM(x) SERIAL_PROTOCOLPGM(x)</front>
<front id="MarlinH-90">#define SERIAL_ECHOLN(x) SERIAL_PROTOCOLLN(x)</front>
<front id="MarlinH-91">#define SERIAL_ECHOLNPGM(x) SERIAL_PROTOCOLLNPGM(x)</front>
<front id="MarlinH-92"></front>
<front id="MarlinH-93">#define SERIAL_ECHOPAIR(name,value) do{ serial_echopair_P(PSTR(name),(value)); }while(0)</front>
<front id="MarlinH-94"></front>
<front id="MarlinH-95">void serial_echopair_P(const char *s_P, int v);</front>
<front id="MarlinH-96">void serial_echopair_P(const char *s_P, long v);</front>
<front id="MarlinH-97">void serial_echopair_P(const char *s_P, float v);</front>
<front id="MarlinH-98">void serial_echopair_P(const char *s_P, double v);</front>
<front id="MarlinH-99">void serial_echopair_P(const char *s_P, unsigned long v);</front>
<front id="MarlinH-100"></front>
<front id="MarlinH-101"></front>
<front id="MarlinH-102">// Things to write to serial from Program memory. Saves 400 to 2k of RAM.</front>
<front id="MarlinH-103">FORCE_INLINE void serialprintPGM(const char *str) {</front>
<front id="MarlinH-104">  char ch;</front>
<front id="MarlinH-105">  while ((ch = pgm_read_byte(str))) {</front>
<front id="MarlinH-106">    MYSERIAL.write(ch);</front>
<front id="MarlinH-107">    str++;</front>
<front id="MarlinH-108">  }</front>
<front id="MarlinH-109">}</front>
<front id="MarlinH-110"></front>
<front id="MarlinH-111">void get_command();</front>
<front id="MarlinH-112"></front>
<front id="MarlinH-113">void idle(); // the standard idle routine calls manage_inactivity(false)</front>
<front id="MarlinH-114"></front>
<front id="MarlinH-115">void manage_inactivity(bool ignore_stepper_queue=false);</front>
<front id="MarlinH-116"></front>
<front id="MarlinH-117">#if ENABLED(DUAL_X_CARRIAGE) && HAS_X_ENABLE && HAS_X2_ENABLE</front>
<front id="MarlinH-118">  #define  enable_x() do { X_ENABLE_WRITE( X_ENABLE_ON); X2_ENABLE_WRITE( X_ENABLE_ON); } while (0)</front>
<front id="MarlinH-119">  #define disable_x() do { X_ENABLE_WRITE(!X_ENABLE_ON); X2_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; } while (0)</front>
<front id="MarlinH-120">#elif HAS_X_ENABLE</front>
<front id="MarlinH-121">  #define  enable_x() X_ENABLE_WRITE( X_ENABLE_ON)</front>
<front id="MarlinH-122">  #define disable_x() { X_ENABLE_WRITE(!X_ENABLE_ON); axis_known_position[X_AXIS] = false; }</front>
<front id="MarlinH-123">#else</front>
<front id="MarlinH-124">  #define enable_x() ;</front>
<front id="MarlinH-125">  #define disable_x() ;</front>
<front id="MarlinH-126">#endif</front>
<front id="MarlinH-127"></front>
<front id="MarlinH-128">#if HAS_Y_ENABLE</front>
<front id="MarlinH-129">  #if ENABLED(Y_DUAL_STEPPER_DRIVERS)</front>
<front id="MarlinH-130">    #define  enable_y() { Y_ENABLE_WRITE( Y_ENABLE_ON); Y2_ENABLE_WRITE(Y_ENABLE_ON); }</front>
<front id="MarlinH-131">    #define disable_y() { Y_ENABLE_WRITE(!Y_ENABLE_ON); Y2_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }</front>
<front id="MarlinH-132">  #else</front>
<front id="MarlinH-133">    #define  enable_y() Y_ENABLE_WRITE( Y_ENABLE_ON)</front>
<front id="MarlinH-134">    #define disable_y() { Y_ENABLE_WRITE(!Y_ENABLE_ON); axis_known_position[Y_AXIS] = false; }</front>
<front id="MarlinH-135">  #endif</front>
<front id="MarlinH-136">#else</front>
<front id="MarlinH-137">  #define enable_y() ;</front>
<front id="MarlinH-138">  #define disable_y() ;</front>
<front id="MarlinH-139">#endif</front>
<front id="MarlinH-140"></front>
<front id="MarlinH-141">#if HAS_Z_ENABLE</front>
<front id="MarlinH-142">  #if ENABLED(Z_DUAL_STEPPER_DRIVERS)</front>
<front id="MarlinH-143">    #define  enable_z() { Z_ENABLE_WRITE( Z_ENABLE_ON); Z2_ENABLE_WRITE(Z_ENABLE_ON); }</front>
<front id="MarlinH-144">    #define disable_z() { Z_ENABLE_WRITE(!Z_ENABLE_ON); Z2_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }</front>
<front id="MarlinH-145">  #else</front>
<front id="MarlinH-146">    #define  enable_z() Z_ENABLE_WRITE( Z_ENABLE_ON)</front>
<front id="MarlinH-147">    #define disable_z() { Z_ENABLE_WRITE(!Z_ENABLE_ON); axis_known_position[Z_AXIS] = false; }</front>
<front id="MarlinH-148">  #endif</front>
<front id="MarlinH-149">#else</front>
<front id="MarlinH-150">  #define enable_z() ;</front>
<front id="MarlinH-151">  #define disable_z() ;</front>
<front id="MarlinH-152">#endif</front>
<front id="MarlinH-153"></front>
<front id="MarlinH-154">#if HAS_E0_ENABLE</front>
<front id="MarlinH-155">  #define enable_e0()  E0_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-156">  #define disable_e0() E0_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-157">#else</front>
<front id="MarlinH-158">  #define enable_e0()  /* nothing */</front>
<front id="MarlinH-159">  #define disable_e0() /* nothing */</front>
<front id="MarlinH-160">#endif</front>
<front id="MarlinH-161"></front>
<front id="MarlinH-162">#if (EXTRUDERS &gt; 1) && HAS_E1_ENABLE</front>
<front id="MarlinH-163">  #define enable_e1()  E1_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-164">  #define disable_e1() E1_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-165">#else</front>
<front id="MarlinH-166">  #define enable_e1()  /* nothing */</front>
<front id="MarlinH-167">  #define disable_e1() /* nothing */</front>
<front id="MarlinH-168">#endif</front>
<front id="MarlinH-169"></front>
<front id="MarlinH-170">#if (EXTRUDERS &gt; 2) && HAS_E2_ENABLE</front>
<front id="MarlinH-171">  #define enable_e2()  E2_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-172">  #define disable_e2() E2_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-173">#else</front>
<front id="MarlinH-174">  #define enable_e2()  /* nothing */</front>
<front id="MarlinH-175">  #define disable_e2() /* nothing */</front>
<front id="MarlinH-176">#endif</front>
<front id="MarlinH-177"></front>
<front id="MarlinH-178">#if (EXTRUDERS &gt; 3) && HAS_E3_ENABLE</front>
<front id="MarlinH-179">  #define enable_e3()  E3_ENABLE_WRITE( E_ENABLE_ON)</front>
<front id="MarlinH-180">  #define disable_e3() E3_ENABLE_WRITE(!E_ENABLE_ON)</front>
<front id="MarlinH-181">#else</front>
<front id="MarlinH-182">  #define enable_e3()  /* nothing */</front>
<front id="MarlinH-183">  #define disable_e3() /* nothing */</front>
<front id="MarlinH-184">#endif</front>
<front id="MarlinH-185"></front>
<front id="MarlinH-186">/**</front>
<front id="MarlinH-187"> * The axis order in all axis related arrays is X, Y, Z, E</front>
<front id="MarlinH-188"> */</front>
<front id="MarlinH-189">#define NUM_AXIS 4</front>
<front id="MarlinH-190"></front>
<front id="MarlinH-191">/**</front>
<front id="MarlinH-192"> * Axis indices as enumerated constants</front>
<front id="MarlinH-193"> *</front>
<front id="MarlinH-194"> * A_AXIS and B_AXIS are used by COREXY printers</front>
<front id="MarlinH-195"> * X_HEAD and Y_HEAD is used for systems that don't have a 1:1 relationship between X_AXIS and X Head movement, like CoreXY bots.</front>
<front id="MarlinH-196"> */</front>
<front id="MarlinH-197">enum AxisEnum {X_AXIS=0, A_AXIS=0, Y_AXIS=1, B_AXIS=1, Z_AXIS=2, C_AXIS=2, E_AXIS=3, X_HEAD=4, Y_HEAD=5, Z_HEAD=5};</front>
<front id="MarlinH-198"></front>
<front id="MarlinH-199">enum EndstopEnum {X_MIN=0, Y_MIN=1, Z_MIN=2, Z_MIN_PROBE=3, X_MAX=4, Y_MAX=5, Z_MAX=6, Z2_MIN=7, Z2_MAX=8};</front>
<front id="MarlinH-200"></front>
<front id="MarlinH-201">void enable_all_steppers();</front>
<front id="MarlinH-202">void disable_all_steppers();</front>
<front id="MarlinH-203"></front>
<front id="MarlinH-204">void FlushSerialRequestResend();</front>
<front id="MarlinH-205">void ok_to_send();</front>
<front id="MarlinH-206"></front>
<front id="MarlinH-207">void reset_bed_level();</front>
<front id="MarlinH-208">void prepare_move();</front>
<front id="MarlinH-209">void kill(const char *);</front>
<front id="MarlinH-210">void Stop();</front>
<front id="MarlinH-211"></front>
<front id="MarlinH-212">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="MarlinH-213">  void filrunout();</front>
<front id="MarlinH-214">#endif</front>
<front id="MarlinH-215"></front>
<front id="MarlinH-216">/**</front>
<front id="MarlinH-217"> * Debug flags - not yet widely applied</front>
<front id="MarlinH-218"> */</front>
<front id="MarlinH-219">enum DebugFlags {</front>
<front id="MarlinH-220">  DEBUG_ECHO          = BIT(0),</front>
<front id="MarlinH-221">  DEBUG_INFO          = BIT(1),</front>
<front id="MarlinH-222">  DEBUG_ERRORS        = BIT(2),</front>
<front id="MarlinH-223">  DEBUG_DRYRUN        = BIT(3),</front>
<front id="MarlinH-224">  DEBUG_COMMUNICATION = BIT(4),</front>
<front id="MarlinH-225">  DEBUG_LEVELING      = BIT(5)</front>
<front id="MarlinH-226">};</front>
<front id="MarlinH-227">extern uint8_t marlin_debug_flags;</front>
<front id="MarlinH-228"></front>
<front id="MarlinH-229">extern bool Running;</front>
<front id="MarlinH-230">inline bool IsRunning() { return  Running; }</front>
<front id="MarlinH-231">inline bool IsStopped() { return !Running; }</front>
<front id="MarlinH-232"></front>
<front id="MarlinH-233">bool enqueuecommand(const char *cmd); //put a single ASCII command at the end of the current buffer or return false when it is full</front>
<front id="MarlinH-234">void enqueuecommands_P(const char *cmd); //put one or many ASCII commands at the end of the current buffer, read from flash</front>
<front id="MarlinH-235"></front>
<front id="MarlinH-236">void prepare_arc_move(char isclockwise);</front>
<front id="MarlinH-237">void clamp_to_software_endstops(float target[3]);</front>
<front id="MarlinH-238"></front>
<front id="MarlinH-239">extern millis_t previous_cmd_ms;</front>
<front id="MarlinH-240">inline void refresh_cmd_timeout() { previous_cmd_ms = millis(); }</front>
<front id="MarlinH-241"></front>
<front id="MarlinH-242">#if ENABLED(FAST_PWM_FAN)</front>
<front id="MarlinH-243">  void setPwmFrequency(uint8_t pin, int val);</front>
<front id="MarlinH-244">#endif</front>
<front id="MarlinH-245"></front>
<front id="MarlinH-246">#ifndef CRITICAL_SECTION_START</front>
<front id="MarlinH-247">  #define CRITICAL_SECTION_START  unsigned char _sreg = SREG; cli();</front>
<front id="MarlinH-248">  #define CRITICAL_SECTION_END    SREG = _sreg;</front>
<front id="MarlinH-249">#endif</front>
<front id="MarlinH-250"></front>
<front id="MarlinH-251">extern bool axis_relative_modes[];</front>
<front id="MarlinH-252">extern int feedrate_multiplier;</front>
<front id="MarlinH-253">extern bool volumetric_enabled;</front>
<front id="MarlinH-254">extern int extruder_multiplier[EXTRUDERS]; // sets extrude multiply factor (in percent) for each extruder individually</front>
<front id="MarlinH-255">extern float filament_size[EXTRUDERS]; // cross-sectional area of filament (in millimeters), typically around 1.75 or 2.85, 0 disables the volumetric calculations for the extruder.</front>
<front id="MarlinH-256">extern float volumetric_multiplier[EXTRUDERS]; // reciprocal of cross-sectional area of filament (in square millimeters), stored this way to reduce computational burden in planner</front>
<front id="MarlinH-257">extern float current_position[NUM_AXIS];</front>
<front id="MarlinH-258">extern float home_offset[3]; // axis[n].home_offset</front>
<front id="MarlinH-259">extern float min_pos[3]; // axis[n].min_pos</front>
<front id="MarlinH-260">extern float max_pos[3]; // axis[n].max_pos</front>
<front id="MarlinH-261">extern bool axis_known_position[3]; // axis[n].is_known</front>
<front id="MarlinH-262">#ifdef RESUME_FEATURE</front>
<front id="MarlinH-263">  extern float planner_disabled_below_z;</front>
<front id="MarlinH-264">#endif</front>
<front id="MarlinH-265">#ifdef TRACK_LAYER</front>
<front id="MarlinH-266">  extern float last_layer_z;</front>
<front id="MarlinH-267">  extern unsigned short current_layer; // estimated current layer number</front>
<front id="MarlinH-268">#endif //TRACK_LAYER</front>
<front id="MarlinH-269"></front>
<front id="MarlinH-270">#if ENABLED(DELTA)</front>
<front id="MarlinH-271">  extern float delta[3];</front>
<front id="MarlinH-272">  extern float endstop_adj[3]; // axis[n].endstop_adj</front>
<front id="MarlinH-273">  extern float delta_radius;</front>
<front id="MarlinH-274">  #ifndef DELTA_RADIUS_TRIM_TOWER_1</front>
<front id="MarlinH-275">    #define DELTA_RADIUS_TRIM_TOWER_1 0.0</front>
<front id="MarlinH-276">  #endif</front>
<front id="MarlinH-277">  #ifndef DELTA_RADIUS_TRIM_TOWER_2</front>
<front id="MarlinH-278">    #define DELTA_RADIUS_TRIM_TOWER_2 0.0</front>
<front id="MarlinH-279">  #endif</front>
<front id="MarlinH-280">  #ifndef DELTA_RADIUS_TRIM_TOWER_3</front>
<front id="MarlinH-281">    #define DELTA_RADIUS_TRIM_TOWER_3 0.0</front>
<front id="MarlinH-282">  #endif</front>
<front id="MarlinH-283">  extern float delta_diagonal_rod;</front>
<front id="MarlinH-284">  #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_1</front>
<front id="MarlinH-285">    #define DELTA_DIAGONAL_ROD_TRIM_TOWER_1 0.0</front>
<front id="MarlinH-286">  #endif</front>
<front id="MarlinH-287">  #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_2</front>
<front id="MarlinH-288">    #define DELTA_DIAGONAL_ROD_TRIM_TOWER_2 0.0</front>
<front id="MarlinH-289">  #endif</front>
<front id="MarlinH-290">  #ifndef DELTA_DIAGONAL_ROD_TRIM_TOWER_3</front>
<front id="MarlinH-291">    #define DELTA_DIAGONAL_ROD_TRIM_TOWER_3 0.0</front>
<front id="MarlinH-292">  #endif</front>
<front id="MarlinH-293">  extern float delta_segments_per_second;</front>
<front id="MarlinH-294">  void calculate_delta(float cartesian[3]);</front>
<front id="MarlinH-295">  void recalc_delta_settings(float radius, float diagonal_rod);</front>
<front id="MarlinH-296">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="MarlinH-297">    extern int delta_grid_spacing[2];</front>
<front id="MarlinH-298">    void adjust_delta(float cartesian[3]);</front>
<front id="MarlinH-299">  #endif</front>
<front id="MarlinH-300">#elif ENABLED(SCARA)</front>
<front id="MarlinH-301">  extern float axis_scaling[3];  // Build size scaling</front>
<front id="MarlinH-302">  void calculate_delta(float cartesian[3]);</front>
<front id="MarlinH-303">  void calculate_SCARA_forward_Transform(float f_scara[3]);</front>
<front id="MarlinH-304">#endif</front>
<front id="MarlinH-305"></front>
<front id="MarlinH-306">#if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="MarlinH-307">  extern float z_endstop_adj;</front>
<front id="MarlinH-308">#endif</front>
<front id="MarlinH-309"></front>
<front id="MarlinH-310">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="MarlinH-311">  extern float zprobe_zoffset;</front>
<front id="MarlinH-312">#endif</front>
<front id="MarlinH-313"></front>
<front id="MarlinH-314">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="MarlinH-315">  extern float extrude_min_temp;</front>
<front id="MarlinH-316">#endif</front>
<front id="MarlinH-317"></front>
<front id="MarlinH-318">extern int fanSpeed;</front>
<front id="MarlinH-319"></front>
<front id="MarlinH-320">#if ENABLED(BARICUDA)</front>
<front id="MarlinH-321">  extern int ValvePressure;</front>
<front id="MarlinH-322">  extern int EtoPPressure;</front>
<front id="MarlinH-323">#endif</front>
<front id="MarlinH-324"></front>
<front id="MarlinH-325">#if ENABLED(FAN_SOFT_PWM)</front>
<front id="MarlinH-326">  extern unsigned char fanSpeedSoftPwm;</front>
<front id="MarlinH-327">#endif</front>
<front id="MarlinH-328"></front>
<front id="MarlinH-329">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="MarlinH-330">  extern float filament_width_nominal;  //holds the theoretical filament diameter ie., 3.00 or 1.75</front>
<front id="MarlinH-331">  extern bool filament_sensor;  //indicates that filament sensor readings should control extrusion</front>
<front id="MarlinH-332">  extern float filament_width_meas; //holds the filament diameter as accurately measured</front>
<front id="MarlinH-333">  extern signed char measurement_delay[];  //ring buffer to delay measurement</front>
<front id="MarlinH-334">  extern int delay_index1, delay_index2;  //ring buffer index. used by planner, temperature, and main code</front>
<front id="MarlinH-335">  extern float delay_dist; //delay distance counter</front>
<front id="MarlinH-336">  extern int meas_delay_cm; //delay distance</front>
<front id="MarlinH-337">#endif</front>
<front id="MarlinH-338"></front>
<front id="MarlinH-339">#if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="MarlinH-340">  extern int lpq_len;</front>
<front id="MarlinH-341">#endif</front>
<front id="MarlinH-342"></front>
<front id="MarlinH-343">#if ENABLED(FWRETRACT)</front>
<front id="MarlinH-344">  extern bool autoretract_enabled;</front>
<front id="MarlinH-345">  extern bool retracted[EXTRUDERS]; // extruder[n].retracted</front>
<front id="MarlinH-346">  extern float retract_length, retract_length_swap, retract_feedrate, retract_zlift;</front>
<front id="MarlinH-347">  extern float retract_recover_length, retract_recover_length_swap, retract_recover_feedrate;</front>
<front id="MarlinH-348">#endif</front>
<front id="MarlinH-349"></front>
<front id="MarlinH-350">extern millis_t print_job_start_ms;</front>
<front id="MarlinH-351">extern millis_t print_job_stop_ms;</front>
<front id="MarlinH-352"></front>
<front id="MarlinH-353">// Handling multiple extruders pins</front>
<front id="MarlinH-354">extern uint8_t active_extruder;</front>
<front id="MarlinH-355"></front>
<front id="MarlinH-356">#if ENABLED(DIGIPOT_I2C)</front>
<front id="MarlinH-357">  extern void digipot_i2c_set_current( int channel, float current );</front>
<front id="MarlinH-358">  extern void digipot_i2c_init();</front>
<front id="MarlinH-359">#endif</front>
<front id="MarlinH-360"></front>
<front id="MarlinH-361">extern void calculate_volumetric_multipliers();</front>
<front id="MarlinH-362"></front>
<front id="MarlinH-363">#endif //MARLIN_H</front>
 </pre>
<h1 id="Marlin_mainCPPtitle" >Marlin_main.cpp</h1>
<pre id="Marlin_mainCPP"  class="prettyprint linenums"><front id="Marlin_mainCPP-1">/**</front>
<front id="Marlin_mainCPP-2"> * Marlin Firmware</front>
<front id="Marlin_mainCPP-3"> *</front>
<front id="Marlin_mainCPP-4"> * Based on Sprinter and grbl.</front>
<front id="Marlin_mainCPP-5"> * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm</front>
<front id="Marlin_mainCPP-6"> *</front>
<front id="Marlin_mainCPP-7"> * This program is free software: you can redistribute it and/or modify</front>
<front id="Marlin_mainCPP-8"> * it under the terms of the GNU General Public License as published by</front>
<front id="Marlin_mainCPP-9"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Marlin_mainCPP-10"> * (at your option) any later version.</front>
<front id="Marlin_mainCPP-11"> *</front>
<front id="Marlin_mainCPP-12"> * This program is distributed in the hope that it will be useful,</front>
<front id="Marlin_mainCPP-13"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Marlin_mainCPP-14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Marlin_mainCPP-15"> * GNU General Public License for more details.</front>
<front id="Marlin_mainCPP-16"> *</front>
<front id="Marlin_mainCPP-17"> * You should have received a copy of the GNU General Public License</front>
<front id="Marlin_mainCPP-18"> * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Marlin_mainCPP-19"> *</front>
<front id="Marlin_mainCPP-20"> * About Marlin</front>
<front id="Marlin_mainCPP-21"> *</front>
<front id="Marlin_mainCPP-22"> * This firmware is a mashup between Sprinter and grbl.</front>
<front id="Marlin_mainCPP-23"> *  - https://github.com/kliment/Sprinter</front>
<front id="Marlin_mainCPP-24"> *  - https://github.com/simen/grbl/tree</front>
<front id="Marlin_mainCPP-25"> *</front>
<front id="Marlin_mainCPP-26"> * It has preliminary support for Matthew Roberts advance algorithm</front>
<front id="Marlin_mainCPP-27"> *  - http://reprap.org/pipermail/reprap-dev/2011-May/003323.html</front>
<front id="Marlin_mainCPP-28"> */</front>
<front id="Marlin_mainCPP-29"></front>
<front id="Marlin_mainCPP-30">#include "Marlin.h"</front>
<front id="Marlin_mainCPP-31"></front>
<front id="Marlin_mainCPP-32">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-33">  #include "vector_3.h"</front>
<front id="Marlin_mainCPP-34">  #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-35">    #include "qr_solve.h"</front>
<front id="Marlin_mainCPP-36">  #endif</front>
<front id="Marlin_mainCPP-37">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-38"></front>
<front id="Marlin_mainCPP-39">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-40">  #include "mesh_bed_leveling.h"</front>
<front id="Marlin_mainCPP-41">#endif</front>
<front id="Marlin_mainCPP-42"></front>
<front id="Marlin_mainCPP-43">#include "ultralcd.h"</front>
<front id="Marlin_mainCPP-44">#include "planner.h"</front>
<front id="Marlin_mainCPP-45">#include "stepper.h"</front>
<front id="Marlin_mainCPP-46">#include "temperature.h"</front>
<front id="Marlin_mainCPP-47">#include "cardreader.h"</front>
<front id="Marlin_mainCPP-48">#include "watchdog.h"</front>
<front id="Marlin_mainCPP-49">#include "configuration_store.h"</front>
<front id="Marlin_mainCPP-50">#include "language.h"</front>
<front id="Marlin_mainCPP-51">#include "pins_arduino.h"</front>
<front id="Marlin_mainCPP-52">#include "math.h"</front>
<front id="Marlin_mainCPP-53">#include "buzzer.h"</front>
<front id="Marlin_mainCPP-54"></front>
<front id="Marlin_mainCPP-55">#if ENABLED(BLINKM)</front>
<front id="Marlin_mainCPP-56">  #include "blinkm.h"</front>
<front id="Marlin_mainCPP-57">  #include "Wire.h"</front>
<front id="Marlin_mainCPP-58">#endif</front>
<front id="Marlin_mainCPP-59"></front>
<front id="Marlin_mainCPP-60">#if HAS_SERVOS</front>
<front id="Marlin_mainCPP-61">  #include "servo.h"</front>
<front id="Marlin_mainCPP-62">#endif</front>
<front id="Marlin_mainCPP-63"></front>
<front id="Marlin_mainCPP-64">#if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-65">  #include &lt;SPI.h&gt;</front>
<front id="Marlin_mainCPP-66">#endif</front>
<front id="Marlin_mainCPP-67"></front>
<front id="Marlin_mainCPP-68">/**</front>
<front id="Marlin_mainCPP-69"> * Look here for descriptions of G-codes:</front>
<front id="Marlin_mainCPP-70"> *  - http://linuxcnc.org/handbook/gcode/g-code.html</front>
<front id="Marlin_mainCPP-71"> *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes</front>
<front id="Marlin_mainCPP-72"> *</front>
<front id="Marlin_mainCPP-73"> * Help us document these G-codes online:</front>
<front id="Marlin_mainCPP-74"> *  - http://marlinfirmware.org/index.php/G-Code</front>
<front id="Marlin_mainCPP-75"> *  - http://reprap.org/wiki/G-code</front>
<front id="Marlin_mainCPP-76"> *</front>
<front id="Marlin_mainCPP-77"> * -----------------</front>
<front id="Marlin_mainCPP-78"> * Implemented Codes</front>
<front id="Marlin_mainCPP-79"> * -----------------</front>
<front id="Marlin_mainCPP-80"> *</front>
<front id="Marlin_mainCPP-81"> * "G" Codes</front>
<front id="Marlin_mainCPP-82"> *</front>
<front id="Marlin_mainCPP-83"> * G0  -&gt; G1</front>
<front id="Marlin_mainCPP-84"> * G1  - Coordinated Movement X Y Z E</front>
<front id="Marlin_mainCPP-85"> * G2  - CW ARC</front>
<front id="Marlin_mainCPP-86"> * G3  - CCW ARC</front>
<front id="Marlin_mainCPP-87"> * G4  - Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</front>
<front id="Marlin_mainCPP-88"> * G10 - retract filament according to settings of M207</front>
<front id="Marlin_mainCPP-89"> * G11 - retract recover filament according to settings of M208</front>
<front id="Marlin_mainCPP-90"> * G28 - Home one or more axes</front>
<front id="Marlin_mainCPP-91"> * G29 - Detailed Z probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.</front>
<front id="Marlin_mainCPP-92"> * G30 - Single Z probe, probes bed at current XY location.</front>
<front id="Marlin_mainCPP-93"> * G31 - Dock sled (Z_PROBE_SLED only)</front>
<front id="Marlin_mainCPP-94"> * G32 - Undock sled (Z_PROBE_SLED only)</front>
<front id="Marlin_mainCPP-95"> * G90 - Use Absolute Coordinates</front>
<front id="Marlin_mainCPP-96"> * G91 - Use Relative Coordinates</front>
<front id="Marlin_mainCPP-97"> * G92 - Set current position to coordinates given</front>
<front id="Marlin_mainCPP-98"> *</front>
<front id="Marlin_mainCPP-99"> * "M" Codes</front>
<front id="Marlin_mainCPP-100"> *</front>
<front id="Marlin_mainCPP-101"> * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)</front>
<front id="Marlin_mainCPP-102"> * M1   - Same as M0</front>
<front id="Marlin_mainCPP-103"> * M17  - Enable/Power all stepper motors</front>
<front id="Marlin_mainCPP-104"> * M18  - Disable all stepper motors; same as M84</front>
<front id="Marlin_mainCPP-105"> * M19  - Resume print from current (or given) Z height (disables all movements below the current Z position, a file must be selected to print after executing this M code)</front>
<front id="Marlin_mainCPP-106"> * M20  - List SD card</front>
<front id="Marlin_mainCPP-107"> * M21  - Init SD card</front>
<front id="Marlin_mainCPP-108"> * M22  - Release SD card</front>
<front id="Marlin_mainCPP-109"> * M23  - Select SD file (M23 filename.g)</front>
<front id="Marlin_mainCPP-110"> * M24  - Start/resume SD print</front>
<front id="Marlin_mainCPP-111"> * M25  - Pause SD print</front>
<front id="Marlin_mainCPP-112"> * M26  - Set SD position in bytes (M26 S12345)</front>
<front id="Marlin_mainCPP-113"> * M27  - Report SD print status</front>
<front id="Marlin_mainCPP-114"> * M28  - Start SD write (M28 filename.g)</front>
<front id="Marlin_mainCPP-115"> * M29  - Stop SD write</front>
<front id="Marlin_mainCPP-116"> * M30  - Delete file from SD (M30 filename.g)</front>
<front id="Marlin_mainCPP-117"> * M31  - Output time since last M109 or SD card start to serial</front>
<front id="Marlin_mainCPP-118"> * M32  - Select file and start SD print (Can be used _while_ printing from SD card files):</front>
<front id="Marlin_mainCPP-119"> *        syntax "M32 /path/filename#", or "M32 S&lt;startpos bytes&gt; !filename#"</front>
<front id="Marlin_mainCPP-120"> *        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).</front>
<front id="Marlin_mainCPP-121"> *        The '#' is necessary when calling from within sd files, as it stops buffer prereading</front>
<front id="Marlin_mainCPP-122"> * M33  - Get the longname version of a path</front>
<front id="Marlin_mainCPP-123"> * M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.</front>
<front id="Marlin_mainCPP-124"> * M48  - Measure Z_Probe repeatability. M48 [P # of points] [X position] [Y position] [V_erboseness #] [E_ngage Probe] [L # of legs of travel]</front>
<front id="Marlin_mainCPP-125"> * M80  - Turn on Power Supply</front>
<front id="Marlin_mainCPP-126"> * M81  - Turn off Power Supply</front>
<front id="Marlin_mainCPP-127"> * M82  - Set E codes absolute (default)</front>
<front id="Marlin_mainCPP-128"> * M83  - Set E codes relative while in Absolute Coordinates (G90) mode</front>
<front id="Marlin_mainCPP-129"> * M84  - Disable steppers until next move,</front>
<front id="Marlin_mainCPP-130"> *        or use S&lt;seconds&gt; to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.</front>
<front id="Marlin_mainCPP-131"> * M85  - Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</front>
<front id="Marlin_mainCPP-132"> * M92  - Set axis_steps_per_unit - same syntax as G92</front>
<front id="Marlin_mainCPP-133"> * M104 - Set extruder target temp</front>
<front id="Marlin_mainCPP-134"> * M105 - Read current temp</front>
<front id="Marlin_mainCPP-135"> * M106 - Fan on</front>
<front id="Marlin_mainCPP-136"> * M107 - Fan off</front>
<front id="Marlin_mainCPP-137"> * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-138"> *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-139"> *        IF AUTOTEMP is enabled, S&lt;mintemp&gt; B&lt;maxtemp&gt; F&lt;factor&gt;. Exit autotemp by any M109 without F</front>
<front id="Marlin_mainCPP-140"> * M110 - Set the current line number</front>
<front id="Marlin_mainCPP-141"> * M111 - Set debug flags with S&lt;mask&gt;. See flag bits defined in Marlin.h.</front>
<front id="Marlin_mainCPP-142"> * M112 - Emergency stop</front>
<front id="Marlin_mainCPP-143"> * M114 - Output current position to serial port</front>
<front id="Marlin_mainCPP-144"> * M115 - Capabilities string</front>
<front id="Marlin_mainCPP-145"> * M117 - Display a message on the controller screen</front>
<front id="Marlin_mainCPP-146"> * M119 - Output Endstop status to serial port</front>
<front id="Marlin_mainCPP-147"> * M120 - Enable endstop detection</front>
<front id="Marlin_mainCPP-148"> * M121 - Disable endstop detection</front>
<front id="Marlin_mainCPP-149"> * M126 - Solenoid Air Valve Open (BariCUDA support by jmil)</front>
<front id="Marlin_mainCPP-150"> * M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)</front>
<front id="Marlin_mainCPP-151"> * M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)</front>
<front id="Marlin_mainCPP-152"> * M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)</front>
<front id="Marlin_mainCPP-153"> * M140 - Set bed target temp</front>
<front id="Marlin_mainCPP-154"> * M145 - Set the heatup state H&lt;hotend&gt; B&lt;bed&gt; F&lt;fan speed&gt; for S&lt;material&gt; (0=PLA, 1=ABS)</front>
<front id="Marlin_mainCPP-155"> * M150 - Set BlinkM Color Output R: Red&lt;0-255&gt; U(!): Green&lt;0-255&gt; B: Blue&lt;0-255&gt; over i2c, G for green does not work.</front>
<front id="Marlin_mainCPP-156"> * M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-157"> *        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-158"> * M200 - set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).:D&lt;millimeters&gt;-</front>
<front id="Marlin_mainCPP-159"> * M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</front>
<front id="Marlin_mainCPP-160"> * M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!</front>
<front id="Marlin_mainCPP-161"> * M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</front>
<front id="Marlin_mainCPP-162"> * M204 - Set default acceleration: P for Printing moves, R for Retract only (no X, Y, Z) moves and T for Travel (non printing) moves (ex. M204 P800 T3000 R9000) in mm/sec^2</front>
<front id="Marlin_mainCPP-163"> * M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk</front>
<front id="Marlin_mainCPP-164"> * M206 - Set additional homing offset</front>
<front id="Marlin_mainCPP-165"> * M207 - Set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting</front>
<front id="Marlin_mainCPP-166"> * M208 - Set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]</front>
<front id="Marlin_mainCPP-167"> * M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-168"> * M218 - Set hotend offset (in mm): T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-169"> * M220 - Set speed factor override percentage: S&lt;factor in percent&gt;</front>
<front id="Marlin_mainCPP-170"> * M221 - Set extrude factor override percentage: S&lt;factor in percent&gt;</front>
<front id="Marlin_mainCPP-171"> * M226 - Wait until the specified pin reaches the state required: P&lt;pin number&gt; S&lt;pin state&gt;</front>
<front id="Marlin_mainCPP-172"> * M240 - Trigger a camera to take a photograph</front>
<front id="Marlin_mainCPP-173"> * M250 - Set LCD contrast C&lt;contrast value&gt; (value 0..63)</front>
<front id="Marlin_mainCPP-174"> * M280 - Set servo position absolute. P: servo index, S: angle or microseconds</front>
<front id="Marlin_mainCPP-175"> * M300 - Play beep sound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</front>
<front id="Marlin_mainCPP-176"> * M301 - Set PID parameters P I and D</front>
<front id="Marlin_mainCPP-177"> * M302 - Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</front>
<front id="Marlin_mainCPP-178"> * M303 - PID relay autotune S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</front>
<front id="Marlin_mainCPP-179"> * M304 - Set bed PID parameters P I and D</front>
<front id="Marlin_mainCPP-180"> * M380 - Activate solenoid on active extruder</front>
<front id="Marlin_mainCPP-181"> * M381 - Disable all solenoids</front>
<front id="Marlin_mainCPP-182"> * M400 - Finish all moves</front>
<front id="Marlin_mainCPP-183"> * M401 - Lower Z probe if present</front>
<front id="Marlin_mainCPP-184"> * M402 - Raise Z probe if present</front>
<front id="Marlin_mainCPP-185"> * M404 - N&lt;dia in mm&gt; Enter the nominal filament width (3mm, 1.75mm ) or will display nominal filament width without parameters</front>
<front id="Marlin_mainCPP-186"> * M405 - Turn on Filament Sensor extrusion control.  Optional D&lt;delay in cm&gt; to set delay in centimeters between sensor and extruder</front>
<front id="Marlin_mainCPP-187"> * M406 - Turn off Filament Sensor extrusion control</front>
<front id="Marlin_mainCPP-188"> * M407 - Display measured filament diameter</front>
<front id="Marlin_mainCPP-189"> * M410 - Quickstop. Abort all the planned moves</front>
<front id="Marlin_mainCPP-190"> * M420 - Enable/Disable Mesh Leveling (with current values) S1=enable S0=disable</front>
<front id="Marlin_mainCPP-191"> * M421 - Set a single Z coordinate in the Mesh Leveling grid. X&lt;mm&gt; Y&lt;mm&gt; Z&lt;mm&gt;</front>
<front id="Marlin_mainCPP-192"> * M428 - Set the home_offset logically based on the current_position</front>
<front id="Marlin_mainCPP-193"> * M500 - Store parameters in EEPROM</front>
<front id="Marlin_mainCPP-194"> * M501 - Read parameters from EEPROM (if you need reset them after you changed them temporarily).</front>
<front id="Marlin_mainCPP-195"> * M502 - Revert to the default "factory settings". You still need to store them in EEPROM afterwards if you want to.</front>
<front id="Marlin_mainCPP-196"> * M503 - Print the current settings (from memory not from EEPROM). Use S0 to leave off headings.</front>
<front id="Marlin_mainCPP-197"> * M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-198"> * M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</front>
<front id="Marlin_mainCPP-199"> * M665 - Set delta configurations: L&lt;diagonal rod&gt; R&lt;delta radius&gt; S&lt;segments/s&gt;</front>
<front id="Marlin_mainCPP-200"> * M666 - Set delta endstop adjustment</front>
<front id="Marlin_mainCPP-201"> * M605 - Set dual x-carriage movement mode: S&lt;mode&gt; [ X&lt;duplication x-offset&gt; R&lt;duplication temp offset&gt; ]</front>
<front id="Marlin_mainCPP-202"> * M907 - Set digital trimpot motor current using axis codes.</front>
<front id="Marlin_mainCPP-203"> * M908 - Control digital trimpot directly.</front>
<front id="Marlin_mainCPP-204"> * M350 - Set microstepping mode.</front>
<front id="Marlin_mainCPP-205"> * M351 - Toggle MS1 MS2 pins directly.</front>
<front id="Marlin_mainCPP-206"> *</front>
<front id="Marlin_mainCPP-207"> * ************ SCARA Specific - This can change to suit future G-code regulations</front>
<front id="Marlin_mainCPP-208"> * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)</front>
<front id="Marlin_mainCPP-209"> * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-210"> * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)</front>
<front id="Marlin_mainCPP-211"> * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-212"> * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)</front>
<front id="Marlin_mainCPP-213"> * M365 - SCARA calibration: Scaling factor, X, Y, Z axis</front>
<front id="Marlin_mainCPP-214"> * ************* SCARA End ***************</front>
<front id="Marlin_mainCPP-215"> *</front>
<front id="Marlin_mainCPP-216"> * ************ Custom codes - This can change to suit future G-code regulations</front>
<front id="Marlin_mainCPP-217"> * M100 - Watch Free Memory (For Debugging Only)</front>
<front id="Marlin_mainCPP-218"> * M851 - Set Z probe's Z offset (mm above extruder -- The value will always be negative)</front>
<front id="Marlin_mainCPP-219"></front>
<front id="Marlin_mainCPP-220"></front>
<front id="Marlin_mainCPP-221"> * M928 - Start SD logging (M928 filename.g) - ended by M29</front>
<front id="Marlin_mainCPP-222"> * M999 - Restart after being stopped by error</front>
<front id="Marlin_mainCPP-223"> *</front>
<front id="Marlin_mainCPP-224"> * "T" Codes</front>
<front id="Marlin_mainCPP-225"> *</front>
<front id="Marlin_mainCPP-226"> * T0-T3 - Select a tool by index (usually an extruder) [ F&lt;mm/min&gt; ]</front>
<front id="Marlin_mainCPP-227"> *</front>
<front id="Marlin_mainCPP-228"> */</front>
<front id="Marlin_mainCPP-229"></front>
<front id="Marlin_mainCPP-230">#if ENABLED(M100_FREE_MEMORY_WATCHER)</front>
<front id="Marlin_mainCPP-231">  void gcode_M100();</front>
<front id="Marlin_mainCPP-232">#endif</front>
<front id="Marlin_mainCPP-233"></front>
<front id="Marlin_mainCPP-234">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-235">  CardReader card;</front>
<front id="Marlin_mainCPP-236">#endif</front>
<front id="Marlin_mainCPP-237"></front>
<front id="Marlin_mainCPP-238">bool Running = true;</front>
<front id="Marlin_mainCPP-239"></front>
<front id="Marlin_mainCPP-240">uint8_t marlin_debug_flags = DEBUG_INFO|DEBUG_ERRORS;</front>
<front id="Marlin_mainCPP-241"></front>
<front id="Marlin_mainCPP-242">static float feedrate = 1500.0, saved_feedrate;</front>
<front id="Marlin_mainCPP-243">float current_position[NUM_AXIS] = { 0.0 };</front>
<front id="Marlin_mainCPP-244">static float destination[NUM_AXIS] = { 0.0 };</front>
<front id="Marlin_mainCPP-245">bool axis_known_position[3] = { false };</front>
<front id="Marlin_mainCPP-246"></front>
<front id="Marlin_mainCPP-247">static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;</front>
<front id="Marlin_mainCPP-248"></front>
<front id="Marlin_mainCPP-249">static char *current_command, *current_command_args;</front>
<front id="Marlin_mainCPP-250">static int cmd_queue_index_r = 0;</front>
<front id="Marlin_mainCPP-251">static int cmd_queue_index_w = 0;</front>
<front id="Marlin_mainCPP-252">static int commands_in_queue = 0;</front>
<front id="Marlin_mainCPP-253">static char command_queue[BUFSIZE][MAX_CMD_SIZE];</front>
<front id="Marlin_mainCPP-254"></front>
<front id="Marlin_mainCPP-255">const float homing_feedrate[] = HOMING_FEEDRATE;</front>
<front id="Marlin_mainCPP-256">bool axis_relative_modes[] = AXIS_RELATIVE_MODES;</front>
<front id="Marlin_mainCPP-257">int feedrate_multiplier = 100; //100-&gt;1 200-&gt;2</front>
<front id="Marlin_mainCPP-258">int saved_feedrate_multiplier;</front>
<front id="Marlin_mainCPP-259">int extruder_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);</front>
<front id="Marlin_mainCPP-260">bool volumetric_enabled = false;</front>
<front id="Marlin_mainCPP-261">float filament_size[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA);</front>
<front id="Marlin_mainCPP-262">float volumetric_multiplier[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);</front>
<front id="Marlin_mainCPP-263">float home_offset[3] = { 0 };</front>
<front id="Marlin_mainCPP-264">float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };</front>
<front id="Marlin_mainCPP-265">float max_pos[3] = { X_MAX_POS, Y_MAX_POS, Z_MAX_POS };</front>
<front id="Marlin_mainCPP-266"></front>
<front id="Marlin_mainCPP-267">uint8_t active_extruder = 0;</front>
<front id="Marlin_mainCPP-268">int fanSpeed = 0;</front>
<front id="Marlin_mainCPP-269">bool cancel_heatup = false;</front>
<front id="Marlin_mainCPP-270"></front>
<front id="Marlin_mainCPP-271">const char errormagic[] PROGMEM = "Error:";</front>
<front id="Marlin_mainCPP-272">const char echomagic[] PROGMEM = "echo:";</front>
<front id="Marlin_mainCPP-273">const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};</front>
<front id="Marlin_mainCPP-274"></front>
<front id="Marlin_mainCPP-275">static bool relative_mode = false;  //Determines Absolute or Relative Coordinates</front>
<front id="Marlin_mainCPP-276">static char serial_char;</front>
<front id="Marlin_mainCPP-277">static int serial_count = 0;</front>
<front id="Marlin_mainCPP-278">static boolean comment_mode = false;</front>
<front id="Marlin_mainCPP-279">static char *seen_pointer; ///&lt; A pointer to find chars in the command string (X, Y, Z, E, etc.)</front>
<front id="Marlin_mainCPP-280">const char* queued_commands_P= NULL; /* pointer to the current line in the active sequence of commands, or NULL when none */</front>
<front id="Marlin_mainCPP-281">const int sensitive_pins[] = SENSITIVE_PINS; ///&lt; Sensitive pin list for M42</front>
<front id="Marlin_mainCPP-282">// Inactivity shutdown</front>
<front id="Marlin_mainCPP-283">millis_t previous_cmd_ms = 0;</front>
<front id="Marlin_mainCPP-284">static millis_t max_inactive_time = 0;</front>
<front id="Marlin_mainCPP-285">static millis_t stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME * 1000L;</front>
<front id="Marlin_mainCPP-286">millis_t print_job_start_ms = 0; ///&lt; Print job start time</front>
<front id="Marlin_mainCPP-287">millis_t print_job_stop_ms = 0;  ///&lt; Print job stop time</front>
<front id="Marlin_mainCPP-288">static uint8_t target_extruder;</front>
<front id="Marlin_mainCPP-289">bool no_wait_for_cooling = true;</front>
<front id="Marlin_mainCPP-290">bool target_direction;</front>
<front id="Marlin_mainCPP-291"></front>
<front id="Marlin_mainCPP-292">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-293">  int xy_travel_speed = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-294">  float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-295">#endif</front>
<front id="Marlin_mainCPP-296"></front>
<front id="Marlin_mainCPP-297">#if ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-298">  float z_endstop_adj = 0;</front>
<front id="Marlin_mainCPP-299">#endif</front>
<front id="Marlin_mainCPP-300"></front>
<front id="Marlin_mainCPP-301">// Extruder offsets</front>
<front id="Marlin_mainCPP-302">#if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-303">  #ifndef EXTRUDER_OFFSET_X</front>
<front id="Marlin_mainCPP-304">    #define EXTRUDER_OFFSET_X { 0 }</front>
<front id="Marlin_mainCPP-305">  #endif</front>
<front id="Marlin_mainCPP-306">  #ifndef EXTRUDER_OFFSET_Y</front>
<front id="Marlin_mainCPP-307">    #define EXTRUDER_OFFSET_Y { 0 }</front>
<front id="Marlin_mainCPP-308">  #endif</front>
<front id="Marlin_mainCPP-309">  float extruder_offset[][EXTRUDERS] = {</front>
<front id="Marlin_mainCPP-310">    EXTRUDER_OFFSET_X,</front>
<front id="Marlin_mainCPP-311">    EXTRUDER_OFFSET_Y</front>
<front id="Marlin_mainCPP-312">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-313">      , { 0 } // supports offsets in XYZ plane</front>
<front id="Marlin_mainCPP-314">    #endif</front>
<front id="Marlin_mainCPP-315">  };</front>
<front id="Marlin_mainCPP-316">#endif</front>
<front id="Marlin_mainCPP-317"></front>
<front id="Marlin_mainCPP-318">#if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-319">  const int servo_endstop_id[] = SERVO_ENDSTOP_IDS;</front>
<front id="Marlin_mainCPP-320">  const int servo_endstop_angle[][2] = SERVO_ENDSTOP_ANGLES;</front>
<front id="Marlin_mainCPP-321">#endif</front>
<front id="Marlin_mainCPP-322"></front>
<front id="Marlin_mainCPP-323">#if ENABLED(BARICUDA)</front>
<front id="Marlin_mainCPP-324">  int ValvePressure = 0;</front>
<front id="Marlin_mainCPP-325">  int EtoPPressure = 0;</front>
<front id="Marlin_mainCPP-326">#endif</front>
<front id="Marlin_mainCPP-327"></front>
<front id="Marlin_mainCPP-328">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-329"></front>
<front id="Marlin_mainCPP-330">  bool autoretract_enabled = false;</front>
<front id="Marlin_mainCPP-331">  bool retracted[EXTRUDERS] = { false };</front>
<front id="Marlin_mainCPP-332">  bool retracted_swap[EXTRUDERS] = { false };</front>
<front id="Marlin_mainCPP-333"></front>
<front id="Marlin_mainCPP-334">  float retract_length = RETRACT_LENGTH;</front>
<front id="Marlin_mainCPP-335">  float retract_length_swap = RETRACT_LENGTH_SWAP;</front>
<front id="Marlin_mainCPP-336">  float retract_feedrate = RETRACT_FEEDRATE;</front>
<front id="Marlin_mainCPP-337">  float retract_zlift = RETRACT_ZLIFT;</front>
<front id="Marlin_mainCPP-338">  float retract_recover_length = RETRACT_RECOVER_LENGTH;</front>
<front id="Marlin_mainCPP-339">  float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;</front>
<front id="Marlin_mainCPP-340">  float retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;</front>
<front id="Marlin_mainCPP-341"></front>
<front id="Marlin_mainCPP-342">#endif // FWRETRACT</front>
<front id="Marlin_mainCPP-343"></front>
<front id="Marlin_mainCPP-344">#if ENABLED(ULTIPANEL) && HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-345">  bool powersupply =</front>
<front id="Marlin_mainCPP-346">    #if ENABLED(PS_DEFAULT_OFF)</front>
<front id="Marlin_mainCPP-347">      false</front>
<front id="Marlin_mainCPP-348">    #else</front>
<front id="Marlin_mainCPP-349">      true</front>
<front id="Marlin_mainCPP-350">    #endif</front>
<front id="Marlin_mainCPP-351">  ;</front>
<front id="Marlin_mainCPP-352">#endif</front>
<front id="Marlin_mainCPP-353"></front>
<front id="Marlin_mainCPP-354">#if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-355"></front>
<front id="Marlin_mainCPP-356">  #define TOWER_1 X_AXIS</front>
<front id="Marlin_mainCPP-357">  #define TOWER_2 Y_AXIS</front>
<front id="Marlin_mainCPP-358">  #define TOWER_3 Z_AXIS</front>
<front id="Marlin_mainCPP-359"></front>
<front id="Marlin_mainCPP-360">  float delta[3] = { 0 };</front>
<front id="Marlin_mainCPP-361">  #define SIN_60 0.8660254037844386</front>
<front id="Marlin_mainCPP-362">  #define COS_60 0.5</front>
<front id="Marlin_mainCPP-363">  float endstop_adj[3] = { 0 };</front>
<front id="Marlin_mainCPP-364">  // these are the default values, can be overriden with M665</front>
<front id="Marlin_mainCPP-365">  float delta_radius = DELTA_RADIUS;</front>
<front id="Marlin_mainCPP-366">  float delta_tower1_x = -SIN_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_1); // front left tower</front>
<front id="Marlin_mainCPP-367">  float delta_tower1_y = -COS_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_1);</front>
<front id="Marlin_mainCPP-368">  float delta_tower2_x =  SIN_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_2); // front right tower</front>
<front id="Marlin_mainCPP-369">  float delta_tower2_y = -COS_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_2);</front>
<front id="Marlin_mainCPP-370">  float delta_tower3_x = 0;                                                    // back middle tower</front>
<front id="Marlin_mainCPP-371">  float delta_tower3_y = (delta_radius + DELTA_RADIUS_TRIM_TOWER_3);</front>
<front id="Marlin_mainCPP-372">  float delta_diagonal_rod = DELTA_DIAGONAL_ROD;</front>
<front id="Marlin_mainCPP-373">  float delta_diagonal_rod_trim_tower_1 = DELTA_DIAGONAL_ROD_TRIM_TOWER_1;</front>
<front id="Marlin_mainCPP-374">  float delta_diagonal_rod_trim_tower_2 = DELTA_DIAGONAL_ROD_TRIM_TOWER_2;</front>
<front id="Marlin_mainCPP-375">  float delta_diagonal_rod_trim_tower_3 = DELTA_DIAGONAL_ROD_TRIM_TOWER_3;</front>
<front id="Marlin_mainCPP-376">  float delta_diagonal_rod_2_tower_1 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_1);</front>
<front id="Marlin_mainCPP-377">  float delta_diagonal_rod_2_tower_2 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_2);</front>
<front id="Marlin_mainCPP-378">  float delta_diagonal_rod_2_tower_3 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_3);</front>
<front id="Marlin_mainCPP-379">  //float delta_diagonal_rod_2 = sq(delta_diagonal_rod);</front>
<front id="Marlin_mainCPP-380">  float delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;</front>
<front id="Marlin_mainCPP-381">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-382">    int delta_grid_spacing[2] = { 0, 0 };</front>
<front id="Marlin_mainCPP-383">    float bed_level[AUTO_BED_LEVELING_GRID_POINTS][AUTO_BED_LEVELING_GRID_POINTS];</front>
<front id="Marlin_mainCPP-384">  #endif</front>
<front id="Marlin_mainCPP-385">#else</front>
<front id="Marlin_mainCPP-386">  static bool home_all_axis = true;</front>
<front id="Marlin_mainCPP-387">#endif</front>
<front id="Marlin_mainCPP-388"></front>
<front id="Marlin_mainCPP-389">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-390">  float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;</front>
<front id="Marlin_mainCPP-391">  static float delta[3] = { 0 };</front>
<front id="Marlin_mainCPP-392">  float axis_scaling[3] = { 1, 1, 1 };    // Build size scaling, default to 1</front>
<front id="Marlin_mainCPP-393">#endif</front>
<front id="Marlin_mainCPP-394"></front>
<front id="Marlin_mainCPP-395">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="Marlin_mainCPP-396">  //Variables for Filament Sensor input</front>
<front id="Marlin_mainCPP-397">  float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA;  //Set nominal filament width, can be changed with M404</front>
<front id="Marlin_mainCPP-398">  bool filament_sensor = false;  //M405 turns on filament_sensor control, M406 turns it off</front>
<front id="Marlin_mainCPP-399">  float filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA; //Stores the measured filament diameter</front>
<front id="Marlin_mainCPP-400">  signed char measurement_delay[MAX_MEASUREMENT_DELAY+1];  //ring buffer to delay measurement  store extruder factor after subtracting 100</front>
<front id="Marlin_mainCPP-401">  int delay_index1 = 0;  //index into ring buffer</front>
<front id="Marlin_mainCPP-402">  int delay_index2 = -1;  //index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized</front>
<front id="Marlin_mainCPP-403">  float delay_dist = 0; //delay distance counter</front>
<front id="Marlin_mainCPP-404">  int meas_delay_cm = MEASUREMENT_DELAY_CM;  //distance delay setting</front>
<front id="Marlin_mainCPP-405">#endif</front>
<front id="Marlin_mainCPP-406"></front>
<front id="Marlin_mainCPP-407">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="Marlin_mainCPP-408">   static bool filrunoutEnqueued = false;</front>
<front id="Marlin_mainCPP-409">#endif</front>
<front id="Marlin_mainCPP-410"></front>
<front id="Marlin_mainCPP-411">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-412">  static bool fromsd[BUFSIZE];</front>
<front id="Marlin_mainCPP-413">#endif</front>
<front id="Marlin_mainCPP-414"></front>
<front id="Marlin_mainCPP-415">#if HAS_SERVOS</front>
<front id="Marlin_mainCPP-416">  Servo servo[NUM_SERVOS];</front>
<front id="Marlin_mainCPP-417">#endif</front>
<front id="Marlin_mainCPP-418"></front>
<front id="Marlin_mainCPP-419">#ifdef CHDK</front>
<front id="Marlin_mainCPP-420">  unsigned long chdkHigh = 0;</front>
<front id="Marlin_mainCPP-421">  boolean chdkActive = false;</front>
<front id="Marlin_mainCPP-422">#endif</front>
<front id="Marlin_mainCPP-423"></front>
<front id="Marlin_mainCPP-424">#if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Marlin_mainCPP-425">  int lpq_len = 20;</front>
<front id="Marlin_mainCPP-426">#endif</front>
<front id="Marlin_mainCPP-427"></front>
<front id="Marlin_mainCPP-428">#if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-429">  extern float planner_disabled_below_z;</front>
<front id="Marlin_mainCPP-430">  extern bool layer_reached;</front>
<front id="Marlin_mainCPP-431">#endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-432"></front>
<front id="Marlin_mainCPP-433">//===========================================================================</front>
<front id="Marlin_mainCPP-434">//================================ Functions ================================</front>
<front id="Marlin_mainCPP-435">//===========================================================================</front>
<front id="Marlin_mainCPP-436"></front>
<front id="Marlin_mainCPP-437">void process_next_command();</front>
<front id="Marlin_mainCPP-438"></front>
<front id="Marlin_mainCPP-439">void plan_arc(float target[NUM_AXIS], float *offset, uint8_t clockwise);</front>
<front id="Marlin_mainCPP-440"></front>
<front id="Marlin_mainCPP-441">bool setTargetedHotend(int code);</front>
<front id="Marlin_mainCPP-442"></front>
<front id="Marlin_mainCPP-443">void serial_echopair_P(const char *s_P, int v)           { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-444">void serial_echopair_P(const char *s_P, long v)          { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-445">void serial_echopair_P(const char *s_P, float v)         { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-446">void serial_echopair_P(const char *s_P, double v)        { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-447">void serial_echopair_P(const char *s_P, unsigned long v) { serialprintPGM(s_P); SERIAL_ECHO(v); }</front>
<front id="Marlin_mainCPP-448"></front>
<front id="Marlin_mainCPP-449">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-450">  float extrude_min_temp = EXTRUDE_MINTEMP;</front>
<front id="Marlin_mainCPP-451">#endif</front>
<front id="Marlin_mainCPP-452"></front>
<front id="Marlin_mainCPP-453">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-454">  #include "SdFatUtil.h"</front>
<front id="Marlin_mainCPP-455">  int freeMemory() { return SdFatUtil::FreeRam(); }</front>
<front id="Marlin_mainCPP-456">#else</front>
<front id="Marlin_mainCPP-457">  extern "C" {</front>
<front id="Marlin_mainCPP-458">    extern unsigned int __bss_end;</front>
<front id="Marlin_mainCPP-459">    extern unsigned int __heap_start;</front>
<front id="Marlin_mainCPP-460">    extern void *__brkval;</front>
<front id="Marlin_mainCPP-461"></front>
<front id="Marlin_mainCPP-462">    int freeMemory() {</front>
<front id="Marlin_mainCPP-463">      int free_memory;</front>
<front id="Marlin_mainCPP-464"></front>
<front id="Marlin_mainCPP-465">      if ((int)__brkval == 0)</front>
<front id="Marlin_mainCPP-466">        free_memory = ((int)&free_memory) - ((int)&__bss_end);</front>
<front id="Marlin_mainCPP-467">      else</front>
<front id="Marlin_mainCPP-468">        free_memory = ((int)&free_memory) - ((int)__brkval);</front>
<front id="Marlin_mainCPP-469"></front>
<front id="Marlin_mainCPP-470">      return free_memory;</front>
<front id="Marlin_mainCPP-471">    }</front>
<front id="Marlin_mainCPP-472">  }</front>
<front id="Marlin_mainCPP-473">#endif //!SDSUPPORT</front>
<front id="Marlin_mainCPP-474"></front>
<front id="Marlin_mainCPP-475">/**</front>
<front id="Marlin_mainCPP-476"> * Inject the next command from the command queue, when possible</front>
<front id="Marlin_mainCPP-477"> * Return false only if no command was pending</front>
<front id="Marlin_mainCPP-478"> */</front>
<front id="Marlin_mainCPP-479">static bool drain_queued_commands_P() {</front>
<front id="Marlin_mainCPP-480">  if (!queued_commands_P) return false;</front>
<front id="Marlin_mainCPP-481"></front>
<front id="Marlin_mainCPP-482">  // Get the next 30 chars from the sequence of gcodes to run</front>
<front id="Marlin_mainCPP-483">  char cmd[30];</front>
<front id="Marlin_mainCPP-484">  strncpy_P(cmd, queued_commands_P, sizeof(cmd) - 1);</front>
<front id="Marlin_mainCPP-485">  cmd[sizeof(cmd) - 1] = '\0';</front>
<front id="Marlin_mainCPP-486"></front>
<front id="Marlin_mainCPP-487">  // Look for the end of line, or the end of sequence</front>
<front id="Marlin_mainCPP-488">  size_t i = 0;</front>
<front id="Marlin_mainCPP-489">  char c;</front>
<front id="Marlin_mainCPP-490">  while((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command</front>
<front id="Marlin_mainCPP-491">  cmd[i] = '\0';</front>
<front id="Marlin_mainCPP-492">  if (enqueuecommand(cmd)) {      // buffer was not full (else we will retry later)</front>
<front id="Marlin_mainCPP-493">    if (c)</front>
<front id="Marlin_mainCPP-494">      queued_commands_P += i + 1; // move to next command</front>
<front id="Marlin_mainCPP-495">    else</front>
<front id="Marlin_mainCPP-496">      queued_commands_P = NULL;   // will have no more commands in the sequence</front>
<front id="Marlin_mainCPP-497">  }</front>
<front id="Marlin_mainCPP-498">  return true;</front>
<front id="Marlin_mainCPP-499">}</front>
<front id="Marlin_mainCPP-500"></front>
<front id="Marlin_mainCPP-501">/**</front>
<front id="Marlin_mainCPP-502"> * Record one or many commands to run from program memory.</front>
<front id="Marlin_mainCPP-503"> * Aborts the current queue, if any.</front>
<front id="Marlin_mainCPP-504"> * Note: drain_queued_commands_P() must be called repeatedly to drain the commands afterwards</front>
<front id="Marlin_mainCPP-505"> */</front>
<front id="Marlin_mainCPP-506">void enqueuecommands_P(const char* pgcode) {</front>
<front id="Marlin_mainCPP-507">  queued_commands_P = pgcode;</front>
<front id="Marlin_mainCPP-508">  drain_queued_commands_P(); // first command executed asap (when possible)</front>
<front id="Marlin_mainCPP-509">}</front>
<front id="Marlin_mainCPP-510"></front>
<front id="Marlin_mainCPP-511">/**</front>
<front id="Marlin_mainCPP-512"> * Copy a command directly into the main command buffer, from RAM.</front>
<front id="Marlin_mainCPP-513"> *</front>
<front id="Marlin_mainCPP-514"> * This is done in a non-safe way and needs a rework someday.</front>
<front id="Marlin_mainCPP-515"> * Returns false if it doesn't add any command</front>
<front id="Marlin_mainCPP-516"> */</front>
<front id="Marlin_mainCPP-517">bool enqueuecommand(const char *cmd) {</front>
<front id="Marlin_mainCPP-518"></front>
<front id="Marlin_mainCPP-519">  if (*cmd == ';' || commands_in_queue &gt;= BUFSIZE) return false;</front>
<front id="Marlin_mainCPP-520"></front>
<front id="Marlin_mainCPP-521">  // This is dangerous if a mixing of serial and this happens</front>
<front id="Marlin_mainCPP-522">  char *command = command_queue[cmd_queue_index_w];</front>
<front id="Marlin_mainCPP-523">  strcpy(command, cmd);</front>
<front id="Marlin_mainCPP-524">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-525">  SERIAL_ECHOPGM(MSG_Enqueueing);</front>
<front id="Marlin_mainCPP-526">  SERIAL_ECHO(command);</front>
<front id="Marlin_mainCPP-527">  SERIAL_ECHOLNPGM("\"");</front>
<front id="Marlin_mainCPP-528">  cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-529">  commands_in_queue++;</front>
<front id="Marlin_mainCPP-530">  return true;</front>
<front id="Marlin_mainCPP-531">}</front>
<front id="Marlin_mainCPP-532"></front>
<front id="Marlin_mainCPP-533">void setup_killpin() {</front>
<front id="Marlin_mainCPP-534">  #if HAS_KILL</front>
<front id="Marlin_mainCPP-535">    SET_INPUT(KILL_PIN);</front>
<front id="Marlin_mainCPP-536">    WRITE(KILL_PIN, HIGH);</front>
<front id="Marlin_mainCPP-537">  #endif</front>
<front id="Marlin_mainCPP-538">}</front>
<front id="Marlin_mainCPP-539"></front>
<front id="Marlin_mainCPP-540">void setup_filrunoutpin() {</front>
<front id="Marlin_mainCPP-541">  #if HAS_FILRUNOUT</front>
<front id="Marlin_mainCPP-542">    pinMode(FILRUNOUT_PIN, INPUT);</front>
<front id="Marlin_mainCPP-543">    #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)</front>
<front id="Marlin_mainCPP-544">      WRITE(FILRUNOUT_PIN, HIGH);</front>
<front id="Marlin_mainCPP-545">    #endif</front>
<front id="Marlin_mainCPP-546">  #endif</front>
<front id="Marlin_mainCPP-547">}</front>
<front id="Marlin_mainCPP-548"></front>
<front id="Marlin_mainCPP-549">// Set home pin</front>
<front id="Marlin_mainCPP-550">void setup_homepin(void) {</front>
<front id="Marlin_mainCPP-551">  #if HAS_HOME</front>
<front id="Marlin_mainCPP-552">    SET_INPUT(HOME_PIN);</front>
<front id="Marlin_mainCPP-553">    WRITE(HOME_PIN, HIGH);</front>
<front id="Marlin_mainCPP-554">  #endif</front>
<front id="Marlin_mainCPP-555">}</front>
<front id="Marlin_mainCPP-556"></front>
<front id="Marlin_mainCPP-557"></front>
<front id="Marlin_mainCPP-558">void setup_photpin() {</front>
<front id="Marlin_mainCPP-559">  #if HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-560">    OUT_WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-561">  #endif</front>
<front id="Marlin_mainCPP-562">}</front>
<front id="Marlin_mainCPP-563"></front>
<front id="Marlin_mainCPP-564">void setup_powerhold() {</front>
<front id="Marlin_mainCPP-565">  #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-566">    OUT_WRITE(SUICIDE_PIN, HIGH);</front>
<front id="Marlin_mainCPP-567">  #endif</front>
<front id="Marlin_mainCPP-568">  #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-569">    #if ENABLED(PS_DEFAULT_OFF)</front>
<front id="Marlin_mainCPP-570">      OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);</front>
<front id="Marlin_mainCPP-571">    #else</front>
<front id="Marlin_mainCPP-572">      OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);</front>
<front id="Marlin_mainCPP-573">    #endif</front>
<front id="Marlin_mainCPP-574">  #endif</front>
<front id="Marlin_mainCPP-575">}</front>
<front id="Marlin_mainCPP-576"></front>
<front id="Marlin_mainCPP-577">void suicide() {</front>
<front id="Marlin_mainCPP-578">  #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-579">    OUT_WRITE(SUICIDE_PIN, LOW);</front>
<front id="Marlin_mainCPP-580">  #endif</front>
<front id="Marlin_mainCPP-581">}</front>
<front id="Marlin_mainCPP-582"></front>
<front id="Marlin_mainCPP-583">void servo_init() {</front>
<front id="Marlin_mainCPP-584">  #if NUM_SERVOS &gt;= 1 && HAS_SERVO_0</front>
<front id="Marlin_mainCPP-585">    servo[0].attach(SERVO0_PIN);</front>
<front id="Marlin_mainCPP-586">    servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.</front>
<front id="Marlin_mainCPP-587">  #endif</front>
<front id="Marlin_mainCPP-588">  #if NUM_SERVOS &gt;= 2 && HAS_SERVO_1</front>
<front id="Marlin_mainCPP-589">    servo[1].attach(SERVO1_PIN);</front>
<front id="Marlin_mainCPP-590">    servo[1].detach();</front>
<front id="Marlin_mainCPP-591">  #endif</front>
<front id="Marlin_mainCPP-592">  #if NUM_SERVOS &gt;= 3 && HAS_SERVO_2</front>
<front id="Marlin_mainCPP-593">    servo[2].attach(SERVO2_PIN);</front>
<front id="Marlin_mainCPP-594">    servo[2].detach();</front>
<front id="Marlin_mainCPP-595">  #endif</front>
<front id="Marlin_mainCPP-596">  #if NUM_SERVOS &gt;= 4 && HAS_SERVO_3</front>
<front id="Marlin_mainCPP-597">    servo[3].attach(SERVO3_PIN);</front>
<front id="Marlin_mainCPP-598">    servo[3].detach();</front>
<front id="Marlin_mainCPP-599">  #endif</front>
<front id="Marlin_mainCPP-600"></front>
<front id="Marlin_mainCPP-601">  // Set position of Servo Endstops that are defined</front>
<front id="Marlin_mainCPP-602">  #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-603">    for (int i = 0; i &lt; 3; i++)</front>
<front id="Marlin_mainCPP-604">      if (servo_endstop_id[i] &gt;= 0)</front>
<front id="Marlin_mainCPP-605">        servo[servo_endstop_id[i]].move(servo_endstop_angle[i][1]);</front>
<front id="Marlin_mainCPP-606">  #endif</front>
<front id="Marlin_mainCPP-607"></front>
<front id="Marlin_mainCPP-608">}</front>
<front id="Marlin_mainCPP-609"></front>
<front id="Marlin_mainCPP-610">/**</front>
<front id="Marlin_mainCPP-611"> * Stepper Reset (RigidBoard, et.al.)</front>
<front id="Marlin_mainCPP-612"> */</front>
<front id="Marlin_mainCPP-613">#if HAS_STEPPER_RESET</front>
<front id="Marlin_mainCPP-614">  void disableStepperDrivers() {</front>
<front id="Marlin_mainCPP-615">    pinMode(STEPPER_RESET_PIN, OUTPUT);</front>
<front id="Marlin_mainCPP-616">    digitalWrite(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips</front>
<front id="Marlin_mainCPP-617">  }</front>
<front id="Marlin_mainCPP-618">  void enableStepperDrivers() { pinMode(STEPPER_RESET_PIN, INPUT); }  // set to input, which allows it to be pulled high by pullups</front>
<front id="Marlin_mainCPP-619">#endif</front>
<front id="Marlin_mainCPP-620"></front>
<front id="Marlin_mainCPP-621">/**</front>
<front id="Marlin_mainCPP-622"> * Marlin entry-point: Set up before the program loop</front>
<front id="Marlin_mainCPP-623"> *  - Set up the kill pin, filament runout, power hold</front>
<front id="Marlin_mainCPP-624"> *  - Start the serial port</front>
<front id="Marlin_mainCPP-625"> *  - Print startup messages and diagnostics</front>
<front id="Marlin_mainCPP-626"> *  - Get EEPROM or default settings</front>
<front id="Marlin_mainCPP-627"> *  - Initialize managers for:</front>
<front id="Marlin_mainCPP-628"> *     temperature</front>
<front id="Marlin_mainCPP-629"> *     planner</front>
<front id="Marlin_mainCPP-630"> *     watchdog</front>
<front id="Marlin_mainCPP-631"> *     stepper</front>
<front id="Marlin_mainCPP-632"> *     photo pin</front>
<front id="Marlin_mainCPP-633"> *     servos</front>
<front id="Marlin_mainCPP-634"> *     LCD controller</front>
<front id="Marlin_mainCPP-635"> *     Digipot I2C</front>
<front id="Marlin_mainCPP-636"> *     Z probe sled</front>
<front id="Marlin_mainCPP-637"> *     status LEDs</front>
<front id="Marlin_mainCPP-638"> */</front>
<front id="Marlin_mainCPP-639">void setup() {</front>
<front id="Marlin_mainCPP-640">  setup_killpin();</front>
<front id="Marlin_mainCPP-641">  setup_filrunoutpin();</front>
<front id="Marlin_mainCPP-642">  setup_powerhold();</front>
<front id="Marlin_mainCPP-643"></front>
<front id="Marlin_mainCPP-644">  #if HAS_STEPPER_RESET</front>
<front id="Marlin_mainCPP-645">    disableStepperDrivers();</front>
<front id="Marlin_mainCPP-646">  #endif</front>
<front id="Marlin_mainCPP-647"></front>
<front id="Marlin_mainCPP-648">  MYSERIAL.begin(BAUDRATE);</front>
<front id="Marlin_mainCPP-649">  SERIAL_PROTOCOLLNPGM("start");</front>
<front id="Marlin_mainCPP-650">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-651"></front>
<front id="Marlin_mainCPP-652">  // Check startup - does nothing if bootloader sets MCUSR to 0</front>
<front id="Marlin_mainCPP-653">  byte mcu = MCUSR;</front>
<front id="Marlin_mainCPP-654">  if (mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);</front>
<front id="Marlin_mainCPP-655">  if (mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);</front>
<front id="Marlin_mainCPP-656">  if (mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);</front>
<front id="Marlin_mainCPP-657">  if (mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);</front>
<front id="Marlin_mainCPP-658">  if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);</front>
<front id="Marlin_mainCPP-659">  MCUSR = 0;</front>
<front id="Marlin_mainCPP-660"></front>
<front id="Marlin_mainCPP-661">  SERIAL_ECHOPGM(MSG_MARLIN);</front>
<front id="Marlin_mainCPP-662">  SERIAL_ECHOLNPGM(" " SHORT_BUILD_VERSION);</front>
<front id="Marlin_mainCPP-663"></front>
<front id="Marlin_mainCPP-664">  #ifdef STRING_DISTRIBUTION_DATE</front>
<front id="Marlin_mainCPP-665">    #ifdef STRING_CONFIG_H_AUTHOR</front>
<front id="Marlin_mainCPP-666">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-667">      SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);</front>
<front id="Marlin_mainCPP-668">      SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);</front>
<front id="Marlin_mainCPP-669">      SERIAL_ECHOPGM(MSG_AUTHOR);</front>
<front id="Marlin_mainCPP-670">      SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);</front>
<front id="Marlin_mainCPP-671">      SERIAL_ECHOPGM("Compiled: ");</front>
<front id="Marlin_mainCPP-672">      SERIAL_ECHOLNPGM(__DATE__);</front>
<front id="Marlin_mainCPP-673">    #endif // STRING_CONFIG_H_AUTHOR</front>
<front id="Marlin_mainCPP-674">  #endif // STRING_DISTRIBUTION_DATE</front>
<front id="Marlin_mainCPP-675"></front>
<front id="Marlin_mainCPP-676">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-677">  SERIAL_ECHOPGM(MSG_FREE_MEMORY);</front>
<front id="Marlin_mainCPP-678">  SERIAL_ECHO(freeMemory());</front>
<front id="Marlin_mainCPP-679">  SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);</front>
<front id="Marlin_mainCPP-680">  SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);</front>
<front id="Marlin_mainCPP-681"></front>
<front id="Marlin_mainCPP-682">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-683">    for (int8_t i = 0; i &lt; BUFSIZE; i++) fromsd[i] = false;</front>
<front id="Marlin_mainCPP-684">  #endif</front>
<front id="Marlin_mainCPP-685"></front>
<front id="Marlin_mainCPP-686">  // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)</front>
<front id="Marlin_mainCPP-687">  Config_RetrieveSettings();</front>
<front id="Marlin_mainCPP-688"></front>
<front id="Marlin_mainCPP-689">  lcd_init();</front>
<front id="Marlin_mainCPP-690"></front>
<front id="Marlin_mainCPP-691">  tp_init();    // Initialize temperature loop</front>
<front id="Marlin_mainCPP-692">  plan_init();  // Initialize planner;</front>
<front id="Marlin_mainCPP-693">  watchdog_init();</front>
<front id="Marlin_mainCPP-694">  st_init();    // Initialize stepper, this enables interrupts!</front>
<front id="Marlin_mainCPP-695">  setup_photpin();</front>
<front id="Marlin_mainCPP-696">  servo_init();</front>
<front id="Marlin_mainCPP-697"></front>
<front id="Marlin_mainCPP-698">  #if HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-699">    SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan</front>
<front id="Marlin_mainCPP-700">  #endif</front>
<front id="Marlin_mainCPP-701"></front>
<front id="Marlin_mainCPP-702">  #if HAS_STEPPER_RESET</front>
<front id="Marlin_mainCPP-703">    enableStepperDrivers();</front>
<front id="Marlin_mainCPP-704">  #endif</front>
<front id="Marlin_mainCPP-705"></front>
<front id="Marlin_mainCPP-706">  #if ENABLED(DIGIPOT_I2C)</front>
<front id="Marlin_mainCPP-707">    digipot_i2c_init();</front>
<front id="Marlin_mainCPP-708">  #endif</front>
<front id="Marlin_mainCPP-709"></front>
<front id="Marlin_mainCPP-710">  #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-711">    pinMode(SLED_PIN, OUTPUT);</front>
<front id="Marlin_mainCPP-712">    digitalWrite(SLED_PIN, LOW); // turn it off</front>
<front id="Marlin_mainCPP-713">  #endif // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-714"></front>
<front id="Marlin_mainCPP-715">  setup_homepin();</front>
<front id="Marlin_mainCPP-716"></front>
<front id="Marlin_mainCPP-717">  #ifdef STAT_LED_RED</front>
<front id="Marlin_mainCPP-718">    pinMode(STAT_LED_RED, OUTPUT);</front>
<front id="Marlin_mainCPP-719">    digitalWrite(STAT_LED_RED, LOW); // turn it off</front>
<front id="Marlin_mainCPP-720">  #endif</front>
<front id="Marlin_mainCPP-721"></front>
<front id="Marlin_mainCPP-722">  #ifdef STAT_LED_BLUE</front>
<front id="Marlin_mainCPP-723">    pinMode(STAT_LED_BLUE, OUTPUT);</front>
<front id="Marlin_mainCPP-724">    digitalWrite(STAT_LED_BLUE, LOW); // turn it off</front>
<front id="Marlin_mainCPP-725">  #endif</front>
<front id="Marlin_mainCPP-726">}</front>
<front id="Marlin_mainCPP-727"></front>
<front id="Marlin_mainCPP-728">/**</front>
<front id="Marlin_mainCPP-729"> * The main Marlin program loop</front>
<front id="Marlin_mainCPP-730"> *</front>
<front id="Marlin_mainCPP-731"> *  - Save or log commands to SD</front>
<front id="Marlin_mainCPP-732"> *  - Process available commands (if not saving)</front>
<front id="Marlin_mainCPP-733"> *  - Call heater manager</front>
<front id="Marlin_mainCPP-734"> *  - Call inactivity manager</front>
<front id="Marlin_mainCPP-735"> *  - Call endstop manager</front>
<front id="Marlin_mainCPP-736"> *  - Call LCD update</front>
<front id="Marlin_mainCPP-737"> */</front>
<front id="Marlin_mainCPP-738">void loop() {</front>
<front id="Marlin_mainCPP-739">  if (commands_in_queue &lt; BUFSIZE - 1) get_command();</front>
<front id="Marlin_mainCPP-740"></front>
<front id="Marlin_mainCPP-741">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-742">    card.checkautostart(false);</front>
<front id="Marlin_mainCPP-743">  #endif</front>
<front id="Marlin_mainCPP-744"></front>
<front id="Marlin_mainCPP-745">  if (commands_in_queue) {</front>
<front id="Marlin_mainCPP-746"></front>
<front id="Marlin_mainCPP-747">    #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-748"></front>
<front id="Marlin_mainCPP-749">      if (card.saving) {</front>
<front id="Marlin_mainCPP-750">        char *command = command_queue[cmd_queue_index_r];</front>
<front id="Marlin_mainCPP-751">        if (strstr_P(command, PSTR("M29"))) {</front>
<front id="Marlin_mainCPP-752">          // M29 closes the file</front>
<front id="Marlin_mainCPP-753">          card.closefile();</front>
<front id="Marlin_mainCPP-754">          SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);</front>
<front id="Marlin_mainCPP-755">        }</front>
<front id="Marlin_mainCPP-756">        else {</front>
<front id="Marlin_mainCPP-757">          // Write the string from the read buffer to SD</front>
<front id="Marlin_mainCPP-758">          card.write_command(command);</front>
<front id="Marlin_mainCPP-759">          if (card.logging)</front>
<front id="Marlin_mainCPP-760">            process_next_command(); // The card is saving because it's logging</front>
<front id="Marlin_mainCPP-761">          else</front>
<front id="Marlin_mainCPP-762">            SERIAL_PROTOCOLLNPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-763">        }</front>
<front id="Marlin_mainCPP-764">      }</front>
<front id="Marlin_mainCPP-765">      else</front>
<front id="Marlin_mainCPP-766">        process_next_command();</front>
<front id="Marlin_mainCPP-767"></front>
<front id="Marlin_mainCPP-768">    #else</front>
<front id="Marlin_mainCPP-769"></front>
<front id="Marlin_mainCPP-770">      process_next_command();</front>
<front id="Marlin_mainCPP-771"></front>
<front id="Marlin_mainCPP-772">    #endif // SDSUPPORT</front>
<front id="Marlin_mainCPP-773"></front>
<front id="Marlin_mainCPP-774">    commands_in_queue--;</front>
<front id="Marlin_mainCPP-775">    cmd_queue_index_r = (cmd_queue_index_r + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-776">  }</front>
<front id="Marlin_mainCPP-777">  checkHitEndstops();</front>
<front id="Marlin_mainCPP-778">  idle();</front>
<front id="Marlin_mainCPP-779">}</front>
<front id="Marlin_mainCPP-780"></front>
<front id="Marlin_mainCPP-781">void gcode_line_error(const char *err, bool doFlush=true) {</front>
<front id="Marlin_mainCPP-782">  SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-783">  serialprintPGM(err);</front>
<front id="Marlin_mainCPP-784">  SERIAL_ERRORLN(gcode_LastN);</front>
<front id="Marlin_mainCPP-785">  //Serial.println(gcode_N);</front>
<front id="Marlin_mainCPP-786">  if (doFlush) FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-787">  serial_count = 0;</front>
<front id="Marlin_mainCPP-788">}</front>
<front id="Marlin_mainCPP-789"></front>
<front id="Marlin_mainCPP-790">/**</front>
<front id="Marlin_mainCPP-791"> * Add to the circular command queue the next command from:</front>
<front id="Marlin_mainCPP-792"> *  - The command-injection queue (queued_commands_P)</front>
<front id="Marlin_mainCPP-793"> *  - The active serial input (usually USB)</front>
<front id="Marlin_mainCPP-794"> *  - The SD card file being actively printed</front>
<front id="Marlin_mainCPP-795"> */</front>
<front id="Marlin_mainCPP-796">void get_command() {</front>
<front id="Marlin_mainCPP-797"></front>
<front id="Marlin_mainCPP-798">  if (drain_queued_commands_P()) return; // priority is given to non-serial commands</front>
<front id="Marlin_mainCPP-799"></front>
<front id="Marlin_mainCPP-800">  #if ENABLED(NO_TIMEOUTS)</front>
<front id="Marlin_mainCPP-801">    static millis_t last_command_time = 0;</front>
<front id="Marlin_mainCPP-802">    millis_t ms = millis();</front>
<front id="Marlin_mainCPP-803"></front>
<front id="Marlin_mainCPP-804">    if (!MYSERIAL.available() && commands_in_queue == 0 && ms - last_command_time &gt; NO_TIMEOUTS) {</front>
<front id="Marlin_mainCPP-805">      SERIAL_ECHOLNPGM(MSG_WAIT);</front>
<front id="Marlin_mainCPP-806">      last_command_time = ms;</front>
<front id="Marlin_mainCPP-807">    }</front>
<front id="Marlin_mainCPP-808">  #endif</front>
<front id="Marlin_mainCPP-809"></front>
<front id="Marlin_mainCPP-810">  //</front>
<front id="Marlin_mainCPP-811">  // Loop while serial characters are incoming and the queue is not full</front>
<front id="Marlin_mainCPP-812">  //</front>
<front id="Marlin_mainCPP-813">  while (commands_in_queue &lt; BUFSIZE && MYSERIAL.available() &gt; 0) {</front>
<front id="Marlin_mainCPP-814"></front>
<front id="Marlin_mainCPP-815">    #if ENABLED(NO_TIMEOUTS)</front>
<front id="Marlin_mainCPP-816">      last_command_time = ms;</front>
<front id="Marlin_mainCPP-817">    #endif</front>
<front id="Marlin_mainCPP-818"></front>
<front id="Marlin_mainCPP-819">    serial_char = MYSERIAL.read();</front>
<front id="Marlin_mainCPP-820"></front>
<front id="Marlin_mainCPP-821">    //</front>
<front id="Marlin_mainCPP-822">    // If the character ends the line, or the line is full...</front>
<front id="Marlin_mainCPP-823">    //</front>
<front id="Marlin_mainCPP-824">    if (serial_char == '\n' || serial_char == '\r' || serial_count &gt;= MAX_CMD_SIZE-1) {</front>
<front id="Marlin_mainCPP-825"></front>
<front id="Marlin_mainCPP-826">      // end of line == end of comment</front>
<front id="Marlin_mainCPP-827">      comment_mode = false;</front>
<front id="Marlin_mainCPP-828"></front>
<front id="Marlin_mainCPP-829">      if (!serial_count) return; // empty lines just exit</front>
<front id="Marlin_mainCPP-830"></front>
<front id="Marlin_mainCPP-831">      char *command = command_queue[cmd_queue_index_w];</front>
<front id="Marlin_mainCPP-832">      command[serial_count] = 0; // terminate string</front>
<front id="Marlin_mainCPP-833"></front>
<front id="Marlin_mainCPP-834">      // this item in the queue is not from sd</front>
<front id="Marlin_mainCPP-835">      #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-836">        fromsd[cmd_queue_index_w] = false;</front>
<front id="Marlin_mainCPP-837">      #endif</front>
<front id="Marlin_mainCPP-838"></front>
<front id="Marlin_mainCPP-839">      char *npos = strchr(command, 'N');</front>
<front id="Marlin_mainCPP-840">      char *apos = strchr(command, '*');</front>
<front id="Marlin_mainCPP-841">      if (npos) {</front>
<front id="Marlin_mainCPP-842"></front>
<front id="Marlin_mainCPP-843">        boolean M110 = strstr_P(command, PSTR("M110")) != NULL;</front>
<front id="Marlin_mainCPP-844"></front>
<front id="Marlin_mainCPP-845">        if (M110) {</front>
<front id="Marlin_mainCPP-846">          char *n2pos = strchr(command + 4, 'N');</front>
<front id="Marlin_mainCPP-847">          if (n2pos) npos = n2pos;</front>
<front id="Marlin_mainCPP-848">        }</front>
<front id="Marlin_mainCPP-849"></front>
<front id="Marlin_mainCPP-850">        gcode_N = strtol(npos + 1, NULL, 10);</front>
<front id="Marlin_mainCPP-851"></front>
<front id="Marlin_mainCPP-852">        if (gcode_N != gcode_LastN + 1 && !M110) {</front>
<front id="Marlin_mainCPP-853">          gcode_line_error(PSTR(MSG_ERR_LINE_NO));</front>
<front id="Marlin_mainCPP-854">          return;</front>
<front id="Marlin_mainCPP-855">        }</front>
<front id="Marlin_mainCPP-856"></front>
<front id="Marlin_mainCPP-857">        if (apos) {</front>
<front id="Marlin_mainCPP-858">          byte checksum = 0, count = 0;</front>
<front id="Marlin_mainCPP-859">          while (command[count] != '*') checksum ^= command[count++];</front>
<front id="Marlin_mainCPP-860"></front>
<front id="Marlin_mainCPP-861">          if (strtol(apos + 1, NULL, 10) != checksum) {</front>
<front id="Marlin_mainCPP-862">            gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));</front>
<front id="Marlin_mainCPP-863">            return;</front>
<front id="Marlin_mainCPP-864">          }</front>
<front id="Marlin_mainCPP-865">          // if no errors, continue parsing</front>
<front id="Marlin_mainCPP-866">        }</front>
<front id="Marlin_mainCPP-867">        else if (npos == command) {</front>
<front id="Marlin_mainCPP-868">          gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));</front>
<front id="Marlin_mainCPP-869">          return;</front>
<front id="Marlin_mainCPP-870">        }</front>
<front id="Marlin_mainCPP-871"></front>
<front id="Marlin_mainCPP-872">        gcode_LastN = gcode_N;</front>
<front id="Marlin_mainCPP-873">        // if no errors, continue parsing</front>
<front id="Marlin_mainCPP-874">      }</front>
<front id="Marlin_mainCPP-875">      else if (apos) { // No '*' without 'N'</front>
<front id="Marlin_mainCPP-876">        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);</front>
<front id="Marlin_mainCPP-877">        return;</front>
<front id="Marlin_mainCPP-878">      }</front>
<front id="Marlin_mainCPP-879"></front>
<front id="Marlin_mainCPP-880">      // Movement commands alert when stopped</front>
<front id="Marlin_mainCPP-881">      if (IsStopped()) {</front>
<front id="Marlin_mainCPP-882">        char *gpos = strchr(command, 'G');</front>
<front id="Marlin_mainCPP-883">        if (gpos) {</front>
<front id="Marlin_mainCPP-884">          int codenum = strtol(gpos + 1, NULL, 10);</front>
<front id="Marlin_mainCPP-885">          switch (codenum) {</front>
<front id="Marlin_mainCPP-886">            case 0:</front>
<front id="Marlin_mainCPP-887">            case 1:</front>
<front id="Marlin_mainCPP-888">            case 2:</front>
<front id="Marlin_mainCPP-889">            case 3:</front>
<front id="Marlin_mainCPP-890">              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);</front>
<front id="Marlin_mainCPP-891">              LCD_MESSAGEPGM(MSG_STOPPED);</front>
<front id="Marlin_mainCPP-892">              break;</front>
<front id="Marlin_mainCPP-893">          }</front>
<front id="Marlin_mainCPP-894">        }</front>
<front id="Marlin_mainCPP-895">      }</front>
<front id="Marlin_mainCPP-896"></front>
<front id="Marlin_mainCPP-897">      // If command was e-stop process now</front>
<front id="Marlin_mainCPP-898">      if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));</front>
<front id="Marlin_mainCPP-899"></front>
<front id="Marlin_mainCPP-900">      cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-901">      commands_in_queue += 1;</front>
<front id="Marlin_mainCPP-902"></front>
<front id="Marlin_mainCPP-903">      serial_count = 0; //clear buffer</front>
<front id="Marlin_mainCPP-904">    }</front>
<front id="Marlin_mainCPP-905">    else if (serial_char == '\\') {  // Handle escapes</front>
<front id="Marlin_mainCPP-906">      if (MYSERIAL.available() &gt; 0 && commands_in_queue &lt; BUFSIZE) {</front>
<front id="Marlin_mainCPP-907">        // if we have one more character, copy it over</front>
<front id="Marlin_mainCPP-908">        serial_char = MYSERIAL.read();</front>
<front id="Marlin_mainCPP-909">        command_queue[cmd_queue_index_w][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-910">      }</front>
<front id="Marlin_mainCPP-911">      // otherwise do nothing</front>
<front id="Marlin_mainCPP-912">    }</front>
<front id="Marlin_mainCPP-913">    else { // its not a newline, carriage return or escape char</front>
<front id="Marlin_mainCPP-914">      if (serial_char == ';') comment_mode = true;</front>
<front id="Marlin_mainCPP-915">      if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-916">    }</front>
<front id="Marlin_mainCPP-917">  }</front>
<front id="Marlin_mainCPP-918"></front>
<front id="Marlin_mainCPP-919">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-920"></front>
<front id="Marlin_mainCPP-921">    if (!card.sdprinting || serial_count) return;</front>
<front id="Marlin_mainCPP-922"></front>
<front id="Marlin_mainCPP-923">    // '#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible</front>
<front id="Marlin_mainCPP-924">    // if it occurs, stop_buffering is triggered and the buffer is ran dry.</front>
<front id="Marlin_mainCPP-925">    // this character _can_ occur in serial com, due to checksums. however, no checksums are used in SD printing</front>
<front id="Marlin_mainCPP-926"></front>
<front id="Marlin_mainCPP-927">    static bool stop_buffering = false;</front>
<front id="Marlin_mainCPP-928">    if (commands_in_queue == 0) stop_buffering = false;</front>
<front id="Marlin_mainCPP-929"></front>
<front id="Marlin_mainCPP-930">    while (!card.eof() && commands_in_queue &lt; BUFSIZE && !stop_buffering) {</front>
<front id="Marlin_mainCPP-931">      int16_t n = card.get();</front>
<front id="Marlin_mainCPP-932">      serial_char = (char)n;</front>
<front id="Marlin_mainCPP-933">      if (serial_char == '\n' || serial_char == '\r' ||</front>
<front id="Marlin_mainCPP-934">          ((serial_char == '#' || serial_char == ':') && !comment_mode) ||</front>
<front id="Marlin_mainCPP-935">          serial_count &gt;= (MAX_CMD_SIZE - 1) || n == -1</front>
<front id="Marlin_mainCPP-936">      ) {</front>
<front id="Marlin_mainCPP-937">        if (card.eof()) {</front>
<front id="Marlin_mainCPP-938">          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);</front>
<front id="Marlin_mainCPP-939">          print_job_stop_ms = millis();</front>
<front id="Marlin_mainCPP-940">          char time[30];</front>
<front id="Marlin_mainCPP-941">          millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;</front>
<front id="Marlin_mainCPP-942">          int hours = t / 60 / 60, minutes = (t / 60) % 60;</front>
<front id="Marlin_mainCPP-943">          sprintf_P(time, PSTR("%i " MSG_END_HOUR " %i " MSG_END_MINUTE), hours, minutes);</front>
<front id="Marlin_mainCPP-944">          SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-945">          SERIAL_ECHOLN(time);</front>
<front id="Marlin_mainCPP-946">          lcd_setstatus(time, true);</front>
<front id="Marlin_mainCPP-947">          card.printingHasFinished();</front>
<front id="Marlin_mainCPP-948">          card.checkautostart(true);</front>
<front id="Marlin_mainCPP-949">          #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-950">            planner_disabled_below_z = 0;</front>
<front id="Marlin_mainCPP-951">          #endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-952">        }</front>
<front id="Marlin_mainCPP-953">        if (serial_char == '#') stop_buffering = true;</front>
<front id="Marlin_mainCPP-954"></front>
<front id="Marlin_mainCPP-955">        if (!serial_count) {</front>
<front id="Marlin_mainCPP-956">          comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-957">          return; //if empty line</front>
<front id="Marlin_mainCPP-958">        }</front>
<front id="Marlin_mainCPP-959">        command_queue[cmd_queue_index_w][serial_count] = 0; //terminate string</front>
<front id="Marlin_mainCPP-960">        // if (!comment_mode) {</front>
<front id="Marlin_mainCPP-961">        fromsd[cmd_queue_index_w] = true;</front>
<front id="Marlin_mainCPP-962">        commands_in_queue += 1;</front>
<front id="Marlin_mainCPP-963">        cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;</front>
<front id="Marlin_mainCPP-964">        // }</front>
<front id="Marlin_mainCPP-965">        comment_mode = false; //for new command</front>
<front id="Marlin_mainCPP-966">        serial_count = 0; //clear buffer</front>
<front id="Marlin_mainCPP-967">      }</front>
<front id="Marlin_mainCPP-968">      else {</front>
<front id="Marlin_mainCPP-969">        if (serial_char == ';') comment_mode = true;</front>
<front id="Marlin_mainCPP-970">        if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;</front>
<front id="Marlin_mainCPP-971">      }</front>
<front id="Marlin_mainCPP-972">    }</front>
<front id="Marlin_mainCPP-973"></front>
<front id="Marlin_mainCPP-974">  #endif // SDSUPPORT</front>
<front id="Marlin_mainCPP-975">}</front>
<front id="Marlin_mainCPP-976"></front>
<front id="Marlin_mainCPP-977">bool code_has_value() {</front>
<front id="Marlin_mainCPP-978">  int i = 1;</front>
<front id="Marlin_mainCPP-979">  char c = seen_pointer[i];</front>
<front id="Marlin_mainCPP-980">  if (c == '-' || c == '+') c = seen_pointer[++i];</front>
<front id="Marlin_mainCPP-981">  if (c == '.') c = seen_pointer[++i];</front>
<front id="Marlin_mainCPP-982">  return (c &gt;= '0' && c &lt;= '9');</front>
<front id="Marlin_mainCPP-983">}</front>
<front id="Marlin_mainCPP-984"></front>
<front id="Marlin_mainCPP-985">float code_value() {</front>
<front id="Marlin_mainCPP-986">  float ret;</front>
<front id="Marlin_mainCPP-987">  char *e = strchr(seen_pointer, 'E');</front>
<front id="Marlin_mainCPP-988">  if (e) {</front>
<front id="Marlin_mainCPP-989">    *e = 0;</front>
<front id="Marlin_mainCPP-990">    ret = strtod(seen_pointer+1, NULL);</front>
<front id="Marlin_mainCPP-991">    *e = 'E';</front>
<front id="Marlin_mainCPP-992">  }</front>
<front id="Marlin_mainCPP-993">  else</front>
<front id="Marlin_mainCPP-994">    ret = strtod(seen_pointer+1, NULL);</front>
<front id="Marlin_mainCPP-995">  return ret;</front>
<front id="Marlin_mainCPP-996">}</front>
<front id="Marlin_mainCPP-997"></front>
<front id="Marlin_mainCPP-998">long code_value_long() { return strtol(seen_pointer + 1, NULL, 10); }</front>
<front id="Marlin_mainCPP-999"></front>
<front id="Marlin_mainCPP-1000">int16_t code_value_short() { return (int16_t)strtol(seen_pointer + 1, NULL, 10); }</front>
<front id="Marlin_mainCPP-1001"></front>
<front id="Marlin_mainCPP-1002">bool code_seen(char code) {</front>
<front id="Marlin_mainCPP-1003">  seen_pointer = strchr(current_command_args, code);</front>
<front id="Marlin_mainCPP-1004">  return (seen_pointer != NULL); // Return TRUE if the code-letter was found</front>
<front id="Marlin_mainCPP-1005">}</front>
<front id="Marlin_mainCPP-1006"></front>
<front id="Marlin_mainCPP-1007">#define DEFINE_PGM_READ_ANY(type, reader)       \</front>
<front id="Marlin_mainCPP-1008">    static inline type pgm_read_any(const type *p)  \</front>
<front id="Marlin_mainCPP-1009">    { return pgm_read_##reader##_near(p); }</front>
<front id="Marlin_mainCPP-1010"></front>
<front id="Marlin_mainCPP-1011">DEFINE_PGM_READ_ANY(float,       float);</front>
<front id="Marlin_mainCPP-1012">DEFINE_PGM_READ_ANY(signed char, byte);</front>
<front id="Marlin_mainCPP-1013"></front>
<front id="Marlin_mainCPP-1014">#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \</front>
<front id="Marlin_mainCPP-1015">static const PROGMEM type array##_P[3] =        \</front>
<front id="Marlin_mainCPP-1016">    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \</front>
<front id="Marlin_mainCPP-1017">static inline type array(int axis)          \</front>
<front id="Marlin_mainCPP-1018">    { return pgm_read_any(&array##_P[axis]); }</front>
<front id="Marlin_mainCPP-1019"></front>
<front id="Marlin_mainCPP-1020">XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);</front>
<front id="Marlin_mainCPP-1021">XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);</front>
<front id="Marlin_mainCPP-1022">XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);</front>
<front id="Marlin_mainCPP-1023">XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);</front>
<front id="Marlin_mainCPP-1024">XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);</front>
<front id="Marlin_mainCPP-1025">XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);</front>
<front id="Marlin_mainCPP-1026"></front>
<front id="Marlin_mainCPP-1027">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-1028"></front>
<front id="Marlin_mainCPP-1029">  #define DXC_FULL_CONTROL_MODE 0</front>
<front id="Marlin_mainCPP-1030">  #define DXC_AUTO_PARK_MODE    1</front>
<front id="Marlin_mainCPP-1031">  #define DXC_DUPLICATION_MODE  2</front>
<front id="Marlin_mainCPP-1032"></front>
<front id="Marlin_mainCPP-1033">  static int dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;</front>
<front id="Marlin_mainCPP-1034"></front>
<front id="Marlin_mainCPP-1035">  static float x_home_pos(int extruder) {</front>
<front id="Marlin_mainCPP-1036">    if (extruder == 0)</front>
<front id="Marlin_mainCPP-1037">      return base_home_pos(X_AXIS) + home_offset[X_AXIS];</front>
<front id="Marlin_mainCPP-1038">    else</front>
<front id="Marlin_mainCPP-1039">      // In dual carriage mode the extruder offset provides an override of the</front>
<front id="Marlin_mainCPP-1040">      // second X-carriage offset when homed - otherwise X2_HOME_POS is used.</front>
<front id="Marlin_mainCPP-1041">      // This allow soft recalibration of the second extruder offset position without firmware reflash</front>
<front id="Marlin_mainCPP-1042">      // (through the M218 command).</front>
<front id="Marlin_mainCPP-1043">      return (extruder_offset[X_AXIS][1] &gt; 0) ? extruder_offset[X_AXIS][1] : X2_HOME_POS;</front>
<front id="Marlin_mainCPP-1044">  }</front>
<front id="Marlin_mainCPP-1045"></front>
<front id="Marlin_mainCPP-1046">  static int x_home_dir(int extruder) {</front>
<front id="Marlin_mainCPP-1047">    return (extruder == 0) ? X_HOME_DIR : X2_HOME_DIR;</front>
<front id="Marlin_mainCPP-1048">  }</front>
<front id="Marlin_mainCPP-1049"></front>
<front id="Marlin_mainCPP-1050">  static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1</front>
<front id="Marlin_mainCPP-1051">  static bool active_extruder_parked = false; // used in mode 1 & 2</front>
<front id="Marlin_mainCPP-1052">  static float raised_parked_position[NUM_AXIS]; // used in mode 1</front>
<front id="Marlin_mainCPP-1053">  static millis_t delayed_move_time = 0; // used in mode 1</front>
<front id="Marlin_mainCPP-1054">  static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2</front>
<front id="Marlin_mainCPP-1055">  static float duplicate_extruder_temp_offset = 0; // used in mode 2</front>
<front id="Marlin_mainCPP-1056">  bool extruder_duplication_enabled = false; // used in mode 2</front>
<front id="Marlin_mainCPP-1057"></front>
<front id="Marlin_mainCPP-1058">#endif //DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-1059"></front>
<front id="Marlin_mainCPP-1060">#if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1061">  void print_xyz(const char *prefix, const float x, const float y, const float z) {</front>
<front id="Marlin_mainCPP-1062">    SERIAL_ECHO(prefix);</front>
<front id="Marlin_mainCPP-1063">    SERIAL_ECHOPAIR(": (", x);</front>
<front id="Marlin_mainCPP-1064">    SERIAL_ECHOPAIR(", ", y);</front>
<front id="Marlin_mainCPP-1065">    SERIAL_ECHOPAIR(", ", z);</front>
<front id="Marlin_mainCPP-1066">    SERIAL_ECHOLNPGM(")");</front>
<front id="Marlin_mainCPP-1067">  }</front>
<front id="Marlin_mainCPP-1068">  void print_xyz(const char *prefix, const float xyz[]) {</front>
<front id="Marlin_mainCPP-1069">    print_xyz(prefix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);</front>
<front id="Marlin_mainCPP-1070">  }</front>
<front id="Marlin_mainCPP-1071">#endif</front>
<front id="Marlin_mainCPP-1072"></front>
<front id="Marlin_mainCPP-1073">static void set_axis_is_at_home(AxisEnum axis) {</front>
<front id="Marlin_mainCPP-1074"></front>
<front id="Marlin_mainCPP-1075">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-1076">    if (axis == X_AXIS) {</front>
<front id="Marlin_mainCPP-1077">      if (active_extruder != 0) {</front>
<front id="Marlin_mainCPP-1078">        current_position[X_AXIS] = x_home_pos(active_extruder);</front>
<front id="Marlin_mainCPP-1079">                 min_pos[X_AXIS] = X2_MIN_POS;</front>
<front id="Marlin_mainCPP-1080">                 max_pos[X_AXIS] = max(extruder_offset[X_AXIS][1], X2_MAX_POS);</front>
<front id="Marlin_mainCPP-1081">        return;</front>
<front id="Marlin_mainCPP-1082">      }</front>
<front id="Marlin_mainCPP-1083">      else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {</front>
<front id="Marlin_mainCPP-1084">        float xoff = home_offset[X_AXIS];</front>
<front id="Marlin_mainCPP-1085">        current_position[X_AXIS] = base_home_pos(X_AXIS) + xoff;</front>
<front id="Marlin_mainCPP-1086">                 min_pos[X_AXIS] = base_min_pos(X_AXIS) + xoff;</front>
<front id="Marlin_mainCPP-1087">                 max_pos[X_AXIS] = min(base_max_pos(X_AXIS) + xoff, max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);</front>
<front id="Marlin_mainCPP-1088">        return;</front>
<front id="Marlin_mainCPP-1089">      }</front>
<front id="Marlin_mainCPP-1090">    }</front>
<front id="Marlin_mainCPP-1091">  #endif</front>
<front id="Marlin_mainCPP-1092"></front>
<front id="Marlin_mainCPP-1093">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-1094"></front>
<front id="Marlin_mainCPP-1095">    if (axis == X_AXIS || axis == Y_AXIS) {</front>
<front id="Marlin_mainCPP-1096"></front>
<front id="Marlin_mainCPP-1097">      float homeposition[3];</front>
<front id="Marlin_mainCPP-1098">      for (int i = 0; i &lt; 3; i++) homeposition[i] = base_home_pos(i);</front>
<front id="Marlin_mainCPP-1099"></front>
<front id="Marlin_mainCPP-1100">      // SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);</front>
<front id="Marlin_mainCPP-1101">      // SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);</front>
<front id="Marlin_mainCPP-1102">      // Works out real Homeposition angles using inverse kinematics,</front>
<front id="Marlin_mainCPP-1103">      // and calculates homing offset using forward kinematics</front>
<front id="Marlin_mainCPP-1104">      calculate_delta(homeposition);</front>
<front id="Marlin_mainCPP-1105"></front>
<front id="Marlin_mainCPP-1106">      // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-1107">      // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1108"></front>
<front id="Marlin_mainCPP-1109">      for (int i = 0; i &lt; 2; i++) delta[i] -= home_offset[i];</front>
<front id="Marlin_mainCPP-1110"></front>
<front id="Marlin_mainCPP-1111">      // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(home_offset[X_AXIS]);</front>
<front id="Marlin_mainCPP-1112">      // SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(home_offset[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1113">      // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-1114">      // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1115"></front>
<front id="Marlin_mainCPP-1116">      calculate_SCARA_forward_Transform(delta);</front>
<front id="Marlin_mainCPP-1117"></front>
<front id="Marlin_mainCPP-1118">      // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-1119">      // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-1120"></front>
<front id="Marlin_mainCPP-1121">      current_position[axis] = delta[axis];</front>
<front id="Marlin_mainCPP-1122"></front>
<front id="Marlin_mainCPP-1123">      // SCARA home positions are based on configuration since the actual limits are determined by the</front>
<front id="Marlin_mainCPP-1124">      // inverse kinematic transform.</front>
<front id="Marlin_mainCPP-1125">      min_pos[axis] = base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));</front>
<front id="Marlin_mainCPP-1126">      max_pos[axis] = base_max_pos(axis); // + (delta[axis] - base_home_pos(axis));</front>
<front id="Marlin_mainCPP-1127">    }</front>
<front id="Marlin_mainCPP-1128">    else</front>
<front id="Marlin_mainCPP-1129">  #endif</front>
<front id="Marlin_mainCPP-1130">  {</front>
<front id="Marlin_mainCPP-1131">    current_position[axis] = base_home_pos(axis) + home_offset[axis];</front>
<front id="Marlin_mainCPP-1132">    min_pos[axis] = base_min_pos(axis) + home_offset[axis];</front>
<front id="Marlin_mainCPP-1133">    max_pos[axis] = base_max_pos(axis) + home_offset[axis];</front>
<front id="Marlin_mainCPP-1134"></front>
<front id="Marlin_mainCPP-1135">    #if ENABLED(AUTO_BED_LEVELING_FEATURE) && Z_HOME_DIR &lt; 0</front>
<front id="Marlin_mainCPP-1136">      if (axis == Z_AXIS) current_position[Z_AXIS] -= zprobe_zoffset;</front>
<front id="Marlin_mainCPP-1137">    #endif</front>
<front id="Marlin_mainCPP-1138"></front>
<front id="Marlin_mainCPP-1139">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1140">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1141">        SERIAL_ECHOPAIR("set_axis_is_at_home ", (unsigned long)axis);</front>
<front id="Marlin_mainCPP-1142">        SERIAL_ECHOPAIR(" &gt; (home_offset[axis]==", home_offset[axis]);</front>
<front id="Marlin_mainCPP-1143">        print_xyz(") &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1144">      }</front>
<front id="Marlin_mainCPP-1145">    #endif</front>
<front id="Marlin_mainCPP-1146">  }</front>
<front id="Marlin_mainCPP-1147">}</front>
<front id="Marlin_mainCPP-1148"></front>
<front id="Marlin_mainCPP-1149">/**</front>
<front id="Marlin_mainCPP-1150"> * Some planner shorthand inline functions</front>
<front id="Marlin_mainCPP-1151"> */</front>
<front id="Marlin_mainCPP-1152">inline void set_homing_bump_feedrate(AxisEnum axis) {</front>
<front id="Marlin_mainCPP-1153">  const int homing_bump_divisor[] = HOMING_BUMP_DIVISOR;</front>
<front id="Marlin_mainCPP-1154">  int hbd = homing_bump_divisor[axis];</front>
<front id="Marlin_mainCPP-1155">  if (hbd &lt; 1) {</front>
<front id="Marlin_mainCPP-1156">    hbd = 10;</front>
<front id="Marlin_mainCPP-1157">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-1158">    SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor &lt; 1");</front>
<front id="Marlin_mainCPP-1159">  }</front>
<front id="Marlin_mainCPP-1160">  feedrate = homing_feedrate[axis] / hbd;</front>
<front id="Marlin_mainCPP-1161">}</front>
<front id="Marlin_mainCPP-1162">inline void line_to_current_position() {</front>
<front id="Marlin_mainCPP-1163">  plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1164">}</front>
<front id="Marlin_mainCPP-1165">inline void line_to_z(float zPosition) {</front>
<front id="Marlin_mainCPP-1166">  plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate/60, active_extruder);</front>
<front id="Marlin_mainCPP-1167">}</front>
<front id="Marlin_mainCPP-1168">inline void line_to_destination(float mm_m) {</front>
<front id="Marlin_mainCPP-1169">  plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], mm_m/60, active_extruder);</front>
<front id="Marlin_mainCPP-1170">}</front>
<front id="Marlin_mainCPP-1171">inline void line_to_destination() {</front>
<front id="Marlin_mainCPP-1172">  line_to_destination(feedrate);</front>
<front id="Marlin_mainCPP-1173">}</front>
<front id="Marlin_mainCPP-1174">inline void sync_plan_position() {</front>
<front id="Marlin_mainCPP-1175">  plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1176">}</front>
<front id="Marlin_mainCPP-1177">#if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-1178">  inline void sync_plan_position_delta() {</front>
<front id="Marlin_mainCPP-1179">    calculate_delta(current_position);</front>
<front id="Marlin_mainCPP-1180">    plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1181">  }</front>
<front id="Marlin_mainCPP-1182">#endif</front>
<front id="Marlin_mainCPP-1183">inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }</front>
<front id="Marlin_mainCPP-1184">inline void set_destination_to_current() { memcpy(destination, current_position, sizeof(destination)); }</front>
<front id="Marlin_mainCPP-1185"></front>
<front id="Marlin_mainCPP-1186">static void setup_for_endstop_move() {</front>
<front id="Marlin_mainCPP-1187">  saved_feedrate = feedrate;</front>
<front id="Marlin_mainCPP-1188">  saved_feedrate_multiplier = feedrate_multiplier;</front>
<front id="Marlin_mainCPP-1189">  feedrate_multiplier = 100;</front>
<front id="Marlin_mainCPP-1190">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-1191">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1192">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1193">      SERIAL_ECHOLNPGM("setup_for_endstop_move &gt; enable_endstops(true)");</front>
<front id="Marlin_mainCPP-1194">    }</front>
<front id="Marlin_mainCPP-1195">  #endif</front>
<front id="Marlin_mainCPP-1196">  enable_endstops(true);</front>
<front id="Marlin_mainCPP-1197">}</front>
<front id="Marlin_mainCPP-1198"></front>
<front id="Marlin_mainCPP-1199">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1200"></front>
<front id="Marlin_mainCPP-1201">  #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1202">    /**</front>
<front id="Marlin_mainCPP-1203">     * Calculate delta, start a line, and set current_position to destination</front>
<front id="Marlin_mainCPP-1204">     */</front>
<front id="Marlin_mainCPP-1205">    void prepare_move_raw() {</front>
<front id="Marlin_mainCPP-1206">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1207">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1208">          print_xyz("prepare_move_raw &gt; destination", destination);</front>
<front id="Marlin_mainCPP-1209">        }</front>
<front id="Marlin_mainCPP-1210">      #endif</front>
<front id="Marlin_mainCPP-1211">      refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-1212">      calculate_delta(destination);</front>
<front id="Marlin_mainCPP-1213">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], (feedrate/60)*(feedrate_multiplier/100.0), active_extruder);</front>
<front id="Marlin_mainCPP-1214">      set_current_to_destination();</front>
<front id="Marlin_mainCPP-1215">    }</front>
<front id="Marlin_mainCPP-1216">  #endif</front>
<front id="Marlin_mainCPP-1217"></front>
<front id="Marlin_mainCPP-1218">  #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-1219"></front>
<front id="Marlin_mainCPP-1220">    #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-1221"></front>
<front id="Marlin_mainCPP-1222">      static void set_bed_level_equation_lsq(double *plane_equation_coefficients) {</front>
<front id="Marlin_mainCPP-1223">        vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);</front>
<front id="Marlin_mainCPP-1224">        planeNormal.debug("planeNormal");</front>
<front id="Marlin_mainCPP-1225">        plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);</front>
<front id="Marlin_mainCPP-1226">        //bedLevel.debug("bedLevel");</front>
<front id="Marlin_mainCPP-1227"></front>
<front id="Marlin_mainCPP-1228">        //plan_bed_level_matrix.debug("bed level before");</front>
<front id="Marlin_mainCPP-1229">        //vector_3 uncorrected_position = plan_get_position_mm();</front>
<front id="Marlin_mainCPP-1230">        //uncorrected_position.debug("position before");</front>
<front id="Marlin_mainCPP-1231"></front>
<front id="Marlin_mainCPP-1232">        vector_3 corrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-1233">        //corrected_position.debug("position after");</front>
<front id="Marlin_mainCPP-1234">        current_position[X_AXIS] = corrected_position.x;</front>
<front id="Marlin_mainCPP-1235">        current_position[Y_AXIS] = corrected_position.y;</front>
<front id="Marlin_mainCPP-1236">        current_position[Z_AXIS] = corrected_position.z;</front>
<front id="Marlin_mainCPP-1237"></front>
<front id="Marlin_mainCPP-1238">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1239">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1240">            print_xyz("set_bed_level_equation_lsq &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1241">          }</front>
<front id="Marlin_mainCPP-1242">        #endif</front>
<front id="Marlin_mainCPP-1243"></front>
<front id="Marlin_mainCPP-1244">        sync_plan_position();</front>
<front id="Marlin_mainCPP-1245">      }</front>
<front id="Marlin_mainCPP-1246"></front>
<front id="Marlin_mainCPP-1247">    #endif // !DELTA</front>
<front id="Marlin_mainCPP-1248"></front>
<front id="Marlin_mainCPP-1249">  #else // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-1250"></front>
<front id="Marlin_mainCPP-1251">    static void set_bed_level_equation_3pts(float z_at_pt_1, float z_at_pt_2, float z_at_pt_3) {</front>
<front id="Marlin_mainCPP-1252"></front>
<front id="Marlin_mainCPP-1253">      plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-1254"></front>
<front id="Marlin_mainCPP-1255">      vector_3 pt1 = vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, z_at_pt_1);</front>
<front id="Marlin_mainCPP-1256">      vector_3 pt2 = vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, z_at_pt_2);</front>
<front id="Marlin_mainCPP-1257">      vector_3 pt3 = vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, z_at_pt_3);</front>
<front id="Marlin_mainCPP-1258">      vector_3 planeNormal = vector_3::cross(pt1 - pt2, pt3 - pt2).get_normal();</front>
<front id="Marlin_mainCPP-1259"></front>
<front id="Marlin_mainCPP-1260">      if (planeNormal.z &lt; 0) {</front>
<front id="Marlin_mainCPP-1261">        planeNormal.x = -planeNormal.x;</front>
<front id="Marlin_mainCPP-1262">        planeNormal.y = -planeNormal.y;</front>
<front id="Marlin_mainCPP-1263">        planeNormal.z = -planeNormal.z;</front>
<front id="Marlin_mainCPP-1264">      }</front>
<front id="Marlin_mainCPP-1265"></front>
<front id="Marlin_mainCPP-1266">      plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);</front>
<front id="Marlin_mainCPP-1267"></front>
<front id="Marlin_mainCPP-1268">      vector_3 corrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-1269">      current_position[X_AXIS] = corrected_position.x;</front>
<front id="Marlin_mainCPP-1270">      current_position[Y_AXIS] = corrected_position.y;</front>
<front id="Marlin_mainCPP-1271">      current_position[Z_AXIS] = corrected_position.z;</front>
<front id="Marlin_mainCPP-1272"></front>
<front id="Marlin_mainCPP-1273">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1274">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1275">          print_xyz("set_bed_level_equation_3pts &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1276">        }</front>
<front id="Marlin_mainCPP-1277">      #endif</front>
<front id="Marlin_mainCPP-1278"></front>
<front id="Marlin_mainCPP-1279">      sync_plan_position();</front>
<front id="Marlin_mainCPP-1280">    }</front>
<front id="Marlin_mainCPP-1281"></front>
<front id="Marlin_mainCPP-1282">  #endif // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-1283"></front>
<front id="Marlin_mainCPP-1284">  static void run_z_probe() {</front>
<front id="Marlin_mainCPP-1285"></front>
<front id="Marlin_mainCPP-1286">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1287"></front>
<front id="Marlin_mainCPP-1288">      float start_z = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1289">      long start_steps = st_get_position(Z_AXIS);</front>
<front id="Marlin_mainCPP-1290"></front>
<front id="Marlin_mainCPP-1291">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1292">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1293">          SERIAL_ECHOLNPGM("run_z_probe (DELTA) 1");</front>
<front id="Marlin_mainCPP-1294">        }</front>
<front id="Marlin_mainCPP-1295">      #endif</front>
<front id="Marlin_mainCPP-1296"></front>
<front id="Marlin_mainCPP-1297">      // move down slowly until you find the bed</front>
<front id="Marlin_mainCPP-1298">      feedrate = homing_feedrate[Z_AXIS] / 4;</front>
<front id="Marlin_mainCPP-1299">      destination[Z_AXIS] = -10;</front>
<front id="Marlin_mainCPP-1300">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1301">      st_synchronize();</front>
<front id="Marlin_mainCPP-1302">      endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-1303"></front>
<front id="Marlin_mainCPP-1304">      // we have to let the planner know where we are right now as it is not where we said to go.</front>
<front id="Marlin_mainCPP-1305">      long stop_steps = st_get_position(Z_AXIS);</front>
<front id="Marlin_mainCPP-1306">      float mm = start_z - float(start_steps - stop_steps) / axis_steps_per_unit[Z_AXIS];</front>
<front id="Marlin_mainCPP-1307">      current_position[Z_AXIS] = mm;</front>
<front id="Marlin_mainCPP-1308"></front>
<front id="Marlin_mainCPP-1309">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1310">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1311">          print_xyz("run_z_probe (DELTA) 2 &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1312">        }</front>
<front id="Marlin_mainCPP-1313">      #endif</front>
<front id="Marlin_mainCPP-1314"></front>
<front id="Marlin_mainCPP-1315">      sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-1316"></front>
<front id="Marlin_mainCPP-1317">    #else // !DELTA</front>
<front id="Marlin_mainCPP-1318"></front>
<front id="Marlin_mainCPP-1319">      plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-1320">      feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-1321"></front>
<front id="Marlin_mainCPP-1322">      // Move down until the Z probe (or endstop?) is triggered</front>
<front id="Marlin_mainCPP-1323">      float zPosition = -(Z_MAX_LENGTH + 10);</front>
<front id="Marlin_mainCPP-1324">      line_to_z(zPosition);</front>
<front id="Marlin_mainCPP-1325">      st_synchronize();</front>
<front id="Marlin_mainCPP-1326"></front>
<front id="Marlin_mainCPP-1327">      // Tell the planner where we ended up - Get this from the stepper handler</front>
<front id="Marlin_mainCPP-1328">      zPosition = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-1329">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-1330"></front>
<front id="Marlin_mainCPP-1331">      // move up the retract distance</front>
<front id="Marlin_mainCPP-1332">      zPosition += home_bump_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-1333">      line_to_z(zPosition);</front>
<front id="Marlin_mainCPP-1334">      st_synchronize();</front>
<front id="Marlin_mainCPP-1335">      endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-1336"></front>
<front id="Marlin_mainCPP-1337">      // move back down slowly to find bed</front>
<front id="Marlin_mainCPP-1338">      set_homing_bump_feedrate(Z_AXIS);</front>
<front id="Marlin_mainCPP-1339"></front>
<front id="Marlin_mainCPP-1340">      zPosition -= home_bump_mm(Z_AXIS) * 2;</front>
<front id="Marlin_mainCPP-1341">      line_to_z(zPosition);</front>
<front id="Marlin_mainCPP-1342">      st_synchronize();</front>
<front id="Marlin_mainCPP-1343">      endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-1344"></front>
<front id="Marlin_mainCPP-1345">      // Get the current stepper position after bumping an endstop</front>
<front id="Marlin_mainCPP-1346">      current_position[Z_AXIS] = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-1347">      sync_plan_position();</front>
<front id="Marlin_mainCPP-1348"></front>
<front id="Marlin_mainCPP-1349">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1350">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1351">          print_xyz("run_z_probe &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1352">        }</front>
<front id="Marlin_mainCPP-1353">      #endif</front>
<front id="Marlin_mainCPP-1354"></front>
<front id="Marlin_mainCPP-1355">    #endif // !DELTA</front>
<front id="Marlin_mainCPP-1356">  }</front>
<front id="Marlin_mainCPP-1357"></front>
<front id="Marlin_mainCPP-1358">  /**</front>
<front id="Marlin_mainCPP-1359">   *  Plan a move to (X, Y, Z) and set the current_position</front>
<front id="Marlin_mainCPP-1360">   *  The final current_position may not be the one that was requested</front>
<front id="Marlin_mainCPP-1361">   */</front>
<front id="Marlin_mainCPP-1362">  static void do_blocking_move_to(float x, float y, float z) {</front>
<front id="Marlin_mainCPP-1363">    float oldFeedRate = feedrate;</front>
<front id="Marlin_mainCPP-1364"></front>
<front id="Marlin_mainCPP-1365">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1366">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1367">        print_xyz("do_blocking_move_to", x, y, z);</front>
<front id="Marlin_mainCPP-1368">      }</front>
<front id="Marlin_mainCPP-1369">    #endif</front>
<front id="Marlin_mainCPP-1370"></front>
<front id="Marlin_mainCPP-1371">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1372"></front>
<front id="Marlin_mainCPP-1373">      feedrate = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-1374"></front>
<front id="Marlin_mainCPP-1375">      destination[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-1376">      destination[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-1377">      destination[Z_AXIS] = z;</front>
<front id="Marlin_mainCPP-1378">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1379">      st_synchronize();</front>
<front id="Marlin_mainCPP-1380"></front>
<front id="Marlin_mainCPP-1381">    #else</front>
<front id="Marlin_mainCPP-1382"></front>
<front id="Marlin_mainCPP-1383">      feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-1384"></front>
<front id="Marlin_mainCPP-1385">      current_position[Z_AXIS] = z;</front>
<front id="Marlin_mainCPP-1386">      line_to_current_position();</front>
<front id="Marlin_mainCPP-1387">      st_synchronize();</front>
<front id="Marlin_mainCPP-1388"></front>
<front id="Marlin_mainCPP-1389">      feedrate = xy_travel_speed;</front>
<front id="Marlin_mainCPP-1390"></front>
<front id="Marlin_mainCPP-1391">      current_position[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-1392">      current_position[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-1393">      line_to_current_position();</front>
<front id="Marlin_mainCPP-1394">      st_synchronize();</front>
<front id="Marlin_mainCPP-1395"></front>
<front id="Marlin_mainCPP-1396">    #endif</front>
<front id="Marlin_mainCPP-1397"></front>
<front id="Marlin_mainCPP-1398">    feedrate = oldFeedRate;</front>
<front id="Marlin_mainCPP-1399">  }</front>
<front id="Marlin_mainCPP-1400"></front>
<front id="Marlin_mainCPP-1401">  inline void do_blocking_move_to_xy(float x, float y) { do_blocking_move_to(x, y, current_position[Z_AXIS]); }</front>
<front id="Marlin_mainCPP-1402">  inline void do_blocking_move_to_x(float x) { do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS]); }</front>
<front id="Marlin_mainCPP-1403">  inline void do_blocking_move_to_z(float z) { do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z); }</front>
<front id="Marlin_mainCPP-1404">  inline void raise_z_after_probing() { do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING); }</front>
<front id="Marlin_mainCPP-1405"></front>
<front id="Marlin_mainCPP-1406">  static void clean_up_after_endstop_move() {</front>
<front id="Marlin_mainCPP-1407">    #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)</front>
<front id="Marlin_mainCPP-1408">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1409">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1410">          SERIAL_ECHOLNPGM("clean_up_after_endstop_move &gt; ENDSTOPS_ONLY_FOR_HOMING &gt; enable_endstops(false)");</front>
<front id="Marlin_mainCPP-1411">        }</front>
<front id="Marlin_mainCPP-1412">      #endif</front>
<front id="Marlin_mainCPP-1413">      enable_endstops(false);</front>
<front id="Marlin_mainCPP-1414">    #endif</front>
<front id="Marlin_mainCPP-1415">    feedrate = saved_feedrate;</front>
<front id="Marlin_mainCPP-1416">    feedrate_multiplier = saved_feedrate_multiplier;</front>
<front id="Marlin_mainCPP-1417">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-1418">  }</front>
<front id="Marlin_mainCPP-1419"></front>
<front id="Marlin_mainCPP-1420">  static void deploy_z_probe() {</front>
<front id="Marlin_mainCPP-1421"></front>
<front id="Marlin_mainCPP-1422">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1423">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1424">        print_xyz("deploy_z_probe &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1425">      }</front>
<front id="Marlin_mainCPP-1426">    #endif</front>
<front id="Marlin_mainCPP-1427"></front>
<front id="Marlin_mainCPP-1428">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-1429"></front>
<front id="Marlin_mainCPP-1430">      // Engage Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-1431">      if (servo_endstop_id[Z_AXIS] &gt;= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);</front>
<front id="Marlin_mainCPP-1432"></front>
<front id="Marlin_mainCPP-1433">    #elif ENABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1434">      feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE;</front>
<front id="Marlin_mainCPP-1435"></front>
<front id="Marlin_mainCPP-1436">      // If endstop is already false, the Z probe is deployed</front>
<front id="Marlin_mainCPP-1437">      #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-1438">        bool z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1439">        if (z_probe_endstop)</front>
<front id="Marlin_mainCPP-1440">      #else</front>
<front id="Marlin_mainCPP-1441">        bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1442">        if (z_min_endstop)</front>
<front id="Marlin_mainCPP-1443">      #endif</front>
<front id="Marlin_mainCPP-1444">        {</front>
<front id="Marlin_mainCPP-1445"></front>
<front id="Marlin_mainCPP-1446">          // Move to the start position to initiate deployment</front>
<front id="Marlin_mainCPP-1447">          destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_X;</front>
<front id="Marlin_mainCPP-1448">          destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Y;</front>
<front id="Marlin_mainCPP-1449">          destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Z;</front>
<front id="Marlin_mainCPP-1450">          prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1451"></front>
<front id="Marlin_mainCPP-1452">          // Move to engage deployment</front>
<front id="Marlin_mainCPP-1453">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1454">            feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE;</front>
<front id="Marlin_mainCPP-1455">          }</front>
<front id="Marlin_mainCPP-1456">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_X != Z_PROBE_ALLEN_KEY_DEPLOY_1_X) {</front>
<front id="Marlin_mainCPP-1457">            destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_X;</front>
<front id="Marlin_mainCPP-1458">          }</front>
<front id="Marlin_mainCPP-1459">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Y != Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) {</front>
<front id="Marlin_mainCPP-1460">            destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Y;</front>
<front id="Marlin_mainCPP-1461">          }</front>
<front id="Marlin_mainCPP-1462">          if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Z != Z_PROBE_ALLEN_KEY_DEPLOY_1_Z) {</front>
<front id="Marlin_mainCPP-1463">            destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Z;</front>
<front id="Marlin_mainCPP-1464">          }</front>
<front id="Marlin_mainCPP-1465">          prepare_move_raw();</front>
<front id="Marlin_mainCPP-1466"></front>
<front id="Marlin_mainCPP-1467">          #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3_X</front>
<front id="Marlin_mainCPP-1468">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1469">              feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;</front>
<front id="Marlin_mainCPP-1470">            }</front>
<front id="Marlin_mainCPP-1471"></front>
<front id="Marlin_mainCPP-1472">            // Move to trigger deployment</front>
<front id="Marlin_mainCPP-1473">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1474">              feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;</front>
<front id="Marlin_mainCPP-1475">            }</front>
<front id="Marlin_mainCPP-1476">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_X != Z_PROBE_ALLEN_KEY_DEPLOY_2_X) {</front>
<front id="Marlin_mainCPP-1477">              destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_X;</front>
<front id="Marlin_mainCPP-1478">            }</front>
<front id="Marlin_mainCPP-1479">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Y != Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) {</front>
<front id="Marlin_mainCPP-1480">              destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Y;</front>
<front id="Marlin_mainCPP-1481">            }</front>
<front id="Marlin_mainCPP-1482">            if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Z != Z_PROBE_ALLEN_KEY_DEPLOY_2_Z) {</front>
<front id="Marlin_mainCPP-1483">              destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Z;</front>
<front id="Marlin_mainCPP-1484">            }</front>
<front id="Marlin_mainCPP-1485">            prepare_move_raw();</front>
<front id="Marlin_mainCPP-1486">          #endif</front>
<front id="Marlin_mainCPP-1487">      }</front>
<front id="Marlin_mainCPP-1488"></front>
<front id="Marlin_mainCPP-1489">      // Partially Home X,Y for safety</front>
<front id="Marlin_mainCPP-1490">      destination[X_AXIS] = destination[X_AXIS]*0.75;</front>
<front id="Marlin_mainCPP-1491">      destination[Y_AXIS] = destination[Y_AXIS]*0.75;</front>
<front id="Marlin_mainCPP-1492">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1493"></front>
<front id="Marlin_mainCPP-1494">      st_synchronize();</front>
<front id="Marlin_mainCPP-1495"></front>
<front id="Marlin_mainCPP-1496">      #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-1497">        z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1498">        if (z_probe_endstop)</front>
<front id="Marlin_mainCPP-1499">      #else</front>
<front id="Marlin_mainCPP-1500">        z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1501">        if (z_min_endstop)</front>
<front id="Marlin_mainCPP-1502">      #endif</front>
<front id="Marlin_mainCPP-1503">        {</front>
<front id="Marlin_mainCPP-1504">          if (IsRunning()) {</front>
<front id="Marlin_mainCPP-1505">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-1506">            SERIAL_ERRORLNPGM("Z-Probe failed to engage!");</front>
<front id="Marlin_mainCPP-1507">            LCD_ALERTMESSAGEPGM("Err: ZPROBE");</front>
<front id="Marlin_mainCPP-1508">          }</front>
<front id="Marlin_mainCPP-1509">          Stop();</front>
<front id="Marlin_mainCPP-1510">        }</front>
<front id="Marlin_mainCPP-1511"></front>
<front id="Marlin_mainCPP-1512">    #endif // Z_PROBE_ALLEN_KEY</front>
<front id="Marlin_mainCPP-1513"></front>
<front id="Marlin_mainCPP-1514">  }</front>
<front id="Marlin_mainCPP-1515"></front>
<front id="Marlin_mainCPP-1516">  static void stow_z_probe(bool doRaise=true) {</front>
<front id="Marlin_mainCPP-1517"></front>
<front id="Marlin_mainCPP-1518">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1519">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1520">        print_xyz("stow_z_probe &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1521">      }</front>
<front id="Marlin_mainCPP-1522">    #endif</front>
<front id="Marlin_mainCPP-1523"></front>
<front id="Marlin_mainCPP-1524">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-1525"></front>
<front id="Marlin_mainCPP-1526">      // Retract Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-1527">      if (servo_endstop_id[Z_AXIS] &gt;= 0) {</front>
<front id="Marlin_mainCPP-1528"></front>
<front id="Marlin_mainCPP-1529">        #if Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-1530">          if (doRaise) {</front>
<front id="Marlin_mainCPP-1531">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1532">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1533">                SERIAL_ECHOPAIR("Raise Z (after) by ", (float)Z_RAISE_AFTER_PROBING);</front>
<front id="Marlin_mainCPP-1534">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1535">                SERIAL_ECHOPAIR("&gt; SERVO_ENDSTOPS &gt; raise_z_after_probing()");</front>
<front id="Marlin_mainCPP-1536">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1537">              }</front>
<front id="Marlin_mainCPP-1538">            #endif</front>
<front id="Marlin_mainCPP-1539">            raise_z_after_probing(); // this also updates current_position</front>
<front id="Marlin_mainCPP-1540">            st_synchronize();</front>
<front id="Marlin_mainCPP-1541">          }</front>
<front id="Marlin_mainCPP-1542">        #endif</front>
<front id="Marlin_mainCPP-1543"></front>
<front id="Marlin_mainCPP-1544">        // Change the Z servo angle</front>
<front id="Marlin_mainCPP-1545">        servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][1]);</front>
<front id="Marlin_mainCPP-1546">      }</front>
<front id="Marlin_mainCPP-1547"></front>
<front id="Marlin_mainCPP-1548">    #elif ENABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1549"></front>
<front id="Marlin_mainCPP-1550">      // Move up for safety</front>
<front id="Marlin_mainCPP-1551">      feedrate = Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE;</front>
<front id="Marlin_mainCPP-1552"></front>
<front id="Marlin_mainCPP-1553">      #if Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-1554">        destination[Z_AXIS] = current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING;</front>
<front id="Marlin_mainCPP-1555">        prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1556">      #endif</front>
<front id="Marlin_mainCPP-1557"></front>
<front id="Marlin_mainCPP-1558">      // Move to the start position to initiate retraction</front>
<front id="Marlin_mainCPP-1559">      destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_X;</front>
<front id="Marlin_mainCPP-1560">      destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Y;</front>
<front id="Marlin_mainCPP-1561">      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Z;</front>
<front id="Marlin_mainCPP-1562">      prepare_move_raw();</front>
<front id="Marlin_mainCPP-1563"></front>
<front id="Marlin_mainCPP-1564">      // Move the nozzle down to push the Z probe into retracted position</front>
<front id="Marlin_mainCPP-1565">      if (Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1566">        feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;</front>
<front id="Marlin_mainCPP-1567">      }</front>
<front id="Marlin_mainCPP-1568">      if (Z_PROBE_ALLEN_KEY_STOW_2_X != Z_PROBE_ALLEN_KEY_STOW_1_X) {</front>
<front id="Marlin_mainCPP-1569">        destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_X;</front>
<front id="Marlin_mainCPP-1570">      }</front>
<front id="Marlin_mainCPP-1571">      if (Z_PROBE_ALLEN_KEY_STOW_2_Y != Z_PROBE_ALLEN_KEY_STOW_1_Y) {</front>
<front id="Marlin_mainCPP-1572">        destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Y;</front>
<front id="Marlin_mainCPP-1573">      }</front>
<front id="Marlin_mainCPP-1574">      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Z;</front>
<front id="Marlin_mainCPP-1575">      prepare_move_raw();</front>
<front id="Marlin_mainCPP-1576"></front>
<front id="Marlin_mainCPP-1577">      // Move up for safety</front>
<front id="Marlin_mainCPP-1578">      if (Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE) {</front>
<front id="Marlin_mainCPP-1579">        feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;</front>
<front id="Marlin_mainCPP-1580">      }</front>
<front id="Marlin_mainCPP-1581">      if (Z_PROBE_ALLEN_KEY_STOW_3_X != Z_PROBE_ALLEN_KEY_STOW_2_X) {</front>
<front id="Marlin_mainCPP-1582">        destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_X;</front>
<front id="Marlin_mainCPP-1583">      }</front>
<front id="Marlin_mainCPP-1584">      if (Z_PROBE_ALLEN_KEY_STOW_3_Y != Z_PROBE_ALLEN_KEY_STOW_2_Y) {</front>
<front id="Marlin_mainCPP-1585">        destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Y;</front>
<front id="Marlin_mainCPP-1586">      }</front>
<front id="Marlin_mainCPP-1587">      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Z;</front>
<front id="Marlin_mainCPP-1588">      prepare_move_raw();</front>
<front id="Marlin_mainCPP-1589"></front>
<front id="Marlin_mainCPP-1590">      // Home XY for safety</front>
<front id="Marlin_mainCPP-1591">      feedrate = homing_feedrate[X_AXIS]/2;</front>
<front id="Marlin_mainCPP-1592">      destination[X_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1593">      destination[Y_AXIS] = 0;</front>
<front id="Marlin_mainCPP-1594">      prepare_move_raw(); // this will also set_current_to_destination</front>
<front id="Marlin_mainCPP-1595"></front>
<front id="Marlin_mainCPP-1596">      st_synchronize();</front>
<front id="Marlin_mainCPP-1597"></front>
<front id="Marlin_mainCPP-1598">      #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-1599">        bool z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1600">        if (!z_probe_endstop)</front>
<front id="Marlin_mainCPP-1601">      #else</front>
<front id="Marlin_mainCPP-1602">        bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);</front>
<front id="Marlin_mainCPP-1603">        if (!z_min_endstop)</front>
<front id="Marlin_mainCPP-1604">      #endif</front>
<front id="Marlin_mainCPP-1605">        {</front>
<front id="Marlin_mainCPP-1606">          if (IsRunning()) {</front>
<front id="Marlin_mainCPP-1607">            SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-1608">            SERIAL_ERRORLNPGM("Z-Probe failed to retract!");</front>
<front id="Marlin_mainCPP-1609">            LCD_ALERTMESSAGEPGM("Err: ZPROBE");</front>
<front id="Marlin_mainCPP-1610">          }</front>
<front id="Marlin_mainCPP-1611">          Stop();</front>
<front id="Marlin_mainCPP-1612">        }</front>
<front id="Marlin_mainCPP-1613"></front>
<front id="Marlin_mainCPP-1614">    #endif // Z_PROBE_ALLEN_KEY</front>
<front id="Marlin_mainCPP-1615"></front>
<front id="Marlin_mainCPP-1616">  }</front>
<front id="Marlin_mainCPP-1617"></front>
<front id="Marlin_mainCPP-1618">  enum ProbeAction {</front>
<front id="Marlin_mainCPP-1619">    ProbeStay          = 0,</front>
<front id="Marlin_mainCPP-1620">    ProbeDeploy        = BIT(0),</front>
<front id="Marlin_mainCPP-1621">    ProbeStow          = BIT(1),</front>
<front id="Marlin_mainCPP-1622">    ProbeDeployAndStow = (ProbeDeploy | ProbeStow)</front>
<front id="Marlin_mainCPP-1623">  };</front>
<front id="Marlin_mainCPP-1624"></front>
<front id="Marlin_mainCPP-1625">  // Probe bed height at position (x,y), returns the measured z value</front>
<front id="Marlin_mainCPP-1626">  static float probe_pt(float x, float y, float z_before, ProbeAction probe_action=ProbeDeployAndStow, int verbose_level=1) {</front>
<front id="Marlin_mainCPP-1627"></front>
<front id="Marlin_mainCPP-1628">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1629">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1630">        SERIAL_ECHOLNPGM("probe_pt &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-1631">        SERIAL_ECHOPAIR("&gt; ProbeAction:", (unsigned long)probe_action);</front>
<front id="Marlin_mainCPP-1632">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1633">        print_xyz("&gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1634">      }</front>
<front id="Marlin_mainCPP-1635">    #endif</front>
<front id="Marlin_mainCPP-1636"></front>
<front id="Marlin_mainCPP-1637">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1638">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1639">        SERIAL_ECHOPAIR("Z Raise to z_before ", z_before);</front>
<front id="Marlin_mainCPP-1640">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1641">        SERIAL_ECHOPAIR("&gt; do_blocking_move_to_z ", z_before);</front>
<front id="Marlin_mainCPP-1642">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1643">      }</front>
<front id="Marlin_mainCPP-1644">    #endif</front>
<front id="Marlin_mainCPP-1645"></front>
<front id="Marlin_mainCPP-1646">    // Move Z up to the z_before height, then move the Z probe to the given XY</front>
<front id="Marlin_mainCPP-1647">    do_blocking_move_to_z(z_before); // this also updates current_position</front>
<front id="Marlin_mainCPP-1648"></front>
<front id="Marlin_mainCPP-1649">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1650">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1651">        SERIAL_ECHOPAIR("&gt; do_blocking_move_to_xy ", x - X_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-1652">        SERIAL_ECHOPAIR(", ", y - Y_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-1653">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1654">      }</front>
<front id="Marlin_mainCPP-1655">    #endif</front>
<front id="Marlin_mainCPP-1656"></front>
<front id="Marlin_mainCPP-1657">    do_blocking_move_to_xy(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER); // this also updates current_position</front>
<front id="Marlin_mainCPP-1658"></front>
<front id="Marlin_mainCPP-1659">    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1660">      if (probe_action & ProbeDeploy) {</front>
<front id="Marlin_mainCPP-1661">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1662">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1663">            SERIAL_ECHOLNPGM("&gt; ProbeDeploy");</front>
<front id="Marlin_mainCPP-1664">          }</front>
<front id="Marlin_mainCPP-1665">        #endif</front>
<front id="Marlin_mainCPP-1666">        deploy_z_probe();</front>
<front id="Marlin_mainCPP-1667">      }</front>
<front id="Marlin_mainCPP-1668">    #endif</front>
<front id="Marlin_mainCPP-1669"></front>
<front id="Marlin_mainCPP-1670">    run_z_probe();</front>
<front id="Marlin_mainCPP-1671">    float measured_z = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1672"></front>
<front id="Marlin_mainCPP-1673">    #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-1674">      if (probe_action & ProbeStow) {</front>
<front id="Marlin_mainCPP-1675">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1676">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1677">            SERIAL_ECHOLNPGM("&gt; ProbeStow (stow_z_probe will do Z Raise)");</front>
<front id="Marlin_mainCPP-1678">          }</front>
<front id="Marlin_mainCPP-1679">        #endif</front>
<front id="Marlin_mainCPP-1680">        stow_z_probe();</front>
<front id="Marlin_mainCPP-1681">      }</front>
<front id="Marlin_mainCPP-1682">    #endif</front>
<front id="Marlin_mainCPP-1683"></front>
<front id="Marlin_mainCPP-1684">    if (verbose_level &gt; 2) {</front>
<front id="Marlin_mainCPP-1685">      SERIAL_PROTOCOLPGM("Bed X: ");</front>
<front id="Marlin_mainCPP-1686">      SERIAL_PROTOCOL_F(x, 3);</front>
<front id="Marlin_mainCPP-1687">      SERIAL_PROTOCOLPGM(" Y: ");</front>
<front id="Marlin_mainCPP-1688">      SERIAL_PROTOCOL_F(y, 3);</front>
<front id="Marlin_mainCPP-1689">      SERIAL_PROTOCOLPGM(" Z: ");</front>
<front id="Marlin_mainCPP-1690">      SERIAL_PROTOCOL_F(measured_z, 3);</front>
<front id="Marlin_mainCPP-1691">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1692">    }</front>
<front id="Marlin_mainCPP-1693"></front>
<front id="Marlin_mainCPP-1694">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1695">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1696">        SERIAL_ECHOLNPGM("&lt;&lt;&lt; probe_pt");</front>
<front id="Marlin_mainCPP-1697">      }</front>
<front id="Marlin_mainCPP-1698">    #endif</front>
<front id="Marlin_mainCPP-1699"></front>
<front id="Marlin_mainCPP-1700">    return measured_z;</front>
<front id="Marlin_mainCPP-1701">  }</front>
<front id="Marlin_mainCPP-1702"></front>
<front id="Marlin_mainCPP-1703">  #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1704"></front>
<front id="Marlin_mainCPP-1705">    /**</front>
<front id="Marlin_mainCPP-1706">     * All DELTA leveling in the Marlin uses NONLINEAR_BED_LEVELING</front>
<front id="Marlin_mainCPP-1707">     */</front>
<front id="Marlin_mainCPP-1708"></front>
<front id="Marlin_mainCPP-1709">    static void extrapolate_one_point(int x, int y, int xdir, int ydir) {</front>
<front id="Marlin_mainCPP-1710">      if (bed_level[x][y] != 0.0) {</front>
<front id="Marlin_mainCPP-1711">        return;  // Don't overwrite good values.</front>
<front id="Marlin_mainCPP-1712">      }</front>
<front id="Marlin_mainCPP-1713">      float a = 2*bed_level[x+xdir][y] - bed_level[x+xdir*2][y];  // Left to right.</front>
<front id="Marlin_mainCPP-1714">      float b = 2*bed_level[x][y+ydir] - bed_level[x][y+ydir*2];  // Front to back.</front>
<front id="Marlin_mainCPP-1715">      float c = 2*bed_level[x+xdir][y+ydir] - bed_level[x+xdir*2][y+ydir*2];  // Diagonal.</front>
<front id="Marlin_mainCPP-1716">      float median = c;  // Median is robust (ignores outliers).</front>
<front id="Marlin_mainCPP-1717">      if (a &lt; b) {</front>
<front id="Marlin_mainCPP-1718">        if (b &lt; c) median = b;</front>
<front id="Marlin_mainCPP-1719">        if (c &lt; a) median = a;</front>
<front id="Marlin_mainCPP-1720">      } else {  // b &lt;= a</front>
<front id="Marlin_mainCPP-1721">        if (c &lt; b) median = b;</front>
<front id="Marlin_mainCPP-1722">        if (a &lt; c) median = a;</front>
<front id="Marlin_mainCPP-1723">      }</front>
<front id="Marlin_mainCPP-1724">      bed_level[x][y] = median;</front>
<front id="Marlin_mainCPP-1725">    }</front>
<front id="Marlin_mainCPP-1726"></front>
<front id="Marlin_mainCPP-1727">    // Fill in the unprobed points (corners of circular print surface)</front>
<front id="Marlin_mainCPP-1728">    // using linear extrapolation, away from the center.</front>
<front id="Marlin_mainCPP-1729">    static void extrapolate_unprobed_bed_level() {</front>
<front id="Marlin_mainCPP-1730">      int half = (AUTO_BED_LEVELING_GRID_POINTS-1)/2;</front>
<front id="Marlin_mainCPP-1731">      for (int y = 0; y &lt;= half; y++) {</front>
<front id="Marlin_mainCPP-1732">        for (int x = 0; x &lt;= half; x++) {</front>
<front id="Marlin_mainCPP-1733">          if (x + y &lt; 3) continue;</front>
<front id="Marlin_mainCPP-1734">          extrapolate_one_point(half-x, half-y, x&gt;1?+1:0, y&gt;1?+1:0);</front>
<front id="Marlin_mainCPP-1735">          extrapolate_one_point(half+x, half-y, x&gt;1?-1:0, y&gt;1?+1:0);</front>
<front id="Marlin_mainCPP-1736">          extrapolate_one_point(half-x, half+y, x&gt;1?+1:0, y&gt;1?-1:0);</front>
<front id="Marlin_mainCPP-1737">          extrapolate_one_point(half+x, half+y, x&gt;1?-1:0, y&gt;1?-1:0);</front>
<front id="Marlin_mainCPP-1738">        }</front>
<front id="Marlin_mainCPP-1739">      }</front>
<front id="Marlin_mainCPP-1740">    }</front>
<front id="Marlin_mainCPP-1741"></front>
<front id="Marlin_mainCPP-1742">    // Print calibration results for plotting or manual frame adjustment.</front>
<front id="Marlin_mainCPP-1743">    static void print_bed_level() {</front>
<front id="Marlin_mainCPP-1744">      for (int y = 0; y &lt; AUTO_BED_LEVELING_GRID_POINTS; y++) {</front>
<front id="Marlin_mainCPP-1745">        for (int x = 0; x &lt; AUTO_BED_LEVELING_GRID_POINTS; x++) {</front>
<front id="Marlin_mainCPP-1746">          SERIAL_PROTOCOL_F(bed_level[x][y], 2);</front>
<front id="Marlin_mainCPP-1747">          SERIAL_PROTOCOLCHAR(' ');</front>
<front id="Marlin_mainCPP-1748">        }</front>
<front id="Marlin_mainCPP-1749">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1750">      }</front>
<front id="Marlin_mainCPP-1751">    }</front>
<front id="Marlin_mainCPP-1752"></front>
<front id="Marlin_mainCPP-1753">    // Reset calibration results to zero.</front>
<front id="Marlin_mainCPP-1754">    void reset_bed_level() {</front>
<front id="Marlin_mainCPP-1755">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1756">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1757">          SERIAL_ECHOLNPGM("reset_bed_level");</front>
<front id="Marlin_mainCPP-1758">        }</front>
<front id="Marlin_mainCPP-1759">      #endif</front>
<front id="Marlin_mainCPP-1760">      for (int y = 0; y &lt; AUTO_BED_LEVELING_GRID_POINTS; y++) {</front>
<front id="Marlin_mainCPP-1761">        for (int x = 0; x &lt; AUTO_BED_LEVELING_GRID_POINTS; x++) {</front>
<front id="Marlin_mainCPP-1762">          bed_level[x][y] = 0.0;</front>
<front id="Marlin_mainCPP-1763">        }</front>
<front id="Marlin_mainCPP-1764">      }</front>
<front id="Marlin_mainCPP-1765">    }</front>
<front id="Marlin_mainCPP-1766"></front>
<front id="Marlin_mainCPP-1767">  #endif // DELTA</front>
<front id="Marlin_mainCPP-1768"></front>
<front id="Marlin_mainCPP-1769">  #if HAS_SERVO_ENDSTOPS && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1770"></front>
<front id="Marlin_mainCPP-1771">    void raise_z_for_servo() {</front>
<front id="Marlin_mainCPP-1772">      float zpos = current_position[Z_AXIS], z_dest = Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-1773">      z_dest += axis_known_position[Z_AXIS] ? zprobe_zoffset : zpos;</front>
<front id="Marlin_mainCPP-1774">      if (zpos &lt; z_dest) do_blocking_move_to_z(z_dest); // also updates current_position</front>
<front id="Marlin_mainCPP-1775">    }</front>
<front id="Marlin_mainCPP-1776"></front>
<front id="Marlin_mainCPP-1777">  #endif</front>
<front id="Marlin_mainCPP-1778"></front>
<front id="Marlin_mainCPP-1779">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-1780"></front>
<front id="Marlin_mainCPP-1781"></front>
<front id="Marlin_mainCPP-1782">#if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1783"></front>
<front id="Marlin_mainCPP-1784">  #ifndef SLED_DOCKING_OFFSET</front>
<front id="Marlin_mainCPP-1785">    #define SLED_DOCKING_OFFSET 0</front>
<front id="Marlin_mainCPP-1786">  #endif</front>
<front id="Marlin_mainCPP-1787"></front>
<front id="Marlin_mainCPP-1788">  /**</front>
<front id="Marlin_mainCPP-1789">   * Method to dock/undock a sled designed by Charles Bell.</front>
<front id="Marlin_mainCPP-1790">   *</front>
<front id="Marlin_mainCPP-1791">   * dock[in]     If true, move to MAX_X and engage the electromagnet</front>
<front id="Marlin_mainCPP-1792">   * offset[in]   The additional distance to move to adjust docking location</front>
<front id="Marlin_mainCPP-1793">   */</front>
<front id="Marlin_mainCPP-1794">  static void dock_sled(bool dock, int offset=0) {</front>
<front id="Marlin_mainCPP-1795">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1796">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1797">        SERIAL_ECHOPAIR("dock_sled", dock);</front>
<front id="Marlin_mainCPP-1798">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1799">      }</front>
<front id="Marlin_mainCPP-1800">    #endif</front>
<front id="Marlin_mainCPP-1801">    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-1802">      LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-1803">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-1804">      SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-1805">      return;</front>
<front id="Marlin_mainCPP-1806">    }</front>
<front id="Marlin_mainCPP-1807"></front>
<front id="Marlin_mainCPP-1808">    float oldXpos = current_position[X_AXIS]; // save x position</front>
<front id="Marlin_mainCPP-1809">    if (dock) {</front>
<front id="Marlin_mainCPP-1810">      #if Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-1811">        raise_z_after_probing(); // raise Z</front>
<front id="Marlin_mainCPP-1812">      #endif</front>
<front id="Marlin_mainCPP-1813">      do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);  // Dock sled a bit closer to ensure proper capturing</front>
<front id="Marlin_mainCPP-1814">      digitalWrite(SLED_PIN, LOW); // turn off magnet</front>
<front id="Marlin_mainCPP-1815">    } else {</front>
<front id="Marlin_mainCPP-1816">      float z_loc = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-1817">      if (z_loc &lt; Z_RAISE_BEFORE_PROBING + 5) z_loc = Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-1818">      do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset, current_position[Y_AXIS], z_loc); // this also updates current_position</front>
<front id="Marlin_mainCPP-1819">      digitalWrite(SLED_PIN, HIGH); // turn on magnet</front>
<front id="Marlin_mainCPP-1820">    }</front>
<front id="Marlin_mainCPP-1821">    do_blocking_move_to_x(oldXpos); // return to position before docking</front>
<front id="Marlin_mainCPP-1822">  }</front>
<front id="Marlin_mainCPP-1823"></front>
<front id="Marlin_mainCPP-1824">#endif // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-1825"></front>
<front id="Marlin_mainCPP-1826"></front>
<front id="Marlin_mainCPP-1827"></front>
<front id="Marlin_mainCPP-1828">/**</front>
<front id="Marlin_mainCPP-1829"> * Home an individual axis</front>
<front id="Marlin_mainCPP-1830"> */</front>
<front id="Marlin_mainCPP-1831"></front>
<front id="Marlin_mainCPP-1832">#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)</front>
<front id="Marlin_mainCPP-1833"></front>
<front id="Marlin_mainCPP-1834">static void homeaxis(AxisEnum axis) {</front>
<front id="Marlin_mainCPP-1835">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1836">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1837">      SERIAL_ECHOPAIR("&gt;&gt;&gt; homeaxis(", (unsigned long)axis);</front>
<front id="Marlin_mainCPP-1838">      SERIAL_CHAR(')');</front>
<front id="Marlin_mainCPP-1839">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1840">    }</front>
<front id="Marlin_mainCPP-1841">  #endif</front>
<front id="Marlin_mainCPP-1842">  #define HOMEAXIS_DO(LETTER) \</front>
<front id="Marlin_mainCPP-1843">    ((LETTER##_MIN_PIN &gt; -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN &gt; -1 && LETTER##_HOME_DIR==1))</front>
<front id="Marlin_mainCPP-1844"></front>
<front id="Marlin_mainCPP-1845">  if (axis == X_AXIS ? HOMEAXIS_DO(X) : axis == Y_AXIS ? HOMEAXIS_DO(Y) : axis == Z_AXIS ? HOMEAXIS_DO(Z) : 0) {</front>
<front id="Marlin_mainCPP-1846"></front>
<front id="Marlin_mainCPP-1847">    int axis_home_dir =</front>
<front id="Marlin_mainCPP-1848">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-1849">        (axis == X_AXIS) ? x_home_dir(active_extruder) :</front>
<front id="Marlin_mainCPP-1850">      #endif</front>
<front id="Marlin_mainCPP-1851">      home_dir(axis);</front>
<front id="Marlin_mainCPP-1852"></front>
<front id="Marlin_mainCPP-1853">    // Set the axis position as setup for the move</front>
<front id="Marlin_mainCPP-1854">    current_position[axis] = 0;</front>
<front id="Marlin_mainCPP-1855">    sync_plan_position();</front>
<front id="Marlin_mainCPP-1856"></front>
<front id="Marlin_mainCPP-1857">    #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1858">      // Get Probe</front>
<front id="Marlin_mainCPP-1859">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-1860">        if (axis_home_dir &lt; 0) dock_sled(false);</front>
<front id="Marlin_mainCPP-1861">      }</front>
<front id="Marlin_mainCPP-1862">    #endif</front>
<front id="Marlin_mainCPP-1863"></front>
<front id="Marlin_mainCPP-1864">    #if SERVO_LEVELING && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-1865"></front>
<front id="Marlin_mainCPP-1866">      // Deploy a Z probe if there is one, and homing towards the bed</front>
<front id="Marlin_mainCPP-1867">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-1868">        if (axis_home_dir &lt; 0) deploy_z_probe();</front>
<front id="Marlin_mainCPP-1869">      }</front>
<front id="Marlin_mainCPP-1870"></front>
<front id="Marlin_mainCPP-1871">    #endif</front>
<front id="Marlin_mainCPP-1872"></front>
<front id="Marlin_mainCPP-1873">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-1874">      // Engage Servo endstop if enabled</front>
<front id="Marlin_mainCPP-1875">      if (axis != Z_AXIS && servo_endstop_id[axis] &gt;= 0)</front>
<front id="Marlin_mainCPP-1876">        servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][0]);</front>
<front id="Marlin_mainCPP-1877">    #endif</front>
<front id="Marlin_mainCPP-1878"></front>
<front id="Marlin_mainCPP-1879">    // Set a flag for Z motor locking</front>
<front id="Marlin_mainCPP-1880">    #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-1881">      if (axis == Z_AXIS) In_Homing_Process(true);</front>
<front id="Marlin_mainCPP-1882">    #endif</front>
<front id="Marlin_mainCPP-1883"></front>
<front id="Marlin_mainCPP-1884">    // Move towards the endstop until an endstop is triggered</front>
<front id="Marlin_mainCPP-1885">    destination[axis] = 1.5 * max_length(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-1886">    feedrate = homing_feedrate[axis];</front>
<front id="Marlin_mainCPP-1887">    line_to_destination();</front>
<front id="Marlin_mainCPP-1888">    st_synchronize();</front>
<front id="Marlin_mainCPP-1889"></front>
<front id="Marlin_mainCPP-1890">    // Set the axis position as setup for the move</front>
<front id="Marlin_mainCPP-1891">    current_position[axis] = 0;</front>
<front id="Marlin_mainCPP-1892">    sync_plan_position();</front>
<front id="Marlin_mainCPP-1893"></front>
<front id="Marlin_mainCPP-1894">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1895">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1896">        SERIAL_ECHOLNPGM("&gt; enable_endstops(false)");</front>
<front id="Marlin_mainCPP-1897">      }</front>
<front id="Marlin_mainCPP-1898">    #endif</front>
<front id="Marlin_mainCPP-1899">    enable_endstops(false); // Disable endstops while moving away</front>
<front id="Marlin_mainCPP-1900"></front>
<front id="Marlin_mainCPP-1901">    // Move away from the endstop by the axis HOME_BUMP_MM</front>
<front id="Marlin_mainCPP-1902">    destination[axis] = -home_bump_mm(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-1903">    line_to_destination();</front>
<front id="Marlin_mainCPP-1904">    st_synchronize();</front>
<front id="Marlin_mainCPP-1905"></front>
<front id="Marlin_mainCPP-1906">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1907">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1908">        SERIAL_ECHOLNPGM("&gt; enable_endstops(true)");</front>
<front id="Marlin_mainCPP-1909">      }</front>
<front id="Marlin_mainCPP-1910">    #endif</front>
<front id="Marlin_mainCPP-1911">    enable_endstops(true); // Enable endstops for next homing move</front>
<front id="Marlin_mainCPP-1912"></front>
<front id="Marlin_mainCPP-1913">    // Slow down the feedrate for the next move</front>
<front id="Marlin_mainCPP-1914">    set_homing_bump_feedrate(axis);</front>
<front id="Marlin_mainCPP-1915"></front>
<front id="Marlin_mainCPP-1916">    // Move slowly towards the endstop until triggered</front>
<front id="Marlin_mainCPP-1917">    destination[axis] = 2 * home_bump_mm(axis) * axis_home_dir;</front>
<front id="Marlin_mainCPP-1918">    line_to_destination();</front>
<front id="Marlin_mainCPP-1919">    st_synchronize();</front>
<front id="Marlin_mainCPP-1920"></front>
<front id="Marlin_mainCPP-1921">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1922">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1923">        print_xyz("&gt; TRIGGER ENDSTOP &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1924">      }</front>
<front id="Marlin_mainCPP-1925">    #endif</front>
<front id="Marlin_mainCPP-1926"></front>
<front id="Marlin_mainCPP-1927">    #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-1928">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-1929">        float adj = fabs(z_endstop_adj);</front>
<front id="Marlin_mainCPP-1930">        bool lockZ1;</front>
<front id="Marlin_mainCPP-1931">        if (axis_home_dir &gt; 0) {</front>
<front id="Marlin_mainCPP-1932">          adj = -adj;</front>
<front id="Marlin_mainCPP-1933">          lockZ1 = (z_endstop_adj &gt; 0);</front>
<front id="Marlin_mainCPP-1934">        }</front>
<front id="Marlin_mainCPP-1935">        else</front>
<front id="Marlin_mainCPP-1936">          lockZ1 = (z_endstop_adj &lt; 0);</front>
<front id="Marlin_mainCPP-1937"></front>
<front id="Marlin_mainCPP-1938">        if (lockZ1) Lock_z_motor(true); else Lock_z2_motor(true);</front>
<front id="Marlin_mainCPP-1939">        sync_plan_position();</front>
<front id="Marlin_mainCPP-1940"></front>
<front id="Marlin_mainCPP-1941">        // Move to the adjusted endstop height</front>
<front id="Marlin_mainCPP-1942">        feedrate = homing_feedrate[axis];</front>
<front id="Marlin_mainCPP-1943">        destination[Z_AXIS] = adj;</front>
<front id="Marlin_mainCPP-1944">        line_to_destination();</front>
<front id="Marlin_mainCPP-1945">        st_synchronize();</front>
<front id="Marlin_mainCPP-1946"></front>
<front id="Marlin_mainCPP-1947">        if (lockZ1) Lock_z_motor(false); else Lock_z2_motor(false);</front>
<front id="Marlin_mainCPP-1948">        In_Homing_Process(false);</front>
<front id="Marlin_mainCPP-1949">      } // Z_AXIS</front>
<front id="Marlin_mainCPP-1950">    #endif</front>
<front id="Marlin_mainCPP-1951"></front>
<front id="Marlin_mainCPP-1952">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-1953">      // retrace by the amount specified in endstop_adj</front>
<front id="Marlin_mainCPP-1954">      if (endstop_adj[axis] * axis_home_dir &lt; 0) {</front>
<front id="Marlin_mainCPP-1955">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1956">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1957">            SERIAL_ECHOLNPGM("&gt; enable_endstops(false)");</front>
<front id="Marlin_mainCPP-1958">          }</front>
<front id="Marlin_mainCPP-1959">        #endif</front>
<front id="Marlin_mainCPP-1960">        enable_endstops(false); // Disable endstops while moving away</front>
<front id="Marlin_mainCPP-1961">        sync_plan_position();</front>
<front id="Marlin_mainCPP-1962">        destination[axis] = endstop_adj[axis];</front>
<front id="Marlin_mainCPP-1963">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1964">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1965">            SERIAL_ECHOPAIR("&gt; endstop_adj = ", endstop_adj[axis]);</front>
<front id="Marlin_mainCPP-1966">            print_xyz(" &gt; destination", destination);</front>
<front id="Marlin_mainCPP-1967">          }</front>
<front id="Marlin_mainCPP-1968">        #endif</front>
<front id="Marlin_mainCPP-1969">        line_to_destination();</front>
<front id="Marlin_mainCPP-1970">        st_synchronize();</front>
<front id="Marlin_mainCPP-1971">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1972">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1973">            SERIAL_ECHOLNPGM("&gt; enable_endstops(true)");</front>
<front id="Marlin_mainCPP-1974">          }</front>
<front id="Marlin_mainCPP-1975">        #endif</front>
<front id="Marlin_mainCPP-1976">        enable_endstops(true); // Enable endstops for next homing move</front>
<front id="Marlin_mainCPP-1977">      }</front>
<front id="Marlin_mainCPP-1978">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1979">        else {</front>
<front id="Marlin_mainCPP-1980">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1981">            SERIAL_ECHOPAIR("&gt; endstop_adj * axis_home_dir = ", endstop_adj[axis] * axis_home_dir);</front>
<front id="Marlin_mainCPP-1982">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-1983">          }</front>
<front id="Marlin_mainCPP-1984">        }</front>
<front id="Marlin_mainCPP-1985">      #endif</front>
<front id="Marlin_mainCPP-1986">    #endif</front>
<front id="Marlin_mainCPP-1987"></front>
<front id="Marlin_mainCPP-1988">    // Set the axis position to its home position (plus home offsets)</front>
<front id="Marlin_mainCPP-1989">    set_axis_is_at_home(axis);</front>
<front id="Marlin_mainCPP-1990">    sync_plan_position();</front>
<front id="Marlin_mainCPP-1991"></front>
<front id="Marlin_mainCPP-1992">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-1993">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-1994">        print_xyz("&gt; AFTER set_axis_is_at_home &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-1995">      }</front>
<front id="Marlin_mainCPP-1996">    #endif</front>
<front id="Marlin_mainCPP-1997"></front>
<front id="Marlin_mainCPP-1998">    destination[axis] = current_position[axis];</front>
<front id="Marlin_mainCPP-1999">    feedrate = 0.0;</front>
<front id="Marlin_mainCPP-2000">    endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2001">    axis_known_position[axis] = true;</front>
<front id="Marlin_mainCPP-2002"></front>
<front id="Marlin_mainCPP-2003">    #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-2004">    // bring Z probe back</front>
<front id="Marlin_mainCPP-2005">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-2006">        if (axis_home_dir &lt; 0) dock_sled(true);</front>
<front id="Marlin_mainCPP-2007">      }</front>
<front id="Marlin_mainCPP-2008">    #endif</front>
<front id="Marlin_mainCPP-2009"></front>
<front id="Marlin_mainCPP-2010">    #if SERVO_LEVELING && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-2011"></front>
<front id="Marlin_mainCPP-2012">      // Deploy a Z probe if there is one, and homing towards the bed</front>
<front id="Marlin_mainCPP-2013">      if (axis == Z_AXIS) {</front>
<front id="Marlin_mainCPP-2014">        if (axis_home_dir &lt; 0) {</front>
<front id="Marlin_mainCPP-2015">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2016">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2017">              SERIAL_ECHOLNPGM("&gt; SERVO_LEVELING &gt; stow_z_probe");</front>
<front id="Marlin_mainCPP-2018">            }</front>
<front id="Marlin_mainCPP-2019">          #endif</front>
<front id="Marlin_mainCPP-2020">          stow_z_probe();</front>
<front id="Marlin_mainCPP-2021">        }</front>
<front id="Marlin_mainCPP-2022">      }</front>
<front id="Marlin_mainCPP-2023">      else</front>
<front id="Marlin_mainCPP-2024"></front>
<front id="Marlin_mainCPP-2025">    #endif</front>
<front id="Marlin_mainCPP-2026"></front>
<front id="Marlin_mainCPP-2027">    {</front>
<front id="Marlin_mainCPP-2028">      #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-2029">        // Retract Servo endstop if enabled</front>
<front id="Marlin_mainCPP-2030">        if (servo_endstop_id[axis] &gt;= 0) {</front>
<front id="Marlin_mainCPP-2031">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2032">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2033">              SERIAL_ECHOLNPGM("&gt; SERVO_ENDSTOPS &gt; Stow with servo.move()");</front>
<front id="Marlin_mainCPP-2034">            }</front>
<front id="Marlin_mainCPP-2035">          #endif</front>
<front id="Marlin_mainCPP-2036">          servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);</front>
<front id="Marlin_mainCPP-2037">        }</front>
<front id="Marlin_mainCPP-2038">      #endif</front>
<front id="Marlin_mainCPP-2039">    }</front>
<front id="Marlin_mainCPP-2040"></front>
<front id="Marlin_mainCPP-2041">  }</front>
<front id="Marlin_mainCPP-2042"></front>
<front id="Marlin_mainCPP-2043">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2044">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2045">      SERIAL_ECHOPAIR("&lt;&lt;&lt; homeaxis(", (unsigned long)axis);</front>
<front id="Marlin_mainCPP-2046">      SERIAL_CHAR(')');</front>
<front id="Marlin_mainCPP-2047">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2048">    }</front>
<front id="Marlin_mainCPP-2049">  #endif</front>
<front id="Marlin_mainCPP-2050">}</front>
<front id="Marlin_mainCPP-2051"></front>
<front id="Marlin_mainCPP-2052">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-2053"></front>
<front id="Marlin_mainCPP-2054">  void retract(bool retracting, bool swapping=false) {</front>
<front id="Marlin_mainCPP-2055"></front>
<front id="Marlin_mainCPP-2056">    if (retracting == retracted[active_extruder]) return;</front>
<front id="Marlin_mainCPP-2057"></front>
<front id="Marlin_mainCPP-2058">    float oldFeedrate = feedrate;</front>
<front id="Marlin_mainCPP-2059"></front>
<front id="Marlin_mainCPP-2060">    set_destination_to_current();</front>
<front id="Marlin_mainCPP-2061"></front>
<front id="Marlin_mainCPP-2062">    if (retracting) {</front>
<front id="Marlin_mainCPP-2063"></front>
<front id="Marlin_mainCPP-2064">      feedrate = retract_feedrate * 60;</front>
<front id="Marlin_mainCPP-2065">      current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];</front>
<front id="Marlin_mainCPP-2066">      plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2067">      prepare_move();</front>
<front id="Marlin_mainCPP-2068"></front>
<front id="Marlin_mainCPP-2069">      if (retract_zlift &gt; 0.01) {</front>
<front id="Marlin_mainCPP-2070">        current_position[Z_AXIS] -= retract_zlift;</front>
<front id="Marlin_mainCPP-2071">        #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2072">          sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2073">        #else</front>
<front id="Marlin_mainCPP-2074">          sync_plan_position();</front>
<front id="Marlin_mainCPP-2075">        #endif</front>
<front id="Marlin_mainCPP-2076">        prepare_move();</front>
<front id="Marlin_mainCPP-2077">      }</front>
<front id="Marlin_mainCPP-2078">    }</front>
<front id="Marlin_mainCPP-2079">    else {</front>
<front id="Marlin_mainCPP-2080"></front>
<front id="Marlin_mainCPP-2081">      if (retract_zlift &gt; 0.01) {</front>
<front id="Marlin_mainCPP-2082">        current_position[Z_AXIS] += retract_zlift;</front>
<front id="Marlin_mainCPP-2083">        #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2084">          sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2085">        #else</front>
<front id="Marlin_mainCPP-2086">          sync_plan_position();</front>
<front id="Marlin_mainCPP-2087">        #endif</front>
<front id="Marlin_mainCPP-2088">        //prepare_move();</front>
<front id="Marlin_mainCPP-2089">      }</front>
<front id="Marlin_mainCPP-2090"></front>
<front id="Marlin_mainCPP-2091">      feedrate = retract_recover_feedrate * 60;</front>
<front id="Marlin_mainCPP-2092">      float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;</front>
<front id="Marlin_mainCPP-2093">      current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];</front>
<front id="Marlin_mainCPP-2094">      plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-2095">      prepare_move();</front>
<front id="Marlin_mainCPP-2096">    }</front>
<front id="Marlin_mainCPP-2097"></front>
<front id="Marlin_mainCPP-2098">    feedrate = oldFeedrate;</front>
<front id="Marlin_mainCPP-2099">    retracted[active_extruder] = retracting;</front>
<front id="Marlin_mainCPP-2100"></front>
<front id="Marlin_mainCPP-2101">  } // retract()</front>
<front id="Marlin_mainCPP-2102"></front>
<front id="Marlin_mainCPP-2103">#endif // FWRETRACT</front>
<front id="Marlin_mainCPP-2104"></front>
<front id="Marlin_mainCPP-2105">/**</front>
<front id="Marlin_mainCPP-2106"> *</front>
<front id="Marlin_mainCPP-2107"> * G-Code Handler functions</front>
<front id="Marlin_mainCPP-2108"> *</front>
<front id="Marlin_mainCPP-2109"> */</front>
<front id="Marlin_mainCPP-2110"></front>
<front id="Marlin_mainCPP-2111">/**</front>
<front id="Marlin_mainCPP-2112"> * Set XYZE destination and feedrate from the current GCode command</front>
<front id="Marlin_mainCPP-2113"> *</front>
<front id="Marlin_mainCPP-2114"> *  - Set destination from included axis codes</front>
<front id="Marlin_mainCPP-2115"> *  - Set to current for missing axis codes</front>
<front id="Marlin_mainCPP-2116"> *  - Set the feedrate, if included</front>
<front id="Marlin_mainCPP-2117"> */</front>
<front id="Marlin_mainCPP-2118">void gcode_get_destination() {</front>
<front id="Marlin_mainCPP-2119">  for (int i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-2120">    if (code_seen(axis_codes[i]))</front>
<front id="Marlin_mainCPP-2121">      destination[i] = code_value() + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);</front>
<front id="Marlin_mainCPP-2122">    else</front>
<front id="Marlin_mainCPP-2123">      destination[i] = current_position[i];</front>
<front id="Marlin_mainCPP-2124">  }</front>
<front id="Marlin_mainCPP-2125">  if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-2126">    float next_feedrate = code_value();</front>
<front id="Marlin_mainCPP-2127">    if (next_feedrate &gt; 0.0) feedrate = next_feedrate;</front>
<front id="Marlin_mainCPP-2128">  }</front>
<front id="Marlin_mainCPP-2129">}</front>
<front id="Marlin_mainCPP-2130"></front>
<front id="Marlin_mainCPP-2131">void unknown_command_error() {</front>
<front id="Marlin_mainCPP-2132">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2133">  SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);</front>
<front id="Marlin_mainCPP-2134">  SERIAL_ECHO(current_command);</front>
<front id="Marlin_mainCPP-2135">  SERIAL_ECHOPGM("\"\n");</front>
<front id="Marlin_mainCPP-2136">}</front>
<front id="Marlin_mainCPP-2137"></front>
<front id="Marlin_mainCPP-2138">/**</front>
<front id="Marlin_mainCPP-2139"> * G0, G1: Coordinated movement of X Y Z E axes</front>
<front id="Marlin_mainCPP-2140"> */</front>
<front id="Marlin_mainCPP-2141">inline void gcode_G0_G1() {</front>
<front id="Marlin_mainCPP-2142">  if (IsRunning()) {</front>
<front id="Marlin_mainCPP-2143">    gcode_get_destination(); // For X Y Z E F</front>
<front id="Marlin_mainCPP-2144"></front>
<front id="Marlin_mainCPP-2145">    #if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-2146"></front>
<front id="Marlin_mainCPP-2147">      if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {</front>
<front id="Marlin_mainCPP-2148">        float echange = destination[E_AXIS] - current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-2149">        // Is this move an attempt to retract or recover?</front>
<front id="Marlin_mainCPP-2150">        if ((echange &lt; -MIN_RETRACT && !retracted[active_extruder]) || (echange &gt; MIN_RETRACT && retracted[active_extruder])) {</front>
<front id="Marlin_mainCPP-2151">          current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations</front>
<front id="Marlin_mainCPP-2152">          plan_set_e_position(current_position[E_AXIS]);  // AND from the planner</front>
<front id="Marlin_mainCPP-2153">          retract(!retracted[active_extruder]);</front>
<front id="Marlin_mainCPP-2154">          return;</front>
<front id="Marlin_mainCPP-2155">        }</front>
<front id="Marlin_mainCPP-2156">      }</front>
<front id="Marlin_mainCPP-2157"></front>
<front id="Marlin_mainCPP-2158">    #endif //FWRETRACT</front>
<front id="Marlin_mainCPP-2159"></front>
<front id="Marlin_mainCPP-2160">    prepare_move();</front>
<front id="Marlin_mainCPP-2161">  }</front>
<front id="Marlin_mainCPP-2162">}</front>
<front id="Marlin_mainCPP-2163"></front>
<front id="Marlin_mainCPP-2164">/**</front>
<front id="Marlin_mainCPP-2165"> * G2: Clockwise Arc</front>
<front id="Marlin_mainCPP-2166"> * G3: Counterclockwise Arc</front>
<front id="Marlin_mainCPP-2167"> */</front>
<front id="Marlin_mainCPP-2168">inline void gcode_G2_G3(bool clockwise) {</front>
<front id="Marlin_mainCPP-2169">  if (IsRunning()) {</front>
<front id="Marlin_mainCPP-2170"></front>
<front id="Marlin_mainCPP-2171">    #if ENABLED(SF_ARC_FIX)</front>
<front id="Marlin_mainCPP-2172">      bool relative_mode_backup = relative_mode;</front>
<front id="Marlin_mainCPP-2173">      relative_mode = true;</front>
<front id="Marlin_mainCPP-2174">    #endif</front>
<front id="Marlin_mainCPP-2175"></front>
<front id="Marlin_mainCPP-2176">    gcode_get_destination();</front>
<front id="Marlin_mainCPP-2177"></front>
<front id="Marlin_mainCPP-2178">    #if ENABLED(SF_ARC_FIX)</front>
<front id="Marlin_mainCPP-2179">      relative_mode = relative_mode_backup;</front>
<front id="Marlin_mainCPP-2180">    #endif</front>
<front id="Marlin_mainCPP-2181"></front>
<front id="Marlin_mainCPP-2182">    // Center of arc as offset from current_position</front>
<front id="Marlin_mainCPP-2183">    float arc_offset[2] = {</front>
<front id="Marlin_mainCPP-2184">      code_seen('I') ? code_value() : 0,</front>
<front id="Marlin_mainCPP-2185">      code_seen('J') ? code_value() : 0</front>
<front id="Marlin_mainCPP-2186">    };</front>
<front id="Marlin_mainCPP-2187"></front>
<front id="Marlin_mainCPP-2188">    // Send an arc to the planner</front>
<front id="Marlin_mainCPP-2189">    plan_arc(destination, arc_offset, clockwise);</front>
<front id="Marlin_mainCPP-2190"></front>
<front id="Marlin_mainCPP-2191">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-2192">  }</front>
<front id="Marlin_mainCPP-2193">}</front>
<front id="Marlin_mainCPP-2194"></front>
<front id="Marlin_mainCPP-2195">/**</front>
<front id="Marlin_mainCPP-2196"> * G4: Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</front>
<front id="Marlin_mainCPP-2197"> */</front>
<front id="Marlin_mainCPP-2198">inline void gcode_G4() {</front>
<front id="Marlin_mainCPP-2199">  millis_t codenum = 0;</front>
<front id="Marlin_mainCPP-2200"></front>
<front id="Marlin_mainCPP-2201">  if (code_seen('P')) codenum = code_value_long(); // milliseconds to wait</front>
<front id="Marlin_mainCPP-2202">  if (code_seen('S')) codenum = code_value() * 1000; // seconds to wait</front>
<front id="Marlin_mainCPP-2203"></front>
<front id="Marlin_mainCPP-2204">  st_synchronize();</front>
<front id="Marlin_mainCPP-2205">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-2206">  codenum += previous_cmd_ms;  // keep track of when we started waiting</front>
<front id="Marlin_mainCPP-2207"></front>
<front id="Marlin_mainCPP-2208">  if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);</front>
<front id="Marlin_mainCPP-2209"></front>
<front id="Marlin_mainCPP-2210">  while (millis() &lt; codenum) idle();</front>
<front id="Marlin_mainCPP-2211">}</front>
<front id="Marlin_mainCPP-2212"></front>
<front id="Marlin_mainCPP-2213">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-2214"></front>
<front id="Marlin_mainCPP-2215">  /**</front>
<front id="Marlin_mainCPP-2216">   * G10 - Retract filament according to settings of M207</front>
<front id="Marlin_mainCPP-2217">   * G11 - Recover filament according to settings of M208</front>
<front id="Marlin_mainCPP-2218">   */</front>
<front id="Marlin_mainCPP-2219">  inline void gcode_G10_G11(bool doRetract=false) {</front>
<front id="Marlin_mainCPP-2220">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-2221">      if (doRetract) {</front>
<front id="Marlin_mainCPP-2222">        retracted_swap[active_extruder] = (code_seen('S') && code_value_short() == 1); // checks for swap retract argument</front>
<front id="Marlin_mainCPP-2223">      }</front>
<front id="Marlin_mainCPP-2224">    #endif</front>
<front id="Marlin_mainCPP-2225">    retract(doRetract</front>
<front id="Marlin_mainCPP-2226">     #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-2227">      , retracted_swap[active_extruder]</front>
<front id="Marlin_mainCPP-2228">     #endif</front>
<front id="Marlin_mainCPP-2229">    );</front>
<front id="Marlin_mainCPP-2230">  }</front>
<front id="Marlin_mainCPP-2231"></front>
<front id="Marlin_mainCPP-2232">#endif //FWRETRACT</front>
<front id="Marlin_mainCPP-2233"></front>
<front id="Marlin_mainCPP-2234">/**</front>
<front id="Marlin_mainCPP-2235"> * G28: Home all axes according to settings</front>
<front id="Marlin_mainCPP-2236"> *</front>
<front id="Marlin_mainCPP-2237"> * Parameters</front>
<front id="Marlin_mainCPP-2238"> *</front>
<front id="Marlin_mainCPP-2239"> *  None  Home to all axes with no parameters.</front>
<front id="Marlin_mainCPP-2240"> *        With QUICK_HOME enabled XY will home together, then Z.</front>
<front id="Marlin_mainCPP-2241"> *</front>
<front id="Marlin_mainCPP-2242"> * Cartesian parameters</front>
<front id="Marlin_mainCPP-2243"> *</front>
<front id="Marlin_mainCPP-2244"> *  X   Home to the X endstop</front>
<front id="Marlin_mainCPP-2245"> *  Y   Home to the Y endstop</front>
<front id="Marlin_mainCPP-2246"> *  Z   Home to the Z endstop</front>
<front id="Marlin_mainCPP-2247"> *</front>
<front id="Marlin_mainCPP-2248"> */</front>
<front id="Marlin_mainCPP-2249">inline void gcode_G28() {</front>
<front id="Marlin_mainCPP-2250"></front>
<front id="Marlin_mainCPP-2251">  #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-2252">    if (planner_disabled_below_z) return; // Disable homing if resuming print</front>
<front id="Marlin_mainCPP-2253">  #endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-2254"></front>
<front id="Marlin_mainCPP-2255">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2256">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2257">      SERIAL_ECHOLNPGM("gcode_G28 &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-2258">    }</front>
<front id="Marlin_mainCPP-2259">  #endif</front>
<front id="Marlin_mainCPP-2260"></front>
<front id="Marlin_mainCPP-2261">  // Wait for planner moves to finish!</front>
<front id="Marlin_mainCPP-2262">  st_synchronize();</front>
<front id="Marlin_mainCPP-2263"></front>
<front id="Marlin_mainCPP-2264">  // For auto bed leveling, clear the level matrix</front>
<front id="Marlin_mainCPP-2265">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2266">    plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-2267">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2268">      reset_bed_level();</front>
<front id="Marlin_mainCPP-2269">    #endif</front>
<front id="Marlin_mainCPP-2270">  #endif</front>
<front id="Marlin_mainCPP-2271"></front>
<front id="Marlin_mainCPP-2272">  // For manual bed leveling deactivate the matrix temporarily</front>
<front id="Marlin_mainCPP-2273">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-2274">    uint8_t mbl_was_active = mbl.active;</front>
<front id="Marlin_mainCPP-2275">    mbl.active = 0;</front>
<front id="Marlin_mainCPP-2276">  #endif</front>
<front id="Marlin_mainCPP-2277"></front>
<front id="Marlin_mainCPP-2278">  setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-2279"></front>
<front id="Marlin_mainCPP-2280">  set_destination_to_current();</front>
<front id="Marlin_mainCPP-2281"></front>
<front id="Marlin_mainCPP-2282">  feedrate = 0.0;</front>
<front id="Marlin_mainCPP-2283"></front>
<front id="Marlin_mainCPP-2284">  #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2285">    // A delta can only safely home all axis at the same time</front>
<front id="Marlin_mainCPP-2286">    // all axis have to home at the same time</front>
<front id="Marlin_mainCPP-2287"></front>
<front id="Marlin_mainCPP-2288">    // Pretend the current position is 0,0,0</front>
<front id="Marlin_mainCPP-2289">    for (int i = X_AXIS; i &lt;= Z_AXIS; i++) current_position[i] = 0;</front>
<front id="Marlin_mainCPP-2290">    sync_plan_position();</front>
<front id="Marlin_mainCPP-2291"></front>
<front id="Marlin_mainCPP-2292">    // Move all carriages up together until the first endstop is hit.</front>
<front id="Marlin_mainCPP-2293">    for (int i = X_AXIS; i &lt;= Z_AXIS; i++) destination[i] = 3 * Z_MAX_LENGTH;</front>
<front id="Marlin_mainCPP-2294">    feedrate = 1.732 * homing_feedrate[X_AXIS];</front>
<front id="Marlin_mainCPP-2295">    line_to_destination();</front>
<front id="Marlin_mainCPP-2296">    st_synchronize();</front>
<front id="Marlin_mainCPP-2297">    endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2298"></front>
<front id="Marlin_mainCPP-2299">    // Destination reached</front>
<front id="Marlin_mainCPP-2300">    for (int i = X_AXIS; i &lt;= Z_AXIS; i++) current_position[i] = destination[i];</front>
<front id="Marlin_mainCPP-2301"></front>
<front id="Marlin_mainCPP-2302">    // take care of back off and rehome now we are all at the top</front>
<front id="Marlin_mainCPP-2303">    HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2304">    HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-2305">    HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2306"></front>
<front id="Marlin_mainCPP-2307">    sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2308"></front>
<front id="Marlin_mainCPP-2309">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2310">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2311">        print_xyz("(DELTA) &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2312">      }</front>
<front id="Marlin_mainCPP-2313">    #endif</front>
<front id="Marlin_mainCPP-2314"></front>
<front id="Marlin_mainCPP-2315">  #else // NOT DELTA</front>
<front id="Marlin_mainCPP-2316"></front>
<front id="Marlin_mainCPP-2317">    bool  homeX = code_seen(axis_codes[X_AXIS]),</front>
<front id="Marlin_mainCPP-2318">          homeY = code_seen(axis_codes[Y_AXIS]),</front>
<front id="Marlin_mainCPP-2319">          homeZ = code_seen(axis_codes[Z_AXIS]);</front>
<front id="Marlin_mainCPP-2320"></front>
<front id="Marlin_mainCPP-2321">    home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);</front>
<front id="Marlin_mainCPP-2322"></front>
<front id="Marlin_mainCPP-2323">    if (home_all_axis || homeZ) {</front>
<front id="Marlin_mainCPP-2324"></front>
<front id="Marlin_mainCPP-2325">      #if Z_HOME_DIR &gt; 0  // If homing away from BED do Z first</front>
<front id="Marlin_mainCPP-2326"></front>
<front id="Marlin_mainCPP-2327">        HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2328">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2329">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2330">            print_xyz("&gt; HOMEAXIS(Z) &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2331">          }</front>
<front id="Marlin_mainCPP-2332">        #endif</front>
<front id="Marlin_mainCPP-2333"></front>
<front id="Marlin_mainCPP-2334">      #elif DISABLED(Z_SAFE_HOMING) && defined(Z_RAISE_BEFORE_HOMING) && Z_RAISE_BEFORE_HOMING &gt; 0</front>
<front id="Marlin_mainCPP-2335"></front>
<front id="Marlin_mainCPP-2336">        // Raise Z before homing any other axes</front>
<front id="Marlin_mainCPP-2337">        // (Does this need to be "negative home direction?" Why not just use Z_RAISE_BEFORE_HOMING?)</front>
<front id="Marlin_mainCPP-2338">        destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);</front>
<front id="Marlin_mainCPP-2339">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2340">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2341">            SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);</front>
<front id="Marlin_mainCPP-2342">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2343">            print_xyz("&gt; (home_all_axis || homeZ) &gt; destination", destination);</front>
<front id="Marlin_mainCPP-2344">          }</front>
<front id="Marlin_mainCPP-2345">        #endif</front>
<front id="Marlin_mainCPP-2346">        feedrate = max_feedrate[Z_AXIS] * 60;</front>
<front id="Marlin_mainCPP-2347">        line_to_destination();</front>
<front id="Marlin_mainCPP-2348">        st_synchronize();</front>
<front id="Marlin_mainCPP-2349"></front>
<front id="Marlin_mainCPP-2350">      #endif</front>
<front id="Marlin_mainCPP-2351"></front>
<front id="Marlin_mainCPP-2352">    } // home_all_axis || homeZ</front>
<front id="Marlin_mainCPP-2353"></front>
<front id="Marlin_mainCPP-2354">    #if ENABLED(QUICK_HOME)</front>
<front id="Marlin_mainCPP-2355"></front>
<front id="Marlin_mainCPP-2356">      if (home_all_axis || (homeX && homeY)) {  // First diagonal move</front>
<front id="Marlin_mainCPP-2357"></front>
<front id="Marlin_mainCPP-2358">        current_position[X_AXIS] = current_position[Y_AXIS] = 0;</front>
<front id="Marlin_mainCPP-2359"></front>
<front id="Marlin_mainCPP-2360">        #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-2361">          int x_axis_home_dir = x_home_dir(active_extruder);</front>
<front id="Marlin_mainCPP-2362">          extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-2363">        #else</front>
<front id="Marlin_mainCPP-2364">          int x_axis_home_dir = home_dir(X_AXIS);</front>
<front id="Marlin_mainCPP-2365">        #endif</front>
<front id="Marlin_mainCPP-2366"></front>
<front id="Marlin_mainCPP-2367">        sync_plan_position();</front>
<front id="Marlin_mainCPP-2368"></front>
<front id="Marlin_mainCPP-2369">        float mlx = max_length(X_AXIS), mly = max_length(Y_AXIS),</front>
<front id="Marlin_mainCPP-2370">              mlratio = mlx&gt;mly ? mly/mlx : mlx/mly;</front>
<front id="Marlin_mainCPP-2371"></front>
<front id="Marlin_mainCPP-2372">        destination[X_AXIS] = 1.5 * mlx * x_axis_home_dir;</front>
<front id="Marlin_mainCPP-2373">        destination[Y_AXIS] = 1.5 * mly * home_dir(Y_AXIS);</front>
<front id="Marlin_mainCPP-2374">        feedrate = min(homing_feedrate[X_AXIS], homing_feedrate[Y_AXIS]) * sqrt(mlratio * mlratio + 1);</front>
<front id="Marlin_mainCPP-2375">        line_to_destination();</front>
<front id="Marlin_mainCPP-2376">        st_synchronize();</front>
<front id="Marlin_mainCPP-2377"></front>
<front id="Marlin_mainCPP-2378">        set_axis_is_at_home(X_AXIS);</front>
<front id="Marlin_mainCPP-2379">        set_axis_is_at_home(Y_AXIS);</front>
<front id="Marlin_mainCPP-2380">        sync_plan_position();</front>
<front id="Marlin_mainCPP-2381"></front>
<front id="Marlin_mainCPP-2382">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2383">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2384">            print_xyz("&gt; QUICK_HOME &gt; current_position 1", current_position);</front>
<front id="Marlin_mainCPP-2385">          }</front>
<front id="Marlin_mainCPP-2386">        #endif</front>
<front id="Marlin_mainCPP-2387"></front>
<front id="Marlin_mainCPP-2388">        destination[X_AXIS] = current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-2389">        destination[Y_AXIS] = current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-2390">        line_to_destination();</front>
<front id="Marlin_mainCPP-2391">        feedrate = 0.0;</front>
<front id="Marlin_mainCPP-2392">        st_synchronize();</front>
<front id="Marlin_mainCPP-2393">        endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2394"></front>
<front id="Marlin_mainCPP-2395">        current_position[X_AXIS] = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-2396">        current_position[Y_AXIS] = destination[Y_AXIS];</front>
<front id="Marlin_mainCPP-2397">        #if DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-2398">          current_position[Z_AXIS] = destination[Z_AXIS];</front>
<front id="Marlin_mainCPP-2399">        #endif</front>
<front id="Marlin_mainCPP-2400"></front>
<front id="Marlin_mainCPP-2401">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2402">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2403">            print_xyz("&gt; QUICK_HOME &gt; current_position 2", current_position);</front>
<front id="Marlin_mainCPP-2404">          }</front>
<front id="Marlin_mainCPP-2405">        #endif</front>
<front id="Marlin_mainCPP-2406">      }</front>
<front id="Marlin_mainCPP-2407"></front>
<front id="Marlin_mainCPP-2408">    #endif // QUICK_HOME</front>
<front id="Marlin_mainCPP-2409"></front>
<front id="Marlin_mainCPP-2410">    #if ENABLED(HOME_Y_BEFORE_X)</front>
<front id="Marlin_mainCPP-2411">      // Home Y</front>
<front id="Marlin_mainCPP-2412">      if (home_all_axis || homeY) HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-2413">    #endif</front>
<front id="Marlin_mainCPP-2414"></front>
<front id="Marlin_mainCPP-2415">    // Home X</front>
<front id="Marlin_mainCPP-2416">    if (home_all_axis || homeX) {</front>
<front id="Marlin_mainCPP-2417">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-2418">        int tmp_extruder = active_extruder;</front>
<front id="Marlin_mainCPP-2419">        extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-2420">        active_extruder = !active_extruder;</front>
<front id="Marlin_mainCPP-2421">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2422">        inactive_extruder_x_pos = current_position[X_AXIS];</front>
<front id="Marlin_mainCPP-2423">        active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-2424">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2425">        // reset state used by the different modes</front>
<front id="Marlin_mainCPP-2426">        memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));</front>
<front id="Marlin_mainCPP-2427">        delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-2428">        active_extruder_parked = true;</front>
<front id="Marlin_mainCPP-2429">      #else</front>
<front id="Marlin_mainCPP-2430">        HOMEAXIS(X);</front>
<front id="Marlin_mainCPP-2431">      #endif</front>
<front id="Marlin_mainCPP-2432">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2433">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2434">          print_xyz("&gt; homeX", current_position);</front>
<front id="Marlin_mainCPP-2435">        }</front>
<front id="Marlin_mainCPP-2436">      #endif</front>
<front id="Marlin_mainCPP-2437">    }</front>
<front id="Marlin_mainCPP-2438"></front>
<front id="Marlin_mainCPP-2439">    #if DISABLED(HOME_Y_BEFORE_X)</front>
<front id="Marlin_mainCPP-2440">      // Home Y</front>
<front id="Marlin_mainCPP-2441">      if (home_all_axis || homeY) {</front>
<front id="Marlin_mainCPP-2442">        HOMEAXIS(Y);</front>
<front id="Marlin_mainCPP-2443">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2444">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2445">            print_xyz("&gt; homeY", current_position);</front>
<front id="Marlin_mainCPP-2446">          }</front>
<front id="Marlin_mainCPP-2447">        #endif</front>
<front id="Marlin_mainCPP-2448">      }</front>
<front id="Marlin_mainCPP-2449">    #endif</front>
<front id="Marlin_mainCPP-2450"></front>
<front id="Marlin_mainCPP-2451">    // Home Z last if homing towards the bed</front>
<front id="Marlin_mainCPP-2452">    #if Z_HOME_DIR &lt; 0</front>
<front id="Marlin_mainCPP-2453"></front>
<front id="Marlin_mainCPP-2454">      if (home_all_axis || homeZ) {</front>
<front id="Marlin_mainCPP-2455"></front>
<front id="Marlin_mainCPP-2456">        #if ENABLED(Z_SAFE_HOMING)</front>
<front id="Marlin_mainCPP-2457"></front>
<front id="Marlin_mainCPP-2458">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2459">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2460">              SERIAL_ECHOLNPGM("&gt; Z_SAFE_HOMING &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-2461">            }</front>
<front id="Marlin_mainCPP-2462">          #endif</front>
<front id="Marlin_mainCPP-2463"></front>
<front id="Marlin_mainCPP-2464">          if (home_all_axis) {</front>
<front id="Marlin_mainCPP-2465"></front>
<front id="Marlin_mainCPP-2466">            current_position[Z_AXIS] = 0;</front>
<front id="Marlin_mainCPP-2467">            sync_plan_position();</front>
<front id="Marlin_mainCPP-2468"></front>
<front id="Marlin_mainCPP-2469">            //</front>
<front id="Marlin_mainCPP-2470">            // Set the Z probe (or just the nozzle) destination to the safe homing point</front>
<front id="Marlin_mainCPP-2471">            //</front>
<front id="Marlin_mainCPP-2472">            // NOTE: If current_position[X_AXIS] or current_position[Y_AXIS] were set above</front>
<front id="Marlin_mainCPP-2473">            // then this may not work as expected.</front>
<front id="Marlin_mainCPP-2474">            destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-2475">            destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);</front>
<front id="Marlin_mainCPP-2476">            destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);    // Set destination away from bed</front>
<front id="Marlin_mainCPP-2477">            feedrate = XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-2478"></front>
<front id="Marlin_mainCPP-2479">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2480">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2481">                SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);</front>
<front id="Marlin_mainCPP-2482">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2483">                print_xyz("&gt; home_all_axis &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2484">                print_xyz("&gt; home_all_axis &gt; destination", destination);</front>
<front id="Marlin_mainCPP-2485">              }</front>
<front id="Marlin_mainCPP-2486">            #endif</front>
<front id="Marlin_mainCPP-2487"></front>
<front id="Marlin_mainCPP-2488">            // This could potentially move X, Y, Z all together</front>
<front id="Marlin_mainCPP-2489">            line_to_destination();</front>
<front id="Marlin_mainCPP-2490">            st_synchronize();</front>
<front id="Marlin_mainCPP-2491"></front>
<front id="Marlin_mainCPP-2492">            // Set current X, Y is the Z_SAFE_HOMING_POINT minus PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2493">            current_position[X_AXIS] = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-2494">            current_position[Y_AXIS] = destination[Y_AXIS];</front>
<front id="Marlin_mainCPP-2495"></front>
<front id="Marlin_mainCPP-2496">            // Home the Z axis</front>
<front id="Marlin_mainCPP-2497">            HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2498">          }</front>
<front id="Marlin_mainCPP-2499"></front>
<front id="Marlin_mainCPP-2500">          else if (homeZ) { // Don't need to Home Z twice</front>
<front id="Marlin_mainCPP-2501"></front>
<front id="Marlin_mainCPP-2502">            // Let's see if X and Y are homed</front>
<front id="Marlin_mainCPP-2503">            if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-2504"></front>
<front id="Marlin_mainCPP-2505">              // Make sure the Z probe is within the physical limits</front>
<front id="Marlin_mainCPP-2506">              // NOTE: This doesn't necessarily ensure the Z probe is also within the bed!</front>
<front id="Marlin_mainCPP-2507">              float cpx = current_position[X_AXIS], cpy = current_position[Y_AXIS];</front>
<front id="Marlin_mainCPP-2508">              if (   cpx &gt;= X_MIN_POS - X_PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2509">                  && cpx &lt;= X_MAX_POS - X_PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2510">                  && cpy &gt;= Y_MIN_POS - Y_PROBE_OFFSET_FROM_EXTRUDER</front>
<front id="Marlin_mainCPP-2511">                  && cpy &lt;= Y_MAX_POS - Y_PROBE_OFFSET_FROM_EXTRUDER) {</front>
<front id="Marlin_mainCPP-2512">                // Set the plan current position to X, Y, 0</front>
<front id="Marlin_mainCPP-2513">                current_position[Z_AXIS] = 0;</front>
<front id="Marlin_mainCPP-2514">                plan_set_position(cpx, cpy, 0, current_position[E_AXIS]); // = sync_plan_position</front>
<front id="Marlin_mainCPP-2515"></front>
<front id="Marlin_mainCPP-2516">                // Set Z destination away from bed and raise the axis</front>
<front id="Marlin_mainCPP-2517">                // NOTE: This should always just be Z_RAISE_BEFORE_HOMING unless...???</front>
<front id="Marlin_mainCPP-2518">                destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);</front>
<front id="Marlin_mainCPP-2519">                feedrate = max_feedrate[Z_AXIS] * 60;  // feedrate (mm/m) = max_feedrate (mm/s)</front>
<front id="Marlin_mainCPP-2520"></front>
<front id="Marlin_mainCPP-2521">                #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2522">                  if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2523">                    SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);</front>
<front id="Marlin_mainCPP-2524">                    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2525">                    print_xyz("&gt; homeZ &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2526">                    print_xyz("&gt; homeZ &gt; destination", destination);</front>
<front id="Marlin_mainCPP-2527">                  }</front>
<front id="Marlin_mainCPP-2528">                #endif</front>
<front id="Marlin_mainCPP-2529"></front>
<front id="Marlin_mainCPP-2530">                line_to_destination();</front>
<front id="Marlin_mainCPP-2531">                st_synchronize();</front>
<front id="Marlin_mainCPP-2532"></front>
<front id="Marlin_mainCPP-2533">                // Home the Z axis</front>
<front id="Marlin_mainCPP-2534">                HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2535">              }</front>
<front id="Marlin_mainCPP-2536">              else {</front>
<front id="Marlin_mainCPP-2537">                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);</front>
<front id="Marlin_mainCPP-2538">                SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2539">                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);</front>
<front id="Marlin_mainCPP-2540">              }</front>
<front id="Marlin_mainCPP-2541">            }</front>
<front id="Marlin_mainCPP-2542">            else {</front>
<front id="Marlin_mainCPP-2543">              LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2544">              SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2545">              SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2546">            }</front>
<front id="Marlin_mainCPP-2547"></front>
<front id="Marlin_mainCPP-2548">          } // !home_all_axes && homeZ</front>
<front id="Marlin_mainCPP-2549"></front>
<front id="Marlin_mainCPP-2550">          #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2551">            if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2552">              SERIAL_ECHOLNPGM("&lt;&lt;&lt; Z_SAFE_HOMING");</front>
<front id="Marlin_mainCPP-2553">            }</front>
<front id="Marlin_mainCPP-2554">          #endif</front>
<front id="Marlin_mainCPP-2555"></front>
<front id="Marlin_mainCPP-2556">        #else // !Z_SAFE_HOMING</front>
<front id="Marlin_mainCPP-2557"></front>
<front id="Marlin_mainCPP-2558">          HOMEAXIS(Z);</front>
<front id="Marlin_mainCPP-2559"></front>
<front id="Marlin_mainCPP-2560">        #endif // !Z_SAFE_HOMING</front>
<front id="Marlin_mainCPP-2561"></front>
<front id="Marlin_mainCPP-2562">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2563">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2564">            print_xyz("&gt; (home_all_axis || homeZ) &gt; final", current_position);</front>
<front id="Marlin_mainCPP-2565">          }</front>
<front id="Marlin_mainCPP-2566">        #endif</front>
<front id="Marlin_mainCPP-2567"></front>
<front id="Marlin_mainCPP-2568">      } // home_all_axis || homeZ</front>
<front id="Marlin_mainCPP-2569"></front>
<front id="Marlin_mainCPP-2570">    #endif // Z_HOME_DIR &lt; 0</front>
<front id="Marlin_mainCPP-2571"></front>
<front id="Marlin_mainCPP-2572">    sync_plan_position();</front>
<front id="Marlin_mainCPP-2573"></front>
<front id="Marlin_mainCPP-2574">  #endif // else DELTA</front>
<front id="Marlin_mainCPP-2575"></front>
<front id="Marlin_mainCPP-2576">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-2577">    sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-2578">  #endif</front>
<front id="Marlin_mainCPP-2579"></front>
<front id="Marlin_mainCPP-2580">  #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)</front>
<front id="Marlin_mainCPP-2581">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2582">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2583">        SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING enable_endstops(false)");</front>
<front id="Marlin_mainCPP-2584">      }</front>
<front id="Marlin_mainCPP-2585">    #endif</front>
<front id="Marlin_mainCPP-2586">    enable_endstops(false);</front>
<front id="Marlin_mainCPP-2587">  #endif</front>
<front id="Marlin_mainCPP-2588"></front>
<front id="Marlin_mainCPP-2589">  // For manual leveling move back to 0,0</front>
<front id="Marlin_mainCPP-2590">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-2591">    if (mbl_was_active) {</front>
<front id="Marlin_mainCPP-2592">      current_position[X_AXIS] = mbl.get_x(0);</front>
<front id="Marlin_mainCPP-2593">      current_position[Y_AXIS] = mbl.get_y(0);</front>
<front id="Marlin_mainCPP-2594">      set_destination_to_current();</front>
<front id="Marlin_mainCPP-2595">      feedrate = homing_feedrate[X_AXIS];</front>
<front id="Marlin_mainCPP-2596">      line_to_destination();</front>
<front id="Marlin_mainCPP-2597">      st_synchronize();</front>
<front id="Marlin_mainCPP-2598">      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="Marlin_mainCPP-2599">      sync_plan_position();</front>
<front id="Marlin_mainCPP-2600">      mbl.active = 1;</front>
<front id="Marlin_mainCPP-2601">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2602">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2603">          print_xyz("mbl_was_active &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-2604">        }</front>
<front id="Marlin_mainCPP-2605">      #endif</front>
<front id="Marlin_mainCPP-2606">    }</front>
<front id="Marlin_mainCPP-2607">  #endif</front>
<front id="Marlin_mainCPP-2608"></front>
<front id="Marlin_mainCPP-2609">  #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-2610">    current_layer = 0;</front>
<front id="Marlin_mainCPP-2611">    last_layer_z = 0;</front>
<front id="Marlin_mainCPP-2612">  #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-2613">  feedrate = saved_feedrate;</front>
<front id="Marlin_mainCPP-2614">  feedrate_multiplier = saved_feedrate_multiplier;</front>
<front id="Marlin_mainCPP-2615">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-2616">  endstops_hit_on_purpose(); // clear endstop hit flags</front>
<front id="Marlin_mainCPP-2617"></front>
<front id="Marlin_mainCPP-2618">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2619">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2620">      SERIAL_ECHOLNPGM("&lt;&lt;&lt; gcode_G28");</front>
<front id="Marlin_mainCPP-2621">    }</front>
<front id="Marlin_mainCPP-2622">  #endif</front>
<front id="Marlin_mainCPP-2623"></front>
<front id="Marlin_mainCPP-2624">}</front>
<front id="Marlin_mainCPP-2625"></front>
<front id="Marlin_mainCPP-2626">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-2627"></front>
<front id="Marlin_mainCPP-2628">  enum MeshLevelingState { MeshReport, MeshStart, MeshNext, MeshSet };</front>
<front id="Marlin_mainCPP-2629"></front>
<front id="Marlin_mainCPP-2630">  /**</front>
<front id="Marlin_mainCPP-2631">   * G29: Mesh-based Z probe, probes a grid and produces a</front>
<front id="Marlin_mainCPP-2632">   *      mesh to compensate for variable bed height</front>
<front id="Marlin_mainCPP-2633">   *</front>
<front id="Marlin_mainCPP-2634">   * Parameters With MESH_BED_LEVELING:</front>
<front id="Marlin_mainCPP-2635">   *</front>
<front id="Marlin_mainCPP-2636">   *  S0              Produce a mesh report</front>
<front id="Marlin_mainCPP-2637">   *  S1              Start probing mesh points</front>
<front id="Marlin_mainCPP-2638">   *  S2              Probe the next mesh point</front>
<front id="Marlin_mainCPP-2639">   *  S3 Xn Yn Zn.nn  Manually modify a single point</front>
<front id="Marlin_mainCPP-2640">   *</front>
<front id="Marlin_mainCPP-2641">   * The S0 report the points as below</front>
<front id="Marlin_mainCPP-2642">   *</front>
<front id="Marlin_mainCPP-2643">   *  +----&gt; X-axis</front>
<front id="Marlin_mainCPP-2644">   *  |</front>
<front id="Marlin_mainCPP-2645">   *  |</front>
<front id="Marlin_mainCPP-2646">   *  v Y-axis</front>
<front id="Marlin_mainCPP-2647">   *</front>
<front id="Marlin_mainCPP-2648">   */</front>
<front id="Marlin_mainCPP-2649">  inline void gcode_G29() {</front>
<front id="Marlin_mainCPP-2650"></front>
<front id="Marlin_mainCPP-2651">    #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-2652">      if (planner_disabled_below_z) return; // Disable probing if resuming print</front>
<front id="Marlin_mainCPP-2653">    #endif</front>
<front id="Marlin_mainCPP-2654">    static int probe_point = -1;</front>
<front id="Marlin_mainCPP-2655">    MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_short() : MeshReport;</front>
<front id="Marlin_mainCPP-2656">    if (state &lt; 0 || state &gt; 3) {</front>
<front id="Marlin_mainCPP-2657">      SERIAL_PROTOCOLLNPGM("S out of range (0-3).");</front>
<front id="Marlin_mainCPP-2658">      return;</front>
<front id="Marlin_mainCPP-2659">    }</front>
<front id="Marlin_mainCPP-2660"></front>
<front id="Marlin_mainCPP-2661">    int ix, iy;</front>
<front id="Marlin_mainCPP-2662">    float z;</front>
<front id="Marlin_mainCPP-2663"></front>
<front id="Marlin_mainCPP-2664">    switch(state) {</front>
<front id="Marlin_mainCPP-2665">      case MeshReport:</front>
<front id="Marlin_mainCPP-2666">        if (mbl.active) {</front>
<front id="Marlin_mainCPP-2667">          SERIAL_PROTOCOLPGM("Num X,Y: ");</front>
<front id="Marlin_mainCPP-2668">          SERIAL_PROTOCOL(MESH_NUM_X_POINTS);</front>
<front id="Marlin_mainCPP-2669">          SERIAL_PROTOCOLCHAR(',');</front>
<front id="Marlin_mainCPP-2670">          SERIAL_PROTOCOL(MESH_NUM_Y_POINTS);</front>
<front id="Marlin_mainCPP-2671">          SERIAL_PROTOCOLPGM("\nZ search height: ");</front>
<front id="Marlin_mainCPP-2672">          SERIAL_PROTOCOL(MESH_HOME_SEARCH_Z);</front>
<front id="Marlin_mainCPP-2673">          SERIAL_PROTOCOLLNPGM("\nMeasured points:");</front>
<front id="Marlin_mainCPP-2674">          for (int y = 0; y &lt; MESH_NUM_Y_POINTS; y++) {</front>
<front id="Marlin_mainCPP-2675">            for (int x = 0; x &lt; MESH_NUM_X_POINTS; x++) {</front>
<front id="Marlin_mainCPP-2676">              SERIAL_PROTOCOLPGM("  ");</front>
<front id="Marlin_mainCPP-2677">              SERIAL_PROTOCOL_F(mbl.z_values[y][x], 5);</front>
<front id="Marlin_mainCPP-2678">            }</front>
<front id="Marlin_mainCPP-2679">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2680">          }</front>
<front id="Marlin_mainCPP-2681">        }</front>
<front id="Marlin_mainCPP-2682">        else</front>
<front id="Marlin_mainCPP-2683">          SERIAL_PROTOCOLLNPGM("Mesh bed leveling not active.");</front>
<front id="Marlin_mainCPP-2684">        break;</front>
<front id="Marlin_mainCPP-2685"></front>
<front id="Marlin_mainCPP-2686">      case MeshStart:</front>
<front id="Marlin_mainCPP-2687">        mbl.reset();</front>
<front id="Marlin_mainCPP-2688">        probe_point = 0;</front>
<front id="Marlin_mainCPP-2689">        enqueuecommands_P(PSTR("G28\nG29 S2"));</front>
<front id="Marlin_mainCPP-2690">        break;</front>
<front id="Marlin_mainCPP-2691"></front>
<front id="Marlin_mainCPP-2692">      case MeshNext:</front>
<front id="Marlin_mainCPP-2693">        if (probe_point &lt; 0) {</front>
<front id="Marlin_mainCPP-2694">          SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");</front>
<front id="Marlin_mainCPP-2695">          return;</front>
<front id="Marlin_mainCPP-2696">        }</front>
<front id="Marlin_mainCPP-2697">        if (probe_point == 0) {</front>
<front id="Marlin_mainCPP-2698">          // Set Z to a positive value before recording the first Z.</front>
<front id="Marlin_mainCPP-2699">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="Marlin_mainCPP-2700">          sync_plan_position();</front>
<front id="Marlin_mainCPP-2701">        }</front>
<front id="Marlin_mainCPP-2702">        else {</front>
<front id="Marlin_mainCPP-2703">          // For others, save the Z of the previous point, then raise Z again.</front>
<front id="Marlin_mainCPP-2704">          ix = (probe_point - 1) % MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2705">          iy = (probe_point - 1) / MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2706">          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag</front>
<front id="Marlin_mainCPP-2707">          mbl.set_z(ix, iy, current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-2708">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="Marlin_mainCPP-2709">          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);</front>
<front id="Marlin_mainCPP-2710">          st_synchronize();</front>
<front id="Marlin_mainCPP-2711">        }</front>
<front id="Marlin_mainCPP-2712">        // Is there another point to sample? Move there.</front>
<front id="Marlin_mainCPP-2713">        if (probe_point &lt; MESH_NUM_X_POINTS * MESH_NUM_Y_POINTS) {</front>
<front id="Marlin_mainCPP-2714">          ix = probe_point % MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2715">          iy = probe_point / MESH_NUM_X_POINTS;</front>
<front id="Marlin_mainCPP-2716">          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag</front>
<front id="Marlin_mainCPP-2717">          current_position[X_AXIS] = mbl.get_x(ix);</front>
<front id="Marlin_mainCPP-2718">          current_position[Y_AXIS] = mbl.get_y(iy);</front>
<front id="Marlin_mainCPP-2719">          plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS]/60, active_extruder);</front>
<front id="Marlin_mainCPP-2720">          st_synchronize();</front>
<front id="Marlin_mainCPP-2721">          probe_point++;</front>
<front id="Marlin_mainCPP-2722">        }</front>
<front id="Marlin_mainCPP-2723">        else {</front>
<front id="Marlin_mainCPP-2724">          // After recording the last point, activate the mbl and home</front>
<front id="Marlin_mainCPP-2725">          SERIAL_PROTOCOLLNPGM("Mesh probing done.");</front>
<front id="Marlin_mainCPP-2726">          probe_point = -1;</front>
<front id="Marlin_mainCPP-2727">          mbl.active = 1;</front>
<front id="Marlin_mainCPP-2728">          enqueuecommands_P(PSTR("G28"));</front>
<front id="Marlin_mainCPP-2729">        }</front>
<front id="Marlin_mainCPP-2730">        break;</front>
<front id="Marlin_mainCPP-2731"></front>
<front id="Marlin_mainCPP-2732">      case MeshSet:</front>
<front id="Marlin_mainCPP-2733">        if (code_seen('X')) {</front>
<front id="Marlin_mainCPP-2734">          ix = code_value_long()-1;</front>
<front id="Marlin_mainCPP-2735">          if (ix &lt; 0 || ix &gt;= MESH_NUM_X_POINTS) {</front>
<front id="Marlin_mainCPP-2736">            SERIAL_PROTOCOLPGM("X out of range (1-" STRINGIFY(MESH_NUM_X_POINTS) ").\n");</front>
<front id="Marlin_mainCPP-2737">            return;</front>
<front id="Marlin_mainCPP-2738">          }</front>
<front id="Marlin_mainCPP-2739">        } else {</front>
<front id="Marlin_mainCPP-2740">            SERIAL_PROTOCOLPGM("X not entered.\n");</front>
<front id="Marlin_mainCPP-2741">            return;</front>
<front id="Marlin_mainCPP-2742">        }</front>
<front id="Marlin_mainCPP-2743">        if (code_seen('Y')) {</front>
<front id="Marlin_mainCPP-2744">          iy = code_value_long()-1;</front>
<front id="Marlin_mainCPP-2745">          if (iy &lt; 0 || iy &gt;= MESH_NUM_Y_POINTS) {</front>
<front id="Marlin_mainCPP-2746">            SERIAL_PROTOCOLPGM("Y out of range (1-" STRINGIFY(MESH_NUM_Y_POINTS) ").\n");</front>
<front id="Marlin_mainCPP-2747">            return;</front>
<front id="Marlin_mainCPP-2748">          }</front>
<front id="Marlin_mainCPP-2749">        } else {</front>
<front id="Marlin_mainCPP-2750">            SERIAL_PROTOCOLPGM("Y not entered.\n");</front>
<front id="Marlin_mainCPP-2751">            return;</front>
<front id="Marlin_mainCPP-2752">        }</front>
<front id="Marlin_mainCPP-2753">        if (code_seen('Z')) {</front>
<front id="Marlin_mainCPP-2754">          z = code_value();</front>
<front id="Marlin_mainCPP-2755">        } else {</front>
<front id="Marlin_mainCPP-2756">          SERIAL_PROTOCOLPGM("Z not entered.\n");</front>
<front id="Marlin_mainCPP-2757">          return;</front>
<front id="Marlin_mainCPP-2758">        }</front>
<front id="Marlin_mainCPP-2759">        mbl.z_values[iy][ix] = z;</front>
<front id="Marlin_mainCPP-2760"></front>
<front id="Marlin_mainCPP-2761">    } // switch(state)</front>
<front id="Marlin_mainCPP-2762">    #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-2763">      current_layer = 0;</front>
<front id="Marlin_mainCPP-2764">      last_layer_z = 0;</front>
<front id="Marlin_mainCPP-2765">    #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-2766">  }</front>
<front id="Marlin_mainCPP-2767"></front>
<front id="Marlin_mainCPP-2768">#elif ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2769"></front>
<front id="Marlin_mainCPP-2770">  void out_of_range_error(const char *p_edge) {</front>
<front id="Marlin_mainCPP-2771">    SERIAL_PROTOCOLPGM("?Probe ");</front>
<front id="Marlin_mainCPP-2772">    serialprintPGM(p_edge);</front>
<front id="Marlin_mainCPP-2773">    SERIAL_PROTOCOLLNPGM(" position out of range.");</front>
<front id="Marlin_mainCPP-2774">  }</front>
<front id="Marlin_mainCPP-2775"></front>
<front id="Marlin_mainCPP-2776">  /**</front>
<front id="Marlin_mainCPP-2777">   * G29: Detailed Z probe, probes the bed at 3 or more points.</front>
<front id="Marlin_mainCPP-2778">   *      Will fail if the printer has not been homed with G28.</front>
<front id="Marlin_mainCPP-2779">   *</front>
<front id="Marlin_mainCPP-2780">   * Enhanced G29 Auto Bed Leveling Probe Routine</front>
<front id="Marlin_mainCPP-2781">   *</front>
<front id="Marlin_mainCPP-2782">   * Parameters With AUTO_BED_LEVELING_GRID:</front>
<front id="Marlin_mainCPP-2783">   *</front>
<front id="Marlin_mainCPP-2784">   *  P  Set the size of the grid that will be probed (P x P points).</front>
<front id="Marlin_mainCPP-2785">   *     Not supported by non-linear delta printer bed leveling.</front>
<front id="Marlin_mainCPP-2786">   *     Example: "G29 P4"</front>
<front id="Marlin_mainCPP-2787">   *</front>
<front id="Marlin_mainCPP-2788">   *  S  Set the XY travel speed between probe points (in mm/min)</front>
<front id="Marlin_mainCPP-2789">   *</front>
<front id="Marlin_mainCPP-2790">   *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply</front>
<front id="Marlin_mainCPP-2791">   *     or clean the rotation Matrix. Useful to check the topology</front>
<front id="Marlin_mainCPP-2792">   *     after a first run of G29.</front>
<front id="Marlin_mainCPP-2793">   *</front>
<front id="Marlin_mainCPP-2794">   *  V  Set the verbose level (0-4). Example: "G29 V3"</front>
<front id="Marlin_mainCPP-2795">   *</front>
<front id="Marlin_mainCPP-2796">   *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.</front>
<front id="Marlin_mainCPP-2797">   *     This is useful for manual bed leveling and finding flaws in the bed (to</front>
<front id="Marlin_mainCPP-2798">   *     assist with part placement).</front>
<front id="Marlin_mainCPP-2799">   *     Not supported by non-linear delta printer bed leveling.</front>
<front id="Marlin_mainCPP-2800">   *</front>
<front id="Marlin_mainCPP-2801">   *  F  Set the Front limit of the probing grid</front>
<front id="Marlin_mainCPP-2802">   *  B  Set the Back limit of the probing grid</front>
<front id="Marlin_mainCPP-2803">   *  L  Set the Left limit of the probing grid</front>
<front id="Marlin_mainCPP-2804">   *  R  Set the Right limit of the probing grid</front>
<front id="Marlin_mainCPP-2805">   *</front>
<front id="Marlin_mainCPP-2806">   * Global Parameters:</front>
<front id="Marlin_mainCPP-2807">   *</front>
<front id="Marlin_mainCPP-2808">   * E/e By default G29 will engage the Z probe, test the bed, then disengage.</front>
<front id="Marlin_mainCPP-2809">   *     Include "E" to engage/disengage the Z probe for each sample.</front>
<front id="Marlin_mainCPP-2810">   *     There's no extra effect if you have a fixed Z probe.</front>
<front id="Marlin_mainCPP-2811">   *     Usage: "G29 E" or "G29 e"</front>
<front id="Marlin_mainCPP-2812">   *</front>
<front id="Marlin_mainCPP-2813">   */</front>
<front id="Marlin_mainCPP-2814">  inline void gcode_G29() {</front>
<front id="Marlin_mainCPP-2815"></front>
<front id="Marlin_mainCPP-2816">    #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-2817">      if (planner_disabled_below_z) return; // Disable probing if resuming print</front>
<front id="Marlin_mainCPP-2818">    #endif</front>
<front id="Marlin_mainCPP-2819"></front>
<front id="Marlin_mainCPP-2820">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2821">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2822">        SERIAL_ECHOLNPGM("gcode_G29 &gt;&gt;&gt;");</front>
<front id="Marlin_mainCPP-2823">      }</front>
<front id="Marlin_mainCPP-2824">    #endif</front>
<front id="Marlin_mainCPP-2825"></front>
<front id="Marlin_mainCPP-2826">    // Don't allow auto-leveling without homing first</front>
<front id="Marlin_mainCPP-2827">    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-2828">      LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2829">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-2830">      SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);</front>
<front id="Marlin_mainCPP-2831">      return;</front>
<front id="Marlin_mainCPP-2832">    }</front>
<front id="Marlin_mainCPP-2833"></front>
<front id="Marlin_mainCPP-2834">    int verbose_level = code_seen('V') ? code_value_short() : 1;</front>
<front id="Marlin_mainCPP-2835">    if (verbose_level &lt; 0 || verbose_level &gt; 4) {</front>
<front id="Marlin_mainCPP-2836">      SERIAL_ECHOLNPGM("?(V)erbose Level is implausible (0-4).");</front>
<front id="Marlin_mainCPP-2837">      return;</front>
<front id="Marlin_mainCPP-2838">    }</front>
<front id="Marlin_mainCPP-2839"></front>
<front id="Marlin_mainCPP-2840">    bool dryrun = code_seen('D'),</front>
<front id="Marlin_mainCPP-2841">         deploy_probe_for_each_reading = code_seen('E');</front>
<front id="Marlin_mainCPP-2842"></front>
<front id="Marlin_mainCPP-2843">    #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-2844"></front>
<front id="Marlin_mainCPP-2845">      #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-2846">        bool do_topography_map = verbose_level &gt; 2 || code_seen('T');</front>
<front id="Marlin_mainCPP-2847">      #endif</front>
<front id="Marlin_mainCPP-2848"></front>
<front id="Marlin_mainCPP-2849">      if (verbose_level &gt; 0) {</front>
<front id="Marlin_mainCPP-2850">        SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling\n");</front>
<front id="Marlin_mainCPP-2851">        if (dryrun) SERIAL_ECHOLNPGM("Running in DRY-RUN mode");</front>
<front id="Marlin_mainCPP-2852">      }</front>
<front id="Marlin_mainCPP-2853"></front>
<front id="Marlin_mainCPP-2854">      int auto_bed_leveling_grid_points = AUTO_BED_LEVELING_GRID_POINTS;</front>
<front id="Marlin_mainCPP-2855">      #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-2856">        if (code_seen('P')) auto_bed_leveling_grid_points = code_value_short();</front>
<front id="Marlin_mainCPP-2857">        if (auto_bed_leveling_grid_points &lt; 2) {</front>
<front id="Marlin_mainCPP-2858">          SERIAL_PROTOCOLPGM("?Number of probed (P)oints is implausible (2 minimum).\n");</front>
<front id="Marlin_mainCPP-2859">          return;</front>
<front id="Marlin_mainCPP-2860">        }</front>
<front id="Marlin_mainCPP-2861">      #endif</front>
<front id="Marlin_mainCPP-2862"></front>
<front id="Marlin_mainCPP-2863">      xy_travel_speed = code_seen('S') ? code_value_short() : XY_TRAVEL_SPEED;</front>
<front id="Marlin_mainCPP-2864"></front>
<front id="Marlin_mainCPP-2865">      int left_probe_bed_position = code_seen('L') ? code_value_short() : LEFT_PROBE_BED_POSITION,</front>
<front id="Marlin_mainCPP-2866">          right_probe_bed_position = code_seen('R') ? code_value_short() : RIGHT_PROBE_BED_POSITION,</front>
<front id="Marlin_mainCPP-2867">          front_probe_bed_position = code_seen('F') ? code_value_short() : FRONT_PROBE_BED_POSITION,</front>
<front id="Marlin_mainCPP-2868">          back_probe_bed_position = code_seen('B') ? code_value_short() : BACK_PROBE_BED_POSITION;</front>
<front id="Marlin_mainCPP-2869"></front>
<front id="Marlin_mainCPP-2870">      bool left_out_l = left_probe_bed_position &lt; MIN_PROBE_X,</front>
<front id="Marlin_mainCPP-2871">           left_out = left_out_l || left_probe_bed_position &gt; right_probe_bed_position - MIN_PROBE_EDGE,</front>
<front id="Marlin_mainCPP-2872">           right_out_r = right_probe_bed_position &gt; MAX_PROBE_X,</front>
<front id="Marlin_mainCPP-2873">           right_out = right_out_r || right_probe_bed_position &lt; left_probe_bed_position + MIN_PROBE_EDGE,</front>
<front id="Marlin_mainCPP-2874">           front_out_f = front_probe_bed_position &lt; MIN_PROBE_Y,</front>
<front id="Marlin_mainCPP-2875">           front_out = front_out_f || front_probe_bed_position &gt; back_probe_bed_position - MIN_PROBE_EDGE,</front>
<front id="Marlin_mainCPP-2876">           back_out_b = back_probe_bed_position &gt; MAX_PROBE_Y,</front>
<front id="Marlin_mainCPP-2877">           back_out = back_out_b || back_probe_bed_position &lt; front_probe_bed_position + MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2878"></front>
<front id="Marlin_mainCPP-2879">      if (left_out || right_out || front_out || back_out) {</front>
<front id="Marlin_mainCPP-2880">        if (left_out) {</front>
<front id="Marlin_mainCPP-2881">          out_of_range_error(PSTR("(L)eft"));</front>
<front id="Marlin_mainCPP-2882">          left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2883">        }</front>
<front id="Marlin_mainCPP-2884">        if (right_out) {</front>
<front id="Marlin_mainCPP-2885">          out_of_range_error(PSTR("(R)ight"));</front>
<front id="Marlin_mainCPP-2886">          right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2887">        }</front>
<front id="Marlin_mainCPP-2888">        if (front_out) {</front>
<front id="Marlin_mainCPP-2889">          out_of_range_error(PSTR("(F)ront"));</front>
<front id="Marlin_mainCPP-2890">          front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2891">        }</front>
<front id="Marlin_mainCPP-2892">        if (back_out) {</front>
<front id="Marlin_mainCPP-2893">          out_of_range_error(PSTR("(B)ack"));</front>
<front id="Marlin_mainCPP-2894">          back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;</front>
<front id="Marlin_mainCPP-2895">        }</front>
<front id="Marlin_mainCPP-2896">        return;</front>
<front id="Marlin_mainCPP-2897">      }</front>
<front id="Marlin_mainCPP-2898"></front>
<front id="Marlin_mainCPP-2899">    #endif // AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-2900"></front>
<front id="Marlin_mainCPP-2901">    #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-2902">      dock_sled(false); // engage (un-dock) the Z probe</front>
<front id="Marlin_mainCPP-2903">    #elif ENABLED(Z_PROBE_ALLEN_KEY) //|| SERVO_LEVELING</front>
<front id="Marlin_mainCPP-2904">      deploy_z_probe();</front>
<front id="Marlin_mainCPP-2905">    #endif</front>
<front id="Marlin_mainCPP-2906"></front>
<front id="Marlin_mainCPP-2907">    st_synchronize();</front>
<front id="Marlin_mainCPP-2908"></front>
<front id="Marlin_mainCPP-2909">    if (!dryrun) {</front>
<front id="Marlin_mainCPP-2910">      // make sure the bed_level_rotation_matrix is identity or the planner will get it wrong</front>
<front id="Marlin_mainCPP-2911">      plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-2912"></front>
<front id="Marlin_mainCPP-2913">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2914">        reset_bed_level();</front>
<front id="Marlin_mainCPP-2915">      #else //!DELTA</front>
<front id="Marlin_mainCPP-2916">        //vector_3 corrected_position = plan_get_position_mm();</front>
<front id="Marlin_mainCPP-2917">        //corrected_position.debug("position before G29");</front>
<front id="Marlin_mainCPP-2918">        vector_3 uncorrected_position = plan_get_position();</front>
<front id="Marlin_mainCPP-2919">        //uncorrected_position.debug("position during G29");</front>
<front id="Marlin_mainCPP-2920">        current_position[X_AXIS] = uncorrected_position.x;</front>
<front id="Marlin_mainCPP-2921">        current_position[Y_AXIS] = uncorrected_position.y;</front>
<front id="Marlin_mainCPP-2922">        current_position[Z_AXIS] = uncorrected_position.z;</front>
<front id="Marlin_mainCPP-2923">        sync_plan_position();</front>
<front id="Marlin_mainCPP-2924">      #endif // !DELTA</front>
<front id="Marlin_mainCPP-2925">    }</front>
<front id="Marlin_mainCPP-2926"></front>
<front id="Marlin_mainCPP-2927">    setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-2928"></front>
<front id="Marlin_mainCPP-2929">    feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-2930"></front>
<front id="Marlin_mainCPP-2931">    #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="Marlin_mainCPP-2932"></front>
<front id="Marlin_mainCPP-2933">      // probe at the points of a lattice grid</front>
<front id="Marlin_mainCPP-2934">      const int xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (auto_bed_leveling_grid_points - 1),</front>
<front id="Marlin_mainCPP-2935">                yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (auto_bed_leveling_grid_points - 1);</front>
<front id="Marlin_mainCPP-2936"></front>
<front id="Marlin_mainCPP-2937">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-2938">        delta_grid_spacing[0] = xGridSpacing;</front>
<front id="Marlin_mainCPP-2939">        delta_grid_spacing[1] = yGridSpacing;</front>
<front id="Marlin_mainCPP-2940">        float z_offset = zprobe_zoffset;</front>
<front id="Marlin_mainCPP-2941">        if (code_seen(axis_codes[Z_AXIS])) z_offset += code_value();</front>
<front id="Marlin_mainCPP-2942">      #else // !DELTA</front>
<front id="Marlin_mainCPP-2943">        // solve the plane equation ax + by + d = z</front>
<front id="Marlin_mainCPP-2944">        // A is the matrix with rows [x y 1] for all the probed points</front>
<front id="Marlin_mainCPP-2945">        // B is the vector of the Z positions</front>
<front id="Marlin_mainCPP-2946">        // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0</front>
<front id="Marlin_mainCPP-2947">        // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z</front>
<front id="Marlin_mainCPP-2948"></front>
<front id="Marlin_mainCPP-2949">        int abl2 = auto_bed_leveling_grid_points * auto_bed_leveling_grid_points;</front>
<front id="Marlin_mainCPP-2950"></front>
<front id="Marlin_mainCPP-2951">        double eqnAMatrix[abl2 * 3], // "A" matrix of the linear system of equations</front>
<front id="Marlin_mainCPP-2952">               eqnBVector[abl2],     // "B" vector of Z points</front>
<front id="Marlin_mainCPP-2953">               mean = 0.0;</front>
<front id="Marlin_mainCPP-2954">        int8_t indexIntoAB[auto_bed_leveling_grid_points][auto_bed_leveling_grid_points];</front>
<front id="Marlin_mainCPP-2955">      #endif // !DELTA</front>
<front id="Marlin_mainCPP-2956"></front>
<front id="Marlin_mainCPP-2957">      int probePointCounter = 0;</front>
<front id="Marlin_mainCPP-2958">      bool zig = (auto_bed_leveling_grid_points & 1) ? true : false; //always end at [RIGHT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION]</front>
<front id="Marlin_mainCPP-2959"></front>
<front id="Marlin_mainCPP-2960">      for (int yCount = 0; yCount &lt; auto_bed_leveling_grid_points; yCount++) {</front>
<front id="Marlin_mainCPP-2961">        double yProbe = front_probe_bed_position + yGridSpacing * yCount;</front>
<front id="Marlin_mainCPP-2962">        int xStart, xStop, xInc;</front>
<front id="Marlin_mainCPP-2963"></front>
<front id="Marlin_mainCPP-2964">        if (zig) {</front>
<front id="Marlin_mainCPP-2965">          xStart = 0;</front>
<front id="Marlin_mainCPP-2966">          xStop = auto_bed_leveling_grid_points;</front>
<front id="Marlin_mainCPP-2967">          xInc = 1;</front>
<front id="Marlin_mainCPP-2968">        }</front>
<front id="Marlin_mainCPP-2969">        else {</front>
<front id="Marlin_mainCPP-2970">          xStart = auto_bed_leveling_grid_points - 1;</front>
<front id="Marlin_mainCPP-2971">          xStop = -1;</front>
<front id="Marlin_mainCPP-2972">          xInc = -1;</front>
<front id="Marlin_mainCPP-2973">        }</front>
<front id="Marlin_mainCPP-2974"></front>
<front id="Marlin_mainCPP-2975">        zig = !zig;</front>
<front id="Marlin_mainCPP-2976"></front>
<front id="Marlin_mainCPP-2977">        for (int xCount = xStart; xCount != xStop; xCount += xInc) {</front>
<front id="Marlin_mainCPP-2978">          double xProbe = left_probe_bed_position + xGridSpacing * xCount;</front>
<front id="Marlin_mainCPP-2979"></front>
<front id="Marlin_mainCPP-2980">          // raise extruder</front>
<front id="Marlin_mainCPP-2981">          float measured_z,</front>
<front id="Marlin_mainCPP-2982">                z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-2983"></front>
<front id="Marlin_mainCPP-2984">          if (probePointCounter) {</front>
<front id="Marlin_mainCPP-2985">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2986">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2987">                SERIAL_ECHOPAIR("z_before = (between) ", (float)(Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS]));</front>
<front id="Marlin_mainCPP-2988">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2989">              }</front>
<front id="Marlin_mainCPP-2990">            #endif</front>
<front id="Marlin_mainCPP-2991">          }</front>
<front id="Marlin_mainCPP-2992">          else {</front>
<front id="Marlin_mainCPP-2993">            #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-2994">              if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-2995">                SERIAL_ECHOPAIR("z_before = (before) ", (float)Z_RAISE_BEFORE_PROBING);</front>
<front id="Marlin_mainCPP-2996">                SERIAL_EOL;</front>
<front id="Marlin_mainCPP-2997">              }</front>
<front id="Marlin_mainCPP-2998">            #endif</front>
<front id="Marlin_mainCPP-2999">          }</front>
<front id="Marlin_mainCPP-3000"></front>
<front id="Marlin_mainCPP-3001">          #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-3002">            // Avoid probing the corners (outside the round or hexagon print surface) on a delta printer.</front>
<front id="Marlin_mainCPP-3003">            float distance_from_center = sqrt(xProbe*xProbe + yProbe*yProbe);</front>
<front id="Marlin_mainCPP-3004">            if (distance_from_center &gt; DELTA_PROBABLE_RADIUS) continue;</front>
<front id="Marlin_mainCPP-3005">          #endif //DELTA</front>
<front id="Marlin_mainCPP-3006"></front>
<front id="Marlin_mainCPP-3007">          ProbeAction act;</front>
<front id="Marlin_mainCPP-3008">          if (deploy_probe_for_each_reading) // G29 E - Stow between probes</front>
<front id="Marlin_mainCPP-3009">            act = ProbeDeployAndStow;</front>
<front id="Marlin_mainCPP-3010">          else if (yCount == 0 && xCount == xStart)</front>
<front id="Marlin_mainCPP-3011">            act = ProbeDeploy;</front>
<front id="Marlin_mainCPP-3012">          else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)</front>
<front id="Marlin_mainCPP-3013">            act = ProbeStow;</front>
<front id="Marlin_mainCPP-3014">          else</front>
<front id="Marlin_mainCPP-3015">            act = ProbeStay;</front>
<front id="Marlin_mainCPP-3016"></front>
<front id="Marlin_mainCPP-3017">          measured_z = probe_pt(xProbe, yProbe, z_before, act, verbose_level);</front>
<front id="Marlin_mainCPP-3018"></front>
<front id="Marlin_mainCPP-3019">          #if DISABLED(DELTA)</front>
<front id="Marlin_mainCPP-3020">            mean += measured_z;</front>
<front id="Marlin_mainCPP-3021"></front>
<front id="Marlin_mainCPP-3022">            eqnBVector[probePointCounter] = measured_z;</front>
<front id="Marlin_mainCPP-3023">            eqnAMatrix[probePointCounter + 0 * abl2] = xProbe;</front>
<front id="Marlin_mainCPP-3024">            eqnAMatrix[probePointCounter + 1 * abl2] = yProbe;</front>
<front id="Marlin_mainCPP-3025">            eqnAMatrix[probePointCounter + 2 * abl2] = 1;</front>
<front id="Marlin_mainCPP-3026">            indexIntoAB[xCount][yCount] = probePointCounter;</front>
<front id="Marlin_mainCPP-3027">          #else</front>
<front id="Marlin_mainCPP-3028">            bed_level[xCount][yCount] = measured_z + z_offset;</front>
<front id="Marlin_mainCPP-3029">          #endif</front>
<front id="Marlin_mainCPP-3030"></front>
<front id="Marlin_mainCPP-3031">          probePointCounter++;</front>
<front id="Marlin_mainCPP-3032">  </front>
<front id="Marlin_mainCPP-3033">          idle();</front>
<front id="Marlin_mainCPP-3034"></front>
<front id="Marlin_mainCPP-3035">        } //xProbe</front>
<front id="Marlin_mainCPP-3036">      } //yProbe</front>
<front id="Marlin_mainCPP-3037"></front>
<front id="Marlin_mainCPP-3038">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3039">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3040">          print_xyz("&gt; probing complete &gt; current_position", current_position);</front>
<front id="Marlin_mainCPP-3041">        }</front>
<front id="Marlin_mainCPP-3042">      #endif</front>
<front id="Marlin_mainCPP-3043"></front>
<front id="Marlin_mainCPP-3044">      clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3045"></front>
<front id="Marlin_mainCPP-3046">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-3047"></front>
<front id="Marlin_mainCPP-3048">        if (!dryrun) extrapolate_unprobed_bed_level();</front>
<front id="Marlin_mainCPP-3049">        print_bed_level();</front>
<front id="Marlin_mainCPP-3050"></front>
<front id="Marlin_mainCPP-3051">      #else // !DELTA</front>
<front id="Marlin_mainCPP-3052"></front>
<front id="Marlin_mainCPP-3053">        // solve lsq problem</front>
<front id="Marlin_mainCPP-3054">        double plane_equation_coefficients[3];</front>
<front id="Marlin_mainCPP-3055">        qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);</front>
<front id="Marlin_mainCPP-3056"></front>
<front id="Marlin_mainCPP-3057">        mean /= abl2;</front>
<front id="Marlin_mainCPP-3058"></front>
<front id="Marlin_mainCPP-3059">        if (verbose_level) {</front>
<front id="Marlin_mainCPP-3060">          SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");</front>
<front id="Marlin_mainCPP-3061">          SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);</front>
<front id="Marlin_mainCPP-3062">          SERIAL_PROTOCOLPGM(" b: ");</front>
<front id="Marlin_mainCPP-3063">          SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);</front>
<front id="Marlin_mainCPP-3064">          SERIAL_PROTOCOLPGM(" d: ");</front>
<front id="Marlin_mainCPP-3065">          SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);</front>
<front id="Marlin_mainCPP-3066">          SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3067">          if (verbose_level &gt; 2) {</front>
<front id="Marlin_mainCPP-3068">            SERIAL_PROTOCOLPGM("Mean of sampled points: ");</front>
<front id="Marlin_mainCPP-3069">            SERIAL_PROTOCOL_F(mean, 8);</front>
<front id="Marlin_mainCPP-3070">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3071">          }</front>
<front id="Marlin_mainCPP-3072">        }</front>
<front id="Marlin_mainCPP-3073"></front>
<front id="Marlin_mainCPP-3074">        if (!dryrun) set_bed_level_equation_lsq(plane_equation_coefficients);</front>
<front id="Marlin_mainCPP-3075"></front>
<front id="Marlin_mainCPP-3076">        // Show the Topography map if enabled</front>
<front id="Marlin_mainCPP-3077">        if (do_topography_map) {</front>
<front id="Marlin_mainCPP-3078"></front>
<front id="Marlin_mainCPP-3079">          SERIAL_PROTOCOLPGM(" \nBed Height Topography: \n");</front>
<front id="Marlin_mainCPP-3080">          SERIAL_PROTOCOLPGM("+-----------+\n");</front>
<front id="Marlin_mainCPP-3081">          SERIAL_PROTOCOLPGM("|...Back....|\n");</front>
<front id="Marlin_mainCPP-3082">          SERIAL_PROTOCOLPGM("|Left..Right|\n");</front>
<front id="Marlin_mainCPP-3083">          SERIAL_PROTOCOLPGM("|...Front...|\n");</front>
<front id="Marlin_mainCPP-3084">          SERIAL_PROTOCOLPGM("+-----------+\n");</front>
<front id="Marlin_mainCPP-3085"></front>
<front id="Marlin_mainCPP-3086">          float min_diff = 999;</front>
<front id="Marlin_mainCPP-3087"></front>
<front id="Marlin_mainCPP-3088">          for (int yy = auto_bed_leveling_grid_points - 1; yy &gt;= 0; yy--) {</front>
<front id="Marlin_mainCPP-3089">            for (int xx = 0; xx &lt; auto_bed_leveling_grid_points; xx++) {</front>
<front id="Marlin_mainCPP-3090">              int ind = indexIntoAB[xx][yy];</front>
<front id="Marlin_mainCPP-3091">              float diff = eqnBVector[ind] - mean;</front>
<front id="Marlin_mainCPP-3092"></front>
<front id="Marlin_mainCPP-3093">              float x_tmp = eqnAMatrix[ind + 0 * abl2],</front>
<front id="Marlin_mainCPP-3094">                y_tmp = eqnAMatrix[ind + 1 * abl2],</front>
<front id="Marlin_mainCPP-3095">                z_tmp = 0;</front>
<front id="Marlin_mainCPP-3096"></front>
<front id="Marlin_mainCPP-3097">              apply_rotation_xyz(plan_bed_level_matrix,x_tmp,y_tmp,z_tmp);</front>
<front id="Marlin_mainCPP-3098"></front>
<front id="Marlin_mainCPP-3099">              if (eqnBVector[ind] - z_tmp &lt; min_diff)</front>
<front id="Marlin_mainCPP-3100">                min_diff = eqnBVector[ind] - z_tmp;</front>
<front id="Marlin_mainCPP-3101"></front>
<front id="Marlin_mainCPP-3102">              if (diff &gt;= 0.0)</front>
<front id="Marlin_mainCPP-3103">                SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment</front>
<front id="Marlin_mainCPP-3104">              else</front>
<front id="Marlin_mainCPP-3105">                SERIAL_PROTOCOLCHAR(' ');</front>
<front id="Marlin_mainCPP-3106">              SERIAL_PROTOCOL_F(diff, 5);</front>
<front id="Marlin_mainCPP-3107">            } // xx</front>
<front id="Marlin_mainCPP-3108">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3109">          } // yy</front>
<front id="Marlin_mainCPP-3110">          SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3111">          if (verbose_level &gt; 3) {</front>
<front id="Marlin_mainCPP-3112">            SERIAL_PROTOCOLPGM(" \nCorrected Bed Height vs. Bed Topology: \n");</front>
<front id="Marlin_mainCPP-3113"></front>
<front id="Marlin_mainCPP-3114">            for (int yy = auto_bed_leveling_grid_points - 1; yy &gt;= 0; yy--) {</front>
<front id="Marlin_mainCPP-3115">              for (int xx = 0; xx &lt; auto_bed_leveling_grid_points; xx++) {</front>
<front id="Marlin_mainCPP-3116">                int ind = indexIntoAB[xx][yy];</front>
<front id="Marlin_mainCPP-3117">                float x_tmp = eqnAMatrix[ind + 0 * abl2],</front>
<front id="Marlin_mainCPP-3118">                  y_tmp = eqnAMatrix[ind + 1 * abl2],</front>
<front id="Marlin_mainCPP-3119">                  z_tmp = 0;</front>
<front id="Marlin_mainCPP-3120"></front>
<front id="Marlin_mainCPP-3121">                apply_rotation_xyz(plan_bed_level_matrix,x_tmp,y_tmp,z_tmp);</front>
<front id="Marlin_mainCPP-3122"></front>
<front id="Marlin_mainCPP-3123">                float diff = eqnBVector[ind] - z_tmp - min_diff;</front>
<front id="Marlin_mainCPP-3124">                if (diff &gt;= 0.0)</front>
<front id="Marlin_mainCPP-3125">                  SERIAL_PROTOCOLPGM(" +");</front>
<front id="Marlin_mainCPP-3126">                // Include + for column alignment</front>
<front id="Marlin_mainCPP-3127">                else</front>
<front id="Marlin_mainCPP-3128">                  SERIAL_PROTOCOLCHAR(' ');</front>
<front id="Marlin_mainCPP-3129">                SERIAL_PROTOCOL_F(diff, 5);</front>
<front id="Marlin_mainCPP-3130">              } // xx</front>
<front id="Marlin_mainCPP-3131">              SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3132">            } // yy</front>
<front id="Marlin_mainCPP-3133">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3134">          }</front>
<front id="Marlin_mainCPP-3135">        } //do_topography_map</front>
<front id="Marlin_mainCPP-3136">      #endif //!DELTA</front>
<front id="Marlin_mainCPP-3137"></front>
<front id="Marlin_mainCPP-3138">    #else // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-3139"></front>
<front id="Marlin_mainCPP-3140">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3141">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3142">          SERIAL_ECHOLNPGM("&gt; 3-point Leveling");</front>
<front id="Marlin_mainCPP-3143">        }</front>
<front id="Marlin_mainCPP-3144">      #endif</front>
<front id="Marlin_mainCPP-3145"></front>
<front id="Marlin_mainCPP-3146">      // Actions for each probe</front>
<front id="Marlin_mainCPP-3147">      ProbeAction p1, p2, p3;</front>
<front id="Marlin_mainCPP-3148">      if (deploy_probe_for_each_reading)</front>
<front id="Marlin_mainCPP-3149">        p1 = p2 = p3 = ProbeDeployAndStow;</front>
<front id="Marlin_mainCPP-3150">      else</front>
<front id="Marlin_mainCPP-3151">        p1 = ProbeDeploy, p2 = ProbeStay, p3 = ProbeStow;</front>
<front id="Marlin_mainCPP-3152"></front>
<front id="Marlin_mainCPP-3153">      // Probe at 3 arbitrary points</front>
<front id="Marlin_mainCPP-3154">      float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING, p1, verbose_level),</front>
<front id="Marlin_mainCPP-3155">            z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p2, verbose_level),</front>
<front id="Marlin_mainCPP-3156">            z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p3, verbose_level);</front>
<front id="Marlin_mainCPP-3157">      clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3158">      if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);</front>
<front id="Marlin_mainCPP-3159"></front>
<front id="Marlin_mainCPP-3160">    #endif // !AUTO_BED_LEVELING_GRID</front>
<front id="Marlin_mainCPP-3161"></front>
<front id="Marlin_mainCPP-3162">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-3163">      // Allen Key Probe for Delta</front>
<front id="Marlin_mainCPP-3164">      #if ENABLED(Z_PROBE_ALLEN_KEY)</front>
<front id="Marlin_mainCPP-3165">        stow_z_probe();</front>
<front id="Marlin_mainCPP-3166">      #elif Z_RAISE_AFTER_PROBING &gt; 0</front>
<front id="Marlin_mainCPP-3167">        raise_z_after_probing();</front>
<front id="Marlin_mainCPP-3168">      #endif</front>
<front id="Marlin_mainCPP-3169">    #else // !DELTA</front>
<front id="Marlin_mainCPP-3170">      if (verbose_level &gt; 0)</front>
<front id="Marlin_mainCPP-3171">        plan_bed_level_matrix.debug(" \n\nBed Level Correction Matrix:");</front>
<front id="Marlin_mainCPP-3172"></front>
<front id="Marlin_mainCPP-3173">      if (!dryrun) {</front>
<front id="Marlin_mainCPP-3174">        // Correct the Z height difference from Z probe position and nozzle tip position.</front>
<front id="Marlin_mainCPP-3175">        // The Z height on homing is measured by Z probe, but the Z probe is quite far from the nozzle.</front>
<front id="Marlin_mainCPP-3176">        // When the bed is uneven, this height must be corrected.</front>
<front id="Marlin_mainCPP-3177">        float x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,</front>
<front id="Marlin_mainCPP-3178">              y_tmp = current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER,</front>
<front id="Marlin_mainCPP-3179">              z_tmp = current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-3180">              real_z = st_get_position_mm(Z_AXIS);  //get the real Z (since plan_get_position is now correcting the plane)</front>
<front id="Marlin_mainCPP-3181"></front>
<front id="Marlin_mainCPP-3182">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3183">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3184">            SERIAL_ECHOPAIR("&gt; BEFORE apply_rotation_xyz &gt; z_tmp  = ", z_tmp);</front>
<front id="Marlin_mainCPP-3185">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3186">            SERIAL_ECHOPAIR("&gt; BEFORE apply_rotation_xyz &gt; real_z = ", real_z);</front>
<front id="Marlin_mainCPP-3187">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3188">          }</front>
<front id="Marlin_mainCPP-3189">        #endif</front>
<front id="Marlin_mainCPP-3190"></front>
<front id="Marlin_mainCPP-3191">        apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp); // Apply the correction sending the Z probe offset</front>
<front id="Marlin_mainCPP-3192"></front>
<front id="Marlin_mainCPP-3193">        // Get the current Z position and send it to the planner.</front>
<front id="Marlin_mainCPP-3194">        //</front>
<front id="Marlin_mainCPP-3195">        // &gt;&gt; (z_tmp - real_z) : The rotated current Z minus the uncorrected Z (most recent plan_set_position/sync_plan_position)</front>
<front id="Marlin_mainCPP-3196">        //</front>
<front id="Marlin_mainCPP-3197">        // &gt;&gt; zprobe_zoffset : Z distance from nozzle to Z probe (set by default, M851, EEPROM, or Menu)</front>
<front id="Marlin_mainCPP-3198">        //</front>
<front id="Marlin_mainCPP-3199">        // &gt;&gt; Z_RAISE_AFTER_PROBING : The distance the Z probe will have lifted after the last probe</front>
<front id="Marlin_mainCPP-3200">        //</front>
<front id="Marlin_mainCPP-3201">        // &gt;&gt; Should home_offset[Z_AXIS] be included?</front>
<front id="Marlin_mainCPP-3202">        //</front>
<front id="Marlin_mainCPP-3203">        //      Discussion: home_offset[Z_AXIS] was applied in G28 to set the starting Z.</front>
<front id="Marlin_mainCPP-3204">        //      If Z is not tweaked in G29 -and- the Z probe in G29 is not actually "homing" Z...</front>
<front id="Marlin_mainCPP-3205">        //      then perhaps it should not be included here. The purpose of home_offset[] is to</front>
<front id="Marlin_mainCPP-3206">        //      adjust for inaccurate endstops, not for reasonably accurate probes. If it were</front>
<front id="Marlin_mainCPP-3207">        //      added here, it could be seen as a compensating factor for the Z probe.</front>
<front id="Marlin_mainCPP-3208">        //</front>
<front id="Marlin_mainCPP-3209">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3210">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3211">            SERIAL_ECHOPAIR("&gt; AFTER apply_rotation_xyz &gt; z_tmp  = ", z_tmp);</front>
<front id="Marlin_mainCPP-3212">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3213">          }</front>
<front id="Marlin_mainCPP-3214">        #endif</front>
<front id="Marlin_mainCPP-3215"></front>
<front id="Marlin_mainCPP-3216">        current_position[Z_AXIS] = -zprobe_zoffset + (z_tmp - real_z)</front>
<front id="Marlin_mainCPP-3217">          #if HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-3218">             + Z_RAISE_AFTER_PROBING</front>
<front id="Marlin_mainCPP-3219">          #endif</front>
<front id="Marlin_mainCPP-3220">          ;</front>
<front id="Marlin_mainCPP-3221">        // current_position[Z_AXIS] += home_offset[Z_AXIS]; // The Z probe determines Z=0, not "Z home"</front>
<front id="Marlin_mainCPP-3222">        sync_plan_position();</front>
<front id="Marlin_mainCPP-3223"></front>
<front id="Marlin_mainCPP-3224">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3225">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3226">            print_xyz("&gt; corrected Z in G29", current_position);</front>
<front id="Marlin_mainCPP-3227">          }</front>
<front id="Marlin_mainCPP-3228">        #endif</front>
<front id="Marlin_mainCPP-3229">      }</front>
<front id="Marlin_mainCPP-3230"></front>
<front id="Marlin_mainCPP-3231">      // Sled assembly for Cartesian bots</front>
<front id="Marlin_mainCPP-3232">      #if ENABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-3233">        dock_sled(true); // dock the sled</front>
<front id="Marlin_mainCPP-3234">      #endif</front>
<front id="Marlin_mainCPP-3235"></front>
<front id="Marlin_mainCPP-3236">    #endif // !DELTA</front>
<front id="Marlin_mainCPP-3237"></front>
<front id="Marlin_mainCPP-3238">    #ifdef Z_PROBE_END_SCRIPT</front>
<front id="Marlin_mainCPP-3239">      #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3240">        if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3241">          SERIAL_ECHO("Z Probe End Script: ");</front>
<front id="Marlin_mainCPP-3242">          SERIAL_ECHOLNPGM(Z_PROBE_END_SCRIPT);</front>
<front id="Marlin_mainCPP-3243">        }</front>
<front id="Marlin_mainCPP-3244">      #endif</front>
<front id="Marlin_mainCPP-3245">      enqueuecommands_P(PSTR(Z_PROBE_END_SCRIPT));</front>
<front id="Marlin_mainCPP-3246">      st_synchronize();</front>
<front id="Marlin_mainCPP-3247">    #endif</front>
<front id="Marlin_mainCPP-3248"></front>
<front id="Marlin_mainCPP-3249">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-3250">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-3251">        SERIAL_ECHOLNPGM("&lt;&lt;&lt; gcode_G29");</front>
<front id="Marlin_mainCPP-3252">      }</front>
<front id="Marlin_mainCPP-3253">    #endif</front>
<front id="Marlin_mainCPP-3254"></front>
<front id="Marlin_mainCPP-3255">    #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-3256">      current_layer = 0;</front>
<front id="Marlin_mainCPP-3257">      last_layer_z = 0;</front>
<front id="Marlin_mainCPP-3258">    #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-3259">  }</front>
<front id="Marlin_mainCPP-3260"></front>
<front id="Marlin_mainCPP-3261">  #if DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-3262"></front>
<front id="Marlin_mainCPP-3263">    /**</front>
<front id="Marlin_mainCPP-3264">     * G30: Do a single Z probe at the current XY</front>
<front id="Marlin_mainCPP-3265">     */</front>
<front id="Marlin_mainCPP-3266">    inline void gcode_G30() {</front>
<front id="Marlin_mainCPP-3267">      #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-3268">        raise_z_for_servo();</front>
<front id="Marlin_mainCPP-3269">      #endif</front>
<front id="Marlin_mainCPP-3270">      deploy_z_probe(); // Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-3271"></front>
<front id="Marlin_mainCPP-3272">      st_synchronize();</front>
<front id="Marlin_mainCPP-3273">      // TODO: clear the leveling matrix or the planner will be set incorrectly</front>
<front id="Marlin_mainCPP-3274">      setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-3275"></front>
<front id="Marlin_mainCPP-3276">      feedrate = homing_feedrate[Z_AXIS];</front>
<front id="Marlin_mainCPP-3277"></front>
<front id="Marlin_mainCPP-3278">      run_z_probe();</front>
<front id="Marlin_mainCPP-3279">      SERIAL_PROTOCOLPGM("Bed X: ");</front>
<front id="Marlin_mainCPP-3280">      SERIAL_PROTOCOL(current_position[X_AXIS] + 0.0001);</front>
<front id="Marlin_mainCPP-3281">      SERIAL_PROTOCOLPGM(" Y: ");</front>
<front id="Marlin_mainCPP-3282">      SERIAL_PROTOCOL(current_position[Y_AXIS] + 0.0001);</front>
<front id="Marlin_mainCPP-3283">      SERIAL_PROTOCOLPGM(" Z: ");</front>
<front id="Marlin_mainCPP-3284">      SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);</front>
<front id="Marlin_mainCPP-3285">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3286"></front>
<front id="Marlin_mainCPP-3287">      clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3288"></front>
<front id="Marlin_mainCPP-3289">      #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-3290">        raise_z_for_servo();</front>
<front id="Marlin_mainCPP-3291">      #endif</front>
<front id="Marlin_mainCPP-3292">      stow_z_probe(false); // Retract Z Servo endstop if available</front>
<front id="Marlin_mainCPP-3293">    }</front>
<front id="Marlin_mainCPP-3294"></front>
<front id="Marlin_mainCPP-3295">  #endif //!Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-3296"></front>
<front id="Marlin_mainCPP-3297">#endif //AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-3298"></front>
<front id="Marlin_mainCPP-3299">/**</front>
<front id="Marlin_mainCPP-3300"> * G92: Set current position to given X Y Z E</front>
<front id="Marlin_mainCPP-3301"> */</front>
<front id="Marlin_mainCPP-3302">inline void gcode_G92() {</front>
<front id="Marlin_mainCPP-3303">  if (!code_seen(axis_codes[E_AXIS]))</front>
<front id="Marlin_mainCPP-3304">    st_synchronize();</front>
<front id="Marlin_mainCPP-3305"></front>
<front id="Marlin_mainCPP-3306">  bool didXYZ = false;</front>
<front id="Marlin_mainCPP-3307">  for (int i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-3308">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-3309">      float v = current_position[i] = code_value();</front>
<front id="Marlin_mainCPP-3310">      if (i == E_AXIS)</front>
<front id="Marlin_mainCPP-3311">        plan_set_e_position(v);</front>
<front id="Marlin_mainCPP-3312">      else</front>
<front id="Marlin_mainCPP-3313">        didXYZ = true;</front>
<front id="Marlin_mainCPP-3314">    }</front>
<front id="Marlin_mainCPP-3315">  }</front>
<front id="Marlin_mainCPP-3316">  if (didXYZ) {</front>
<front id="Marlin_mainCPP-3317">    #if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-3318">      sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-3319">    #else</front>
<front id="Marlin_mainCPP-3320">      sync_plan_position();</front>
<front id="Marlin_mainCPP-3321">    #endif</front>
<front id="Marlin_mainCPP-3322">  }</front>
<front id="Marlin_mainCPP-3323">}</front>
<front id="Marlin_mainCPP-3324"></front>
<front id="Marlin_mainCPP-3325">#if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-3326"></front>
<front id="Marlin_mainCPP-3327">  /**</front>
<front id="Marlin_mainCPP-3328">   * M0: // M0 - Unconditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-3329">   * M1: // M1 - Conditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-3330">   */</front>
<front id="Marlin_mainCPP-3331">  inline void gcode_M0_M1() {</front>
<front id="Marlin_mainCPP-3332">    char *args = current_command_args;</front>
<front id="Marlin_mainCPP-3333"></front>
<front id="Marlin_mainCPP-3334">    millis_t codenum = 0;</front>
<front id="Marlin_mainCPP-3335">    bool hasP = false, hasS = false;</front>
<front id="Marlin_mainCPP-3336">    if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-3337">      codenum = code_value_short(); // milliseconds to wait</front>
<front id="Marlin_mainCPP-3338">      hasP = codenum &gt; 0;</front>
<front id="Marlin_mainCPP-3339">    }</front>
<front id="Marlin_mainCPP-3340">    if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-3341">      codenum = code_value() * 1000; // seconds to wait</front>
<front id="Marlin_mainCPP-3342">      hasS = codenum &gt; 0;</front>
<front id="Marlin_mainCPP-3343">    }</front>
<front id="Marlin_mainCPP-3344"></front>
<front id="Marlin_mainCPP-3345">    if (!hasP && !hasS && *args != '\0')</front>
<front id="Marlin_mainCPP-3346">      lcd_setstatus(args, true);</front>
<front id="Marlin_mainCPP-3347">    else {</front>
<front id="Marlin_mainCPP-3348">      LCD_MESSAGEPGM(MSG_USERWAIT);</front>
<front id="Marlin_mainCPP-3349">      #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="Marlin_mainCPP-3350">        dontExpireStatus();</front>
<front id="Marlin_mainCPP-3351">      #endif</front>
<front id="Marlin_mainCPP-3352">    }</front>
<front id="Marlin_mainCPP-3353"></front>
<front id="Marlin_mainCPP-3354">    lcd_ignore_click();</front>
<front id="Marlin_mainCPP-3355">    st_synchronize();</front>
<front id="Marlin_mainCPP-3356">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-3357">    if (codenum &gt; 0) {</front>
<front id="Marlin_mainCPP-3358">      codenum += previous_cmd_ms;  // wait until this time for a click</front>
<front id="Marlin_mainCPP-3359">      while (millis() &lt; codenum && !lcd_clicked()) idle();</front>
<front id="Marlin_mainCPP-3360">      lcd_ignore_click(false);</front>
<front id="Marlin_mainCPP-3361">    }</front>
<front id="Marlin_mainCPP-3362">    else {</front>
<front id="Marlin_mainCPP-3363">      if (!lcd_detected()) return;</front>
<front id="Marlin_mainCPP-3364">      while (!lcd_clicked()) idle();</front>
<front id="Marlin_mainCPP-3365">    }</front>
<front id="Marlin_mainCPP-3366">    if (IS_SD_PRINTING)</front>
<front id="Marlin_mainCPP-3367">      LCD_MESSAGEPGM(MSG_RESUMING);</front>
<front id="Marlin_mainCPP-3368">    else</front>
<front id="Marlin_mainCPP-3369">      LCD_MESSAGEPGM(WELCOME_MSG);</front>
<front id="Marlin_mainCPP-3370">  }</front>
<front id="Marlin_mainCPP-3371"></front>
<front id="Marlin_mainCPP-3372">#endif // ULTIPANEL</front>
<front id="Marlin_mainCPP-3373"></front>
<front id="Marlin_mainCPP-3374">/**</front>
<front id="Marlin_mainCPP-3375"> * M17: Enable power on all stepper motors</front>
<front id="Marlin_mainCPP-3376"> */</front>
<front id="Marlin_mainCPP-3377">inline void gcode_M17() {</front>
<front id="Marlin_mainCPP-3378">  LCD_MESSAGEPGM(MSG_NO_MOVE);</front>
<front id="Marlin_mainCPP-3379">  enable_all_steppers();</front>
<front id="Marlin_mainCPP-3380">}</front>
<front id="Marlin_mainCPP-3381"></front>
<front id="Marlin_mainCPP-3382">#if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-3383">  inline void gcode_M19() {</front>
<front id="Marlin_mainCPP-3384">    if (code_seen('Z')) {</front>
<front id="Marlin_mainCPP-3385">      gcode_get_destination(); // For Z</front>
<front id="Marlin_mainCPP-3386">      prepare_move();</front>
<front id="Marlin_mainCPP-3387">      enqueuecommands_P(PSTR("M114")); // tell the host where it is</front>
<front id="Marlin_mainCPP-3388">    }</front>
<front id="Marlin_mainCPP-3389"></front>
<front id="Marlin_mainCPP-3390">    if (current_position[Z_AXIS] &gt; 0) {</front>
<front id="Marlin_mainCPP-3391">      planner_disabled_below_z = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-3392"></front>
<front id="Marlin_mainCPP-3393">      SERIAL_PROTOCOLPGM("Resume from Z = ");</front>
<front id="Marlin_mainCPP-3394">      SERIAL_PROTOCOL(planner_disabled_below_z);</front>
<front id="Marlin_mainCPP-3395">      SERIAL_PROTOCOLPGM(" mm\n");</front>
<front id="Marlin_mainCPP-3396">    }</front>
<front id="Marlin_mainCPP-3397">    else</front>
<front id="Marlin_mainCPP-3398">      SERIAL_PROTOCOLPGM("Error: Resume from Z &lt;= 0\n");</front>
<front id="Marlin_mainCPP-3399">  }</front>
<front id="Marlin_mainCPP-3400">#endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-3401"></front>
<front id="Marlin_mainCPP-3402">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-3403"></front>
<front id="Marlin_mainCPP-3404">  /**</front>
<front id="Marlin_mainCPP-3405">   * M20: List SD card to serial output</front>
<front id="Marlin_mainCPP-3406">   */</front>
<front id="Marlin_mainCPP-3407">  inline void gcode_M20() {</front>
<front id="Marlin_mainCPP-3408">    SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);</front>
<front id="Marlin_mainCPP-3409">    card.ls();</front>
<front id="Marlin_mainCPP-3410">    SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);</front>
<front id="Marlin_mainCPP-3411">  }</front>
<front id="Marlin_mainCPP-3412"></front>
<front id="Marlin_mainCPP-3413">  /**</front>
<front id="Marlin_mainCPP-3414">   * M21: Init SD Card</front>
<front id="Marlin_mainCPP-3415">   */</front>
<front id="Marlin_mainCPP-3416">  inline void gcode_M21() {</front>
<front id="Marlin_mainCPP-3417">    card.initsd();</front>
<front id="Marlin_mainCPP-3418">  }</front>
<front id="Marlin_mainCPP-3419"></front>
<front id="Marlin_mainCPP-3420">  /**</front>
<front id="Marlin_mainCPP-3421">   * M22: Release SD Card</front>
<front id="Marlin_mainCPP-3422">   */</front>
<front id="Marlin_mainCPP-3423">  inline void gcode_M22() {</front>
<front id="Marlin_mainCPP-3424">    card.release();</front>
<front id="Marlin_mainCPP-3425">  }</front>
<front id="Marlin_mainCPP-3426"></front>
<front id="Marlin_mainCPP-3427">  /**</front>
<front id="Marlin_mainCPP-3428">   * M23: Select a file</front>
<front id="Marlin_mainCPP-3429">   */</front>
<front id="Marlin_mainCPP-3430">  inline void gcode_M23() {</front>
<front id="Marlin_mainCPP-3431">    card.openFile(current_command_args, true);</front>
<front id="Marlin_mainCPP-3432">  }</front>
<front id="Marlin_mainCPP-3433"></front>
<front id="Marlin_mainCPP-3434">  /**</front>
<front id="Marlin_mainCPP-3435">   * M24: Start SD Print</front>
<front id="Marlin_mainCPP-3436">   */</front>
<front id="Marlin_mainCPP-3437">  inline void gcode_M24() {</front>
<front id="Marlin_mainCPP-3438">    card.startFileprint();</front>
<front id="Marlin_mainCPP-3439">    #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-3440">      current_layer = 0;</front>
<front id="Marlin_mainCPP-3441">      last_layer_z = 0;</front>
<front id="Marlin_mainCPP-3442">    #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-3443">    print_job_start_ms = millis();</front>
<front id="Marlin_mainCPP-3444">  }</front>
<front id="Marlin_mainCPP-3445"></front>
<front id="Marlin_mainCPP-3446">  /**</front>
<front id="Marlin_mainCPP-3447">   * M25: Pause SD Print</front>
<front id="Marlin_mainCPP-3448">   */</front>
<front id="Marlin_mainCPP-3449">  inline void gcode_M25() {</front>
<front id="Marlin_mainCPP-3450">    card.pauseSDPrint();</front>
<front id="Marlin_mainCPP-3451">  }</front>
<front id="Marlin_mainCPP-3452"></front>
<front id="Marlin_mainCPP-3453">  /**</front>
<front id="Marlin_mainCPP-3454">   * M26: Set SD Card file index</front>
<front id="Marlin_mainCPP-3455">   */</front>
<front id="Marlin_mainCPP-3456">  inline void gcode_M26() {</front>
<front id="Marlin_mainCPP-3457">    if (card.cardOK && code_seen('S'))</front>
<front id="Marlin_mainCPP-3458">      card.setIndex(code_value_short());</front>
<front id="Marlin_mainCPP-3459">  }</front>
<front id="Marlin_mainCPP-3460"></front>
<front id="Marlin_mainCPP-3461">  /**</front>
<front id="Marlin_mainCPP-3462">   * M27: Get SD Card status</front>
<front id="Marlin_mainCPP-3463">   */</front>
<front id="Marlin_mainCPP-3464">  inline void gcode_M27() {</front>
<front id="Marlin_mainCPP-3465">    card.getStatus();</front>
<front id="Marlin_mainCPP-3466">  }</front>
<front id="Marlin_mainCPP-3467"></front>
<front id="Marlin_mainCPP-3468">  /**</front>
<front id="Marlin_mainCPP-3469">   * M28: Start SD Write</front>
<front id="Marlin_mainCPP-3470">   */</front>
<front id="Marlin_mainCPP-3471">  inline void gcode_M28() {</front>
<front id="Marlin_mainCPP-3472">    card.openFile(current_command_args, false);</front>
<front id="Marlin_mainCPP-3473">  }</front>
<front id="Marlin_mainCPP-3474"></front>
<front id="Marlin_mainCPP-3475">  /**</front>
<front id="Marlin_mainCPP-3476">   * M29: Stop SD Write</front>
<front id="Marlin_mainCPP-3477">   * Processed in write to file routine above</front>
<front id="Marlin_mainCPP-3478">   */</front>
<front id="Marlin_mainCPP-3479">  inline void gcode_M29() {</front>
<front id="Marlin_mainCPP-3480">    // card.saving = false;</front>
<front id="Marlin_mainCPP-3481">  }</front>
<front id="Marlin_mainCPP-3482"></front>
<front id="Marlin_mainCPP-3483">  /**</front>
<front id="Marlin_mainCPP-3484">   * M30 &lt;filename&gt;: Delete SD Card file</front>
<front id="Marlin_mainCPP-3485">   */</front>
<front id="Marlin_mainCPP-3486">  inline void gcode_M30() {</front>
<front id="Marlin_mainCPP-3487">    if (card.cardOK) {</front>
<front id="Marlin_mainCPP-3488">      card.closefile();</front>
<front id="Marlin_mainCPP-3489">      card.removeFile(current_command_args);</front>
<front id="Marlin_mainCPP-3490">    }</front>
<front id="Marlin_mainCPP-3491">  }</front>
<front id="Marlin_mainCPP-3492"></front>
<front id="Marlin_mainCPP-3493">#endif</front>
<front id="Marlin_mainCPP-3494"></front>
<front id="Marlin_mainCPP-3495">/**</front>
<front id="Marlin_mainCPP-3496"> * M31: Get the time since the start of SD Print (or last M109)</front>
<front id="Marlin_mainCPP-3497"> */</front>
<front id="Marlin_mainCPP-3498">inline void gcode_M31() {</front>
<front id="Marlin_mainCPP-3499">  print_job_stop_ms = millis();</front>
<front id="Marlin_mainCPP-3500">  millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;</front>
<front id="Marlin_mainCPP-3501">  int min = t / 60, sec = t % 60;</front>
<front id="Marlin_mainCPP-3502">  char time[30];</front>
<front id="Marlin_mainCPP-3503">  sprintf_P(time, PSTR("%i min, %i sec"), min, sec);</front>
<front id="Marlin_mainCPP-3504">  SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-3505">  SERIAL_ECHOLN(time);</front>
<front id="Marlin_mainCPP-3506">  lcd_setstatus(time);</front>
<front id="Marlin_mainCPP-3507">  autotempShutdown();</front>
<front id="Marlin_mainCPP-3508">}</front>
<front id="Marlin_mainCPP-3509"></front>
<front id="Marlin_mainCPP-3510">#if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-3511"></front>
<front id="Marlin_mainCPP-3512">  /**</front>
<front id="Marlin_mainCPP-3513">   * M32: Select file and start SD Print</front>
<front id="Marlin_mainCPP-3514">   */</front>
<front id="Marlin_mainCPP-3515">  inline void gcode_M32() {</front>
<front id="Marlin_mainCPP-3516">    if (card.sdprinting)</front>
<front id="Marlin_mainCPP-3517">      st_synchronize();</front>
<front id="Marlin_mainCPP-3518"></front>
<front id="Marlin_mainCPP-3519">    char* namestartpos = strchr(current_command_args, '!');  // Find ! to indicate filename string start.</front>
<front id="Marlin_mainCPP-3520">    if (!namestartpos)</front>
<front id="Marlin_mainCPP-3521">      namestartpos = current_command_args; // Default name position, 4 letters after the M</front>
<front id="Marlin_mainCPP-3522">    else</front>
<front id="Marlin_mainCPP-3523">      namestartpos++; //to skip the '!'</front>
<front id="Marlin_mainCPP-3524"></front>
<front id="Marlin_mainCPP-3525">    bool call_procedure = code_seen('P') && (seen_pointer &lt; namestartpos);</front>
<front id="Marlin_mainCPP-3526"></front>
<front id="Marlin_mainCPP-3527">    if (card.cardOK) {</front>
<front id="Marlin_mainCPP-3528">      card.openFile(namestartpos, true, !call_procedure);</front>
<front id="Marlin_mainCPP-3529"></front>
<front id="Marlin_mainCPP-3530">      if (code_seen('S') && seen_pointer &lt; namestartpos) // "S" (must occur _before_ the filename!)</front>
<front id="Marlin_mainCPP-3531">        card.setIndex(code_value_short());</front>
<front id="Marlin_mainCPP-3532"></front>
<front id="Marlin_mainCPP-3533">      card.startFileprint();</front>
<front id="Marlin_mainCPP-3534">      if (!call_procedure)</front>
<front id="Marlin_mainCPP-3535">        print_job_start_ms = millis(); //procedure calls count as normal print time.</front>
<front id="Marlin_mainCPP-3536">    }</front>
<front id="Marlin_mainCPP-3537">  }</front>
<front id="Marlin_mainCPP-3538"></front>
<front id="Marlin_mainCPP-3539">  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)</front>
<front id="Marlin_mainCPP-3540"></front>
<front id="Marlin_mainCPP-3541">    /**</front>
<front id="Marlin_mainCPP-3542">     * M33: Get the long full path of a file or folder</front>
<front id="Marlin_mainCPP-3543">     *</front>
<front id="Marlin_mainCPP-3544">     * Parameters:</front>
<front id="Marlin_mainCPP-3545">     *   &lt;dospath&gt; Case-insensitive DOS-style path to a file or folder</front>
<front id="Marlin_mainCPP-3546">     *</front>
<front id="Marlin_mainCPP-3547">     * Example:</front>
<front id="Marlin_mainCPP-3548">     *   M33 miscel~1/armchair/armcha~1.gco</front>
<front id="Marlin_mainCPP-3549">     *</front>
<front id="Marlin_mainCPP-3550">     * Output:</front>
<front id="Marlin_mainCPP-3551">     *   /Miscellaneous/Armchair/Armchair.gcode</front>
<front id="Marlin_mainCPP-3552">     */</front>
<front id="Marlin_mainCPP-3553">    inline void gcode_M33() {</front>
<front id="Marlin_mainCPP-3554">      card.printLongPath(current_command_args);</front>
<front id="Marlin_mainCPP-3555">    }</front>
<front id="Marlin_mainCPP-3556"></front>
<front id="Marlin_mainCPP-3557">  #endif</front>
<front id="Marlin_mainCPP-3558"></front>
<front id="Marlin_mainCPP-3559">  /**</front>
<front id="Marlin_mainCPP-3560">   * M928: Start SD Write</front>
<front id="Marlin_mainCPP-3561">   */</front>
<front id="Marlin_mainCPP-3562">  inline void gcode_M928() {</front>
<front id="Marlin_mainCPP-3563">    card.openLogFile(current_command_args);</front>
<front id="Marlin_mainCPP-3564">  }</front>
<front id="Marlin_mainCPP-3565"></front>
<front id="Marlin_mainCPP-3566">#endif // SDSUPPORT</front>
<front id="Marlin_mainCPP-3567"></front>
<front id="Marlin_mainCPP-3568">/**</front>
<front id="Marlin_mainCPP-3569"> * M42: Change pin status via GCode</front>
<front id="Marlin_mainCPP-3570"> */</front>
<front id="Marlin_mainCPP-3571">inline void gcode_M42() {</front>
<front id="Marlin_mainCPP-3572">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-3573">    int pin_status = code_value_short(),</front>
<front id="Marlin_mainCPP-3574">        pin_number = LED_PIN;</front>
<front id="Marlin_mainCPP-3575"></front>
<front id="Marlin_mainCPP-3576">    if (code_seen('P') && pin_status &gt;= 0 && pin_status &lt;= 255)</front>
<front id="Marlin_mainCPP-3577">      pin_number = code_value_short();</front>
<front id="Marlin_mainCPP-3578"></front>
<front id="Marlin_mainCPP-3579">    for (uint8_t i = 0; i &lt; COUNT(sensitive_pins); i++) {</front>
<front id="Marlin_mainCPP-3580">      if (sensitive_pins[i] == pin_number) {</front>
<front id="Marlin_mainCPP-3581">        pin_number = -1;</front>
<front id="Marlin_mainCPP-3582">        break;</front>
<front id="Marlin_mainCPP-3583">      }</front>
<front id="Marlin_mainCPP-3584">    }</front>
<front id="Marlin_mainCPP-3585"></front>
<front id="Marlin_mainCPP-3586">    #if HAS_FAN</front>
<front id="Marlin_mainCPP-3587">      if (pin_number == FAN_PIN) fanSpeed = pin_status;</front>
<front id="Marlin_mainCPP-3588">    #endif</front>
<front id="Marlin_mainCPP-3589"></front>
<front id="Marlin_mainCPP-3590">    if (pin_number &gt; -1) {</front>
<front id="Marlin_mainCPP-3591">      pinMode(pin_number, OUTPUT);</front>
<front id="Marlin_mainCPP-3592">      digitalWrite(pin_number, pin_status);</front>
<front id="Marlin_mainCPP-3593">      analogWrite(pin_number, pin_status);</front>
<front id="Marlin_mainCPP-3594">    }</front>
<front id="Marlin_mainCPP-3595">  } // code_seen('S')</front>
<front id="Marlin_mainCPP-3596">}</front>
<front id="Marlin_mainCPP-3597"></front>
<front id="Marlin_mainCPP-3598">#if ENABLED(AUTO_BED_LEVELING_FEATURE) && ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)</front>
<front id="Marlin_mainCPP-3599"></front>
<front id="Marlin_mainCPP-3600">  // This is redundant since the SanityCheck.h already checks for a valid Z_MIN_PROBE_PIN, but here for clarity.</front>
<front id="Marlin_mainCPP-3601">  #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="Marlin_mainCPP-3602">    #if !HAS_Z_PROBE</front>
<front id="Marlin_mainCPP-3603">      #error You must define Z_MIN_PROBE_PIN to enable Z probe repeatability calculation.</front>
<front id="Marlin_mainCPP-3604">    #endif</front>
<front id="Marlin_mainCPP-3605">  #elif !HAS_Z_MIN</front>
<front id="Marlin_mainCPP-3606">    #error You must define Z_MIN_PIN to enable Z probe repeatability calculation.</front>
<front id="Marlin_mainCPP-3607">  #endif</front>
<front id="Marlin_mainCPP-3608"></front>
<front id="Marlin_mainCPP-3609">  /**</front>
<front id="Marlin_mainCPP-3610">   * M48: Z probe repeatability measurement function.</front>
<front id="Marlin_mainCPP-3611">   *</front>
<front id="Marlin_mainCPP-3612">   * Usage:</front>
<front id="Marlin_mainCPP-3613">   *   M48 &lt;P#&gt; &lt;X#&gt; &lt;Y#&gt; &lt;V#&gt; &lt;E&gt; &lt;L#&gt;</front>
<front id="Marlin_mainCPP-3614">   *     P = Number of sampled points (4-50, default 10)</front>
<front id="Marlin_mainCPP-3615">   *     X = Sample X position</front>
<front id="Marlin_mainCPP-3616">   *     Y = Sample Y position</front>
<front id="Marlin_mainCPP-3617">   *     V = Verbose level (0-4, default=1)</front>
<front id="Marlin_mainCPP-3618">   *     E = Engage Z probe for each reading</front>
<front id="Marlin_mainCPP-3619">   *     L = Number of legs of movement before probe</front>
<front id="Marlin_mainCPP-3620">   *</front>
<front id="Marlin_mainCPP-3621">   * This function assumes the bed has been homed.  Specifically, that a G28 command</front>
<front id="Marlin_mainCPP-3622">   * as been issued prior to invoking the M48 Z probe repeatability measurement function.</front>
<front id="Marlin_mainCPP-3623">   * Any information generated by a prior G29 Bed leveling command will be lost and need to be</front>
<front id="Marlin_mainCPP-3624">   * regenerated.</front>
<front id="Marlin_mainCPP-3625">   */</front>
<front id="Marlin_mainCPP-3626">  inline void gcode_M48() {</front>
<front id="Marlin_mainCPP-3627"></front>
<front id="Marlin_mainCPP-3628">    double sum = 0.0, mean = 0.0, sigma = 0.0, sample_set[50];</front>
<front id="Marlin_mainCPP-3629">    uint8_t verbose_level = 1, n_samples = 10, n_legs = 0;</front>
<front id="Marlin_mainCPP-3630"></front>
<front id="Marlin_mainCPP-3631">    if (code_seen('V')) {</front>
<front id="Marlin_mainCPP-3632">      verbose_level = code_value_short();</front>
<front id="Marlin_mainCPP-3633">      if (verbose_level &lt; 0 || verbose_level &gt; 4 ) {</front>
<front id="Marlin_mainCPP-3634">        SERIAL_PROTOCOLPGM("?Verbose Level not plausible (0-4).\n");</front>
<front id="Marlin_mainCPP-3635">        return;</front>
<front id="Marlin_mainCPP-3636">      }</front>
<front id="Marlin_mainCPP-3637">    }</front>
<front id="Marlin_mainCPP-3638"></front>
<front id="Marlin_mainCPP-3639">    if (verbose_level &gt; 0)</front>
<front id="Marlin_mainCPP-3640">      SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test\n");</front>
<front id="Marlin_mainCPP-3641"></front>
<front id="Marlin_mainCPP-3642">    if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-3643">      n_samples = code_value_short();</front>
<front id="Marlin_mainCPP-3644">      if (n_samples &lt; 4 || n_samples &gt; 50) {</front>
<front id="Marlin_mainCPP-3645">        SERIAL_PROTOCOLPGM("?Sample size not plausible (4-50).\n");</front>
<front id="Marlin_mainCPP-3646">        return;</front>
<front id="Marlin_mainCPP-3647">      }</front>
<front id="Marlin_mainCPP-3648">    }</front>
<front id="Marlin_mainCPP-3649"></front>
<front id="Marlin_mainCPP-3650">    double X_current = st_get_position_mm(X_AXIS),</front>
<front id="Marlin_mainCPP-3651">           Y_current = st_get_position_mm(Y_AXIS),</front>
<front id="Marlin_mainCPP-3652">           Z_current = st_get_position_mm(Z_AXIS),</front>
<front id="Marlin_mainCPP-3653">           E_current = st_get_position_mm(E_AXIS),</front>
<front id="Marlin_mainCPP-3654">           X_probe_location = X_current, Y_probe_location = Y_current,</front>
<front id="Marlin_mainCPP-3655">           Z_start_location = Z_current + Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-3656"></front>
<front id="Marlin_mainCPP-3657">    bool deploy_probe_for_each_reading = code_seen('E');</front>
<front id="Marlin_mainCPP-3658"></front>
<front id="Marlin_mainCPP-3659">    if (code_seen('X')) {</front>
<front id="Marlin_mainCPP-3660">      X_probe_location = code_value() - X_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-3661">      if (X_probe_location &lt; X_MIN_POS || X_probe_location &gt; X_MAX_POS) {</front>
<front id="Marlin_mainCPP-3662">        out_of_range_error(PSTR("X"));</front>
<front id="Marlin_mainCPP-3663">        return;</front>
<front id="Marlin_mainCPP-3664">      }</front>
<front id="Marlin_mainCPP-3665">    }</front>
<front id="Marlin_mainCPP-3666"></front>
<front id="Marlin_mainCPP-3667">    if (code_seen('Y')) {</front>
<front id="Marlin_mainCPP-3668">      Y_probe_location = code_value() -  Y_PROBE_OFFSET_FROM_EXTRUDER;</front>
<front id="Marlin_mainCPP-3669">      if (Y_probe_location &lt; Y_MIN_POS || Y_probe_location &gt; Y_MAX_POS) {</front>
<front id="Marlin_mainCPP-3670">        out_of_range_error(PSTR("Y"));</front>
<front id="Marlin_mainCPP-3671">        return;</front>
<front id="Marlin_mainCPP-3672">      }</front>
<front id="Marlin_mainCPP-3673">    }</front>
<front id="Marlin_mainCPP-3674"></front>
<front id="Marlin_mainCPP-3675">    if (code_seen('L')) {</front>
<front id="Marlin_mainCPP-3676">      n_legs = code_value_short();</front>
<front id="Marlin_mainCPP-3677">      if (n_legs == 1) n_legs = 2;</front>
<front id="Marlin_mainCPP-3678">      if (n_legs &lt; 0 || n_legs &gt; 15) {</front>
<front id="Marlin_mainCPP-3679">        SERIAL_PROTOCOLPGM("?Number of legs in movement not plausible (0-15).\n");</front>
<front id="Marlin_mainCPP-3680">        return;</front>
<front id="Marlin_mainCPP-3681">      }</front>
<front id="Marlin_mainCPP-3682">    }</front>
<front id="Marlin_mainCPP-3683"></front>
<front id="Marlin_mainCPP-3684">    //</front>
<front id="Marlin_mainCPP-3685">    // Do all the preliminary setup work.   First raise the Z probe.</front>
<front id="Marlin_mainCPP-3686">    //</front>
<front id="Marlin_mainCPP-3687"></front>
<front id="Marlin_mainCPP-3688">    st_synchronize();</front>
<front id="Marlin_mainCPP-3689">    plan_bed_level_matrix.set_to_identity();</front>
<front id="Marlin_mainCPP-3690">    plan_buffer_line(X_current, Y_current, Z_start_location, E_current, homing_feedrate[Z_AXIS] / 60, active_extruder);</front>
<front id="Marlin_mainCPP-3691">    st_synchronize();</front>
<front id="Marlin_mainCPP-3692"></front>
<front id="Marlin_mainCPP-3693">    //</front>
<front id="Marlin_mainCPP-3694">    // Now get everything to the specified probe point So we can safely do a probe to</front>
<front id="Marlin_mainCPP-3695">    // get us close to the bed.  If the Z-Axis is far from the bed, we don't want to</front>
<front id="Marlin_mainCPP-3696">    // use that as a starting point for each probe.</front>
<front id="Marlin_mainCPP-3697">    //</front>
<front id="Marlin_mainCPP-3698">    if (verbose_level &gt; 2)</front>
<front id="Marlin_mainCPP-3699">      SERIAL_PROTOCOLPGM("Positioning the probe...\n");</front>
<front id="Marlin_mainCPP-3700"></front>
<front id="Marlin_mainCPP-3701">    plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,</front>
<front id="Marlin_mainCPP-3702">        E_current,</front>
<front id="Marlin_mainCPP-3703">        homing_feedrate[X_AXIS]/60,</front>
<front id="Marlin_mainCPP-3704">        active_extruder);</front>
<front id="Marlin_mainCPP-3705">    st_synchronize();</front>
<front id="Marlin_mainCPP-3706"></front>
<front id="Marlin_mainCPP-3707">    current_position[X_AXIS] = X_current = st_get_position_mm(X_AXIS);</front>
<front id="Marlin_mainCPP-3708">    current_position[Y_AXIS] = Y_current = st_get_position_mm(Y_AXIS);</front>
<front id="Marlin_mainCPP-3709">    current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-3710">    current_position[E_AXIS] = E_current = st_get_position_mm(E_AXIS);</front>
<front id="Marlin_mainCPP-3711"></front>
<front id="Marlin_mainCPP-3712">    //</front>
<front id="Marlin_mainCPP-3713">    // OK, do the initial probe to get us close to the bed.</front>
<front id="Marlin_mainCPP-3714">    // Then retrace the right amount and use that in subsequent probes</front>
<front id="Marlin_mainCPP-3715">    //</front>
<front id="Marlin_mainCPP-3716"></front>
<front id="Marlin_mainCPP-3717">    deploy_z_probe();</front>
<front id="Marlin_mainCPP-3718"></front>
<front id="Marlin_mainCPP-3719">    setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-3720">    run_z_probe();</front>
<front id="Marlin_mainCPP-3721"></front>
<front id="Marlin_mainCPP-3722">    current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-3723">    Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;</front>
<front id="Marlin_mainCPP-3724"></front>
<front id="Marlin_mainCPP-3725">    plan_buffer_line( X_probe_location, Y_probe_location, Z_start_location,</front>
<front id="Marlin_mainCPP-3726">        E_current,</front>
<front id="Marlin_mainCPP-3727">        homing_feedrate[X_AXIS]/60,</front>
<front id="Marlin_mainCPP-3728">        active_extruder);</front>
<front id="Marlin_mainCPP-3729">    st_synchronize();</front>
<front id="Marlin_mainCPP-3730">    current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);</front>
<front id="Marlin_mainCPP-3731"></front>
<front id="Marlin_mainCPP-3732">    if (deploy_probe_for_each_reading) stow_z_probe();</front>
<front id="Marlin_mainCPP-3733"></front>
<front id="Marlin_mainCPP-3734">    for (uint8_t n=0; n &lt; n_samples; n++) {</front>
<front id="Marlin_mainCPP-3735">      // Make sure we are at the probe location</front>
<front id="Marlin_mainCPP-3736">      do_blocking_move_to(X_probe_location, Y_probe_location, Z_start_location); // this also updates current_position</front>
<front id="Marlin_mainCPP-3737"></front>
<front id="Marlin_mainCPP-3738">      if (n_legs) {</front>
<front id="Marlin_mainCPP-3739">        millis_t ms = millis();</front>
<front id="Marlin_mainCPP-3740">        double radius = ms % (X_MAX_LENGTH / 4),       // limit how far out to go</front>
<front id="Marlin_mainCPP-3741">               theta = RADIANS(ms % 360L);</front>
<front id="Marlin_mainCPP-3742">        float dir = (ms & 0x0001) ? 1 : -1;            // clockwise or counter clockwise</front>
<front id="Marlin_mainCPP-3743"></front>
<front id="Marlin_mainCPP-3744">        //SERIAL_ECHOPAIR("starting radius: ",radius);</front>
<front id="Marlin_mainCPP-3745">        //SERIAL_ECHOPAIR("   theta: ",theta);</front>
<front id="Marlin_mainCPP-3746">        //SERIAL_ECHOPAIR("   direction: ",dir);</front>
<front id="Marlin_mainCPP-3747">        //SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3748"></front>
<front id="Marlin_mainCPP-3749">        for (uint8_t l = 0; l &lt; n_legs - 1; l++) {</front>
<front id="Marlin_mainCPP-3750">          ms = millis();</front>
<front id="Marlin_mainCPP-3751">          theta += RADIANS(dir * (ms % 20L));</front>
<front id="Marlin_mainCPP-3752">          radius += (ms % 10L) - 5L;</front>
<front id="Marlin_mainCPP-3753">          if (radius &lt; 0.0) radius = -radius;</front>
<front id="Marlin_mainCPP-3754"></front>
<front id="Marlin_mainCPP-3755">          X_current = X_probe_location + cos(theta) * radius;</front>
<front id="Marlin_mainCPP-3756">          X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);</front>
<front id="Marlin_mainCPP-3757">          Y_current = Y_probe_location + sin(theta) * radius;</front>
<front id="Marlin_mainCPP-3758">          Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);</front>
<front id="Marlin_mainCPP-3759"></front>
<front id="Marlin_mainCPP-3760">          if (verbose_level &gt; 3) {</front>
<front id="Marlin_mainCPP-3761">            SERIAL_ECHOPAIR("x: ", X_current);</front>
<front id="Marlin_mainCPP-3762">            SERIAL_ECHOPAIR("y: ", Y_current);</front>
<front id="Marlin_mainCPP-3763">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3764">          }</front>
<front id="Marlin_mainCPP-3765"></front>
<front id="Marlin_mainCPP-3766">          do_blocking_move_to(X_current, Y_current, Z_current); // this also updates current_position</front>
<front id="Marlin_mainCPP-3767"></front>
<front id="Marlin_mainCPP-3768">        } // n_legs loop</front>
<front id="Marlin_mainCPP-3769"></front>
<front id="Marlin_mainCPP-3770">        // Go back to the probe location</front>
<front id="Marlin_mainCPP-3771">        do_blocking_move_to(X_probe_location, Y_probe_location, Z_start_location); // this also updates current_position</front>
<front id="Marlin_mainCPP-3772"></front>
<front id="Marlin_mainCPP-3773">      } // n_legs</front>
<front id="Marlin_mainCPP-3774"></front>
<front id="Marlin_mainCPP-3775">      if (deploy_probe_for_each_reading)  {</front>
<front id="Marlin_mainCPP-3776">        deploy_z_probe();</front>
<front id="Marlin_mainCPP-3777">        delay(1000);</front>
<front id="Marlin_mainCPP-3778">      }</front>
<front id="Marlin_mainCPP-3779"></front>
<front id="Marlin_mainCPP-3780">      setup_for_endstop_move();</front>
<front id="Marlin_mainCPP-3781">      run_z_probe();</front>
<front id="Marlin_mainCPP-3782"></front>
<front id="Marlin_mainCPP-3783">      sample_set[n] = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-3784"></front>
<front id="Marlin_mainCPP-3785">      //</front>
<front id="Marlin_mainCPP-3786">      // Get the current mean for the data points we have so far</front>
<front id="Marlin_mainCPP-3787">      //</front>
<front id="Marlin_mainCPP-3788">      sum = 0.0;</front>
<front id="Marlin_mainCPP-3789">      for (uint8_t j = 0; j &lt;= n; j++) sum += sample_set[j];</front>
<front id="Marlin_mainCPP-3790">      mean = sum / (n + 1);</front>
<front id="Marlin_mainCPP-3791"></front>
<front id="Marlin_mainCPP-3792">      //</front>
<front id="Marlin_mainCPP-3793">      // Now, use that mean to calculate the standard deviation for the</front>
<front id="Marlin_mainCPP-3794">      // data points we have so far</front>
<front id="Marlin_mainCPP-3795">      //</front>
<front id="Marlin_mainCPP-3796">      sum = 0.0;</front>
<front id="Marlin_mainCPP-3797">      for (uint8_t j = 0; j &lt;= n; j++) {</front>
<front id="Marlin_mainCPP-3798">        float ss = sample_set[j] - mean;</front>
<front id="Marlin_mainCPP-3799">        sum += ss * ss;</front>
<front id="Marlin_mainCPP-3800">      }</front>
<front id="Marlin_mainCPP-3801">      sigma = sqrt(sum / (n + 1));</front>
<front id="Marlin_mainCPP-3802"></front>
<front id="Marlin_mainCPP-3803">      if (verbose_level &gt; 1) {</front>
<front id="Marlin_mainCPP-3804">        SERIAL_PROTOCOL(n+1);</front>
<front id="Marlin_mainCPP-3805">        SERIAL_PROTOCOLPGM(" of ");</front>
<front id="Marlin_mainCPP-3806">        SERIAL_PROTOCOL((int)n_samples);</front>
<front id="Marlin_mainCPP-3807">        SERIAL_PROTOCOLPGM("   z: ");</front>
<front id="Marlin_mainCPP-3808">        SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);</front>
<front id="Marlin_mainCPP-3809">        if (verbose_level &gt; 2) {</front>
<front id="Marlin_mainCPP-3810">          SERIAL_PROTOCOLPGM(" mean: ");</front>
<front id="Marlin_mainCPP-3811">          SERIAL_PROTOCOL_F(mean,6);</front>
<front id="Marlin_mainCPP-3812">          SERIAL_PROTOCOLPGM("   sigma: ");</front>
<front id="Marlin_mainCPP-3813">          SERIAL_PROTOCOL_F(sigma,6);</front>
<front id="Marlin_mainCPP-3814">        }</front>
<front id="Marlin_mainCPP-3815">      }</front>
<front id="Marlin_mainCPP-3816"></front>
<front id="Marlin_mainCPP-3817">      if (verbose_level &gt; 0) SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3818"></front>
<front id="Marlin_mainCPP-3819">      plan_buffer_line(X_probe_location, Y_probe_location, Z_start_location, current_position[E_AXIS], homing_feedrate[Z_AXIS]/60, active_extruder);</front>
<front id="Marlin_mainCPP-3820">      st_synchronize();</front>
<front id="Marlin_mainCPP-3821"></front>
<front id="Marlin_mainCPP-3822">      // Stow between</front>
<front id="Marlin_mainCPP-3823">      if (deploy_probe_for_each_reading) {</front>
<front id="Marlin_mainCPP-3824">        stow_z_probe();</front>
<front id="Marlin_mainCPP-3825">        delay(1000);</front>
<front id="Marlin_mainCPP-3826">      }</front>
<front id="Marlin_mainCPP-3827">    }</front>
<front id="Marlin_mainCPP-3828"></front>
<front id="Marlin_mainCPP-3829">    // Stow after</front>
<front id="Marlin_mainCPP-3830">    if (!deploy_probe_for_each_reading) {</front>
<front id="Marlin_mainCPP-3831">      stow_z_probe();</front>
<front id="Marlin_mainCPP-3832">      delay(1000);</front>
<front id="Marlin_mainCPP-3833">    }</front>
<front id="Marlin_mainCPP-3834"></front>
<front id="Marlin_mainCPP-3835">    clean_up_after_endstop_move();</front>
<front id="Marlin_mainCPP-3836"></front>
<front id="Marlin_mainCPP-3837">    if (verbose_level &gt; 0) {</front>
<front id="Marlin_mainCPP-3838">      SERIAL_PROTOCOLPGM("Mean: ");</front>
<front id="Marlin_mainCPP-3839">      SERIAL_PROTOCOL_F(mean, 6);</front>
<front id="Marlin_mainCPP-3840">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3841">    }</front>
<front id="Marlin_mainCPP-3842"></front>
<front id="Marlin_mainCPP-3843">    SERIAL_PROTOCOLPGM("Standard Deviation: ");</front>
<front id="Marlin_mainCPP-3844">    SERIAL_PROTOCOL_F(sigma, 6);</front>
<front id="Marlin_mainCPP-3845">    SERIAL_EOL; SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3846">  }</front>
<front id="Marlin_mainCPP-3847"></front>
<front id="Marlin_mainCPP-3848">#endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST</front>
<front id="Marlin_mainCPP-3849"></front>
<front id="Marlin_mainCPP-3850">/**</front>
<front id="Marlin_mainCPP-3851"> * M104: Set hot end temperature</front>
<front id="Marlin_mainCPP-3852"> */</front>
<front id="Marlin_mainCPP-3853">inline void gcode_M104() {</front>
<front id="Marlin_mainCPP-3854">  if (setTargetedHotend(104)) return;</front>
<front id="Marlin_mainCPP-3855">  if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-3856"></front>
<front id="Marlin_mainCPP-3857">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-3858">    float temp = code_value();</front>
<front id="Marlin_mainCPP-3859">    setTargetHotend(temp, target_extruder);</front>
<front id="Marlin_mainCPP-3860">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-3861">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)</front>
<front id="Marlin_mainCPP-3862">        setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-3863">    #endif</front>
<front id="Marlin_mainCPP-3864">  }</front>
<front id="Marlin_mainCPP-3865">}</front>
<front id="Marlin_mainCPP-3866"></front>
<front id="Marlin_mainCPP-3867">/**</front>
<front id="Marlin_mainCPP-3868"> * M105: Read hot end and bed temperature</front>
<front id="Marlin_mainCPP-3869"> */</front>
<front id="Marlin_mainCPP-3870">inline void gcode_M105() {</front>
<front id="Marlin_mainCPP-3871">  if (setTargetedHotend(105)) return;</front>
<front id="Marlin_mainCPP-3872"></front>
<front id="Marlin_mainCPP-3873">  #if HAS_TEMP_0 || HAS_TEMP_BED || ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="Marlin_mainCPP-3874">    SERIAL_PROTOCOLPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-3875">    #if HAS_TEMP_0 || ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="Marlin_mainCPP-3876">      SERIAL_PROTOCOLPGM(" T:");</front>
<front id="Marlin_mainCPP-3877">      SERIAL_PROTOCOL_F(degHotend(target_extruder), 1);</front>
<front id="Marlin_mainCPP-3878">      SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-3879">      SERIAL_PROTOCOL_F(degTargetHotend(target_extruder), 1);</front>
<front id="Marlin_mainCPP-3880">    #endif</front>
<front id="Marlin_mainCPP-3881">    #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-3882">      SERIAL_PROTOCOLPGM(" B:");</front>
<front id="Marlin_mainCPP-3883">      SERIAL_PROTOCOL_F(degBed(), 1);</front>
<front id="Marlin_mainCPP-3884">      SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-3885">      SERIAL_PROTOCOL_F(degTargetBed(), 1);</front>
<front id="Marlin_mainCPP-3886">    #endif</front>
<front id="Marlin_mainCPP-3887">    for (int8_t e = 0; e &lt; EXTRUDERS; ++e) {</front>
<front id="Marlin_mainCPP-3888">      SERIAL_PROTOCOLPGM(" T");</front>
<front id="Marlin_mainCPP-3889">      SERIAL_PROTOCOL(e);</front>
<front id="Marlin_mainCPP-3890">      SERIAL_PROTOCOLCHAR(':');</front>
<front id="Marlin_mainCPP-3891">      SERIAL_PROTOCOL_F(degHotend(e), 1);</front>
<front id="Marlin_mainCPP-3892">      SERIAL_PROTOCOLPGM(" /");</front>
<front id="Marlin_mainCPP-3893">      SERIAL_PROTOCOL_F(degTargetHotend(e), 1);</front>
<front id="Marlin_mainCPP-3894">    }</front>
<front id="Marlin_mainCPP-3895">  #else // !HAS_TEMP_0 && !HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-3896">    SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-3897">    SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);</front>
<front id="Marlin_mainCPP-3898">  #endif</front>
<front id="Marlin_mainCPP-3899"></front>
<front id="Marlin_mainCPP-3900">  SERIAL_PROTOCOLPGM(" @:");</front>
<front id="Marlin_mainCPP-3901">  #ifdef EXTRUDER_WATTS</front>
<front id="Marlin_mainCPP-3902">    SERIAL_PROTOCOL((EXTRUDER_WATTS * getHeaterPower(target_extruder))/127);</front>
<front id="Marlin_mainCPP-3903">    SERIAL_PROTOCOLCHAR('W');</front>
<front id="Marlin_mainCPP-3904">  #else</front>
<front id="Marlin_mainCPP-3905">    SERIAL_PROTOCOL(getHeaterPower(target_extruder));</front>
<front id="Marlin_mainCPP-3906">  #endif</front>
<front id="Marlin_mainCPP-3907"></front>
<front id="Marlin_mainCPP-3908">  SERIAL_PROTOCOLPGM(" B@:");</front>
<front id="Marlin_mainCPP-3909">  #ifdef BED_WATTS</front>
<front id="Marlin_mainCPP-3910">    SERIAL_PROTOCOL((BED_WATTS * getHeaterPower(-1))/127);</front>
<front id="Marlin_mainCPP-3911">    SERIAL_PROTOCOLCHAR('W');</front>
<front id="Marlin_mainCPP-3912">  #else</front>
<front id="Marlin_mainCPP-3913">    SERIAL_PROTOCOL(getHeaterPower(-1));</front>
<front id="Marlin_mainCPP-3914">  #endif</front>
<front id="Marlin_mainCPP-3915"></front>
<front id="Marlin_mainCPP-3916">  #if ENABLED(SHOW_TEMP_ADC_VALUES)</front>
<front id="Marlin_mainCPP-3917">    #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-3918">      SERIAL_PROTOCOLPGM("    ADC B:");</front>
<front id="Marlin_mainCPP-3919">      SERIAL_PROTOCOL_F(degBed(),1);</front>
<front id="Marlin_mainCPP-3920">      SERIAL_PROTOCOLPGM("C-&gt;");</front>
<front id="Marlin_mainCPP-3921">      SERIAL_PROTOCOL_F(rawBedTemp()/OVERSAMPLENR,0);</front>
<front id="Marlin_mainCPP-3922">    #endif</front>
<front id="Marlin_mainCPP-3923">    for (int8_t cur_extruder = 0; cur_extruder &lt; EXTRUDERS; ++cur_extruder) {</front>
<front id="Marlin_mainCPP-3924">      SERIAL_PROTOCOLPGM("  T");</front>
<front id="Marlin_mainCPP-3925">      SERIAL_PROTOCOL(cur_extruder);</front>
<front id="Marlin_mainCPP-3926">      SERIAL_PROTOCOLCHAR(':');</front>
<front id="Marlin_mainCPP-3927">      SERIAL_PROTOCOL_F(degHotend(cur_extruder),1);</front>
<front id="Marlin_mainCPP-3928">      SERIAL_PROTOCOLPGM("C-&gt;");</front>
<front id="Marlin_mainCPP-3929">      SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder)/OVERSAMPLENR,0);</front>
<front id="Marlin_mainCPP-3930">    }</front>
<front id="Marlin_mainCPP-3931">  #endif</front>
<front id="Marlin_mainCPP-3932"></front>
<front id="Marlin_mainCPP-3933">  SERIAL_EOL;</front>
<front id="Marlin_mainCPP-3934">}</front>
<front id="Marlin_mainCPP-3935"></front>
<front id="Marlin_mainCPP-3936">#if HAS_FAN</front>
<front id="Marlin_mainCPP-3937"></front>
<front id="Marlin_mainCPP-3938">  /**</front>
<front id="Marlin_mainCPP-3939">   * M106: Set Fan Speed</front>
<front id="Marlin_mainCPP-3940">   */</front>
<front id="Marlin_mainCPP-3941">  inline void gcode_M106() { fanSpeed = code_seen('S') ? constrain(code_value_short(), 0, 255) : 255; }</front>
<front id="Marlin_mainCPP-3942"></front>
<front id="Marlin_mainCPP-3943">  /**</front>
<front id="Marlin_mainCPP-3944">   * M107: Fan Off</front>
<front id="Marlin_mainCPP-3945">   */</front>
<front id="Marlin_mainCPP-3946">  inline void gcode_M107() { fanSpeed = 0; }</front>
<front id="Marlin_mainCPP-3947"></front>
<front id="Marlin_mainCPP-3948">#endif // HAS_FAN</front>
<front id="Marlin_mainCPP-3949"></front>
<front id="Marlin_mainCPP-3950">/**</front>
<front id="Marlin_mainCPP-3951"> * M109: Wait for extruder(s) to reach temperature</front>
<front id="Marlin_mainCPP-3952"> */</front>
<front id="Marlin_mainCPP-3953">inline void gcode_M109() {</front>
<front id="Marlin_mainCPP-3954">  if (setTargetedHotend(109)) return;</front>
<front id="Marlin_mainCPP-3955">  if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-3956"></front>
<front id="Marlin_mainCPP-3957">  LCD_MESSAGEPGM(MSG_HEATING);</front>
<front id="Marlin_mainCPP-3958"></front>
<front id="Marlin_mainCPP-3959">  no_wait_for_cooling = code_seen('S');</front>
<front id="Marlin_mainCPP-3960">  if (no_wait_for_cooling || code_seen('R')) {</front>
<front id="Marlin_mainCPP-3961">    float temp = code_value();</front>
<front id="Marlin_mainCPP-3962">    setTargetHotend(temp, target_extruder);</front>
<front id="Marlin_mainCPP-3963">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-3964">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)</front>
<front id="Marlin_mainCPP-3965">        setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);</front>
<front id="Marlin_mainCPP-3966">    #endif</front>
<front id="Marlin_mainCPP-3967">  }</front>
<front id="Marlin_mainCPP-3968"></front>
<front id="Marlin_mainCPP-3969">  #if ENABLED(AUTOTEMP)</front>
<front id="Marlin_mainCPP-3970">    autotemp_enabled = code_seen('F');</front>
<front id="Marlin_mainCPP-3971">    if (autotemp_enabled) autotemp_factor = code_value();</front>
<front id="Marlin_mainCPP-3972">    if (code_seen('S')) autotemp_min = code_value();</front>
<front id="Marlin_mainCPP-3973">    if (code_seen('B')) autotemp_max = code_value();</front>
<front id="Marlin_mainCPP-3974">  #endif</front>
<front id="Marlin_mainCPP-3975"></front>
<front id="Marlin_mainCPP-3976">  millis_t temp_ms = millis();</front>
<front id="Marlin_mainCPP-3977"></front>
<front id="Marlin_mainCPP-3978">  /* See if we are heating up or cooling down */</front>
<front id="Marlin_mainCPP-3979">  target_direction = isHeatingHotend(target_extruder); // true if heating, false if cooling</front>
<front id="Marlin_mainCPP-3980"></front>
<front id="Marlin_mainCPP-3981">  cancel_heatup = false;</front>
<front id="Marlin_mainCPP-3982"></front>
<front id="Marlin_mainCPP-3983">  #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-3984">    long residency_start_ms = -1;</front>
<front id="Marlin_mainCPP-3985">    /* continue to loop until we have reached the target temp</front>
<front id="Marlin_mainCPP-3986">      _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */</front>
<front id="Marlin_mainCPP-3987">    while((!cancel_heatup)&&((residency_start_ms == -1) ||</front>
<front id="Marlin_mainCPP-3988">          (residency_start_ms &gt;= 0 && (((unsigned int) (millis() - residency_start_ms)) &lt; (TEMP_RESIDENCY_TIME * 1000UL)))) )</front>
<front id="Marlin_mainCPP-3989">  #else</front>
<front id="Marlin_mainCPP-3990">    while ( target_direction ? (isHeatingHotend(target_extruder)) : (isCoolingHotend(target_extruder)&&(no_wait_for_cooling==false)) )</front>
<front id="Marlin_mainCPP-3991">  #endif //TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-3992"></front>
<front id="Marlin_mainCPP-3993">    { // while loop</front>
<front id="Marlin_mainCPP-3994">      if (millis() &gt; temp_ms + 1000UL) { //Print temp & remaining time every 1s while waiting</front>
<front id="Marlin_mainCPP-3995">        SERIAL_PROTOCOLPGM("T:");</front>
<front id="Marlin_mainCPP-3996">        SERIAL_PROTOCOL_F(degHotend(target_extruder),1);</front>
<front id="Marlin_mainCPP-3997">        SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-3998">        SERIAL_PROTOCOL((int)target_extruder);</front>
<front id="Marlin_mainCPP-3999">        #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-4000">          SERIAL_PROTOCOLPGM(" W:");</front>
<front id="Marlin_mainCPP-4001">          if (residency_start_ms &gt; -1) {</front>
<front id="Marlin_mainCPP-4002">            temp_ms = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residency_start_ms)) / 1000UL;</front>
<front id="Marlin_mainCPP-4003">            SERIAL_PROTOCOLLN(temp_ms);</front>
<front id="Marlin_mainCPP-4004">          }</front>
<front id="Marlin_mainCPP-4005">          else {</front>
<front id="Marlin_mainCPP-4006">            SERIAL_PROTOCOLLNPGM("?");</front>
<front id="Marlin_mainCPP-4007">          }</front>
<front id="Marlin_mainCPP-4008">        #else</front>
<front id="Marlin_mainCPP-4009">          SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4010">        #endif</front>
<front id="Marlin_mainCPP-4011">        temp_ms = millis();</front>
<front id="Marlin_mainCPP-4012">      }</front>
<front id="Marlin_mainCPP-4013"></front>
<front id="Marlin_mainCPP-4014">      idle();</front>
<front id="Marlin_mainCPP-4015"></front>
<front id="Marlin_mainCPP-4016">      #ifdef TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-4017">        // start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time</front>
<front id="Marlin_mainCPP-4018">        // or when current temp falls outside the hysteresis after target temp was reached</front>
<front id="Marlin_mainCPP-4019">        if ((residency_start_ms == -1 &&  target_direction && (degHotend(target_extruder) &gt;= (degTargetHotend(target_extruder)-TEMP_WINDOW))) ||</front>
<front id="Marlin_mainCPP-4020">            (residency_start_ms == -1 && !target_direction && (degHotend(target_extruder) &lt;= (degTargetHotend(target_extruder)+TEMP_WINDOW))) ||</front>
<front id="Marlin_mainCPP-4021">            (residency_start_ms &gt; -1 && labs(degHotend(target_extruder) - degTargetHotend(target_extruder)) &gt; TEMP_HYSTERESIS) )</front>
<front id="Marlin_mainCPP-4022">        {</front>
<front id="Marlin_mainCPP-4023">          residency_start_ms = millis();</front>
<front id="Marlin_mainCPP-4024">        }</front>
<front id="Marlin_mainCPP-4025">      #endif //TEMP_RESIDENCY_TIME</front>
<front id="Marlin_mainCPP-4026">    }</front>
<front id="Marlin_mainCPP-4027"></front>
<front id="Marlin_mainCPP-4028">  LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);</front>
<front id="Marlin_mainCPP-4029">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-4030">  print_job_start_ms = previous_cmd_ms;</front>
<front id="Marlin_mainCPP-4031">}</front>
<front id="Marlin_mainCPP-4032"></front>
<front id="Marlin_mainCPP-4033">#if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-4034"></front>
<front id="Marlin_mainCPP-4035">  /**</front>
<front id="Marlin_mainCPP-4036">   * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating</front>
<front id="Marlin_mainCPP-4037">   *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</front>
<front id="Marlin_mainCPP-4038">   */</front>
<front id="Marlin_mainCPP-4039">  inline void gcode_M190() {</front>
<front id="Marlin_mainCPP-4040">    if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-4041"></front>
<front id="Marlin_mainCPP-4042">    LCD_MESSAGEPGM(MSG_BED_HEATING);</front>
<front id="Marlin_mainCPP-4043">    no_wait_for_cooling = code_seen('S');</front>
<front id="Marlin_mainCPP-4044">    if (no_wait_for_cooling || code_seen('R'))</front>
<front id="Marlin_mainCPP-4045">      setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-4046"></front>
<front id="Marlin_mainCPP-4047">    millis_t temp_ms = millis();</front>
<front id="Marlin_mainCPP-4048"></front>
<front id="Marlin_mainCPP-4049">    cancel_heatup = false;</front>
<front id="Marlin_mainCPP-4050">    target_direction = isHeatingBed(); // true if heating, false if cooling</front>
<front id="Marlin_mainCPP-4051"></front>
<front id="Marlin_mainCPP-4052">    while ((target_direction && !cancel_heatup) ? isHeatingBed() : isCoolingBed() && !no_wait_for_cooling) {</front>
<front id="Marlin_mainCPP-4053">      millis_t ms = millis();</front>
<front id="Marlin_mainCPP-4054">      if (ms &gt; temp_ms + 1000UL) { //Print Temp Reading every 1 second while heating up.</front>
<front id="Marlin_mainCPP-4055">        temp_ms = ms;</front>
<front id="Marlin_mainCPP-4056">        float tt = degHotend(active_extruder);</front>
<front id="Marlin_mainCPP-4057">        SERIAL_PROTOCOLPGM("T:");</front>
<front id="Marlin_mainCPP-4058">        SERIAL_PROTOCOL(tt);</front>
<front id="Marlin_mainCPP-4059">        SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-4060">        SERIAL_PROTOCOL((int)active_extruder);</front>
<front id="Marlin_mainCPP-4061">        SERIAL_PROTOCOLPGM(" B:");</front>
<front id="Marlin_mainCPP-4062">        SERIAL_PROTOCOL_F(degBed(), 1);</front>
<front id="Marlin_mainCPP-4063">        SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4064">      }</front>
<front id="Marlin_mainCPP-4065">      idle();</front>
<front id="Marlin_mainCPP-4066">    }</front>
<front id="Marlin_mainCPP-4067">    LCD_MESSAGEPGM(MSG_BED_DONE);</front>
<front id="Marlin_mainCPP-4068">    refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-4069">  }</front>
<front id="Marlin_mainCPP-4070"></front>
<front id="Marlin_mainCPP-4071">#endif // HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-4072"></front>
<front id="Marlin_mainCPP-4073">/**</front>
<front id="Marlin_mainCPP-4074"> * M111: Set the debug level</front>
<front id="Marlin_mainCPP-4075"> */</front>
<front id="Marlin_mainCPP-4076">inline void gcode_M111() {</front>
<front id="Marlin_mainCPP-4077">  marlin_debug_flags = code_seen('S') ? code_value_short() : DEBUG_INFO|DEBUG_COMMUNICATION;</front>
<front id="Marlin_mainCPP-4078"></front>
<front id="Marlin_mainCPP-4079">  if (marlin_debug_flags & DEBUG_ECHO) {</front>
<front id="Marlin_mainCPP-4080">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4081">    SERIAL_ECHOLNPGM(MSG_DEBUG_ECHO);</front>
<front id="Marlin_mainCPP-4082">  }</front>
<front id="Marlin_mainCPP-4083">  // FOR MOMENT NOT ACTIVE</front>
<front id="Marlin_mainCPP-4084">  //if (marlin_debug_flags & DEBUG_INFO) SERIAL_ECHOLNPGM(MSG_DEBUG_INFO);</front>
<front id="Marlin_mainCPP-4085">  //if (marlin_debug_flags & DEBUG_ERRORS) SERIAL_ECHOLNPGM(MSG_DEBUG_ERRORS);</front>
<front id="Marlin_mainCPP-4086">  if (marlin_debug_flags & DEBUG_DRYRUN) {</front>
<front id="Marlin_mainCPP-4087">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4088">    SERIAL_ECHOLNPGM(MSG_DEBUG_DRYRUN);</front>
<front id="Marlin_mainCPP-4089">    disable_all_heaters();</front>
<front id="Marlin_mainCPP-4090">  }</front>
<front id="Marlin_mainCPP-4091"></front>
<front id="Marlin_mainCPP-4092">  #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4093">    if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4094">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4095">      SERIAL_ECHOLNPGM(MSG_DEBUG_LEVELING);</front>
<front id="Marlin_mainCPP-4096">    }</front>
<front id="Marlin_mainCPP-4097">  #endif</front>
<front id="Marlin_mainCPP-4098">}</front>
<front id="Marlin_mainCPP-4099"></front>
<front id="Marlin_mainCPP-4100">/**</front>
<front id="Marlin_mainCPP-4101"> * M112: Emergency Stop</front>
<front id="Marlin_mainCPP-4102"> */</front>
<front id="Marlin_mainCPP-4103">inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }</front>
<front id="Marlin_mainCPP-4104"></front>
<front id="Marlin_mainCPP-4105">#if ENABLED(BARICUDA)</front>
<front id="Marlin_mainCPP-4106"></front>
<front id="Marlin_mainCPP-4107">  #if HAS_HEATER_1</front>
<front id="Marlin_mainCPP-4108">    /**</front>
<front id="Marlin_mainCPP-4109">     * M126: Heater 1 valve open</front>
<front id="Marlin_mainCPP-4110">     */</front>
<front id="Marlin_mainCPP-4111">    inline void gcode_M126() { ValvePressure = code_seen('S') ? constrain(code_value(), 0, 255) : 255; }</front>
<front id="Marlin_mainCPP-4112">    /**</front>
<front id="Marlin_mainCPP-4113">     * M127: Heater 1 valve close</front>
<front id="Marlin_mainCPP-4114">     */</front>
<front id="Marlin_mainCPP-4115">    inline void gcode_M127() { ValvePressure = 0; }</front>
<front id="Marlin_mainCPP-4116">  #endif</front>
<front id="Marlin_mainCPP-4117"></front>
<front id="Marlin_mainCPP-4118">  #if HAS_HEATER_2</front>
<front id="Marlin_mainCPP-4119">    /**</front>
<front id="Marlin_mainCPP-4120">     * M128: Heater 2 valve open</front>
<front id="Marlin_mainCPP-4121">     */</front>
<front id="Marlin_mainCPP-4122">    inline void gcode_M128() { EtoPPressure = code_seen('S') ? constrain(code_value(), 0, 255) : 255; }</front>
<front id="Marlin_mainCPP-4123">    /**</front>
<front id="Marlin_mainCPP-4124">     * M129: Heater 2 valve close</front>
<front id="Marlin_mainCPP-4125">     */</front>
<front id="Marlin_mainCPP-4126">    inline void gcode_M129() { EtoPPressure = 0; }</front>
<front id="Marlin_mainCPP-4127">  #endif</front>
<front id="Marlin_mainCPP-4128"></front>
<front id="Marlin_mainCPP-4129">#endif //BARICUDA</front>
<front id="Marlin_mainCPP-4130"></front>
<front id="Marlin_mainCPP-4131">/**</front>
<front id="Marlin_mainCPP-4132"> * M140: Set bed temperature</front>
<front id="Marlin_mainCPP-4133"> */</front>
<front id="Marlin_mainCPP-4134">inline void gcode_M140() {</front>
<front id="Marlin_mainCPP-4135">  if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-4136">  if (code_seen('S')) setTargetBed(code_value());</front>
<front id="Marlin_mainCPP-4137">}</front>
<front id="Marlin_mainCPP-4138"></front>
<front id="Marlin_mainCPP-4139">#if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-4140"></front>
<front id="Marlin_mainCPP-4141">  /**</front>
<front id="Marlin_mainCPP-4142">   * M145: Set the heatup state for a material in the LCD menu</front>
<front id="Marlin_mainCPP-4143">   *   S&lt;material&gt; (0=PLA, 1=ABS)</front>
<front id="Marlin_mainCPP-4144">   *   H&lt;hotend temp&gt;</front>
<front id="Marlin_mainCPP-4145">   *   B&lt;bed temp&gt;</front>
<front id="Marlin_mainCPP-4146">   *   F&lt;fan speed&gt;</front>
<front id="Marlin_mainCPP-4147">   */</front>
<front id="Marlin_mainCPP-4148">  inline void gcode_M145() {</front>
<front id="Marlin_mainCPP-4149">    uint8_t material = code_seen('S') ? code_value_short() : 0;</front>
<front id="Marlin_mainCPP-4150">    if (material &lt; 0 || material &gt; 1) {</front>
<front id="Marlin_mainCPP-4151">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-4152">      SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);</front>
<front id="Marlin_mainCPP-4153">    }</front>
<front id="Marlin_mainCPP-4154">    else {</front>
<front id="Marlin_mainCPP-4155">      int v;</front>
<front id="Marlin_mainCPP-4156">      switch (material) {</front>
<front id="Marlin_mainCPP-4157">        case 0:</front>
<front id="Marlin_mainCPP-4158">          if (code_seen('H')) {</front>
<front id="Marlin_mainCPP-4159">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4160">            plaPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4161">          }</front>
<front id="Marlin_mainCPP-4162">          if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-4163">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4164">            plaPreheatFanSpeed = constrain(v, 0, 255);</front>
<front id="Marlin_mainCPP-4165">          }</front>
<front id="Marlin_mainCPP-4166">          #if TEMP_SENSOR_BED != 0</front>
<front id="Marlin_mainCPP-4167">            if (code_seen('B')) {</front>
<front id="Marlin_mainCPP-4168">              v = code_value_short();</front>
<front id="Marlin_mainCPP-4169">              plaPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4170">            }</front>
<front id="Marlin_mainCPP-4171">          #endif</front>
<front id="Marlin_mainCPP-4172">          break;</front>
<front id="Marlin_mainCPP-4173">        case 1:</front>
<front id="Marlin_mainCPP-4174">          if (code_seen('H')) {</front>
<front id="Marlin_mainCPP-4175">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4176">            absPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4177">          }</front>
<front id="Marlin_mainCPP-4178">          if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-4179">            v = code_value_short();</front>
<front id="Marlin_mainCPP-4180">            absPreheatFanSpeed = constrain(v, 0, 255);</front>
<front id="Marlin_mainCPP-4181">          }</front>
<front id="Marlin_mainCPP-4182">          #if TEMP_SENSOR_BED != 0</front>
<front id="Marlin_mainCPP-4183">            if (code_seen('B')) {</front>
<front id="Marlin_mainCPP-4184">              v = code_value_short();</front>
<front id="Marlin_mainCPP-4185">              absPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="Marlin_mainCPP-4186">            }</front>
<front id="Marlin_mainCPP-4187">          #endif</front>
<front id="Marlin_mainCPP-4188">          break;</front>
<front id="Marlin_mainCPP-4189">      }</front>
<front id="Marlin_mainCPP-4190">    }</front>
<front id="Marlin_mainCPP-4191">  }</front>
<front id="Marlin_mainCPP-4192"></front>
<front id="Marlin_mainCPP-4193">#endif</front>
<front id="Marlin_mainCPP-4194"></front>
<front id="Marlin_mainCPP-4195">#if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4196"></front>
<front id="Marlin_mainCPP-4197">  /**</front>
<front id="Marlin_mainCPP-4198">   * M80: Turn on Power Supply</front>
<front id="Marlin_mainCPP-4199">   */</front>
<front id="Marlin_mainCPP-4200">  inline void gcode_M80() {</front>
<front id="Marlin_mainCPP-4201">    OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); //GND</front>
<front id="Marlin_mainCPP-4202"></front>
<front id="Marlin_mainCPP-4203">    // If you have a switch on suicide pin, this is useful</front>
<front id="Marlin_mainCPP-4204">    // if you want to start another print with suicide feature after</front>
<front id="Marlin_mainCPP-4205">    // a print without suicide...</front>
<front id="Marlin_mainCPP-4206">    #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-4207">      OUT_WRITE(SUICIDE_PIN, HIGH);</front>
<front id="Marlin_mainCPP-4208">    #endif</front>
<front id="Marlin_mainCPP-4209"></front>
<front id="Marlin_mainCPP-4210">    #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-4211">      powersupply = true;</front>
<front id="Marlin_mainCPP-4212">      LCD_MESSAGEPGM(WELCOME_MSG);</front>
<front id="Marlin_mainCPP-4213">      lcd_update();</front>
<front id="Marlin_mainCPP-4214">    #endif</front>
<front id="Marlin_mainCPP-4215">  }</front>
<front id="Marlin_mainCPP-4216"></front>
<front id="Marlin_mainCPP-4217">#endif // HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4218"></front>
<front id="Marlin_mainCPP-4219">/**</front>
<front id="Marlin_mainCPP-4220"> * M81: Turn off Power, including Power Supply, if there is one.</front>
<front id="Marlin_mainCPP-4221"> *</front>
<front id="Marlin_mainCPP-4222"> *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!</front>
<front id="Marlin_mainCPP-4223"> */</front>
<front id="Marlin_mainCPP-4224">inline void gcode_M81() {</front>
<front id="Marlin_mainCPP-4225">  disable_all_heaters();</front>
<front id="Marlin_mainCPP-4226">  finishAndDisableSteppers();</front>
<front id="Marlin_mainCPP-4227">  fanSpeed = 0;</front>
<front id="Marlin_mainCPP-4228">  delay(1000); // Wait 1 second before switching off</front>
<front id="Marlin_mainCPP-4229">  #if HAS_SUICIDE</front>
<front id="Marlin_mainCPP-4230">    st_synchronize();</front>
<front id="Marlin_mainCPP-4231">    suicide();</front>
<front id="Marlin_mainCPP-4232">  #elif HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4233">    OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);</front>
<front id="Marlin_mainCPP-4234">  #endif</front>
<front id="Marlin_mainCPP-4235">  #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-4236">    #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-4237">      powersupply = false;</front>
<front id="Marlin_mainCPP-4238">    #endif</front>
<front id="Marlin_mainCPP-4239">    LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");</front>
<front id="Marlin_mainCPP-4240">    lcd_update();</front>
<front id="Marlin_mainCPP-4241">  #endif</front>
<front id="Marlin_mainCPP-4242">}</front>
<front id="Marlin_mainCPP-4243"></front>
<front id="Marlin_mainCPP-4244"></front>
<front id="Marlin_mainCPP-4245">/**</front>
<front id="Marlin_mainCPP-4246"> * M82: Set E codes absolute (default)</front>
<front id="Marlin_mainCPP-4247"> */</front>
<front id="Marlin_mainCPP-4248">inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }</front>
<front id="Marlin_mainCPP-4249"></front>
<front id="Marlin_mainCPP-4250">/**</front>
<front id="Marlin_mainCPP-4251"> * M83: Set E codes relative while in Absolute Coordinates (G90) mode</front>
<front id="Marlin_mainCPP-4252"> */</front>
<front id="Marlin_mainCPP-4253">inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }</front>
<front id="Marlin_mainCPP-4254"></front>
<front id="Marlin_mainCPP-4255">/**</front>
<front id="Marlin_mainCPP-4256"> * M18, M84: Disable all stepper motors</front>
<front id="Marlin_mainCPP-4257"> */</front>
<front id="Marlin_mainCPP-4258">inline void gcode_M18_M84() {</front>
<front id="Marlin_mainCPP-4259">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4260">    stepper_inactive_time = code_value() * 1000;</front>
<front id="Marlin_mainCPP-4261">  }</front>
<front id="Marlin_mainCPP-4262">  else {</front>
<front id="Marlin_mainCPP-4263">    bool all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS]))|| (code_seen(axis_codes[E_AXIS])));</front>
<front id="Marlin_mainCPP-4264">    if (all_axis) {</front>
<front id="Marlin_mainCPP-4265">      finishAndDisableSteppers();</front>
<front id="Marlin_mainCPP-4266">    }</front>
<front id="Marlin_mainCPP-4267">    else {</front>
<front id="Marlin_mainCPP-4268">      st_synchronize();</front>
<front id="Marlin_mainCPP-4269">      if (code_seen('X')) disable_x();</front>
<front id="Marlin_mainCPP-4270">      if (code_seen('Y')) disable_y();</front>
<front id="Marlin_mainCPP-4271">      if (code_seen('Z')) disable_z();</front>
<front id="Marlin_mainCPP-4272">      #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS</front>
<front id="Marlin_mainCPP-4273">        if (code_seen('E')) {</front>
<front id="Marlin_mainCPP-4274">          disable_e0();</front>
<front id="Marlin_mainCPP-4275">          disable_e1();</front>
<front id="Marlin_mainCPP-4276">          disable_e2();</front>
<front id="Marlin_mainCPP-4277">          disable_e3();</front>
<front id="Marlin_mainCPP-4278">        }</front>
<front id="Marlin_mainCPP-4279">      #endif</front>
<front id="Marlin_mainCPP-4280">    }</front>
<front id="Marlin_mainCPP-4281">  }</front>
<front id="Marlin_mainCPP-4282">}</front>
<front id="Marlin_mainCPP-4283"></front>
<front id="Marlin_mainCPP-4284">/**</front>
<front id="Marlin_mainCPP-4285"> * M85: Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</front>
<front id="Marlin_mainCPP-4286"> */</front>
<front id="Marlin_mainCPP-4287">inline void gcode_M85() {</front>
<front id="Marlin_mainCPP-4288">  if (code_seen('S')) max_inactive_time = code_value() * 1000;</front>
<front id="Marlin_mainCPP-4289">}</front>
<front id="Marlin_mainCPP-4290"></front>
<front id="Marlin_mainCPP-4291">/**</front>
<front id="Marlin_mainCPP-4292"> * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.</front>
<front id="Marlin_mainCPP-4293"> *      (Follows the same syntax as G92)</front>
<front id="Marlin_mainCPP-4294"> */</front>
<front id="Marlin_mainCPP-4295">inline void gcode_M92() {</front>
<front id="Marlin_mainCPP-4296">  for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4297">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4298">      if (i == E_AXIS) {</front>
<front id="Marlin_mainCPP-4299">        float value = code_value();</front>
<front id="Marlin_mainCPP-4300">        if (value &lt; 20.0) {</front>
<front id="Marlin_mainCPP-4301">          float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.</front>
<front id="Marlin_mainCPP-4302">          max_e_jerk *= factor;</front>
<front id="Marlin_mainCPP-4303">          max_feedrate[i] *= factor;</front>
<front id="Marlin_mainCPP-4304">          axis_steps_per_sqr_second[i] *= factor;</front>
<front id="Marlin_mainCPP-4305">        }</front>
<front id="Marlin_mainCPP-4306">        axis_steps_per_unit[i] = value;</front>
<front id="Marlin_mainCPP-4307">      }</front>
<front id="Marlin_mainCPP-4308">      else {</front>
<front id="Marlin_mainCPP-4309">        axis_steps_per_unit[i] = code_value();</front>
<front id="Marlin_mainCPP-4310">      }</front>
<front id="Marlin_mainCPP-4311">    }</front>
<front id="Marlin_mainCPP-4312">  }</front>
<front id="Marlin_mainCPP-4313">}</front>
<front id="Marlin_mainCPP-4314"></front>
<front id="Marlin_mainCPP-4315">/**</front>
<front id="Marlin_mainCPP-4316"> * M114: Output current position to serial port</front>
<front id="Marlin_mainCPP-4317"> */</front>
<front id="Marlin_mainCPP-4318">inline void gcode_M114() {</front>
<front id="Marlin_mainCPP-4319">  SERIAL_PROTOCOLPGM("X:");</front>
<front id="Marlin_mainCPP-4320">  SERIAL_PROTOCOL(current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-4321">  SERIAL_PROTOCOLPGM(" Y:");</front>
<front id="Marlin_mainCPP-4322">  SERIAL_PROTOCOL(current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4323">  SERIAL_PROTOCOLPGM(" Z:");</front>
<front id="Marlin_mainCPP-4324">  SERIAL_PROTOCOL(current_position[Z_AXIS]);</front>
<front id="Marlin_mainCPP-4325">  SERIAL_PROTOCOLPGM(" E:");</front>
<front id="Marlin_mainCPP-4326">  SERIAL_PROTOCOL(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-4327"></front>
<front id="Marlin_mainCPP-4328">  SERIAL_PROTOCOLPGM(MSG_COUNT_X);</front>
<front id="Marlin_mainCPP-4329">  SERIAL_PROTOCOL(st_get_position_mm(X_AXIS));</front>
<front id="Marlin_mainCPP-4330">  SERIAL_PROTOCOLPGM(" Y:");</front>
<front id="Marlin_mainCPP-4331">  SERIAL_PROTOCOL(st_get_position_mm(Y_AXIS));</front>
<front id="Marlin_mainCPP-4332">  SERIAL_PROTOCOLPGM(" Z:");</front>
<front id="Marlin_mainCPP-4333">  SERIAL_PROTOCOL(st_get_position_mm(Z_AXIS));</front>
<front id="Marlin_mainCPP-4334"></front>
<front id="Marlin_mainCPP-4335">  #if ENABLED(TRACK_LAYER)</front>
<front id="Marlin_mainCPP-4336">    SERIAL_PROTOCOLPGM("  Layer:");</front>
<front id="Marlin_mainCPP-4337">    SERIAL_PROTOCOL(current_layer);</front>
<front id="Marlin_mainCPP-4338">    SERIAL_PROTOCOLLN("");</front>
<front id="Marlin_mainCPP-4339">  #endif //TRACK_LAYER</front>
<front id="Marlin_mainCPP-4340"></front>
<front id="Marlin_mainCPP-4341">  SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4342"></front>
<front id="Marlin_mainCPP-4343">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-4344">    SERIAL_PROTOCOLPGM("SCARA Theta:");</front>
<front id="Marlin_mainCPP-4345">    SERIAL_PROTOCOL(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-4346">    SERIAL_PROTOCOLPGM("   Psi+Theta:");</front>
<front id="Marlin_mainCPP-4347">    SERIAL_PROTOCOL(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4348">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4349"></front>
<front id="Marlin_mainCPP-4350">    SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");</front>
<front id="Marlin_mainCPP-4351">    SERIAL_PROTOCOL(delta[X_AXIS]+home_offset[X_AXIS]);</front>
<front id="Marlin_mainCPP-4352">    SERIAL_PROTOCOLPGM("   Psi+Theta (90):");</front>
<front id="Marlin_mainCPP-4353">    SERIAL_PROTOCOL(delta[Y_AXIS]-delta[X_AXIS]-90+home_offset[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4354">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4355"></front>
<front id="Marlin_mainCPP-4356">    SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");</front>
<front id="Marlin_mainCPP-4357">    SERIAL_PROTOCOL(delta[X_AXIS]/90*axis_steps_per_unit[X_AXIS]);</front>
<front id="Marlin_mainCPP-4358">    SERIAL_PROTOCOLPGM("   Psi+Theta:");</front>
<front id="Marlin_mainCPP-4359">    SERIAL_PROTOCOL((delta[Y_AXIS]-delta[X_AXIS])/90*axis_steps_per_unit[Y_AXIS]);</front>
<front id="Marlin_mainCPP-4360">    SERIAL_EOL; SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4361">  #endif</front>
<front id="Marlin_mainCPP-4362">}</front>
<front id="Marlin_mainCPP-4363"></front>
<front id="Marlin_mainCPP-4364">/**</front>
<front id="Marlin_mainCPP-4365"> * M115: Capabilities string</front>
<front id="Marlin_mainCPP-4366"> */</front>
<front id="Marlin_mainCPP-4367">inline void gcode_M115() {</front>
<front id="Marlin_mainCPP-4368">  SERIAL_PROTOCOLPGM(MSG_M115_REPORT);</front>
<front id="Marlin_mainCPP-4369">}</front>
<front id="Marlin_mainCPP-4370"></front>
<front id="Marlin_mainCPP-4371">/**</front>
<front id="Marlin_mainCPP-4372"> * M117: Set LCD Status Message</front>
<front id="Marlin_mainCPP-4373"> */</front>
<front id="Marlin_mainCPP-4374">inline void gcode_M117() {</front>
<front id="Marlin_mainCPP-4375">  lcd_setstatus(current_command_args);</front>
<front id="Marlin_mainCPP-4376">}</front>
<front id="Marlin_mainCPP-4377"></front>
<front id="Marlin_mainCPP-4378">/**</front>
<front id="Marlin_mainCPP-4379"> * M119: Output endstop states to serial output</front>
<front id="Marlin_mainCPP-4380"> */</front>
<front id="Marlin_mainCPP-4381">inline void gcode_M119() {</front>
<front id="Marlin_mainCPP-4382">  SERIAL_PROTOCOLLN(MSG_M119_REPORT);</front>
<front id="Marlin_mainCPP-4383">  #if HAS_X_MIN</front>
<front id="Marlin_mainCPP-4384">    SERIAL_PROTOCOLPGM(MSG_X_MIN);</front>
<front id="Marlin_mainCPP-4385">    SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4386">  #endif</front>
<front id="Marlin_mainCPP-4387">  #if HAS_X_MAX</front>
<front id="Marlin_mainCPP-4388">    SERIAL_PROTOCOLPGM(MSG_X_MAX);</front>
<front id="Marlin_mainCPP-4389">    SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4390">  #endif</front>
<front id="Marlin_mainCPP-4391">  #if HAS_Y_MIN</front>
<front id="Marlin_mainCPP-4392">    SERIAL_PROTOCOLPGM(MSG_Y_MIN);</front>
<front id="Marlin_mainCPP-4393">    SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4394">  #endif</front>
<front id="Marlin_mainCPP-4395">  #if HAS_Y_MAX</front>
<front id="Marlin_mainCPP-4396">    SERIAL_PROTOCOLPGM(MSG_Y_MAX);</front>
<front id="Marlin_mainCPP-4397">    SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4398">  #endif</front>
<front id="Marlin_mainCPP-4399">  #if HAS_Z_MIN</front>
<front id="Marlin_mainCPP-4400">    SERIAL_PROTOCOLPGM(MSG_Z_MIN);</front>
<front id="Marlin_mainCPP-4401">    SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4402">  #endif</front>
<front id="Marlin_mainCPP-4403">  #if HAS_Z_MAX</front>
<front id="Marlin_mainCPP-4404">    SERIAL_PROTOCOLPGM(MSG_Z_MAX);</front>
<front id="Marlin_mainCPP-4405">    SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4406">  #endif</front>
<front id="Marlin_mainCPP-4407">  #if HAS_Z2_MAX</front>
<front id="Marlin_mainCPP-4408">    SERIAL_PROTOCOLPGM(MSG_Z2_MAX);</front>
<front id="Marlin_mainCPP-4409">    SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4410">  #endif</front>
<front id="Marlin_mainCPP-4411">  #if HAS_Z_PROBE</front>
<front id="Marlin_mainCPP-4412">    SERIAL_PROTOCOLPGM(MSG_Z_PROBE);</front>
<front id="Marlin_mainCPP-4413">    SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING)?MSG_ENDSTOP_HIT:MSG_ENDSTOP_OPEN));</front>
<front id="Marlin_mainCPP-4414">  #endif</front>
<front id="Marlin_mainCPP-4415">}</front>
<front id="Marlin_mainCPP-4416"></front>
<front id="Marlin_mainCPP-4417">/**</front>
<front id="Marlin_mainCPP-4418"> * M120: Enable endstops</front>
<front id="Marlin_mainCPP-4419"> */</front>
<front id="Marlin_mainCPP-4420">inline void gcode_M120() { enable_endstops(true); }</front>
<front id="Marlin_mainCPP-4421"></front>
<front id="Marlin_mainCPP-4422">/**</front>
<front id="Marlin_mainCPP-4423"> * M121: Disable endstops</front>
<front id="Marlin_mainCPP-4424"> */</front>
<front id="Marlin_mainCPP-4425">inline void gcode_M121() { enable_endstops(false); }</front>
<front id="Marlin_mainCPP-4426"></front>
<front id="Marlin_mainCPP-4427">#if ENABLED(BLINKM)</front>
<front id="Marlin_mainCPP-4428"></front>
<front id="Marlin_mainCPP-4429">  /**</front>
<front id="Marlin_mainCPP-4430">   * M150: Set Status LED Color - Use R-U-B for R-G-B</front>
<front id="Marlin_mainCPP-4431">   */</front>
<front id="Marlin_mainCPP-4432">  inline void gcode_M150() {</front>
<front id="Marlin_mainCPP-4433">    SendColors(</front>
<front id="Marlin_mainCPP-4434">      code_seen('R') ? (byte)code_value_short() : 0,</front>
<front id="Marlin_mainCPP-4435">      code_seen('U') ? (byte)code_value_short() : 0,</front>
<front id="Marlin_mainCPP-4436">      code_seen('B') ? (byte)code_value_short() : 0</front>
<front id="Marlin_mainCPP-4437">    );</front>
<front id="Marlin_mainCPP-4438">  }</front>
<front id="Marlin_mainCPP-4439"></front>
<front id="Marlin_mainCPP-4440">#endif // BLINKM</front>
<front id="Marlin_mainCPP-4441"></front>
<front id="Marlin_mainCPP-4442">/**</front>
<front id="Marlin_mainCPP-4443"> * M200: Set filament diameter and set E axis units to cubic millimeters</front>
<front id="Marlin_mainCPP-4444"> *</front>
<front id="Marlin_mainCPP-4445"> *    T&lt;extruder&gt; - Optional extruder number. Current extruder if omitted.</front>
<front id="Marlin_mainCPP-4446"> *    D&lt;mm&gt; - Diameter of the filament. Use "D0" to set units back to millimeters.</front>
<front id="Marlin_mainCPP-4447"> */</front>
<front id="Marlin_mainCPP-4448">inline void gcode_M200() {</front>
<front id="Marlin_mainCPP-4449"></front>
<front id="Marlin_mainCPP-4450">  if (setTargetedHotend(200)) return;</front>
<front id="Marlin_mainCPP-4451"></front>
<front id="Marlin_mainCPP-4452">  if (code_seen('D')) {</front>
<front id="Marlin_mainCPP-4453">    float diameter = code_value();</front>
<front id="Marlin_mainCPP-4454">    // setting any extruder filament size disables volumetric on the assumption that</front>
<front id="Marlin_mainCPP-4455">    // slicers either generate in extruder values as cubic mm or as as filament feeds</front>
<front id="Marlin_mainCPP-4456">    // for all extruders</front>
<front id="Marlin_mainCPP-4457">    volumetric_enabled = (diameter != 0.0);</front>
<front id="Marlin_mainCPP-4458">    if (volumetric_enabled) {</front>
<front id="Marlin_mainCPP-4459">      filament_size[target_extruder] = diameter;</front>
<front id="Marlin_mainCPP-4460">      // make sure all extruders have some sane value for the filament size</front>
<front id="Marlin_mainCPP-4461">      for (int i=0; i&lt;EXTRUDERS; i++)</front>
<front id="Marlin_mainCPP-4462">        if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;</front>
<front id="Marlin_mainCPP-4463">    }</front>
<front id="Marlin_mainCPP-4464">  }</front>
<front id="Marlin_mainCPP-4465">  else {</front>
<front id="Marlin_mainCPP-4466">    //reserved for setting filament diameter via UFID or filament measuring device</front>
<front id="Marlin_mainCPP-4467">    return;</front>
<front id="Marlin_mainCPP-4468">  }</front>
<front id="Marlin_mainCPP-4469">  calculate_volumetric_multipliers();</front>
<front id="Marlin_mainCPP-4470">}</front>
<front id="Marlin_mainCPP-4471"></front>
<front id="Marlin_mainCPP-4472">/**</front>
<front id="Marlin_mainCPP-4473"> * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</front>
<front id="Marlin_mainCPP-4474"> */</front>
<front id="Marlin_mainCPP-4475">inline void gcode_M201() {</front>
<front id="Marlin_mainCPP-4476">  for (int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4477">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4478">      max_acceleration_units_per_sq_second[i] = code_value();</front>
<front id="Marlin_mainCPP-4479">    }</front>
<front id="Marlin_mainCPP-4480">  }</front>
<front id="Marlin_mainCPP-4481">  // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</front>
<front id="Marlin_mainCPP-4482">  reset_acceleration_rates();</front>
<front id="Marlin_mainCPP-4483">}</front>
<front id="Marlin_mainCPP-4484"></front>
<front id="Marlin_mainCPP-4485">#if 0 // Not used for Sprinter/grbl gen6</front>
<front id="Marlin_mainCPP-4486">  inline void gcode_M202() {</front>
<front id="Marlin_mainCPP-4487">    for(int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4488">      if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];</front>
<front id="Marlin_mainCPP-4489">    }</front>
<front id="Marlin_mainCPP-4490">  }</front>
<front id="Marlin_mainCPP-4491">#endif</front>
<front id="Marlin_mainCPP-4492"></front>
<front id="Marlin_mainCPP-4493"></front>
<front id="Marlin_mainCPP-4494">/**</front>
<front id="Marlin_mainCPP-4495"> * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</front>
<front id="Marlin_mainCPP-4496"> */</front>
<front id="Marlin_mainCPP-4497">inline void gcode_M203() {</front>
<front id="Marlin_mainCPP-4498">  for (int8_t i=0; i &lt; NUM_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4499">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4500">      max_feedrate[i] = code_value();</front>
<front id="Marlin_mainCPP-4501">    }</front>
<front id="Marlin_mainCPP-4502">  }</front>
<front id="Marlin_mainCPP-4503">}</front>
<front id="Marlin_mainCPP-4504"></front>
<front id="Marlin_mainCPP-4505">/**</front>
<front id="Marlin_mainCPP-4506"> * M204: Set Accelerations in mm/sec^2 (M204 P1200 R3000 T3000)</front>
<front id="Marlin_mainCPP-4507"> *</front>
<front id="Marlin_mainCPP-4508"> *    P = Printing moves</front>
<front id="Marlin_mainCPP-4509"> *    R = Retract only (no X, Y, Z) moves</front>
<front id="Marlin_mainCPP-4510"> *    T = Travel (non printing) moves</front>
<front id="Marlin_mainCPP-4511"> *</front>
<front id="Marlin_mainCPP-4512"> *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate</front>
<front id="Marlin_mainCPP-4513"> */</front>
<front id="Marlin_mainCPP-4514">inline void gcode_M204() {</front>
<front id="Marlin_mainCPP-4515">  if (code_seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.</front>
<front id="Marlin_mainCPP-4516">    travel_acceleration = acceleration = code_value();</front>
<front id="Marlin_mainCPP-4517">    SERIAL_ECHOPAIR("Setting Print and Travel Acceleration: ", acceleration);</front>
<front id="Marlin_mainCPP-4518">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4519">  }</front>
<front id="Marlin_mainCPP-4520">  if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-4521">    acceleration = code_value();</front>
<front id="Marlin_mainCPP-4522">    SERIAL_ECHOPAIR("Setting Print Acceleration: ", acceleration );</front>
<front id="Marlin_mainCPP-4523">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4524">  }</front>
<front id="Marlin_mainCPP-4525">  if (code_seen('R')) {</front>
<front id="Marlin_mainCPP-4526">    retract_acceleration = code_value();</front>
<front id="Marlin_mainCPP-4527">    SERIAL_ECHOPAIR("Setting Retract Acceleration: ", retract_acceleration );</front>
<front id="Marlin_mainCPP-4528">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4529">  }</front>
<front id="Marlin_mainCPP-4530">  if (code_seen('T')) {</front>
<front id="Marlin_mainCPP-4531">    travel_acceleration = code_value();</front>
<front id="Marlin_mainCPP-4532">    SERIAL_ECHOPAIR("Setting Travel Acceleration: ", travel_acceleration );</front>
<front id="Marlin_mainCPP-4533">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4534">  }</front>
<front id="Marlin_mainCPP-4535"></front>
<front id="Marlin_mainCPP-4536">}</front>
<front id="Marlin_mainCPP-4537"></front>
<front id="Marlin_mainCPP-4538">/**</front>
<front id="Marlin_mainCPP-4539"> * M205: Set Advanced Settings</front>
<front id="Marlin_mainCPP-4540"> *</front>
<front id="Marlin_mainCPP-4541"> *    S = Min Feed Rate (mm/s)</front>
<front id="Marlin_mainCPP-4542"> *    T = Min Travel Feed Rate (mm/s)</front>
<front id="Marlin_mainCPP-4543"> *    B = Min Segment Time (s)</front>
<front id="Marlin_mainCPP-4544"> *    X = Max XY Jerk (mm/s/s)</front>
<front id="Marlin_mainCPP-4545"> *    Z = Max Z Jerk (mm/s/s)</front>
<front id="Marlin_mainCPP-4546"> *    E = Max E Jerk (mm/s/s)</front>
<front id="Marlin_mainCPP-4547"> */</front>
<front id="Marlin_mainCPP-4548">inline void gcode_M205() {</front>
<front id="Marlin_mainCPP-4549">  if (code_seen('S')) minimumfeedrate = code_value();</front>
<front id="Marlin_mainCPP-4550">  if (code_seen('T')) mintravelfeedrate = code_value();</front>
<front id="Marlin_mainCPP-4551">  if (code_seen('B')) minsegmenttime = code_value();</front>
<front id="Marlin_mainCPP-4552">  if (code_seen('X')) max_xy_jerk = code_value();</front>
<front id="Marlin_mainCPP-4553">  if (code_seen('Z')) max_z_jerk = code_value();</front>
<front id="Marlin_mainCPP-4554">  if (code_seen('E')) max_e_jerk = code_value();</front>
<front id="Marlin_mainCPP-4555">}</front>
<front id="Marlin_mainCPP-4556"></front>
<front id="Marlin_mainCPP-4557">/**</front>
<front id="Marlin_mainCPP-4558"> * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y</front>
<front id="Marlin_mainCPP-4559"> */</front>
<front id="Marlin_mainCPP-4560">inline void gcode_M206() {</front>
<front id="Marlin_mainCPP-4561">  for (int8_t i=X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4562">    if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4563">      home_offset[i] = code_value();</front>
<front id="Marlin_mainCPP-4564">    }</front>
<front id="Marlin_mainCPP-4565">  }</front>
<front id="Marlin_mainCPP-4566">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-4567">    if (code_seen('T')) home_offset[X_AXIS] = code_value(); // Theta</front>
<front id="Marlin_mainCPP-4568">    if (code_seen('P')) home_offset[Y_AXIS] = code_value(); // Psi</front>
<front id="Marlin_mainCPP-4569">  #endif</front>
<front id="Marlin_mainCPP-4570">}</front>
<front id="Marlin_mainCPP-4571"></front>
<front id="Marlin_mainCPP-4572">#if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-4573">  /**</front>
<front id="Marlin_mainCPP-4574">   * M665: Set delta configurations</front>
<front id="Marlin_mainCPP-4575">   *</front>
<front id="Marlin_mainCPP-4576">   *    L = diagonal rod</front>
<front id="Marlin_mainCPP-4577">   *    R = delta radius</front>
<front id="Marlin_mainCPP-4578">   *    S = segments per second</front>
<front id="Marlin_mainCPP-4579">   *    A = Alpha (Tower 1) diagonal rod trim</front>
<front id="Marlin_mainCPP-4580">   *    B = Beta (Tower 2) diagonal rod trim</front>
<front id="Marlin_mainCPP-4581">   *    C = Gamma (Tower 3) diagonal rod trim</front>
<front id="Marlin_mainCPP-4582">   */</front>
<front id="Marlin_mainCPP-4583">  inline void gcode_M665() {</front>
<front id="Marlin_mainCPP-4584">    if (code_seen('L')) delta_diagonal_rod = code_value();</front>
<front id="Marlin_mainCPP-4585">    if (code_seen('R')) delta_radius = code_value();</front>
<front id="Marlin_mainCPP-4586">    if (code_seen('S')) delta_segments_per_second = code_value();</front>
<front id="Marlin_mainCPP-4587">    if (code_seen('A')) delta_diagonal_rod_trim_tower_1 = code_value();</front>
<front id="Marlin_mainCPP-4588">    if (code_seen('B')) delta_diagonal_rod_trim_tower_2 = code_value();</front>
<front id="Marlin_mainCPP-4589">    if (code_seen('C')) delta_diagonal_rod_trim_tower_3 = code_value();</front>
<front id="Marlin_mainCPP-4590">    recalc_delta_settings(delta_radius, delta_diagonal_rod);</front>
<front id="Marlin_mainCPP-4591">  }</front>
<front id="Marlin_mainCPP-4592">  /**</front>
<front id="Marlin_mainCPP-4593">   * M666: Set delta endstop adjustment</front>
<front id="Marlin_mainCPP-4594">   */</front>
<front id="Marlin_mainCPP-4595">  inline void gcode_M666() {</front>
<front id="Marlin_mainCPP-4596">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4597">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4598">        SERIAL_ECHOLNPGM("&gt;&gt;&gt; gcode_M666");</front>
<front id="Marlin_mainCPP-4599">      }</front>
<front id="Marlin_mainCPP-4600">    #endif</front>
<front id="Marlin_mainCPP-4601">    for (int8_t i = X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-4602">      if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-4603">        endstop_adj[i] = code_value();</front>
<front id="Marlin_mainCPP-4604">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4605">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4606">            SERIAL_ECHOPGM("endstop_adj[");</front>
<front id="Marlin_mainCPP-4607">            SERIAL_ECHO(axis_codes[i]);</front>
<front id="Marlin_mainCPP-4608">            SERIAL_ECHOPAIR("] = ", endstop_adj[i]);</front>
<front id="Marlin_mainCPP-4609">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4610">          }</front>
<front id="Marlin_mainCPP-4611">        #endif</front>
<front id="Marlin_mainCPP-4612">      }</front>
<front id="Marlin_mainCPP-4613">    }</front>
<front id="Marlin_mainCPP-4614">    #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-4615">      if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-4616">        SERIAL_ECHOLNPGM("&lt;&lt;&lt; gcode_M666");</front>
<front id="Marlin_mainCPP-4617">      }</front>
<front id="Marlin_mainCPP-4618">    #endif</front>
<front id="Marlin_mainCPP-4619">  }</front>
<front id="Marlin_mainCPP-4620">#elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-4621">  /**</front>
<front id="Marlin_mainCPP-4622">   * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.</front>
<front id="Marlin_mainCPP-4623">   */</front>
<front id="Marlin_mainCPP-4624">  inline void gcode_M666() {</front>
<front id="Marlin_mainCPP-4625">    if (code_seen('Z')) z_endstop_adj = code_value();</front>
<front id="Marlin_mainCPP-4626">    SERIAL_ECHOPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);</front>
<front id="Marlin_mainCPP-4627">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4628">  }</front>
<front id="Marlin_mainCPP-4629"></front>
<front id="Marlin_mainCPP-4630">#endif // !DELTA && Z_DUAL_ENDSTOPS</front>
<front id="Marlin_mainCPP-4631"></front>
<front id="Marlin_mainCPP-4632">#if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-4633"></front>
<front id="Marlin_mainCPP-4634">  /**</front>
<front id="Marlin_mainCPP-4635">   * M207: Set firmware retraction values</front>
<front id="Marlin_mainCPP-4636">   *</front>
<front id="Marlin_mainCPP-4637">   *   S[+mm]    retract_length</front>
<front id="Marlin_mainCPP-4638">   *   W[+mm]    retract_length_swap (multi-extruder)</front>
<front id="Marlin_mainCPP-4639">   *   F[mm/min] retract_feedrate</front>
<front id="Marlin_mainCPP-4640">   *   Z[mm]     retract_zlift</front>
<front id="Marlin_mainCPP-4641">   */</front>
<front id="Marlin_mainCPP-4642">  inline void gcode_M207() {</front>
<front id="Marlin_mainCPP-4643">    if (code_seen('S')) retract_length = code_value();</front>
<front id="Marlin_mainCPP-4644">    if (code_seen('F')) retract_feedrate = code_value() / 60;</front>
<front id="Marlin_mainCPP-4645">    if (code_seen('Z')) retract_zlift = code_value();</front>
<front id="Marlin_mainCPP-4646">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4647">      if (code_seen('W')) retract_length_swap = code_value();</front>
<front id="Marlin_mainCPP-4648">    #endif</front>
<front id="Marlin_mainCPP-4649">  }</front>
<front id="Marlin_mainCPP-4650"></front>
<front id="Marlin_mainCPP-4651">  /**</front>
<front id="Marlin_mainCPP-4652">   * M208: Set firmware un-retraction values</front>
<front id="Marlin_mainCPP-4653">   *</front>
<front id="Marlin_mainCPP-4654">   *   S[+mm]    retract_recover_length (in addition to M207 S*)</front>
<front id="Marlin_mainCPP-4655">   *   W[+mm]    retract_recover_length_swap (multi-extruder)</front>
<front id="Marlin_mainCPP-4656">   *   F[mm/min] retract_recover_feedrate</front>
<front id="Marlin_mainCPP-4657">   */</front>
<front id="Marlin_mainCPP-4658">  inline void gcode_M208() {</front>
<front id="Marlin_mainCPP-4659">    if (code_seen('S')) retract_recover_length = code_value();</front>
<front id="Marlin_mainCPP-4660">    if (code_seen('F')) retract_recover_feedrate = code_value() / 60;</front>
<front id="Marlin_mainCPP-4661">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4662">      if (code_seen('W')) retract_recover_length_swap = code_value();</front>
<front id="Marlin_mainCPP-4663">    #endif</front>
<front id="Marlin_mainCPP-4664">  }</front>
<front id="Marlin_mainCPP-4665"></front>
<front id="Marlin_mainCPP-4666">  /**</front>
<front id="Marlin_mainCPP-4667">   * M209: Enable automatic retract (M209 S1)</front>
<front id="Marlin_mainCPP-4668">   *       detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-4669">   */</front>
<front id="Marlin_mainCPP-4670">  inline void gcode_M209() {</front>
<front id="Marlin_mainCPP-4671">    if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4672">      int t = code_value_short();</front>
<front id="Marlin_mainCPP-4673">      switch(t) {</front>
<front id="Marlin_mainCPP-4674">        case 0:</front>
<front id="Marlin_mainCPP-4675">          autoretract_enabled = false;</front>
<front id="Marlin_mainCPP-4676">          break;</front>
<front id="Marlin_mainCPP-4677">        case 1:</front>
<front id="Marlin_mainCPP-4678">          autoretract_enabled = true;</front>
<front id="Marlin_mainCPP-4679">          break;</front>
<front id="Marlin_mainCPP-4680">        default:</front>
<front id="Marlin_mainCPP-4681">          unknown_command_error();</front>
<front id="Marlin_mainCPP-4682">          return;</front>
<front id="Marlin_mainCPP-4683">      }</front>
<front id="Marlin_mainCPP-4684">      for (int i=0; i&lt;EXTRUDERS; i++) retracted[i] = false;</front>
<front id="Marlin_mainCPP-4685">    }</front>
<front id="Marlin_mainCPP-4686">  }</front>
<front id="Marlin_mainCPP-4687"></front>
<front id="Marlin_mainCPP-4688">#endif // FWRETRACT</front>
<front id="Marlin_mainCPP-4689"></front>
<front id="Marlin_mainCPP-4690">#if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4691"></front>
<front id="Marlin_mainCPP-4692">  /**</front>
<front id="Marlin_mainCPP-4693">   * M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-4694">   */</front>
<front id="Marlin_mainCPP-4695">  inline void gcode_M218() {</front>
<front id="Marlin_mainCPP-4696">    if (setTargetedHotend(218)) return;</front>
<front id="Marlin_mainCPP-4697"></front>
<front id="Marlin_mainCPP-4698">    if (code_seen('X')) extruder_offset[X_AXIS][target_extruder] = code_value();</front>
<front id="Marlin_mainCPP-4699">    if (code_seen('Y')) extruder_offset[Y_AXIS][target_extruder] = code_value();</front>
<front id="Marlin_mainCPP-4700"></front>
<front id="Marlin_mainCPP-4701">    #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-4702">      if (code_seen('Z')) extruder_offset[Z_AXIS][target_extruder] = code_value();</front>
<front id="Marlin_mainCPP-4703">    #endif</front>
<front id="Marlin_mainCPP-4704"></front>
<front id="Marlin_mainCPP-4705">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4706">    SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);</front>
<front id="Marlin_mainCPP-4707">    for (int e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="Marlin_mainCPP-4708">      SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-4709">      SERIAL_ECHO(extruder_offset[X_AXIS][e]);</front>
<front id="Marlin_mainCPP-4710">      SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-4711">      SERIAL_ECHO(extruder_offset[Y_AXIS][e]);</front>
<front id="Marlin_mainCPP-4712">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-4713">        SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-4714">        SERIAL_ECHO(extruder_offset[Z_AXIS][e]);</front>
<front id="Marlin_mainCPP-4715">      #endif</front>
<front id="Marlin_mainCPP-4716">    }</front>
<front id="Marlin_mainCPP-4717">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4718">  }</front>
<front id="Marlin_mainCPP-4719"></front>
<front id="Marlin_mainCPP-4720">#endif // EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-4721"></front>
<front id="Marlin_mainCPP-4722">/**</front>
<front id="Marlin_mainCPP-4723"> * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)</front>
<front id="Marlin_mainCPP-4724"> */</front>
<front id="Marlin_mainCPP-4725">inline void gcode_M220() {</front>
<front id="Marlin_mainCPP-4726">  if (code_seen('S')) feedrate_multiplier = code_value();</front>
<front id="Marlin_mainCPP-4727">}</front>
<front id="Marlin_mainCPP-4728"></front>
<front id="Marlin_mainCPP-4729">/**</front>
<front id="Marlin_mainCPP-4730"> * M221: Set extrusion percentage (M221 T0 S95)</front>
<front id="Marlin_mainCPP-4731"> */</front>
<front id="Marlin_mainCPP-4732">inline void gcode_M221() {</front>
<front id="Marlin_mainCPP-4733">  if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4734">    int sval = code_value();</front>
<front id="Marlin_mainCPP-4735">    if (code_seen('T')) {</front>
<front id="Marlin_mainCPP-4736">      if (setTargetedHotend(221)) return;</front>
<front id="Marlin_mainCPP-4737">      extruder_multiplier[target_extruder] = sval;</front>
<front id="Marlin_mainCPP-4738">    }</front>
<front id="Marlin_mainCPP-4739">    else {</front>
<front id="Marlin_mainCPP-4740">      extruder_multiplier[active_extruder] = sval;</front>
<front id="Marlin_mainCPP-4741">    }</front>
<front id="Marlin_mainCPP-4742">  }</front>
<front id="Marlin_mainCPP-4743">}</front>
<front id="Marlin_mainCPP-4744"></front>
<front id="Marlin_mainCPP-4745">/**</front>
<front id="Marlin_mainCPP-4746"> * M226: Wait until the specified pin reaches the state required (M226 P&lt;pin&gt; S&lt;state&gt;)</front>
<front id="Marlin_mainCPP-4747"> */</front>
<front id="Marlin_mainCPP-4748">inline void gcode_M226() {</front>
<front id="Marlin_mainCPP-4749">  if (code_seen('P')) {</front>
<front id="Marlin_mainCPP-4750">    int pin_number = code_value();</front>
<front id="Marlin_mainCPP-4751"></front>
<front id="Marlin_mainCPP-4752">    int pin_state = code_seen('S') ? code_value() : -1; // required pin state - default is inverted</front>
<front id="Marlin_mainCPP-4753"></front>
<front id="Marlin_mainCPP-4754">    if (pin_state &gt;= -1 && pin_state &lt;= 1) {</front>
<front id="Marlin_mainCPP-4755"></front>
<front id="Marlin_mainCPP-4756">      for (uint8_t i = 0; i &lt; COUNT(sensitive_pins); i++) {</front>
<front id="Marlin_mainCPP-4757">        if (sensitive_pins[i] == pin_number) {</front>
<front id="Marlin_mainCPP-4758">          pin_number = -1;</front>
<front id="Marlin_mainCPP-4759">          break;</front>
<front id="Marlin_mainCPP-4760">        }</front>
<front id="Marlin_mainCPP-4761">      }</front>
<front id="Marlin_mainCPP-4762"></front>
<front id="Marlin_mainCPP-4763">      if (pin_number &gt; -1) {</front>
<front id="Marlin_mainCPP-4764">        int target = LOW;</front>
<front id="Marlin_mainCPP-4765"></front>
<front id="Marlin_mainCPP-4766">        st_synchronize();</front>
<front id="Marlin_mainCPP-4767"></front>
<front id="Marlin_mainCPP-4768">        pinMode(pin_number, INPUT);</front>
<front id="Marlin_mainCPP-4769"></front>
<front id="Marlin_mainCPP-4770">        switch(pin_state){</front>
<front id="Marlin_mainCPP-4771">          case 1:</front>
<front id="Marlin_mainCPP-4772">            target = HIGH;</front>
<front id="Marlin_mainCPP-4773">            break;</front>
<front id="Marlin_mainCPP-4774"></front>
<front id="Marlin_mainCPP-4775">          case 0:</front>
<front id="Marlin_mainCPP-4776">            target = LOW;</front>
<front id="Marlin_mainCPP-4777">            break;</front>
<front id="Marlin_mainCPP-4778"></front>
<front id="Marlin_mainCPP-4779">          case -1:</front>
<front id="Marlin_mainCPP-4780">            target = !digitalRead(pin_number);</front>
<front id="Marlin_mainCPP-4781">            break;</front>
<front id="Marlin_mainCPP-4782">        }</front>
<front id="Marlin_mainCPP-4783"></front>
<front id="Marlin_mainCPP-4784">        while (digitalRead(pin_number) != target) idle();</front>
<front id="Marlin_mainCPP-4785"></front>
<front id="Marlin_mainCPP-4786">      } // pin_number &gt; -1</front>
<front id="Marlin_mainCPP-4787">    } // pin_state -1 0 1</front>
<front id="Marlin_mainCPP-4788">  } // code_seen('P')</front>
<front id="Marlin_mainCPP-4789">}</front>
<front id="Marlin_mainCPP-4790"></front>
<front id="Marlin_mainCPP-4791">#if HAS_SERVOS</front>
<front id="Marlin_mainCPP-4792"></front>
<front id="Marlin_mainCPP-4793">  /**</front>
<front id="Marlin_mainCPP-4794">   * M280: Get or set servo position. P&lt;index&gt; S&lt;angle&gt;</front>
<front id="Marlin_mainCPP-4795">   */</front>
<front id="Marlin_mainCPP-4796">  inline void gcode_M280() {</front>
<front id="Marlin_mainCPP-4797">    int servo_index = code_seen('P') ? code_value_short() : -1;</front>
<front id="Marlin_mainCPP-4798">    int servo_position = 0;</front>
<front id="Marlin_mainCPP-4799">    if (code_seen('S')) {</front>
<front id="Marlin_mainCPP-4800">      servo_position = code_value_short();</front>
<front id="Marlin_mainCPP-4801">      if (servo_index &gt;= 0 && servo_index &lt; NUM_SERVOS)</front>
<front id="Marlin_mainCPP-4802">        servo[servo_index].move(servo_position);</front>
<front id="Marlin_mainCPP-4803">      else {</front>
<front id="Marlin_mainCPP-4804">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4805">        SERIAL_ECHO("Servo ");</front>
<front id="Marlin_mainCPP-4806">        SERIAL_ECHO(servo_index);</front>
<front id="Marlin_mainCPP-4807">        SERIAL_ECHOLN(" out of range");</front>
<front id="Marlin_mainCPP-4808">      }</front>
<front id="Marlin_mainCPP-4809">    }</front>
<front id="Marlin_mainCPP-4810">    else if (servo_index &gt;= 0) {</front>
<front id="Marlin_mainCPP-4811">      SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-4812">      SERIAL_PROTOCOL(" Servo ");</front>
<front id="Marlin_mainCPP-4813">      SERIAL_PROTOCOL(servo_index);</front>
<front id="Marlin_mainCPP-4814">      SERIAL_PROTOCOL(": ");</front>
<front id="Marlin_mainCPP-4815">      SERIAL_PROTOCOL(servo[servo_index].read());</front>
<front id="Marlin_mainCPP-4816">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4817">    }</front>
<front id="Marlin_mainCPP-4818">  }</front>
<front id="Marlin_mainCPP-4819"></front>
<front id="Marlin_mainCPP-4820">#endif // HAS_SERVOS</front>
<front id="Marlin_mainCPP-4821"></front>
<front id="Marlin_mainCPP-4822">#if HAS_BUZZER</front>
<front id="Marlin_mainCPP-4823"></front>
<front id="Marlin_mainCPP-4824">  /**</front>
<front id="Marlin_mainCPP-4825">   * M300: Play beep sound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</front>
<front id="Marlin_mainCPP-4826">   */</front>
<front id="Marlin_mainCPP-4827">  inline void gcode_M300() {</front>
<front id="Marlin_mainCPP-4828">    uint16_t beepS = code_seen('S') ? code_value_short() : 110;</front>
<front id="Marlin_mainCPP-4829">    uint32_t beepP = code_seen('P') ? code_value_long() : 1000;</front>
<front id="Marlin_mainCPP-4830">    if (beepP &gt; 5000) beepP = 5000; // limit to 5 seconds</front>
<front id="Marlin_mainCPP-4831">    buzz(beepP, beepS);</front>
<front id="Marlin_mainCPP-4832">  }</front>
<front id="Marlin_mainCPP-4833"></front>
<front id="Marlin_mainCPP-4834">#endif // HAS_BUZZER</front>
<front id="Marlin_mainCPP-4835"></front>
<front id="Marlin_mainCPP-4836">#if ENABLED(PIDTEMP)</front>
<front id="Marlin_mainCPP-4837"></front>
<front id="Marlin_mainCPP-4838">  /**</front>
<front id="Marlin_mainCPP-4839">   * M301: Set PID parameters P I D (and optionally C, L)</front>
<front id="Marlin_mainCPP-4840">   *</front>
<front id="Marlin_mainCPP-4841">   *   P[float] Kp term</front>
<front id="Marlin_mainCPP-4842">   *   I[float] Ki term (unscaled)</front>
<front id="Marlin_mainCPP-4843">   *   D[float] Kd term (unscaled)</front>
<front id="Marlin_mainCPP-4844">   *</front>
<front id="Marlin_mainCPP-4845">   * With PID_ADD_EXTRUSION_RATE:</front>
<front id="Marlin_mainCPP-4846">   *</front>
<front id="Marlin_mainCPP-4847">   *   C[float] Kc term</front>
<front id="Marlin_mainCPP-4848">   *   L[float] LPQ length</front>
<front id="Marlin_mainCPP-4849">   */</front>
<front id="Marlin_mainCPP-4850">  inline void gcode_M301() {</front>
<front id="Marlin_mainCPP-4851"></front>
<front id="Marlin_mainCPP-4852">    // multi-extruder PID patch: M301 updates or prints a single extruder's PID values</front>
<front id="Marlin_mainCPP-4853">    // default behaviour (omitting E parameter) is to update for extruder 0 only</front>
<front id="Marlin_mainCPP-4854">    int e = code_seen('E') ? code_value() : 0; // extruder being updated</front>
<front id="Marlin_mainCPP-4855"></front>
<front id="Marlin_mainCPP-4856">    if (e &lt; EXTRUDERS) { // catch bad input value</front>
<front id="Marlin_mainCPP-4857">      if (code_seen('P')) PID_PARAM(Kp, e) = code_value();</front>
<front id="Marlin_mainCPP-4858">      if (code_seen('I')) PID_PARAM(Ki, e) = scalePID_i(code_value());</front>
<front id="Marlin_mainCPP-4859">      if (code_seen('D')) PID_PARAM(Kd, e) = scalePID_d(code_value());</front>
<front id="Marlin_mainCPP-4860">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Marlin_mainCPP-4861">        if (code_seen('C')) PID_PARAM(Kc, e) = code_value();</front>
<front id="Marlin_mainCPP-4862">        if (code_seen('L')) lpq_len = code_value();</front>
<front id="Marlin_mainCPP-4863">        NOMORE(lpq_len, LPQ_MAX_LEN);</front>
<front id="Marlin_mainCPP-4864">      #endif</front>
<front id="Marlin_mainCPP-4865"></front>
<front id="Marlin_mainCPP-4866">      updatePID();</front>
<front id="Marlin_mainCPP-4867">      SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-4868">      #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="Marlin_mainCPP-4869">        SERIAL_PROTOCOL(" e:"); // specify extruder in serial output</front>
<front id="Marlin_mainCPP-4870">        SERIAL_PROTOCOL(e);</front>
<front id="Marlin_mainCPP-4871">      #endif // PID_PARAMS_PER_EXTRUDER</front>
<front id="Marlin_mainCPP-4872">      SERIAL_PROTOCOL(" p:");</front>
<front id="Marlin_mainCPP-4873">      SERIAL_PROTOCOL(PID_PARAM(Kp, e));</front>
<front id="Marlin_mainCPP-4874">      SERIAL_PROTOCOL(" i:");</front>
<front id="Marlin_mainCPP-4875">      SERIAL_PROTOCOL(unscalePID_i(PID_PARAM(Ki, e)));</front>
<front id="Marlin_mainCPP-4876">      SERIAL_PROTOCOL(" d:");</front>
<front id="Marlin_mainCPP-4877">      SERIAL_PROTOCOL(unscalePID_d(PID_PARAM(Kd, e)));</front>
<front id="Marlin_mainCPP-4878">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="Marlin_mainCPP-4879">        SERIAL_PROTOCOL(" c:");</front>
<front id="Marlin_mainCPP-4880">        //Kc does not have scaling applied above, or in resetting defaults</front>
<front id="Marlin_mainCPP-4881">        SERIAL_PROTOCOL(PID_PARAM(Kc, e));</front>
<front id="Marlin_mainCPP-4882">      #endif</front>
<front id="Marlin_mainCPP-4883">      SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4884">    }</front>
<front id="Marlin_mainCPP-4885">    else {</front>
<front id="Marlin_mainCPP-4886">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-4887">      SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-4888">    }</front>
<front id="Marlin_mainCPP-4889">  }</front>
<front id="Marlin_mainCPP-4890"></front>
<front id="Marlin_mainCPP-4891">#endif // PIDTEMP</front>
<front id="Marlin_mainCPP-4892"></front>
<front id="Marlin_mainCPP-4893">#if ENABLED(PIDTEMPBED)</front>
<front id="Marlin_mainCPP-4894"></front>
<front id="Marlin_mainCPP-4895">  inline void gcode_M304() {</front>
<front id="Marlin_mainCPP-4896">    if (code_seen('P')) bedKp = code_value();</front>
<front id="Marlin_mainCPP-4897">    if (code_seen('I')) bedKi = scalePID_i(code_value());</front>
<front id="Marlin_mainCPP-4898">    if (code_seen('D')) bedKd = scalePID_d(code_value());</front>
<front id="Marlin_mainCPP-4899"></front>
<front id="Marlin_mainCPP-4900">    updatePID();</front>
<front id="Marlin_mainCPP-4901">    SERIAL_PROTOCOL(MSG_OK);</front>
<front id="Marlin_mainCPP-4902">    SERIAL_PROTOCOL(" p:");</front>
<front id="Marlin_mainCPP-4903">    SERIAL_PROTOCOL(bedKp);</front>
<front id="Marlin_mainCPP-4904">    SERIAL_PROTOCOL(" i:");</front>
<front id="Marlin_mainCPP-4905">    SERIAL_PROTOCOL(unscalePID_i(bedKi));</front>
<front id="Marlin_mainCPP-4906">    SERIAL_PROTOCOL(" d:");</front>
<front id="Marlin_mainCPP-4907">    SERIAL_PROTOCOL(unscalePID_d(bedKd));</front>
<front id="Marlin_mainCPP-4908">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4909">  }</front>
<front id="Marlin_mainCPP-4910"></front>
<front id="Marlin_mainCPP-4911">#endif // PIDTEMPBED</front>
<front id="Marlin_mainCPP-4912"></front>
<front id="Marlin_mainCPP-4913">#if defined(CHDK) || HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-4914"></front>
<front id="Marlin_mainCPP-4915">  /**</front>
<front id="Marlin_mainCPP-4916">   * M240: Trigger a camera by emulating a Canon RC-1</front>
<front id="Marlin_mainCPP-4917">   *       See http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="Marlin_mainCPP-4918">   */</front>
<front id="Marlin_mainCPP-4919">  inline void gcode_M240() {</front>
<front id="Marlin_mainCPP-4920">    #ifdef CHDK</front>
<front id="Marlin_mainCPP-4921"></front>
<front id="Marlin_mainCPP-4922">       OUT_WRITE(CHDK, HIGH);</front>
<front id="Marlin_mainCPP-4923">       chdkHigh = millis();</front>
<front id="Marlin_mainCPP-4924">       chdkActive = true;</front>
<front id="Marlin_mainCPP-4925"></front>
<front id="Marlin_mainCPP-4926">    #elif HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-4927"></front>
<front id="Marlin_mainCPP-4928">      const uint8_t NUM_PULSES = 16;</front>
<front id="Marlin_mainCPP-4929">      const float PULSE_LENGTH = 0.01524;</front>
<front id="Marlin_mainCPP-4930">      for (int i = 0; i &lt; NUM_PULSES; i++) {</front>
<front id="Marlin_mainCPP-4931">        WRITE(PHOTOGRAPH_PIN, HIGH);</front>
<front id="Marlin_mainCPP-4932">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4933">        WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-4934">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4935">      }</front>
<front id="Marlin_mainCPP-4936">      delay(7.33);</front>
<front id="Marlin_mainCPP-4937">      for (int i = 0; i &lt; NUM_PULSES; i++) {</front>
<front id="Marlin_mainCPP-4938">        WRITE(PHOTOGRAPH_PIN, HIGH);</front>
<front id="Marlin_mainCPP-4939">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4940">        WRITE(PHOTOGRAPH_PIN, LOW);</front>
<front id="Marlin_mainCPP-4941">        _delay_ms(PULSE_LENGTH);</front>
<front id="Marlin_mainCPP-4942">      }</front>
<front id="Marlin_mainCPP-4943"></front>
<front id="Marlin_mainCPP-4944">    #endif // !CHDK && HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-4945">  }</front>
<front id="Marlin_mainCPP-4946"></front>
<front id="Marlin_mainCPP-4947">#endif // CHDK || PHOTOGRAPH_PIN</front>
<front id="Marlin_mainCPP-4948"></front>
<front id="Marlin_mainCPP-4949">#if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="Marlin_mainCPP-4950"></front>
<front id="Marlin_mainCPP-4951">  /**</front>
<front id="Marlin_mainCPP-4952">   * M250: Read and optionally set the LCD contrast</front>
<front id="Marlin_mainCPP-4953">   */</front>
<front id="Marlin_mainCPP-4954">  inline void gcode_M250() {</front>
<front id="Marlin_mainCPP-4955">    if (code_seen('C')) lcd_setcontrast(code_value_short() & 0x3F);</front>
<front id="Marlin_mainCPP-4956">    SERIAL_PROTOCOLPGM("lcd contrast value: ");</front>
<front id="Marlin_mainCPP-4957">    SERIAL_PROTOCOL(lcd_contrast);</front>
<front id="Marlin_mainCPP-4958">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-4959">  }</front>
<front id="Marlin_mainCPP-4960"></front>
<front id="Marlin_mainCPP-4961">#endif // HAS_LCD_CONTRAST</front>
<front id="Marlin_mainCPP-4962"></front>
<front id="Marlin_mainCPP-4963">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-4964"></front>
<front id="Marlin_mainCPP-4965">  void set_extrude_min_temp(float temp) { extrude_min_temp = temp; }</front>
<front id="Marlin_mainCPP-4966"></front>
<front id="Marlin_mainCPP-4967">  /**</front>
<front id="Marlin_mainCPP-4968">   * M302: Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</front>
<front id="Marlin_mainCPP-4969">   */</front>
<front id="Marlin_mainCPP-4970">  inline void gcode_M302() {</front>
<front id="Marlin_mainCPP-4971">    set_extrude_min_temp(code_seen('S') ? code_value() : 0);</front>
<front id="Marlin_mainCPP-4972">  }</front>
<front id="Marlin_mainCPP-4973"></front>
<front id="Marlin_mainCPP-4974">#endif // PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-4975"></front>
<front id="Marlin_mainCPP-4976">/**</front>
<front id="Marlin_mainCPP-4977"> * M303: PID relay autotune</front>
<front id="Marlin_mainCPP-4978"> *       S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</front>
<front id="Marlin_mainCPP-4979"> *       E&lt;extruder&gt; (-1 for the bed)</front>
<front id="Marlin_mainCPP-4980"> *       C&lt;cycles&gt;</front>
<front id="Marlin_mainCPP-4981"> */</front>
<front id="Marlin_mainCPP-4982">inline void gcode_M303() {</front>
<front id="Marlin_mainCPP-4983">  int e = code_seen('E') ? code_value_short() : 0;</front>
<front id="Marlin_mainCPP-4984">  int c = code_seen('C') ? code_value_short() : 5;</front>
<front id="Marlin_mainCPP-4985">  float temp = code_seen('S') ? code_value() : (e &lt; 0 ? 70.0 : 150.0);</front>
<front id="Marlin_mainCPP-4986">  PID_autotune(temp, e, c);</front>
<front id="Marlin_mainCPP-4987">}</front>
<front id="Marlin_mainCPP-4988"></front>
<front id="Marlin_mainCPP-4989">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-4990">  bool SCARA_move_to_cal(uint8_t delta_x, uint8_t delta_y) {</front>
<front id="Marlin_mainCPP-4991">    //SoftEndsEnabled = false;              // Ignore soft endstops during calibration</front>
<front id="Marlin_mainCPP-4992">    //SERIAL_ECHOLN(" Soft endstops disabled ");</front>
<front id="Marlin_mainCPP-4993">    if (IsRunning()) {</front>
<front id="Marlin_mainCPP-4994">      //gcode_get_destination(); // For X Y Z E F</front>
<front id="Marlin_mainCPP-4995">      delta[X_AXIS] = delta_x;</front>
<front id="Marlin_mainCPP-4996">      delta[Y_AXIS] = delta_y;</front>
<front id="Marlin_mainCPP-4997">      calculate_SCARA_forward_Transform(delta);</front>
<front id="Marlin_mainCPP-4998">      destination[X_AXIS] = delta[X_AXIS]/axis_scaling[X_AXIS];</front>
<front id="Marlin_mainCPP-4999">      destination[Y_AXIS] = delta[Y_AXIS]/axis_scaling[Y_AXIS];</front>
<front id="Marlin_mainCPP-5000">      prepare_move();</front>
<front id="Marlin_mainCPP-5001">      //ok_to_send();</front>
<front id="Marlin_mainCPP-5002">      return true;</front>
<front id="Marlin_mainCPP-5003">    }</front>
<front id="Marlin_mainCPP-5004">    return false;</front>
<front id="Marlin_mainCPP-5005">  }</front>
<front id="Marlin_mainCPP-5006"></front>
<front id="Marlin_mainCPP-5007">  /**</front>
<front id="Marlin_mainCPP-5008">   * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)</front>
<front id="Marlin_mainCPP-5009">   */</front>
<front id="Marlin_mainCPP-5010">  inline bool gcode_M360() {</front>
<front id="Marlin_mainCPP-5011">    SERIAL_ECHOLN(" Cal: Theta 0 ");</front>
<front id="Marlin_mainCPP-5012">    return SCARA_move_to_cal(0, 120);</front>
<front id="Marlin_mainCPP-5013">  }</front>
<front id="Marlin_mainCPP-5014"></front>
<front id="Marlin_mainCPP-5015">  /**</front>
<front id="Marlin_mainCPP-5016">   * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-5017">   */</front>
<front id="Marlin_mainCPP-5018">  inline bool gcode_M361() {</front>
<front id="Marlin_mainCPP-5019">    SERIAL_ECHOLN(" Cal: Theta 90 ");</front>
<front id="Marlin_mainCPP-5020">    return SCARA_move_to_cal(90, 130);</front>
<front id="Marlin_mainCPP-5021">  }</front>
<front id="Marlin_mainCPP-5022"></front>
<front id="Marlin_mainCPP-5023">  /**</front>
<front id="Marlin_mainCPP-5024">   * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)</front>
<front id="Marlin_mainCPP-5025">   */</front>
<front id="Marlin_mainCPP-5026">  inline bool gcode_M362() {</front>
<front id="Marlin_mainCPP-5027">    SERIAL_ECHOLN(" Cal: Psi 0 ");</front>
<front id="Marlin_mainCPP-5028">    return SCARA_move_to_cal(60, 180);</front>
<front id="Marlin_mainCPP-5029">  }</front>
<front id="Marlin_mainCPP-5030"></front>
<front id="Marlin_mainCPP-5031">  /**</front>
<front id="Marlin_mainCPP-5032">   * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)</front>
<front id="Marlin_mainCPP-5033">   */</front>
<front id="Marlin_mainCPP-5034">  inline bool gcode_M363() {</front>
<front id="Marlin_mainCPP-5035">    SERIAL_ECHOLN(" Cal: Psi 90 ");</front>
<front id="Marlin_mainCPP-5036">    return SCARA_move_to_cal(50, 90);</front>
<front id="Marlin_mainCPP-5037">  }</front>
<front id="Marlin_mainCPP-5038"></front>
<front id="Marlin_mainCPP-5039">  /**</front>
<front id="Marlin_mainCPP-5040">   * M364: SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)</front>
<front id="Marlin_mainCPP-5041">   */</front>
<front id="Marlin_mainCPP-5042">  inline bool gcode_M364() {</front>
<front id="Marlin_mainCPP-5043">    SERIAL_ECHOLN(" Cal: Theta-Psi 90 ");</front>
<front id="Marlin_mainCPP-5044">    return SCARA_move_to_cal(45, 135);</front>
<front id="Marlin_mainCPP-5045">  }</front>
<front id="Marlin_mainCPP-5046"></front>
<front id="Marlin_mainCPP-5047">  /**</front>
<front id="Marlin_mainCPP-5048">   * M365: SCARA calibration: Scaling factor, X, Y, Z axis</front>
<front id="Marlin_mainCPP-5049">   */</front>
<front id="Marlin_mainCPP-5050">  inline void gcode_M365() {</front>
<front id="Marlin_mainCPP-5051">    for (int8_t i = X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-5052">      if (code_seen(axis_codes[i])) {</front>
<front id="Marlin_mainCPP-5053">        axis_scaling[i] = code_value();</front>
<front id="Marlin_mainCPP-5054">      }</front>
<front id="Marlin_mainCPP-5055">    }</front>
<front id="Marlin_mainCPP-5056">  }</front>
<front id="Marlin_mainCPP-5057"></front>
<front id="Marlin_mainCPP-5058">#endif // SCARA</front>
<front id="Marlin_mainCPP-5059"></front>
<front id="Marlin_mainCPP-5060">#if ENABLED(EXT_SOLENOID)</front>
<front id="Marlin_mainCPP-5061"></front>
<front id="Marlin_mainCPP-5062">  void enable_solenoid(uint8_t num) {</front>
<front id="Marlin_mainCPP-5063">    switch(num) {</front>
<front id="Marlin_mainCPP-5064">      case 0:</front>
<front id="Marlin_mainCPP-5065">        OUT_WRITE(SOL0_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5066">        break;</front>
<front id="Marlin_mainCPP-5067">        #if HAS_SOLENOID_1</front>
<front id="Marlin_mainCPP-5068">          case 1:</front>
<front id="Marlin_mainCPP-5069">            OUT_WRITE(SOL1_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5070">            break;</front>
<front id="Marlin_mainCPP-5071">        #endif</front>
<front id="Marlin_mainCPP-5072">        #if HAS_SOLENOID_2</front>
<front id="Marlin_mainCPP-5073">          case 2:</front>
<front id="Marlin_mainCPP-5074">            OUT_WRITE(SOL2_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5075">            break;</front>
<front id="Marlin_mainCPP-5076">        #endif</front>
<front id="Marlin_mainCPP-5077">        #if HAS_SOLENOID_3</front>
<front id="Marlin_mainCPP-5078">          case 3:</front>
<front id="Marlin_mainCPP-5079">            OUT_WRITE(SOL3_PIN, HIGH);</front>
<front id="Marlin_mainCPP-5080">            break;</front>
<front id="Marlin_mainCPP-5081">        #endif</front>
<front id="Marlin_mainCPP-5082">      default:</front>
<front id="Marlin_mainCPP-5083">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5084">        SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);</front>
<front id="Marlin_mainCPP-5085">        break;</front>
<front id="Marlin_mainCPP-5086">    }</front>
<front id="Marlin_mainCPP-5087">  }</front>
<front id="Marlin_mainCPP-5088"></front>
<front id="Marlin_mainCPP-5089">  void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }</front>
<front id="Marlin_mainCPP-5090"></front>
<front id="Marlin_mainCPP-5091">  void disable_all_solenoids() {</front>
<front id="Marlin_mainCPP-5092">    OUT_WRITE(SOL0_PIN, LOW);</front>
<front id="Marlin_mainCPP-5093">    OUT_WRITE(SOL1_PIN, LOW);</front>
<front id="Marlin_mainCPP-5094">    OUT_WRITE(SOL2_PIN, LOW);</front>
<front id="Marlin_mainCPP-5095">    OUT_WRITE(SOL3_PIN, LOW);</front>
<front id="Marlin_mainCPP-5096">  }</front>
<front id="Marlin_mainCPP-5097"></front>
<front id="Marlin_mainCPP-5098">  /**</front>
<front id="Marlin_mainCPP-5099">   * M380: Enable solenoid on the active extruder</front>
<front id="Marlin_mainCPP-5100">   */</front>
<front id="Marlin_mainCPP-5101">  inline void gcode_M380() { enable_solenoid_on_active_extruder(); }</front>
<front id="Marlin_mainCPP-5102"></front>
<front id="Marlin_mainCPP-5103">  /**</front>
<front id="Marlin_mainCPP-5104">   * M381: Disable all solenoids</front>
<front id="Marlin_mainCPP-5105">   */</front>
<front id="Marlin_mainCPP-5106">  inline void gcode_M381() { disable_all_solenoids(); }</front>
<front id="Marlin_mainCPP-5107"></front>
<front id="Marlin_mainCPP-5108">#endif // EXT_SOLENOID</front>
<front id="Marlin_mainCPP-5109"></front>
<front id="Marlin_mainCPP-5110">/**</front>
<front id="Marlin_mainCPP-5111"> * M400: Finish all moves</front>
<front id="Marlin_mainCPP-5112"> */</front>
<front id="Marlin_mainCPP-5113">inline void gcode_M400() { st_synchronize(); }</front>
<front id="Marlin_mainCPP-5114"></front>
<front id="Marlin_mainCPP-5115">#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY))</front>
<front id="Marlin_mainCPP-5116"></front>
<front id="Marlin_mainCPP-5117">  /**</front>
<front id="Marlin_mainCPP-5118">   * M401: Engage Z Servo endstop if available</front>
<front id="Marlin_mainCPP-5119">   */</front>
<front id="Marlin_mainCPP-5120">  inline void gcode_M401() {</front>
<front id="Marlin_mainCPP-5121">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-5122">      raise_z_for_servo();</front>
<front id="Marlin_mainCPP-5123">    #endif</front>
<front id="Marlin_mainCPP-5124">    deploy_z_probe();</front>
<front id="Marlin_mainCPP-5125">  }</front>
<front id="Marlin_mainCPP-5126"></front>
<front id="Marlin_mainCPP-5127">  /**</front>
<front id="Marlin_mainCPP-5128">   * M402: Retract Z Servo endstop if enabled</front>
<front id="Marlin_mainCPP-5129">   */</front>
<front id="Marlin_mainCPP-5130">  inline void gcode_M402() {</front>
<front id="Marlin_mainCPP-5131">    #if HAS_SERVO_ENDSTOPS</front>
<front id="Marlin_mainCPP-5132">      raise_z_for_servo();</front>
<front id="Marlin_mainCPP-5133">    #endif</front>
<front id="Marlin_mainCPP-5134">    stow_z_probe(false);</front>
<front id="Marlin_mainCPP-5135">  }</front>
<front id="Marlin_mainCPP-5136"></front>
<front id="Marlin_mainCPP-5137">#endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-5138"></front>
<front id="Marlin_mainCPP-5139">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="Marlin_mainCPP-5140"></front>
<front id="Marlin_mainCPP-5141">  /**</front>
<front id="Marlin_mainCPP-5142">   * M404: Display or set the nominal filament width (3mm, 1.75mm ) W&lt;3.0&gt;</front>
<front id="Marlin_mainCPP-5143">   */</front>
<front id="Marlin_mainCPP-5144">  inline void gcode_M404() {</front>
<front id="Marlin_mainCPP-5145">    #if HAS_FILWIDTH</front>
<front id="Marlin_mainCPP-5146">      if (code_seen('W')) {</front>
<front id="Marlin_mainCPP-5147">        filament_width_nominal = code_value();</front>
<front id="Marlin_mainCPP-5148">      }</front>
<front id="Marlin_mainCPP-5149">      else {</front>
<front id="Marlin_mainCPP-5150">        SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");</front>
<front id="Marlin_mainCPP-5151">        SERIAL_PROTOCOLLN(filament_width_nominal);</front>
<front id="Marlin_mainCPP-5152">      }</front>
<front id="Marlin_mainCPP-5153">    #endif</front>
<front id="Marlin_mainCPP-5154">  }</front>
<front id="Marlin_mainCPP-5155"></front>
<front id="Marlin_mainCPP-5156">  /**</front>
<front id="Marlin_mainCPP-5157">   * M405: Turn on filament sensor for control</front>
<front id="Marlin_mainCPP-5158">   */</front>
<front id="Marlin_mainCPP-5159">  inline void gcode_M405() {</front>
<front id="Marlin_mainCPP-5160">    if (code_seen('D')) meas_delay_cm = code_value();</front>
<front id="Marlin_mainCPP-5161">    if (meas_delay_cm &gt; MAX_MEASUREMENT_DELAY) meas_delay_cm = MAX_MEASUREMENT_DELAY;</front>
<front id="Marlin_mainCPP-5162"></front>
<front id="Marlin_mainCPP-5163">    if (delay_index2 == -1) { //initialize the ring buffer if it has not been done since startup</front>
<front id="Marlin_mainCPP-5164">      int temp_ratio = widthFil_to_size_ratio();</front>
<front id="Marlin_mainCPP-5165"></front>
<front id="Marlin_mainCPP-5166">      for (delay_index1 = 0; delay_index1 &lt; MAX_MEASUREMENT_DELAY + 1; ++delay_index1)</front>
<front id="Marlin_mainCPP-5167">        measurement_delay[delay_index1] = temp_ratio - 100;  //subtract 100 to scale within a signed byte</front>
<front id="Marlin_mainCPP-5168"></front>
<front id="Marlin_mainCPP-5169">      delay_index1 = delay_index2 = 0;</front>
<front id="Marlin_mainCPP-5170">    }</front>
<front id="Marlin_mainCPP-5171"></front>
<front id="Marlin_mainCPP-5172">    filament_sensor = true;</front>
<front id="Marlin_mainCPP-5173"></front>
<front id="Marlin_mainCPP-5174">    //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");</front>
<front id="Marlin_mainCPP-5175">    //SERIAL_PROTOCOL(filament_width_meas);</front>
<front id="Marlin_mainCPP-5176">    //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");</front>
<front id="Marlin_mainCPP-5177">    //SERIAL_PROTOCOL(extruder_multiplier[active_extruder]);</front>
<front id="Marlin_mainCPP-5178">  }</front>
<front id="Marlin_mainCPP-5179"></front>
<front id="Marlin_mainCPP-5180">  /**</front>
<front id="Marlin_mainCPP-5181">   * M406: Turn off filament sensor for control</front>
<front id="Marlin_mainCPP-5182">   */</front>
<front id="Marlin_mainCPP-5183">  inline void gcode_M406() { filament_sensor = false; }</front>
<front id="Marlin_mainCPP-5184"></front>
<front id="Marlin_mainCPP-5185">  /**</front>
<front id="Marlin_mainCPP-5186">   * M407: Get measured filament diameter on serial output</front>
<front id="Marlin_mainCPP-5187">   */</front>
<front id="Marlin_mainCPP-5188">  inline void gcode_M407() {</front>
<front id="Marlin_mainCPP-5189">    SERIAL_PROTOCOLPGM("Filament dia (measured mm):");</front>
<front id="Marlin_mainCPP-5190">    SERIAL_PROTOCOLLN(filament_width_meas);</front>
<front id="Marlin_mainCPP-5191">  }</front>
<front id="Marlin_mainCPP-5192"></front>
<front id="Marlin_mainCPP-5193">#endif // FILAMENT_SENSOR</front>
<front id="Marlin_mainCPP-5194"></front>
<front id="Marlin_mainCPP-5195">/**</front>
<front id="Marlin_mainCPP-5196"> * M410: Quickstop - Abort all planned moves</front>
<front id="Marlin_mainCPP-5197"> *</front>
<front id="Marlin_mainCPP-5198"> * This will stop the carriages mid-move, so most likely they</front>
<front id="Marlin_mainCPP-5199"> * will be out of sync with the stepper position after this.</front>
<front id="Marlin_mainCPP-5200"> */</front>
<front id="Marlin_mainCPP-5201">inline void gcode_M410() { quickStop(); }</front>
<front id="Marlin_mainCPP-5202"></front>
<front id="Marlin_mainCPP-5203"></front>
<front id="Marlin_mainCPP-5204">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-5205"></front>
<front id="Marlin_mainCPP-5206">  /**</front>
<front id="Marlin_mainCPP-5207">   * M420: Enable/Disable Mesh Bed Leveling</front>
<front id="Marlin_mainCPP-5208">   */</front>
<front id="Marlin_mainCPP-5209">  inline void gcode_M420() { if (code_seen('S') && code_has_value()) mbl.active = !!code_value_short(); }</front>
<front id="Marlin_mainCPP-5210"></front>
<front id="Marlin_mainCPP-5211">  /**</front>
<front id="Marlin_mainCPP-5212">   * M421: Set a single Mesh Bed Leveling Z coordinate</front>
<front id="Marlin_mainCPP-5213">   */</front>
<front id="Marlin_mainCPP-5214">  inline void gcode_M421() {</front>
<front id="Marlin_mainCPP-5215">    float x, y, z;</front>
<front id="Marlin_mainCPP-5216">    bool err = false, hasX, hasY, hasZ;</front>
<front id="Marlin_mainCPP-5217">    if ((hasX = code_seen('X'))) x = code_value();</front>
<front id="Marlin_mainCPP-5218">    if ((hasY = code_seen('Y'))) y = code_value();</front>
<front id="Marlin_mainCPP-5219">    if ((hasZ = code_seen('Z'))) z = code_value();</front>
<front id="Marlin_mainCPP-5220"></front>
<front id="Marlin_mainCPP-5221">    if (!hasX || !hasY || !hasZ) {</front>
<front id="Marlin_mainCPP-5222">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5223">      SERIAL_ERRORLNPGM(MSG_ERR_M421_REQUIRES_XYZ);</front>
<front id="Marlin_mainCPP-5224">      err = true;</front>
<front id="Marlin_mainCPP-5225">    }</front>
<front id="Marlin_mainCPP-5226"></front>
<front id="Marlin_mainCPP-5227">    if (x &gt;= MESH_NUM_X_POINTS || y &gt;= MESH_NUM_Y_POINTS) {</front>
<front id="Marlin_mainCPP-5228">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5229">      SERIAL_ERRORLNPGM(MSG_ERR_MESH_INDEX_OOB);</front>
<front id="Marlin_mainCPP-5230">      err = true;</front>
<front id="Marlin_mainCPP-5231">    }</front>
<front id="Marlin_mainCPP-5232"></front>
<front id="Marlin_mainCPP-5233">    if (!err) mbl.set_z(mbl.select_x_index(x), mbl.select_y_index(y), z);</front>
<front id="Marlin_mainCPP-5234">  }</front>
<front id="Marlin_mainCPP-5235"></front>
<front id="Marlin_mainCPP-5236">#endif</front>
<front id="Marlin_mainCPP-5237"></front>
<front id="Marlin_mainCPP-5238">/**</front>
<front id="Marlin_mainCPP-5239"> * M428: Set home_offset based on the distance between the</front>
<front id="Marlin_mainCPP-5240"> *       current_position and the nearest "reference point."</front>
<front id="Marlin_mainCPP-5241"> *       If an axis is past center its endstop position</front>
<front id="Marlin_mainCPP-5242"> *       is the reference-point. Otherwise it uses 0. This allows</front>
<front id="Marlin_mainCPP-5243"> *       the Z offset to be set near the bed when using a max endstop.</front>
<front id="Marlin_mainCPP-5244"> *</front>
<front id="Marlin_mainCPP-5245"> *       M428 can't be used more than 2cm away from 0 or an endstop.</front>
<front id="Marlin_mainCPP-5246"> *</front>
<front id="Marlin_mainCPP-5247"> *       Use M206 to set these values directly.</front>
<front id="Marlin_mainCPP-5248"> */</front>
<front id="Marlin_mainCPP-5249">inline void gcode_M428() {</front>
<front id="Marlin_mainCPP-5250">  bool err = false;</front>
<front id="Marlin_mainCPP-5251">  float new_offs[3], new_pos[3];</front>
<front id="Marlin_mainCPP-5252">  memcpy(new_pos, current_position, sizeof(new_pos));</front>
<front id="Marlin_mainCPP-5253">  memcpy(new_offs, home_offset, sizeof(new_offs));</front>
<front id="Marlin_mainCPP-5254">  for (int8_t i = X_AXIS; i &lt;= Z_AXIS; i++) {</front>
<front id="Marlin_mainCPP-5255">    if (axis_known_position[i]) {</front>
<front id="Marlin_mainCPP-5256">      float base = (new_pos[i] &gt; (min_pos[i] + max_pos[i]) / 2) ? base_home_pos(i) : 0,</front>
<front id="Marlin_mainCPP-5257">            diff = new_pos[i] - base;</front>
<front id="Marlin_mainCPP-5258">      if (diff &gt; -20 && diff &lt; 20) {</front>
<front id="Marlin_mainCPP-5259">        new_offs[i] -= diff;</front>
<front id="Marlin_mainCPP-5260">        new_pos[i] = base;</front>
<front id="Marlin_mainCPP-5261">      }</front>
<front id="Marlin_mainCPP-5262">      else {</front>
<front id="Marlin_mainCPP-5263">        SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5264">        SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);</front>
<front id="Marlin_mainCPP-5265">        LCD_ALERTMESSAGEPGM("Err: Too far!");</front>
<front id="Marlin_mainCPP-5266">        #if HAS_BUZZER</front>
<front id="Marlin_mainCPP-5267">          enqueuecommands_P(PSTR("M300 S40 P200"));</front>
<front id="Marlin_mainCPP-5268">        #endif</front>
<front id="Marlin_mainCPP-5269">        err = true;</front>
<front id="Marlin_mainCPP-5270">        break;</front>
<front id="Marlin_mainCPP-5271">      }</front>
<front id="Marlin_mainCPP-5272">    }</front>
<front id="Marlin_mainCPP-5273">  }</front>
<front id="Marlin_mainCPP-5274"></front>
<front id="Marlin_mainCPP-5275">  if (!err) {</front>
<front id="Marlin_mainCPP-5276">    memcpy(current_position, new_pos, sizeof(new_pos));</front>
<front id="Marlin_mainCPP-5277">    memcpy(home_offset, new_offs, sizeof(new_offs));</front>
<front id="Marlin_mainCPP-5278">    sync_plan_position();</front>
<front id="Marlin_mainCPP-5279">    LCD_ALERTMESSAGEPGM("Offset applied.");</front>
<front id="Marlin_mainCPP-5280">    #if HAS_BUZZER</front>
<front id="Marlin_mainCPP-5281">      enqueuecommands_P(PSTR("M300 S659 P200\nM300 S698 P200"));</front>
<front id="Marlin_mainCPP-5282">    #endif</front>
<front id="Marlin_mainCPP-5283">  }</front>
<front id="Marlin_mainCPP-5284">}</front>
<front id="Marlin_mainCPP-5285"></front>
<front id="Marlin_mainCPP-5286">/**</front>
<front id="Marlin_mainCPP-5287"> * M500: Store settings in EEPROM</front>
<front id="Marlin_mainCPP-5288"> */</front>
<front id="Marlin_mainCPP-5289">inline void gcode_M500() {</front>
<front id="Marlin_mainCPP-5290">  Config_StoreSettings();</front>
<front id="Marlin_mainCPP-5291">}</front>
<front id="Marlin_mainCPP-5292"></front>
<front id="Marlin_mainCPP-5293">/**</front>
<front id="Marlin_mainCPP-5294"> * M501: Read settings from EEPROM</front>
<front id="Marlin_mainCPP-5295"> */</front>
<front id="Marlin_mainCPP-5296">inline void gcode_M501() {</front>
<front id="Marlin_mainCPP-5297">  Config_RetrieveSettings();</front>
<front id="Marlin_mainCPP-5298">}</front>
<front id="Marlin_mainCPP-5299"></front>
<front id="Marlin_mainCPP-5300">/**</front>
<front id="Marlin_mainCPP-5301"> * M502: Revert to default settings</front>
<front id="Marlin_mainCPP-5302"> */</front>
<front id="Marlin_mainCPP-5303">inline void gcode_M502() {</front>
<front id="Marlin_mainCPP-5304">  Config_ResetDefault();</front>
<front id="Marlin_mainCPP-5305">}</front>
<front id="Marlin_mainCPP-5306"></front>
<front id="Marlin_mainCPP-5307">/**</front>
<front id="Marlin_mainCPP-5308"> * M503: print settings currently in memory</front>
<front id="Marlin_mainCPP-5309"> */</front>
<front id="Marlin_mainCPP-5310">inline void gcode_M503() {</front>
<front id="Marlin_mainCPP-5311">  Config_PrintSettings(code_seen('S') && code_value() == 0);</front>
<front id="Marlin_mainCPP-5312">}</front>
<front id="Marlin_mainCPP-5313"></front>
<front id="Marlin_mainCPP-5314">#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-5315"></front>
<front id="Marlin_mainCPP-5316">  /**</front>
<front id="Marlin_mainCPP-5317">   * M540: Set whether SD card print should abort on endstop hit (M540 S&lt;0|1&gt;)</front>
<front id="Marlin_mainCPP-5318">   */</front>
<front id="Marlin_mainCPP-5319">  inline void gcode_M540() {</front>
<front id="Marlin_mainCPP-5320">    if (code_seen('S')) abort_on_endstop_hit = (code_value() &gt; 0);</front>
<front id="Marlin_mainCPP-5321">  }</front>
<front id="Marlin_mainCPP-5322"></front>
<front id="Marlin_mainCPP-5323">#endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</front>
<front id="Marlin_mainCPP-5324"></front>
<front id="Marlin_mainCPP-5325">#ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-5326"></front>
<front id="Marlin_mainCPP-5327">  inline void gcode_SET_Z_PROBE_OFFSET() {</front>
<front id="Marlin_mainCPP-5328"></front>
<front id="Marlin_mainCPP-5329">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5330">    SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET);</front>
<front id="Marlin_mainCPP-5331">    SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-5332"></front>
<front id="Marlin_mainCPP-5333">    if (code_seen('Z')) {</front>
<front id="Marlin_mainCPP-5334">      float value = code_value();</front>
<front id="Marlin_mainCPP-5335">      if (Z_PROBE_OFFSET_RANGE_MIN &lt;= value && value &lt;= Z_PROBE_OFFSET_RANGE_MAX) {</front>
<front id="Marlin_mainCPP-5336">        zprobe_zoffset = value;</front>
<front id="Marlin_mainCPP-5337">        SERIAL_ECHOPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-5338">      }</front>
<front id="Marlin_mainCPP-5339">      else {</front>
<front id="Marlin_mainCPP-5340">        SERIAL_ECHOPGM(MSG_Z_MIN);</front>
<front id="Marlin_mainCPP-5341">        SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MIN);</front>
<front id="Marlin_mainCPP-5342">        SERIAL_ECHOPGM(MSG_Z_MAX);</front>
<front id="Marlin_mainCPP-5343">        SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MAX);</front>
<front id="Marlin_mainCPP-5344">      }</front>
<front id="Marlin_mainCPP-5345">    }</front>
<front id="Marlin_mainCPP-5346">    else {</front>
<front id="Marlin_mainCPP-5347">      SERIAL_ECHOPAIR(": ", zprobe_zoffset);</front>
<front id="Marlin_mainCPP-5348">    }</front>
<front id="Marlin_mainCPP-5349"></front>
<front id="Marlin_mainCPP-5350">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-5351">  }</front>
<front id="Marlin_mainCPP-5352"></front>
<front id="Marlin_mainCPP-5353">#endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-5354"></front>
<front id="Marlin_mainCPP-5355">#if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="Marlin_mainCPP-5356"></front>
<front id="Marlin_mainCPP-5357">  /**</front>
<front id="Marlin_mainCPP-5358">   * M600: Pause for filament change</front>
<front id="Marlin_mainCPP-5359">   *</front>
<front id="Marlin_mainCPP-5360">   *  E[distance] - Retract the filament this far (negative value)</front>
<front id="Marlin_mainCPP-5361">   *  Z[distance] - Move the Z axis by this distance</front>
<front id="Marlin_mainCPP-5362">   *  X[position] - Move to this X position, with Y</front>
<front id="Marlin_mainCPP-5363">   *  Y[position] - Move to this Y position, with X</front>
<front id="Marlin_mainCPP-5364">   *  L[distance] - Retract distance for removal (manual reload)</front>
<front id="Marlin_mainCPP-5365">   *</front>
<front id="Marlin_mainCPP-5366">   *  Default values are used for omitted arguments.</front>
<front id="Marlin_mainCPP-5367">   *</front>
<front id="Marlin_mainCPP-5368">   */</front>
<front id="Marlin_mainCPP-5369">  inline void gcode_M600() {</front>
<front id="Marlin_mainCPP-5370"></front>
<front id="Marlin_mainCPP-5371">    if (degHotend(active_extruder) &lt; extrude_min_temp) {</front>
<front id="Marlin_mainCPP-5372">      SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-5373">      SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);</front>
<front id="Marlin_mainCPP-5374">      return;</front>
<front id="Marlin_mainCPP-5375">    }</front>
<front id="Marlin_mainCPP-5376"></front>
<front id="Marlin_mainCPP-5377">    float lastpos[NUM_AXIS], fr60 = feedrate / 60;</front>
<front id="Marlin_mainCPP-5378"></front>
<front id="Marlin_mainCPP-5379">    for (int i=0; i&lt;NUM_AXIS; i++)</front>
<front id="Marlin_mainCPP-5380">      lastpos[i] = destination[i] = current_position[i];</front>
<front id="Marlin_mainCPP-5381"></front>
<front id="Marlin_mainCPP-5382">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-5383">      #define RUNPLAN calculate_delta(destination); \</front>
<front id="Marlin_mainCPP-5384">                      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);</front>
<front id="Marlin_mainCPP-5385">    #else</front>
<front id="Marlin_mainCPP-5386">      #define RUNPLAN line_to_destination();</front>
<front id="Marlin_mainCPP-5387">    #endif</front>
<front id="Marlin_mainCPP-5388"></front>
<front id="Marlin_mainCPP-5389">    //retract by E</front>
<front id="Marlin_mainCPP-5390">    if (code_seen('E')) destination[E_AXIS] += code_value();</front>
<front id="Marlin_mainCPP-5391">    #ifdef FILAMENTCHANGE_FIRSTRETRACT</front>
<front id="Marlin_mainCPP-5392">      else destination[E_AXIS] += FILAMENTCHANGE_FIRSTRETRACT;</front>
<front id="Marlin_mainCPP-5393">    #endif</front>
<front id="Marlin_mainCPP-5394"></front>
<front id="Marlin_mainCPP-5395">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5396"></front>
<front id="Marlin_mainCPP-5397">    //lift Z</front>
<front id="Marlin_mainCPP-5398">    if (code_seen('Z')) destination[Z_AXIS] += code_value();</front>
<front id="Marlin_mainCPP-5399">    #ifdef FILAMENTCHANGE_ZADD</front>
<front id="Marlin_mainCPP-5400">      else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;</front>
<front id="Marlin_mainCPP-5401">    #endif</front>
<front id="Marlin_mainCPP-5402"></front>
<front id="Marlin_mainCPP-5403">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5404"></front>
<front id="Marlin_mainCPP-5405">    //move xy</front>
<front id="Marlin_mainCPP-5406">    if (code_seen('X')) destination[X_AXIS] = code_value();</front>
<front id="Marlin_mainCPP-5407">    #ifdef FILAMENTCHANGE_XPOS</front>
<front id="Marlin_mainCPP-5408">      else destination[X_AXIS] = FILAMENTCHANGE_XPOS;</front>
<front id="Marlin_mainCPP-5409">    #endif</front>
<front id="Marlin_mainCPP-5410"></front>
<front id="Marlin_mainCPP-5411">    if (code_seen('Y')) destination[Y_AXIS] = code_value();</front>
<front id="Marlin_mainCPP-5412">    #ifdef FILAMENTCHANGE_YPOS</front>
<front id="Marlin_mainCPP-5413">      else destination[Y_AXIS] = FILAMENTCHANGE_YPOS;</front>
<front id="Marlin_mainCPP-5414">    #endif</front>
<front id="Marlin_mainCPP-5415"></front>
<front id="Marlin_mainCPP-5416">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5417"></front>
<front id="Marlin_mainCPP-5418">    if (code_seen('L')) destination[E_AXIS] += code_value();</front>
<front id="Marlin_mainCPP-5419">    #ifdef FILAMENTCHANGE_FINALRETRACT</front>
<front id="Marlin_mainCPP-5420">      else destination[E_AXIS] += FILAMENTCHANGE_FINALRETRACT;</front>
<front id="Marlin_mainCPP-5421">    #endif</front>
<front id="Marlin_mainCPP-5422"></front>
<front id="Marlin_mainCPP-5423">    RUNPLAN;</front>
<front id="Marlin_mainCPP-5424"></front>
<front id="Marlin_mainCPP-5425">    //finish moves</front>
<front id="Marlin_mainCPP-5426">    st_synchronize();</front>
<front id="Marlin_mainCPP-5427">    //disable extruder steppers so filament can be removed</front>
<front id="Marlin_mainCPP-5428">    disable_e0();</front>
<front id="Marlin_mainCPP-5429">    disable_e1();</front>
<front id="Marlin_mainCPP-5430">    disable_e2();</front>
<front id="Marlin_mainCPP-5431">    disable_e3();</front>
<front id="Marlin_mainCPP-5432">    delay(100);</front>
<front id="Marlin_mainCPP-5433">    LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);</front>
<front id="Marlin_mainCPP-5434">    millis_t next_tick = 0;</front>
<front id="Marlin_mainCPP-5435">    while (!lcd_clicked()) {</front>
<front id="Marlin_mainCPP-5436">      #if DISABLED(AUTO_FILAMENT_CHANGE)</front>
<front id="Marlin_mainCPP-5437">        millis_t ms = millis();</front>
<front id="Marlin_mainCPP-5438">        if (ms &gt;= next_tick) {</front>
<front id="Marlin_mainCPP-5439">          lcd_quick_feedback();</front>
<front id="Marlin_mainCPP-5440">          next_tick = ms + 2500; // feedback every 2.5s while waiting</front>
<front id="Marlin_mainCPP-5441">        }</front>
<front id="Marlin_mainCPP-5442">        manage_heater();</front>
<front id="Marlin_mainCPP-5443">        manage_inactivity(true);</front>
<front id="Marlin_mainCPP-5444">        lcd_update();</front>
<front id="Marlin_mainCPP-5445">      #else</front>
<front id="Marlin_mainCPP-5446">        current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;</front>
<front id="Marlin_mainCPP-5447">        destination[E_AXIS] = current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-5448">        line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);</front>
<front id="Marlin_mainCPP-5449">        st_synchronize();</front>
<front id="Marlin_mainCPP-5450">      #endif</front>
<front id="Marlin_mainCPP-5451">    } // while(!lcd_clicked)</front>
<front id="Marlin_mainCPP-5452">    lcd_quick_feedback(); // click sound feedback</front>
<front id="Marlin_mainCPP-5453"></front>
<front id="Marlin_mainCPP-5454">    #if ENABLED(AUTO_FILAMENT_CHANGE)</front>
<front id="Marlin_mainCPP-5455">      current_position[E_AXIS] = 0;</front>
<front id="Marlin_mainCPP-5456">      st_synchronize();</front>
<front id="Marlin_mainCPP-5457">    #endif</front>
<front id="Marlin_mainCPP-5458"></front>
<front id="Marlin_mainCPP-5459">    //return to normal</front>
<front id="Marlin_mainCPP-5460">    if (code_seen('L')) destination[E_AXIS] -= code_value();</front>
<front id="Marlin_mainCPP-5461">    #ifdef FILAMENTCHANGE_FINALRETRACT</front>
<front id="Marlin_mainCPP-5462">      else destination[E_AXIS] -= FILAMENTCHANGE_FINALRETRACT;</front>
<front id="Marlin_mainCPP-5463">    #endif</front>
<front id="Marlin_mainCPP-5464"></front>
<front id="Marlin_mainCPP-5465">    current_position[E_AXIS] = destination[E_AXIS]; //the long retract of L is compensated by manual filament feeding</front>
<front id="Marlin_mainCPP-5466">    plan_set_e_position(current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-5467"></front>
<front id="Marlin_mainCPP-5468">    RUNPLAN; //should do nothing</front>
<front id="Marlin_mainCPP-5469"></front>
<front id="Marlin_mainCPP-5470">    lcd_reset_alert_level();</front>
<front id="Marlin_mainCPP-5471"></front>
<front id="Marlin_mainCPP-5472">    #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-5473">      // Move XYZ to starting position, then E</front>
<front id="Marlin_mainCPP-5474">      calculate_delta(lastpos);</front>
<front id="Marlin_mainCPP-5475">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);</front>
<front id="Marlin_mainCPP-5476">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], fr60, active_extruder);</front>
<front id="Marlin_mainCPP-5477">    #else</front>
<front id="Marlin_mainCPP-5478">      // Move XY to starting position, then Z, then E</front>
<front id="Marlin_mainCPP-5479">      destination[X_AXIS] = lastpos[X_AXIS];</front>
<front id="Marlin_mainCPP-5480">      destination[Y_AXIS] = lastpos[Y_AXIS];</front>
<front id="Marlin_mainCPP-5481">      line_to_destination();</front>
<front id="Marlin_mainCPP-5482">      destination[Z_AXIS] = lastpos[Z_AXIS];</front>
<front id="Marlin_mainCPP-5483">      line_to_destination();</front>
<front id="Marlin_mainCPP-5484">      destination[E_AXIS] = lastpos[E_AXIS];</front>
<front id="Marlin_mainCPP-5485">      line_to_destination();</front>
<front id="Marlin_mainCPP-5486">    #endif</front>
<front id="Marlin_mainCPP-5487"></front>
<front id="Marlin_mainCPP-5488">    #if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="Marlin_mainCPP-5489">      filrunoutEnqueued = false;</front>
<front id="Marlin_mainCPP-5490">    #endif</front>
<front id="Marlin_mainCPP-5491"></front>
<front id="Marlin_mainCPP-5492">  }</front>
<front id="Marlin_mainCPP-5493"></front>
<front id="Marlin_mainCPP-5494">#endif // FILAMENTCHANGEENABLE</front>
<front id="Marlin_mainCPP-5495"></front>
<front id="Marlin_mainCPP-5496">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-5497"></front>
<front id="Marlin_mainCPP-5498">  /**</front>
<front id="Marlin_mainCPP-5499">   * M605: Set dual x-carriage movement mode</front>
<front id="Marlin_mainCPP-5500">   *</front>
<front id="Marlin_mainCPP-5501">   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement</front>
<front id="Marlin_mainCPP-5502">   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement</front>
<front id="Marlin_mainCPP-5503">   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn</front>
<front id="Marlin_mainCPP-5504">   *                         millimeters x-offset and an optional differential hotend temperature of</front>
<front id="Marlin_mainCPP-5505">   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate</front>
<front id="Marlin_mainCPP-5506">   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.</front>
<front id="Marlin_mainCPP-5507">   *</front>
<front id="Marlin_mainCPP-5508">   *    Note: the X axis should be homed after changing dual x-carriage mode.</front>
<front id="Marlin_mainCPP-5509">   */</front>
<front id="Marlin_mainCPP-5510">  inline void gcode_M605() {</front>
<front id="Marlin_mainCPP-5511">    st_synchronize();</front>
<front id="Marlin_mainCPP-5512">    if (code_seen('S')) dual_x_carriage_mode = code_value();</front>
<front id="Marlin_mainCPP-5513">    switch(dual_x_carriage_mode) {</front>
<front id="Marlin_mainCPP-5514">      case DXC_DUPLICATION_MODE:</front>
<front id="Marlin_mainCPP-5515">        if (code_seen('X')) duplicate_extruder_x_offset = max(code_value(), X2_MIN_POS - x_home_pos(0));</front>
<front id="Marlin_mainCPP-5516">        if (code_seen('R')) duplicate_extruder_temp_offset = code_value();</front>
<front id="Marlin_mainCPP-5517">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5518">        SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);</front>
<front id="Marlin_mainCPP-5519">        SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-5520">        SERIAL_ECHO(extruder_offset[X_AXIS][0]);</front>
<front id="Marlin_mainCPP-5521">        SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-5522">        SERIAL_ECHO(extruder_offset[Y_AXIS][0]);</front>
<front id="Marlin_mainCPP-5523">        SERIAL_CHAR(' ');</front>
<front id="Marlin_mainCPP-5524">        SERIAL_ECHO(duplicate_extruder_x_offset);</front>
<front id="Marlin_mainCPP-5525">        SERIAL_CHAR(',');</front>
<front id="Marlin_mainCPP-5526">        SERIAL_ECHOLN(extruder_offset[Y_AXIS][1]);</front>
<front id="Marlin_mainCPP-5527">        break;</front>
<front id="Marlin_mainCPP-5528">      case DXC_FULL_CONTROL_MODE:</front>
<front id="Marlin_mainCPP-5529">      case DXC_AUTO_PARK_MODE:</front>
<front id="Marlin_mainCPP-5530">        break;</front>
<front id="Marlin_mainCPP-5531">      default:</front>
<front id="Marlin_mainCPP-5532">        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;</front>
<front id="Marlin_mainCPP-5533">        break;</front>
<front id="Marlin_mainCPP-5534">    }</front>
<front id="Marlin_mainCPP-5535">    active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-5536">    extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-5537">    delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-5538">  }</front>
<front id="Marlin_mainCPP-5539"></front>
<front id="Marlin_mainCPP-5540">#endif // DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-5541"></front>
<front id="Marlin_mainCPP-5542">/**</front>
<front id="Marlin_mainCPP-5543"> * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S</front>
<front id="Marlin_mainCPP-5544"> */</front>
<front id="Marlin_mainCPP-5545">inline void gcode_M907() {</front>
<front id="Marlin_mainCPP-5546">  #if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-5547">    for (int i=0;i&lt;NUM_AXIS;i++)</front>
<front id="Marlin_mainCPP-5548">      if (code_seen(axis_codes[i])) digipot_current(i, code_value());</front>
<front id="Marlin_mainCPP-5549">    if (code_seen('B')) digipot_current(4, code_value());</front>
<front id="Marlin_mainCPP-5550">    if (code_seen('S')) for (int i=0; i&lt;=4; i++) digipot_current(i, code_value());</front>
<front id="Marlin_mainCPP-5551">  #endif</front>
<front id="Marlin_mainCPP-5552">  #ifdef MOTOR_CURRENT_PWM_XY_PIN</front>
<front id="Marlin_mainCPP-5553">    if (code_seen('X')) digipot_current(0, code_value());</front>
<front id="Marlin_mainCPP-5554">  #endif</front>
<front id="Marlin_mainCPP-5555">  #ifdef MOTOR_CURRENT_PWM_Z_PIN</front>
<front id="Marlin_mainCPP-5556">    if (code_seen('Z')) digipot_current(1, code_value());</front>
<front id="Marlin_mainCPP-5557">  #endif</front>
<front id="Marlin_mainCPP-5558">  #ifdef MOTOR_CURRENT_PWM_E_PIN</front>
<front id="Marlin_mainCPP-5559">    if (code_seen('E')) digipot_current(2, code_value());</front>
<front id="Marlin_mainCPP-5560">  #endif</front>
<front id="Marlin_mainCPP-5561">  #if ENABLED(DIGIPOT_I2C)</front>
<front id="Marlin_mainCPP-5562">    // this one uses actual amps in floating point</front>
<front id="Marlin_mainCPP-5563">    for (int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value());</front>
<front id="Marlin_mainCPP-5564">    // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)</front>
<front id="Marlin_mainCPP-5565">    for (int i=NUM_AXIS;i&lt;DIGIPOT_I2C_NUM_CHANNELS;i++) if(code_seen('B'+i-NUM_AXIS)) digipot_i2c_set_current(i, code_value());</front>
<front id="Marlin_mainCPP-5566">  #endif</front>
<front id="Marlin_mainCPP-5567">}</front>
<front id="Marlin_mainCPP-5568"></front>
<front id="Marlin_mainCPP-5569">#if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-5570"></front>
<front id="Marlin_mainCPP-5571">  /**</front>
<front id="Marlin_mainCPP-5572">   * M908: Control digital trimpot directly (M908 P&lt;pin&gt; S&lt;current&gt;)</front>
<front id="Marlin_mainCPP-5573">   */</front>
<front id="Marlin_mainCPP-5574">  inline void gcode_M908() {</front>
<front id="Marlin_mainCPP-5575">      digitalPotWrite(</front>
<front id="Marlin_mainCPP-5576">        code_seen('P') ? code_value() : 0,</front>
<front id="Marlin_mainCPP-5577">        code_seen('S') ? code_value() : 0</front>
<front id="Marlin_mainCPP-5578">      );</front>
<front id="Marlin_mainCPP-5579">  }</front>
<front id="Marlin_mainCPP-5580"></front>
<front id="Marlin_mainCPP-5581">#endif // HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-5582"></front>
<front id="Marlin_mainCPP-5583">#if HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-5584"></front>
<front id="Marlin_mainCPP-5585">  // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</front>
<front id="Marlin_mainCPP-5586">  inline void gcode_M350() {</front>
<front id="Marlin_mainCPP-5587">    if(code_seen('S')) for(int i=0;i&lt;=4;i++) microstep_mode(i,code_value());</front>
<front id="Marlin_mainCPP-5588">    for(int i=0;i&lt;NUM_AXIS;i++) if(code_seen(axis_codes[i])) microstep_mode(i,(uint8_t)code_value());</front>
<front id="Marlin_mainCPP-5589">    if(code_seen('B')) microstep_mode(4,code_value());</front>
<front id="Marlin_mainCPP-5590">    microstep_readings();</front>
<front id="Marlin_mainCPP-5591">  }</front>
<front id="Marlin_mainCPP-5592"></front>
<front id="Marlin_mainCPP-5593">  /**</front>
<front id="Marlin_mainCPP-5594">   * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B</front>
<front id="Marlin_mainCPP-5595">   *       S# determines MS1 or MS2, X# sets the pin high/low.</front>
<front id="Marlin_mainCPP-5596">   */</front>
<front id="Marlin_mainCPP-5597">  inline void gcode_M351() {</front>
<front id="Marlin_mainCPP-5598">    if (code_seen('S')) switch(code_value_short()) {</front>
<front id="Marlin_mainCPP-5599">      case 1:</front>
<front id="Marlin_mainCPP-5600">        for(int i=0;i&lt;NUM_AXIS;i++) if (code_seen(axis_codes[i])) microstep_ms(i, code_value(), -1);</front>
<front id="Marlin_mainCPP-5601">        if (code_seen('B')) microstep_ms(4, code_value(), -1);</front>
<front id="Marlin_mainCPP-5602">        break;</front>
<front id="Marlin_mainCPP-5603">      case 2:</front>
<front id="Marlin_mainCPP-5604">        for(int i=0;i&lt;NUM_AXIS;i++) if (code_seen(axis_codes[i])) microstep_ms(i, -1, code_value());</front>
<front id="Marlin_mainCPP-5605">        if (code_seen('B')) microstep_ms(4, -1, code_value());</front>
<front id="Marlin_mainCPP-5606">        break;</front>
<front id="Marlin_mainCPP-5607">    }</front>
<front id="Marlin_mainCPP-5608">    microstep_readings();</front>
<front id="Marlin_mainCPP-5609">  }</front>
<front id="Marlin_mainCPP-5610"></front>
<front id="Marlin_mainCPP-5611">#endif // HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-5612"></front>
<front id="Marlin_mainCPP-5613">/**</front>
<front id="Marlin_mainCPP-5614"> * M999: Restart after being stopped</front>
<front id="Marlin_mainCPP-5615"> */</front>
<front id="Marlin_mainCPP-5616">inline void gcode_M999() {</front>
<front id="Marlin_mainCPP-5617">  Running = true;</front>
<front id="Marlin_mainCPP-5618">  lcd_reset_alert_level();</front>
<front id="Marlin_mainCPP-5619">  // gcode_LastN = Stopped_gcode_LastN;</front>
<front id="Marlin_mainCPP-5620">  FlushSerialRequestResend();</front>
<front id="Marlin_mainCPP-5621">}</front>
<front id="Marlin_mainCPP-5622"></front>
<front id="Marlin_mainCPP-5623">/**</front>
<front id="Marlin_mainCPP-5624"> * T0-T3: Switch tool, usually switching extruders</front>
<front id="Marlin_mainCPP-5625"> *</front>
<front id="Marlin_mainCPP-5626"> *   F[mm/min] Set the movement feedrate</front>
<front id="Marlin_mainCPP-5627"> */</front>
<front id="Marlin_mainCPP-5628">inline void gcode_T(uint8_t tmp_extruder) {</front>
<front id="Marlin_mainCPP-5629">  if (tmp_extruder &gt;= EXTRUDERS) {</front>
<front id="Marlin_mainCPP-5630">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5631">    SERIAL_CHAR('T');</front>
<front id="Marlin_mainCPP-5632">    SERIAL_PROTOCOL_F(tmp_extruder,DEC);</front>
<front id="Marlin_mainCPP-5633">    SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);</front>
<front id="Marlin_mainCPP-5634">  }</front>
<front id="Marlin_mainCPP-5635">  #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-5636">    else if (!planner_disabled_below_z || layer_reached);</front>
<front id="Marlin_mainCPP-5637">  #endif</front>
<front id="Marlin_mainCPP-5638">  else {</front>
<front id="Marlin_mainCPP-5639">    target_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-5640"></front>
<front id="Marlin_mainCPP-5641">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5642">      bool make_move = false;</front>
<front id="Marlin_mainCPP-5643">    #endif</front>
<front id="Marlin_mainCPP-5644"></front>
<front id="Marlin_mainCPP-5645">    if (code_seen('F')) {</front>
<front id="Marlin_mainCPP-5646"></front>
<front id="Marlin_mainCPP-5647">      #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5648">        make_move = true;</front>
<front id="Marlin_mainCPP-5649">      #endif</front>
<front id="Marlin_mainCPP-5650"></front>
<front id="Marlin_mainCPP-5651">      float next_feedrate = code_value();</front>
<front id="Marlin_mainCPP-5652">      if (next_feedrate &gt; 0.0) feedrate = next_feedrate;</front>
<front id="Marlin_mainCPP-5653">    }</front>
<front id="Marlin_mainCPP-5654">    #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5655">      if (tmp_extruder != active_extruder) {</front>
<front id="Marlin_mainCPP-5656">        // Save current position to return to after applying extruder offset</front>
<front id="Marlin_mainCPP-5657">        set_destination_to_current();</front>
<front id="Marlin_mainCPP-5658">        #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-5659">          if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning() &&</front>
<front id="Marlin_mainCPP-5660">                (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder))) {</front>
<front id="Marlin_mainCPP-5661">            // Park old head: 1) raise 2) move to park position 3) lower</front>
<front id="Marlin_mainCPP-5662">            plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,</front>
<front id="Marlin_mainCPP-5663">                  current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-5664">            plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,</front>
<front id="Marlin_mainCPP-5665">                  current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-5666">            plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-5667">                  current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-5668">            st_synchronize();</front>
<front id="Marlin_mainCPP-5669">          }</front>
<front id="Marlin_mainCPP-5670"></front>
<front id="Marlin_mainCPP-5671">          // apply Y & Z extruder offset (x offset is already used in determining home pos)</front>
<front id="Marlin_mainCPP-5672">          current_position[Y_AXIS] = current_position[Y_AXIS] -</front>
<front id="Marlin_mainCPP-5673">                       extruder_offset[Y_AXIS][active_extruder] +</front>
<front id="Marlin_mainCPP-5674">                       extruder_offset[Y_AXIS][tmp_extruder];</front>
<front id="Marlin_mainCPP-5675">          current_position[Z_AXIS] = current_position[Z_AXIS] -</front>
<front id="Marlin_mainCPP-5676">                       extruder_offset[Z_AXIS][active_extruder] +</front>
<front id="Marlin_mainCPP-5677">                       extruder_offset[Z_AXIS][tmp_extruder];</front>
<front id="Marlin_mainCPP-5678"></front>
<front id="Marlin_mainCPP-5679">          active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-5680"></front>
<front id="Marlin_mainCPP-5681">          // This function resets the max/min values - the current position may be overwritten below.</front>
<front id="Marlin_mainCPP-5682">          set_axis_is_at_home(X_AXIS);</front>
<front id="Marlin_mainCPP-5683"></front>
<front id="Marlin_mainCPP-5684">          if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE) {</front>
<front id="Marlin_mainCPP-5685">            current_position[X_AXIS] = inactive_extruder_x_pos;</front>
<front id="Marlin_mainCPP-5686">            inactive_extruder_x_pos = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-5687">          }</front>
<front id="Marlin_mainCPP-5688">          else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {</front>
<front id="Marlin_mainCPP-5689">            active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position</front>
<front id="Marlin_mainCPP-5690">            if (active_extruder == 0 || active_extruder_parked)</front>
<front id="Marlin_mainCPP-5691">              current_position[X_AXIS] = inactive_extruder_x_pos;</front>
<front id="Marlin_mainCPP-5692">            else</front>
<front id="Marlin_mainCPP-5693">              current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;</front>
<front id="Marlin_mainCPP-5694">            inactive_extruder_x_pos = destination[X_AXIS];</front>
<front id="Marlin_mainCPP-5695">            extruder_duplication_enabled = false;</front>
<front id="Marlin_mainCPP-5696">          }</front>
<front id="Marlin_mainCPP-5697">          else {</front>
<front id="Marlin_mainCPP-5698">            // record raised toolhead position for use by unpark</front>
<front id="Marlin_mainCPP-5699">            memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));</front>
<front id="Marlin_mainCPP-5700">            raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;</front>
<front id="Marlin_mainCPP-5701">            active_extruder_parked = true;</front>
<front id="Marlin_mainCPP-5702">            delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-5703">          }</front>
<front id="Marlin_mainCPP-5704">        #else // !DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-5705">          // Offset extruder (only by XY)</front>
<front id="Marlin_mainCPP-5706">          for (int i=X_AXIS; i&lt;=Y_AXIS; i++)</front>
<front id="Marlin_mainCPP-5707">            current_position[i] += extruder_offset[i][tmp_extruder] - extruder_offset[i][active_extruder];</front>
<front id="Marlin_mainCPP-5708">          // Set the new active extruder and position</front>
<front id="Marlin_mainCPP-5709">          active_extruder = tmp_extruder;</front>
<front id="Marlin_mainCPP-5710">        #endif // !DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-5711">        #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-5712">          sync_plan_position_delta();</front>
<front id="Marlin_mainCPP-5713">        #else</front>
<front id="Marlin_mainCPP-5714">          sync_plan_position();</front>
<front id="Marlin_mainCPP-5715">        #endif</front>
<front id="Marlin_mainCPP-5716">        // Move to the old position if 'F' was in the parameters</front>
<front id="Marlin_mainCPP-5717">        if (make_move && IsRunning()) prepare_move();</front>
<front id="Marlin_mainCPP-5718">      }</front>
<front id="Marlin_mainCPP-5719"></front>
<front id="Marlin_mainCPP-5720">      #if ENABLED(EXT_SOLENOID)</front>
<front id="Marlin_mainCPP-5721">        st_synchronize();</front>
<front id="Marlin_mainCPP-5722">        disable_all_solenoids();</front>
<front id="Marlin_mainCPP-5723">        enable_solenoid_on_active_extruder();</front>
<front id="Marlin_mainCPP-5724">      #endif // EXT_SOLENOID</front>
<front id="Marlin_mainCPP-5725"></front>
<front id="Marlin_mainCPP-5726">    #endif // EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-5727">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5728">    SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);</front>
<front id="Marlin_mainCPP-5729">    SERIAL_PROTOCOLLN((int)active_extruder);</front>
<front id="Marlin_mainCPP-5730">  }</front>
<front id="Marlin_mainCPP-5731">}</front>
<front id="Marlin_mainCPP-5732"></front>
<front id="Marlin_mainCPP-5733">/**</front>
<front id="Marlin_mainCPP-5734"> * Process a single command and dispatch it to its handler</front>
<front id="Marlin_mainCPP-5735"> * This is called from the main loop()</front>
<front id="Marlin_mainCPP-5736"> */</front>
<front id="Marlin_mainCPP-5737">void process_next_command() {</front>
<front id="Marlin_mainCPP-5738">  current_command = command_queue[cmd_queue_index_r];</front>
<front id="Marlin_mainCPP-5739"></front>
<front id="Marlin_mainCPP-5740">  if ((marlin_debug_flags & DEBUG_ECHO)) {</front>
<front id="Marlin_mainCPP-5741">    SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-5742">    SERIAL_ECHOLN(current_command);</front>
<front id="Marlin_mainCPP-5743">  }</front>
<front id="Marlin_mainCPP-5744"></front>
<front id="Marlin_mainCPP-5745">  // Sanitize the current command:</front>
<front id="Marlin_mainCPP-5746">  //  - Skip leading spaces</front>
<front id="Marlin_mainCPP-5747">  //  - Bypass N[0-9][0-9]*[ ]*</front>
<front id="Marlin_mainCPP-5748">  //  - Overwrite * with nul to mark the end</front>
<front id="Marlin_mainCPP-5749">  while (*current_command == ' ') ++current_command;</front>
<front id="Marlin_mainCPP-5750">  if (*current_command == 'N' && ((current_command[1] &gt;= '0' && current_command[1] &lt;= '9') || current_command[1] == '-')) {</front>
<front id="Marlin_mainCPP-5751">    current_command += 2; // skip N[-0-9]</front>
<front id="Marlin_mainCPP-5752">    while (*current_command &gt;= '0' && *current_command &lt;= '9') ++current_command; // skip [0-9]*</front>
<front id="Marlin_mainCPP-5753">    while (*current_command == ' ') ++current_command; // skip [ ]*</front>
<front id="Marlin_mainCPP-5754">  }</front>
<front id="Marlin_mainCPP-5755">  char *starpos = strchr(current_command, '*');  // * should always be the last parameter</front>
<front id="Marlin_mainCPP-5756">  if (starpos) while (*starpos == ' ' || *starpos == '*') *starpos-- = '\0'; // nullify '*' and ' '</front>
<front id="Marlin_mainCPP-5757"></front>
<front id="Marlin_mainCPP-5758">  // Get the command code, which must be G, M, or T</front>
<front id="Marlin_mainCPP-5759">  char command_code = *current_command;</front>
<front id="Marlin_mainCPP-5760"></front>
<front id="Marlin_mainCPP-5761">  // The code must have a numeric value</front>
<front id="Marlin_mainCPP-5762">  bool code_is_good = (current_command[1] &gt;= '0' && current_command[1] &lt;= '9');</front>
<front id="Marlin_mainCPP-5763"></front>
<front id="Marlin_mainCPP-5764">  int codenum; // define ahead of goto</front>
<front id="Marlin_mainCPP-5765"></front>
<front id="Marlin_mainCPP-5766">  // Bail early if there's no code</front>
<front id="Marlin_mainCPP-5767">  if (!code_is_good) goto ExitUnknownCommand;</front>
<front id="Marlin_mainCPP-5768"></front>
<front id="Marlin_mainCPP-5769">  // Args pointer optimizes code_seen, especially those taking XYZEF</front>
<front id="Marlin_mainCPP-5770">  // This wastes a little cpu on commands that expect no arguments.</front>
<front id="Marlin_mainCPP-5771">  current_command_args = current_command;</front>
<front id="Marlin_mainCPP-5772">  while (*current_command_args && *current_command_args != ' ') ++current_command_args;</front>
<front id="Marlin_mainCPP-5773">  while (*current_command_args == ' ') ++current_command_args;</front>
<front id="Marlin_mainCPP-5774"></front>
<front id="Marlin_mainCPP-5775">  // Interpret the code int</front>
<front id="Marlin_mainCPP-5776">  seen_pointer = current_command;</front>
<front id="Marlin_mainCPP-5777">  codenum = code_value_short();</front>
<front id="Marlin_mainCPP-5778"></front>
<front id="Marlin_mainCPP-5779">  // Handle a known G, M, or T</front>
<front id="Marlin_mainCPP-5780">  switch(command_code) {</front>
<front id="Marlin_mainCPP-5781">    case 'G': switch (codenum) {</front>
<front id="Marlin_mainCPP-5782"></front>
<front id="Marlin_mainCPP-5783">      // G0, G1</front>
<front id="Marlin_mainCPP-5784">      case 0:</front>
<front id="Marlin_mainCPP-5785">      case 1:</front>
<front id="Marlin_mainCPP-5786">        gcode_G0_G1();</front>
<front id="Marlin_mainCPP-5787">        break;</front>
<front id="Marlin_mainCPP-5788"></front>
<front id="Marlin_mainCPP-5789">      // G2, G3</front>
<front id="Marlin_mainCPP-5790">      #if DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-5791">        case 2: // G2  - CW ARC</front>
<front id="Marlin_mainCPP-5792">        case 3: // G3  - CCW ARC</front>
<front id="Marlin_mainCPP-5793">          gcode_G2_G3(codenum == 2);</front>
<front id="Marlin_mainCPP-5794">          break;</front>
<front id="Marlin_mainCPP-5795">      #endif</front>
<front id="Marlin_mainCPP-5796"></front>
<front id="Marlin_mainCPP-5797">      // G4 Dwell</front>
<front id="Marlin_mainCPP-5798">      case 4:</front>
<front id="Marlin_mainCPP-5799">        gcode_G4();</front>
<front id="Marlin_mainCPP-5800">        break;</front>
<front id="Marlin_mainCPP-5801"></front>
<front id="Marlin_mainCPP-5802">      #if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-5803"></front>
<front id="Marlin_mainCPP-5804">        case 10: // G10: retract</front>
<front id="Marlin_mainCPP-5805">        case 11: // G11: retract_recover</front>
<front id="Marlin_mainCPP-5806">          gcode_G10_G11(codenum == 10);</front>
<front id="Marlin_mainCPP-5807">          break;</front>
<front id="Marlin_mainCPP-5808"></front>
<front id="Marlin_mainCPP-5809">      #endif //FWRETRACT</front>
<front id="Marlin_mainCPP-5810"></front>
<front id="Marlin_mainCPP-5811">      case 28: // G28: Home all axes, one at a time</front>
<front id="Marlin_mainCPP-5812">        gcode_G28();</front>
<front id="Marlin_mainCPP-5813">        break;</front>
<front id="Marlin_mainCPP-5814"></front>
<front id="Marlin_mainCPP-5815">      #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-5816">        case 29: // G29 Detailed Z probe, probes the bed at 3 or more points.</front>
<front id="Marlin_mainCPP-5817">          gcode_G29();</front>
<front id="Marlin_mainCPP-5818">          break;</front>
<front id="Marlin_mainCPP-5819">      #endif</front>
<front id="Marlin_mainCPP-5820"></front>
<front id="Marlin_mainCPP-5821">      #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-5822"></front>
<front id="Marlin_mainCPP-5823">        #if DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-5824"></front>
<front id="Marlin_mainCPP-5825">          case 30: // G30 Single Z probe</front>
<front id="Marlin_mainCPP-5826">            gcode_G30();</front>
<front id="Marlin_mainCPP-5827">            break;</front>
<front id="Marlin_mainCPP-5828"></front>
<front id="Marlin_mainCPP-5829">        #else // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-5830"></front>
<front id="Marlin_mainCPP-5831">            case 31: // G31: dock the sled</front>
<front id="Marlin_mainCPP-5832">            case 32: // G32: undock the sled</front>
<front id="Marlin_mainCPP-5833">              dock_sled(codenum == 31);</front>
<front id="Marlin_mainCPP-5834">              break;</front>
<front id="Marlin_mainCPP-5835"></front>
<front id="Marlin_mainCPP-5836">        #endif // Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-5837"></front>
<front id="Marlin_mainCPP-5838">      #endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-5839"></front>
<front id="Marlin_mainCPP-5840">      case 90: // G90</front>
<front id="Marlin_mainCPP-5841">        relative_mode = false;</front>
<front id="Marlin_mainCPP-5842">        break;</front>
<front id="Marlin_mainCPP-5843">      case 91: // G91</front>
<front id="Marlin_mainCPP-5844">        relative_mode = true;</front>
<front id="Marlin_mainCPP-5845">        break;</front>
<front id="Marlin_mainCPP-5846"></front>
<front id="Marlin_mainCPP-5847">      case 92: // G92</front>
<front id="Marlin_mainCPP-5848">        gcode_G92();</front>
<front id="Marlin_mainCPP-5849">        break;</front>
<front id="Marlin_mainCPP-5850">    }</front>
<front id="Marlin_mainCPP-5851">    break;</front>
<front id="Marlin_mainCPP-5852"></front>
<front id="Marlin_mainCPP-5853">    case 'M': switch (codenum) {</front>
<front id="Marlin_mainCPP-5854">      #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-5855">        case 0: // M0 - Unconditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-5856">        case 1: // M1 - Conditional stop - Wait for user button press on LCD</front>
<front id="Marlin_mainCPP-5857">          gcode_M0_M1();</front>
<front id="Marlin_mainCPP-5858">          break;</front>
<front id="Marlin_mainCPP-5859">      #endif // ULTIPANEL</front>
<front id="Marlin_mainCPP-5860"></front>
<front id="Marlin_mainCPP-5861">      case 17:</front>
<front id="Marlin_mainCPP-5862">        gcode_M17();</front>
<front id="Marlin_mainCPP-5863">        break;</front>
<front id="Marlin_mainCPP-5864"></front>
<front id="Marlin_mainCPP-5865">      #if ENABLED(RESUME_FEATURE)</front>
<front id="Marlin_mainCPP-5866">        case 19: // M19 - resume Z</front>
<front id="Marlin_mainCPP-5867">          gcode_M19(); break;</front>
<front id="Marlin_mainCPP-5868">      #endif //RESUME_FEATURE</front>
<front id="Marlin_mainCPP-5869"></front>
<front id="Marlin_mainCPP-5870">    #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-5871"></front>
<front id="Marlin_mainCPP-5872">        case 20: // M20 - list SD card</front>
<front id="Marlin_mainCPP-5873">          gcode_M20(); break;</front>
<front id="Marlin_mainCPP-5874">        case 21: // M21 - init SD card</front>
<front id="Marlin_mainCPP-5875">          gcode_M21(); break;</front>
<front id="Marlin_mainCPP-5876">        case 22: //M22 - release SD card</front>
<front id="Marlin_mainCPP-5877">          gcode_M22(); break;</front>
<front id="Marlin_mainCPP-5878">        case 23: //M23 - Select file</front>
<front id="Marlin_mainCPP-5879">          gcode_M23(); break;</front>
<front id="Marlin_mainCPP-5880">        case 24: //M24 - Start SD print</front>
<front id="Marlin_mainCPP-5881">          gcode_M24(); break;</front>
<front id="Marlin_mainCPP-5882">        case 25: //M25 - Pause SD print</front>
<front id="Marlin_mainCPP-5883">          gcode_M25(); break;</front>
<front id="Marlin_mainCPP-5884">        case 26: //M26 - Set SD index</front>
<front id="Marlin_mainCPP-5885">          gcode_M26(); break;</front>
<front id="Marlin_mainCPP-5886">        case 27: //M27 - Get SD status</front>
<front id="Marlin_mainCPP-5887">          gcode_M27(); break;</front>
<front id="Marlin_mainCPP-5888">        case 28: //M28 - Start SD write</front>
<front id="Marlin_mainCPP-5889">          gcode_M28(); break;</front>
<front id="Marlin_mainCPP-5890">        case 29: //M29 - Stop SD write</front>
<front id="Marlin_mainCPP-5891">          gcode_M29(); break;</front>
<front id="Marlin_mainCPP-5892">        case 30: //M30 &lt;filename&gt; Delete File</front>
<front id="Marlin_mainCPP-5893">          gcode_M30(); break;</front>
<front id="Marlin_mainCPP-5894">        case 32: //M32 - Select file and start SD print</front>
<front id="Marlin_mainCPP-5895">          gcode_M32(); break;</front>
<front id="Marlin_mainCPP-5896"></front>
<front id="Marlin_mainCPP-5897">        #if ENABLED(LONG_FILENAME_HOST_SUPPORT)</front>
<front id="Marlin_mainCPP-5898">          case 33: //M33 - Get the long full path to a file or folder</front>
<front id="Marlin_mainCPP-5899">            gcode_M33(); break;</front>
<front id="Marlin_mainCPP-5900">        #endif // LONG_FILENAME_HOST_SUPPORT</front>
<front id="Marlin_mainCPP-5901"></front>
<front id="Marlin_mainCPP-5902">        case 928: //M928 - Start SD write</front>
<front id="Marlin_mainCPP-5903">          gcode_M928(); break;</front>
<front id="Marlin_mainCPP-5904"></front>
<front id="Marlin_mainCPP-5905">      #endif //SDSUPPORT</front>
<front id="Marlin_mainCPP-5906"></front>
<front id="Marlin_mainCPP-5907">      case 31: //M31 take time since the start of the SD print or an M109 command</front>
<front id="Marlin_mainCPP-5908">        gcode_M31();</front>
<front id="Marlin_mainCPP-5909">        break;</front>
<front id="Marlin_mainCPP-5910"></front>
<front id="Marlin_mainCPP-5911">      case 42: //M42 -Change pin status via gcode</front>
<front id="Marlin_mainCPP-5912">        gcode_M42();</front>
<front id="Marlin_mainCPP-5913">        break;</front>
<front id="Marlin_mainCPP-5914"></front>
<front id="Marlin_mainCPP-5915">      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)</front>
<front id="Marlin_mainCPP-5916">        case 48: // M48 Z probe repeatability</front>
<front id="Marlin_mainCPP-5917">          gcode_M48();</front>
<front id="Marlin_mainCPP-5918">          break;</front>
<front id="Marlin_mainCPP-5919">      #endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST</front>
<front id="Marlin_mainCPP-5920"></front>
<front id="Marlin_mainCPP-5921">      #if ENABLED(M100_FREE_MEMORY_WATCHER)</front>
<front id="Marlin_mainCPP-5922">        case 100:</front>
<front id="Marlin_mainCPP-5923">          gcode_M100();</front>
<front id="Marlin_mainCPP-5924">          break;</front>
<front id="Marlin_mainCPP-5925">      #endif</front>
<front id="Marlin_mainCPP-5926"></front>
<front id="Marlin_mainCPP-5927">      case 104: // M104</front>
<front id="Marlin_mainCPP-5928">        gcode_M104();</front>
<front id="Marlin_mainCPP-5929">        break;</front>
<front id="Marlin_mainCPP-5930"></front>
<front id="Marlin_mainCPP-5931">      case 111: // M111: Set debug level</front>
<front id="Marlin_mainCPP-5932">        gcode_M111();</front>
<front id="Marlin_mainCPP-5933">        break;</front>
<front id="Marlin_mainCPP-5934"></front>
<front id="Marlin_mainCPP-5935">      case 112: // M112: Emergency Stop</front>
<front id="Marlin_mainCPP-5936">        gcode_M112();</front>
<front id="Marlin_mainCPP-5937">        break;</front>
<front id="Marlin_mainCPP-5938"></front>
<front id="Marlin_mainCPP-5939">      case 140: // M140: Set bed temp</front>
<front id="Marlin_mainCPP-5940">        gcode_M140();</front>
<front id="Marlin_mainCPP-5941">        break;</front>
<front id="Marlin_mainCPP-5942"></front>
<front id="Marlin_mainCPP-5943">      case 105: // M105: Read current temperature</front>
<front id="Marlin_mainCPP-5944">        gcode_M105();</front>
<front id="Marlin_mainCPP-5945">        return; // "ok" already printed</front>
<front id="Marlin_mainCPP-5946"></front>
<front id="Marlin_mainCPP-5947">      case 109: // M109: Wait for temperature</front>
<front id="Marlin_mainCPP-5948">        gcode_M109();</front>
<front id="Marlin_mainCPP-5949">        break;</front>
<front id="Marlin_mainCPP-5950"></front>
<front id="Marlin_mainCPP-5951">      #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-5952">        case 190: // M190: Wait for bed heater to reach target</front>
<front id="Marlin_mainCPP-5953">          gcode_M190();</front>
<front id="Marlin_mainCPP-5954">          break;</front>
<front id="Marlin_mainCPP-5955">      #endif // HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-5956"></front>
<front id="Marlin_mainCPP-5957">      #if HAS_FAN</front>
<front id="Marlin_mainCPP-5958">        case 106: // M106: Fan On</front>
<front id="Marlin_mainCPP-5959">          gcode_M106();</front>
<front id="Marlin_mainCPP-5960">          break;</front>
<front id="Marlin_mainCPP-5961">        case 107: // M107: Fan Off</front>
<front id="Marlin_mainCPP-5962">          gcode_M107();</front>
<front id="Marlin_mainCPP-5963">          break;</front>
<front id="Marlin_mainCPP-5964">      #endif // HAS_FAN</front>
<front id="Marlin_mainCPP-5965"></front>
<front id="Marlin_mainCPP-5966">      #if ENABLED(BARICUDA)</front>
<front id="Marlin_mainCPP-5967">        // PWM for HEATER_1_PIN</front>
<front id="Marlin_mainCPP-5968">        #if HAS_HEATER_1</front>
<front id="Marlin_mainCPP-5969">          case 126: // M126: valve open</front>
<front id="Marlin_mainCPP-5970">            gcode_M126();</front>
<front id="Marlin_mainCPP-5971">            break;</front>
<front id="Marlin_mainCPP-5972">          case 127: // M127: valve closed</front>
<front id="Marlin_mainCPP-5973">            gcode_M127();</front>
<front id="Marlin_mainCPP-5974">            break;</front>
<front id="Marlin_mainCPP-5975">        #endif // HAS_HEATER_1</front>
<front id="Marlin_mainCPP-5976"></front>
<front id="Marlin_mainCPP-5977">        // PWM for HEATER_2_PIN</front>
<front id="Marlin_mainCPP-5978">        #if HAS_HEATER_2</front>
<front id="Marlin_mainCPP-5979">          case 128: // M128: valve open</front>
<front id="Marlin_mainCPP-5980">            gcode_M128();</front>
<front id="Marlin_mainCPP-5981">            break;</front>
<front id="Marlin_mainCPP-5982">          case 129: // M129: valve closed</front>
<front id="Marlin_mainCPP-5983">            gcode_M129();</front>
<front id="Marlin_mainCPP-5984">            break;</front>
<front id="Marlin_mainCPP-5985">        #endif // HAS_HEATER_2</front>
<front id="Marlin_mainCPP-5986">      #endif // BARICUDA</front>
<front id="Marlin_mainCPP-5987"></front>
<front id="Marlin_mainCPP-5988">      #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-5989"></front>
<front id="Marlin_mainCPP-5990">        case 80: // M80: Turn on Power Supply</front>
<front id="Marlin_mainCPP-5991">          gcode_M80();</front>
<front id="Marlin_mainCPP-5992">          break;</front>
<front id="Marlin_mainCPP-5993"></front>
<front id="Marlin_mainCPP-5994">      #endif // HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-5995"></front>
<front id="Marlin_mainCPP-5996">      case 81: // M81: Turn off Power, including Power Supply, if possible</front>
<front id="Marlin_mainCPP-5997">        gcode_M81();</front>
<front id="Marlin_mainCPP-5998">        break;</front>
<front id="Marlin_mainCPP-5999"></front>
<front id="Marlin_mainCPP-6000">      case 82:</front>
<front id="Marlin_mainCPP-6001">        gcode_M82();</front>
<front id="Marlin_mainCPP-6002">        break;</front>
<front id="Marlin_mainCPP-6003">      case 83:</front>
<front id="Marlin_mainCPP-6004">        gcode_M83();</front>
<front id="Marlin_mainCPP-6005">        break;</front>
<front id="Marlin_mainCPP-6006">      case 18: // (for compatibility)</front>
<front id="Marlin_mainCPP-6007">      case 84: // M84</front>
<front id="Marlin_mainCPP-6008">        gcode_M18_M84();</front>
<front id="Marlin_mainCPP-6009">        break;</front>
<front id="Marlin_mainCPP-6010">      case 85: // M85</front>
<front id="Marlin_mainCPP-6011">        gcode_M85();</front>
<front id="Marlin_mainCPP-6012">        break;</front>
<front id="Marlin_mainCPP-6013">      case 92: // M92: Set the steps-per-unit for one or more axes</front>
<front id="Marlin_mainCPP-6014">        gcode_M92();</front>
<front id="Marlin_mainCPP-6015">        break;</front>
<front id="Marlin_mainCPP-6016">      case 115: // M115: Report capabilities</front>
<front id="Marlin_mainCPP-6017">        gcode_M115();</front>
<front id="Marlin_mainCPP-6018">        break;</front>
<front id="Marlin_mainCPP-6019">      case 117: // M117: Set LCD message text, if possible</front>
<front id="Marlin_mainCPP-6020">        gcode_M117();</front>
<front id="Marlin_mainCPP-6021">        break;</front>
<front id="Marlin_mainCPP-6022">      case 114: // M114: Report current position</front>
<front id="Marlin_mainCPP-6023">        gcode_M114();</front>
<front id="Marlin_mainCPP-6024">        break;</front>
<front id="Marlin_mainCPP-6025">      case 120: // M120: Enable endstops</front>
<front id="Marlin_mainCPP-6026">        gcode_M120();</front>
<front id="Marlin_mainCPP-6027">        break;</front>
<front id="Marlin_mainCPP-6028">      case 121: // M121: Disable endstops</front>
<front id="Marlin_mainCPP-6029">        gcode_M121();</front>
<front id="Marlin_mainCPP-6030">        break;</front>
<front id="Marlin_mainCPP-6031">      case 119: // M119: Report endstop states</front>
<front id="Marlin_mainCPP-6032">        gcode_M119();</front>
<front id="Marlin_mainCPP-6033">        break;</front>
<front id="Marlin_mainCPP-6034"></front>
<front id="Marlin_mainCPP-6035">      #if ENABLED(ULTIPANEL)</front>
<front id="Marlin_mainCPP-6036"></front>
<front id="Marlin_mainCPP-6037">        case 145: // M145: Set material heatup parameters</front>
<front id="Marlin_mainCPP-6038">          gcode_M145();</front>
<front id="Marlin_mainCPP-6039">          break;</front>
<front id="Marlin_mainCPP-6040"></front>
<front id="Marlin_mainCPP-6041">      #endif</front>
<front id="Marlin_mainCPP-6042"></front>
<front id="Marlin_mainCPP-6043">      #if ENABLED(BLINKM)</front>
<front id="Marlin_mainCPP-6044"></front>
<front id="Marlin_mainCPP-6045">        case 150: // M150</front>
<front id="Marlin_mainCPP-6046">          gcode_M150();</front>
<front id="Marlin_mainCPP-6047">          break;</front>
<front id="Marlin_mainCPP-6048"></front>
<front id="Marlin_mainCPP-6049">      #endif //BLINKM</front>
<front id="Marlin_mainCPP-6050"></front>
<front id="Marlin_mainCPP-6051">      case 200: // M200 D&lt;millimeters&gt; set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).</front>
<front id="Marlin_mainCPP-6052">        gcode_M200();</front>
<front id="Marlin_mainCPP-6053">        break;</front>
<front id="Marlin_mainCPP-6054">      case 201: // M201</front>
<front id="Marlin_mainCPP-6055">        gcode_M201();</front>
<front id="Marlin_mainCPP-6056">        break;</front>
<front id="Marlin_mainCPP-6057">      #if 0 // Not used for Sprinter/grbl gen6</front>
<front id="Marlin_mainCPP-6058">      case 202: // M202</front>
<front id="Marlin_mainCPP-6059">        gcode_M202();</front>
<front id="Marlin_mainCPP-6060">        break;</front>
<front id="Marlin_mainCPP-6061">      #endif</front>
<front id="Marlin_mainCPP-6062">      case 203: // M203 max feedrate mm/sec</front>
<front id="Marlin_mainCPP-6063">        gcode_M203();</front>
<front id="Marlin_mainCPP-6064">        break;</front>
<front id="Marlin_mainCPP-6065">      case 204: // M204 acclereration S normal moves T filmanent only moves</front>
<front id="Marlin_mainCPP-6066">        gcode_M204();</front>
<front id="Marlin_mainCPP-6067">        break;</front>
<front id="Marlin_mainCPP-6068">      case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk</front>
<front id="Marlin_mainCPP-6069">        gcode_M205();</front>
<front id="Marlin_mainCPP-6070">        break;</front>
<front id="Marlin_mainCPP-6071">      case 206: // M206 additional homing offset</front>
<front id="Marlin_mainCPP-6072">        gcode_M206();</front>
<front id="Marlin_mainCPP-6073">        break;</front>
<front id="Marlin_mainCPP-6074"></front>
<front id="Marlin_mainCPP-6075">      #if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-6076">        case 665: // M665 set delta configurations L&lt;diagonal_rod&gt; R&lt;delta_radius&gt; S&lt;segments_per_sec&gt;</front>
<front id="Marlin_mainCPP-6077">          gcode_M665();</front>
<front id="Marlin_mainCPP-6078">          break;</front>
<front id="Marlin_mainCPP-6079">      #endif</front>
<front id="Marlin_mainCPP-6080"></front>
<front id="Marlin_mainCPP-6081">      #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="Marlin_mainCPP-6082">        case 666: // M666 set delta / dual endstop adjustment</front>
<front id="Marlin_mainCPP-6083">          gcode_M666();</front>
<front id="Marlin_mainCPP-6084">          break;</front>
<front id="Marlin_mainCPP-6085">      #endif</front>
<front id="Marlin_mainCPP-6086"></front>
<front id="Marlin_mainCPP-6087">      #if ENABLED(FWRETRACT)</front>
<front id="Marlin_mainCPP-6088">        case 207: //M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop]</front>
<front id="Marlin_mainCPP-6089">          gcode_M207();</front>
<front id="Marlin_mainCPP-6090">          break;</front>
<front id="Marlin_mainCPP-6091">        case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/min]</front>
<front id="Marlin_mainCPP-6092">          gcode_M208();</front>
<front id="Marlin_mainCPP-6093">          break;</front>
<front id="Marlin_mainCPP-6094">        case 209: // M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</front>
<front id="Marlin_mainCPP-6095">          gcode_M209();</front>
<front id="Marlin_mainCPP-6096">          break;</front>
<front id="Marlin_mainCPP-6097">      #endif // FWRETRACT</front>
<front id="Marlin_mainCPP-6098"></front>
<front id="Marlin_mainCPP-6099">      #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-6100">        case 218: // M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</front>
<front id="Marlin_mainCPP-6101">          gcode_M218();</front>
<front id="Marlin_mainCPP-6102">          break;</front>
<front id="Marlin_mainCPP-6103">      #endif</front>
<front id="Marlin_mainCPP-6104"></front>
<front id="Marlin_mainCPP-6105">      case 220: // M220 S&lt;factor in percent&gt;- set speed factor override percentage</front>
<front id="Marlin_mainCPP-6106">        gcode_M220();</front>
<front id="Marlin_mainCPP-6107">        break;</front>
<front id="Marlin_mainCPP-6108"></front>
<front id="Marlin_mainCPP-6109">      case 221: // M221 S&lt;factor in percent&gt;- set extrude factor override percentage</front>
<front id="Marlin_mainCPP-6110">        gcode_M221();</front>
<front id="Marlin_mainCPP-6111">        break;</front>
<front id="Marlin_mainCPP-6112"></front>
<front id="Marlin_mainCPP-6113">      case 226: // M226 P&lt;pin number&gt; S&lt;pin state&gt;- Wait until the specified pin reaches the state required</front>
<front id="Marlin_mainCPP-6114">        gcode_M226();</front>
<front id="Marlin_mainCPP-6115">        break;</front>
<front id="Marlin_mainCPP-6116"></front>
<front id="Marlin_mainCPP-6117">      #if HAS_SERVOS</front>
<front id="Marlin_mainCPP-6118">        case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds</front>
<front id="Marlin_mainCPP-6119">          gcode_M280();</front>
<front id="Marlin_mainCPP-6120">          break;</front>
<front id="Marlin_mainCPP-6121">      #endif // HAS_SERVOS</front>
<front id="Marlin_mainCPP-6122"></front>
<front id="Marlin_mainCPP-6123">      #if HAS_BUZZER</front>
<front id="Marlin_mainCPP-6124">        case 300: // M300 - Play beep tone</front>
<front id="Marlin_mainCPP-6125">          gcode_M300();</front>
<front id="Marlin_mainCPP-6126">          break;</front>
<front id="Marlin_mainCPP-6127">      #endif // HAS_BUZZER</front>
<front id="Marlin_mainCPP-6128"></front>
<front id="Marlin_mainCPP-6129">      #if ENABLED(PIDTEMP)</front>
<front id="Marlin_mainCPP-6130">        case 301: // M301</front>
<front id="Marlin_mainCPP-6131">          gcode_M301();</front>
<front id="Marlin_mainCPP-6132">          break;</front>
<front id="Marlin_mainCPP-6133">      #endif // PIDTEMP</front>
<front id="Marlin_mainCPP-6134"></front>
<front id="Marlin_mainCPP-6135">      #if ENABLED(PIDTEMPBED)</front>
<front id="Marlin_mainCPP-6136">        case 304: // M304</front>
<front id="Marlin_mainCPP-6137">          gcode_M304();</front>
<front id="Marlin_mainCPP-6138">          break;</front>
<front id="Marlin_mainCPP-6139">      #endif // PIDTEMPBED</front>
<front id="Marlin_mainCPP-6140"></front>
<front id="Marlin_mainCPP-6141">      #if defined(CHDK) || HAS_PHOTOGRAPH</front>
<front id="Marlin_mainCPP-6142">        case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="Marlin_mainCPP-6143">          gcode_M240();</front>
<front id="Marlin_mainCPP-6144">          break;</front>
<front id="Marlin_mainCPP-6145">      #endif // CHDK || PHOTOGRAPH_PIN</front>
<front id="Marlin_mainCPP-6146"></front>
<front id="Marlin_mainCPP-6147">      #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="Marlin_mainCPP-6148">        case 250: // M250  Set LCD contrast value: C&lt;value&gt; (value 0..63)</front>
<front id="Marlin_mainCPP-6149">          gcode_M250();</front>
<front id="Marlin_mainCPP-6150">          break;</front>
<front id="Marlin_mainCPP-6151">      #endif // HAS_LCD_CONTRAST</front>
<front id="Marlin_mainCPP-6152"></front>
<front id="Marlin_mainCPP-6153">      #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-6154">        case 302: // allow cold extrudes, or set the minimum extrude temperature</front>
<front id="Marlin_mainCPP-6155">          gcode_M302();</front>
<front id="Marlin_mainCPP-6156">          break;</front>
<front id="Marlin_mainCPP-6157">      #endif // PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-6158"></front>
<front id="Marlin_mainCPP-6159">      case 303: // M303 PID autotune</front>
<front id="Marlin_mainCPP-6160">        gcode_M303();</front>
<front id="Marlin_mainCPP-6161">        break;</front>
<front id="Marlin_mainCPP-6162"></front>
<front id="Marlin_mainCPP-6163">      #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6164">        case 360:  // M360 SCARA Theta pos1</front>
<front id="Marlin_mainCPP-6165">          if (gcode_M360()) return;</front>
<front id="Marlin_mainCPP-6166">          break;</front>
<front id="Marlin_mainCPP-6167">        case 361:  // M361 SCARA Theta pos2</front>
<front id="Marlin_mainCPP-6168">          if (gcode_M361()) return;</front>
<front id="Marlin_mainCPP-6169">          break;</front>
<front id="Marlin_mainCPP-6170">        case 362:  // M362 SCARA Psi pos1</front>
<front id="Marlin_mainCPP-6171">          if (gcode_M362()) return;</front>
<front id="Marlin_mainCPP-6172">          break;</front>
<front id="Marlin_mainCPP-6173">        case 363:  // M363 SCARA Psi pos2</front>
<front id="Marlin_mainCPP-6174">          if (gcode_M363()) return;</front>
<front id="Marlin_mainCPP-6175">          break;</front>
<front id="Marlin_mainCPP-6176">        case 364:  // M364 SCARA Psi pos3 (90 deg to Theta)</front>
<front id="Marlin_mainCPP-6177">          if (gcode_M364()) return;</front>
<front id="Marlin_mainCPP-6178">          break;</front>
<front id="Marlin_mainCPP-6179">        case 365: // M365 Set SCARA scaling for X Y Z</front>
<front id="Marlin_mainCPP-6180">          gcode_M365();</front>
<front id="Marlin_mainCPP-6181">          break;</front>
<front id="Marlin_mainCPP-6182">      #endif // SCARA</front>
<front id="Marlin_mainCPP-6183"></front>
<front id="Marlin_mainCPP-6184">      case 400: // M400 finish all moves</front>
<front id="Marlin_mainCPP-6185">        gcode_M400();</front>
<front id="Marlin_mainCPP-6186">        break;</front>
<front id="Marlin_mainCPP-6187"></front>
<front id="Marlin_mainCPP-6188">      #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)</front>
<front id="Marlin_mainCPP-6189">        case 401:</front>
<front id="Marlin_mainCPP-6190">          gcode_M401();</front>
<front id="Marlin_mainCPP-6191">          break;</front>
<front id="Marlin_mainCPP-6192">        case 402:</front>
<front id="Marlin_mainCPP-6193">          gcode_M402();</front>
<front id="Marlin_mainCPP-6194">          break;</front>
<front id="Marlin_mainCPP-6195">      #endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED</front>
<front id="Marlin_mainCPP-6196"></front>
<front id="Marlin_mainCPP-6197">      #if ENABLED(FILAMENT_SENSOR)</front>
<front id="Marlin_mainCPP-6198">        case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N&lt;3.0&gt; or display nominal filament width</front>
<front id="Marlin_mainCPP-6199">          gcode_M404();</front>
<front id="Marlin_mainCPP-6200">          break;</front>
<front id="Marlin_mainCPP-6201">        case 405:  //M405 Turn on filament sensor for control</front>
<front id="Marlin_mainCPP-6202">          gcode_M405();</front>
<front id="Marlin_mainCPP-6203">          break;</front>
<front id="Marlin_mainCPP-6204">        case 406:  //M406 Turn off filament sensor for control</front>
<front id="Marlin_mainCPP-6205">          gcode_M406();</front>
<front id="Marlin_mainCPP-6206">          break;</front>
<front id="Marlin_mainCPP-6207">        case 407:   //M407 Display measured filament diameter</front>
<front id="Marlin_mainCPP-6208">          gcode_M407();</front>
<front id="Marlin_mainCPP-6209">          break;</front>
<front id="Marlin_mainCPP-6210">      #endif // FILAMENT_SENSOR</front>
<front id="Marlin_mainCPP-6211"></front>
<front id="Marlin_mainCPP-6212">      case 410: // M410 quickstop - Abort all the planned moves.</front>
<front id="Marlin_mainCPP-6213">        gcode_M410();</front>
<front id="Marlin_mainCPP-6214">        break;</front>
<front id="Marlin_mainCPP-6215"></front>
<front id="Marlin_mainCPP-6216">      #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-6217">        case 420: // M420 Enable/Disable Mesh Bed Leveling</front>
<front id="Marlin_mainCPP-6218">          gcode_M420();</front>
<front id="Marlin_mainCPP-6219">          break;</front>
<front id="Marlin_mainCPP-6220">        case 421: // M421 Set a Mesh Bed Leveling Z coordinate</front>
<front id="Marlin_mainCPP-6221">          gcode_M421();</front>
<front id="Marlin_mainCPP-6222">          break;</front>
<front id="Marlin_mainCPP-6223">      #endif</front>
<front id="Marlin_mainCPP-6224"></front>
<front id="Marlin_mainCPP-6225">      case 428: // M428 Apply current_position to home_offset</front>
<front id="Marlin_mainCPP-6226">        gcode_M428();</front>
<front id="Marlin_mainCPP-6227">        break;</front>
<front id="Marlin_mainCPP-6228"></front>
<front id="Marlin_mainCPP-6229">      case 500: // M500 Store settings in EEPROM</front>
<front id="Marlin_mainCPP-6230">        gcode_M500();</front>
<front id="Marlin_mainCPP-6231">        break;</front>
<front id="Marlin_mainCPP-6232">      case 501: // M501 Read settings from EEPROM</front>
<front id="Marlin_mainCPP-6233">        gcode_M501();</front>
<front id="Marlin_mainCPP-6234">        break;</front>
<front id="Marlin_mainCPP-6235">      case 502: // M502 Revert to default settings</front>
<front id="Marlin_mainCPP-6236">        gcode_M502();</front>
<front id="Marlin_mainCPP-6237">        break;</front>
<front id="Marlin_mainCPP-6238">      case 503: // M503 print settings currently in memory</front>
<front id="Marlin_mainCPP-6239">        gcode_M503();</front>
<front id="Marlin_mainCPP-6240">        break;</front>
<front id="Marlin_mainCPP-6241"></front>
<front id="Marlin_mainCPP-6242">      #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="Marlin_mainCPP-6243">        case 540:</front>
<front id="Marlin_mainCPP-6244">          gcode_M540();</front>
<front id="Marlin_mainCPP-6245">          break;</front>
<front id="Marlin_mainCPP-6246">      #endif</front>
<front id="Marlin_mainCPP-6247"></front>
<front id="Marlin_mainCPP-6248">      #ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-6249">        case CUSTOM_M_CODE_SET_Z_PROBE_OFFSET:</front>
<front id="Marlin_mainCPP-6250">          gcode_SET_Z_PROBE_OFFSET();</front>
<front id="Marlin_mainCPP-6251">          break;</front>
<front id="Marlin_mainCPP-6252">      #endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</front>
<front id="Marlin_mainCPP-6253"></front>
<front id="Marlin_mainCPP-6254">      #if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="Marlin_mainCPP-6255">        case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</front>
<front id="Marlin_mainCPP-6256">          gcode_M600();</front>
<front id="Marlin_mainCPP-6257">          break;</front>
<front id="Marlin_mainCPP-6258">      #endif // FILAMENTCHANGEENABLE</front>
<front id="Marlin_mainCPP-6259"></front>
<front id="Marlin_mainCPP-6260">      #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-6261">        case 605:</front>
<front id="Marlin_mainCPP-6262">          gcode_M605();</front>
<front id="Marlin_mainCPP-6263">          break;</front>
<front id="Marlin_mainCPP-6264">      #endif // DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-6265"></front>
<front id="Marlin_mainCPP-6266">      case 907: // M907 Set digital trimpot motor current using axis codes.</front>
<front id="Marlin_mainCPP-6267">        gcode_M907();</front>
<front id="Marlin_mainCPP-6268">        break;</front>
<front id="Marlin_mainCPP-6269"></front>
<front id="Marlin_mainCPP-6270">      #if HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-6271">        case 908: // M908 Control digital trimpot directly.</front>
<front id="Marlin_mainCPP-6272">          gcode_M908();</front>
<front id="Marlin_mainCPP-6273">          break;</front>
<front id="Marlin_mainCPP-6274">      #endif // HAS_DIGIPOTSS</front>
<front id="Marlin_mainCPP-6275"></front>
<front id="Marlin_mainCPP-6276">      #if HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-6277"></front>
<front id="Marlin_mainCPP-6278">        case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</front>
<front id="Marlin_mainCPP-6279">          gcode_M350();</front>
<front id="Marlin_mainCPP-6280">          break;</front>
<front id="Marlin_mainCPP-6281"></front>
<front id="Marlin_mainCPP-6282">        case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.</front>
<front id="Marlin_mainCPP-6283">          gcode_M351();</front>
<front id="Marlin_mainCPP-6284">          break;</front>
<front id="Marlin_mainCPP-6285"></front>
<front id="Marlin_mainCPP-6286">      #endif // HAS_MICROSTEPS</front>
<front id="Marlin_mainCPP-6287"></front>
<front id="Marlin_mainCPP-6288">      case 999: // M999: Restart after being Stopped</front>
<front id="Marlin_mainCPP-6289">        gcode_M999();</front>
<front id="Marlin_mainCPP-6290">        break;</front>
<front id="Marlin_mainCPP-6291">    }</front>
<front id="Marlin_mainCPP-6292">    break;</front>
<front id="Marlin_mainCPP-6293"></front>
<front id="Marlin_mainCPP-6294">    case 'T':</front>
<front id="Marlin_mainCPP-6295">      gcode_T(codenum);</front>
<front id="Marlin_mainCPP-6296">    break;</front>
<front id="Marlin_mainCPP-6297"></front>
<front id="Marlin_mainCPP-6298">    default: code_is_good = false;</front>
<front id="Marlin_mainCPP-6299">  }</front>
<front id="Marlin_mainCPP-6300"></front>
<front id="Marlin_mainCPP-6301">ExitUnknownCommand:</front>
<front id="Marlin_mainCPP-6302"></front>
<front id="Marlin_mainCPP-6303">  // Still unknown command? Throw an error</front>
<front id="Marlin_mainCPP-6304">  if (!code_is_good) unknown_command_error();</front>
<front id="Marlin_mainCPP-6305"></front>
<front id="Marlin_mainCPP-6306">  ok_to_send();</front>
<front id="Marlin_mainCPP-6307">}</front>
<front id="Marlin_mainCPP-6308"></front>
<front id="Marlin_mainCPP-6309">void FlushSerialRequestResend() {</front>
<front id="Marlin_mainCPP-6310">  //char command_queue[cmd_queue_index_r][100]="Resend:";</front>
<front id="Marlin_mainCPP-6311">  MYSERIAL.flush();</front>
<front id="Marlin_mainCPP-6312">  SERIAL_PROTOCOLPGM(MSG_RESEND);</front>
<front id="Marlin_mainCPP-6313">  SERIAL_PROTOCOLLN(gcode_LastN + 1);</front>
<front id="Marlin_mainCPP-6314">  ok_to_send();</front>
<front id="Marlin_mainCPP-6315">}</front>
<front id="Marlin_mainCPP-6316"></front>
<front id="Marlin_mainCPP-6317">void ok_to_send() {</front>
<front id="Marlin_mainCPP-6318">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-6319">  #if ENABLED(SDSUPPORT)</front>
<front id="Marlin_mainCPP-6320">    if (fromsd[cmd_queue_index_r]) return;</front>
<front id="Marlin_mainCPP-6321">  #endif</front>
<front id="Marlin_mainCPP-6322">  SERIAL_PROTOCOLPGM(MSG_OK);</front>
<front id="Marlin_mainCPP-6323">  #if ENABLED(ADVANCED_OK)</front>
<front id="Marlin_mainCPP-6324">    SERIAL_PROTOCOLPGM(" N"); SERIAL_PROTOCOL(gcode_LastN);</front>
<front id="Marlin_mainCPP-6325">    SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - movesplanned() - 1));</front>
<front id="Marlin_mainCPP-6326">    SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);</front>
<front id="Marlin_mainCPP-6327">  #endif</front>
<front id="Marlin_mainCPP-6328">  SERIAL_EOL;</front>
<front id="Marlin_mainCPP-6329">}</front>
<front id="Marlin_mainCPP-6330"></front>
<front id="Marlin_mainCPP-6331">void clamp_to_software_endstops(float target[3]) {</front>
<front id="Marlin_mainCPP-6332">  if (min_software_endstops) {</front>
<front id="Marlin_mainCPP-6333">    NOLESS(target[X_AXIS], min_pos[X_AXIS]);</front>
<front id="Marlin_mainCPP-6334">    NOLESS(target[Y_AXIS], min_pos[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6335"></front>
<front id="Marlin_mainCPP-6336">    float negative_z_offset = 0;</front>
<front id="Marlin_mainCPP-6337">    #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6338">      if (zprobe_zoffset &lt; 0) negative_z_offset += zprobe_zoffset;</front>
<front id="Marlin_mainCPP-6339">      if (home_offset[Z_AXIS] &lt; 0) {</front>
<front id="Marlin_mainCPP-6340">        #if ENABLED(DEBUG_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6341">          if (marlin_debug_flags & DEBUG_LEVELING) {</front>
<front id="Marlin_mainCPP-6342">            SERIAL_ECHOPAIR("&gt; clamp_to_software_endstops &gt; Add home_offset[Z_AXIS]:", home_offset[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6343">            SERIAL_EOL;</front>
<front id="Marlin_mainCPP-6344">          }</front>
<front id="Marlin_mainCPP-6345">        #endif</front>
<front id="Marlin_mainCPP-6346">        negative_z_offset += home_offset[Z_AXIS];</front>
<front id="Marlin_mainCPP-6347">      }</front>
<front id="Marlin_mainCPP-6348">    #endif</front>
<front id="Marlin_mainCPP-6349">    NOLESS(target[Z_AXIS], min_pos[Z_AXIS] + negative_z_offset);</front>
<front id="Marlin_mainCPP-6350">  }</front>
<front id="Marlin_mainCPP-6351"></front>
<front id="Marlin_mainCPP-6352">  if (max_software_endstops) {</front>
<front id="Marlin_mainCPP-6353">    NOMORE(target[X_AXIS], max_pos[X_AXIS]);</front>
<front id="Marlin_mainCPP-6354">    NOMORE(target[Y_AXIS], max_pos[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6355">    NOMORE(target[Z_AXIS], max_pos[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6356">  }</front>
<front id="Marlin_mainCPP-6357">}</front>
<front id="Marlin_mainCPP-6358"></front>
<front id="Marlin_mainCPP-6359">#if ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-6360"></front>
<front id="Marlin_mainCPP-6361">  void recalc_delta_settings(float radius, float diagonal_rod) {</front>
<front id="Marlin_mainCPP-6362">    delta_tower1_x = -SIN_60 * (radius + DELTA_RADIUS_TRIM_TOWER_1);  // front left tower</front>
<front id="Marlin_mainCPP-6363">    delta_tower1_y = -COS_60 * (radius + DELTA_RADIUS_TRIM_TOWER_1);</front>
<front id="Marlin_mainCPP-6364">    delta_tower2_x =  SIN_60 * (radius + DELTA_RADIUS_TRIM_TOWER_2);  // front right tower</front>
<front id="Marlin_mainCPP-6365">    delta_tower2_y = -COS_60 * (radius + DELTA_RADIUS_TRIM_TOWER_2);</front>
<front id="Marlin_mainCPP-6366">    delta_tower3_x = 0.0;                                             // back middle tower</front>
<front id="Marlin_mainCPP-6367">    delta_tower3_y = (radius + DELTA_RADIUS_TRIM_TOWER_3);</front>
<front id="Marlin_mainCPP-6368">    delta_diagonal_rod_2_tower_1 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_1);</front>
<front id="Marlin_mainCPP-6369">    delta_diagonal_rod_2_tower_2 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_2);</front>
<front id="Marlin_mainCPP-6370">    delta_diagonal_rod_2_tower_3 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_3);</front>
<front id="Marlin_mainCPP-6371">  }</front>
<front id="Marlin_mainCPP-6372"></front>
<front id="Marlin_mainCPP-6373">  void calculate_delta(float cartesian[3]) {</front>
<front id="Marlin_mainCPP-6374"></front>
<front id="Marlin_mainCPP-6375">    delta[TOWER_1] = sqrt(delta_diagonal_rod_2_tower_1</front>
<front id="Marlin_mainCPP-6376">                         - sq(delta_tower1_x-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-6377">                         - sq(delta_tower1_y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-6378">                         ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6379">    delta[TOWER_2] = sqrt(delta_diagonal_rod_2_tower_2</front>
<front id="Marlin_mainCPP-6380">                         - sq(delta_tower2_x-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-6381">                         - sq(delta_tower2_y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-6382">                         ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6383">    delta[TOWER_3] = sqrt(delta_diagonal_rod_2_tower_3</front>
<front id="Marlin_mainCPP-6384">                         - sq(delta_tower3_x-cartesian[X_AXIS])</front>
<front id="Marlin_mainCPP-6385">                         - sq(delta_tower3_y-cartesian[Y_AXIS])</front>
<front id="Marlin_mainCPP-6386">                         ) + cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6387">    /*</front>
<front id="Marlin_mainCPP-6388">    SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);</front>
<front id="Marlin_mainCPP-6389">    SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6390">    SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6391"></front>
<front id="Marlin_mainCPP-6392">    SERIAL_ECHOPGM("delta a="); SERIAL_ECHO(delta[TOWER_1]);</front>
<front id="Marlin_mainCPP-6393">    SERIAL_ECHOPGM(" b="); SERIAL_ECHO(delta[TOWER_2]);</front>
<front id="Marlin_mainCPP-6394">    SERIAL_ECHOPGM(" c="); SERIAL_ECHOLN(delta[TOWER_3]);</front>
<front id="Marlin_mainCPP-6395">    */</front>
<front id="Marlin_mainCPP-6396">  }</front>
<front id="Marlin_mainCPP-6397"></front>
<front id="Marlin_mainCPP-6398">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6399"></front>
<front id="Marlin_mainCPP-6400">    // Adjust print surface height by linear interpolation over the bed_level array.</front>
<front id="Marlin_mainCPP-6401">    void adjust_delta(float cartesian[3]) {</front>
<front id="Marlin_mainCPP-6402">      if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!</front>
<front id="Marlin_mainCPP-6403"></front>
<front id="Marlin_mainCPP-6404">      int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;</front>
<front id="Marlin_mainCPP-6405">      float h1 = 0.001 - half, h2 = half - 0.001,</front>
<front id="Marlin_mainCPP-6406">            grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),</front>
<front id="Marlin_mainCPP-6407">            grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));</front>
<front id="Marlin_mainCPP-6408">      int floor_x = floor(grid_x), floor_y = floor(grid_y);</front>
<front id="Marlin_mainCPP-6409">      float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,</front>
<front id="Marlin_mainCPP-6410">            z1 = bed_level[floor_x + half][floor_y + half],</front>
<front id="Marlin_mainCPP-6411">            z2 = bed_level[floor_x + half][floor_y + half + 1],</front>
<front id="Marlin_mainCPP-6412">            z3 = bed_level[floor_x + half + 1][floor_y + half],</front>
<front id="Marlin_mainCPP-6413">            z4 = bed_level[floor_x + half + 1][floor_y + half + 1],</front>
<front id="Marlin_mainCPP-6414">            left = (1 - ratio_y) * z1 + ratio_y * z2,</front>
<front id="Marlin_mainCPP-6415">            right = (1 - ratio_y) * z3 + ratio_y * z4,</front>
<front id="Marlin_mainCPP-6416">            offset = (1 - ratio_x) * left + ratio_x * right;</front>
<front id="Marlin_mainCPP-6417"></front>
<front id="Marlin_mainCPP-6418">      delta[X_AXIS] += offset;</front>
<front id="Marlin_mainCPP-6419">      delta[Y_AXIS] += offset;</front>
<front id="Marlin_mainCPP-6420">      delta[Z_AXIS] += offset;</front>
<front id="Marlin_mainCPP-6421"></front>
<front id="Marlin_mainCPP-6422">      /*</front>
<front id="Marlin_mainCPP-6423">      SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);</front>
<front id="Marlin_mainCPP-6424">      SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);</front>
<front id="Marlin_mainCPP-6425">      SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);</front>
<front id="Marlin_mainCPP-6426">      SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);</front>
<front id="Marlin_mainCPP-6427">      SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);</front>
<front id="Marlin_mainCPP-6428">      SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);</front>
<front id="Marlin_mainCPP-6429">      SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);</front>
<front id="Marlin_mainCPP-6430">      SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);</front>
<front id="Marlin_mainCPP-6431">      SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);</front>
<front id="Marlin_mainCPP-6432">      SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);</front>
<front id="Marlin_mainCPP-6433">      SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);</front>
<front id="Marlin_mainCPP-6434">      SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);</front>
<front id="Marlin_mainCPP-6435">      SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);</front>
<front id="Marlin_mainCPP-6436">      */</front>
<front id="Marlin_mainCPP-6437">    }</front>
<front id="Marlin_mainCPP-6438">  #endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="Marlin_mainCPP-6439"></front>
<front id="Marlin_mainCPP-6440">#endif // DELTA</front>
<front id="Marlin_mainCPP-6441"></front>
<front id="Marlin_mainCPP-6442">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-6443"></front>
<front id="Marlin_mainCPP-6444">// This function is used to split lines on mesh borders so each segment is only part of one mesh area</front>
<front id="Marlin_mainCPP-6445">void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_rate, const uint8_t &extruder, uint8_t x_splits=0xff, uint8_t y_splits=0xff)</front>
<front id="Marlin_mainCPP-6446">{</front>
<front id="Marlin_mainCPP-6447">  if (!mbl.active) {</front>
<front id="Marlin_mainCPP-6448">    plan_buffer_line(x, y, z, e, feed_rate, extruder);</front>
<front id="Marlin_mainCPP-6449">    set_current_to_destination();</front>
<front id="Marlin_mainCPP-6450">    return;</front>
<front id="Marlin_mainCPP-6451">  }</front>
<front id="Marlin_mainCPP-6452">  int pix = mbl.select_x_index(current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-6453">  int piy = mbl.select_y_index(current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6454">  int ix = mbl.select_x_index(x);</front>
<front id="Marlin_mainCPP-6455">  int iy = mbl.select_y_index(y);</front>
<front id="Marlin_mainCPP-6456">  pix = min(pix, MESH_NUM_X_POINTS - 2);</front>
<front id="Marlin_mainCPP-6457">  piy = min(piy, MESH_NUM_Y_POINTS - 2);</front>
<front id="Marlin_mainCPP-6458">  ix = min(ix, MESH_NUM_X_POINTS - 2);</front>
<front id="Marlin_mainCPP-6459">  iy = min(iy, MESH_NUM_Y_POINTS - 2);</front>
<front id="Marlin_mainCPP-6460">  if (pix == ix && piy == iy) {</front>
<front id="Marlin_mainCPP-6461">    // Start and end on same mesh square</front>
<front id="Marlin_mainCPP-6462">    plan_buffer_line(x, y, z, e, feed_rate, extruder);</front>
<front id="Marlin_mainCPP-6463">    set_current_to_destination();</front>
<front id="Marlin_mainCPP-6464">    return;</front>
<front id="Marlin_mainCPP-6465">  }</front>
<front id="Marlin_mainCPP-6466">  float nx, ny, ne, normalized_dist;</front>
<front id="Marlin_mainCPP-6467">  if (ix &gt; pix && (x_splits) & BIT(ix)) {</front>
<front id="Marlin_mainCPP-6468">    nx = mbl.get_x(ix);</front>
<front id="Marlin_mainCPP-6469">    normalized_dist = (nx - current_position[X_AXIS])/(x - current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-6470">    ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6471">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6472">    x_splits ^= BIT(ix);</front>
<front id="Marlin_mainCPP-6473">  } else if (ix &lt; pix && (x_splits) & BIT(pix)) {</front>
<front id="Marlin_mainCPP-6474">    nx = mbl.get_x(pix);</front>
<front id="Marlin_mainCPP-6475">    normalized_dist = (nx - current_position[X_AXIS])/(x - current_position[X_AXIS]);</front>
<front id="Marlin_mainCPP-6476">    ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6477">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6478">    x_splits ^= BIT(pix);</front>
<front id="Marlin_mainCPP-6479">  } else if (iy &gt; piy && (y_splits) & BIT(iy)) {</front>
<front id="Marlin_mainCPP-6480">    ny = mbl.get_y(iy);</front>
<front id="Marlin_mainCPP-6481">    normalized_dist = (ny - current_position[Y_AXIS])/(y - current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6482">    nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6483">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6484">    y_splits ^= BIT(iy);</front>
<front id="Marlin_mainCPP-6485">  } else if (iy &lt; piy && (y_splits) & BIT(piy)) {</front>
<front id="Marlin_mainCPP-6486">    ny = mbl.get_y(piy);</front>
<front id="Marlin_mainCPP-6487">    normalized_dist = (ny - current_position[Y_AXIS])/(y - current_position[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6488">    nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6489">    ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;</front>
<front id="Marlin_mainCPP-6490">    y_splits ^= BIT(piy);</front>
<front id="Marlin_mainCPP-6491">  } else {</front>
<front id="Marlin_mainCPP-6492">    // Already split on a border</front>
<front id="Marlin_mainCPP-6493">    plan_buffer_line(x, y, z, e, feed_rate, extruder);</front>
<front id="Marlin_mainCPP-6494">    set_current_to_destination();</front>
<front id="Marlin_mainCPP-6495">    return;</front>
<front id="Marlin_mainCPP-6496">  }</front>
<front id="Marlin_mainCPP-6497">  // Do the split and look for more borders</front>
<front id="Marlin_mainCPP-6498">  destination[X_AXIS] = nx;</front>
<front id="Marlin_mainCPP-6499">  destination[Y_AXIS] = ny;</front>
<front id="Marlin_mainCPP-6500">  destination[E_AXIS] = ne;</front>
<front id="Marlin_mainCPP-6501">  mesh_plan_buffer_line(nx, ny, z, ne, feed_rate, extruder, x_splits, y_splits);</front>
<front id="Marlin_mainCPP-6502">  destination[X_AXIS] = x;</front>
<front id="Marlin_mainCPP-6503">  destination[Y_AXIS] = y;</front>
<front id="Marlin_mainCPP-6504">  destination[E_AXIS] = e;</front>
<front id="Marlin_mainCPP-6505">  mesh_plan_buffer_line(x, y, z, e, feed_rate, extruder, x_splits, y_splits);</front>
<front id="Marlin_mainCPP-6506">}</front>
<front id="Marlin_mainCPP-6507">#endif  // MESH_BED_LEVELING</front>
<front id="Marlin_mainCPP-6508"></front>
<front id="Marlin_mainCPP-6509">#if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-6510"></front>
<front id="Marlin_mainCPP-6511">  inline void prevent_dangerous_extrude(float &curr_e, float &dest_e) {</front>
<front id="Marlin_mainCPP-6512">    if (marlin_debug_flags & DEBUG_DRYRUN) return;</front>
<front id="Marlin_mainCPP-6513">    float de = dest_e - curr_e;</front>
<front id="Marlin_mainCPP-6514">    if (de) {</front>
<front id="Marlin_mainCPP-6515">      if (degHotend(active_extruder) &lt; extrude_min_temp) {</front>
<front id="Marlin_mainCPP-6516">        curr_e = dest_e; // Behave as if the move really took place, but ignore E part</front>
<front id="Marlin_mainCPP-6517">        SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-6518">        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);</front>
<front id="Marlin_mainCPP-6519">      }</front>
<front id="Marlin_mainCPP-6520">      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)</front>
<front id="Marlin_mainCPP-6521">        if (labs(de) &gt; EXTRUDE_MAXLENGTH) {</front>
<front id="Marlin_mainCPP-6522">          curr_e = dest_e; // Behave as if the move really took place, but ignore E part</front>
<front id="Marlin_mainCPP-6523">          SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-6524">          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);</front>
<front id="Marlin_mainCPP-6525">        }</front>
<front id="Marlin_mainCPP-6526">      #endif</front>
<front id="Marlin_mainCPP-6527">    }</front>
<front id="Marlin_mainCPP-6528">  }</front>
<front id="Marlin_mainCPP-6529"></front>
<front id="Marlin_mainCPP-6530">#endif // PREVENT_DANGEROUS_EXTRUDE</front>
<front id="Marlin_mainCPP-6531"></front>
<front id="Marlin_mainCPP-6532">#if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6533"></front>
<front id="Marlin_mainCPP-6534">  inline bool prepare_move_delta(float target[NUM_AXIS]) {</front>
<front id="Marlin_mainCPP-6535">    float difference[NUM_AXIS];</front>
<front id="Marlin_mainCPP-6536">    for (int8_t i=0; i &lt; NUM_AXIS; i++) difference[i] = target[i] - current_position[i];</front>
<front id="Marlin_mainCPP-6537"></front>
<front id="Marlin_mainCPP-6538">    float cartesian_mm = sqrt(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));</front>
<front id="Marlin_mainCPP-6539">    if (cartesian_mm &lt; 0.000001) cartesian_mm = abs(difference[E_AXIS]);</front>
<front id="Marlin_mainCPP-6540">    if (cartesian_mm &lt; 0.000001) return false;</front>
<front id="Marlin_mainCPP-6541">    float seconds = 6000 * cartesian_mm / feedrate / feedrate_multiplier;</front>
<front id="Marlin_mainCPP-6542">    int steps = max(1, int(delta_segments_per_second * seconds));</front>
<front id="Marlin_mainCPP-6543"></front>
<front id="Marlin_mainCPP-6544">    // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);</front>
<front id="Marlin_mainCPP-6545">    // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);</front>
<front id="Marlin_mainCPP-6546">    // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);</front>
<front id="Marlin_mainCPP-6547"></front>
<front id="Marlin_mainCPP-6548">    for (int s = 1; s &lt;= steps; s++) {</front>
<front id="Marlin_mainCPP-6549"></front>
<front id="Marlin_mainCPP-6550">      float fraction = float(s) / float(steps);</front>
<front id="Marlin_mainCPP-6551"></front>
<front id="Marlin_mainCPP-6552">      for (int8_t i = 0; i &lt; NUM_AXIS; i++)</front>
<front id="Marlin_mainCPP-6553">        target[i] = current_position[i] + difference[i] * fraction;</front>
<front id="Marlin_mainCPP-6554"></front>
<front id="Marlin_mainCPP-6555">      calculate_delta(target);</front>
<front id="Marlin_mainCPP-6556"></front>
<front id="Marlin_mainCPP-6557">      #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6558">        adjust_delta(target);</front>
<front id="Marlin_mainCPP-6559">      #endif</front>
<front id="Marlin_mainCPP-6560"></front>
<front id="Marlin_mainCPP-6561">      //SERIAL_ECHOPGM("target[X_AXIS]="); SERIAL_ECHOLN(target[X_AXIS]);</front>
<front id="Marlin_mainCPP-6562">      //SERIAL_ECHOPGM("target[Y_AXIS]="); SERIAL_ECHOLN(target[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6563">      //SERIAL_ECHOPGM("target[Z_AXIS]="); SERIAL_ECHOLN(target[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6564">      //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-6565">      //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6566">      //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6567"></front>
<front id="Marlin_mainCPP-6568">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feedrate/60*feedrate_multiplier/100.0, active_extruder);</front>
<front id="Marlin_mainCPP-6569">    }</front>
<front id="Marlin_mainCPP-6570">    return true;</front>
<front id="Marlin_mainCPP-6571">  }</front>
<front id="Marlin_mainCPP-6572"></front>
<front id="Marlin_mainCPP-6573">#endif // DELTA || SCARA</front>
<front id="Marlin_mainCPP-6574"></front>
<front id="Marlin_mainCPP-6575">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6576">  inline bool prepare_move_scara(float target[NUM_AXIS]) { return prepare_move_delta(target); }</front>
<front id="Marlin_mainCPP-6577">#endif</front>
<front id="Marlin_mainCPP-6578"></front>
<front id="Marlin_mainCPP-6579">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-6580"></front>
<front id="Marlin_mainCPP-6581">  inline bool prepare_move_dual_x_carriage() {</front>
<front id="Marlin_mainCPP-6582">    if (active_extruder_parked) {</front>
<front id="Marlin_mainCPP-6583">      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {</front>
<front id="Marlin_mainCPP-6584">        // move duplicate extruder into correct duplication position.</front>
<front id="Marlin_mainCPP-6585">        plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="Marlin_mainCPP-6586">        plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,</front>
<front id="Marlin_mainCPP-6587">          current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[X_AXIS], 1);</front>
<front id="Marlin_mainCPP-6588">        sync_plan_position();</front>
<front id="Marlin_mainCPP-6589">        st_synchronize();</front>
<front id="Marlin_mainCPP-6590">        extruder_duplication_enabled = true;</front>
<front id="Marlin_mainCPP-6591">        active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-6592">      }</front>
<front id="Marlin_mainCPP-6593">      else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) { // handle unparking of head</front>
<front id="Marlin_mainCPP-6594">        if (current_position[E_AXIS] == destination[E_AXIS]) {</front>
<front id="Marlin_mainCPP-6595">          // This is a travel move (with no extrusion)</front>
<front id="Marlin_mainCPP-6596">          // Skip it, but keep track of the current position</front>
<front id="Marlin_mainCPP-6597">          // (so it can be used as the start of the next non-travel move)</front>
<front id="Marlin_mainCPP-6598">          if (delayed_move_time != 0xFFFFFFFFUL) {</front>
<front id="Marlin_mainCPP-6599">            set_current_to_destination();</front>
<front id="Marlin_mainCPP-6600">            NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6601">            delayed_move_time = millis();</front>
<front id="Marlin_mainCPP-6602">            return false;</front>
<front id="Marlin_mainCPP-6603">          }</front>
<front id="Marlin_mainCPP-6604">        }</front>
<front id="Marlin_mainCPP-6605">        delayed_move_time = 0;</front>
<front id="Marlin_mainCPP-6606">        // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower</front>
<front id="Marlin_mainCPP-6607">        plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-6608">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], min(max_feedrate[X_AXIS], max_feedrate[Y_AXIS]), active_extruder);</front>
<front id="Marlin_mainCPP-6609">        plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-6610">        active_extruder_parked = false;</front>
<front id="Marlin_mainCPP-6611">      }</front>
<front id="Marlin_mainCPP-6612">    }</front>
<front id="Marlin_mainCPP-6613">    return true;</front>
<front id="Marlin_mainCPP-6614">  }</front>
<front id="Marlin_mainCPP-6615"></front>
<front id="Marlin_mainCPP-6616">#endif // DUAL_X_CARRIAGE</front>
<front id="Marlin_mainCPP-6617"></front>
<front id="Marlin_mainCPP-6618">#if DISABLED(DELTA) && DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-6619"></front>
<front id="Marlin_mainCPP-6620">  inline bool prepare_move_cartesian() {</front>
<front id="Marlin_mainCPP-6621">    // Do not use feedrate_multiplier for E or Z only moves</front>
<front id="Marlin_mainCPP-6622">    if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) {</front>
<front id="Marlin_mainCPP-6623">      line_to_destination();</front>
<front id="Marlin_mainCPP-6624">    }</front>
<front id="Marlin_mainCPP-6625">    else {</front>
<front id="Marlin_mainCPP-6626">      #if ENABLED(MESH_BED_LEVELING)</front>
<front id="Marlin_mainCPP-6627">        mesh_plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], (feedrate/60)*(feedrate_multiplier/100.0), active_extruder);</front>
<front id="Marlin_mainCPP-6628">        return false;</front>
<front id="Marlin_mainCPP-6629">      #else</front>
<front id="Marlin_mainCPP-6630">        line_to_destination(feedrate * feedrate_multiplier / 100.0);</front>
<front id="Marlin_mainCPP-6631">      #endif</front>
<front id="Marlin_mainCPP-6632">    }</front>
<front id="Marlin_mainCPP-6633">    return true;</front>
<front id="Marlin_mainCPP-6634">  }</front>
<front id="Marlin_mainCPP-6635"></front>
<front id="Marlin_mainCPP-6636">#endif // !DELTA && !SCARA</front>
<front id="Marlin_mainCPP-6637"></front>
<front id="Marlin_mainCPP-6638">/**</front>
<front id="Marlin_mainCPP-6639"> * Prepare a single move and get ready for the next one</front>
<front id="Marlin_mainCPP-6640"> *</front>
<front id="Marlin_mainCPP-6641"> * (This may call plan_buffer_line several times to put</front>
<front id="Marlin_mainCPP-6642"> *  smaller moves into the planner for DELTA or SCARA.)</front>
<front id="Marlin_mainCPP-6643"> */</front>
<front id="Marlin_mainCPP-6644">void prepare_move() {</front>
<front id="Marlin_mainCPP-6645">  clamp_to_software_endstops(destination);</front>
<front id="Marlin_mainCPP-6646">  refresh_cmd_timeout();</front>
<front id="Marlin_mainCPP-6647"></front>
<front id="Marlin_mainCPP-6648">  #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="Marlin_mainCPP-6649">    prevent_dangerous_extrude(current_position[E_AXIS], destination[E_AXIS]);</front>
<front id="Marlin_mainCPP-6650">  #endif</front>
<front id="Marlin_mainCPP-6651"></front>
<front id="Marlin_mainCPP-6652">  #if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6653">    if (!prepare_move_scara(destination)) return;</front>
<front id="Marlin_mainCPP-6654">  #elif ENABLED(DELTA)</front>
<front id="Marlin_mainCPP-6655">    if (!prepare_move_delta(destination)) return;</front>
<front id="Marlin_mainCPP-6656">  #endif</front>
<front id="Marlin_mainCPP-6657"></front>
<front id="Marlin_mainCPP-6658">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-6659">    if (!prepare_move_dual_x_carriage()) return;</front>
<front id="Marlin_mainCPP-6660">  #endif</front>
<front id="Marlin_mainCPP-6661"></front>
<front id="Marlin_mainCPP-6662">  #if DISABLED(DELTA) && DISABLED(SCARA)</front>
<front id="Marlin_mainCPP-6663">    if (!prepare_move_cartesian()) return;</front>
<front id="Marlin_mainCPP-6664">  #endif</front>
<front id="Marlin_mainCPP-6665"></front>
<front id="Marlin_mainCPP-6666">  set_current_to_destination();</front>
<front id="Marlin_mainCPP-6667">}</front>
<front id="Marlin_mainCPP-6668"></front>
<front id="Marlin_mainCPP-6669">/**</front>
<front id="Marlin_mainCPP-6670"> * Plan an arc in 2 dimensions</front>
<front id="Marlin_mainCPP-6671"> *</front>
<front id="Marlin_mainCPP-6672"> * The arc is approximated by generating many small linear segments.</front>
<front id="Marlin_mainCPP-6673"> * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)</front>
<front id="Marlin_mainCPP-6674"> * Arcs should only be made relatively large (over 5mm), as larger arcs with</front>
<front id="Marlin_mainCPP-6675"> * larger segments will tend to be more efficient. Your slicer should have</front>
<front id="Marlin_mainCPP-6676"> * options for G2/G3 arc generation. In future these options may be GCode tunable.</front>
<front id="Marlin_mainCPP-6677"> */</front>
<front id="Marlin_mainCPP-6678">void plan_arc(</front>
<front id="Marlin_mainCPP-6679">  float target[NUM_AXIS], // Destination position</front>
<front id="Marlin_mainCPP-6680">  float *offset,          // Center of rotation relative to current_position</front>
<front id="Marlin_mainCPP-6681">  uint8_t clockwise       // Clockwise?</front>
<front id="Marlin_mainCPP-6682">) {</front>
<front id="Marlin_mainCPP-6683"></front>
<front id="Marlin_mainCPP-6684">  float radius = hypot(offset[X_AXIS], offset[Y_AXIS]),</front>
<front id="Marlin_mainCPP-6685">        center_axis0 = current_position[X_AXIS] + offset[X_AXIS],</front>
<front id="Marlin_mainCPP-6686">        center_axis1 = current_position[Y_AXIS] + offset[Y_AXIS],</front>
<front id="Marlin_mainCPP-6687">        linear_travel = target[Z_AXIS] - current_position[Z_AXIS],</front>
<front id="Marlin_mainCPP-6688">        extruder_travel = target[E_AXIS] - current_position[E_AXIS],</front>
<front id="Marlin_mainCPP-6689">        r_axis0 = -offset[X_AXIS],  // Radius vector from center to current location</front>
<front id="Marlin_mainCPP-6690">        r_axis1 = -offset[Y_AXIS],</front>
<front id="Marlin_mainCPP-6691">        rt_axis0 = target[X_AXIS] - center_axis0,</front>
<front id="Marlin_mainCPP-6692">        rt_axis1 = target[Y_AXIS] - center_axis1;</front>
<front id="Marlin_mainCPP-6693"></front>
<front id="Marlin_mainCPP-6694">  // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.</front>
<front id="Marlin_mainCPP-6695">  float angular_travel = atan2(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis1);</front>
<front id="Marlin_mainCPP-6696">  if (angular_travel &lt; 0) { angular_travel += RADIANS(360); }</front>
<front id="Marlin_mainCPP-6697">  if (clockwise) { angular_travel -= RADIANS(360); }</front>
<front id="Marlin_mainCPP-6698"></front>
<front id="Marlin_mainCPP-6699">  // Make a circle if the angular rotation is 0</front>
<front id="Marlin_mainCPP-6700">  if (current_position[X_AXIS] == target[X_AXIS] && current_position[Y_AXIS] == target[Y_AXIS] && angular_travel == 0)</front>
<front id="Marlin_mainCPP-6701">    angular_travel += RADIANS(360);</front>
<front id="Marlin_mainCPP-6702"></front>
<front id="Marlin_mainCPP-6703">  float mm_of_travel = hypot(angular_travel*radius, fabs(linear_travel));</front>
<front id="Marlin_mainCPP-6704">  if (mm_of_travel &lt; 0.001) { return; }</front>
<front id="Marlin_mainCPP-6705">  uint16_t segments = floor(mm_of_travel / MM_PER_ARC_SEGMENT);</front>
<front id="Marlin_mainCPP-6706">  if (segments == 0) segments = 1;</front>
<front id="Marlin_mainCPP-6707"></front>
<front id="Marlin_mainCPP-6708">  float theta_per_segment = angular_travel/segments;</front>
<front id="Marlin_mainCPP-6709">  float linear_per_segment = linear_travel/segments;</front>
<front id="Marlin_mainCPP-6710">  float extruder_per_segment = extruder_travel/segments;</front>
<front id="Marlin_mainCPP-6711"></front>
<front id="Marlin_mainCPP-6712">  /* Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,</front>
<front id="Marlin_mainCPP-6713">     and phi is the angle of rotation. Based on the solution approach by Jens Geisler.</front>
<front id="Marlin_mainCPP-6714">         r_T = [cos(phi) -sin(phi);</front>
<front id="Marlin_mainCPP-6715">                sin(phi)  cos(phi] * r ;</front>
<front id="Marlin_mainCPP-6716"></front>
<front id="Marlin_mainCPP-6717">     For arc generation, the center of the circle is the axis of rotation and the radius vector is</front>
<front id="Marlin_mainCPP-6718">     defined from the circle center to the initial position. Each line segment is formed by successive</front>
<front id="Marlin_mainCPP-6719">     vector rotations. This requires only two cos() and sin() computations to form the rotation</front>
<front id="Marlin_mainCPP-6720">     matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since</front>
<front id="Marlin_mainCPP-6721">     all double numbers are single precision on the Arduino. (True double precision will not have</front>
<front id="Marlin_mainCPP-6722">     round off issues for CNC applications.) Single precision error can accumulate to be greater than</front>
<front id="Marlin_mainCPP-6723">     tool precision in some cases. Therefore, arc path correction is implemented.</front>
<front id="Marlin_mainCPP-6724"></front>
<front id="Marlin_mainCPP-6725">     Small angle approximation may be used to reduce computation overhead further. This approximation</front>
<front id="Marlin_mainCPP-6726">     holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,</front>
<front id="Marlin_mainCPP-6727">     theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large</front>
<front id="Marlin_mainCPP-6728">     to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for</front>
<front id="Marlin_mainCPP-6729">     numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an</front>
<front id="Marlin_mainCPP-6730">     issue for CNC machines with the single precision Arduino calculations.</front>
<front id="Marlin_mainCPP-6731"></front>
<front id="Marlin_mainCPP-6732">     This approximation also allows plan_arc to immediately insert a line segment into the planner</front>
<front id="Marlin_mainCPP-6733">     without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied</front>
<front id="Marlin_mainCPP-6734">     a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.</front>
<front id="Marlin_mainCPP-6735">     This is important when there are successive arc motions.</front>
<front id="Marlin_mainCPP-6736">  */</front>
<front id="Marlin_mainCPP-6737">  // Vector rotation matrix values</front>
<front id="Marlin_mainCPP-6738">  float cos_T = 1-0.5*theta_per_segment*theta_per_segment; // Small angle approximation</front>
<front id="Marlin_mainCPP-6739">  float sin_T = theta_per_segment;</front>
<front id="Marlin_mainCPP-6740"></front>
<front id="Marlin_mainCPP-6741">  float arc_target[NUM_AXIS];</front>
<front id="Marlin_mainCPP-6742">  float sin_Ti;</front>
<front id="Marlin_mainCPP-6743">  float cos_Ti;</front>
<front id="Marlin_mainCPP-6744">  float r_axisi;</front>
<front id="Marlin_mainCPP-6745">  uint16_t i;</front>
<front id="Marlin_mainCPP-6746">  int8_t count = 0;</front>
<front id="Marlin_mainCPP-6747"></front>
<front id="Marlin_mainCPP-6748">  // Initialize the linear axis</front>
<front id="Marlin_mainCPP-6749">  arc_target[Z_AXIS] = current_position[Z_AXIS];</front>
<front id="Marlin_mainCPP-6750"></front>
<front id="Marlin_mainCPP-6751">  // Initialize the extruder axis</front>
<front id="Marlin_mainCPP-6752">  arc_target[E_AXIS] = current_position[E_AXIS];</front>
<front id="Marlin_mainCPP-6753"></front>
<front id="Marlin_mainCPP-6754">  float feed_rate = feedrate*feedrate_multiplier/60/100.0;</front>
<front id="Marlin_mainCPP-6755"></front>
<front id="Marlin_mainCPP-6756">  for (i = 1; i &lt; segments; i++) { // Increment (segments-1)</front>
<front id="Marlin_mainCPP-6757"></front>
<front id="Marlin_mainCPP-6758">    if (count &lt; N_ARC_CORRECTION) {</front>
<front id="Marlin_mainCPP-6759">      // Apply vector rotation matrix to previous r_axis0 / 1</front>
<front id="Marlin_mainCPP-6760">      r_axisi = r_axis0*sin_T + r_axis1*cos_T;</front>
<front id="Marlin_mainCPP-6761">      r_axis0 = r_axis0*cos_T - r_axis1*sin_T;</front>
<front id="Marlin_mainCPP-6762">      r_axis1 = r_axisi;</front>
<front id="Marlin_mainCPP-6763">      count++;</front>
<front id="Marlin_mainCPP-6764">    }</front>
<front id="Marlin_mainCPP-6765">    else {</front>
<front id="Marlin_mainCPP-6766">      // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.</front>
<front id="Marlin_mainCPP-6767">      // Compute exact location by applying transformation matrix from initial radius vector(=-offset).</front>
<front id="Marlin_mainCPP-6768">      cos_Ti = cos(i*theta_per_segment);</front>
<front id="Marlin_mainCPP-6769">      sin_Ti = sin(i*theta_per_segment);</front>
<front id="Marlin_mainCPP-6770">      r_axis0 = -offset[X_AXIS]*cos_Ti + offset[Y_AXIS]*sin_Ti;</front>
<front id="Marlin_mainCPP-6771">      r_axis1 = -offset[X_AXIS]*sin_Ti - offset[Y_AXIS]*cos_Ti;</front>
<front id="Marlin_mainCPP-6772">      count = 0;</front>
<front id="Marlin_mainCPP-6773">    }</front>
<front id="Marlin_mainCPP-6774"></front>
<front id="Marlin_mainCPP-6775">    // Update arc_target location</front>
<front id="Marlin_mainCPP-6776">    arc_target[X_AXIS] = center_axis0 + r_axis0;</front>
<front id="Marlin_mainCPP-6777">    arc_target[Y_AXIS] = center_axis1 + r_axis1;</front>
<front id="Marlin_mainCPP-6778">    arc_target[Z_AXIS] += linear_per_segment;</front>
<front id="Marlin_mainCPP-6779">    arc_target[E_AXIS] += extruder_per_segment;</front>
<front id="Marlin_mainCPP-6780"></front>
<front id="Marlin_mainCPP-6781">    clamp_to_software_endstops(arc_target);</front>
<front id="Marlin_mainCPP-6782"></front>
<front id="Marlin_mainCPP-6783">    #if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6784">      calculate_delta(arc_target);</front>
<front id="Marlin_mainCPP-6785">      #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6786">        adjust_delta(arc_target);</front>
<front id="Marlin_mainCPP-6787">      #endif</front>
<front id="Marlin_mainCPP-6788">      plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], arc_target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6789">    #else</front>
<front id="Marlin_mainCPP-6790">      plan_buffer_line(arc_target[X_AXIS], arc_target[Y_AXIS], arc_target[Z_AXIS], arc_target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6791">    #endif</front>
<front id="Marlin_mainCPP-6792">  }</front>
<front id="Marlin_mainCPP-6793"></front>
<front id="Marlin_mainCPP-6794">  // Ensure last segment arrives at target location.</front>
<front id="Marlin_mainCPP-6795">  #if ENABLED(DELTA) || ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6796">    calculate_delta(target);</front>
<front id="Marlin_mainCPP-6797">    #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="Marlin_mainCPP-6798">      adjust_delta(target);</front>
<front id="Marlin_mainCPP-6799">    #endif</front>
<front id="Marlin_mainCPP-6800">    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6801">  #else</front>
<front id="Marlin_mainCPP-6802">    plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feed_rate, active_extruder);</front>
<front id="Marlin_mainCPP-6803">  #endif</front>
<front id="Marlin_mainCPP-6804"></front>
<front id="Marlin_mainCPP-6805">  // As far as the parser is concerned, the position is now == target. In reality the</front>
<front id="Marlin_mainCPP-6806">  // motion control system might still be processing the action and the real tool position</front>
<front id="Marlin_mainCPP-6807">  // in any intermediate location.</front>
<front id="Marlin_mainCPP-6808">  set_current_to_destination();</front>
<front id="Marlin_mainCPP-6809">}</front>
<front id="Marlin_mainCPP-6810"></front>
<front id="Marlin_mainCPP-6811">#if HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-6812"></front>
<front id="Marlin_mainCPP-6813">  void controllerFan() {</front>
<front id="Marlin_mainCPP-6814">    static millis_t lastMotor = 0;      // Last time a motor was turned on</front>
<front id="Marlin_mainCPP-6815">    static millis_t lastMotorCheck = 0; // Last time the state was checked</front>
<front id="Marlin_mainCPP-6816">    millis_t ms = millis();</front>
<front id="Marlin_mainCPP-6817">    if (ms &gt;= lastMotorCheck + 2500) { // Not a time critical function, so we only check every 2500ms</front>
<front id="Marlin_mainCPP-6818">      lastMotorCheck = ms;</front>
<front id="Marlin_mainCPP-6819">      if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || soft_pwm_bed &gt; 0</front>
<front id="Marlin_mainCPP-6820">        || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...</front>
<front id="Marlin_mainCPP-6821">        #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-6822">          || E1_ENABLE_READ == E_ENABLE_ON</front>
<front id="Marlin_mainCPP-6823">          #if HAS_X2_ENABLE</front>
<front id="Marlin_mainCPP-6824">            || X2_ENABLE_READ == X_ENABLE_ON</front>
<front id="Marlin_mainCPP-6825">          #endif</front>
<front id="Marlin_mainCPP-6826">          #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-6827">            || E2_ENABLE_READ == E_ENABLE_ON</front>
<front id="Marlin_mainCPP-6828">            #if EXTRUDERS &gt; 3</front>
<front id="Marlin_mainCPP-6829">              || E3_ENABLE_READ == E_ENABLE_ON</front>
<front id="Marlin_mainCPP-6830">            #endif</front>
<front id="Marlin_mainCPP-6831">          #endif</front>
<front id="Marlin_mainCPP-6832">        #endif</front>
<front id="Marlin_mainCPP-6833">      ) {</front>
<front id="Marlin_mainCPP-6834">        lastMotor = ms; //... set time to NOW so the fan will turn on</front>
<front id="Marlin_mainCPP-6835">      }</front>
<front id="Marlin_mainCPP-6836">      uint8_t speed = (lastMotor == 0 || ms &gt;= lastMotor + (CONTROLLERFAN_SECS * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;</front>
<front id="Marlin_mainCPP-6837">      // allows digital or PWM fan output to be used (see M42 handling)</front>
<front id="Marlin_mainCPP-6838">      digitalWrite(CONTROLLERFAN_PIN, speed);</front>
<front id="Marlin_mainCPP-6839">      analogWrite(CONTROLLERFAN_PIN, speed);</front>
<front id="Marlin_mainCPP-6840">    }</front>
<front id="Marlin_mainCPP-6841">  }</front>
<front id="Marlin_mainCPP-6842"></front>
<front id="Marlin_mainCPP-6843">#endif // HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-6844"></front>
<front id="Marlin_mainCPP-6845">#if ENABLED(SCARA)</front>
<front id="Marlin_mainCPP-6846"></front>
<front id="Marlin_mainCPP-6847">  void calculate_SCARA_forward_Transform(float f_scara[3]) {</front>
<front id="Marlin_mainCPP-6848">    // Perform forward kinematics, and place results in delta[3]</front>
<front id="Marlin_mainCPP-6849">    // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014</front>
<front id="Marlin_mainCPP-6850"></front>
<front id="Marlin_mainCPP-6851">    float x_sin, x_cos, y_sin, y_cos;</front>
<front id="Marlin_mainCPP-6852"></front>
<front id="Marlin_mainCPP-6853">    //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);</front>
<front id="Marlin_mainCPP-6854">    //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6855"></front>
<front id="Marlin_mainCPP-6856">    x_sin = sin(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;</front>
<front id="Marlin_mainCPP-6857">    x_cos = cos(f_scara[X_AXIS]/SCARA_RAD2DEG) * Linkage_1;</front>
<front id="Marlin_mainCPP-6858">    y_sin = sin(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;</front>
<front id="Marlin_mainCPP-6859">    y_cos = cos(f_scara[Y_AXIS]/SCARA_RAD2DEG) * Linkage_2;</front>
<front id="Marlin_mainCPP-6860"></front>
<front id="Marlin_mainCPP-6861">    //SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);</front>
<front id="Marlin_mainCPP-6862">    //SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);</front>
<front id="Marlin_mainCPP-6863">    //SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);</front>
<front id="Marlin_mainCPP-6864">    //SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);</front>
<front id="Marlin_mainCPP-6865"></front>
<front id="Marlin_mainCPP-6866">    delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta</front>
<front id="Marlin_mainCPP-6867">    delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi</front>
<front id="Marlin_mainCPP-6868"></front>
<front id="Marlin_mainCPP-6869">    //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-6870">    //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6871">  }</front>
<front id="Marlin_mainCPP-6872"></front>
<front id="Marlin_mainCPP-6873">  void calculate_delta(float cartesian[3]){</front>
<front id="Marlin_mainCPP-6874">    //reverse kinematics.</front>
<front id="Marlin_mainCPP-6875">    // Perform reversed kinematics, and place results in delta[3]</front>
<front id="Marlin_mainCPP-6876">    // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014</front>
<front id="Marlin_mainCPP-6877"></front>
<front id="Marlin_mainCPP-6878">    float SCARA_pos[2];</front>
<front id="Marlin_mainCPP-6879">    static float SCARA_C2, SCARA_S2, SCARA_K1, SCARA_K2, SCARA_theta, SCARA_psi;</front>
<front id="Marlin_mainCPP-6880"></front>
<front id="Marlin_mainCPP-6881">    SCARA_pos[X_AXIS] = cartesian[X_AXIS] * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y</front>
<front id="Marlin_mainCPP-6882">    SCARA_pos[Y_AXIS] = cartesian[Y_AXIS] * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.</front>
<front id="Marlin_mainCPP-6883"></front>
<front id="Marlin_mainCPP-6884">    #if (Linkage_1 == Linkage_2)</front>
<front id="Marlin_mainCPP-6885">      SCARA_C2 = ( ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) ) / (2 * (float)L1_2) ) - 1;</front>
<front id="Marlin_mainCPP-6886">    #else</front>
<front id="Marlin_mainCPP-6887">      SCARA_C2 =   ( sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) - (float)L1_2 - (float)L2_2 ) / 45000;</front>
<front id="Marlin_mainCPP-6888">    #endif</front>
<front id="Marlin_mainCPP-6889"></front>
<front id="Marlin_mainCPP-6890">    SCARA_S2 = sqrt( 1 - sq(SCARA_C2) );</front>
<front id="Marlin_mainCPP-6891"></front>
<front id="Marlin_mainCPP-6892">    SCARA_K1 = Linkage_1 + Linkage_2 * SCARA_C2;</front>
<front id="Marlin_mainCPP-6893">    SCARA_K2 = Linkage_2 * SCARA_S2;</front>
<front id="Marlin_mainCPP-6894"></front>
<front id="Marlin_mainCPP-6895">    SCARA_theta = ( atan2(SCARA_pos[X_AXIS],SCARA_pos[Y_AXIS])-atan2(SCARA_K1, SCARA_K2) ) * -1;</front>
<front id="Marlin_mainCPP-6896">    SCARA_psi   =   atan2(SCARA_S2,SCARA_C2);</front>
<front id="Marlin_mainCPP-6897"></front>
<front id="Marlin_mainCPP-6898">    delta[X_AXIS] = SCARA_theta * SCARA_RAD2DEG;  // Multiply by 180/Pi  -  theta is support arm angle</front>
<front id="Marlin_mainCPP-6899">    delta[Y_AXIS] = (SCARA_theta + SCARA_psi) * SCARA_RAD2DEG;  //       -  equal to sub arm angle (inverted motor)</front>
<front id="Marlin_mainCPP-6900">    delta[Z_AXIS] = cartesian[Z_AXIS];</front>
<front id="Marlin_mainCPP-6901"></front>
<front id="Marlin_mainCPP-6902">    /*</front>
<front id="Marlin_mainCPP-6903">    SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);</front>
<front id="Marlin_mainCPP-6904">    SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6905">    SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6906"></front>
<front id="Marlin_mainCPP-6907">    SERIAL_ECHOPGM("scara x="); SERIAL_ECHO(SCARA_pos[X_AXIS]);</front>
<front id="Marlin_mainCPP-6908">    SERIAL_ECHOPGM(" y="); SERIAL_ECHOLN(SCARA_pos[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6909"></front>
<front id="Marlin_mainCPP-6910">    SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);</front>
<front id="Marlin_mainCPP-6911">    SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);</front>
<front id="Marlin_mainCPP-6912">    SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);</front>
<front id="Marlin_mainCPP-6913"></front>
<front id="Marlin_mainCPP-6914">    SERIAL_ECHOPGM("C2="); SERIAL_ECHO(SCARA_C2);</front>
<front id="Marlin_mainCPP-6915">    SERIAL_ECHOPGM(" S2="); SERIAL_ECHO(SCARA_S2);</front>
<front id="Marlin_mainCPP-6916">    SERIAL_ECHOPGM(" Theta="); SERIAL_ECHO(SCARA_theta);</front>
<front id="Marlin_mainCPP-6917">    SERIAL_ECHOPGM(" Psi="); SERIAL_ECHOLN(SCARA_psi);</front>
<front id="Marlin_mainCPP-6918">    SERIAL_EOL;</front>
<front id="Marlin_mainCPP-6919">    */</front>
<front id="Marlin_mainCPP-6920">  }</front>
<front id="Marlin_mainCPP-6921"></front>
<front id="Marlin_mainCPP-6922">#endif // SCARA</front>
<front id="Marlin_mainCPP-6923"></front>
<front id="Marlin_mainCPP-6924">#if ENABLED(TEMP_STAT_LEDS)</front>
<front id="Marlin_mainCPP-6925"></front>
<front id="Marlin_mainCPP-6926">  static bool red_led = false;</front>
<front id="Marlin_mainCPP-6927">  static millis_t next_status_led_update_ms = 0;</front>
<front id="Marlin_mainCPP-6928"></front>
<front id="Marlin_mainCPP-6929">  void handle_status_leds(void) {</front>
<front id="Marlin_mainCPP-6930">    float max_temp = 0.0;</front>
<front id="Marlin_mainCPP-6931">    if (millis() &gt; next_status_led_update_ms) {</front>
<front id="Marlin_mainCPP-6932">      next_status_led_update_ms += 500; // Update every 0.5s</front>
<front id="Marlin_mainCPP-6933">      for (int8_t cur_extruder = 0; cur_extruder &lt; EXTRUDERS; ++cur_extruder)</front>
<front id="Marlin_mainCPP-6934">         max_temp = max(max(max_temp, degHotend(cur_extruder)), degTargetHotend(cur_extruder));</front>
<front id="Marlin_mainCPP-6935">      #if HAS_TEMP_BED</front>
<front id="Marlin_mainCPP-6936">        max_temp = max(max(max_temp, degTargetBed()), degBed());</front>
<front id="Marlin_mainCPP-6937">      #endif</front>
<front id="Marlin_mainCPP-6938">      bool new_led = (max_temp &gt; 55.0) ? true : (max_temp &lt; 54.0) ? false : red_led;</front>
<front id="Marlin_mainCPP-6939">      if (new_led != red_led) {</front>
<front id="Marlin_mainCPP-6940">        red_led = new_led;</front>
<front id="Marlin_mainCPP-6941">        digitalWrite(STAT_LED_RED, new_led ? HIGH : LOW);</front>
<front id="Marlin_mainCPP-6942">        digitalWrite(STAT_LED_BLUE, new_led ? LOW : HIGH);</front>
<front id="Marlin_mainCPP-6943">      }</front>
<front id="Marlin_mainCPP-6944">    }</front>
<front id="Marlin_mainCPP-6945">  }</front>
<front id="Marlin_mainCPP-6946"></front>
<front id="Marlin_mainCPP-6947">#endif</front>
<front id="Marlin_mainCPP-6948"></front>
<front id="Marlin_mainCPP-6949">void enable_all_steppers() {</front>
<front id="Marlin_mainCPP-6950">  enable_x();</front>
<front id="Marlin_mainCPP-6951">  enable_y();</front>
<front id="Marlin_mainCPP-6952">  enable_z();</front>
<front id="Marlin_mainCPP-6953">  enable_e0();</front>
<front id="Marlin_mainCPP-6954">  enable_e1();</front>
<front id="Marlin_mainCPP-6955">  enable_e2();</front>
<front id="Marlin_mainCPP-6956">  enable_e3();</front>
<front id="Marlin_mainCPP-6957">}</front>
<front id="Marlin_mainCPP-6958"></front>
<front id="Marlin_mainCPP-6959">void disable_all_steppers() {</front>
<front id="Marlin_mainCPP-6960">  disable_x();</front>
<front id="Marlin_mainCPP-6961">  disable_y();</front>
<front id="Marlin_mainCPP-6962">  disable_z();</front>
<front id="Marlin_mainCPP-6963">  disable_e0();</front>
<front id="Marlin_mainCPP-6964">  disable_e1();</front>
<front id="Marlin_mainCPP-6965">  disable_e2();</front>
<front id="Marlin_mainCPP-6966">  disable_e3();</front>
<front id="Marlin_mainCPP-6967">}</front>
<front id="Marlin_mainCPP-6968"></front>
<front id="Marlin_mainCPP-6969">/**</front>
<front id="Marlin_mainCPP-6970"> * Standard idle routine keeps the machine alive</front>
<front id="Marlin_mainCPP-6971"> */</front>
<front id="Marlin_mainCPP-6972">void idle() {</front>
<front id="Marlin_mainCPP-6973">  manage_heater();</front>
<front id="Marlin_mainCPP-6974">  manage_inactivity();</front>
<front id="Marlin_mainCPP-6975">  lcd_update();</front>
<front id="Marlin_mainCPP-6976">}</front>
<front id="Marlin_mainCPP-6977"></front>
<front id="Marlin_mainCPP-6978">/**</front>
<front id="Marlin_mainCPP-6979"> * Manage several activities:</front>
<front id="Marlin_mainCPP-6980"> *  - Check for Filament Runout</front>
<front id="Marlin_mainCPP-6981"> *  - Keep the command buffer full</front>
<front id="Marlin_mainCPP-6982"> *  - Check for maximum inactive time between commands</front>
<front id="Marlin_mainCPP-6983"> *  - Check for maximum inactive time between stepper commands</front>
<front id="Marlin_mainCPP-6984"> *  - Check if pin CHDK needs to go LOW</front>
<front id="Marlin_mainCPP-6985"> *  - Check for KILL button held down</front>
<front id="Marlin_mainCPP-6986"> *  - Check for HOME button held down</front>
<front id="Marlin_mainCPP-6987"> *  - Check if cooling fan needs to be switched on</front>
<front id="Marlin_mainCPP-6988"> *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)</front>
<front id="Marlin_mainCPP-6989"> */</front>
<front id="Marlin_mainCPP-6990">void manage_inactivity(bool ignore_stepper_queue/*=false*/) {</front>
<front id="Marlin_mainCPP-6991"></front>
<front id="Marlin_mainCPP-6992">  #if HAS_FILRUNOUT</front>
<front id="Marlin_mainCPP-6993">    if (IS_SD_PRINTING && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING))</front>
<front id="Marlin_mainCPP-6994">      filrunout();</front>
<front id="Marlin_mainCPP-6995">  #endif</front>
<front id="Marlin_mainCPP-6996"></front>
<front id="Marlin_mainCPP-6997">  if (commands_in_queue &lt; BUFSIZE - 1) get_command();</front>
<front id="Marlin_mainCPP-6998"></front>
<front id="Marlin_mainCPP-6999">  millis_t ms = millis();</front>
<front id="Marlin_mainCPP-7000"></front>
<front id="Marlin_mainCPP-7001">  if (max_inactive_time && ms &gt; previous_cmd_ms + max_inactive_time) kill(PSTR(MSG_KILLED));</front>
<front id="Marlin_mainCPP-7002"></front>
<front id="Marlin_mainCPP-7003">  if (stepper_inactive_time && ms &gt; previous_cmd_ms + stepper_inactive_time</front>
<front id="Marlin_mainCPP-7004">      && !ignore_stepper_queue && !blocks_queued()) {</front>
<front id="Marlin_mainCPP-7005">    #if DISABLE_X == true</front>
<front id="Marlin_mainCPP-7006">      disable_x();</front>
<front id="Marlin_mainCPP-7007">    #endif</front>
<front id="Marlin_mainCPP-7008">    #if DISABLE_Y == true</front>
<front id="Marlin_mainCPP-7009">      disable_y();</front>
<front id="Marlin_mainCPP-7010">    #endif</front>
<front id="Marlin_mainCPP-7011">    #if DISABLE_Z == true</front>
<front id="Marlin_mainCPP-7012">      disable_z();</front>
<front id="Marlin_mainCPP-7013">    #endif</front>
<front id="Marlin_mainCPP-7014">    #if DISABLE_E == true</front>
<front id="Marlin_mainCPP-7015">      disable_e0();</front>
<front id="Marlin_mainCPP-7016">      disable_e1();</front>
<front id="Marlin_mainCPP-7017">      disable_e2();</front>
<front id="Marlin_mainCPP-7018">      disable_e3();</front>
<front id="Marlin_mainCPP-7019">    #endif</front>
<front id="Marlin_mainCPP-7020">  }</front>
<front id="Marlin_mainCPP-7021"></front>
<front id="Marlin_mainCPP-7022">  #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH</front>
<front id="Marlin_mainCPP-7023">    if (chdkActive && ms &gt; chdkHigh + CHDK_DELAY) {</front>
<front id="Marlin_mainCPP-7024">      chdkActive = false;</front>
<front id="Marlin_mainCPP-7025">      WRITE(CHDK, LOW);</front>
<front id="Marlin_mainCPP-7026">    }</front>
<front id="Marlin_mainCPP-7027">  #endif</front>
<front id="Marlin_mainCPP-7028"></front>
<front id="Marlin_mainCPP-7029">  #if HAS_KILL</front>
<front id="Marlin_mainCPP-7030"></front>
<front id="Marlin_mainCPP-7031">    // Check if the kill button was pressed and wait just in case it was an accidental</front>
<front id="Marlin_mainCPP-7032">    // key kill key press</front>
<front id="Marlin_mainCPP-7033">    // -------------------------------------------------------------------------------</front>
<front id="Marlin_mainCPP-7034">    static int killCount = 0;   // make the inactivity button a bit less responsive</front>
<front id="Marlin_mainCPP-7035">    const int KILL_DELAY = 750;</front>
<front id="Marlin_mainCPP-7036">    if (!READ(KILL_PIN))</front>
<front id="Marlin_mainCPP-7037">       killCount++;</front>
<front id="Marlin_mainCPP-7038">    else if (killCount &gt; 0)</front>
<front id="Marlin_mainCPP-7039">       killCount--;</front>
<front id="Marlin_mainCPP-7040"></front>
<front id="Marlin_mainCPP-7041">    // Exceeded threshold and we can confirm that it was not accidental</front>
<front id="Marlin_mainCPP-7042">    // KILL the machine</front>
<front id="Marlin_mainCPP-7043">    // ----------------------------------------------------------------</front>
<front id="Marlin_mainCPP-7044">    if (killCount &gt;= KILL_DELAY) kill(PSTR(MSG_KILLED));</front>
<front id="Marlin_mainCPP-7045">  #endif</front>
<front id="Marlin_mainCPP-7046"></front>
<front id="Marlin_mainCPP-7047">  #if HAS_HOME</front>
<front id="Marlin_mainCPP-7048">    // Check to see if we have to home, use poor man's debouncer</front>
<front id="Marlin_mainCPP-7049">    // ---------------------------------------------------------</front>
<front id="Marlin_mainCPP-7050">    static int homeDebounceCount = 0;   // poor man's debouncing count</front>
<front id="Marlin_mainCPP-7051">    const int HOME_DEBOUNCE_DELAY = 2500;</front>
<front id="Marlin_mainCPP-7052">    if (!READ(HOME_PIN)) {</front>
<front id="Marlin_mainCPP-7053">      if (!homeDebounceCount) {</front>
<front id="Marlin_mainCPP-7054">        enqueuecommands_P(PSTR("G28"));</front>
<front id="Marlin_mainCPP-7055">        LCD_MESSAGEPGM(MSG_AUTO_HOME);</front>
<front id="Marlin_mainCPP-7056">      }</front>
<front id="Marlin_mainCPP-7057">      if (homeDebounceCount &lt; HOME_DEBOUNCE_DELAY)</front>
<front id="Marlin_mainCPP-7058">        homeDebounceCount++;</front>
<front id="Marlin_mainCPP-7059">      else</front>
<front id="Marlin_mainCPP-7060">        homeDebounceCount = 0;</front>
<front id="Marlin_mainCPP-7061">    }</front>
<front id="Marlin_mainCPP-7062">  #endif</front>
<front id="Marlin_mainCPP-7063"></front>
<front id="Marlin_mainCPP-7064">  #if HAS_CONTROLLERFAN</front>
<front id="Marlin_mainCPP-7065">    controllerFan(); // Check if fan should be turned on to cool stepper drivers down</front>
<front id="Marlin_mainCPP-7066">  #endif</front>
<front id="Marlin_mainCPP-7067"></front>
<front id="Marlin_mainCPP-7068">  #if ENABLED(EXTRUDER_RUNOUT_PREVENT)</front>
<front id="Marlin_mainCPP-7069">    if (ms &gt; previous_cmd_ms + EXTRUDER_RUNOUT_SECONDS * 1000)</front>
<front id="Marlin_mainCPP-7070">    if (degHotend(active_extruder) &gt; EXTRUDER_RUNOUT_MINTEMP) {</front>
<front id="Marlin_mainCPP-7071">      bool oldstatus;</front>
<front id="Marlin_mainCPP-7072">      switch(active_extruder) {</front>
<front id="Marlin_mainCPP-7073">        case 0:</front>
<front id="Marlin_mainCPP-7074">          oldstatus = E0_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7075">          enable_e0();</front>
<front id="Marlin_mainCPP-7076">          break;</front>
<front id="Marlin_mainCPP-7077">        #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-7078">          case 1:</front>
<front id="Marlin_mainCPP-7079">            oldstatus = E1_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7080">            enable_e1();</front>
<front id="Marlin_mainCPP-7081">            break;</front>
<front id="Marlin_mainCPP-7082">          #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-7083">            case 2:</front>
<front id="Marlin_mainCPP-7084">              oldstatus = E2_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7085">              enable_e2();</front>
<front id="Marlin_mainCPP-7086">              break;</front>
<front id="Marlin_mainCPP-7087">            #if EXTRUDERS &gt; 3</front>
<front id="Marlin_mainCPP-7088">              case 3:</front>
<front id="Marlin_mainCPP-7089">                oldstatus = E3_ENABLE_READ;</front>
<front id="Marlin_mainCPP-7090">                enable_e3();</front>
<front id="Marlin_mainCPP-7091">                break;</front>
<front id="Marlin_mainCPP-7092">            #endif</front>
<front id="Marlin_mainCPP-7093">          #endif</front>
<front id="Marlin_mainCPP-7094">        #endif</front>
<front id="Marlin_mainCPP-7095">      }</front>
<front id="Marlin_mainCPP-7096">      float oldepos = current_position[E_AXIS], oldedes = destination[E_AXIS];</front>
<front id="Marlin_mainCPP-7097">      plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],</front>
<front id="Marlin_mainCPP-7098">                      destination[E_AXIS] + EXTRUDER_RUNOUT_EXTRUDE * EXTRUDER_RUNOUT_ESTEPS / axis_steps_per_unit[E_AXIS],</front>
<front id="Marlin_mainCPP-7099">                      EXTRUDER_RUNOUT_SPEED / 60. * EXTRUDER_RUNOUT_ESTEPS / axis_steps_per_unit[E_AXIS], active_extruder);</front>
<front id="Marlin_mainCPP-7100">      current_position[E_AXIS] = oldepos;</front>
<front id="Marlin_mainCPP-7101">      destination[E_AXIS] = oldedes;</front>
<front id="Marlin_mainCPP-7102">      plan_set_e_position(oldepos);</front>
<front id="Marlin_mainCPP-7103">      previous_cmd_ms = ms; // refresh_cmd_timeout()</front>
<front id="Marlin_mainCPP-7104">      st_synchronize();</front>
<front id="Marlin_mainCPP-7105">      switch(active_extruder) {</front>
<front id="Marlin_mainCPP-7106">        case 0:</front>
<front id="Marlin_mainCPP-7107">          E0_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7108">          break;</front>
<front id="Marlin_mainCPP-7109">        #if EXTRUDERS &gt; 1</front>
<front id="Marlin_mainCPP-7110">          case 1:</front>
<front id="Marlin_mainCPP-7111">            E1_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7112">            break;</front>
<front id="Marlin_mainCPP-7113">          #if EXTRUDERS &gt; 2</front>
<front id="Marlin_mainCPP-7114">            case 2:</front>
<front id="Marlin_mainCPP-7115">              E2_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7116">              break;</front>
<front id="Marlin_mainCPP-7117">            #if EXTRUDERS &gt; 3</front>
<front id="Marlin_mainCPP-7118">              case 3:</front>
<front id="Marlin_mainCPP-7119">                E3_ENABLE_WRITE(oldstatus);</front>
<front id="Marlin_mainCPP-7120">                break;</front>
<front id="Marlin_mainCPP-7121">            #endif</front>
<front id="Marlin_mainCPP-7122">          #endif</front>
<front id="Marlin_mainCPP-7123">        #endif</front>
<front id="Marlin_mainCPP-7124">      }</front>
<front id="Marlin_mainCPP-7125">    }</front>
<front id="Marlin_mainCPP-7126">  #endif</front>
<front id="Marlin_mainCPP-7127"></front>
<front id="Marlin_mainCPP-7128">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="Marlin_mainCPP-7129">    // handle delayed move timeout</front>
<front id="Marlin_mainCPP-7130">    if (delayed_move_time && ms &gt; delayed_move_time + 1000 && IsRunning()) {</front>
<front id="Marlin_mainCPP-7131">      // travel moves have been received so enact them</front>
<front id="Marlin_mainCPP-7132">      delayed_move_time = 0xFFFFFFFFUL; // force moves to be done</front>
<front id="Marlin_mainCPP-7133">      set_destination_to_current();</front>
<front id="Marlin_mainCPP-7134">      prepare_move();</front>
<front id="Marlin_mainCPP-7135">    }</front>
<front id="Marlin_mainCPP-7136">  #endif</front>
<front id="Marlin_mainCPP-7137"></front>
<front id="Marlin_mainCPP-7138">  #if ENABLED(TEMP_STAT_LEDS)</front>
<front id="Marlin_mainCPP-7139">    handle_status_leds();</front>
<front id="Marlin_mainCPP-7140">  #endif</front>
<front id="Marlin_mainCPP-7141"></front>
<front id="Marlin_mainCPP-7142">  check_axes_activity();</front>
<front id="Marlin_mainCPP-7143">}</front>
<front id="Marlin_mainCPP-7144"></front>
<front id="Marlin_mainCPP-7145">void kill(const char *lcd_msg) {</front>
<front id="Marlin_mainCPP-7146">  #if ENABLED(ULTRA_LCD)</front>
<front id="Marlin_mainCPP-7147">    lcd_setalertstatuspgm(lcd_msg);</front>
<front id="Marlin_mainCPP-7148">  #endif</front>
<front id="Marlin_mainCPP-7149"></front>
<front id="Marlin_mainCPP-7150">  cli(); // Stop interrupts</front>
<front id="Marlin_mainCPP-7151">  disable_all_heaters();</front>
<front id="Marlin_mainCPP-7152">  disable_all_steppers();</front>
<front id="Marlin_mainCPP-7153"></front>
<front id="Marlin_mainCPP-7154">  #if HAS_POWER_SWITCH</front>
<front id="Marlin_mainCPP-7155">    pinMode(PS_ON_PIN, INPUT);</front>
<front id="Marlin_mainCPP-7156">  #endif</front>
<front id="Marlin_mainCPP-7157"></front>
<front id="Marlin_mainCPP-7158">  SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-7159">  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);</front>
<front id="Marlin_mainCPP-7160"></front>
<front id="Marlin_mainCPP-7161">  // FMC small patch to update the LCD before ending</front>
<front id="Marlin_mainCPP-7162">  sei();   // enable interrupts</front>
<front id="Marlin_mainCPP-7163">  for (int i = 5; i--; lcd_update()) delay(200); // Wait a short time</front>
<front id="Marlin_mainCPP-7164">  cli();   // disable interrupts</front>
<front id="Marlin_mainCPP-7165">  suicide();</front>
<front id="Marlin_mainCPP-7166">  while(1) { /* Intentionally left empty */ } // Wait for reset</front>
<front id="Marlin_mainCPP-7167">}</front>
<front id="Marlin_mainCPP-7168"></front>
<front id="Marlin_mainCPP-7169">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="Marlin_mainCPP-7170"></front>
<front id="Marlin_mainCPP-7171">  void filrunout() {</front>
<front id="Marlin_mainCPP-7172">    if (!filrunoutEnqueued) {</front>
<front id="Marlin_mainCPP-7173">      filrunoutEnqueued = true;</front>
<front id="Marlin_mainCPP-7174">      enqueuecommands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));</front>
<front id="Marlin_mainCPP-7175">      st_synchronize();</front>
<front id="Marlin_mainCPP-7176">    }</front>
<front id="Marlin_mainCPP-7177">  }</front>
<front id="Marlin_mainCPP-7178"></front>
<front id="Marlin_mainCPP-7179">#endif // FILAMENT_RUNOUT_SENSOR</front>
<front id="Marlin_mainCPP-7180"></front>
<front id="Marlin_mainCPP-7181">#if ENABLED(FAST_PWM_FAN)</front>
<front id="Marlin_mainCPP-7182"></front>
<front id="Marlin_mainCPP-7183">  void setPwmFrequency(uint8_t pin, int val) {</front>
<front id="Marlin_mainCPP-7184">    val &= 0x07;</front>
<front id="Marlin_mainCPP-7185">    switch (digitalPinToTimer(pin)) {</front>
<front id="Marlin_mainCPP-7186"></front>
<front id="Marlin_mainCPP-7187">      #if defined(TCCR0A)</front>
<front id="Marlin_mainCPP-7188">        case TIMER0A:</front>
<front id="Marlin_mainCPP-7189">        case TIMER0B:</front>
<front id="Marlin_mainCPP-7190">             // TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));</front>
<front id="Marlin_mainCPP-7191">             // TCCR0B |= val;</front>
<front id="Marlin_mainCPP-7192">             break;</front>
<front id="Marlin_mainCPP-7193">      #endif</front>
<front id="Marlin_mainCPP-7194"></front>
<front id="Marlin_mainCPP-7195">      #if defined(TCCR1A)</front>
<front id="Marlin_mainCPP-7196">        case TIMER1A:</front>
<front id="Marlin_mainCPP-7197">        case TIMER1B:</front>
<front id="Marlin_mainCPP-7198">             // TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</front>
<front id="Marlin_mainCPP-7199">             // TCCR1B |= val;</front>
<front id="Marlin_mainCPP-7200">             break;</front>
<front id="Marlin_mainCPP-7201">      #endif</front>
<front id="Marlin_mainCPP-7202"></front>
<front id="Marlin_mainCPP-7203">      #if defined(TCCR2)</front>
<front id="Marlin_mainCPP-7204">        case TIMER2:</front>
<front id="Marlin_mainCPP-7205">        case TIMER2:</front>
<front id="Marlin_mainCPP-7206">             TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</front>
<front id="Marlin_mainCPP-7207">             TCCR2 |= val;</front>
<front id="Marlin_mainCPP-7208">             break;</front>
<front id="Marlin_mainCPP-7209">      #endif</front>
<front id="Marlin_mainCPP-7210"></front>
<front id="Marlin_mainCPP-7211">      #if defined(TCCR2A)</front>
<front id="Marlin_mainCPP-7212">        case TIMER2A:</front>
<front id="Marlin_mainCPP-7213">        case TIMER2B:</front>
<front id="Marlin_mainCPP-7214">             TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));</front>
<front id="Marlin_mainCPP-7215">             TCCR2B |= val;</front>
<front id="Marlin_mainCPP-7216">             break;</front>
<front id="Marlin_mainCPP-7217">      #endif</front>
<front id="Marlin_mainCPP-7218"></front>
<front id="Marlin_mainCPP-7219">      #if defined(TCCR3A)</front>
<front id="Marlin_mainCPP-7220">        case TIMER3A:</front>
<front id="Marlin_mainCPP-7221">        case TIMER3B:</front>
<front id="Marlin_mainCPP-7222">        case TIMER3C:</front>
<front id="Marlin_mainCPP-7223">             TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));</front>
<front id="Marlin_mainCPP-7224">             TCCR3B |= val;</front>
<front id="Marlin_mainCPP-7225">             break;</front>
<front id="Marlin_mainCPP-7226">      #endif</front>
<front id="Marlin_mainCPP-7227"></front>
<front id="Marlin_mainCPP-7228">      #if defined(TCCR4A)</front>
<front id="Marlin_mainCPP-7229">        case TIMER4A:</front>
<front id="Marlin_mainCPP-7230">        case TIMER4B:</front>
<front id="Marlin_mainCPP-7231">        case TIMER4C:</front>
<front id="Marlin_mainCPP-7232">             TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));</front>
<front id="Marlin_mainCPP-7233">             TCCR4B |= val;</front>
<front id="Marlin_mainCPP-7234">             break;</front>
<front id="Marlin_mainCPP-7235">      #endif</front>
<front id="Marlin_mainCPP-7236"></front>
<front id="Marlin_mainCPP-7237">      #if defined(TCCR5A)</front>
<front id="Marlin_mainCPP-7238">        case TIMER5A:</front>
<front id="Marlin_mainCPP-7239">        case TIMER5B:</front>
<front id="Marlin_mainCPP-7240">        case TIMER5C:</front>
<front id="Marlin_mainCPP-7241">             TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));</front>
<front id="Marlin_mainCPP-7242">             TCCR5B |= val;</front>
<front id="Marlin_mainCPP-7243">             break;</front>
<front id="Marlin_mainCPP-7244">      #endif</front>
<front id="Marlin_mainCPP-7245"></front>
<front id="Marlin_mainCPP-7246">    }</front>
<front id="Marlin_mainCPP-7247">  }</front>
<front id="Marlin_mainCPP-7248"></front>
<front id="Marlin_mainCPP-7249">#endif // FAST_PWM_FAN</front>
<front id="Marlin_mainCPP-7250"></front>
<front id="Marlin_mainCPP-7251">void Stop() {</front>
<front id="Marlin_mainCPP-7252">  disable_all_heaters();</front>
<front id="Marlin_mainCPP-7253">  if (IsRunning()) {</front>
<front id="Marlin_mainCPP-7254">    Running = false;</front>
<front id="Marlin_mainCPP-7255">    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart</front>
<front id="Marlin_mainCPP-7256">    SERIAL_ERROR_START;</front>
<front id="Marlin_mainCPP-7257">    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);</front>
<front id="Marlin_mainCPP-7258">    LCD_MESSAGEPGM(MSG_STOPPED);</front>
<front id="Marlin_mainCPP-7259">  }</front>
<front id="Marlin_mainCPP-7260">}</front>
<front id="Marlin_mainCPP-7261"></front>
<front id="Marlin_mainCPP-7262">/**</front>
<front id="Marlin_mainCPP-7263"> * Set target_extruder from the T parameter or the active_extruder</front>
<front id="Marlin_mainCPP-7264"> *</front>
<front id="Marlin_mainCPP-7265"> * Returns TRUE if the target is invalid</front>
<front id="Marlin_mainCPP-7266"> */</front>
<front id="Marlin_mainCPP-7267">bool setTargetedHotend(int code) {</front>
<front id="Marlin_mainCPP-7268">  target_extruder = active_extruder;</front>
<front id="Marlin_mainCPP-7269">  if (code_seen('T')) {</front>
<front id="Marlin_mainCPP-7270">    target_extruder = code_value_short();</front>
<front id="Marlin_mainCPP-7271">    if (target_extruder &gt;= EXTRUDERS) {</front>
<front id="Marlin_mainCPP-7272">      SERIAL_ECHO_START;</front>
<front id="Marlin_mainCPP-7273">      SERIAL_CHAR('M');</front>
<front id="Marlin_mainCPP-7274">      SERIAL_ECHO(code);</front>
<front id="Marlin_mainCPP-7275">      SERIAL_ECHOPGM(" " MSG_INVALID_EXTRUDER " ");</front>
<front id="Marlin_mainCPP-7276">      SERIAL_ECHOLN(target_extruder);</front>
<front id="Marlin_mainCPP-7277">      return true;</front>
<front id="Marlin_mainCPP-7278">    }</front>
<front id="Marlin_mainCPP-7279">  }</front>
<front id="Marlin_mainCPP-7280">  return false;</front>
<front id="Marlin_mainCPP-7281">}</front>
<front id="Marlin_mainCPP-7282"></front>
<front id="Marlin_mainCPP-7283">float calculate_volumetric_multiplier(float diameter) {</front>
<front id="Marlin_mainCPP-7284">  if (!volumetric_enabled || diameter == 0) return 1.0;</front>
<front id="Marlin_mainCPP-7285">  float d2 = diameter * 0.5;</front>
<front id="Marlin_mainCPP-7286">  return 1.0 / (M_PI * d2 * d2);</front>
<front id="Marlin_mainCPP-7287">}</front>
<front id="Marlin_mainCPP-7288"></front>
<front id="Marlin_mainCPP-7289">void calculate_volumetric_multipliers() {</front>
<front id="Marlin_mainCPP-7290">  for (int i=0; i&lt;EXTRUDERS; i++)</front>
<front id="Marlin_mainCPP-7291">    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);</front>
<front id="Marlin_mainCPP-7292">}</front>
 </pre>
<h1 id="MarlinSerialCPPtitle" >MarlinSerial.cpp</h1>
<pre id="MarlinSerialCPP"  class="prettyprint linenums"><front id="MarlinSerialCPP-1">/*</front>
<front id="MarlinSerialCPP-2">  HardwareSerial.cpp - Hardware serial library for Wiring</front>
<front id="MarlinSerialCPP-3">  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.</front>
<front id="MarlinSerialCPP-4"></front>
<front id="MarlinSerialCPP-5">  This library is free software; you can redistribute it and/or</front>
<front id="MarlinSerialCPP-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="MarlinSerialCPP-7">  License as published by the Free Software Foundation; either</front>
<front id="MarlinSerialCPP-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="MarlinSerialCPP-9"></front>
<front id="MarlinSerialCPP-10">  This library is distributed in the hope that it will be useful,</front>
<front id="MarlinSerialCPP-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="MarlinSerialCPP-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="MarlinSerialCPP-13">  Lesser General Public License for more details.</front>
<front id="MarlinSerialCPP-14"></front>
<front id="MarlinSerialCPP-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="MarlinSerialCPP-16">  License along with this library; if not, write to the Free Software</front>
<front id="MarlinSerialCPP-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="MarlinSerialCPP-18">  </front>
<front id="MarlinSerialCPP-19">  Modified 23 November 2006 by David A. Mellis</front>
<front id="MarlinSerialCPP-20">  Modified 28 September 2010 by Mark Sproul</front>
<front id="MarlinSerialCPP-21">*/</front>
<front id="MarlinSerialCPP-22"></front>
<front id="MarlinSerialCPP-23">#include "Marlin.h"</front>
<front id="MarlinSerialCPP-24">#include "MarlinSerial.h"</front>
<front id="MarlinSerialCPP-25"></front>
<front id="MarlinSerialCPP-26">#ifndef USBCON</front>
<front id="MarlinSerialCPP-27">// this next line disables the entire HardwareSerial.cpp, </front>
<front id="MarlinSerialCPP-28">// this is so I can support Attiny series and any other chip without a UART</front>
<front id="MarlinSerialCPP-29">#if defined(UBRRH) || defined(UBRR0H) || defined(UBRR1H) || defined(UBRR2H) || defined(UBRR3H)</front>
<front id="MarlinSerialCPP-30"></front>
<front id="MarlinSerialCPP-31">#if UART_PRESENT(SERIAL_PORT)</front>
<front id="MarlinSerialCPP-32">  ring_buffer rx_buffer  =  { { 0 }, 0, 0 };</front>
<front id="MarlinSerialCPP-33">#endif</front>
<front id="MarlinSerialCPP-34"></front>
<front id="MarlinSerialCPP-35">FORCE_INLINE void store_char(unsigned char c) {</front>
<front id="MarlinSerialCPP-36">  int i = (unsigned int)(rx_buffer.head + 1) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialCPP-37"></front>
<front id="MarlinSerialCPP-38">  // if we should be storing the received character into the location</front>
<front id="MarlinSerialCPP-39">  // just before the tail (meaning that the head would advance to the</front>
<front id="MarlinSerialCPP-40">  // current location of the tail), we're about to overflow the buffer</front>
<front id="MarlinSerialCPP-41">  // and so we don't write the character or advance the head.</front>
<front id="MarlinSerialCPP-42">  if (i != rx_buffer.tail) {</front>
<front id="MarlinSerialCPP-43">    rx_buffer.buffer[rx_buffer.head] = c;</front>
<front id="MarlinSerialCPP-44">    rx_buffer.head = i;</front>
<front id="MarlinSerialCPP-45">  }</front>
<front id="MarlinSerialCPP-46">}</front>
<front id="MarlinSerialCPP-47"></front>
<front id="MarlinSerialCPP-48"></front>
<front id="MarlinSerialCPP-49">//#elif defined(SIG_USART_RECV)</front>
<front id="MarlinSerialCPP-50">#if defined(M_USARTx_RX_vect)</front>
<front id="MarlinSerialCPP-51">  // fixed by Mark Sproul this is on the 644/644p</front>
<front id="MarlinSerialCPP-52">  //SIGNAL(SIG_USART_RECV)</front>
<front id="MarlinSerialCPP-53">  SIGNAL(M_USARTx_RX_vect) {</front>
<front id="MarlinSerialCPP-54">    unsigned char c  =  M_UDRx;</front>
<front id="MarlinSerialCPP-55">    store_char(c);</front>
<front id="MarlinSerialCPP-56">  }</front>
<front id="MarlinSerialCPP-57">#endif</front>
<front id="MarlinSerialCPP-58"></front>
<front id="MarlinSerialCPP-59">// Constructors ////////////////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-60"></front>
<front id="MarlinSerialCPP-61">MarlinSerial::MarlinSerial() { }</front>
<front id="MarlinSerialCPP-62"></front>
<front id="MarlinSerialCPP-63">// Public Methods //////////////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-64"></front>
<front id="MarlinSerialCPP-65">void MarlinSerial::begin(long baud) {</front>
<front id="MarlinSerialCPP-66">  uint16_t baud_setting;</front>
<front id="MarlinSerialCPP-67">  bool useU2X = true;</front>
<front id="MarlinSerialCPP-68"></front>
<front id="MarlinSerialCPP-69">  #if F_CPU == 16000000UL && SERIAL_PORT == 0</front>
<front id="MarlinSerialCPP-70">    // hard-coded exception for compatibility with the bootloader shipped</front>
<front id="MarlinSerialCPP-71">    // with the Duemilanove and previous boards and the firmware on the 8U2</front>
<front id="MarlinSerialCPP-72">    // on the Uno and Mega 2560.</front>
<front id="MarlinSerialCPP-73">    if (baud == 57600) {</front>
<front id="MarlinSerialCPP-74">      useU2X = false;</front>
<front id="MarlinSerialCPP-75">    }</front>
<front id="MarlinSerialCPP-76">  #endif</front>
<front id="MarlinSerialCPP-77">  </front>
<front id="MarlinSerialCPP-78">  if (useU2X) {</front>
<front id="MarlinSerialCPP-79">    M_UCSRxA = BIT(M_U2Xx);</front>
<front id="MarlinSerialCPP-80">    baud_setting = (F_CPU / 4 / baud - 1) / 2;</front>
<front id="MarlinSerialCPP-81">  } else {</front>
<front id="MarlinSerialCPP-82">    M_UCSRxA = 0;</front>
<front id="MarlinSerialCPP-83">    baud_setting = (F_CPU / 8 / baud - 1) / 2;</front>
<front id="MarlinSerialCPP-84">  }</front>
<front id="MarlinSerialCPP-85"></front>
<front id="MarlinSerialCPP-86">  // assign the baud_setting, a.k.a. ubbr (USART Baud Rate Register)</front>
<front id="MarlinSerialCPP-87">  M_UBRRxH = baud_setting &gt;&gt; 8;</front>
<front id="MarlinSerialCPP-88">  M_UBRRxL = baud_setting;</front>
<front id="MarlinSerialCPP-89"></front>
<front id="MarlinSerialCPP-90">  sbi(M_UCSRxB, M_RXENx);</front>
<front id="MarlinSerialCPP-91">  sbi(M_UCSRxB, M_TXENx);</front>
<front id="MarlinSerialCPP-92">  sbi(M_UCSRxB, M_RXCIEx);</front>
<front id="MarlinSerialCPP-93">}</front>
<front id="MarlinSerialCPP-94"></front>
<front id="MarlinSerialCPP-95">void MarlinSerial::end() {</front>
<front id="MarlinSerialCPP-96">  cbi(M_UCSRxB, M_RXENx);</front>
<front id="MarlinSerialCPP-97">  cbi(M_UCSRxB, M_TXENx);</front>
<front id="MarlinSerialCPP-98">  cbi(M_UCSRxB, M_RXCIEx);  </front>
<front id="MarlinSerialCPP-99">}</front>
<front id="MarlinSerialCPP-100"></front>
<front id="MarlinSerialCPP-101"></front>
<front id="MarlinSerialCPP-102">int MarlinSerial::peek(void) {</front>
<front id="MarlinSerialCPP-103">  if (rx_buffer.head == rx_buffer.tail) {</front>
<front id="MarlinSerialCPP-104">    return -1;</front>
<front id="MarlinSerialCPP-105">  } else {</front>
<front id="MarlinSerialCPP-106">    return rx_buffer.buffer[rx_buffer.tail];</front>
<front id="MarlinSerialCPP-107">  }</front>
<front id="MarlinSerialCPP-108">}</front>
<front id="MarlinSerialCPP-109"></front>
<front id="MarlinSerialCPP-110">int MarlinSerial::read(void) {</front>
<front id="MarlinSerialCPP-111">  // if the head isn't ahead of the tail, we don't have any characters</front>
<front id="MarlinSerialCPP-112">  if (rx_buffer.head == rx_buffer.tail) {</front>
<front id="MarlinSerialCPP-113">    return -1;</front>
<front id="MarlinSerialCPP-114">  }</front>
<front id="MarlinSerialCPP-115">  else {</front>
<front id="MarlinSerialCPP-116">    unsigned char c = rx_buffer.buffer[rx_buffer.tail];</front>
<front id="MarlinSerialCPP-117">    rx_buffer.tail = (unsigned int)(rx_buffer.tail + 1) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialCPP-118">    return c;</front>
<front id="MarlinSerialCPP-119">  }</front>
<front id="MarlinSerialCPP-120">}</front>
<front id="MarlinSerialCPP-121"></front>
<front id="MarlinSerialCPP-122">void MarlinSerial::flush() {</front>
<front id="MarlinSerialCPP-123">  // don't reverse this or there may be problems if the RX interrupt</front>
<front id="MarlinSerialCPP-124">  // occurs after reading the value of rx_buffer_head but before writing</front>
<front id="MarlinSerialCPP-125">  // the value to rx_buffer_tail; the previous value of rx_buffer_head</front>
<front id="MarlinSerialCPP-126">  // may be written to rx_buffer_tail, making it appear as if the buffer</front>
<front id="MarlinSerialCPP-127">  // don't reverse this or there may be problems if the RX interrupt</front>
<front id="MarlinSerialCPP-128">  // occurs after reading the value of rx_buffer_head but before writing</front>
<front id="MarlinSerialCPP-129">  // the value to rx_buffer_tail; the previous value of rx_buffer_head</front>
<front id="MarlinSerialCPP-130">  // may be written to rx_buffer_tail, making it appear as if the buffer</front>
<front id="MarlinSerialCPP-131">  // were full, not empty.</front>
<front id="MarlinSerialCPP-132">  rx_buffer.head = rx_buffer.tail;</front>
<front id="MarlinSerialCPP-133">}</front>
<front id="MarlinSerialCPP-134"></front>
<front id="MarlinSerialCPP-135"></front>
<front id="MarlinSerialCPP-136">/// imports from print.h</front>
<front id="MarlinSerialCPP-137"></front>
<front id="MarlinSerialCPP-138"></front>
<front id="MarlinSerialCPP-139">void MarlinSerial::print(char c, int base) {</front>
<front id="MarlinSerialCPP-140">  print((long) c, base);</front>
<front id="MarlinSerialCPP-141">}</front>
<front id="MarlinSerialCPP-142"></front>
<front id="MarlinSerialCPP-143">void MarlinSerial::print(unsigned char b, int base) {</front>
<front id="MarlinSerialCPP-144">  print((unsigned long) b, base);</front>
<front id="MarlinSerialCPP-145">}</front>
<front id="MarlinSerialCPP-146"></front>
<front id="MarlinSerialCPP-147">void MarlinSerial::print(int n, int base) {</front>
<front id="MarlinSerialCPP-148">  print((long) n, base);</front>
<front id="MarlinSerialCPP-149">}</front>
<front id="MarlinSerialCPP-150"></front>
<front id="MarlinSerialCPP-151">void MarlinSerial::print(unsigned int n, int base) {</front>
<front id="MarlinSerialCPP-152">  print((unsigned long) n, base);</front>
<front id="MarlinSerialCPP-153">}</front>
<front id="MarlinSerialCPP-154"></front>
<front id="MarlinSerialCPP-155">void MarlinSerial::print(long n, int base) {</front>
<front id="MarlinSerialCPP-156">  if (base == 0) {</front>
<front id="MarlinSerialCPP-157">    write(n);</front>
<front id="MarlinSerialCPP-158">  }</front>
<front id="MarlinSerialCPP-159">  else if (base == 10) {</front>
<front id="MarlinSerialCPP-160">    if (n &lt; 0) {</front>
<front id="MarlinSerialCPP-161">      print('-');</front>
<front id="MarlinSerialCPP-162">      n = -n;</front>
<front id="MarlinSerialCPP-163">    }</front>
<front id="MarlinSerialCPP-164">    printNumber(n, 10);</front>
<front id="MarlinSerialCPP-165">  } else {</front>
<front id="MarlinSerialCPP-166">    printNumber(n, base);</front>
<front id="MarlinSerialCPP-167">  }</front>
<front id="MarlinSerialCPP-168">}</front>
<front id="MarlinSerialCPP-169"></front>
<front id="MarlinSerialCPP-170">void MarlinSerial::print(unsigned long n, int base) {</front>
<front id="MarlinSerialCPP-171">  if (base == 0) write(n);</front>
<front id="MarlinSerialCPP-172">  else printNumber(n, base);</front>
<front id="MarlinSerialCPP-173">}</front>
<front id="MarlinSerialCPP-174"></front>
<front id="MarlinSerialCPP-175">void MarlinSerial::print(double n, int digits) {</front>
<front id="MarlinSerialCPP-176">  printFloat(n, digits);</front>
<front id="MarlinSerialCPP-177">}</front>
<front id="MarlinSerialCPP-178"></front>
<front id="MarlinSerialCPP-179">void MarlinSerial::println(void) {</front>
<front id="MarlinSerialCPP-180">  print('\r');</front>
<front id="MarlinSerialCPP-181">  print('\n');  </front>
<front id="MarlinSerialCPP-182">}</front>
<front id="MarlinSerialCPP-183"></front>
<front id="MarlinSerialCPP-184">void MarlinSerial::println(const String &s) {</front>
<front id="MarlinSerialCPP-185">  print(s);</front>
<front id="MarlinSerialCPP-186">  println();</front>
<front id="MarlinSerialCPP-187">}</front>
<front id="MarlinSerialCPP-188"></front>
<front id="MarlinSerialCPP-189">void MarlinSerial::println(const char c[]) {</front>
<front id="MarlinSerialCPP-190">  print(c);</front>
<front id="MarlinSerialCPP-191">  println();</front>
<front id="MarlinSerialCPP-192">}</front>
<front id="MarlinSerialCPP-193"></front>
<front id="MarlinSerialCPP-194">void MarlinSerial::println(char c, int base) {</front>
<front id="MarlinSerialCPP-195">  print(c, base);</front>
<front id="MarlinSerialCPP-196">  println();</front>
<front id="MarlinSerialCPP-197">}</front>
<front id="MarlinSerialCPP-198"></front>
<front id="MarlinSerialCPP-199">void MarlinSerial::println(unsigned char b, int base) {</front>
<front id="MarlinSerialCPP-200">  print(b, base);</front>
<front id="MarlinSerialCPP-201">  println();</front>
<front id="MarlinSerialCPP-202">}</front>
<front id="MarlinSerialCPP-203"></front>
<front id="MarlinSerialCPP-204">void MarlinSerial::println(int n, int base) {</front>
<front id="MarlinSerialCPP-205">  print(n, base);</front>
<front id="MarlinSerialCPP-206">  println();</front>
<front id="MarlinSerialCPP-207">}</front>
<front id="MarlinSerialCPP-208"></front>
<front id="MarlinSerialCPP-209">void MarlinSerial::println(unsigned int n, int base) {</front>
<front id="MarlinSerialCPP-210">  print(n, base);</front>
<front id="MarlinSerialCPP-211">  println();</front>
<front id="MarlinSerialCPP-212">}</front>
<front id="MarlinSerialCPP-213"></front>
<front id="MarlinSerialCPP-214">void MarlinSerial::println(long n, int base) {</front>
<front id="MarlinSerialCPP-215">  print(n, base);</front>
<front id="MarlinSerialCPP-216">  println();</front>
<front id="MarlinSerialCPP-217">}</front>
<front id="MarlinSerialCPP-218"></front>
<front id="MarlinSerialCPP-219">void MarlinSerial::println(unsigned long n, int base) {</front>
<front id="MarlinSerialCPP-220">  print(n, base);</front>
<front id="MarlinSerialCPP-221">  println();</front>
<front id="MarlinSerialCPP-222">}</front>
<front id="MarlinSerialCPP-223"></front>
<front id="MarlinSerialCPP-224">void MarlinSerial::println(double n, int digits) {</front>
<front id="MarlinSerialCPP-225">  print(n, digits);</front>
<front id="MarlinSerialCPP-226">  println();</front>
<front id="MarlinSerialCPP-227">}</front>
<front id="MarlinSerialCPP-228"></front>
<front id="MarlinSerialCPP-229">// Private Methods /////////////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-230"></front>
<front id="MarlinSerialCPP-231">void MarlinSerial::printNumber(unsigned long n, uint8_t base) {</front>
<front id="MarlinSerialCPP-232">  unsigned char buf[8 * sizeof(long)]; // Assumes 8-bit chars. </front>
<front id="MarlinSerialCPP-233">  unsigned long i = 0;</front>
<front id="MarlinSerialCPP-234"></front>
<front id="MarlinSerialCPP-235">  if (n == 0) {</front>
<front id="MarlinSerialCPP-236">    print('0');</front>
<front id="MarlinSerialCPP-237">    return;</front>
<front id="MarlinSerialCPP-238">  } </front>
<front id="MarlinSerialCPP-239"></front>
<front id="MarlinSerialCPP-240">  while (n &gt; 0) {</front>
<front id="MarlinSerialCPP-241">    buf[i++] = n % base;</front>
<front id="MarlinSerialCPP-242">    n /= base;</front>
<front id="MarlinSerialCPP-243">  }</front>
<front id="MarlinSerialCPP-244"></front>
<front id="MarlinSerialCPP-245">  for (; i &gt; 0; i--)</front>
<front id="MarlinSerialCPP-246">    print((char) (buf[i - 1] &lt; 10 ?</front>
<front id="MarlinSerialCPP-247">      '0' + buf[i - 1] :</front>
<front id="MarlinSerialCPP-248">      'A' + buf[i - 1] - 10));</front>
<front id="MarlinSerialCPP-249">}</front>
<front id="MarlinSerialCPP-250"></front>
<front id="MarlinSerialCPP-251">void MarlinSerial::printFloat(double number, uint8_t digits) {</front>
<front id="MarlinSerialCPP-252">  // Handle negative numbers</front>
<front id="MarlinSerialCPP-253">  if (number &lt; 0.0) {</front>
<front id="MarlinSerialCPP-254">     print('-');</front>
<front id="MarlinSerialCPP-255">     number = -number;</front>
<front id="MarlinSerialCPP-256">  }</front>
<front id="MarlinSerialCPP-257"></front>
<front id="MarlinSerialCPP-258">  // Round correctly so that print(1.999, 2) prints as "2.00"</front>
<front id="MarlinSerialCPP-259">  double rounding = 0.5;</front>
<front id="MarlinSerialCPP-260">  for (uint8_t i = 0; i &lt; digits; ++i)</front>
<front id="MarlinSerialCPP-261">    rounding /= 10.0;</front>
<front id="MarlinSerialCPP-262">  </front>
<front id="MarlinSerialCPP-263">  number += rounding;</front>
<front id="MarlinSerialCPP-264"></front>
<front id="MarlinSerialCPP-265">  // Extract the integer part of the number and print it</front>
<front id="MarlinSerialCPP-266">  unsigned long int_part = (unsigned long)number;</front>
<front id="MarlinSerialCPP-267">  double remainder = number - (double)int_part;</front>
<front id="MarlinSerialCPP-268">  print(int_part);</front>
<front id="MarlinSerialCPP-269"></front>
<front id="MarlinSerialCPP-270">  // Print the decimal point, but only if there are digits beyond</front>
<front id="MarlinSerialCPP-271">  if (digits &gt; 0) print('.');</front>
<front id="MarlinSerialCPP-272"></front>
<front id="MarlinSerialCPP-273">  // Extract digits from the remainder one at a time</front>
<front id="MarlinSerialCPP-274">  while (digits-- &gt; 0) {</front>
<front id="MarlinSerialCPP-275">    remainder *= 10.0;</front>
<front id="MarlinSerialCPP-276">    int toPrint = int(remainder);</front>
<front id="MarlinSerialCPP-277">    print(toPrint);</front>
<front id="MarlinSerialCPP-278">    remainder -= toPrint; </front>
<front id="MarlinSerialCPP-279">  } </front>
<front id="MarlinSerialCPP-280">}</front>
<front id="MarlinSerialCPP-281">// Preinstantiate Objects //////////////////////////////////////////////////////</front>
<front id="MarlinSerialCPP-282"></front>
<front id="MarlinSerialCPP-283"></front>
<front id="MarlinSerialCPP-284">MarlinSerial customizedSerial;</front>
<front id="MarlinSerialCPP-285"></front>
<front id="MarlinSerialCPP-286">#endif // whole file</front>
<front id="MarlinSerialCPP-287">#endif // !USBCON</front>
<front id="MarlinSerialCPP-288"></front>
<front id="MarlinSerialCPP-289">// For AT90USB targets use the UART for BT interfacing</front>
<front id="MarlinSerialCPP-290">#if defined(USBCON) && ENABLED(BLUETOOTH)</front>
<front id="MarlinSerialCPP-291">  HardwareSerial bluetoothSerial;</front>
<front id="MarlinSerialCPP-292">#endif</front>
 </pre>
<h1 id="MarlinSerialHtitle" >MarlinSerial.h</h1>
<pre id="MarlinSerialH"  class="prettyprint linenums"><front id="MarlinSerialH-1">/*</front>
<front id="MarlinSerialH-2">  HardwareSerial.h - Hardware serial library for Wiring</front>
<front id="MarlinSerialH-3">  Copyright (c) 2006 Nicholas Zambetti.  All right reserved.</front>
<front id="MarlinSerialH-4"></front>
<front id="MarlinSerialH-5">  This library is free software; you can redistribute it and/or</front>
<front id="MarlinSerialH-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="MarlinSerialH-7">  License as published by the Free Software Foundation; either</front>
<front id="MarlinSerialH-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="MarlinSerialH-9"></front>
<front id="MarlinSerialH-10">  This library is distributed in the hope that it will be useful,</front>
<front id="MarlinSerialH-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="MarlinSerialH-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="MarlinSerialH-13">  Lesser General Public License for more details.</front>
<front id="MarlinSerialH-14"></front>
<front id="MarlinSerialH-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="MarlinSerialH-16">  License along with this library; if not, write to the Free Software</front>
<front id="MarlinSerialH-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="MarlinSerialH-18"></front>
<front id="MarlinSerialH-19">  Modified 28 September 2010 by Mark Sproul</front>
<front id="MarlinSerialH-20">*/</front>
<front id="MarlinSerialH-21"></front>
<front id="MarlinSerialH-22">#ifndef MarlinSerial_h</front>
<front id="MarlinSerialH-23">#define MarlinSerial_h</front>
<front id="MarlinSerialH-24">#include "Marlin.h"</front>
<front id="MarlinSerialH-25"></front>
<front id="MarlinSerialH-26">#ifndef SERIAL_PORT</front>
<front id="MarlinSerialH-27">  #define SERIAL_PORT 0</front>
<front id="MarlinSerialH-28">#endif</front>
<front id="MarlinSerialH-29"></front>
<front id="MarlinSerialH-30">// The presence of the UBRRH register is used to detect a UART.</front>
<front id="MarlinSerialH-31">#define UART_PRESENT(port) ((port == 0 && (defined(UBRRH) || defined(UBRR0H))) || \</front>
<front id="MarlinSerialH-32">						(port == 1 && defined(UBRR1H)) || (port == 2 && defined(UBRR2H)) || \</front>
<front id="MarlinSerialH-33">						(port == 3 && defined(UBRR3H)))				</front>
<front id="MarlinSerialH-34">						</front>
<front id="MarlinSerialH-35">// These are macros to build serial port register names for the selected SERIAL_PORT (C preprocessor</front>
<front id="MarlinSerialH-36">// requires two levels of indirection to expand macro values properly)</front>
<front id="MarlinSerialH-37">#define SERIAL_REGNAME(registerbase,number,suffix) SERIAL_REGNAME_INTERNAL(registerbase,number,suffix)</front>
<front id="MarlinSerialH-38">#if SERIAL_PORT == 0 && (!defined(UBRR0H) || !defined(UDR0)) // use un-numbered registers if necessary</front>
<front id="MarlinSerialH-39">  #define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##suffix</front>
<front id="MarlinSerialH-40">#else</front>
<front id="MarlinSerialH-41">  #define SERIAL_REGNAME_INTERNAL(registerbase,number,suffix) registerbase##number##suffix</front>
<front id="MarlinSerialH-42">#endif</front>
<front id="MarlinSerialH-43"></front>
<front id="MarlinSerialH-44">// Registers used by MarlinSerial class (these are expanded </front>
<front id="MarlinSerialH-45">// depending on selected serial port</front>
<front id="MarlinSerialH-46">#define M_UCSRxA SERIAL_REGNAME(UCSR,SERIAL_PORT,A) // defines M_UCSRxA to be UCSRnA where n is the serial port number</front>
<front id="MarlinSerialH-47">#define M_UCSRxB SERIAL_REGNAME(UCSR,SERIAL_PORT,B) </front>
<front id="MarlinSerialH-48">#define M_RXENx SERIAL_REGNAME(RXEN,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-49">#define M_TXENx SERIAL_REGNAME(TXEN,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-50">#define M_RXCIEx SERIAL_REGNAME(RXCIE,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-51">#define M_UDREx SERIAL_REGNAME(UDRE,SERIAL_PORT,)    </front>
<front id="MarlinSerialH-52">#define M_UDRx SERIAL_REGNAME(UDR,SERIAL_PORT,)  </front>
<front id="MarlinSerialH-53">#define M_UBRRxH SERIAL_REGNAME(UBRR,SERIAL_PORT,H)</front>
<front id="MarlinSerialH-54">#define M_UBRRxL SERIAL_REGNAME(UBRR,SERIAL_PORT,L)</front>
<front id="MarlinSerialH-55">#define M_RXCx SERIAL_REGNAME(RXC,SERIAL_PORT,)</front>
<front id="MarlinSerialH-56">#define M_USARTx_RX_vect SERIAL_REGNAME(USART,SERIAL_PORT,_RX_vect)</front>
<front id="MarlinSerialH-57">#define M_U2Xx SERIAL_REGNAME(U2X,SERIAL_PORT,)</front>
<front id="MarlinSerialH-58"></front>
<front id="MarlinSerialH-59"></front>
<front id="MarlinSerialH-60">#define DEC 10</front>
<front id="MarlinSerialH-61">#define HEX 16</front>
<front id="MarlinSerialH-62">#define OCT 8</front>
<front id="MarlinSerialH-63">#define BIN 2</front>
<front id="MarlinSerialH-64">#define BYTE 0</front>
<front id="MarlinSerialH-65"></front>
<front id="MarlinSerialH-66"></front>
<front id="MarlinSerialH-67">#ifndef USBCON</front>
<front id="MarlinSerialH-68">// Define constants and variables for buffering incoming serial data.  We're</front>
<front id="MarlinSerialH-69">// using a ring buffer (I think), in which rx_buffer_head is the index of the</front>
<front id="MarlinSerialH-70">// location to which to write the next incoming character and rx_buffer_tail</front>
<front id="MarlinSerialH-71">// is the index of the location from which to read.</front>
<front id="MarlinSerialH-72">#define RX_BUFFER_SIZE 128</front>
<front id="MarlinSerialH-73"></front>
<front id="MarlinSerialH-74"></front>
<front id="MarlinSerialH-75">struct ring_buffer {</front>
<front id="MarlinSerialH-76">  unsigned char buffer[RX_BUFFER_SIZE];</front>
<front id="MarlinSerialH-77">  int head;</front>
<front id="MarlinSerialH-78">  int tail;</front>
<front id="MarlinSerialH-79">};</front>
<front id="MarlinSerialH-80"></front>
<front id="MarlinSerialH-81">#if UART_PRESENT(SERIAL_PORT)</front>
<front id="MarlinSerialH-82">  extern ring_buffer rx_buffer;</front>
<front id="MarlinSerialH-83">#endif</front>
<front id="MarlinSerialH-84"></front>
<front id="MarlinSerialH-85">class MarlinSerial { //: public Stream</front>
<front id="MarlinSerialH-86"></front>
<front id="MarlinSerialH-87">  public:</front>
<front id="MarlinSerialH-88">    MarlinSerial();</front>
<front id="MarlinSerialH-89">    void begin(long);</front>
<front id="MarlinSerialH-90">    void end();</front>
<front id="MarlinSerialH-91">    int peek(void);</front>
<front id="MarlinSerialH-92">    int read(void);</front>
<front id="MarlinSerialH-93">    void flush(void);</front>
<front id="MarlinSerialH-94"></front>
<front id="MarlinSerialH-95">    FORCE_INLINE int available(void) {</front>
<front id="MarlinSerialH-96">      return (unsigned int)(RX_BUFFER_SIZE + rx_buffer.head - rx_buffer.tail) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialH-97">    }</front>
<front id="MarlinSerialH-98"></front>
<front id="MarlinSerialH-99">    FORCE_INLINE void write(uint8_t c) {</front>
<front id="MarlinSerialH-100">      while (!TEST(M_UCSRxA, M_UDREx))</front>
<front id="MarlinSerialH-101">        ;</front>
<front id="MarlinSerialH-102"></front>
<front id="MarlinSerialH-103">      M_UDRx = c;</front>
<front id="MarlinSerialH-104">    }</front>
<front id="MarlinSerialH-105"></front>
<front id="MarlinSerialH-106">    FORCE_INLINE void checkRx(void) {</front>
<front id="MarlinSerialH-107">      if (TEST(M_UCSRxA, M_RXCx)) {</front>
<front id="MarlinSerialH-108">        unsigned char c  =  M_UDRx;</front>
<front id="MarlinSerialH-109">        int i = (unsigned int)(rx_buffer.head + 1) % RX_BUFFER_SIZE;</front>
<front id="MarlinSerialH-110"></front>
<front id="MarlinSerialH-111">        // if we should be storing the received character into the location</front>
<front id="MarlinSerialH-112">        // just before the tail (meaning that the head would advance to the</front>
<front id="MarlinSerialH-113">        // current location of the tail), we're about to overflow the buffer</front>
<front id="MarlinSerialH-114">        // and so we don't write the character or advance the head.</front>
<front id="MarlinSerialH-115">        if (i != rx_buffer.tail) {</front>
<front id="MarlinSerialH-116">          rx_buffer.buffer[rx_buffer.head] = c;</front>
<front id="MarlinSerialH-117">          rx_buffer.head = i;</front>
<front id="MarlinSerialH-118">        }</front>
<front id="MarlinSerialH-119">      }</front>
<front id="MarlinSerialH-120">    }</front>
<front id="MarlinSerialH-121"></front>
<front id="MarlinSerialH-122">  private:</front>
<front id="MarlinSerialH-123">    void printNumber(unsigned long, uint8_t);</front>
<front id="MarlinSerialH-124">    void printFloat(double, uint8_t);</front>
<front id="MarlinSerialH-125"></front>
<front id="MarlinSerialH-126">  public:</front>
<front id="MarlinSerialH-127">    FORCE_INLINE void write(const char *str) { while (*str) write(*str++); }</front>
<front id="MarlinSerialH-128">    FORCE_INLINE void write(const uint8_t *buffer, size_t size) { while (size--) write(*buffer++); }</front>
<front id="MarlinSerialH-129">    FORCE_INLINE void print(const String &s) { for (int i = 0; i &lt; (int)s.length(); i++) write(s[i]); }</front>
<front id="MarlinSerialH-130">    FORCE_INLINE void print(const char *str) { write(str); }</front>
<front id="MarlinSerialH-131"></front>
<front id="MarlinSerialH-132">    void print(char, int = BYTE);</front>
<front id="MarlinSerialH-133">    void print(unsigned char, int = BYTE);</front>
<front id="MarlinSerialH-134">    void print(int, int = DEC);</front>
<front id="MarlinSerialH-135">    void print(unsigned int, int = DEC);</front>
<front id="MarlinSerialH-136">    void print(long, int = DEC);</front>
<front id="MarlinSerialH-137">    void print(unsigned long, int = DEC);</front>
<front id="MarlinSerialH-138">    void print(double, int = 2);</front>
<front id="MarlinSerialH-139"></front>
<front id="MarlinSerialH-140">    void println(const String &s);</front>
<front id="MarlinSerialH-141">    void println(const char[]);</front>
<front id="MarlinSerialH-142">    void println(char, int = BYTE);</front>
<front id="MarlinSerialH-143">    void println(unsigned char, int = BYTE);</front>
<front id="MarlinSerialH-144">    void println(int, int = DEC);</front>
<front id="MarlinSerialH-145">    void println(unsigned int, int = DEC);</front>
<front id="MarlinSerialH-146">    void println(long, int = DEC);</front>
<front id="MarlinSerialH-147">    void println(unsigned long, int = DEC);</front>
<front id="MarlinSerialH-148">    void println(double, int = 2);</front>
<front id="MarlinSerialH-149">    void println(void);</front>
<front id="MarlinSerialH-150">};</front>
<front id="MarlinSerialH-151"></front>
<front id="MarlinSerialH-152">extern MarlinSerial customizedSerial;</front>
<front id="MarlinSerialH-153">#endif // !USBCON</front>
<front id="MarlinSerialH-154"></front>
<front id="MarlinSerialH-155">// Use the UART for Bluetooth in AT90USB configurations</front>
<front id="MarlinSerialH-156">#if defined(USBCON) && ENABLED(BLUETOOTH)</front>
<front id="MarlinSerialH-157">  extern HardwareSerial bluetoothSerial;</front>
<front id="MarlinSerialH-158">#endif</front>
<front id="MarlinSerialH-159"></front>
<front id="MarlinSerialH-160">#endif</front>
 </pre>
<h1 id="mesh_bed_levelingCPPtitle" >mesh_bed_leveling.cpp</h1>
<pre id="mesh_bed_levelingCPP"  class="prettyprint linenums"><front id="mesh_bed_levelingCPP-1">#include "mesh_bed_leveling.h"</front>
<front id="mesh_bed_levelingCPP-2"></front>
<front id="mesh_bed_levelingCPP-3">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="mesh_bed_levelingCPP-4"></front>
<front id="mesh_bed_levelingCPP-5">  mesh_bed_leveling mbl;</front>
<front id="mesh_bed_levelingCPP-6"></front>
<front id="mesh_bed_levelingCPP-7">  mesh_bed_leveling::mesh_bed_leveling() { reset(); }</front>
<front id="mesh_bed_levelingCPP-8">      </front>
<front id="mesh_bed_levelingCPP-9">  void mesh_bed_leveling::reset() {</front>
<front id="mesh_bed_levelingCPP-10">    active = 0;</front>
<front id="mesh_bed_levelingCPP-11">    for (int y = 0; y &lt; MESH_NUM_Y_POINTS; y++)</front>
<front id="mesh_bed_levelingCPP-12">      for (int x = 0; x &lt; MESH_NUM_X_POINTS; x++)</front>
<front id="mesh_bed_levelingCPP-13">        z_values[y][x] = 0;</front>
<front id="mesh_bed_levelingCPP-14">  }</front>
<front id="mesh_bed_levelingCPP-15"></front>
<front id="mesh_bed_levelingCPP-16">#endif  // MESH_BED_LEVELING</front>
 </pre>
<h1 id="mesh_bed_levelingHtitle" >mesh_bed_leveling.h</h1>
<pre id="mesh_bed_levelingH"  class="prettyprint linenums"><front id="mesh_bed_levelingH-1">#include "Marlin.h"</front>
<front id="mesh_bed_levelingH-2"></front>
<front id="mesh_bed_levelingH-3">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="mesh_bed_levelingH-4"></front>
<front id="mesh_bed_levelingH-5">  #define MESH_X_DIST ((MESH_MAX_X - MESH_MIN_X)/(MESH_NUM_X_POINTS - 1))</front>
<front id="mesh_bed_levelingH-6">  #define MESH_Y_DIST ((MESH_MAX_Y - MESH_MIN_Y)/(MESH_NUM_Y_POINTS - 1))</front>
<front id="mesh_bed_levelingH-7"></front>
<front id="mesh_bed_levelingH-8">  class mesh_bed_leveling {</front>
<front id="mesh_bed_levelingH-9">  public:</front>
<front id="mesh_bed_levelingH-10">    uint8_t active;</front>
<front id="mesh_bed_levelingH-11">    float z_values[MESH_NUM_Y_POINTS][MESH_NUM_X_POINTS];</front>
<front id="mesh_bed_levelingH-12">    </front>
<front id="mesh_bed_levelingH-13">    mesh_bed_leveling();</front>
<front id="mesh_bed_levelingH-14">    </front>
<front id="mesh_bed_levelingH-15">    void reset();</front>
<front id="mesh_bed_levelingH-16">    </front>
<front id="mesh_bed_levelingH-17">    float get_x(int i) { return MESH_MIN_X + MESH_X_DIST * i; }</front>
<front id="mesh_bed_levelingH-18">    float get_y(int i) { return MESH_MIN_Y + MESH_Y_DIST * i; }</front>
<front id="mesh_bed_levelingH-19">    void set_z(int ix, int iy, float z) { z_values[iy][ix] = z; }</front>
<front id="mesh_bed_levelingH-20">    </front>
<front id="mesh_bed_levelingH-21">    int select_x_index(float x) {</front>
<front id="mesh_bed_levelingH-22">      int i = 1;</front>
<front id="mesh_bed_levelingH-23">      while (x &gt; get_x(i) && i &lt; MESH_NUM_X_POINTS-1) i++;</front>
<front id="mesh_bed_levelingH-24">      return i - 1;</front>
<front id="mesh_bed_levelingH-25">    }</front>
<front id="mesh_bed_levelingH-26">    </front>
<front id="mesh_bed_levelingH-27">    int select_y_index(float y) {</front>
<front id="mesh_bed_levelingH-28">      int i = 1;</front>
<front id="mesh_bed_levelingH-29">      while (y &gt; get_y(i) && i &lt; MESH_NUM_Y_POINTS - 1) i++;</front>
<front id="mesh_bed_levelingH-30">      return i - 1;</front>
<front id="mesh_bed_levelingH-31">    }</front>
<front id="mesh_bed_levelingH-32">    </front>
<front id="mesh_bed_levelingH-33">    float calc_z0(float a0, float a1, float z1, float a2, float z2) {</front>
<front id="mesh_bed_levelingH-34">      float delta_z = (z2 - z1)/(a2 - a1);</front>
<front id="mesh_bed_levelingH-35">      float delta_a = a0 - a1;</front>
<front id="mesh_bed_levelingH-36">      return z1 + delta_a * delta_z;</front>
<front id="mesh_bed_levelingH-37">    }</front>
<front id="mesh_bed_levelingH-38">    </front>
<front id="mesh_bed_levelingH-39">    float get_z(float x0, float y0) {</front>
<front id="mesh_bed_levelingH-40">      int x_index = select_x_index(x0);</front>
<front id="mesh_bed_levelingH-41">      int y_index = select_y_index(y0);</front>
<front id="mesh_bed_levelingH-42">      float z1 = calc_z0(x0,</front>
<front id="mesh_bed_levelingH-43">                         get_x(x_index), z_values[y_index][x_index],</front>
<front id="mesh_bed_levelingH-44">                         get_x(x_index+1), z_values[y_index][x_index+1]);</front>
<front id="mesh_bed_levelingH-45">      float z2 = calc_z0(x0,</front>
<front id="mesh_bed_levelingH-46">                         get_x(x_index), z_values[y_index+1][x_index],</front>
<front id="mesh_bed_levelingH-47">                         get_x(x_index+1), z_values[y_index+1][x_index+1]);</front>
<front id="mesh_bed_levelingH-48">      float z0 = calc_z0(y0,</front>
<front id="mesh_bed_levelingH-49">                         get_y(y_index), z1,</front>
<front id="mesh_bed_levelingH-50">                         get_y(y_index+1), z2);</front>
<front id="mesh_bed_levelingH-51">      return z0;</front>
<front id="mesh_bed_levelingH-52">    }</front>
<front id="mesh_bed_levelingH-53">  };</front>
<front id="mesh_bed_levelingH-54"></front>
<front id="mesh_bed_levelingH-55">  extern mesh_bed_leveling mbl;</front>
<front id="mesh_bed_levelingH-56"></front>
<front id="mesh_bed_levelingH-57">#endif  // MESH_BED_LEVELING</front>
 </pre>
<h1 id="pinsHtitle" >pins.h</h1>
<pre id="pinsH"  class="prettyprint linenums"><front id="pinsH-1">/**</front>
<front id="pinsH-2"> * pins.h</front>
<front id="pinsH-3"> */</front>
<front id="pinsH-4"></front>
<front id="pinsH-5">#ifndef PINS_H</front>
<front id="pinsH-6">#define PINS_H</front>
<front id="pinsH-7"></front>
<front id="pinsH-8">// Preset optional pins</front>
<front id="pinsH-9">#define X_MS1_PIN -1</front>
<front id="pinsH-10">#define X_MS2_PIN -1</front>
<front id="pinsH-11">#define Y_MS1_PIN -1</front>
<front id="pinsH-12">#define Y_MS2_PIN -1</front>
<front id="pinsH-13">#define Z_MS1_PIN -1</front>
<front id="pinsH-14">#define Z_MS2_PIN -1</front>
<front id="pinsH-15">#define E0_MS1_PIN -1</front>
<front id="pinsH-16">#define E0_MS2_PIN -1</front>
<front id="pinsH-17">#define E1_MS1_PIN -1</front>
<front id="pinsH-18">#define E1_MS2_PIN -1</front>
<front id="pinsH-19">#define DIGIPOTSS_PIN -1</front>
<front id="pinsH-20">#define HEATER_3_PIN -1</front>
<front id="pinsH-21">#define TEMP_3_PIN -1</front>
<front id="pinsH-22"></front>
<front id="pinsH-23">#if MB(GEN7_CUSTOM)</front>
<front id="pinsH-24">  #include "pins_GEN7_CUSTOM.h"</front>
<front id="pinsH-25">#elif MB(GEN7_12)</front>
<front id="pinsH-26">  #include "pins_GEN7_12.h"</front>
<front id="pinsH-27">#elif MB(GEN7_13)</front>
<front id="pinsH-28">  #include "pins_GEN7_13.h"</front>
<front id="pinsH-29">#elif MB(GEN7_14)</front>
<front id="pinsH-30">  #include "pins_GEN7_14.h"</front>
<front id="pinsH-31">#elif MB(CHEAPTRONIC)</front>
<front id="pinsH-32">  #include "pins_CHEAPTRONIC.h"</front>
<front id="pinsH-33">#elif MB(SETHI)</front>
<front id="pinsH-34">  #include "pins_SETHI.h"</front>
<front id="pinsH-35">#elif MB(RAMPS_OLD)</front>
<front id="pinsH-36">  #include "pins_RAMPS_OLD.h"</front>
<front id="pinsH-37">#elif MB(RAMPS_13_EFB)</front>
<front id="pinsH-38">  #include "pins_RAMPS_13_EFB.h"</front>
<front id="pinsH-39">#elif MB(RAMPS_13_EEB) || MB(RAMPS_13_EFF) || MB(RAMPS_13_EEF) || MB(RAMPS_13_SF)</front>
<front id="pinsH-40">  #include "pins_RAMPS_13.h"</front>
<front id="pinsH-41">#elif MB(GEN6)</front>
<front id="pinsH-42">  #include "pins_GEN6.h"</front>
<front id="pinsH-43">#elif MB(GEN6_DELUXE)</front>
<front id="pinsH-44">  #include "pins_GEN6_DELUXE.h"</front>
<front id="pinsH-45">#elif MB(SANGUINOLOLU_11)</front>
<front id="pinsH-46">  #include "pins_SANGUINOLOLU_11.h"</front>
<front id="pinsH-47">#elif MB(SANGUINOLOLU_12)</front>
<front id="pinsH-48">  #include "pins_SANGUINOLOLU_12.h"</front>
<front id="pinsH-49">#elif MB(MELZI)</front>
<front id="pinsH-50">  #include "pins_MELZI.h"</front>
<front id="pinsH-51">#elif MB(STB_11)</front>
<front id="pinsH-52">  #include "pins_STB_11.h"</front>
<front id="pinsH-53">#elif MB(AZTEEG_X1)</front>
<front id="pinsH-54">  #include "pins_AZTEEG_X1.h"</front>
<front id="pinsH-55">#elif MB(MELZI_MAKR3D)</front>
<front id="pinsH-56">  #include "pins_MELZI_MAKR3D.h"</front>
<front id="pinsH-57">#elif MB(AZTEEG_X3)</front>
<front id="pinsH-58">  #include "pins_AZTEEG_X3.h"</front>
<front id="pinsH-59">#elif MB(AZTEEG_X3_PRO)</front>
<front id="pinsH-60">  #include "pins_AZTEEG_X3_PRO.h"</front>
<front id="pinsH-61">#elif MB(ULTIMAKER)</front>
<front id="pinsH-62">  #include "pins_ULTIMAKER.h"</front>
<front id="pinsH-63">#elif MB(ULTIMAKER_OLD)</front>
<front id="pinsH-64">  #include "pins_ULTIMAKER_OLD.h"</front>
<front id="pinsH-65">#elif MB(ULTIMAIN_2)</front>
<front id="pinsH-66">  #include "pins_ULTIMAIN_2.h"</front>
<front id="pinsH-67">#elif MB(3DRAG)</front>
<front id="pinsH-68">  #include "pins_3DRAG.h"</front>
<front id="pinsH-69">#elif MB(K8200)</front>
<front id="pinsH-70">  #include "pins_K8200.h"</front>
<front id="pinsH-71">#elif MB(TEENSYLU)</front>
<front id="pinsH-72">  #include "pins_TEENSYLU.h"</front>
<front id="pinsH-73">#elif MB(RUMBA)</front>
<front id="pinsH-74">  #include "pins_RUMBA.h"</front>
<front id="pinsH-75">#elif MB(PRINTRBOARD)</front>
<front id="pinsH-76">  #include "pins_PRINTRBOARD.h"</front>
<front id="pinsH-77">#elif MB(BRAINWAVE)</front>
<front id="pinsH-78">  #include "pins_BRAINWAVE.h"</front>
<front id="pinsH-79">#elif MB(BRAINWAVE_PRO)</front>
<front id="pinsH-80">  #include "pins_BRAINWAVE_PRO.h"</front>
<front id="pinsH-81">#elif MB(SAV_MKI)</front>
<front id="pinsH-82">  #include "pins_SAV_MKI.h"</front>
<front id="pinsH-83">#elif MB(TEENSY2)</front>
<front id="pinsH-84">  #include "pins_TEENSY2.h"</front>
<front id="pinsH-85">#elif MB(GEN3_PLUS)</front>
<front id="pinsH-86">  #include "pins_GEN3_PLUS.h"</front>
<front id="pinsH-87">#elif MB(GEN3_MONOLITHIC)</front>
<front id="pinsH-88">  #include "pins_GEN3_MONOLITHIC.h"</front>
<front id="pinsH-89">#elif MB(MEGATRONICS)</front>
<front id="pinsH-90">  #include "pins_MEGATRONICS.h"</front>
<front id="pinsH-91">#elif MB(MINITRONICS)</front>
<front id="pinsH-92">  #include "pins_MINITRONICS.h"</front>
<front id="pinsH-93">#elif MB(MEGATRONICS_2)</front>
<front id="pinsH-94">  #include "pins_MEGATRONICS_2.h"</front>
<front id="pinsH-95">#elif MB(MEGATRONICS_3)</front>
<front id="pinsH-96">  #include "pins_MEGATRONICS_3.h"</front>
<front id="pinsH-97">#elif MB(OMCA_A)</front>
<front id="pinsH-98">  #include "pins_OMCA_A.h"</front>
<front id="pinsH-99">#elif MB(OMCA)</front>
<front id="pinsH-100">  #include "pins_OMCA.h"</front>
<front id="pinsH-101">#elif MB(RAMBO)</front>
<front id="pinsH-102">  #include "pins_RAMBO.h"</front>
<front id="pinsH-103">#elif MB(MINIRAMBO)</front>
<front id="pinsH-104">  #include "pins_MINIRAMBO.h"</front>
<front id="pinsH-105">#elif MB(ELEFU_3)</front>
<front id="pinsH-106">  #include "pins_ELEFU_3.h"</front>
<front id="pinsH-107">#elif MB(5DPRINT)</front>
<front id="pinsH-108">  #include "pins_5DPRINT.h"</front>
<front id="pinsH-109">#elif MB(LEAPFROG)</front>
<front id="pinsH-110">  #include "pins_LEAPFROG.h"</front>
<front id="pinsH-111">#elif MB(BAM_DICE)</front>
<front id="pinsH-112">  #include "pins_RAMPS_13.h"</front>
<front id="pinsH-113">#elif MB(BAM_DICE_DUE)</front>
<front id="pinsH-114">  #include "pins_BAM_DICE_DUE.h"</front>
<front id="pinsH-115">#elif MB(FELIX2)</front>
<front id="pinsH-116">  #include "pins_FELIX2.h"</front>
<front id="pinsH-117">#elif MB(MKS_BASE)</front>
<front id="pinsH-118">  #include "pins_MKS_BASE.h"</front>
<front id="pinsH-119">#elif MB(RIGIDBOARD)</front>
<front id="pinsH-120">  #include "pins_RIGIDBOARD.h"</front>
<front id="pinsH-121">#elif MB(MEGACONTROLLER)</front>
<front id="pinsH-122">  #include "pins_MEGACONTROLLER.h"</front>
<front id="pinsH-123">#elif MB(99)</front>
<front id="pinsH-124">  #include "pins_99.h"</front>
<front id="pinsH-125">#else</front>
<front id="pinsH-126">  #error Unknown MOTHERBOARD value set in Configuration.h</front>
<front id="pinsH-127">#endif</front>
<front id="pinsH-128"></front>
<front id="pinsH-129">// List of pins which to ignore when asked to change by gcode, 0 and 1 are RX and TX, do not mess with those!</front>
<front id="pinsH-130">#define _E0_PINS E0_STEP_PIN, E0_DIR_PIN, E0_ENABLE_PIN, HEATER_0_PIN, analogInputToDigitalPin(TEMP_0_PIN),</front>
<front id="pinsH-131">#define _E1_PINS</front>
<front id="pinsH-132">#define _E2_PINS</front>
<front id="pinsH-133">#define _E3_PINS</front>
<front id="pinsH-134"></front>
<front id="pinsH-135">#if EXTRUDERS &gt; 1</front>
<front id="pinsH-136">  #undef _E1_PINS</front>
<front id="pinsH-137">  #define _E1_PINS E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN, HEATER_1_PIN, analogInputToDigitalPin(TEMP_1_PIN),</front>
<front id="pinsH-138">  #if EXTRUDERS &gt; 2</front>
<front id="pinsH-139">    #undef _E2_PINS</front>
<front id="pinsH-140">    #define _E2_PINS E2_STEP_PIN, E2_DIR_PIN, E2_ENABLE_PIN, HEATER_2_PIN, analogInputToDigitalPin(TEMP_2_PIN),</front>
<front id="pinsH-141">    #if EXTRUDERS &gt; 3</front>
<front id="pinsH-142">      #undef _E3_PINS</front>
<front id="pinsH-143">      #define _E3_PINS E3_STEP_PIN, E3_DIR_PIN, E3_ENABLE_PIN, HEATER_3_PIN, analogInputToDigitalPin(TEMP_3_PIN),</front>
<front id="pinsH-144">    #endif</front>
<front id="pinsH-145">  #endif</front>
<front id="pinsH-146">#elif ENABLED(Y_DUAL_STEPPER_DRIVERS) || ENABLED(Z_DUAL_STEPPER_DRIVERS)</front>
<front id="pinsH-147">  #undef _E1_PINS</front>
<front id="pinsH-148">  #define _E1_PINS E1_STEP_PIN, E1_DIR_PIN, E1_ENABLE_PIN,</front>
<front id="pinsH-149">#endif</front>
<front id="pinsH-150"></front>
<front id="pinsH-151">#ifdef X_STOP_PIN</front>
<front id="pinsH-152">  #if X_HOME_DIR &lt; 0</front>
<front id="pinsH-153">    #define X_MIN_PIN X_STOP_PIN</front>
<front id="pinsH-154">    #define X_MAX_PIN -1</front>
<front id="pinsH-155">  #else</front>
<front id="pinsH-156">    #define X_MIN_PIN -1</front>
<front id="pinsH-157">    #define X_MAX_PIN X_STOP_PIN</front>
<front id="pinsH-158">  #endif</front>
<front id="pinsH-159">#endif</front>
<front id="pinsH-160"></front>
<front id="pinsH-161">#ifdef Y_STOP_PIN</front>
<front id="pinsH-162">  #if Y_HOME_DIR &lt; 0</front>
<front id="pinsH-163">    #define Y_MIN_PIN Y_STOP_PIN</front>
<front id="pinsH-164">    #define Y_MAX_PIN -1</front>
<front id="pinsH-165">  #else</front>
<front id="pinsH-166">    #define Y_MIN_PIN -1</front>
<front id="pinsH-167">    #define Y_MAX_PIN Y_STOP_PIN</front>
<front id="pinsH-168">  #endif</front>
<front id="pinsH-169">#endif</front>
<front id="pinsH-170"></front>
<front id="pinsH-171">#ifdef Z_STOP_PIN</front>
<front id="pinsH-172">  #if Z_HOME_DIR &lt; 0</front>
<front id="pinsH-173">    #define Z_MIN_PIN Z_STOP_PIN</front>
<front id="pinsH-174">    #define Z_MAX_PIN -1</front>
<front id="pinsH-175">  #else</front>
<front id="pinsH-176">    #define Z_MIN_PIN -1</front>
<front id="pinsH-177">    #define Z_MAX_PIN Z_STOP_PIN</front>
<front id="pinsH-178">  #endif</front>
<front id="pinsH-179">#endif</front>
<front id="pinsH-180"></front>
<front id="pinsH-181">#if ENABLED(DISABLE_MAX_ENDSTOPS)</front>
<front id="pinsH-182">  #undef X_MAX_PIN</front>
<front id="pinsH-183">  #undef Y_MAX_PIN</front>
<front id="pinsH-184">  #undef Z_MAX_PIN</front>
<front id="pinsH-185">  #define X_MAX_PIN          -1</front>
<front id="pinsH-186">  #define Y_MAX_PIN          -1</front>
<front id="pinsH-187">  #define Z_MAX_PIN          -1</front>
<front id="pinsH-188">#endif</front>
<front id="pinsH-189"></front>
<front id="pinsH-190">#if ENABLED(DISABLE_MIN_ENDSTOPS)</front>
<front id="pinsH-191">  #undef X_MIN_PIN</front>
<front id="pinsH-192">  #undef Y_MIN_PIN</front>
<front id="pinsH-193">  #undef Z_MIN_PIN</front>
<front id="pinsH-194">  #define X_MIN_PIN          -1</front>
<front id="pinsH-195">  #define Y_MIN_PIN          -1</front>
<front id="pinsH-196">  #define Z_MIN_PIN          -1</front>
<front id="pinsH-197">#endif</front>
<front id="pinsH-198"></front>
<front id="pinsH-199">#if ENABLED(DISABLE_Z_MIN_PROBE_ENDSTOP) || DISABLED(Z_MIN_PROBE_ENDSTOP) // Allow code to compile regardless of Z_MIN_PROBE_ENDSTOP setting.</front>
<front id="pinsH-200">  #undef Z_MIN_PROBE_PIN</front>
<front id="pinsH-201">  #define Z_MIN_PROBE_PIN    -1</front>
<front id="pinsH-202">#endif</front>
<front id="pinsH-203"></front>
<front id="pinsH-204">#if ENABLED(DISABLE_XMAX_ENDSTOP)</front>
<front id="pinsH-205">  #undef X_MAX_PIN</front>
<front id="pinsH-206">  #define X_MAX_PIN          -1</front>
<front id="pinsH-207">#endif</front>
<front id="pinsH-208"></front>
<front id="pinsH-209">#if ENABLED(DISABLE_XMIN_ENDSTOP)</front>
<front id="pinsH-210">  #undef X_MIN_PIN </front>
<front id="pinsH-211">  #define X_MIN_PIN          -1</front>
<front id="pinsH-212">#endif</front>
<front id="pinsH-213"></front>
<front id="pinsH-214">#if ENABLED(DISABLE_YMAX_ENDSTOP)</front>
<front id="pinsH-215">  #define Y_MAX_PIN          -1</front>
<front id="pinsH-216">#endif</front>
<front id="pinsH-217"></front>
<front id="pinsH-218">#if ENABLED(DISABLE_YMIN_ENDSTOP)</front>
<front id="pinsH-219">  #undef Y_MIN_PIN</front>
<front id="pinsH-220">  #define Y_MIN_PIN          -1</front>
<front id="pinsH-221">#endif</front>
<front id="pinsH-222"></front>
<front id="pinsH-223">#if ENABLED(DISABLE_ZMAX_ENDSTOP)</front>
<front id="pinsH-224">  #undef Z_MAX_PIN</front>
<front id="pinsH-225">  #define Z_MAX_PIN          -1</front>
<front id="pinsH-226">#endif</front>
<front id="pinsH-227"></front>
<front id="pinsH-228">#if ENABLED(DISABLE_ZMIN_ENDSTOP)</front>
<front id="pinsH-229">  #undef Z_MIN_PIN </front>
<front id="pinsH-230">  #define Z_MIN_PIN          -1</front>
<front id="pinsH-231">#endif</front>
<front id="pinsH-232"></front>
<front id="pinsH-233">#ifndef Y2_STEP_PIN</front>
<front id="pinsH-234">  #define Y2_STEP_PIN      E1_STEP_PIN</front>
<front id="pinsH-235">  #define Y2_DIR_PIN       E1_DIR_PIN</front>
<front id="pinsH-236">  #define Y2_ENABLE_PIN    E1_ENABLE_PIN</front>
<front id="pinsH-237">#endif</front>
<front id="pinsH-238"></front>
<front id="pinsH-239">#ifndef Z2_STEP_PIN</front>
<front id="pinsH-240">  #define Z2_STEP_PIN      E1_STEP_PIN</front>
<front id="pinsH-241">  #define Z2_DIR_PIN       E1_DIR_PIN</front>
<front id="pinsH-242">  #define Z2_ENABLE_PIN    E1_ENABLE_PIN</front>
<front id="pinsH-243">#endif</front>
<front id="pinsH-244"></front>
<front id="pinsH-245">#define SENSITIVE_PINS { 0, 1, \</front>
<front id="pinsH-246">                        X_STEP_PIN, X_DIR_PIN, X_ENABLE_PIN, X_MIN_PIN, X_MAX_PIN, \</front>
<front id="pinsH-247">                        Y_STEP_PIN, Y_DIR_PIN, Y_ENABLE_PIN, Y_MIN_PIN, Y_MAX_PIN, \</front>
<front id="pinsH-248">                        Z_STEP_PIN, Z_DIR_PIN, Z_ENABLE_PIN, Z_MIN_PIN, Z_MAX_PIN, Z_MIN_PROBE_PIN, \</front>
<front id="pinsH-249">                        PS_ON_PIN, HEATER_BED_PIN, FAN_PIN, \</front>
<front id="pinsH-250">                        _E0_PINS _E1_PINS _E2_PINS _E3_PINS \</front>
<front id="pinsH-251">                        analogInputToDigitalPin(TEMP_BED_PIN) \</front>
<front id="pinsH-252">                       }</front>
<front id="pinsH-253"></front>
<front id="pinsH-254">#define HAS_DIGIPOTSS (DIGIPOTSS_PIN &gt;= 0)</front>
<front id="pinsH-255"></front>
<front id="pinsH-256">#endif //__PINS_H</front>
<front id="pinsH-257"></front>
 </pre>
<h1 id="pins_3DRAGHtitle" >pins_3DRAG.h</h1>
<pre id="pins_3DRAGH"  class="prettyprint linenums"><front id="pins_3DRAGH-1">/**</front>
<front id="pins_3DRAGH-2"> * 3DRAG (and K8200) Arduino Mega with RAMPS v1.3 pin assignments</front>
<front id="pins_3DRAGH-3"> */</front>
<front id="pins_3DRAGH-4"></front>
<front id="pins_3DRAGH-5">#include "pins_RAMPS_13.h"</front>
<front id="pins_3DRAGH-6"></front>
<front id="pins_3DRAGH-7">#undef Z_ENABLE_PIN</front>
<front id="pins_3DRAGH-8">#define Z_ENABLE_PIN       63</front>
<front id="pins_3DRAGH-9"></front>
<front id="pins_3DRAGH-10">#undef X_MAX_PIN</front>
<front id="pins_3DRAGH-11">#undef Y_MAX_PIN</front>
<front id="pins_3DRAGH-12">#undef Z_MAX_PIN</front>
<front id="pins_3DRAGH-13">#define X_MAX_PIN          2</front>
<front id="pins_3DRAGH-14">#define Y_MAX_PIN          15</front>
<front id="pins_3DRAGH-15">#define Z_MAX_PIN          -1</front>
<front id="pins_3DRAGH-16"></front>
<front id="pins_3DRAGH-17">#undef SDSS</front>
<front id="pins_3DRAGH-18">#define SDSS               25//53</front>
<front id="pins_3DRAGH-19"></front>
<front id="pins_3DRAGH-20">#undef FAN_PIN</front>
<front id="pins_3DRAGH-21">#define FAN_PIN            8</front>
<front id="pins_3DRAGH-22"></front>
<front id="pins_3DRAGH-23">#undef HEATER_1_PIN</front>
<front id="pins_3DRAGH-24">#undef HEATER_2_PIN</front>
<front id="pins_3DRAGH-25">#undef HEATER_BED_PIN</front>
<front id="pins_3DRAGH-26">#define HEATER_0_PIN       10</front>
<front id="pins_3DRAGH-27">#define HEATER_1_PIN       12</front>
<front id="pins_3DRAGH-28">#define HEATER_2_PIN       6</front>
<front id="pins_3DRAGH-29"></front>
<front id="pins_3DRAGH-30">#define HEATER_BED_PIN     9    // BED</front>
<front id="pins_3DRAGH-31"></front>
<front id="pins_3DRAGH-32">#if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)</front>
<front id="pins_3DRAGH-33">  #undef BEEPER_PIN</front>
<front id="pins_3DRAGH-34">  #define BEEPER_PIN -1</front>
<front id="pins_3DRAGH-35"></front>
<front id="pins_3DRAGH-36">  #undef LCD_PINS_RS</front>
<front id="pins_3DRAGH-37">  #undef LCD_PINS_ENABLE</front>
<front id="pins_3DRAGH-38">  #undef LCD_PINS_D4</front>
<front id="pins_3DRAGH-39">  #undef LCD_PINS_D5</front>
<front id="pins_3DRAGH-40">  #undef LCD_PINS_D6</front>
<front id="pins_3DRAGH-41">  #undef LCD_PINS_D7</front>
<front id="pins_3DRAGH-42">  #define LCD_PINS_RS 27</front>
<front id="pins_3DRAGH-43">  #define LCD_PINS_ENABLE 29</front>
<front id="pins_3DRAGH-44">  #define LCD_PINS_D4 37</front>
<front id="pins_3DRAGH-45">  #define LCD_PINS_D5 35</front>
<front id="pins_3DRAGH-46">  #define LCD_PINS_D6 33</front>
<front id="pins_3DRAGH-47">  #define LCD_PINS_D7 31</front>
<front id="pins_3DRAGH-48"></front>
<front id="pins_3DRAGH-49">  // Buttons</front>
<front id="pins_3DRAGH-50">  #undef BTN_EN1</front>
<front id="pins_3DRAGH-51">  #undef BTN_EN2</front>
<front id="pins_3DRAGH-52">  #undef BTN_ENC</front>
<front id="pins_3DRAGH-53">  #define BTN_EN1 16</front>
<front id="pins_3DRAGH-54">  #define BTN_EN2 17</front>
<front id="pins_3DRAGH-55">  #define BTN_ENC 23 //the click</front>
<front id="pins_3DRAGH-56"></front>
<front id="pins_3DRAGH-57">#else</front>
<front id="pins_3DRAGH-58"></front>
<front id="pins_3DRAGH-59">  #define BEEPER_PIN 33</front>
<front id="pins_3DRAGH-60"></front>
<front id="pins_3DRAGH-61">#endif // ULTRA_LCD && NEWPANEL</front>
 </pre>
<h1 id="pins_5DPRINTHtitle" >pins_5DPRINT.h</h1>
<pre id="pins_5DPRINTH"  class="prettyprint linenums"><front id="pins_5DPRINTH-1">/**</front>
<front id="pins_5DPRINTH-2"> * 5DPrint D8 Driver board pin assignments</front>
<front id="pins_5DPRINTH-3"> *</front>
<front id="pins_5DPRINTH-4"> * https://bitbucket.org/makible/5dprint-d8-controller-board</front>
<front id="pins_5DPRINTH-5"> */</front>
<front id="pins_5DPRINTH-6"></front>
<front id="pins_5DPRINTH-7">#ifndef __AVR_AT90USB1286__</front>
<front id="pins_5DPRINTH-8">  #error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_5DPRINTH-9">#endif</front>
<front id="pins_5DPRINTH-10"></front>
<front id="pins_5DPRINTH-11">#define LARGE_FLASH        true</front>
<front id="pins_5DPRINTH-12"></front>
<front id="pins_5DPRINTH-13">#define X_STEP_PIN          0</front>
<front id="pins_5DPRINTH-14">#define X_DIR_PIN           1</front>
<front id="pins_5DPRINTH-15">#define X_ENABLE_PIN       23</front>
<front id="pins_5DPRINTH-16">#define X_STOP_PIN         37</front>
<front id="pins_5DPRINTH-17"></front>
<front id="pins_5DPRINTH-18">#define Y_STEP_PIN          2</front>
<front id="pins_5DPRINTH-19">#define Y_DIR_PIN           3</front>
<front id="pins_5DPRINTH-20">#define Y_ENABLE_PIN       19</front>
<front id="pins_5DPRINTH-21">#define Y_STOP_PIN         36</front>
<front id="pins_5DPRINTH-22"></front>
<front id="pins_5DPRINTH-23">#define Z_STEP_PIN          4</front>
<front id="pins_5DPRINTH-24">#define Z_DIR_PIN           5</front>
<front id="pins_5DPRINTH-25">#define Z_ENABLE_PIN       18</front>
<front id="pins_5DPRINTH-26">#define Z_STOP_PIN         39</front>
<front id="pins_5DPRINTH-27"></front>
<front id="pins_5DPRINTH-28">#define E0_STEP_PIN         6</front>
<front id="pins_5DPRINTH-29">#define E0_DIR_PIN          7</front>
<front id="pins_5DPRINTH-30">#define E0_ENABLE_PIN      17</front>
<front id="pins_5DPRINTH-31"></front>
<front id="pins_5DPRINTH-32">#define HEATER_0_PIN       21  // Extruder</front>
<front id="pins_5DPRINTH-33">#define HEATER_1_PIN       -1</front>
<front id="pins_5DPRINTH-34">#define HEATER_2_PIN       -1</front>
<front id="pins_5DPRINTH-35">#define HEATER_BED_PIN     20  // Bed</front>
<front id="pins_5DPRINTH-36">// You may need to change FAN_PIN to 16 because Marlin isn't using fastio.h</front>
<front id="pins_5DPRINTH-37">// for the fan and Teensyduino uses a different pin mapping.</front>
<front id="pins_5DPRINTH-38">#define FAN_PIN            16  // Fan</front>
<front id="pins_5DPRINTH-39"></front>
<front id="pins_5DPRINTH-40">#define TEMP_0_PIN          1  // Extruder / Analog pin numbering</front>
<front id="pins_5DPRINTH-41">#define TEMP_BED_PIN        0  // Bed / Analog pin numbering</front>
<front id="pins_5DPRINTH-42"></front>
<front id="pins_5DPRINTH-43">#define TEMP_1_PIN         -1</front>
<front id="pins_5DPRINTH-44">#define TEMP_2_PIN         -1</front>
<front id="pins_5DPRINTH-45"></front>
<front id="pins_5DPRINTH-46">#define SDPOWER            -1</front>
<front id="pins_5DPRINTH-47">#define LED_PIN            -1</front>
<front id="pins_5DPRINTH-48">#define PS_ON_PIN          -1</front>
<front id="pins_5DPRINTH-49">#define KILL_PIN           -1</front>
<front id="pins_5DPRINTH-50">#define ALARM_PIN          -1</front>
<front id="pins_5DPRINTH-51"></front>
<front id="pins_5DPRINTH-52">// The SDSS pin uses a different pin mapping from file Sd2PinMap.h</front>
<front id="pins_5DPRINTH-53">#define SDSS               20</front>
<front id="pins_5DPRINTH-54"></front>
<front id="pins_5DPRINTH-55">#if DISABLED(SDSUPPORT)</front>
<front id="pins_5DPRINTH-56">// these pins are defined in the SD library if building with SD support</front>
<front id="pins_5DPRINTH-57">  #define SCK_PIN           9</front>
<front id="pins_5DPRINTH-58">  #define MISO_PIN         11</front>
<front id="pins_5DPRINTH-59">  #define MOSI_PIN         10</front>
<front id="pins_5DPRINTH-60">#endif</front>
<front id="pins_5DPRINTH-61"></front>
<front id="pins_5DPRINTH-62">// Microstepping pins</front>
<front id="pins_5DPRINTH-63">// Note that the pin mapping is not from fastio.h</front>
<front id="pins_5DPRINTH-64">// See Sd2PinMap.h for the pin configurations</front>
<front id="pins_5DPRINTH-65"></front>
<front id="pins_5DPRINTH-66">#undef X_MS1_PIN</front>
<front id="pins_5DPRINTH-67">#undef X_MS2_PIN</front>
<front id="pins_5DPRINTH-68">#undef Y_MS1_PIN</front>
<front id="pins_5DPRINTH-69">#undef Y_MS2_PIN</front>
<front id="pins_5DPRINTH-70">#undef Z_MS1_PIN</front>
<front id="pins_5DPRINTH-71">#undef Z_MS2_PIN</front>
<front id="pins_5DPRINTH-72">#undef E0_MS1_PIN</front>
<front id="pins_5DPRINTH-73">#undef E0_MS2_PIN</front>
<front id="pins_5DPRINTH-74">#define X_MS1_PIN 25</front>
<front id="pins_5DPRINTH-75">#define X_MS2_PIN 26</front>
<front id="pins_5DPRINTH-76">#define Y_MS1_PIN 9</front>
<front id="pins_5DPRINTH-77">#define Y_MS2_PIN 8</front>
<front id="pins_5DPRINTH-78">#define Z_MS1_PIN 7</front>
<front id="pins_5DPRINTH-79">#define Z_MS2_PIN 6</front>
<front id="pins_5DPRINTH-80">#define E0_MS1_PIN 5</front>
<front id="pins_5DPRINTH-81">#define E0_MS2_PIN 4</front>
<front id="pins_5DPRINTH-82"></front>
 </pre>
<h1 id="pins_99Htitle" >pins_99.h</h1>
<pre id="pins_99H"  class="prettyprint linenums"><front id="pins_99H-1">/**</front>
<front id="pins_99H-2"> * Board 99 pin assignments</front>
<front id="pins_99H-3"> */</front>
<front id="pins_99H-4"></front>
<front id="pins_99H-5">#define X_STEP_PIN          2</front>
<front id="pins_99H-6">#define X_DIR_PIN           3</front>
<front id="pins_99H-7">#define X_ENABLE_PIN        -1</front>
<front id="pins_99H-8">#define X_STOP_PIN          16</front>
<front id="pins_99H-9"></front>
<front id="pins_99H-10">#define Y_STEP_PIN          5</front>
<front id="pins_99H-11">#define Y_DIR_PIN           6</front>
<front id="pins_99H-12">#define Y_ENABLE_PIN       -1</front>
<front id="pins_99H-13">#define Y_STOP_PIN          67</front>
<front id="pins_99H-14"></front>
<front id="pins_99H-15">#define Z_STEP_PIN          62</front>
<front id="pins_99H-16">#define Z_DIR_PIN           63</front>
<front id="pins_99H-17">#define Z_ENABLE_PIN       -1</front>
<front id="pins_99H-18">#define Z_STOP_PIN          59</front>
<front id="pins_99H-19"></front>
<front id="pins_99H-20">#define E0_STEP_PIN         65</front>
<front id="pins_99H-21">#define E0_DIR_PIN          66</front>
<front id="pins_99H-22">#define E0_ENABLE_PIN      -1</front>
<front id="pins_99H-23"></front>
<front id="pins_99H-24">#define SDPOWER            -1</front>
<front id="pins_99H-25">#define SDSS               53</front>
<front id="pins_99H-26">#define LED_PIN            -1</front>
<front id="pins_99H-27">#define FAN_PIN            -1</front>
<front id="pins_99H-28">#define PS_ON_PIN           9</front>
<front id="pins_99H-29">#define KILL_PIN           -1</front>
<front id="pins_99H-30"></front>
<front id="pins_99H-31">#define HEATER_0_PIN        13</front>
<front id="pins_99H-32">#define HEATER_1_PIN       -1</front>
<front id="pins_99H-33">#define HEATER_2_PIN       -1</front>
<front id="pins_99H-34">#define TEMP_0_PIN          6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_99H-35">#define TEMP_1_PIN         -1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_99H-36">#define TEMP_2_PIN         -1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_99H-37">#define HEATER_BED_PIN      4</front>
<front id="pins_99H-38">#define TEMP_BED_PIN       10</front>
 </pre>
<h1 id="pins_AZTEEG_X1Htitle" >pins_AZTEEG_X1.h</h1>
<pre id="pins_AZTEEG_X1H"  class="prettyprint linenums"><front id="pins_AZTEEG_X1H-1">/**</front>
<front id="pins_AZTEEG_X1H-2"> * Azteeg X1 pin assignments</front>
<front id="pins_AZTEEG_X1H-3"> */</front>
<front id="pins_AZTEEG_X1H-4"></front>
<front id="pins_AZTEEG_X1H-5">#define SANGUINOLOLU_V_1_2</front>
<front id="pins_AZTEEG_X1H-6"></front>
<front id="pins_AZTEEG_X1H-7">#include "pins_SANGUINOLOLU_11.h"</front>
 </pre>
<h1 id="pins_AZTEEG_X3Htitle" >pins_AZTEEG_X3.h</h1>
<pre id="pins_AZTEEG_X3H"  class="prettyprint linenums"><front id="pins_AZTEEG_X3H-1">/**</front>
<front id="pins_AZTEEG_X3H-2"> * AZTEEG_X3 Arduino Mega with RAMPS v1.3 pin assignments</front>
<front id="pins_AZTEEG_X3H-3"> */</front>
<front id="pins_AZTEEG_X3H-4"></front>
<front id="pins_AZTEEG_X3H-5">#include "pins_RAMPS_13_EFB.h"</front>
<front id="pins_AZTEEG_X3H-6"></front>
<front id="pins_AZTEEG_X3H-7">//LCD Pins//</front>
<front id="pins_AZTEEG_X3H-8"></front>
<front id="pins_AZTEEG_X3H-9">#if ENABLED(VIKI2) || ENABLED(miniVIKI)</front>
<front id="pins_AZTEEG_X3H-10"></front>
<front id="pins_AZTEEG_X3H-11">  #define BEEPER_PIN        33</front>
<front id="pins_AZTEEG_X3H-12"></front>
<front id="pins_AZTEEG_X3H-13"> // Pins for DOGM SPI LCD Support</front>
<front id="pins_AZTEEG_X3H-14">  #define DOGLCD_A0         31</front>
<front id="pins_AZTEEG_X3H-15">  #define DOGLCD_CS         32</front>
<front id="pins_AZTEEG_X3H-16">  #define LCD_SCREEN_ROT_180</front>
<front id="pins_AZTEEG_X3H-17"></front>
<front id="pins_AZTEEG_X3H-18"> //The encoder and click button</front>
<front id="pins_AZTEEG_X3H-19">  #define BTN_EN1           22</front>
<front id="pins_AZTEEG_X3H-20">  #define BTN_EN2            7</front>
<front id="pins_AZTEEG_X3H-21">  #define BTN_ENC           12  //the click switch</front>
<front id="pins_AZTEEG_X3H-22"></front>
<front id="pins_AZTEEG_X3H-23">  #define SDSS              53</front>
<front id="pins_AZTEEG_X3H-24">  #define SD_DETECT         -1  // Pin 49 if using display sd interface</front>
<front id="pins_AZTEEG_X3H-25"></front>
<front id="pins_AZTEEG_X3H-26">  #if ENABLED(TEMP_STAT_LEDS)</front>
<front id="pins_AZTEEG_X3H-27">    #define STAT_LED_RED    64</front>
<front id="pins_AZTEEG_X3H-28">    #define STAT_LED_BLUE   63</front>
<front id="pins_AZTEEG_X3H-29">  #endif</front>
<front id="pins_AZTEEG_X3H-30"></front>
<front id="pins_AZTEEG_X3H-31">#elif ENABLED(TEMP_STAT_LEDS)</front>
<front id="pins_AZTEEG_X3H-32"></front>
<front id="pins_AZTEEG_X3H-33">  #define STAT_LED_RED       6</front>
<front id="pins_AZTEEG_X3H-34">  #define STAT_LED_BLUE     11</front>
<front id="pins_AZTEEG_X3H-35"></front>
<front id="pins_AZTEEG_X3H-36">#endif</front>
 </pre>
<h1 id="pins_AZTEEG_X3_PROHtitle" >pins_AZTEEG_X3_PRO.h</h1>
<pre id="pins_AZTEEG_X3_PROH"  class="prettyprint linenums"><front id="pins_AZTEEG_X3_PROH-1">/**</front>
<front id="pins_AZTEEG_X3_PROH-2"> * AZTEEG_X3_PRO (Arduino Mega) pin assignments</front>
<front id="pins_AZTEEG_X3_PROH-3"> */</front>
<front id="pins_AZTEEG_X3_PROH-4"></front>
<front id="pins_AZTEEG_X3_PROH-5">#include "pins_RAMPS_13.h"</front>
<front id="pins_AZTEEG_X3_PROH-6"></front>
<front id="pins_AZTEEG_X3_PROH-7">#undef FAN_PIN</front>
<front id="pins_AZTEEG_X3_PROH-8">#define FAN_PIN             6 //Part Cooling System</front>
<front id="pins_AZTEEG_X3_PROH-9">#define BEEPER_PIN         33</front>
<front id="pins_AZTEEG_X3_PROH-10">#define CONTROLLERFAN_PIN   4 //Pin used for the fan to cool motherboard (-1 to disable)</front>
<front id="pins_AZTEEG_X3_PROH-11">//Fans/Water Pump to cool the hotend cool side.</front>
<front id="pins_AZTEEG_X3_PROH-12">#define EXTRUDER_0_AUTO_FAN_PIN   5</front>
<front id="pins_AZTEEG_X3_PROH-13">#define EXTRUDER_1_AUTO_FAN_PIN   5</front>
<front id="pins_AZTEEG_X3_PROH-14">#define EXTRUDER_2_AUTO_FAN_PIN   5</front>
<front id="pins_AZTEEG_X3_PROH-15">#define EXTRUDER_3_AUTO_FAN_PIN   5</front>
<front id="pins_AZTEEG_X3_PROH-16">//</front>
<front id="pins_AZTEEG_X3_PROH-17">//This section is to swap the MIN and MAX pins because the X3 Pro comes with only</front>
<front id="pins_AZTEEG_X3_PROH-18">//MIN endstops soldered onto the board. Delta code wants the homing endstops to be </front>
<front id="pins_AZTEEG_X3_PROH-19">//the MAX so I swapped them here.</front>
<front id="pins_AZTEEG_X3_PROH-20">//</front>
<front id="pins_AZTEEG_X3_PROH-21"> #if ENABLED(DELTA)</front>
<front id="pins_AZTEEG_X3_PROH-22">  #undef X_MIN_PIN</front>
<front id="pins_AZTEEG_X3_PROH-23">  #undef X_MAX_PIN</front>
<front id="pins_AZTEEG_X3_PROH-24">  #undef Y_MIN_PIN</front>
<front id="pins_AZTEEG_X3_PROH-25">  #undef Y_MAX_PIN</front>
<front id="pins_AZTEEG_X3_PROH-26">  #undef Z_MIN_PIN</front>
<front id="pins_AZTEEG_X3_PROH-27">  #undef Z_MAX_PIN</front>
<front id="pins_AZTEEG_X3_PROH-28"></front>
<front id="pins_AZTEEG_X3_PROH-29">  #define X_MIN_PIN         2</front>
<front id="pins_AZTEEG_X3_PROH-30">  #define X_MAX_PIN         3</front>
<front id="pins_AZTEEG_X3_PROH-31">  #define Y_MIN_PIN        15</front>
<front id="pins_AZTEEG_X3_PROH-32">  #define Y_MAX_PIN        14</front>
<front id="pins_AZTEEG_X3_PROH-33">  #define Z_MIN_PIN        19</front>
<front id="pins_AZTEEG_X3_PROH-34">  #define Z_MAX_PIN        18</front>
<front id="pins_AZTEEG_X3_PROH-35"> #endif</front>
<front id="pins_AZTEEG_X3_PROH-36">//</front>
<front id="pins_AZTEEG_X3_PROH-37"> #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="pins_AZTEEG_X3_PROH-38">//#undef Z_MIN_PIN</front>
<front id="pins_AZTEEG_X3_PROH-39">//#define Z_MIN_PIN        15</front>
<front id="pins_AZTEEG_X3_PROH-40">  // Define a pin to use as the signal pin on Arduino for the Z probe endstop.</front>
<front id="pins_AZTEEG_X3_PROH-41">  #define Z_MIN_PROBE_PIN  19</front>
<front id="pins_AZTEEG_X3_PROH-42"> #endif</front>
<front id="pins_AZTEEG_X3_PROH-43">//</front>
<front id="pins_AZTEEG_X3_PROH-44">#define E2_STEP_PIN        23</front>
<front id="pins_AZTEEG_X3_PROH-45">#define E2_DIR_PIN         25</front>
<front id="pins_AZTEEG_X3_PROH-46">#define E2_ENABLE_PIN      40</front>
<front id="pins_AZTEEG_X3_PROH-47"></front>
<front id="pins_AZTEEG_X3_PROH-48">#define E3_STEP_PIN        27</front>
<front id="pins_AZTEEG_X3_PROH-49">#define E3_DIR_PIN         29</front>
<front id="pins_AZTEEG_X3_PROH-50">#define E3_ENABLE_PIN      41</front>
<front id="pins_AZTEEG_X3_PROH-51"></front>
<front id="pins_AZTEEG_X3_PROH-52">#define E4_STEP_PIN        43</front>
<front id="pins_AZTEEG_X3_PROH-53">#define E4_DIR_PIN         37</front>
<front id="pins_AZTEEG_X3_PROH-54">#define E4_ENABLE_PIN      42</front>
<front id="pins_AZTEEG_X3_PROH-55"></front>
<front id="pins_AZTEEG_X3_PROH-56">#undef HEATER_1_PIN</front>
<front id="pins_AZTEEG_X3_PROH-57">#undef HEATER_2_PIN</front>
<front id="pins_AZTEEG_X3_PROH-58">#undef HEATER_3_PIN</front>
<front id="pins_AZTEEG_X3_PROH-59">#define HEATER_1_PIN        9</front>
<front id="pins_AZTEEG_X3_PROH-60">#define HEATER_2_PIN       16</front>
<front id="pins_AZTEEG_X3_PROH-61">#define HEATER_3_PIN       17</front>
<front id="pins_AZTEEG_X3_PROH-62">#define HEATER_4_PIN        4</front>
<front id="pins_AZTEEG_X3_PROH-63">#define HEATER_5_PIN        5</front>
<front id="pins_AZTEEG_X3_PROH-64">#define HEATER_6_PIN        6</front>
<front id="pins_AZTEEG_X3_PROH-65">#define HEATER_7_PIN       11</front>
<front id="pins_AZTEEG_X3_PROH-66"></front>
<front id="pins_AZTEEG_X3_PROH-67">#undef TEMP_2_PIN</front>
<front id="pins_AZTEEG_X3_PROH-68">#undef TEMP_3_PIN</front>
<front id="pins_AZTEEG_X3_PROH-69">#define TEMP_2_PIN         12   // ANALOG NUMBERING</front>
<front id="pins_AZTEEG_X3_PROH-70">#define TEMP_3_PIN         11   // ANALOG NUMBERING</front>
<front id="pins_AZTEEG_X3_PROH-71">#define TEMP_4_PIN         10   // ANALOG NUMBERING</front>
<front id="pins_AZTEEG_X3_PROH-72">#define TC1                 4   // ANALOG NUMBERING Thermo couple on Azteeg X3Pro</front>
<front id="pins_AZTEEG_X3_PROH-73">#define TC2                 5   // ANALOG NUMBERING Thermo couple on Azteeg X3Pro</front>
<front id="pins_AZTEEG_X3_PROH-74"></front>
<front id="pins_AZTEEG_X3_PROH-75">//</front>
<front id="pins_AZTEEG_X3_PROH-76">//These Servo pins are for when they are defined. Tested for usage with bed leveling</front>
<front id="pins_AZTEEG_X3_PROH-77">//on a Delta with 1 servo. Running through the Z servo endstop in code. </front>
<front id="pins_AZTEEG_X3_PROH-78">//Physical wire attachment was done on EXT1 on the GND, 5V, and D47 pins.</front>
<front id="pins_AZTEEG_X3_PROH-79">//</front>
<front id="pins_AZTEEG_X3_PROH-80">#define SERVO0_PIN         47</front>
<front id="pins_AZTEEG_X3_PROH-81"></front>
<front id="pins_AZTEEG_X3_PROH-82">//LCD Pins//</front>
<front id="pins_AZTEEG_X3_PROH-83"></front>
<front id="pins_AZTEEG_X3_PROH-84"> #if ENABLED(VIKI2) || ENABLED(miniVIKI)</front>
<front id="pins_AZTEEG_X3_PROH-85">  #define BEEPER_PIN       33</front>
<front id="pins_AZTEEG_X3_PROH-86"> // Pins for DOGM SPI LCD Support</front>
<front id="pins_AZTEEG_X3_PROH-87">  #define DOGLCD_A0        44</front>
<front id="pins_AZTEEG_X3_PROH-88">  #define DOGLCD_CS        45</front>
<front id="pins_AZTEEG_X3_PROH-89">  #define LCD_SCREEN_ROT_180</front>
<front id="pins_AZTEEG_X3_PROH-90">  </front>
<front id="pins_AZTEEG_X3_PROH-91"> //The encoder and click button</front>
<front id="pins_AZTEEG_X3_PROH-92">  #define BTN_EN1          22</front>
<front id="pins_AZTEEG_X3_PROH-93">  #define BTN_EN2           7</front>
<front id="pins_AZTEEG_X3_PROH-94">  #define BTN_ENC          39  //the click switch</front>
<front id="pins_AZTEEG_X3_PROH-95"> </front>
<front id="pins_AZTEEG_X3_PROH-96">  #define SDSS             53</front>
<front id="pins_AZTEEG_X3_PROH-97">  #define SD_DETECT_PIN 49</front>
<front id="pins_AZTEEG_X3_PROH-98">  </front>
<front id="pins_AZTEEG_X3_PROH-99">  #define KILL_PIN         31</front>
<front id="pins_AZTEEG_X3_PROH-100"> #endif</front>
<front id="pins_AZTEEG_X3_PROH-101"></front>
<front id="pins_AZTEEG_X3_PROH-102"> #if ENABLED(TEMP_STAT_LEDS)</front>
<front id="pins_AZTEEG_X3_PROH-103">  #define STAT_LED_RED     32</front>
<front id="pins_AZTEEG_X3_PROH-104">  #define STAT_LED_BLUE    35</front>
<front id="pins_AZTEEG_X3_PROH-105"> #endif</front>
 </pre>
<h1 id="pins_BAM_DICE_DUEHtitle" >pins_BAM_DICE_DUE.h</h1>
<pre id="pins_BAM_DICE_DUEH"  class="prettyprint linenums"><front id="pins_BAM_DICE_DUEH-1">/**</front>
<front id="pins_BAM_DICE_DUEH-2"> * BAM&DICE Due (Arduino Mega) pin assignments</front>
<front id="pins_BAM_DICE_DUEH-3"> */</front>
<front id="pins_BAM_DICE_DUEH-4"></front>
<front id="pins_BAM_DICE_DUEH-5">#include "pins_RAMPS_13_EFB.h"</front>
<front id="pins_BAM_DICE_DUEH-6"></front>
<front id="pins_BAM_DICE_DUEH-7">#undef TEMP_0_PIN</front>
<front id="pins_BAM_DICE_DUEH-8">#undef TEMP_1_PIN</front>
<front id="pins_BAM_DICE_DUEH-9">#define TEMP_0_PIN          9 // ANALOG NUMBERING</front>
<front id="pins_BAM_DICE_DUEH-10">#define TEMP_1_PIN         11 // ANALOG NUMBERING</front>
 </pre>
<h1 id="pins_BRAINWAVEHtitle" >pins_BRAINWAVE.h</h1>
<pre id="pins_BRAINWAVEH"  class="prettyprint linenums"><front id="pins_BRAINWAVEH-1">/**</front>
<front id="pins_BRAINWAVEH-2"> * Brainwave 1.0 pin assignments (AT90USB646)</front>
<front id="pins_BRAINWAVEH-3"> *</front>
<front id="pins_BRAINWAVEH-4"> * Requires hardware bundle for Arduino:</front>
<front id="pins_BRAINWAVEH-5"> * https://github.com/unrepentantgeek/brainwave-arduino</front>
<front id="pins_BRAINWAVEH-6"> */</front>
<front id="pins_BRAINWAVEH-7"></front>
<front id="pins_BRAINWAVEH-8">#ifndef __AVR_AT90USB646__</front>
<front id="pins_BRAINWAVEH-9">  #error Oops!  Make sure you have 'Brainwave' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_BRAINWAVEH-10">#endif</front>
<front id="pins_BRAINWAVEH-11"></front>
<front id="pins_BRAINWAVEH-12">#define X_STEP_PIN         27</front>
<front id="pins_BRAINWAVEH-13">#define X_DIR_PIN          29</front>
<front id="pins_BRAINWAVEH-14">#define X_ENABLE_PIN       28</front>
<front id="pins_BRAINWAVEH-15">#define X_STOP_PIN          7</front>
<front id="pins_BRAINWAVEH-16">#define X_ATT_PIN          26</front>
<front id="pins_BRAINWAVEH-17"></front>
<front id="pins_BRAINWAVEH-18">#define Y_STEP_PIN         31</front>
<front id="pins_BRAINWAVEH-19">#define Y_DIR_PIN          33</front>
<front id="pins_BRAINWAVEH-20">#define Y_ENABLE_PIN       32</front>
<front id="pins_BRAINWAVEH-21">#define Y_STOP_PIN          6</front>
<front id="pins_BRAINWAVEH-22">#define Y_ATT_PIN          30</front>
<front id="pins_BRAINWAVEH-23"></front>
<front id="pins_BRAINWAVEH-24">#define Z_STEP_PIN         17</front>
<front id="pins_BRAINWAVEH-25">#define Z_DIR_PIN          19</front>
<front id="pins_BRAINWAVEH-26">#define Z_ENABLE_PIN       18</front>
<front id="pins_BRAINWAVEH-27">#define Z_STOP_PIN          5</front>
<front id="pins_BRAINWAVEH-28">#define Z_ATT_PIN          16</front>
<front id="pins_BRAINWAVEH-29"></front>
<front id="pins_BRAINWAVEH-30">#define E0_STEP_PIN        21</front>
<front id="pins_BRAINWAVEH-31">#define E0_DIR_PIN         23</front>
<front id="pins_BRAINWAVEH-32">#define E0_ENABLE_PIN      22</front>
<front id="pins_BRAINWAVEH-33">#define E0_ATT_PIN         20</front>
<front id="pins_BRAINWAVEH-34"></front>
<front id="pins_BRAINWAVEH-35">#define HEATER_0_PIN        4  // Extruder</front>
<front id="pins_BRAINWAVEH-36">#define HEATER_1_PIN       -1</front>
<front id="pins_BRAINWAVEH-37">#define HEATER_2_PIN       -1</front>
<front id="pins_BRAINWAVEH-38">#define HEATER_BED_PIN     38  // Bed</front>
<front id="pins_BRAINWAVEH-39">#define FAN_PIN             3  // Fan</front>
<front id="pins_BRAINWAVEH-40"></front>
<front id="pins_BRAINWAVEH-41">#define TEMP_0_PIN          7  // Extruder / Analog pin numbering</front>
<front id="pins_BRAINWAVEH-42">#define TEMP_1_PIN         -1</front>
<front id="pins_BRAINWAVEH-43">#define TEMP_2_PIN         -1</front>
<front id="pins_BRAINWAVEH-44">#define TEMP_BED_PIN        6  // Bed / Analog pin numbering</front>
<front id="pins_BRAINWAVEH-45"></front>
<front id="pins_BRAINWAVEH-46">#define SDPOWER            -1</front>
<front id="pins_BRAINWAVEH-47">#define SDSS               -1</front>
<front id="pins_BRAINWAVEH-48">#define LED_PIN            39</front>
<front id="pins_BRAINWAVEH-49">#define PS_ON_PIN          -1</front>
<front id="pins_BRAINWAVEH-50">#define KILL_PIN           -1</front>
<front id="pins_BRAINWAVEH-51">#define ALARM_PIN          -1</front>
<front id="pins_BRAINWAVEH-52"></front>
<front id="pins_BRAINWAVEH-53">#if DISABLED(SDSUPPORT)</front>
<front id="pins_BRAINWAVEH-54">  // these pins are defined in the SD library if building with SD support</front>
<front id="pins_BRAINWAVEH-55">  #define SCK_PIN           9</front>
<front id="pins_BRAINWAVEH-56">  #define MISO_PIN         11</front>
<front id="pins_BRAINWAVEH-57">  #define MOSI_PIN         10</front>
<front id="pins_BRAINWAVEH-58">#endif</front>
<front id="pins_BRAINWAVEH-59"></front>
 </pre>
<h1 id="pins_BRAINWAVE_PROHtitle" >pins_BRAINWAVE_PRO.h</h1>
<pre id="pins_BRAINWAVE_PROH"  class="prettyprint linenums"><front id="pins_BRAINWAVE_PROH-1">/**</front>
<front id="pins_BRAINWAVE_PROH-2"> * Brainwave Pro pin assignments (AT90USB1286)</front>
<front id="pins_BRAINWAVE_PROH-3"> *</front>
<front id="pins_BRAINWAVE_PROH-4"> * Requires hardware bundle for Arduino:</front>
<front id="pins_BRAINWAVE_PROH-5"> * https://github.com/unrepentantgeek/brainwave-arduino</front>
<front id="pins_BRAINWAVE_PROH-6"> */</front>
<front id="pins_BRAINWAVE_PROH-7"></front>
<front id="pins_BRAINWAVE_PROH-8">#ifndef __AVR_AT90USB1286__</front>
<front id="pins_BRAINWAVE_PROH-9">  #error Oops!  Make sure you have 'Brainwave Pro' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_BRAINWAVE_PROH-10">#endif</front>
<front id="pins_BRAINWAVE_PROH-11"></front>
<front id="pins_BRAINWAVE_PROH-12">#include "fastio.h"</front>
<front id="pins_BRAINWAVE_PROH-13"></front>
<front id="pins_BRAINWAVE_PROH-14">#ifndef AT90USBxx_TEENSYPP_ASSIGNMENTS  // use Teensyduino Teensy++2.0 pin assignments instead of Marlin alphabetical.</front>
<front id="pins_BRAINWAVE_PROH-15">  #error  Uncomment #define AT90USBxx_TEENSYPP_ASSIGNMENTS in fastio.h for this config</front>
<front id="pins_BRAINWAVE_PROH-16">#endif</front>
<front id="pins_BRAINWAVE_PROH-17"></front>
<front id="pins_BRAINWAVE_PROH-18">#define LARGE_FLASH        true</front>
<front id="pins_BRAINWAVE_PROH-19"></front>
<front id="pins_BRAINWAVE_PROH-20">#define X_STEP_PIN         33</front>
<front id="pins_BRAINWAVE_PROH-21">#define X_DIR_PIN          32</front>
<front id="pins_BRAINWAVE_PROH-22">#define X_ENABLE_PIN       11</front>
<front id="pins_BRAINWAVE_PROH-23">#define X_STOP_PIN         47</front>
<front id="pins_BRAINWAVE_PROH-24"></front>
<front id="pins_BRAINWAVE_PROH-25">#define Y_STEP_PIN         31</front>
<front id="pins_BRAINWAVE_PROH-26">#define Y_DIR_PIN          30</front>
<front id="pins_BRAINWAVE_PROH-27">#define Y_ENABLE_PIN        8</front>
<front id="pins_BRAINWAVE_PROH-28">#define Y_STOP_PIN         18</front>
<front id="pins_BRAINWAVE_PROH-29"></front>
<front id="pins_BRAINWAVE_PROH-30">#define Z_STEP_PIN         29</front>
<front id="pins_BRAINWAVE_PROH-31">#define Z_DIR_PIN          28</front>
<front id="pins_BRAINWAVE_PROH-32">#define Z_ENABLE_PIN       37</front>
<front id="pins_BRAINWAVE_PROH-33">#define Z_MAX_PIN          36</front>
<front id="pins_BRAINWAVE_PROH-34">#define Z_MIN_PIN          17  // Bed Z probe</front>
<front id="pins_BRAINWAVE_PROH-35"></front>
<front id="pins_BRAINWAVE_PROH-36">#define E0_STEP_PIN        35</front>
<front id="pins_BRAINWAVE_PROH-37">#define E0_DIR_PIN         34</front>
<front id="pins_BRAINWAVE_PROH-38">#define E0_ENABLE_PIN      13</front>
<front id="pins_BRAINWAVE_PROH-39"></front>
<front id="pins_BRAINWAVE_PROH-40">#define HEATER_0_PIN       15</front>
<front id="pins_BRAINWAVE_PROH-41">#define HEATER_1_PIN       -1</front>
<front id="pins_BRAINWAVE_PROH-42">#define HEATER_2_PIN       -1</front>
<front id="pins_BRAINWAVE_PROH-43">#define HEATER_BED_PIN     14  // Bed</front>
<front id="pins_BRAINWAVE_PROH-44">#define FAN_PIN            16  // Fan, PWM</front>
<front id="pins_BRAINWAVE_PROH-45"></front>
<front id="pins_BRAINWAVE_PROH-46">#define TEMP_0_PIN          2  // Extruder / Analog pin numbering</front>
<front id="pins_BRAINWAVE_PROH-47">#define TEMP_1_PIN          1  // Spare / Analog pin numbering</front>
<front id="pins_BRAINWAVE_PROH-48">#define TEMP_2_PIN         -1</front>
<front id="pins_BRAINWAVE_PROH-49">#define TEMP_BED_PIN        0  // Bed / Analog pin numbering</front>
<front id="pins_BRAINWAVE_PROH-50"></front>
<front id="pins_BRAINWAVE_PROH-51">#define SDPOWER            -1</front>
<front id="pins_BRAINWAVE_PROH-52">#define SDSS               20</front>
<front id="pins_BRAINWAVE_PROH-53">#define LED_PIN            19</front>
<front id="pins_BRAINWAVE_PROH-54">#define PS_ON_PIN          -1</front>
<front id="pins_BRAINWAVE_PROH-55">#define KILL_PIN           -1</front>
<front id="pins_BRAINWAVE_PROH-56">#define ALARM_PIN          -1</front>
<front id="pins_BRAINWAVE_PROH-57">#define SD_DETECT_PIN      12</front>
<front id="pins_BRAINWAVE_PROH-58"></front>
<front id="pins_BRAINWAVE_PROH-59">#if DISABLED(SDSUPPORT)</front>
<front id="pins_BRAINWAVE_PROH-60">// these pins are defined in the SD library if building with SD support</front>
<front id="pins_BRAINWAVE_PROH-61">  #define SCK_PIN          21</front>
<front id="pins_BRAINWAVE_PROH-62">  #define MISO_PIN         23</front>
<front id="pins_BRAINWAVE_PROH-63">  #define MOSI_PIN         22</front>
<front id="pins_BRAINWAVE_PROH-64">#endif</front>
<front id="pins_BRAINWAVE_PROH-65"></front>
 </pre>
<h1 id="pins_CHEAPTRONICHtitle" >pins_CHEAPTRONIC.h</h1>
<pre id="pins_CHEAPTRONICH"  class="prettyprint linenums"><front id="pins_CHEAPTRONICH-1">/**</front>
<front id="pins_CHEAPTRONICH-2"> * Cheaptronic v1.0 pin assignments</front>
<front id="pins_CHEAPTRONICH-3"> */</front>
<front id="pins_CHEAPTRONICH-4"></front>
<front id="pins_CHEAPTRONICH-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_CHEAPTRONICH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_CHEAPTRONICH-7">#endif</front>
<front id="pins_CHEAPTRONICH-8"></front>
<front id="pins_CHEAPTRONICH-9">#define LARGE_FLASH        true</front>
<front id="pins_CHEAPTRONICH-10"></front>
<front id="pins_CHEAPTRONICH-11">// X motor stepper</front>
<front id="pins_CHEAPTRONICH-12">#define X_STEP_PIN 14</front>
<front id="pins_CHEAPTRONICH-13">#define X_DIR_PIN 15</front>
<front id="pins_CHEAPTRONICH-14">#define X_ENABLE_PIN 24</front>
<front id="pins_CHEAPTRONICH-15"></front>
<front id="pins_CHEAPTRONICH-16">// X endstop</front>
<front id="pins_CHEAPTRONICH-17">#define X_MIN_PIN 3</front>
<front id="pins_CHEAPTRONICH-18">#define X_MAX_PIN -1</front>
<front id="pins_CHEAPTRONICH-19"></front>
<front id="pins_CHEAPTRONICH-20">// Y motor stepper</front>
<front id="pins_CHEAPTRONICH-21">#define Y_STEP_PIN 35</front>
<front id="pins_CHEAPTRONICH-22">#define Y_DIR_PIN 36</front>
<front id="pins_CHEAPTRONICH-23">#define Y_ENABLE_PIN 31</front>
<front id="pins_CHEAPTRONICH-24"></front>
<front id="pins_CHEAPTRONICH-25">// Y endstop</front>
<front id="pins_CHEAPTRONICH-26">#define Y_MIN_PIN 2</front>
<front id="pins_CHEAPTRONICH-27">#define Y_MAX_PIN -1</front>
<front id="pins_CHEAPTRONICH-28"></front>
<front id="pins_CHEAPTRONICH-29">// Z motor stepper</front>
<front id="pins_CHEAPTRONICH-30">#define Z_STEP_PIN 40</front>
<front id="pins_CHEAPTRONICH-31">#define Z_DIR_PIN 41</front>
<front id="pins_CHEAPTRONICH-32">#define Z_ENABLE_PIN 37</front>
<front id="pins_CHEAPTRONICH-33"></front>
<front id="pins_CHEAPTRONICH-34">// Z endstop</front>
<front id="pins_CHEAPTRONICH-35">#define Z_MIN_PIN 5</front>
<front id="pins_CHEAPTRONICH-36">#define Z_MAX_PIN -1</front>
<front id="pins_CHEAPTRONICH-37"></front>
<front id="pins_CHEAPTRONICH-38">// Extruder 0 stepper</front>
<front id="pins_CHEAPTRONICH-39">#define E0_STEP_PIN 26</front>
<front id="pins_CHEAPTRONICH-40">#define E0_DIR_PIN 28</front>
<front id="pins_CHEAPTRONICH-41">#define E0_ENABLE_PIN 25</front>
<front id="pins_CHEAPTRONICH-42"></front>
<front id="pins_CHEAPTRONICH-43">// Extruder 1 stepper</front>
<front id="pins_CHEAPTRONICH-44">#define E1_STEP_PIN 33</front>
<front id="pins_CHEAPTRONICH-45">#define E1_DIR_PIN 34</front>
<front id="pins_CHEAPTRONICH-46">#define E1_ENABLE_PIN 30</front>
<front id="pins_CHEAPTRONICH-47"></front>
<front id="pins_CHEAPTRONICH-48">#define SDPOWER -1</front>
<front id="pins_CHEAPTRONICH-49">#define SDSS -1</front>
<front id="pins_CHEAPTRONICH-50">#define LED_PIN -1</front>
<front id="pins_CHEAPTRONICH-51"></front>
<front id="pins_CHEAPTRONICH-52">// FAN</front>
<front id="pins_CHEAPTRONICH-53">#define FAN_PIN -1</front>
<front id="pins_CHEAPTRONICH-54"></front>
<front id="pins_CHEAPTRONICH-55">#define PS_ON_PIN -1</front>
<front id="pins_CHEAPTRONICH-56">#define KILL_PIN -1</front>
<front id="pins_CHEAPTRONICH-57"></front>
<front id="pins_CHEAPTRONICH-58">#define HEATER_0_PIN 19 // EXTRUDER 1</front>
<front id="pins_CHEAPTRONICH-59">#define HEATER_1_PIN 23 // EXTRUDER 2</front>
<front id="pins_CHEAPTRONICH-60">// HeatedBad</front>
<front id="pins_CHEAPTRONICH-61">#define HEATER_BED_PIN 22</front>
<front id="pins_CHEAPTRONICH-62">// Cheaptronic v1.0 hasent EXTRUDER 3</front>
<front id="pins_CHEAPTRONICH-63">#define HEATER_2_PIN -1</front>
<front id="pins_CHEAPTRONICH-64"></front>
<front id="pins_CHEAPTRONICH-65">// Temperature sensors</front>
<front id="pins_CHEAPTRONICH-66">#define TEMP_0_PIN 15</front>
<front id="pins_CHEAPTRONICH-67">#define TEMP_1_PIN 14</front>
<front id="pins_CHEAPTRONICH-68">#define TEMP_2_PIN -1</front>
<front id="pins_CHEAPTRONICH-69">#define TEMP_BED_PIN 13</front>
<front id="pins_CHEAPTRONICH-70"></front>
<front id="pins_CHEAPTRONICH-71">// Cheaptronic v1.0 doesn't support LCD</front>
<front id="pins_CHEAPTRONICH-72">#define LCD_PINS_RS -1</front>
<front id="pins_CHEAPTRONICH-73">#define LCD_PINS_ENABLE -1</front>
<front id="pins_CHEAPTRONICH-74">#define LCD_PINS_D4 -1</front>
<front id="pins_CHEAPTRONICH-75">#define LCD_PINS_D5 -1</front>
<front id="pins_CHEAPTRONICH-76">#define LCD_PINS_D6 -1</front>
<front id="pins_CHEAPTRONICH-77">#define LCD_PINS_D7 -1</front>
<front id="pins_CHEAPTRONICH-78"></front>
<front id="pins_CHEAPTRONICH-79">// Cheaptronic v1.0 doesn't support keypad</front>
<front id="pins_CHEAPTRONICH-80">#define BTN_EN1 -1</front>
<front id="pins_CHEAPTRONICH-81">#define BTN_EN2 -1</front>
<front id="pins_CHEAPTRONICH-82">#define BTN_ENC -1</front>
<front id="pins_CHEAPTRONICH-83"></front>
<front id="pins_CHEAPTRONICH-84">#define BLEN_C 2</front>
<front id="pins_CHEAPTRONICH-85">#define BLEN_B 1</front>
<front id="pins_CHEAPTRONICH-86">#define BLEN_A 0</front>
<front id="pins_CHEAPTRONICH-87"></front>
<front id="pins_CHEAPTRONICH-88">// Cheaptronic v1.0 doesn't use this</front>
<front id="pins_CHEAPTRONICH-89">#define SD_DETECT_PIN -1</front>
 </pre>
<h1 id="pins_ELEFU_3Htitle" >pins_ELEFU_3.h</h1>
<pre id="pins_ELEFU_3H"  class="prettyprint linenums"><front id="pins_ELEFU_3H-1">/**</front>
<front id="pins_ELEFU_3H-2"> * Elefu RA Board Pin Assignments</front>
<front id="pins_ELEFU_3H-3"> */</front>
<front id="pins_ELEFU_3H-4"></front>
<front id="pins_ELEFU_3H-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_ELEFU_3H-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_ELEFU_3H-7">#endif</front>
<front id="pins_ELEFU_3H-8"></front>
<front id="pins_ELEFU_3H-9">#define X_STEP_PIN         49</front>
<front id="pins_ELEFU_3H-10">#define X_DIR_PIN          13</front>
<front id="pins_ELEFU_3H-11">#define X_ENABLE_PIN       48</front>
<front id="pins_ELEFU_3H-12">#define X_MIN_PIN          35</front>
<front id="pins_ELEFU_3H-13">#define X_MAX_PIN          34</front>
<front id="pins_ELEFU_3H-14"></front>
<front id="pins_ELEFU_3H-15">#define Y_STEP_PIN         11</front>
<front id="pins_ELEFU_3H-16">#define Y_DIR_PIN           9</front>
<front id="pins_ELEFU_3H-17">#define Y_ENABLE_PIN       12</front>
<front id="pins_ELEFU_3H-18">#define Y_MIN_PIN          33</front>
<front id="pins_ELEFU_3H-19">#define Y_MAX_PIN          32</front>
<front id="pins_ELEFU_3H-20"></front>
<front id="pins_ELEFU_3H-21">#define Z_STEP_PIN          7</front>
<front id="pins_ELEFU_3H-22">#define Z_DIR_PIN           6</front>
<front id="pins_ELEFU_3H-23">#define Z_ENABLE_PIN        8</front>
<front id="pins_ELEFU_3H-24">#define Z_MIN_PIN          31</front>
<front id="pins_ELEFU_3H-25">#define Z_MAX_PIN          30</front>
<front id="pins_ELEFU_3H-26"></front>
<front id="pins_ELEFU_3H-27">#define E2_STEP_PIN        43</front>
<front id="pins_ELEFU_3H-28">#define E2_DIR_PIN         47</front>
<front id="pins_ELEFU_3H-29">#define E2_ENABLE_PIN      42</front>
<front id="pins_ELEFU_3H-30"></front>
<front id="pins_ELEFU_3H-31">#define E1_STEP_PIN        18</front>
<front id="pins_ELEFU_3H-32">#define E1_DIR_PIN         19</front>
<front id="pins_ELEFU_3H-33">#define E1_ENABLE_PIN      38</front>
<front id="pins_ELEFU_3H-34"></front>
<front id="pins_ELEFU_3H-35">#define E0_STEP_PIN        40</front>
<front id="pins_ELEFU_3H-36">#define E0_DIR_PIN         41</front>
<front id="pins_ELEFU_3H-37">#define E0_ENABLE_PIN      37</front>
<front id="pins_ELEFU_3H-38"></front>
<front id="pins_ELEFU_3H-39">#define SDPOWER            -1</front>
<front id="pins_ELEFU_3H-40">#define LED_PIN            -1 //Use +12V Aux port for LED Ring</front>
<front id="pins_ELEFU_3H-41"></front>
<front id="pins_ELEFU_3H-42">#define FAN_PIN            16 //5V PWM</front>
<front id="pins_ELEFU_3H-43"></front>
<front id="pins_ELEFU_3H-44">#define PS_ON_PIN          10 //Set to -1 if using a manual switch on the PWRSW Connector</front>
<front id="pins_ELEFU_3H-45">#define SLEEP_WAKE_PIN     26 //This feature still needs work</front>
<front id="pins_ELEFU_3H-46"></front>
<front id="pins_ELEFU_3H-47">#define HEATER_0_PIN       45 //12V PWM1</front>
<front id="pins_ELEFU_3H-48">#define HEATER_1_PIN       46 //12V PWM2</front>
<front id="pins_ELEFU_3H-49">#define HEATER_2_PIN       17 //12V PWM3</front>
<front id="pins_ELEFU_3H-50">#define HEATER_BED_PIN     44 //DOUBLE 12V PWM</front>
<front id="pins_ELEFU_3H-51">#define TEMP_0_PIN          3 //ANALOG NUMBERING</front>
<front id="pins_ELEFU_3H-52">#define TEMP_1_PIN          2 //ANALOG NUMBERING</front>
<front id="pins_ELEFU_3H-53">#define TEMP_2_PIN          1 //ANALOG NUMBERING</front>
<front id="pins_ELEFU_3H-54">#define TEMP_BED_PIN        0 //ANALOG NUMBERING</front>
<front id="pins_ELEFU_3H-55"></front>
<front id="pins_ELEFU_3H-56">#define BEEPER_PIN         36</front>
<front id="pins_ELEFU_3H-57"></front>
<front id="pins_ELEFU_3H-58">#define KILL_PIN           -1</front>
<front id="pins_ELEFU_3H-59"></front>
<front id="pins_ELEFU_3H-60">// M240  Triggers a camera by emulating a Canon RC-1 Remote</front>
<front id="pins_ELEFU_3H-61">// Data from: http://www.doc-diy.net/photo/rc-1_hacked/</front>
<front id="pins_ELEFU_3H-62">#define PHOTOGRAPH_PIN     29</front>
<front id="pins_ELEFU_3H-63"></front>
<front id="pins_ELEFU_3H-64">#if ENABLED(RA_CONTROL_PANEL)</front>
<front id="pins_ELEFU_3H-65"></front>
<front id="pins_ELEFU_3H-66">  #define SDSS             53</front>
<front id="pins_ELEFU_3H-67">  #define SD_DETECT_PIN    28</front>
<front id="pins_ELEFU_3H-68"></front>
<front id="pins_ELEFU_3H-69">  #define BTN_EN1          14</front>
<front id="pins_ELEFU_3H-70">  #define BTN_EN2          39</front>
<front id="pins_ELEFU_3H-71">  #define BTN_ENC          15  //the click</front>
<front id="pins_ELEFU_3H-72"></front>
<front id="pins_ELEFU_3H-73">  #define BLEN_C            2</front>
<front id="pins_ELEFU_3H-74">  #define BLEN_B            1</front>
<front id="pins_ELEFU_3H-75">  #define BLEN_A            0</front>
<front id="pins_ELEFU_3H-76"></front>
<front id="pins_ELEFU_3H-77">#endif // RA_CONTROL_PANEL</front>
<front id="pins_ELEFU_3H-78"></front>
<front id="pins_ELEFU_3H-79">#if ENABLED(RA_DISCO)</front>
<front id="pins_ELEFU_3H-80">  //variables for which pins the TLC5947 is using</front>
<front id="pins_ELEFU_3H-81">  #define TLC_CLOCK_PIN    25</front>
<front id="pins_ELEFU_3H-82">  #define TLC_BLANK_PIN    23</front>
<front id="pins_ELEFU_3H-83">  #define TLC_XLAT_PIN     22</front>
<front id="pins_ELEFU_3H-84">  #define TLC_DATA_PIN     24</front>
<front id="pins_ELEFU_3H-85"></front>
<front id="pins_ELEFU_3H-86">  //We also need to define pin to port number mapping for the 2560 to match the pins listed above. If you change the TLC pins, update this as well per the 2560 datasheet!</front>
<front id="pins_ELEFU_3H-87">  //This currently only works with the RA Board.</front>
<front id="pins_ELEFU_3H-88">  #define TLC_CLOCK_BIT 3 //bit 3 on port A</front>
<front id="pins_ELEFU_3H-89">  #define TLC_CLOCK_PORT &PORTA //bit 3 on port A</front>
<front id="pins_ELEFU_3H-90"></front>
<front id="pins_ELEFU_3H-91">  #define TLC_BLANK_BIT 1 //bit 1 on port A</front>
<front id="pins_ELEFU_3H-92">  #define TLC_BLANK_PORT &PORTA //bit 1 on port A</front>
<front id="pins_ELEFU_3H-93"></front>
<front id="pins_ELEFU_3H-94">  #define TLC_DATA_BIT 2 //bit 2 on port A</front>
<front id="pins_ELEFU_3H-95">  #define TLC_DATA_PORT &PORTA //bit 2 on port A</front>
<front id="pins_ELEFU_3H-96"></front>
<front id="pins_ELEFU_3H-97">  #define TLC_XLAT_BIT 0 //bit 0 on port A</front>
<front id="pins_ELEFU_3H-98">  #define TLC_XLAT_PORT &PORTA //bit 0 on port A</front>
<front id="pins_ELEFU_3H-99"></front>
<front id="pins_ELEFU_3H-100">  //change this to match your situation. Lots of TLCs takes up the arduino SRAM very quickly, so be careful</front>
<front id="pins_ELEFU_3H-101">  //Leave it at at least 1 if you have enabled RA_LIGHTING</front>
<front id="pins_ELEFU_3H-102">  //The number of TLC5947 boards chained together for use with the animation, additional ones will repeat the animation on them, but are not individually addressable and mimic those before them. You can leave the default at 2 even if you only have 1 TLC5947 module.</front>
<front id="pins_ELEFU_3H-103">  #define NUM_TLCS 2</front>
<front id="pins_ELEFU_3H-104"></front>
<front id="pins_ELEFU_3H-105">  //These TRANS_ARRAY values let you change the order the LEDs on the lighting modules will animate for chase functions.</front>
<front id="pins_ELEFU_3H-106">  //Modify them according to your specific situation.</front>
<front id="pins_ELEFU_3H-107">  //NOTE: the array should be 8 long for every TLC you have. These defaults assume (2) TLCs.</front>
<front id="pins_ELEFU_3H-108">  #define TRANS_ARRAY {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8} //forwards</front>
<front id="pins_ELEFU_3H-109">  //#define TRANS_ARRAY {7, 6, 5, 4, 3, 2, 1, 0, 8, 9, 10, 11, 12, 13, 14, 15} //backwards</front>
<front id="pins_ELEFU_3H-110">#endif // RA_DISCO</front>
 </pre>
<h1 id="pins_FELIX2Htitle" >pins_FELIX2.h</h1>
<pre id="pins_FELIX2H"  class="prettyprint linenums"><front id="pins_FELIX2H-1">/**</front>
<front id="pins_FELIX2H-2"> * FELIXprinters v2.0/3.0 (RAMPS v1.3) pin assignments</front>
<front id="pins_FELIX2H-3"> */</front>
<front id="pins_FELIX2H-4"></front>
<front id="pins_FELIX2H-5">#include "pins_RAMPS_13_EFB.h"</front>
<front id="pins_FELIX2H-6"></front>
<front id="pins_FELIX2H-7">#undef HEATER_1_PIN</front>
<front id="pins_FELIX2H-8">#define HEATER_1_PIN        7 // EXTRUDER 2</front>
<front id="pins_FELIX2H-9"></front>
<front id="pins_FELIX2H-10">#define DISABLE_MAX_ENDSTOPS</front>
<front id="pins_FELIX2H-11"></front>
<front id="pins_FELIX2H-12">#undef SDPOWER</front>
<front id="pins_FELIX2H-13">#define SDPOWER             1</front>
<front id="pins_FELIX2H-14"></front>
<front id="pins_FELIX2H-15">#define PS_ON_PIN          12</front>
<front id="pins_FELIX2H-16"></front>
<front id="pins_FELIX2H-17">#if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)</front>
<front id="pins_FELIX2H-18"></front>
<front id="pins_FELIX2H-19">  #define BLEN_C 2</front>
<front id="pins_FELIX2H-20">  #define BLEN_B 1</front>
<front id="pins_FELIX2H-21">  #define BLEN_A 0</front>
<front id="pins_FELIX2H-22">  #define SD_DETECT_PIN 6</front>
<front id="pins_FELIX2H-23"></front>
<front id="pins_FELIX2H-24">#endif // NEWPANEL && ULTRA_LCD</front>
 </pre>
<h1 id="pins_GEN3_MONOLITHICHtitle" >pins_GEN3_MONOLITHIC.h</h1>
<pre id="pins_GEN3_MONOLITHICH"  class="prettyprint linenums"><front id="pins_GEN3_MONOLITHICH-1">/**</front>
<front id="pins_GEN3_MONOLITHICH-2"> * Gen3 Monolithic Electronics pin assignments</front>
<front id="pins_GEN3_MONOLITHICH-3"> */</front>
<front id="pins_GEN3_MONOLITHICH-4"></front>
<front id="pins_GEN3_MONOLITHICH-5">#ifndef __AVR_ATmega644P__</front>
<front id="pins_GEN3_MONOLITHICH-6">  #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_GEN3_MONOLITHICH-7">#endif</front>
<front id="pins_GEN3_MONOLITHICH-8"></front>
<front id="pins_GEN3_MONOLITHICH-9">#define DEBUG_PIN 0</front>
<front id="pins_GEN3_MONOLITHICH-10"></front>
<front id="pins_GEN3_MONOLITHICH-11">// x axis</front>
<front id="pins_GEN3_MONOLITHICH-12">#define X_STEP_PIN 15</front>
<front id="pins_GEN3_MONOLITHICH-13">#define X_DIR_PIN 18</front>
<front id="pins_GEN3_MONOLITHICH-14">#define X_MIN_PIN 20</front>
<front id="pins_GEN3_MONOLITHICH-15">// Alex Checar #define X_STOP_PIN         20</front>
<front id="pins_GEN3_MONOLITHICH-16">#define X_ENABLE_PIN 24 // actually uses Y_enable_pin</front>
<front id="pins_GEN3_MONOLITHICH-17">#define X_MAX_PIN -1</front>
<front id="pins_GEN3_MONOLITHICH-18"></front>
<front id="pins_GEN3_MONOLITHICH-19">// y axis</front>
<front id="pins_GEN3_MONOLITHICH-20">#define Y_STEP_PIN 23</front>
<front id="pins_GEN3_MONOLITHICH-21">#define Y_DIR_PIN 22</front>
<front id="pins_GEN3_MONOLITHICH-22">#define Y_MIN_PIN 25</front>
<front id="pins_GEN3_MONOLITHICH-23">// Alex Checar #define Y_STOP_PIN         25</front>
<front id="pins_GEN3_MONOLITHICH-24">#define Y_ENABLE_PIN 24 // shared with X_enable_pin</front>
<front id="pins_GEN3_MONOLITHICH-25">#define Y_MAX_PIN -1</front>
<front id="pins_GEN3_MONOLITHICH-26"></front>
<front id="pins_GEN3_MONOLITHICH-27">// z axis</front>
<front id="pins_GEN3_MONOLITHICH-28">#define Z_STEP_PIN 27</front>
<front id="pins_GEN3_MONOLITHICH-29">#define Z_DIR_PIN 28</front>
<front id="pins_GEN3_MONOLITHICH-30">#define Z_MIN_PIN 30</front>
<front id="pins_GEN3_MONOLITHICH-31">// Alex Checar #define Z_STOP_PIN         30</front>
<front id="pins_GEN3_MONOLITHICH-32">#define Z_ENABLE_PIN 29</front>
<front id="pins_GEN3_MONOLITHICH-33">#define Z_MAX_PIN -1</front>
<front id="pins_GEN3_MONOLITHICH-34"></front>
<front id="pins_GEN3_MONOLITHICH-35">// extruder pins</front>
<front id="pins_GEN3_MONOLITHICH-36">#define E0_STEP_PIN         12</front>
<front id="pins_GEN3_MONOLITHICH-37">#define E0_DIR_PIN          17</front>
<front id="pins_GEN3_MONOLITHICH-38">#define E0_ENABLE_PIN       3</front>
<front id="pins_GEN3_MONOLITHICH-39"></front>
<front id="pins_GEN3_MONOLITHICH-40">#define HEATER_0_PIN 16</front>
<front id="pins_GEN3_MONOLITHICH-41">#define TEMP_0_PIN 0</front>
<front id="pins_GEN3_MONOLITHICH-42"></front>
<front id="pins_GEN3_MONOLITHICH-43">#define FAN_PIN -1</front>
<front id="pins_GEN3_MONOLITHICH-44"></front>
<front id="pins_GEN3_MONOLITHICH-45">// bed pins</front>
<front id="pins_GEN3_MONOLITHICH-46">#define HEATER_BED_PIN -1</front>
<front id="pins_GEN3_MONOLITHICH-47">#define TEMP_BED_PIN -1</front>
<front id="pins_GEN3_MONOLITHICH-48"></front>
<front id="pins_GEN3_MONOLITHICH-49"></front>
<front id="pins_GEN3_MONOLITHICH-50">#define SDSS     -1</front>
<front id="pins_GEN3_MONOLITHICH-51">#define SDPOWER          -1</front>
<front id="pins_GEN3_MONOLITHICH-52">#define LED_PIN          -1</front>
<front id="pins_GEN3_MONOLITHICH-53"></front>
<front id="pins_GEN3_MONOLITHICH-54">// pin for controlling the PSU.</front>
<front id="pins_GEN3_MONOLITHICH-55">#define PS_ON_PIN       14  // Alex, Do this work on the card?</front>
<front id="pins_GEN3_MONOLITHICH-56"></front>
<front id="pins_GEN3_MONOLITHICH-57">// Alex extras from Gen3+</front>
<front id="pins_GEN3_MONOLITHICH-58">#define KILL_PIN           -1</front>
<front id="pins_GEN3_MONOLITHICH-59">#define TEMP_1_PIN         -1</front>
<front id="pins_GEN3_MONOLITHICH-60">#define TEMP_2_PIN         -1</front>
<front id="pins_GEN3_MONOLITHICH-61">#define HEATER_2_PIN       -1</front>
 </pre>
<h1 id="pins_GEN3_PLUSHtitle" >pins_GEN3_PLUS.h</h1>
<pre id="pins_GEN3_PLUSH"  class="prettyprint linenums"><front id="pins_GEN3_PLUSH-1">/**</front>
<front id="pins_GEN3_PLUSH-2"> * Gen3+ pin assignments</front>
<front id="pins_GEN3_PLUSH-3"> */</front>
<front id="pins_GEN3_PLUSH-4"></front>
<front id="pins_GEN3_PLUSH-5">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pins_GEN3_PLUSH-6">  #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_GEN3_PLUSH-7">#endif</front>
<front id="pins_GEN3_PLUSH-8"></front>
<front id="pins_GEN3_PLUSH-9">#define X_STEP_PIN         15</front>
<front id="pins_GEN3_PLUSH-10">#define X_DIR_PIN          18</front>
<front id="pins_GEN3_PLUSH-11">#define X_STOP_PIN         20</front>
<front id="pins_GEN3_PLUSH-12"></front>
<front id="pins_GEN3_PLUSH-13">#define Y_STEP_PIN         23</front>
<front id="pins_GEN3_PLUSH-14">#define Y_DIR_PIN          22</front>
<front id="pins_GEN3_PLUSH-15">#define Y_STOP_PIN         25</front>
<front id="pins_GEN3_PLUSH-16"></front>
<front id="pins_GEN3_PLUSH-17">#define Z_STEP_PIN         27</front>
<front id="pins_GEN3_PLUSH-18">#define Z_DIR_PIN          28</front>
<front id="pins_GEN3_PLUSH-19">#define Z_STOP_PIN         30</front>
<front id="pins_GEN3_PLUSH-20"></front>
<front id="pins_GEN3_PLUSH-21">#define E0_STEP_PIN        17</front>
<front id="pins_GEN3_PLUSH-22">#define E0_DIR_PIN         21</front>
<front id="pins_GEN3_PLUSH-23"></front>
<front id="pins_GEN3_PLUSH-24">#define LED_PIN            -1</front>
<front id="pins_GEN3_PLUSH-25"></front>
<front id="pins_GEN3_PLUSH-26">#define FAN_PIN            -1</front>
<front id="pins_GEN3_PLUSH-27"></front>
<front id="pins_GEN3_PLUSH-28">#define PS_ON_PIN         14</front>
<front id="pins_GEN3_PLUSH-29">#define KILL_PIN           -1</front>
<front id="pins_GEN3_PLUSH-30"></front>
<front id="pins_GEN3_PLUSH-31">#define HEATER_0_PIN       12 // (extruder)</front>
<front id="pins_GEN3_PLUSH-32"></front>
<front id="pins_GEN3_PLUSH-33">#define HEATER_BED_PIN     16 // (bed)</front>
<front id="pins_GEN3_PLUSH-34">#define X_ENABLE_PIN       19</front>
<front id="pins_GEN3_PLUSH-35">#define Y_ENABLE_PIN       24</front>
<front id="pins_GEN3_PLUSH-36">#define Z_ENABLE_PIN       29</front>
<front id="pins_GEN3_PLUSH-37">#define E0_ENABLE_PIN      13</front>
<front id="pins_GEN3_PLUSH-38"></front>
<front id="pins_GEN3_PLUSH-39">#define TEMP_0_PIN          0   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)</front>
<front id="pins_GEN3_PLUSH-40">#define TEMP_1_PIN         -1   </front>
<front id="pins_GEN3_PLUSH-41">#define TEMP_2_PIN         -1</front>
<front id="pins_GEN3_PLUSH-42">#define TEMP_BED_PIN        5   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)  </front>
<front id="pins_GEN3_PLUSH-43">#define SDPOWER            -1</front>
<front id="pins_GEN3_PLUSH-44">#define SDSS               4</front>
<front id="pins_GEN3_PLUSH-45">#define HEATER_2_PIN       -1</front>
 </pre>
<h1 id="pins_GEN6Htitle" >pins_GEN6.h</h1>
<pre id="pins_GEN6H"  class="prettyprint linenums"><front id="pins_GEN6H-1">/**</front>
<front id="pins_GEN6H-2"> * Gen6 pin assignments</front>
<front id="pins_GEN6H-3"> */</front>
<front id="pins_GEN6H-4"></front>
<front id="pins_GEN6H-5">#ifndef __AVR_ATmega644P__</front>
<front id="pins_GEN6H-6">  #ifndef __AVR_ATmega1284P__</front>
<front id="pins_GEN6H-7">    #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_GEN6H-8">  #endif</front>
<front id="pins_GEN6H-9">#endif</front>
<front id="pins_GEN6H-10"></front>
<front id="pins_GEN6H-11">//x axis pins</front>
<front id="pins_GEN6H-12">#define X_STEP_PIN      15</front>
<front id="pins_GEN6H-13">#define X_DIR_PIN       18</front>
<front id="pins_GEN6H-14">#define X_ENABLE_PIN    19</front>
<front id="pins_GEN6H-15">#define X_STOP_PIN      20</front>
<front id="pins_GEN6H-16"></front>
<front id="pins_GEN6H-17">//y axis pins</front>
<front id="pins_GEN6H-18">#define Y_STEP_PIN      23</front>
<front id="pins_GEN6H-19">#define Y_DIR_PIN       22</front>
<front id="pins_GEN6H-20">#define Y_ENABLE_PIN    24</front>
<front id="pins_GEN6H-21">#define Y_STOP_PIN      25</front>
<front id="pins_GEN6H-22"></front>
<front id="pins_GEN6H-23">//z axis pins</front>
<front id="pins_GEN6H-24">#define Z_STEP_PIN      27</front>
<front id="pins_GEN6H-25">#define Z_DIR_PIN       28</front>
<front id="pins_GEN6H-26">#define Z_ENABLE_PIN    29</front>
<front id="pins_GEN6H-27">#define Z_STOP_PIN      30</front>
<front id="pins_GEN6H-28"></front>
<front id="pins_GEN6H-29">//extruder pins</front>
<front id="pins_GEN6H-30">#define E0_STEP_PIN      4    //Edited @ EJE Electronics 20100715</front>
<front id="pins_GEN6H-31">#define E0_DIR_PIN       2    //Edited @ EJE Electronics 20100715</front>
<front id="pins_GEN6H-32">#define E0_ENABLE_PIN    3    //Added @ EJE Electronics 20100715</front>
<front id="pins_GEN6H-33">#define TEMP_0_PIN      5     //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-34">#define TEMP_1_PIN      -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-35"></front>
<front id="pins_GEN6H-36"></front>
<front id="pins_GEN6H-37">#define TEMP_2_PIN      -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-38">#define HEATER_0_PIN    14    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-39">#define HEATER_1_PIN    -1</front>
<front id="pins_GEN6H-40">#define HEATER_2_PIN    -1</front>
<front id="pins_GEN6H-41"></front>
<front id="pins_GEN6H-42">#if MB(GEN6)</front>
<front id="pins_GEN6H-43">  #define HEATER_BED_PIN  -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-44">  #define TEMP_BED_PIN    -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-45">#else</front>
<front id="pins_GEN6H-46">  #define HEATER_BED_PIN   1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-47">  #define TEMP_BED_PIN     0    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-48">#endif</front>
<front id="pins_GEN6H-49"></front>
<front id="pins_GEN6H-50">#define SDPOWER          -1</front>
<front id="pins_GEN6H-51">#define SDSS          17</front>
<front id="pins_GEN6H-52">#define LED_PIN         -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-53">#define FAN_PIN         -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-54">#define PS_ON_PIN       -1    //changed @ rkoeppl 20110410</front>
<front id="pins_GEN6H-55">#define KILL_PIN        -1    //changed @ drakelive 20120830</front>
<front id="pins_GEN6H-56">//our pin for debugging.</front>
<front id="pins_GEN6H-57"></front>
<front id="pins_GEN6H-58">#define DEBUG_PIN        0</front>
<front id="pins_GEN6H-59"></front>
<front id="pins_GEN6H-60">//our RS485 pins</front>
<front id="pins_GEN6H-61">#define TX_ENABLE_PIN 12</front>
<front id="pins_GEN6H-62">#define RX_ENABLE_PIN 13</front>
 </pre>
<h1 id="pins_GEN6_DELUXEHtitle" >pins_GEN6_DELUXE.h</h1>
<pre id="pins_GEN6_DELUXEH"  class="prettyprint linenums"><front id="pins_GEN6_DELUXEH-1">/**</front>
<front id="pins_GEN6_DELUXEH-2"> * Gen6 Deluxe pin assignments</front>
<front id="pins_GEN6_DELUXEH-3"> */</front>
<front id="pins_GEN6_DELUXEH-4"></front>
<front id="pins_GEN6_DELUXEH-5">#include "pins_GEN6.h"</front>
 </pre>
<h1 id="pins_GEN7_12Htitle" >pins_GEN7_12.h</h1>
<pre id="pins_GEN7_12H"  class="prettyprint linenums"><front id="pins_GEN7_12H-1">/**</front>
<front id="pins_GEN7_12H-2"> * Gen7 v1.1, v1.2, v1.3 pin assignments</front>
<front id="pins_GEN7_12H-3"> */</front>
<front id="pins_GEN7_12H-4"></front>
<front id="pins_GEN7_12H-5">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pins_GEN7_12H-6">  #error Oops!  Make sure you have 'Gen7' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_GEN7_12H-7">#endif</front>
<front id="pins_GEN7_12H-8"></front>
<front id="pins_GEN7_12H-9">#ifndef GEN7_VERSION</front>
<front id="pins_GEN7_12H-10">  #define GEN7_VERSION 12 // v1.x</front>
<front id="pins_GEN7_12H-11">#endif</front>
<front id="pins_GEN7_12H-12"></front>
<front id="pins_GEN7_12H-13">//x axis pins</front>
<front id="pins_GEN7_12H-14">#define X_STEP_PIN 19</front>
<front id="pins_GEN7_12H-15">#define X_DIR_PIN 18</front>
<front id="pins_GEN7_12H-16">#define X_ENABLE_PIN 24</front>
<front id="pins_GEN7_12H-17">#define X_STOP_PIN 7</front>
<front id="pins_GEN7_12H-18"></front>
<front id="pins_GEN7_12H-19">//y axis pins</front>
<front id="pins_GEN7_12H-20">#define Y_STEP_PIN 23</front>
<front id="pins_GEN7_12H-21">#define Y_DIR_PIN 22</front>
<front id="pins_GEN7_12H-22">#define Y_ENABLE_PIN 24</front>
<front id="pins_GEN7_12H-23">#define Y_STOP_PIN 5</front>
<front id="pins_GEN7_12H-24"></front>
<front id="pins_GEN7_12H-25">//z axis pins</front>
<front id="pins_GEN7_12H-26">#define Z_STEP_PIN 26</front>
<front id="pins_GEN7_12H-27">#define Z_DIR_PIN 25</front>
<front id="pins_GEN7_12H-28">#define Z_ENABLE_PIN 24</front>
<front id="pins_GEN7_12H-29">#define Z_MIN_PIN 1</front>
<front id="pins_GEN7_12H-30">#define Z_MAX_PIN 0</front>
<front id="pins_GEN7_12H-31"></front>
<front id="pins_GEN7_12H-32">//extruder pins</front>
<front id="pins_GEN7_12H-33">#define E0_STEP_PIN 28</front>
<front id="pins_GEN7_12H-34">#define E0_DIR_PIN 27</front>
<front id="pins_GEN7_12H-35">#define E0_ENABLE_PIN 24</front>
<front id="pins_GEN7_12H-36"></front>
<front id="pins_GEN7_12H-37">#define TEMP_0_PIN 1</front>
<front id="pins_GEN7_12H-38">#define TEMP_1_PIN -1</front>
<front id="pins_GEN7_12H-39">#define TEMP_2_PIN -1</front>
<front id="pins_GEN7_12H-40">#define TEMP_BED_PIN 2</front>
<front id="pins_GEN7_12H-41"></front>
<front id="pins_GEN7_12H-42">#define HEATER_0_PIN 4</front>
<front id="pins_GEN7_12H-43">#define HEATER_1_PIN -1</front>
<front id="pins_GEN7_12H-44">#define HEATER_2_PIN -1</front>
<front id="pins_GEN7_12H-45">#define HEATER_BED_PIN 3</front>
<front id="pins_GEN7_12H-46"></front>
<front id="pins_GEN7_12H-47">#define KILL_PIN -1</front>
<front id="pins_GEN7_12H-48"></front>
<front id="pins_GEN7_12H-49">#define SDPOWER -1</front>
<front id="pins_GEN7_12H-50">#define SDSS -1 // SCL pin of I2C header</front>
<front id="pins_GEN7_12H-51">#define LED_PIN -1</front>
<front id="pins_GEN7_12H-52"></front>
<front id="pins_GEN7_12H-53">#if (GEN7_VERSION &gt;= 13)</front>
<front id="pins_GEN7_12H-54">  // Gen7 v1.3 removed the fan pin</front>
<front id="pins_GEN7_12H-55">  #define FAN_PIN -1</front>
<front id="pins_GEN7_12H-56">#else</front>
<front id="pins_GEN7_12H-57">  #define FAN_PIN 31</front>
<front id="pins_GEN7_12H-58">#endif</front>
<front id="pins_GEN7_12H-59"></front>
<front id="pins_GEN7_12H-60">#define PS_ON_PIN 15</front>
<front id="pins_GEN7_12H-61"></front>
<front id="pins_GEN7_12H-62">//All these generations of Gen7 supply thermistor power</front>
<front id="pins_GEN7_12H-63">//via PS_ON, so ignore bad thermistor readings</front>
<front id="pins_GEN7_12H-64">#define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="pins_GEN7_12H-65"></front>
<front id="pins_GEN7_12H-66">//our pin for debugging.</front>
<front id="pins_GEN7_12H-67">#define DEBUG_PIN 0</front>
<front id="pins_GEN7_12H-68"></front>
<front id="pins_GEN7_12H-69">//our RS485 pins</front>
<front id="pins_GEN7_12H-70">#define TX_ENABLE_PIN 12</front>
<front id="pins_GEN7_12H-71">#define RX_ENABLE_PIN 13</front>
<front id="pins_GEN7_12H-72"></front>
 </pre>
<h1 id="pins_GEN7_13Htitle" >pins_GEN7_13.h</h1>
<pre id="pins_GEN7_13H"  class="prettyprint linenums"><front id="pins_GEN7_13H-1">/**</front>
<front id="pins_GEN7_13H-2"> * Gen7 v1.3 pin assignments</front>
<front id="pins_GEN7_13H-3"> */</front>
<front id="pins_GEN7_13H-4"></front>
<front id="pins_GEN7_13H-5">#define MOTHERBOARD BOARD_GEN7_12</front>
<front id="pins_GEN7_13H-6">#define GEN7_VERSION 13 // v1.3</front>
<front id="pins_GEN7_13H-7"></front>
<front id="pins_GEN7_13H-8">#include "pins_GEN7_12.h"</front>
 </pre>
<h1 id="pins_GEN7_14Htitle" >pins_GEN7_14.h</h1>
<pre id="pins_GEN7_14H"  class="prettyprint linenums"><front id="pins_GEN7_14H-1">/**</front>
<front id="pins_GEN7_14H-2"> * Gen7 v1.4 pin assignments</front>
<front id="pins_GEN7_14H-3"> */</front>
<front id="pins_GEN7_14H-4"></front>
<front id="pins_GEN7_14H-5">#define GEN7_VERSION 14 // v1.4</front>
<front id="pins_GEN7_14H-6"></front>
<front id="pins_GEN7_14H-7">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pins_GEN7_14H-8">  #error Oops!  Make sure you have 'Gen7' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_GEN7_14H-9">#endif</front>
<front id="pins_GEN7_14H-10"></front>
<front id="pins_GEN7_14H-11">//x axis pins</front>
<front id="pins_GEN7_14H-12">#define X_STEP_PIN 29</front>
<front id="pins_GEN7_14H-13">#define X_DIR_PIN 28</front>
<front id="pins_GEN7_14H-14">#define X_ENABLE_PIN 25</front>
<front id="pins_GEN7_14H-15">#define X_STOP_PIN 0</front>
<front id="pins_GEN7_14H-16"></front>
<front id="pins_GEN7_14H-17">//y axis pins</front>
<front id="pins_GEN7_14H-18">#define Y_STEP_PIN 27</front>
<front id="pins_GEN7_14H-19">#define Y_DIR_PIN 26</front>
<front id="pins_GEN7_14H-20">#define Y_ENABLE_PIN 25</front>
<front id="pins_GEN7_14H-21">#define Y_STOP_PIN 1</front>
<front id="pins_GEN7_14H-22"></front>
<front id="pins_GEN7_14H-23">//z axis pins</front>
<front id="pins_GEN7_14H-24">#define Z_STEP_PIN 23</front>
<front id="pins_GEN7_14H-25">#define Z_DIR_PIN 22</front>
<front id="pins_GEN7_14H-26">#define Z_ENABLE_PIN 25</front>
<front id="pins_GEN7_14H-27">#define Z_STOP_PIN 2</front>
<front id="pins_GEN7_14H-28"></front>
<front id="pins_GEN7_14H-29">//extruder pins</front>
<front id="pins_GEN7_14H-30">#define E0_STEP_PIN 19</front>
<front id="pins_GEN7_14H-31">#define E0_DIR_PIN 18</front>
<front id="pins_GEN7_14H-32">#define E0_ENABLE_PIN 25</front>
<front id="pins_GEN7_14H-33"></front>
<front id="pins_GEN7_14H-34">#define TEMP_0_PIN 1</front>
<front id="pins_GEN7_14H-35">#define TEMP_1_PIN -1</front>
<front id="pins_GEN7_14H-36">#define TEMP_2_PIN -1</front>
<front id="pins_GEN7_14H-37">#define TEMP_BED_PIN 0</front>
<front id="pins_GEN7_14H-38"></front>
<front id="pins_GEN7_14H-39">#define HEATER_0_PIN 4</front>
<front id="pins_GEN7_14H-40">#define HEATER_1_PIN -1</front>
<front id="pins_GEN7_14H-41">#define HEATER_2_PIN -1</front>
<front id="pins_GEN7_14H-42">#define HEATER_BED_PIN 3</front>
<front id="pins_GEN7_14H-43"></front>
<front id="pins_GEN7_14H-44">#define KILL_PIN -1</front>
<front id="pins_GEN7_14H-45"></front>
<front id="pins_GEN7_14H-46">#define SDPOWER -1</front>
<front id="pins_GEN7_14H-47">#define SDSS -1 // SCL pin of I2C header</front>
<front id="pins_GEN7_14H-48">#define LED_PIN -1</front>
<front id="pins_GEN7_14H-49"></front>
<front id="pins_GEN7_14H-50">#define FAN_PIN -1</front>
<front id="pins_GEN7_14H-51"></front>
<front id="pins_GEN7_14H-52">#define PS_ON_PIN 15</front>
<front id="pins_GEN7_14H-53"></front>
<front id="pins_GEN7_14H-54">//our pin for debugging.</front>
<front id="pins_GEN7_14H-55">#define DEBUG_PIN 0</front>
<front id="pins_GEN7_14H-56"></front>
<front id="pins_GEN7_14H-57">//our RS485 pins</front>
<front id="pins_GEN7_14H-58">#define TX_ENABLE_PIN 12</front>
<front id="pins_GEN7_14H-59">#define RX_ENABLE_PIN 13</front>
<front id="pins_GEN7_14H-60"></front>
 </pre>
<h1 id="pins_GEN7_CUSTOMHtitle" >pins_GEN7_CUSTOM.h</h1>
<pre id="pins_GEN7_CUSTOMH"  class="prettyprint linenums"><front id="pins_GEN7_CUSTOMH-1">/**</front>
<front id="pins_GEN7_CUSTOMH-2"> * Gen7 Alfons3 board pin assignments</front>
<front id="pins_GEN7_CUSTOMH-3"> *</front>
<front id="pins_GEN7_CUSTOMH-4"> * These Pins are assigned for the modified GEN7 Board from Alfons3.</front>
<front id="pins_GEN7_CUSTOMH-5"> * Please review the pins and adjust them for your needs.</front>
<front id="pins_GEN7_CUSTOMH-6"> */ </front>
<front id="pins_GEN7_CUSTOMH-7"></front>
<front id="pins_GEN7_CUSTOMH-8">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pins_GEN7_CUSTOMH-9">  #error Oops!  Make sure you have 'Gen7' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_GEN7_CUSTOMH-10">#endif</front>
<front id="pins_GEN7_CUSTOMH-11"></front>
<front id="pins_GEN7_CUSTOMH-12">//x axis pins</front>
<front id="pins_GEN7_CUSTOMH-13">#define X_STEP_PIN      21                  // different from standard GEN7</front>
<front id="pins_GEN7_CUSTOMH-14">#define X_DIR_PIN       20                  // different from standard GEN7</front>
<front id="pins_GEN7_CUSTOMH-15">#define X_ENABLE_PIN    24</front>
<front id="pins_GEN7_CUSTOMH-16">#define X_STOP_PIN       0</front>
<front id="pins_GEN7_CUSTOMH-17"></front>
<front id="pins_GEN7_CUSTOMH-18">//y axis pins</front>
<front id="pins_GEN7_CUSTOMH-19">#define Y_STEP_PIN      23</front>
<front id="pins_GEN7_CUSTOMH-20">#define Y_DIR_PIN       22</front>
<front id="pins_GEN7_CUSTOMH-21">#define Y_ENABLE_PIN    24</front>
<front id="pins_GEN7_CUSTOMH-22">#define Y_STOP_PIN       1</front>
<front id="pins_GEN7_CUSTOMH-23"></front>
<front id="pins_GEN7_CUSTOMH-24">//z axis pins</front>
<front id="pins_GEN7_CUSTOMH-25">#define Z_STEP_PIN      26</front>
<front id="pins_GEN7_CUSTOMH-26">#define Z_DIR_PIN       25</front>
<front id="pins_GEN7_CUSTOMH-27">#define Z_ENABLE_PIN    24</front>
<front id="pins_GEN7_CUSTOMH-28">#define Z_STOP_PIN       2</front>
<front id="pins_GEN7_CUSTOMH-29"></front>
<front id="pins_GEN7_CUSTOMH-30">//extruder pins</front>
<front id="pins_GEN7_CUSTOMH-31">#define E0_STEP_PIN     28</front>
<front id="pins_GEN7_CUSTOMH-32">#define E0_DIR_PIN      27</front>
<front id="pins_GEN7_CUSTOMH-33">#define E0_ENABLE_PIN   24</front>
<front id="pins_GEN7_CUSTOMH-34"></front>
<front id="pins_GEN7_CUSTOMH-35">#define TEMP_0_PIN       2</front>
<front id="pins_GEN7_CUSTOMH-36">#define TEMP_1_PIN      -1</front>
<front id="pins_GEN7_CUSTOMH-37">#define TEMP_2_PIN      -1</front>
<front id="pins_GEN7_CUSTOMH-38">#define TEMP_BED_PIN     1   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)</front>
<front id="pins_GEN7_CUSTOMH-39"></front>
<front id="pins_GEN7_CUSTOMH-40">#define HEATER_0_PIN     4</front>
<front id="pins_GEN7_CUSTOMH-41">#define HEATER_1_PIN    -1</front>
<front id="pins_GEN7_CUSTOMH-42">#define HEATER_2_PIN    -1</front>
<front id="pins_GEN7_CUSTOMH-43">#define HEATER_BED_PIN   3  // (bed)</front>
<front id="pins_GEN7_CUSTOMH-44"></front>
<front id="pins_GEN7_CUSTOMH-45">#define SDPOWER         -1</front>
<front id="pins_GEN7_CUSTOMH-46">#define SDSS            31                  // SCL pin of I2C header || CS Pin for SD Card support</front>
<front id="pins_GEN7_CUSTOMH-47">#define LED_PIN         -1</front>
<front id="pins_GEN7_CUSTOMH-48"></front>
<front id="pins_GEN7_CUSTOMH-49">#define FAN_PIN         -1</front>
<front id="pins_GEN7_CUSTOMH-50">#define PS_ON_PIN       19</front>
<front id="pins_GEN7_CUSTOMH-51">//our pin for debugging.</front>
<front id="pins_GEN7_CUSTOMH-52"></front>
<front id="pins_GEN7_CUSTOMH-53">#define DEBUG_PIN       -1</front>
<front id="pins_GEN7_CUSTOMH-54"></front>
<front id="pins_GEN7_CUSTOMH-55">//our RS485 pins</front>
<front id="pins_GEN7_CUSTOMH-56">//#define TX_ENABLE_PIN       12</front>
<front id="pins_GEN7_CUSTOMH-57">//#define RX_ENABLE_PIN       13</front>
<front id="pins_GEN7_CUSTOMH-58"></front>
<front id="pins_GEN7_CUSTOMH-59">#define BEEPER_PIN       -1</front>
<front id="pins_GEN7_CUSTOMH-60">#define SD_DETECT_PIN    -1</front>
<front id="pins_GEN7_CUSTOMH-61">#define SUICIDE_PIN      -1    //has to be defined; otherwise Power_off doesn't work</front>
<front id="pins_GEN7_CUSTOMH-62"></front>
<front id="pins_GEN7_CUSTOMH-63">#define KILL_PIN -1</front>
<front id="pins_GEN7_CUSTOMH-64">//Pins for 4bit LCD Support</front>
<front id="pins_GEN7_CUSTOMH-65">#define LCD_PINS_RS 18</front>
<front id="pins_GEN7_CUSTOMH-66">#define LCD_PINS_ENABLE 17</front>
<front id="pins_GEN7_CUSTOMH-67">#define LCD_PINS_D4 16</front>
<front id="pins_GEN7_CUSTOMH-68">#define LCD_PINS_D5 15</front>
<front id="pins_GEN7_CUSTOMH-69">#define LCD_PINS_D6 13</front>
<front id="pins_GEN7_CUSTOMH-70">#define LCD_PINS_D7 14</front>
<front id="pins_GEN7_CUSTOMH-71"></front>
<front id="pins_GEN7_CUSTOMH-72">//buttons are directly attached</front>
<front id="pins_GEN7_CUSTOMH-73">#define BTN_EN1 11</front>
<front id="pins_GEN7_CUSTOMH-74">#define BTN_EN2 10</front>
<front id="pins_GEN7_CUSTOMH-75">#define BTN_ENC 12  //the click</front>
<front id="pins_GEN7_CUSTOMH-76"></front>
 </pre>
<h1 id="pins_K8200Htitle" >pins_K8200.h</h1>
<pre id="pins_K8200H"  class="prettyprint linenums"><front id="pins_K8200H-1">/**</front>
<front id="pins_K8200H-2"> * K8200 Arduino Mega with RAMPS v1.3 pin assignments</front>
<front id="pins_K8200H-3"> * Identical to 3DRAG</front>
<front id="pins_K8200H-4"> */</front>
<front id="pins_K8200H-5"></front>
<front id="pins_K8200H-6">#include "pins_3DRAG.h"</front>
 </pre>
<h1 id="pins_LEAPFROGHtitle" >pins_LEAPFROG.h</h1>
<pre id="pins_LEAPFROGH"  class="prettyprint linenums"><front id="pins_LEAPFROGH-1">/**</front>
<front id="pins_LEAPFROGH-2"> * Leapfrog Driver board pin assignments</front>
<front id="pins_LEAPFROGH-3"> */</front>
<front id="pins_LEAPFROGH-4"></front>
<front id="pins_LEAPFROGH-5">#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)</front>
<front id="pins_LEAPFROGH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_LEAPFROGH-7">#endif</front>
<front id="pins_LEAPFROGH-8"></front>
<front id="pins_LEAPFROGH-9">#define X_STEP_PIN         28</front>
<front id="pins_LEAPFROGH-10">#define X_DIR_PIN          63</front>
<front id="pins_LEAPFROGH-11">#define X_ENABLE_PIN       29</front>
<front id="pins_LEAPFROGH-12">#define X_MIN_PIN          47</front>
<front id="pins_LEAPFROGH-13">#define X_MAX_PIN          2 //Max endstops default to disabled "-1", set to commented value to enable.</front>
<front id="pins_LEAPFROGH-14"></front>
<front id="pins_LEAPFROGH-15">#define Y_STEP_PIN         14 // A6</front>
<front id="pins_LEAPFROGH-16">#define Y_DIR_PIN          15 // A0</front>
<front id="pins_LEAPFROGH-17">#define Y_ENABLE_PIN       39</front>
<front id="pins_LEAPFROGH-18">#define Y_MIN_PIN          48</front>
<front id="pins_LEAPFROGH-19">#define Y_MAX_PIN          15</front>
<front id="pins_LEAPFROGH-20"></front>
<front id="pins_LEAPFROGH-21">#define Z_STEP_PIN         31 // A2</front>
<front id="pins_LEAPFROGH-22">#define Z_DIR_PIN          32 // A6</front>
<front id="pins_LEAPFROGH-23">#define Z_ENABLE_PIN       30 // A1</front>
<front id="pins_LEAPFROGH-24">#define Z_MIN_PIN          49</front>
<front id="pins_LEAPFROGH-25">#define Z_MAX_PIN          -1</front>
<front id="pins_LEAPFROGH-26"></front>
<front id="pins_LEAPFROGH-27">#define E0_STEP_PIN         34  //34</front>
<front id="pins_LEAPFROGH-28">#define E0_DIR_PIN          35 //35</front>
<front id="pins_LEAPFROGH-29">#define E0_ENABLE_PIN       33 //33</front>
<front id="pins_LEAPFROGH-30"></front>
<front id="pins_LEAPFROGH-31">#define E1_STEP_PIN         37 //37</front>
<front id="pins_LEAPFROGH-32">#define E1_DIR_PIN          40 //40</front>
<front id="pins_LEAPFROGH-33">#define E1_ENABLE_PIN       36 //36</front>
<front id="pins_LEAPFROGH-34"></front>
<front id="pins_LEAPFROGH-35">#define SDPOWER            -1</front>
<front id="pins_LEAPFROGH-36">#define SDSS               11</front>
<front id="pins_LEAPFROGH-37">#define SD_DETECT_PIN      -1 // 10 optional also used as mode pin</front>
<front id="pins_LEAPFROGH-38">#define LED_PIN            13</front>
<front id="pins_LEAPFROGH-39">#define FAN_PIN            7</front>
<front id="pins_LEAPFROGH-40">#define PS_ON_PIN          -1</front>
<front id="pins_LEAPFROGH-41">#define KILL_PIN           -1</front>
<front id="pins_LEAPFROGH-42">#define SOL1_PIN   16</front>
<front id="pins_LEAPFROGH-43">#define SOL2_PIN    17</front>
<front id="pins_LEAPFROGH-44"></front>
<front id="pins_LEAPFROGH-45">#define HEATER_0_PIN       9</front>
<front id="pins_LEAPFROGH-46">#define HEATER_1_PIN       8 // 12</front>
<front id="pins_LEAPFROGH-47">#define HEATER_2_PIN       11 //-1 // 13</front>
<front id="pins_LEAPFROGH-48">#define TEMP_0_PIN         13 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_LEAPFROGH-49">#define TEMP_1_PIN         15 // 1</front>
<front id="pins_LEAPFROGH-50">#define TEMP_2_PIN         -1 // 2</front>
<front id="pins_LEAPFROGH-51">#define HEATER_BED_PIN     10 // 14/15</front>
<front id="pins_LEAPFROGH-52">#define TEMP_BED_PIN       14 // 1,2 or I2C</front>
<front id="pins_LEAPFROGH-53">/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */</front>
<front id="pins_LEAPFROGH-54"></front>
 </pre>
<h1 id="pins_MEGACONTROLLERHtitle" >pins_MEGACONTROLLER.h</h1>
<pre id="pins_MEGACONTROLLERH"  class="prettyprint linenums"><front id="pins_MEGACONTROLLERH-1">/**</front>
<front id="pins_MEGACONTROLLERH-2"> * Mega controller pin assignments</front>
<front id="pins_MEGACONTROLLERH-3"> */</front>
<front id="pins_MEGACONTROLLERH-4"></front>
<front id="pins_MEGACONTROLLERH-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_MEGACONTROLLERH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_MEGACONTROLLERH-7">#endif</front>
<front id="pins_MEGACONTROLLERH-8"></front>
<front id="pins_MEGACONTROLLERH-9">#if EXTRUDERS &gt; 2</front>
<front id="pins_MEGACONTROLLERH-10">  #error Mega Controller supports up to 2 extruders. Comment this line to keep going.</front>
<front id="pins_MEGACONTROLLERH-11">#endif</front>
<front id="pins_MEGACONTROLLERH-12"></front>
<front id="pins_MEGACONTROLLERH-13">#define SERVO0_PIN 30</front>
<front id="pins_MEGACONTROLLERH-14">#define SERVO1_PIN 31</front>
<front id="pins_MEGACONTROLLERH-15">#define SERVO2_PIN 32</front>
<front id="pins_MEGACONTROLLERH-16">#define SERVO3_PIN 33</front>
<front id="pins_MEGACONTROLLERH-17"></front>
<front id="pins_MEGACONTROLLERH-18">#define X_STEP_PIN 62//A8</front>
<front id="pins_MEGACONTROLLERH-19">#define X_DIR_PIN 63//A9</front>
<front id="pins_MEGACONTROLLERH-20">#define X_ENABLE_PIN 61//A7</front>
<front id="pins_MEGACONTROLLERH-21">#define X_MIN_PIN 43</front>
<front id="pins_MEGACONTROLLERH-22">#define X_MAX_PIN 42 //Max endstops default to disabled "-1", set to commented value to enable.</front>
<front id="pins_MEGACONTROLLERH-23"></front>
<front id="pins_MEGACONTROLLERH-24">#define Y_STEP_PIN 65 // A11</front>
<front id="pins_MEGACONTROLLERH-25">#define Y_DIR_PIN 66 // A12</front>
<front id="pins_MEGACONTROLLERH-26">#define Y_ENABLE_PIN 64//A10</front>
<front id="pins_MEGACONTROLLERH-27">#define Y_MIN_PIN 38</front>
<front id="pins_MEGACONTROLLERH-28">#define Y_MAX_PIN 41 </front>
<front id="pins_MEGACONTROLLERH-29"></front>
<front id="pins_MEGACONTROLLERH-30">#define Z_STEP_PIN 68 // A14</front>
<front id="pins_MEGACONTROLLERH-31">#define Z_DIR_PIN 69 // A15</front>
<front id="pins_MEGACONTROLLERH-32">#define Z_ENABLE_PIN 67 // A13</front>
<front id="pins_MEGACONTROLLERH-33">#define Z_MIN_PIN 40</front>
<front id="pins_MEGACONTROLLERH-34">#define Z_MAX_PIN 37</front>
<front id="pins_MEGACONTROLLERH-35"></front>
<front id="pins_MEGACONTROLLERH-36">#define E0_STEP_PIN 23</front>
<front id="pins_MEGACONTROLLERH-37">#define E0_DIR_PIN 24</front>
<front id="pins_MEGACONTROLLERH-38">#define E0_ENABLE_PIN 22</front>
<front id="pins_MEGACONTROLLERH-39"></front>
<front id="pins_MEGACONTROLLERH-40">#define E1_STEP_PIN 26</front>
<front id="pins_MEGACONTROLLERH-41">#define E1_DIR_PIN 27</front>
<front id="pins_MEGACONTROLLERH-42">#define E1_ENABLE_PIN 25</front>
<front id="pins_MEGACONTROLLERH-43"></front>
<front id="pins_MEGACONTROLLERH-44">#define SDPOWER -1</front>
<front id="pins_MEGACONTROLLERH-45">#define SDSS 53</front>
<front id="pins_MEGACONTROLLERH-46">#define LED_PIN 13</front>
<front id="pins_MEGACONTROLLERH-47"></front>
<front id="pins_MEGACONTROLLERH-48">#define FAN_PIN 39</front>
<front id="pins_MEGACONTROLLERH-49">#define FAN1_PIN 35</front>
<front id="pins_MEGACONTROLLERH-50">#define FAN2_PIN 36</front>
<front id="pins_MEGACONTROLLERH-51">#define FAN_SOFT_PWM</front>
<front id="pins_MEGACONTROLLERH-52">#define CONTROLLERFAN_PIN 36</front>
<front id="pins_MEGACONTROLLERH-53">#define PS_ON_PIN -1</front>
<front id="pins_MEGACONTROLLERH-54">#define KILL_PIN -1</front>
<front id="pins_MEGACONTROLLERH-55"></front>
<front id="pins_MEGACONTROLLERH-56">#define HEATER_0_PIN 29 // EXTRUDER 1</front>
<front id="pins_MEGACONTROLLERH-57">#define HEATER_1_PIN 34 // EXTRUDER 2</front>
<front id="pins_MEGACONTROLLERH-58">#define HEATER_2_PIN -1</front>
<front id="pins_MEGACONTROLLERH-59"></front>
<front id="pins_MEGACONTROLLERH-60">#if TEMP_SENSOR_0 == -1</front>
<front id="pins_MEGACONTROLLERH-61">  #define TEMP_0_PIN 4 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-62">#else</front>
<front id="pins_MEGACONTROLLERH-63">  #define TEMP_0_PIN 0 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-64">#endif</front>
<front id="pins_MEGACONTROLLERH-65"></front>
<front id="pins_MEGACONTROLLERH-66"></front>
<front id="pins_MEGACONTROLLERH-67">#if TEMP_SENSOR_1 == -1</front>
<front id="pins_MEGACONTROLLERH-68">  #define TEMP_1_PIN 5 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-69">#else</front>
<front id="pins_MEGACONTROLLERH-70">  #define TEMP_1_PIN 2 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-71">#endif</front>
<front id="pins_MEGACONTROLLERH-72"></front>
<front id="pins_MEGACONTROLLERH-73">#define TEMP_2_PIN 3 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-74"></front>
<front id="pins_MEGACONTROLLERH-75">#define HEATER_BED_PIN 28 // BED</front>
<front id="pins_MEGACONTROLLERH-76"></front>
<front id="pins_MEGACONTROLLERH-77">#if TEMP_SENSOR_BED == -1</front>
<front id="pins_MEGACONTROLLERH-78">  #define TEMP_BED_PIN 6 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-79">#else</front>
<front id="pins_MEGACONTROLLERH-80">  #define TEMP_BED_PIN 1 // ANALOG NUMBERING</front>
<front id="pins_MEGACONTROLLERH-81">#endif</front>
<front id="pins_MEGACONTROLLERH-82"></front>
<front id="pins_MEGACONTROLLERH-83">#if ENABLED(MINIPANEL)</front>
<front id="pins_MEGACONTROLLERH-84">    #define BEEPER_PIN 46</front>
<front id="pins_MEGACONTROLLERH-85">    // Pins for DOGM SPI LCD Support</front>
<front id="pins_MEGACONTROLLERH-86">    #define DOGLCD_A0  47</front>
<front id="pins_MEGACONTROLLERH-87">    #define DOGLCD_CS  45</front>
<front id="pins_MEGACONTROLLERH-88">    #define LCD_PIN_BL 44  // backlight LED on PA3</front>
<front id="pins_MEGACONTROLLERH-89">    </front>
<front id="pins_MEGACONTROLLERH-90">    #define KILL_PIN 12</front>
<front id="pins_MEGACONTROLLERH-91">    // GLCD features</front>
<front id="pins_MEGACONTROLLERH-92">    //#define LCD_CONTRAST 190</front>
<front id="pins_MEGACONTROLLERH-93">    // Uncomment screen orientation</front>
<front id="pins_MEGACONTROLLERH-94">      // #define LCD_SCREEN_ROT_90</front>
<front id="pins_MEGACONTROLLERH-95">      // #define LCD_SCREEN_ROT_180</front>
<front id="pins_MEGACONTROLLERH-96">      // #define LCD_SCREEN_ROT_270</front>
<front id="pins_MEGACONTROLLERH-97">    //The encoder and click button</front>
<front id="pins_MEGACONTROLLERH-98">    #define BTN_EN1 48</front>
<front id="pins_MEGACONTROLLERH-99">    #define BTN_EN2 11</front>
<front id="pins_MEGACONTROLLERH-100">    #define BTN_ENC 10  //the click switch</front>
<front id="pins_MEGACONTROLLERH-101">    //not connected to a pin</front>
<front id="pins_MEGACONTROLLERH-102">    #define SD_DETECT_PIN 49</front>
<front id="pins_MEGACONTROLLERH-103">#endif //Minipanel</front>
<front id="pins_MEGACONTROLLERH-104"></front>
 </pre>
<h1 id="pins_MEGATRONICSHtitle" >pins_MEGATRONICS.h</h1>
<pre id="pins_MEGATRONICSH"  class="prettyprint linenums"><front id="pins_MEGATRONICSH-1">/**</front>
<front id="pins_MEGATRONICSH-2"> * MegaTronics pin assignments</front>
<front id="pins_MEGATRONICSH-3"> */</front>
<front id="pins_MEGATRONICSH-4"></front>
<front id="pins_MEGATRONICSH-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_MEGATRONICSH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_MEGATRONICSH-7">#endif</front>
<front id="pins_MEGATRONICSH-8"></front>
<front id="pins_MEGATRONICSH-9">#define LARGE_FLASH        true</front>
<front id="pins_MEGATRONICSH-10"></front>
<front id="pins_MEGATRONICSH-11">#define X_STEP_PIN         26</front>
<front id="pins_MEGATRONICSH-12">#define X_DIR_PIN          28</front>
<front id="pins_MEGATRONICSH-13">#define X_ENABLE_PIN       24</front>
<front id="pins_MEGATRONICSH-14">#define X_MIN_PIN          41</front>
<front id="pins_MEGATRONICSH-15">#define X_MAX_PIN          37</front>
<front id="pins_MEGATRONICSH-16"></front>
<front id="pins_MEGATRONICSH-17">#define Y_STEP_PIN         60 // A6</front>
<front id="pins_MEGATRONICSH-18">#define Y_DIR_PIN          61 // A7</front>
<front id="pins_MEGATRONICSH-19">#define Y_ENABLE_PIN       22</front>
<front id="pins_MEGATRONICSH-20">#define Y_MIN_PIN          14</front>
<front id="pins_MEGATRONICSH-21">#define Y_MAX_PIN          15</front>
<front id="pins_MEGATRONICSH-22"></front>
<front id="pins_MEGATRONICSH-23">#define Z_STEP_PIN         54 // A0</front>
<front id="pins_MEGATRONICSH-24">#define Z_DIR_PIN          55 // A1</front>
<front id="pins_MEGATRONICSH-25">#define Z_ENABLE_PIN       56 // A2</front>
<front id="pins_MEGATRONICSH-26">#define Z_MIN_PIN          18</front>
<front id="pins_MEGATRONICSH-27">#define Z_MAX_PIN          19</front>
<front id="pins_MEGATRONICSH-28"></front>
<front id="pins_MEGATRONICSH-29">#define E0_STEP_PIN        31</front>
<front id="pins_MEGATRONICSH-30">#define E0_DIR_PIN         32</front>
<front id="pins_MEGATRONICSH-31">#define E0_ENABLE_PIN      38</front>
<front id="pins_MEGATRONICSH-32"></front>
<front id="pins_MEGATRONICSH-33">#define E1_STEP_PIN        34</front>
<front id="pins_MEGATRONICSH-34">#define E1_DIR_PIN         36</front>
<front id="pins_MEGATRONICSH-35">#define E1_ENABLE_PIN      30</front>
<front id="pins_MEGATRONICSH-36"></front>
<front id="pins_MEGATRONICSH-37">#define SDPOWER            -1</front>
<front id="pins_MEGATRONICSH-38">#define SDSS               53</front>
<front id="pins_MEGATRONICSH-39">#define LED_PIN            13</front>
<front id="pins_MEGATRONICSH-40"></front>
<front id="pins_MEGATRONICSH-41"></front>
<front id="pins_MEGATRONICSH-42">#define FAN_PIN             7   // IO pin. Buffer needed</front>
<front id="pins_MEGATRONICSH-43">#define PS_ON_PIN          12</front>
<front id="pins_MEGATRONICSH-44">#define KILL_PIN           -1</front>
<front id="pins_MEGATRONICSH-45"></front>
<front id="pins_MEGATRONICSH-46">#define HEATER_0_PIN        9</front>
<front id="pins_MEGATRONICSH-47">#define HEATER_1_PIN        8</front>
<front id="pins_MEGATRONICSH-48">#define HEATER_2_PIN       -1</front>
<front id="pins_MEGATRONICSH-49"></front>
<front id="pins_MEGATRONICSH-50">#if TEMP_SENSOR_0 == -1</front>
<front id="pins_MEGATRONICSH-51">  #define TEMP_0_PIN        8   // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICSH-52">#else</front>
<front id="pins_MEGATRONICSH-53">  #define TEMP_0_PIN       13   // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICSH-54">#endif</front>
<front id="pins_MEGATRONICSH-55"></front>
<front id="pins_MEGATRONICSH-56">#define TEMP_1_PIN         15   // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICSH-57">#define TEMP_2_PIN         -1   // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICSH-58">#define HEATER_BED_PIN     10   // BED</front>
<front id="pins_MEGATRONICSH-59">#define TEMP_BED_PIN       14   // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICSH-60"></front>
<front id="pins_MEGATRONICSH-61">#define BEEPER_PIN         33   // AUX-4</front>
<front id="pins_MEGATRONICSH-62"></front>
<front id="pins_MEGATRONICSH-63">#if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)</front>
<front id="pins_MEGATRONICSH-64"></front>
<front id="pins_MEGATRONICSH-65">  #define LCD_PINS_RS     16</front>
<front id="pins_MEGATRONICSH-66">  #define LCD_PINS_ENABLE 17</front>
<front id="pins_MEGATRONICSH-67">  #define LCD_PINS_D4     23</front>
<front id="pins_MEGATRONICSH-68">  #define LCD_PINS_D5     25</front>
<front id="pins_MEGATRONICSH-69">  #define LCD_PINS_D6     27</front>
<front id="pins_MEGATRONICSH-70">  #define LCD_PINS_D7     29</front>
<front id="pins_MEGATRONICSH-71"></front>
<front id="pins_MEGATRONICSH-72">  // Buttons directly attached using AUX-2</front>
<front id="pins_MEGATRONICSH-73">  #define BTN_EN1         59</front>
<front id="pins_MEGATRONICSH-74">  #define BTN_EN2         64</front>
<front id="pins_MEGATRONICSH-75">  #define BTN_ENC         43</front>
<front id="pins_MEGATRONICSH-76"></front>
<front id="pins_MEGATRONICSH-77">  #define BLEN_C           2</front>
<front id="pins_MEGATRONICSH-78">  #define BLEN_B           1</front>
<front id="pins_MEGATRONICSH-79">  #define BLEN_A           0</front>
<front id="pins_MEGATRONICSH-80"></front>
<front id="pins_MEGATRONICSH-81">  #define SD_DETECT_PIN   -1   // RAMPS doesn't use this</front>
<front id="pins_MEGATRONICSH-82"></front>
<front id="pins_MEGATRONICSH-83">#endif // ULTRA_LCD && NEWPANEL</front>
 </pre>
<h1 id="pins_MEGATRONICS_2Htitle" >pins_MEGATRONICS_2.h</h1>
<pre id="pins_MEGATRONICS_2H"  class="prettyprint linenums"><front id="pins_MEGATRONICS_2H-1">/**</front>
<front id="pins_MEGATRONICS_2H-2"> * MegaTronics v2.0 pin assignments</front>
<front id="pins_MEGATRONICS_2H-3"> */</front>
<front id="pins_MEGATRONICS_2H-4"></front>
<front id="pins_MEGATRONICS_2H-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_MEGATRONICS_2H-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_MEGATRONICS_2H-7">#endif</front>
<front id="pins_MEGATRONICS_2H-8"></front>
<front id="pins_MEGATRONICS_2H-9">#define LARGE_FLASH        true</front>
<front id="pins_MEGATRONICS_2H-10"></front>
<front id="pins_MEGATRONICS_2H-11">#define X_STEP_PIN 26</front>
<front id="pins_MEGATRONICS_2H-12">#define X_DIR_PIN 27</front>
<front id="pins_MEGATRONICS_2H-13">#define X_ENABLE_PIN 25</front>
<front id="pins_MEGATRONICS_2H-14">#define X_MIN_PIN 37</front>
<front id="pins_MEGATRONICS_2H-15">#define X_MAX_PIN 40</front>
<front id="pins_MEGATRONICS_2H-16"></front>
<front id="pins_MEGATRONICS_2H-17">#define Y_STEP_PIN 4 // A6</front>
<front id="pins_MEGATRONICS_2H-18">#define Y_DIR_PIN 54 // A0</front>
<front id="pins_MEGATRONICS_2H-19">#define Y_ENABLE_PIN 5</front>
<front id="pins_MEGATRONICS_2H-20">#define Y_MIN_PIN 41</front>
<front id="pins_MEGATRONICS_2H-21">#define Y_MAX_PIN 38</front>
<front id="pins_MEGATRONICS_2H-22"></front>
<front id="pins_MEGATRONICS_2H-23">#define Z_STEP_PIN 56 // A2</front>
<front id="pins_MEGATRONICS_2H-24">#define Z_DIR_PIN 60 // A6</front>
<front id="pins_MEGATRONICS_2H-25">#define Z_ENABLE_PIN 55 // A1</front>
<front id="pins_MEGATRONICS_2H-26">#define Z_MIN_PIN 18</front>
<front id="pins_MEGATRONICS_2H-27">#define Z_MAX_PIN 19</front>
<front id="pins_MEGATRONICS_2H-28"></front>
<front id="pins_MEGATRONICS_2H-29">#define E0_STEP_PIN 35</front>
<front id="pins_MEGATRONICS_2H-30">#define E0_DIR_PIN 36</front>
<front id="pins_MEGATRONICS_2H-31">#define E0_ENABLE_PIN 34</front>
<front id="pins_MEGATRONICS_2H-32"></front>
<front id="pins_MEGATRONICS_2H-33">#define E1_STEP_PIN 29</front>
<front id="pins_MEGATRONICS_2H-34">#define E1_DIR_PIN 39</front>
<front id="pins_MEGATRONICS_2H-35">#define E1_ENABLE_PIN 28</front>
<front id="pins_MEGATRONICS_2H-36"></front>
<front id="pins_MEGATRONICS_2H-37">#define E2_STEP_PIN 23</front>
<front id="pins_MEGATRONICS_2H-38">#define E2_DIR_PIN 24</front>
<front id="pins_MEGATRONICS_2H-39">#define E2_ENABLE_PIN 22</front>
<front id="pins_MEGATRONICS_2H-40"></front>
<front id="pins_MEGATRONICS_2H-41">#define SDPOWER -1</front>
<front id="pins_MEGATRONICS_2H-42">#define SDSS 53</front>
<front id="pins_MEGATRONICS_2H-43">#define LED_PIN 13</front>
<front id="pins_MEGATRONICS_2H-44"></front>
<front id="pins_MEGATRONICS_2H-45">#define FAN_PIN 7</front>
<front id="pins_MEGATRONICS_2H-46">#define FAN2_PIN 6</front>
<front id="pins_MEGATRONICS_2H-47">#define PS_ON_PIN 12</front>
<front id="pins_MEGATRONICS_2H-48">#define KILL_PIN -1</front>
<front id="pins_MEGATRONICS_2H-49"></front>
<front id="pins_MEGATRONICS_2H-50">#define HEATER_0_PIN 9 // EXTRUDER 1</front>
<front id="pins_MEGATRONICS_2H-51">#define HEATER_1_PIN 8 // EXTRUDER 2</front>
<front id="pins_MEGATRONICS_2H-52">#define HEATER_2_PIN -1</front>
<front id="pins_MEGATRONICS_2H-53"></front>
<front id="pins_MEGATRONICS_2H-54">#if TEMP_SENSOR_0 == -1</front>
<front id="pins_MEGATRONICS_2H-55">  #define TEMP_0_PIN 4 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-56">#else</front>
<front id="pins_MEGATRONICS_2H-57">  #define TEMP_0_PIN 13 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-58">#endif</front>
<front id="pins_MEGATRONICS_2H-59"></front>
<front id="pins_MEGATRONICS_2H-60"></front>
<front id="pins_MEGATRONICS_2H-61">#if TEMP_SENSOR_1 == -1</front>
<front id="pins_MEGATRONICS_2H-62">  #define TEMP_1_PIN 8 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-63">#else</front>
<front id="pins_MEGATRONICS_2H-64">  #define TEMP_1_PIN 15 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-65">#endif</front>
<front id="pins_MEGATRONICS_2H-66"></front>
<front id="pins_MEGATRONICS_2H-67">#define TEMP_2_PIN -1 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-68"></front>
<front id="pins_MEGATRONICS_2H-69">#define HEATER_BED_PIN 10 // BED</front>
<front id="pins_MEGATRONICS_2H-70"></front>
<front id="pins_MEGATRONICS_2H-71">#if TEMP_SENSOR_BED == -1</front>
<front id="pins_MEGATRONICS_2H-72">  #define TEMP_BED_PIN 8 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-73">#else</front>
<front id="pins_MEGATRONICS_2H-74">  #define TEMP_BED_PIN 14 // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_2H-75">#endif</front>
<front id="pins_MEGATRONICS_2H-76"></front>
<front id="pins_MEGATRONICS_2H-77">#define BEEPER_PIN 64</front>
<front id="pins_MEGATRONICS_2H-78"></front>
<front id="pins_MEGATRONICS_2H-79"></front>
<front id="pins_MEGATRONICS_2H-80">#define LCD_PINS_RS 14</front>
<front id="pins_MEGATRONICS_2H-81">#define LCD_PINS_ENABLE 15</front>
<front id="pins_MEGATRONICS_2H-82">#define LCD_PINS_D4 30</front>
<front id="pins_MEGATRONICS_2H-83">#define LCD_PINS_D5 31</front>
<front id="pins_MEGATRONICS_2H-84">#define LCD_PINS_D6 32</front>
<front id="pins_MEGATRONICS_2H-85">#define LCD_PINS_D7 33</front>
<front id="pins_MEGATRONICS_2H-86"></front>
<front id="pins_MEGATRONICS_2H-87"></front>
<front id="pins_MEGATRONICS_2H-88">// Buttons are directly attached using keypad</front>
<front id="pins_MEGATRONICS_2H-89">#define BTN_EN1 61</front>
<front id="pins_MEGATRONICS_2H-90">#define BTN_EN2 59</front>
<front id="pins_MEGATRONICS_2H-91">#define BTN_ENC 43 //the click</front>
<front id="pins_MEGATRONICS_2H-92"></front>
<front id="pins_MEGATRONICS_2H-93">#define BLEN_C 2</front>
<front id="pins_MEGATRONICS_2H-94">#define BLEN_B 1</front>
<front id="pins_MEGATRONICS_2H-95">#define BLEN_A 0</front>
<front id="pins_MEGATRONICS_2H-96"></front>
<front id="pins_MEGATRONICS_2H-97">#define SD_DETECT_PIN -1  // Megatronics doesn't use this</front>
 </pre>
<h1 id="pins_MEGATRONICS_3Htitle" >pins_MEGATRONICS_3.h</h1>
<pre id="pins_MEGATRONICS_3H"  class="prettyprint linenums"><front id="pins_MEGATRONICS_3H-1">/**</front>
<front id="pins_MEGATRONICS_3H-2"> * MegaTronics v3.0 pin assignments</front>
<front id="pins_MEGATRONICS_3H-3"> */</front>
<front id="pins_MEGATRONICS_3H-4"></front>
<front id="pins_MEGATRONICS_3H-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_MEGATRONICS_3H-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_MEGATRONICS_3H-7">#endif</front>
<front id="pins_MEGATRONICS_3H-8"></front>
<front id="pins_MEGATRONICS_3H-9">#define LARGE_FLASH        true</front>
<front id="pins_MEGATRONICS_3H-10"></front>
<front id="pins_MEGATRONICS_3H-11"></front>
<front id="pins_MEGATRONICS_3H-12">#if ENABLED(Z_PROBE_SLED)</front>
<front id="pins_MEGATRONICS_3H-13">  #define SLED_PIN         -1</front>
<front id="pins_MEGATRONICS_3H-14">#endif</front>
<front id="pins_MEGATRONICS_3H-15"></front>
<front id="pins_MEGATRONICS_3H-16">// Servo support</front>
<front id="pins_MEGATRONICS_3H-17">#define SERVO0_PIN         46 //AUX3-6</front>
<front id="pins_MEGATRONICS_3H-18">#define SERVO1_PIN         47 //AUX3-5</front>
<front id="pins_MEGATRONICS_3H-19">#define SERVO2_PIN         48 //AUX3-4</front>
<front id="pins_MEGATRONICS_3H-20">#define SERVO2_PIN         49 //AUX3-3</front>
<front id="pins_MEGATRONICS_3H-21"></front>
<front id="pins_MEGATRONICS_3H-22">#define X_STEP_PIN         58</front>
<front id="pins_MEGATRONICS_3H-23">#define X_DIR_PIN          57</front>
<front id="pins_MEGATRONICS_3H-24">#define X_ENABLE_PIN       59</front>
<front id="pins_MEGATRONICS_3H-25">#define X_MIN_PIN          37</front>
<front id="pins_MEGATRONICS_3H-26">#define X_MAX_PIN          40 // put to -1 to disable  </front>
<front id="pins_MEGATRONICS_3H-27"></front>
<front id="pins_MEGATRONICS_3H-28">#define Y_STEP_PIN         5 </front>
<front id="pins_MEGATRONICS_3H-29">#define Y_DIR_PIN          17 </front>
<front id="pins_MEGATRONICS_3H-30">#define Y_ENABLE_PIN       4</front>
<front id="pins_MEGATRONICS_3H-31">#define Y_MIN_PIN          41</front>
<front id="pins_MEGATRONICS_3H-32">#define Y_MAX_PIN          38 // put to -1 to disable</front>
<front id="pins_MEGATRONICS_3H-33"></front>
<front id="pins_MEGATRONICS_3H-34">#define Z_STEP_PIN         16 </front>
<front id="pins_MEGATRONICS_3H-35">#define Z_DIR_PIN          11</front>
<front id="pins_MEGATRONICS_3H-36">#define Z_ENABLE_PIN       3 </front>
<front id="pins_MEGATRONICS_3H-37">#define Z_MIN_PIN          18</front>
<front id="pins_MEGATRONICS_3H-38">#define Z_MAX_PIN          19 // put to -1 to disable</front>
<front id="pins_MEGATRONICS_3H-39"></front>
<front id="pins_MEGATRONICS_3H-40">#define E0_STEP_PIN        28</front>
<front id="pins_MEGATRONICS_3H-41">#define E0_DIR_PIN         27</front>
<front id="pins_MEGATRONICS_3H-42">#define E0_ENABLE_PIN      29</front>
<front id="pins_MEGATRONICS_3H-43"></front>
<front id="pins_MEGATRONICS_3H-44">#define E1_STEP_PIN        25</front>
<front id="pins_MEGATRONICS_3H-45">#define E1_DIR_PIN         24</front>
<front id="pins_MEGATRONICS_3H-46">#define E1_ENABLE_PIN      26</front>
<front id="pins_MEGATRONICS_3H-47"></front>
<front id="pins_MEGATRONICS_3H-48">#define E2_STEP_PIN        22</front>
<front id="pins_MEGATRONICS_3H-49">#define E2_DIR_PIN         60</front>
<front id="pins_MEGATRONICS_3H-50">#define E2_ENABLE_PIN      23</front>
<front id="pins_MEGATRONICS_3H-51"></front>
<front id="pins_MEGATRONICS_3H-52">#define SDPOWER -1</front>
<front id="pins_MEGATRONICS_3H-53">#define SDSS 53</front>
<front id="pins_MEGATRONICS_3H-54">#define LED_PIN 13</front>
<front id="pins_MEGATRONICS_3H-55"></front>
<front id="pins_MEGATRONICS_3H-56">#define PS_ON_PIN 12</front>
<front id="pins_MEGATRONICS_3H-57">#define KILL_PIN -1</front>
<front id="pins_MEGATRONICS_3H-58"></front>
<front id="pins_MEGATRONICS_3H-59">#define HEATER_0_PIN 2</front>
<front id="pins_MEGATRONICS_3H-60">#define HEATER_1_PIN 9</front>
<front id="pins_MEGATRONICS_3H-61">#define HEATER_2_PIN 8</front>
<front id="pins_MEGATRONICS_3H-62">#define HEATER_BED_PIN 10</front>
<front id="pins_MEGATRONICS_3H-63">#define FAN_PIN 6</front>
<front id="pins_MEGATRONICS_3H-64">#define FAN2_PIN 7</front>
<front id="pins_MEGATRONICS_3H-65"></front>
<front id="pins_MEGATRONICS_3H-66">#define TEMP_0_PIN   (TEMP_SENSOR_0 == -1 ?  11 : 15) // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_3H-67">#define TEMP_1_PIN   (TEMP_SENSOR_1 == -1 ?  10 : 13) // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_3H-68">#define TEMP_2_PIN   (TEMP_SENSOR_2 == -1 ?   9 : 12) // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_3H-69">#define TEMP_BED_PIN (TEMP_SENSOR_BED == -1 ? 8 : 14) // ANALOG NUMBERING</front>
<front id="pins_MEGATRONICS_3H-70"></front>
<front id="pins_MEGATRONICS_3H-71">#define BEEPER_PIN 61</front>
<front id="pins_MEGATRONICS_3H-72"></front>
<front id="pins_MEGATRONICS_3H-73">#define LCD_PINS_RS 32</front>
<front id="pins_MEGATRONICS_3H-74">#define LCD_PINS_ENABLE 31</front>
<front id="pins_MEGATRONICS_3H-75">#define LCD_PINS_D4 14</front>
<front id="pins_MEGATRONICS_3H-76">#define LCD_PINS_D5 30</front>
<front id="pins_MEGATRONICS_3H-77">#define LCD_PINS_D6 39</front>
<front id="pins_MEGATRONICS_3H-78">#define LCD_PINS_D7 15</front>
<front id="pins_MEGATRONICS_3H-79"></front>
<front id="pins_MEGATRONICS_3H-80">#define SHIFT_CLK 43</front>
<front id="pins_MEGATRONICS_3H-81">#define SHIFT_LD 35</front>
<front id="pins_MEGATRONICS_3H-82">#define SHIFT_OUT 34</front>
<front id="pins_MEGATRONICS_3H-83">#define SHIFT_EN 44</front>
<front id="pins_MEGATRONICS_3H-84"></front>
<front id="pins_MEGATRONICS_3H-85">// Buttons are directly attached using keypad</front>
<front id="pins_MEGATRONICS_3H-86">#define BTN_EN1 44</front>
<front id="pins_MEGATRONICS_3H-87">#define BTN_EN2 45</front>
<front id="pins_MEGATRONICS_3H-88">#define BTN_ENC 33 // the click</front>
<front id="pins_MEGATRONICS_3H-89"></front>
<front id="pins_MEGATRONICS_3H-90">#define BLEN_C 2</front>
<front id="pins_MEGATRONICS_3H-91">#define BLEN_B 1</front>
<front id="pins_MEGATRONICS_3H-92">#define BLEN_A 0</front>
<front id="pins_MEGATRONICS_3H-93"></front>
<front id="pins_MEGATRONICS_3H-94">#define SD_DETECT_PIN -1	// Megatronics doesn't use this</front>
 </pre>
<h1 id="pins_MELZIHtitle" >pins_MELZI.h</h1>
<pre id="pins_MELZIH"  class="prettyprint linenums"><front id="pins_MELZIH-1">/**</front>
<front id="pins_MELZIH-2"> * Melzi pin assignments</front>
<front id="pins_MELZIH-3"> */</front>
<front id="pins_MELZIH-4"></front>
<front id="pins_MELZIH-5">#define SANGUINOLOLU_V_1_2</front>
<front id="pins_MELZIH-6"></front>
<front id="pins_MELZIH-7">#if defined(__AVR_ATmega1284P__)</front>
<front id="pins_MELZIH-8">  #define LARGE_FLASH true</front>
<front id="pins_MELZIH-9">#endif</front>
<front id="pins_MELZIH-10"></front>
<front id="pins_MELZIH-11">#include "pins_SANGUINOLOLU_11.h"</front>
 </pre>
<h1 id="pins_MELZI_MAKR3DHtitle" >pins_MELZI_MAKR3D.h</h1>
<pre id="pins_MELZI_MAKR3DH"  class="prettyprint linenums"><front id="pins_MELZI_MAKR3DH-1">/**</front>
<front id="pins_MELZI_MAKR3DH-2"> * Melzi with ATmega1284 (MaKr3d version) pin assignments</front>
<front id="pins_MELZI_MAKR3DH-3"> */</front>
<front id="pins_MELZI_MAKR3DH-4"></front>
<front id="pins_MELZI_MAKR3DH-5">#undef MOTHERBOARD</front>
<front id="pins_MELZI_MAKR3DH-6">#define MOTHERBOARD MELZI</front>
<front id="pins_MELZI_MAKR3DH-7">#define SANGUINOLOLU_V_1_2</front>
<front id="pins_MELZI_MAKR3DH-8"></front>
<front id="pins_MELZI_MAKR3DH-9">#if defined(__AVR_ATmega1284P__)</front>
<front id="pins_MELZI_MAKR3DH-10">  #define LARGE_FLASH true</front>
<front id="pins_MELZI_MAKR3DH-11">#endif</front>
<front id="pins_MELZI_MAKR3DH-12"></front>
<front id="pins_MELZI_MAKR3DH-13">#include "pins_SANGUINOLOLU_11.h"</front>
 </pre>
<h1 id="pins_MINIRAMBOHtitle" >pins_MINIRAMBO.h</h1>
<pre id="pins_MINIRAMBOH"  class="prettyprint linenums"><front id="pins_MINIRAMBOH-1">/**</front>
<front id="pins_MINIRAMBOH-2"> * Mini-Rambo pin assignments</front>
<front id="pins_MINIRAMBOH-3"> */</front>
<front id="pins_MINIRAMBOH-4"></front>
<front id="pins_MINIRAMBOH-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_MINIRAMBOH-6">  #error Oops!  Make sure you have 'Arduino Mega 2560 or Rambo' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_MINIRAMBOH-7">#endif</front>
<front id="pins_MINIRAMBOH-8"></front>
<front id="pins_MINIRAMBOH-9">#define LARGE_FLASH         true</front>
<front id="pins_MINIRAMBOH-10"></front>
<front id="pins_MINIRAMBOH-11"></front>
<front id="pins_MINIRAMBOH-12">#undef X_MS1_PIN</front>
<front id="pins_MINIRAMBOH-13">#undef X_MS2_PIN</front>
<front id="pins_MINIRAMBOH-14">#undef Y_MS1_PIN</front>
<front id="pins_MINIRAMBOH-15">#undef Y_MS2_PIN</front>
<front id="pins_MINIRAMBOH-16">#undef Z_MS1_PIN</front>
<front id="pins_MINIRAMBOH-17">#undef Z_MS2_PIN</front>
<front id="pins_MINIRAMBOH-18">#undef E0_MS1_PIN</front>
<front id="pins_MINIRAMBOH-19">#undef E0_MS2_PIN</front>
<front id="pins_MINIRAMBOH-20">#undef E1_MS1_PIN</front>
<front id="pins_MINIRAMBOH-21">#undef E1_MS2_PIN</front>
<front id="pins_MINIRAMBOH-22"> </front>
<front id="pins_MINIRAMBOH-23">#define X_STEP_PIN          37</front>
<front id="pins_MINIRAMBOH-24">#define X_DIR_PIN           48</front>
<front id="pins_MINIRAMBOH-25">#define X_MIN_PIN           12</front>
<front id="pins_MINIRAMBOH-26">#define X_MAX_PIN           30</front>
<front id="pins_MINIRAMBOH-27">#define X_ENABLE_PIN        29</front>
<front id="pins_MINIRAMBOH-28">#define X_MS1_PIN           40</front>
<front id="pins_MINIRAMBOH-29">#define X_MS2_PIN           41</front>
<front id="pins_MINIRAMBOH-30"></front>
<front id="pins_MINIRAMBOH-31">#define Y_STEP_PIN          36</front>
<front id="pins_MINIRAMBOH-32">#define Y_DIR_PIN           49</front>
<front id="pins_MINIRAMBOH-33">#define Y_MIN_PIN           11</front>
<front id="pins_MINIRAMBOH-34">#define Y_MAX_PIN           24</front>
<front id="pins_MINIRAMBOH-35">#define Y_ENABLE_PIN        28</front>
<front id="pins_MINIRAMBOH-36">#define Y_MS1_PIN           69</front>
<front id="pins_MINIRAMBOH-37">#define Y_MS2_PIN           39</front>
<front id="pins_MINIRAMBOH-38"></front>
<front id="pins_MINIRAMBOH-39">#define Z_STEP_PIN          35</front>
<front id="pins_MINIRAMBOH-40">#define Z_DIR_PIN           47</front>
<front id="pins_MINIRAMBOH-41">#define Z_MIN_PIN           10</front>
<front id="pins_MINIRAMBOH-42">#define Z_MAX_PIN           23</front>
<front id="pins_MINIRAMBOH-43">#define Z_ENABLE_PIN        27</front>
<front id="pins_MINIRAMBOH-44">#define Z_MS1_PIN           68</front>
<front id="pins_MINIRAMBOH-45">#define Z_MS2_PIN           67</front>
<front id="pins_MINIRAMBOH-46"></front>
<front id="pins_MINIRAMBOH-47">#define HEATER_BED_PIN       4</front>
<front id="pins_MINIRAMBOH-48">#define TEMP_BED_PIN         2</front>
<front id="pins_MINIRAMBOH-49"></front>
<front id="pins_MINIRAMBOH-50">#define HEATER_0_PIN         3</front>
<front id="pins_MINIRAMBOH-51">#define TEMP_0_PIN           0</front>
<front id="pins_MINIRAMBOH-52"></front>
<front id="pins_MINIRAMBOH-53">#define HEATER_1_PIN         7</front>
<front id="pins_MINIRAMBOH-54">#define TEMP_1_PIN           1</front>
<front id="pins_MINIRAMBOH-55"></front>
<front id="pins_MINIRAMBOH-56">#if ENABLED(BARICUDA)</front>
<front id="pins_MINIRAMBOH-57">  #define HEATER_2_PIN       6</front>
<front id="pins_MINIRAMBOH-58">#else</front>
<front id="pins_MINIRAMBOH-59">  #define HEATER_2_PIN      -1</front>
<front id="pins_MINIRAMBOH-60">#endif</front>
<front id="pins_MINIRAMBOH-61"></front>
<front id="pins_MINIRAMBOH-62">#define TEMP_2_PIN          -1</front>
<front id="pins_MINIRAMBOH-63"></front>
<front id="pins_MINIRAMBOH-64">#define E0_STEP_PIN         34</front>
<front id="pins_MINIRAMBOH-65">#define E0_DIR_PIN          43</front>
<front id="pins_MINIRAMBOH-66">#define E0_ENABLE_PIN       26</front>
<front id="pins_MINIRAMBOH-67">#define E0_MS1_PIN          65</front>
<front id="pins_MINIRAMBOH-68">#define E0_MS2_PIN          66</front>
<front id="pins_MINIRAMBOH-69"></front>
<front id="pins_MINIRAMBOH-70">#define E1_STEP_PIN         -1</front>
<front id="pins_MINIRAMBOH-71">#define E1_DIR_PIN          -1</front>
<front id="pins_MINIRAMBOH-72">#define E1_ENABLE_PIN       -1</front>
<front id="pins_MINIRAMBOH-73">#define E1_MS1_PIN          -1</front>
<front id="pins_MINIRAMBOH-74">#define E1_MS2_PIN          -1</front>
<front id="pins_MINIRAMBOH-75"></front>
<front id="pins_MINIRAMBOH-76">#define MOTOR_CURRENT_PWM_XY_PIN 46</front>
<front id="pins_MINIRAMBOH-77">#define MOTOR_CURRENT_PWM_Z_PIN  45</front>
<front id="pins_MINIRAMBOH-78">#define MOTOR_CURRENT_PWM_E_PIN  44</front>
<front id="pins_MINIRAMBOH-79">//Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range</front>
<front id="pins_MINIRAMBOH-80">#define MOTOR_CURRENT_PWM_RANGE 2000</front>
<front id="pins_MINIRAMBOH-81">#define DEFAULT_PWM_MOTOR_CURRENT  {1300, 1300, 1250}</front>
<front id="pins_MINIRAMBOH-82">#define SDPOWER             -1</front>
<front id="pins_MINIRAMBOH-83">#define SDSS                53</front>
<front id="pins_MINIRAMBOH-84">#define LED_PIN             13</front>
<front id="pins_MINIRAMBOH-85">#define FAN_PIN              8</front>
<front id="pins_MINIRAMBOH-86">#define FAN_1_PIN            6</front>
<front id="pins_MINIRAMBOH-87">#define PS_ON_PIN           -1</front>
<front id="pins_MINIRAMBOH-88">#define KILL_PIN            -1  // 80 with Smart Controller LCD</front>
<front id="pins_MINIRAMBOH-89">#define SUICIDE_PIN         -1  // PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pins_MINIRAMBOH-90"></front>
<front id="pins_MINIRAMBOH-91">#if ENABLED(ULTRA_LCD)</front>
<front id="pins_MINIRAMBOH-92"></front>
<front id="pins_MINIRAMBOH-93">  #define KILL_PIN          32</front>
<front id="pins_MINIRAMBOH-94"></front>
<front id="pins_MINIRAMBOH-95">  #if ENABLED(NEWPANEL)</front>
<front id="pins_MINIRAMBOH-96"></front>
<front id="pins_MINIRAMBOH-97">    #define BEEPER_PIN      84  // Beeper on AUX-4</front>
<front id="pins_MINIRAMBOH-98">    #define LCD_PINS_RS     82</front>
<front id="pins_MINIRAMBOH-99">    #define LCD_PINS_ENABLE 18</front>
<front id="pins_MINIRAMBOH-100">    #define LCD_PINS_D4     19</front>
<front id="pins_MINIRAMBOH-101">    #define LCD_PINS_D5     70</front>
<front id="pins_MINIRAMBOH-102">    #define LCD_PINS_D6     85</front>
<front id="pins_MINIRAMBOH-103">    #define LCD_PINS_D7     71</front>
<front id="pins_MINIRAMBOH-104"></front>
<front id="pins_MINIRAMBOH-105">    //buttons are directly attached using AUX-2</front>
<front id="pins_MINIRAMBOH-106">    #define BTN_EN1         14</front>
<front id="pins_MINIRAMBOH-107">    #define BTN_EN2         72</front>
<front id="pins_MINIRAMBOH-108">    #define BTN_ENC          9  // the click</front>
<front id="pins_MINIRAMBOH-109"></front>
<front id="pins_MINIRAMBOH-110">    #define SD_DETECT_PIN   15</front>
<front id="pins_MINIRAMBOH-111"></front>
<front id="pins_MINIRAMBOH-112">  #endif //NEWPANEL</front>
<front id="pins_MINIRAMBOH-113">#endif //ULTRA_LCD</front>
 </pre>
<h1 id="pins_MINITRONICSHtitle" >pins_MINITRONICS.h</h1>
<pre id="pins_MINITRONICSH"  class="prettyprint linenums"><front id="pins_MINITRONICSH-1">/**</front>
<front id="pins_MINITRONICSH-2"> * Minitronics v1.0/1.1 pin assignments</front>
<front id="pins_MINITRONICSH-3"> */</front>
<front id="pins_MINITRONICSH-4"></front>
<front id="pins_MINITRONICSH-5">#ifndef __AVR_ATmega1281__</front>
<front id="pins_MINITRONICSH-6">  #error Oops!  Make sure you have 'Minitronics' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_MINITRONICSH-7">#endif</front>
<front id="pins_MINITRONICSH-8"></front>
<front id="pins_MINITRONICSH-9">#define LARGE_FLASH        true</front>
<front id="pins_MINITRONICSH-10"></front>
<front id="pins_MINITRONICSH-11">#define X_STEP_PIN 48</front>
<front id="pins_MINITRONICSH-12">#define X_DIR_PIN 47</front>
<front id="pins_MINITRONICSH-13">#define X_ENABLE_PIN 49</front>
<front id="pins_MINITRONICSH-14">#define X_MIN_PIN 5</front>
<front id="pins_MINITRONICSH-15">#define X_MAX_PIN 2</front>
<front id="pins_MINITRONICSH-16"></front>
<front id="pins_MINITRONICSH-17">#define Y_STEP_PIN 39 // A6</front>
<front id="pins_MINITRONICSH-18">#define Y_DIR_PIN 40 // A0</front>
<front id="pins_MINITRONICSH-19">#define Y_ENABLE_PIN 38</front>
<front id="pins_MINITRONICSH-20">#define Y_MIN_PIN 2</front>
<front id="pins_MINITRONICSH-21">#define Y_MAX_PIN 15</front>
<front id="pins_MINITRONICSH-22"></front>
<front id="pins_MINITRONICSH-23">#define Z_STEP_PIN 42 // A2</front>
<front id="pins_MINITRONICSH-24">#define Z_DIR_PIN 43 // A6</front>
<front id="pins_MINITRONICSH-25">#define Z_ENABLE_PIN 41 // A1</front>
<front id="pins_MINITRONICSH-26">#define Z_MIN_PIN 6</front>
<front id="pins_MINITRONICSH-27">#define Z_MAX_PIN -1</front>
<front id="pins_MINITRONICSH-28"></front>
<front id="pins_MINITRONICSH-29">#define E0_STEP_PIN 45</front>
<front id="pins_MINITRONICSH-30">#define E0_DIR_PIN 44</front>
<front id="pins_MINITRONICSH-31">#define E0_ENABLE_PIN 27</front>
<front id="pins_MINITRONICSH-32"></front>
<front id="pins_MINITRONICSH-33">#define E1_STEP_PIN 36</front>
<front id="pins_MINITRONICSH-34">#define E1_DIR_PIN 35</front>
<front id="pins_MINITRONICSH-35">#define E1_ENABLE_PIN 37</front>
<front id="pins_MINITRONICSH-36"></front>
<front id="pins_MINITRONICSH-37">#define E2_STEP_PIN -1</front>
<front id="pins_MINITRONICSH-38">#define E2_DIR_PIN -1</front>
<front id="pins_MINITRONICSH-39">#define E2_ENABLE_PIN -1</front>
<front id="pins_MINITRONICSH-40"></front>
<front id="pins_MINITRONICSH-41">#define SDPOWER -1</front>
<front id="pins_MINITRONICSH-42">#define SDSS 16</front>
<front id="pins_MINITRONICSH-43">#define LED_PIN 46</front>
<front id="pins_MINITRONICSH-44"></front>
<front id="pins_MINITRONICSH-45">#define FAN_PIN 9</front>
<front id="pins_MINITRONICSH-46">#define FAN2_PIN -1</front>
<front id="pins_MINITRONICSH-47">#define PS_ON_PIN -1</front>
<front id="pins_MINITRONICSH-48">#define KILL_PIN -1</front>
<front id="pins_MINITRONICSH-49"></front>
<front id="pins_MINITRONICSH-50">#define HEATER_0_PIN 7 // EXTRUDER 1</front>
<front id="pins_MINITRONICSH-51">#define HEATER_1_PIN 8 // EXTRUDER 2</front>
<front id="pins_MINITRONICSH-52">#define HEATER_2_PIN -1</front>
<front id="pins_MINITRONICSH-53"></front>
<front id="pins_MINITRONICSH-54"></front>
<front id="pins_MINITRONICSH-55">#define TEMP_0_PIN 7 // ANALOG NUMBERING</front>
<front id="pins_MINITRONICSH-56">#define TEMP_1_PIN 6 // ANALOG NUMBERING</front>
<front id="pins_MINITRONICSH-57">#define TEMP_2_PIN -1 // ANALOG NUMBERING</front>
<front id="pins_MINITRONICSH-58"></front>
<front id="pins_MINITRONICSH-59">#define HEATER_BED_PIN 3 // BED</front>
<front id="pins_MINITRONICSH-60">#define TEMP_BED_PIN 6 // ANALOG NUMBERING</front>
<front id="pins_MINITRONICSH-61"></front>
<front id="pins_MINITRONICSH-62">#define BEEPER_PIN -1</front>
<front id="pins_MINITRONICSH-63"></front>
<front id="pins_MINITRONICSH-64">#define LCD_PINS_RS -1</front>
<front id="pins_MINITRONICSH-65">#define LCD_PINS_ENABLE -1</front>
<front id="pins_MINITRONICSH-66">#define LCD_PINS_D4 -1</front>
<front id="pins_MINITRONICSH-67">#define LCD_PINS_D5 -1</front>
<front id="pins_MINITRONICSH-68">#define LCD_PINS_D6 -1</front>
<front id="pins_MINITRONICSH-69">#define LCD_PINS_D7 -1</front>
<front id="pins_MINITRONICSH-70"></front>
<front id="pins_MINITRONICSH-71"></front>
<front id="pins_MINITRONICSH-72">// Buttons are directly attached using keypad</front>
<front id="pins_MINITRONICSH-73">#define BTN_EN1 -1</front>
<front id="pins_MINITRONICSH-74">#define BTN_EN2 -1</front>
<front id="pins_MINITRONICSH-75">#define BTN_ENC -1 // the click</front>
<front id="pins_MINITRONICSH-76"></front>
<front id="pins_MINITRONICSH-77">#define BLEN_C 2</front>
<front id="pins_MINITRONICSH-78">#define BLEN_B 1</front>
<front id="pins_MINITRONICSH-79">#define BLEN_A 0</front>
<front id="pins_MINITRONICSH-80"></front>
<front id="pins_MINITRONICSH-81">#define SD_DETECT_PIN -1  // Minitronics doesn't use this</front>
 </pre>
<h1 id="pins_MKS_BASEHtitle" >pins_MKS_BASE.h</h1>
<pre id="pins_MKS_BASEH"  class="prettyprint linenums"><front id="pins_MKS_BASEH-1">/**</front>
<front id="pins_MKS_BASEH-2"> * MKS BASE 1.0  Arduino Mega2560 with RAMPS v1.4 pin assignments</front>
<front id="pins_MKS_BASEH-3"> */</front>
<front id="pins_MKS_BASEH-4"></front>
<front id="pins_MKS_BASEH-5">#include "pins_RAMPS_13_EFB.h"</front>
<front id="pins_MKS_BASEH-6"></front>
<front id="pins_MKS_BASEH-7">#undef HEATER_1_PIN</front>
<front id="pins_MKS_BASEH-8">#define HEATER_1_PIN        7</front>
 </pre>
<h1 id="pins_OMCAHtitle" >pins_OMCA.h</h1>
<pre id="pins_OMCAH"  class="prettyprint linenums"><front id="pins_OMCAH-1">/**</front>
<front id="pins_OMCAH-2"> * Open Motion controller with enable based extruders (Final!)</front>
<front id="pins_OMCAH-3"> *</front>
<front id="pins_OMCAH-4"> *                        ATMega644</front>
<front id="pins_OMCAH-5"> *</front>
<front id="pins_OMCAH-6"> *                        +---\/---+</front>
<front id="pins_OMCAH-7"> *            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)</front>
<front id="pins_OMCAH-8"> *            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)</front>
<front id="pins_OMCAH-9"> *       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)</front>
<front id="pins_OMCAH-10"> *        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)</front>
<front id="pins_OMCAH-11"> *        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)</front>
<front id="pins_OMCAH-12"> *       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)</front>
<front id="pins_OMCAH-13"> *       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)</front>
<front id="pins_OMCAH-14"> *        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)</front>
<front id="pins_OMCAH-15"> *                  RST  9|        |32  AREF</front>
<front id="pins_OMCAH-16"> *                  VCC 10|        |31  GND</front>
<front id="pins_OMCAH-17"> *                  GND 11|        |30  AVCC</front>
<front id="pins_OMCAH-18"> *                XTAL2 12|        |29  PC7 (D 23)</front>
<front id="pins_OMCAH-19"> *                XTAL1 13|        |28  PC6 (D 22)</front>
<front id="pins_OMCAH-20"> *       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI</front>
<front id="pins_OMCAH-21"> *       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO</front>
<front id="pins_OMCAH-22"> *  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS</front>
<front id="pins_OMCAH-23"> *  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK</front>
<front id="pins_OMCAH-24"> *       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA</front>
<front id="pins_OMCAH-25"> *       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL</front>
<front id="pins_OMCAH-26"> *       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM</front>
<front id="pins_OMCAH-27"> *                        +--------+</front>
<front id="pins_OMCAH-28"> *</front>
<front id="pins_OMCAH-29"> * REF http://sanguino.cc/hardware</front>
<front id="pins_OMCAH-30"> */</front>
<front id="pins_OMCAH-31"></front>
<front id="pins_OMCAH-32">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__)</front>
<front id="pins_OMCAH-33">  #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu. (Final OMCA board)</front>
<front id="pins_OMCAH-34">#endif</front>
<front id="pins_OMCAH-35"></front>
<front id="pins_OMCAH-36">#define X_STEP_PIN         26</front>
<front id="pins_OMCAH-37">#define X_DIR_PIN          25</front>
<front id="pins_OMCAH-38">#define X_ENABLE_PIN       10</front>
<front id="pins_OMCAH-39">#define X_STOP_PIN         0</front>
<front id="pins_OMCAH-40"></front>
<front id="pins_OMCAH-41">#define Y_STEP_PIN         28</front>
<front id="pins_OMCAH-42">#define Y_DIR_PIN          27</front>
<front id="pins_OMCAH-43">#define Y_ENABLE_PIN       10</front>
<front id="pins_OMCAH-44">#define Y_STOP_PIN         1</front>
<front id="pins_OMCAH-45"></front>
<front id="pins_OMCAH-46">#define Z_STEP_PIN         23</front>
<front id="pins_OMCAH-47">#define Z_DIR_PIN          22</front>
<front id="pins_OMCAH-48">#define Z_ENABLE_PIN       10</front>
<front id="pins_OMCAH-49">#define Z_STOP_PIN         2</front>
<front id="pins_OMCAH-50"></front>
<front id="pins_OMCAH-51">#define E0_STEP_PIN        24</front>
<front id="pins_OMCAH-52">#define E0_DIR_PIN         21</front>
<front id="pins_OMCAH-53">#define E0_ENABLE_PIN      10</front>
<front id="pins_OMCAH-54"></front>
<front id="pins_OMCAH-55">// future proofing</front>
<front id="pins_OMCAH-56">#define __FS  20</front>
<front id="pins_OMCAH-57">#define __FD  19</front>
<front id="pins_OMCAH-58">#define __GS  18</front>
<front id="pins_OMCAH-59">#define __GD  13</front>
<front id="pins_OMCAH-60"></front>
<front id="pins_OMCAH-61">#define UNUSED_PWM         14 // PWM on LEFT connector</front>
<front id="pins_OMCAH-62"></front>
<front id="pins_OMCAH-63">#define E1_STEP_PIN        -1 // 21</front>
<front id="pins_OMCAH-64">#define E1_DIR_PIN         -1 // 20</front>
<front id="pins_OMCAH-65">#define E1_ENABLE_PIN      -1 // 19</front>
<front id="pins_OMCAH-66"></front>
<front id="pins_OMCAH-67">#define E2_STEP_PIN        -1 // 21</front>
<front id="pins_OMCAH-68">#define E2_DIR_PIN         -1 // 20</front>
<front id="pins_OMCAH-69">#define E2_ENABLE_PIN      -1 // 18</front>
<front id="pins_OMCAH-70"></front>
<front id="pins_OMCAH-71">#define SDPOWER            -1</front>
<front id="pins_OMCAH-72">#define SDSS               11</front>
<front id="pins_OMCAH-73">#define SD_DETECT_PIN      -1 // 10 optional also used as mode pin</front>
<front id="pins_OMCAH-74">#define LED_PIN            -1</front>
<front id="pins_OMCAH-75">#define FAN_PIN            14 // PWM on MIDDLE connector</front>
<front id="pins_OMCAH-76">#define PS_ON_PIN          -1</front>
<front id="pins_OMCAH-77">#define KILL_PIN           -1</front>
<front id="pins_OMCAH-78"></front>
<front id="pins_OMCAH-79">#define HEATER_0_PIN        3 // DONE PWM on RIGHT connector</front>
<front id="pins_OMCAH-80">#define HEATER_1_PIN       -1</front>
<front id="pins_OMCAH-81">#define HEATER_2_PIN       -1</front>
<front id="pins_OMCAH-82">#define HEATER_1_PIN       -1</front>
<front id="pins_OMCAH-83">#define HEATER_2_PIN       -1</front>
<front id="pins_OMCAH-84">#define TEMP_0_PIN          0 // ANALOG INPUT NUMBERING</front>
<front id="pins_OMCAH-85">#define TEMP_1_PIN          1 // ANALOG</front>
<front id="pins_OMCAH-86">#define TEMP_2_PIN         -1 // 2</front>
<front id="pins_OMCAH-87">#define HEATER_BED_PIN      4</front>
<front id="pins_OMCAH-88">#define TEMP_BED_PIN        2 // 1,2 or I2C</front>
<front id="pins_OMCAH-89"></front>
<front id="pins_OMCAH-90">#define I2C_SCL            16</front>
<front id="pins_OMCAH-91">#define I2C_SDA            17</front>
<front id="pins_OMCAH-92"></front>
 </pre>
<h1 id="pins_OMCA_AHtitle" >pins_OMCA_A.h</h1>
<pre id="pins_OMCA_AH"  class="prettyprint linenums"><front id="pins_OMCA_AH-1">/**</front>
<front id="pins_OMCA_AH-2"> * Open Motion controller with enable based extruders (Alpha!)</front>
<front id="pins_OMCA_AH-3"> *</front>
<front id="pins_OMCA_AH-4"> *                        ATMega644</front>
<front id="pins_OMCA_AH-5"> *</front>
<front id="pins_OMCA_AH-6"> *                        +---\/---+</front>
<front id="pins_OMCA_AH-7"> *            (D 0) PB0  1|        |40  PA0 (AI 0 / D31)</front>
<front id="pins_OMCA_AH-8"> *            (D 1) PB1  2|        |39  PA1 (AI 1 / D30)</front>
<front id="pins_OMCA_AH-9"> *       INT2 (D 2) PB2  3|        |38  PA2 (AI 2 / D29)</front>
<front id="pins_OMCA_AH-10"> *        PWM (D 3) PB3  4|        |37  PA3 (AI 3 / D28)</front>
<front id="pins_OMCA_AH-11"> *        PWM (D 4) PB4  5|        |36  PA4 (AI 4 / D27)</front>
<front id="pins_OMCA_AH-12"> *       MOSI (D 5) PB5  6|        |35  PA5 (AI 5 / D26)</front>
<front id="pins_OMCA_AH-13"> *       MISO (D 6) PB6  7|        |34  PA6 (AI 6 / D25)</front>
<front id="pins_OMCA_AH-14"> *        SCK (D 7) PB7  8|        |33  PA7 (AI 7 / D24)</front>
<front id="pins_OMCA_AH-15"> *                  RST  9|        |32  AREF</front>
<front id="pins_OMCA_AH-16"> *                  VCC 10|        |31  GND</front>
<front id="pins_OMCA_AH-17"> *                  GND 11|        |30  AVCC</front>
<front id="pins_OMCA_AH-18"> *                XTAL2 12|        |29  PC7 (D 23)</front>
<front id="pins_OMCA_AH-19"> *                XTAL1 13|        |28  PC6 (D 22)</front>
<front id="pins_OMCA_AH-20"> *       RX0 (D 8)  PD0 14|        |27  PC5 (D 21) TDI</front>
<front id="pins_OMCA_AH-21"> *       TX0 (D 9)  PD1 15|        |26  PC4 (D 20) TDO</front>
<front id="pins_OMCA_AH-22"> *  INT0 RX1 (D 10) PD2 16|        |25  PC3 (D 19) TMS</front>
<front id="pins_OMCA_AH-23"> *  INT1 TX1 (D 11) PD3 17|        |24  PC2 (D 18) TCK</front>
<front id="pins_OMCA_AH-24"> *       PWM (D 12) PD4 18|        |23  PC1 (D 17) SDA</front>
<front id="pins_OMCA_AH-25"> *       PWM (D 13) PD5 19|        |22  PC0 (D 16) SCL</front>
<front id="pins_OMCA_AH-26"> *       PWM (D 14) PD6 20|        |21  PD7 (D 15) PWM</front>
<front id="pins_OMCA_AH-27"> *                        +--------+</front>
<front id="pins_OMCA_AH-28"> *</front>
<front id="pins_OMCA_AH-29"> */</front>
<front id="pins_OMCA_AH-30"></front>
<front id="pins_OMCA_AH-31">#ifndef __AVR_ATmega644__</front>
<front id="pins_OMCA_AH-32">  #error Oops!  Make sure you have 'SanguinoA' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_OMCA_AH-33">#endif</front>
<front id="pins_OMCA_AH-34"></front>
<front id="pins_OMCA_AH-35">#define X_STEP_PIN         21</front>
<front id="pins_OMCA_AH-36">#define X_DIR_PIN          20</front>
<front id="pins_OMCA_AH-37">#define X_ENABLE_PIN       24</front>
<front id="pins_OMCA_AH-38">#define X_STOP_PIN          0</front>
<front id="pins_OMCA_AH-39"></front>
<front id="pins_OMCA_AH-40">#define Y_STEP_PIN         23</front>
<front id="pins_OMCA_AH-41">#define Y_DIR_PIN          22</front>
<front id="pins_OMCA_AH-42">#define Y_ENABLE_PIN       24</front>
<front id="pins_OMCA_AH-43">#define Y_STOP_PIN          1</front>
<front id="pins_OMCA_AH-44"></front>
<front id="pins_OMCA_AH-45">#define Z_STEP_PIN         26</front>
<front id="pins_OMCA_AH-46">#define Z_DIR_PIN          25</front>
<front id="pins_OMCA_AH-47">#define Z_ENABLE_PIN       24</front>
<front id="pins_OMCA_AH-48">#define Z_STOP_PIN          2</front>
<front id="pins_OMCA_AH-49"></front>
<front id="pins_OMCA_AH-50">#define E0_STEP_PIN        28</front>
<front id="pins_OMCA_AH-51">#define E0_DIR_PIN         27</front>
<front id="pins_OMCA_AH-52">#define E0_ENABLE_PIN      24</front>
<front id="pins_OMCA_AH-53"></front>
<front id="pins_OMCA_AH-54">#define E1_STEP_PIN        -1 // 19</front>
<front id="pins_OMCA_AH-55">#define E1_DIR_PIN         -1 // 18</front>
<front id="pins_OMCA_AH-56">#define E1_ENABLE_PIN      24</front>
<front id="pins_OMCA_AH-57"></front>
<front id="pins_OMCA_AH-58">#define E2_STEP_PIN        -1 // 17</front>
<front id="pins_OMCA_AH-59">#define E2_DIR_PIN         -1 // 16</front>
<front id="pins_OMCA_AH-60">#define E2_ENABLE_PIN      24</front>
<front id="pins_OMCA_AH-61"></front>
<front id="pins_OMCA_AH-62">#define SDPOWER            -1</front>
<front id="pins_OMCA_AH-63">#define SDSS               11</front>
<front id="pins_OMCA_AH-64">#define SD_DETECT_PIN      -1 // 10 optional also used as mode pin</front>
<front id="pins_OMCA_AH-65">#define LED_PIN            -1</front>
<front id="pins_OMCA_AH-66">#define FAN_PIN             3</front>
<front id="pins_OMCA_AH-67">#define PS_ON_PIN          -1</front>
<front id="pins_OMCA_AH-68">#define KILL_PIN           -1</front>
<front id="pins_OMCA_AH-69"></front>
<front id="pins_OMCA_AH-70">#define HEATER_0_PIN        4</front>
<front id="pins_OMCA_AH-71">#define HEATER_1_PIN       -1 // 12</front>
<front id="pins_OMCA_AH-72">#define HEATER_2_PIN       -1 // 13</front>
<front id="pins_OMCA_AH-73">#define TEMP_0_PIN          0 //D27   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_OMCA_AH-74">#define TEMP_1_PIN         -1 // 1</front>
<front id="pins_OMCA_AH-75">#define TEMP_2_PIN         -1 // 2</front>
<front id="pins_OMCA_AH-76">#define HEATER_BED_PIN     -1 // 14/15</front>
<front id="pins_OMCA_AH-77">#define TEMP_BED_PIN       -1 // 1,2 or I2C</front>
<front id="pins_OMCA_AH-78">/*  Unused (1) (2) (3) 4 5 6 7 8 9 10 11 12 13 (14) (15) (16) 17 (18) (19) (20) (21) (22) (23) 24 (25) (26) (27) 28 (29) (30) (31)  */</front>
 </pre>
<h1 id="pins_PRINTRBOARDHtitle" >pins_PRINTRBOARD.h</h1>
<pre id="pins_PRINTRBOARDH"  class="prettyprint linenums"><front id="pins_PRINTRBOARDH-1">/**</front>
<front id="pins_PRINTRBOARDH-2"> * Printrboard pin assignments (AT90USB1286)</front>
<front id="pins_PRINTRBOARDH-3"> * Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!</front>
<front id="pins_PRINTRBOARDH-4"> * http://www.pjrc.com/teensy/teensyduino.html</front>
<front id="pins_PRINTRBOARDH-5"> * See http://reprap.org/wiki/Printrboard for more info</front>
<front id="pins_PRINTRBOARDH-6"> */</front>
<front id="pins_PRINTRBOARDH-7"></front>
<front id="pins_PRINTRBOARDH-8">#ifndef __AVR_AT90USB1286__</front>
<front id="pins_PRINTRBOARDH-9">  #error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_PRINTRBOARDH-10">#endif</front>
<front id="pins_PRINTRBOARDH-11"></front>
<front id="pins_PRINTRBOARDH-12">#if ENABLED(AT90USBxx_TEENSYPP_ASSIGNMENTS)  // use Teensyduino Teensy++2.0 pin assignments instead of Marlin traditional.</front>
<front id="pins_PRINTRBOARDH-13">  #error These Printrboard assignments depend on traditional Marlin assignments, not AT90USBxx_TEENSYPP_ASSIGNMENTS in fastio.h</front>
<front id="pins_PRINTRBOARDH-14">#endif</front>
<front id="pins_PRINTRBOARDH-15"></front>
<front id="pins_PRINTRBOARDH-16">#define LARGE_FLASH        true</front>
<front id="pins_PRINTRBOARDH-17"></front>
<front id="pins_PRINTRBOARDH-18">#define X_STEP_PIN          0</front>
<front id="pins_PRINTRBOARDH-19">#define X_DIR_PIN           1</front>
<front id="pins_PRINTRBOARDH-20">#define X_ENABLE_PIN       39</front>
<front id="pins_PRINTRBOARDH-21"></front>
<front id="pins_PRINTRBOARDH-22">#define Y_STEP_PIN          2</front>
<front id="pins_PRINTRBOARDH-23">#define Y_DIR_PIN           3</front>
<front id="pins_PRINTRBOARDH-24">#define Y_ENABLE_PIN       38</front>
<front id="pins_PRINTRBOARDH-25"></front>
<front id="pins_PRINTRBOARDH-26">#define Z_STEP_PIN          4</front>
<front id="pins_PRINTRBOARDH-27">#define Z_DIR_PIN           5</front>
<front id="pins_PRINTRBOARDH-28">#define Z_ENABLE_PIN       23</front>
<front id="pins_PRINTRBOARDH-29"></front>
<front id="pins_PRINTRBOARDH-30">#define E0_STEP_PIN         6</front>
<front id="pins_PRINTRBOARDH-31">#define E0_DIR_PIN          7</front>
<front id="pins_PRINTRBOARDH-32">#define E0_ENABLE_PIN      19</front>
<front id="pins_PRINTRBOARDH-33"></front>
<front id="pins_PRINTRBOARDH-34">#define HEATER_0_PIN       21  // Extruder</front>
<front id="pins_PRINTRBOARDH-35">#define HEATER_1_PIN       46</front>
<front id="pins_PRINTRBOARDH-36">#define HEATER_2_PIN       47</front>
<front id="pins_PRINTRBOARDH-37">#define HEATER_BED_PIN     20</front>
<front id="pins_PRINTRBOARDH-38"></front>
<front id="pins_PRINTRBOARDH-39">// If soft or fast PWM is off then use Teensyduino pin numbering, Marlin</front>
<front id="pins_PRINTRBOARDH-40">// fastio pin numbering otherwise</front>
<front id="pins_PRINTRBOARDH-41">#if ENABLED(FAN_SOFT_PWM) || ENABLED(FAST_PWM_FAN)</front>
<front id="pins_PRINTRBOARDH-42">  #define FAN_PIN          22</front>
<front id="pins_PRINTRBOARDH-43">#else</front>
<front id="pins_PRINTRBOARDH-44">  #define FAN_PIN          16</front>
<front id="pins_PRINTRBOARDH-45">#endif</front>
<front id="pins_PRINTRBOARDH-46"></front>
<front id="pins_PRINTRBOARDH-47">#define X_STOP_PIN         35</front>
<front id="pins_PRINTRBOARDH-48">#if ENABLED(SDSUPPORT)</front>
<front id="pins_PRINTRBOARDH-49">  #define Y_STOP_PIN       37 // Move Ystop to Estop socket</front>
<front id="pins_PRINTRBOARDH-50">#else</front>
<front id="pins_PRINTRBOARDH-51">  #define Y_STOP_PIN        8 // Ystop in Ystop socket</front>
<front id="pins_PRINTRBOARDH-52">#endif</front>
<front id="pins_PRINTRBOARDH-53">#define Z_STOP_PIN         36</front>
<front id="pins_PRINTRBOARDH-54">#define TEMP_0_PIN          1  // Extruder / Analog pin numbering</front>
<front id="pins_PRINTRBOARDH-55">#define TEMP_BED_PIN        0  // Bed / Analog pin numbering</front>
<front id="pins_PRINTRBOARDH-56"></front>
<front id="pins_PRINTRBOARDH-57">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="pins_PRINTRBOARDH-58">  #define FILWIDTH_PIN      2</front>
<front id="pins_PRINTRBOARDH-59">#endif</front>
<front id="pins_PRINTRBOARDH-60"></front>
<front id="pins_PRINTRBOARDH-61">#define TEMP_1_PIN         -1</front>
<front id="pins_PRINTRBOARDH-62">#define TEMP_2_PIN         -1</front>
<front id="pins_PRINTRBOARDH-63"></front>
<front id="pins_PRINTRBOARDH-64">////LCD Pin Setup////</front>
<front id="pins_PRINTRBOARDH-65"></front>
<front id="pins_PRINTRBOARDH-66">#define SDPOWER            -1</front>
<front id="pins_PRINTRBOARDH-67">#define SDSS                8</front>
<front id="pins_PRINTRBOARDH-68">#define LED_PIN            -1</front>
<front id="pins_PRINTRBOARDH-69">#define PS_ON_PIN          -1</front>
<front id="pins_PRINTRBOARDH-70">#define KILL_PIN           -1</front>
<front id="pins_PRINTRBOARDH-71">#define ALARM_PIN          -1</front>
<front id="pins_PRINTRBOARDH-72"></front>
<front id="pins_PRINTRBOARDH-73">#if DISABLED(SDSUPPORT)</front>
<front id="pins_PRINTRBOARDH-74">  // these pins are defined in the SD library if building with SD support</front>
<front id="pins_PRINTRBOARDH-75">  #define SCK_PIN           9</front>
<front id="pins_PRINTRBOARDH-76">  #define MISO_PIN         11</front>
<front id="pins_PRINTRBOARDH-77">  #define MOSI_PIN         10</front>
<front id="pins_PRINTRBOARDH-78">#endif</front>
<front id="pins_PRINTRBOARDH-79"></front>
<front id="pins_PRINTRBOARDH-80">#if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)</front>
<front id="pins_PRINTRBOARDH-81">  //we have no buzzer installed</front>
<front id="pins_PRINTRBOARDH-82">  #define BEEPER_PIN -1</front>
<front id="pins_PRINTRBOARDH-83">  //LCD Pins</front>
<front id="pins_PRINTRBOARDH-84">  #if ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="pins_PRINTRBOARDH-85">    #define BTN_EN1 27  //RX1 - fastio.h pin mapping 27</front>
<front id="pins_PRINTRBOARDH-86">    #define BTN_EN2 26  //TX1 - fastio.h pin mapping 26</front>
<front id="pins_PRINTRBOARDH-87">    #define BTN_ENC 43 //A3 - fastio.h pin mapping 43</front>
<front id="pins_PRINTRBOARDH-88">    #define SDSS   40 //use SD card on Panelolu2 (Teensyduino pin mapping)</front>
<front id="pins_PRINTRBOARDH-89">  #endif // LCD_I2C_PANELOLU2</front>
<front id="pins_PRINTRBOARDH-90">  //not connected to a pin</front>
<front id="pins_PRINTRBOARDH-91">  #define SD_DETECT_PIN -1    </front>
<front id="pins_PRINTRBOARDH-92">#endif // ULTRA_LCD && NEWPANEL</front>
<front id="pins_PRINTRBOARDH-93"></front>
<front id="pins_PRINTRBOARDH-94">#if ENABLED(VIKI2) || ENABLED(miniVIKI)</front>
<front id="pins_PRINTRBOARDH-95"> #define BEEPER_PIN 32 //FastIO</front>
<front id="pins_PRINTRBOARDH-96"> // Pins for DOGM SPI LCD Support</front>
<front id="pins_PRINTRBOARDH-97"> #define DOGLCD_A0  42 //Non-FastIO</front>
<front id="pins_PRINTRBOARDH-98"> #define DOGLCD_CS  43 //Non-FastIO</front>
<front id="pins_PRINTRBOARDH-99"> #define LCD_SCREEN_ROT_180</front>
<front id="pins_PRINTRBOARDH-100"> </front>
<front id="pins_PRINTRBOARDH-101"> //The encoder and click button (FastIO Pins)</front>
<front id="pins_PRINTRBOARDH-102"> #define BTN_EN1 26 </front>
<front id="pins_PRINTRBOARDH-103"> #define BTN_EN2 27</front>
<front id="pins_PRINTRBOARDH-104"> #define BTN_ENC 47  //the click switch</front>
<front id="pins_PRINTRBOARDH-105"></front>
<front id="pins_PRINTRBOARDH-106"> #define SDSS 45</front>
<front id="pins_PRINTRBOARDH-107"> #define SD_DETECT_PIN -1 // FastIO (Manual says 72 I'm not certain cause I can't test) </front>
<front id="pins_PRINTRBOARDH-108"></front>
<front id="pins_PRINTRBOARDH-109"> #if ENABLED(TEMP_STAT_LEDS)</front>
<front id="pins_PRINTRBOARDH-110">  #define STAT_LED_RED      12 //Non-FastIO</front>
<front id="pins_PRINTRBOARDH-111">  #define STAT_LED_BLUE     10 //Non-FastIO</front>
<front id="pins_PRINTRBOARDH-112"> #endif  </front>
<front id="pins_PRINTRBOARDH-113">#endif</front>
 </pre>
<h1 id="pins_RAMBOHtitle" >pins_RAMBO.h</h1>
<pre id="pins_RAMBOH"  class="prettyprint linenums"><front id="pins_RAMBOH-1">/**</front>
<front id="pins_RAMBOH-2"> * Rambo pin assignments</front>
<front id="pins_RAMBOH-3"> */</front>
<front id="pins_RAMBOH-4"></front>
<front id="pins_RAMBOH-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_RAMBOH-6">  #error Oops!  Make sure you have 'Arduino Mega 2560' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_RAMBOH-7">#endif</front>
<front id="pins_RAMBOH-8"></front>
<front id="pins_RAMBOH-9">#define LARGE_FLASH true</front>
<front id="pins_RAMBOH-10"></front>
<front id="pins_RAMBOH-11">// Servo support</front>
<front id="pins_RAMBOH-12">#define SERVO0_PIN 22 // Motor header MX1</front>
<front id="pins_RAMBOH-13">#define SERVO1_PIN 23 // Motor header MX2</front>
<front id="pins_RAMBOH-14">#define SERVO2_PIN 24 // Motor header MX3</front>
<front id="pins_RAMBOH-15">#define SERVO2_PIN  5 // PWM header pin 5</front>
<front id="pins_RAMBOH-16"></front>
<front id="pins_RAMBOH-17">#if ENABLED(Z_PROBE_SLED)</front>
<front id="pins_RAMBOH-18">  #define SLED_PIN         -1</front>
<front id="pins_RAMBOH-19">#endif</front>
<front id="pins_RAMBOH-20"></front>
<front id="pins_RAMBOH-21">#undef X_MS1_PIN</front>
<front id="pins_RAMBOH-22">#undef X_MS2_PIN</front>
<front id="pins_RAMBOH-23">#undef Y_MS1_PIN</front>
<front id="pins_RAMBOH-24">#undef Y_MS2_PIN</front>
<front id="pins_RAMBOH-25">#undef Z_MS1_PIN</front>
<front id="pins_RAMBOH-26">#undef Z_MS2_PIN</front>
<front id="pins_RAMBOH-27">#undef E0_MS1_PIN</front>
<front id="pins_RAMBOH-28">#undef E0_MS2_PIN</front>
<front id="pins_RAMBOH-29">#undef E1_MS1_PIN</front>
<front id="pins_RAMBOH-30">#undef E1_MS2_PIN</front>
<front id="pins_RAMBOH-31"> </front>
<front id="pins_RAMBOH-32">#define X_STEP_PIN 37</front>
<front id="pins_RAMBOH-33">#define X_DIR_PIN 48</front>
<front id="pins_RAMBOH-34">#define X_MIN_PIN 12</front>
<front id="pins_RAMBOH-35">#define X_MAX_PIN 24</front>
<front id="pins_RAMBOH-36">#define X_ENABLE_PIN 29</front>
<front id="pins_RAMBOH-37">#define X_MS1_PIN 40</front>
<front id="pins_RAMBOH-38">#define X_MS2_PIN 41</front>
<front id="pins_RAMBOH-39"></front>
<front id="pins_RAMBOH-40">#define Y_STEP_PIN 36</front>
<front id="pins_RAMBOH-41">#define Y_DIR_PIN 49</front>
<front id="pins_RAMBOH-42">#define Y_MIN_PIN 11</front>
<front id="pins_RAMBOH-43">#define Y_MAX_PIN 23</front>
<front id="pins_RAMBOH-44">#define Y_ENABLE_PIN 28</front>
<front id="pins_RAMBOH-45">#define Y_MS1_PIN 69</front>
<front id="pins_RAMBOH-46">#define Y_MS2_PIN 39</front>
<front id="pins_RAMBOH-47"></front>
<front id="pins_RAMBOH-48">#define Z_STEP_PIN 35</front>
<front id="pins_RAMBOH-49">#define Z_DIR_PIN 47</front>
<front id="pins_RAMBOH-50">#define Z_MIN_PIN 10</front>
<front id="pins_RAMBOH-51">#define Z_MAX_PIN 30</front>
<front id="pins_RAMBOH-52">#define Z_ENABLE_PIN 27</front>
<front id="pins_RAMBOH-53">#define Z_MS1_PIN 68</front>
<front id="pins_RAMBOH-54">#define Z_MS2_PIN 67</front>
<front id="pins_RAMBOH-55"></front>
<front id="pins_RAMBOH-56">#define HEATER_BED_PIN 3</front>
<front id="pins_RAMBOH-57">#define TEMP_BED_PIN 2</front>
<front id="pins_RAMBOH-58"></front>
<front id="pins_RAMBOH-59">#define HEATER_0_PIN  9</front>
<front id="pins_RAMBOH-60">#define TEMP_0_PIN 0</front>
<front id="pins_RAMBOH-61"></front>
<front id="pins_RAMBOH-62">#define HEATER_1_PIN 7</front>
<front id="pins_RAMBOH-63">#define TEMP_1_PIN 1</front>
<front id="pins_RAMBOH-64"></front>
<front id="pins_RAMBOH-65">#if ENABLED(BARICUDA)</front>
<front id="pins_RAMBOH-66">  #define HEATER_2_PIN 6</front>
<front id="pins_RAMBOH-67">#else</front>
<front id="pins_RAMBOH-68">  #define HEATER_2_PIN -1</front>
<front id="pins_RAMBOH-69">#endif</front>
<front id="pins_RAMBOH-70"></front>
<front id="pins_RAMBOH-71">#define TEMP_2_PIN -1</front>
<front id="pins_RAMBOH-72"></front>
<front id="pins_RAMBOH-73">#define E0_STEP_PIN         34</front>
<front id="pins_RAMBOH-74">#define E0_DIR_PIN          43</front>
<front id="pins_RAMBOH-75">#define E0_ENABLE_PIN       26</front>
<front id="pins_RAMBOH-76">#define E0_MS1_PIN 65</front>
<front id="pins_RAMBOH-77">#define E0_MS2_PIN 66</front>
<front id="pins_RAMBOH-78"></front>
<front id="pins_RAMBOH-79">#define E1_STEP_PIN         33</front>
<front id="pins_RAMBOH-80">#define E1_DIR_PIN          42</front>
<front id="pins_RAMBOH-81">#define E1_ENABLE_PIN       25</front>
<front id="pins_RAMBOH-82">#define E1_MS1_PIN 63</front>
<front id="pins_RAMBOH-83">#define E1_MS2_PIN 64</front>
<front id="pins_RAMBOH-84"></front>
<front id="pins_RAMBOH-85">#undef DIGIPOTSS_PIN</front>
<front id="pins_RAMBOH-86">#define DIGIPOTSS_PIN 38</front>
<front id="pins_RAMBOH-87">#define DIGIPOT_CHANNELS {4,5,3,0,1} // X Y Z E0 E1 digipot channels to stepper driver mapping</front>
<front id="pins_RAMBOH-88"></front>
<front id="pins_RAMBOH-89">#define SDPOWER            -1</front>
<front id="pins_RAMBOH-90">#define SDSS               53</front>
<front id="pins_RAMBOH-91">#define LED_PIN            13</front>
<front id="pins_RAMBOH-92">#define FAN_PIN            8  </front>
<front id="pins_RAMBOH-93"></front>
<front id="pins_RAMBOH-94">/**********************************************************</front>
<front id="pins_RAMBOH-95">  Fan Pins</front>
<front id="pins_RAMBOH-96">  Fan_0 8</front>
<front id="pins_RAMBOH-97">  Fan_1 6</front>
<front id="pins_RAMBOH-98">  Fan_2 2</front>
<front id="pins_RAMBOH-99">***********************************************************/</front>
<front id="pins_RAMBOH-100">#define PS_ON_PIN          4</front>
<front id="pins_RAMBOH-101">#define KILL_PIN           -1 //80 with Smart Controller LCD</front>
<front id="pins_RAMBOH-102">#define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pins_RAMBOH-103"></front>
<front id="pins_RAMBOH-104">#if ENABLED(ULTRA_LCD)</front>
<front id="pins_RAMBOH-105"></front>
<front id="pins_RAMBOH-106">  #define KILL_PIN 80</front>
<front id="pins_RAMBOH-107"></front>
<front id="pins_RAMBOH-108">  #if ENABLED(NEWPANEL)</front>
<front id="pins_RAMBOH-109"></front>
<front id="pins_RAMBOH-110">    #define BEEPER_PIN 79      // Beeper on AUX-4</front>
<front id="pins_RAMBOH-111"></front>
<front id="pins_RAMBOH-112">    #define LCD_PINS_RS 70</front>
<front id="pins_RAMBOH-113">    #define LCD_PINS_ENABLE 71</front>
<front id="pins_RAMBOH-114">    #define LCD_PINS_D4 72</front>
<front id="pins_RAMBOH-115">    #define LCD_PINS_D5 73</front>
<front id="pins_RAMBOH-116">    #define LCD_PINS_D6 74</front>
<front id="pins_RAMBOH-117">    #define LCD_PINS_D7 75</front>
<front id="pins_RAMBOH-118"></front>
<front id="pins_RAMBOH-119">    //buttons are directly attached using AUX-2</front>
<front id="pins_RAMBOH-120">    #define BTN_EN1 76</front>
<front id="pins_RAMBOH-121">    #define BTN_EN2 77</front>
<front id="pins_RAMBOH-122">    #define BTN_ENC 78  //the click</front>
<front id="pins_RAMBOH-123"></front>
<front id="pins_RAMBOH-124">    #define BLEN_C 2</front>
<front id="pins_RAMBOH-125">    #define BLEN_B 1</front>
<front id="pins_RAMBOH-126">    #define BLEN_A 0</front>
<front id="pins_RAMBOH-127"></front>
<front id="pins_RAMBOH-128">    #define SD_DETECT_PIN 81 // Ramps doesn't use this</front>
<front id="pins_RAMBOH-129"></front>
<front id="pins_RAMBOH-130">  #else //!NEWPANEL - old style panel with shift register</front>
<front id="pins_RAMBOH-131"></front>
<front id="pins_RAMBOH-132">    #define BEEPER_PIN 33    // No Beeper added</front>
<front id="pins_RAMBOH-133"></front>
<front id="pins_RAMBOH-134">    //buttons are attached to a shift register</front>
<front id="pins_RAMBOH-135">    // Not wired yet</front>
<front id="pins_RAMBOH-136">    // #define SHIFT_CLK 38</front>
<front id="pins_RAMBOH-137">    // #define SHIFT_LD 42</front>
<front id="pins_RAMBOH-138">    // #define SHIFT_OUT 40</front>
<front id="pins_RAMBOH-139">    // #define SHIFT_EN 17</front>
<front id="pins_RAMBOH-140"></front>
<front id="pins_RAMBOH-141">    #define LCD_PINS_RS 75</front>
<front id="pins_RAMBOH-142">    #define LCD_PINS_ENABLE 17</front>
<front id="pins_RAMBOH-143">    #define LCD_PINS_D4 23</front>
<front id="pins_RAMBOH-144">    #define LCD_PINS_D5 25</front>
<front id="pins_RAMBOH-145">    #define LCD_PINS_D6 27</front>
<front id="pins_RAMBOH-146">    #define LCD_PINS_D7 29</front>
<front id="pins_RAMBOH-147"></front>
<front id="pins_RAMBOH-148">    //bits in the shift register that carry the buttons for:</front>
<front id="pins_RAMBOH-149">    // left up center down right red</front>
<front id="pins_RAMBOH-150">    #define BL_LE 7</front>
<front id="pins_RAMBOH-151">    #define BL_UP 6</front>
<front id="pins_RAMBOH-152">    #define BL_MI 5</front>
<front id="pins_RAMBOH-153">    #define BL_DW 4</front>
<front id="pins_RAMBOH-154">    #define BL_RI 3</front>
<front id="pins_RAMBOH-155">    #define BL_ST 2</front>
<front id="pins_RAMBOH-156">    #define BLEN_B 1</front>
<front id="pins_RAMBOH-157">    #define BLEN_A 0</front>
<front id="pins_RAMBOH-158"></front>
<front id="pins_RAMBOH-159">  #endif // !NEWPANEL</front>
<front id="pins_RAMBOH-160"></front>
<front id="pins_RAMBOH-161">#endif // ULTRA_LCD</front>
<front id="pins_RAMBOH-162"></front>
<front id="pins_RAMBOH-163">#if ENABLED(VIKI2) || ENABLED(miniVIKI)</front>
<front id="pins_RAMBOH-164"> #define BEEPER_PIN 44</front>
<front id="pins_RAMBOH-165"> // Pins for DOGM SPI LCD Support</front>
<front id="pins_RAMBOH-166"> #define DOGLCD_A0  70 </front>
<front id="pins_RAMBOH-167"> #define DOGLCD_CS  71 </front>
<front id="pins_RAMBOH-168"> #define LCD_SCREEN_ROT_180</front>
<front id="pins_RAMBOH-169">  </front>
<front id="pins_RAMBOH-170"> //The encoder and click button </front>
<front id="pins_RAMBOH-171"> #define BTN_EN1 85 </front>
<front id="pins_RAMBOH-172"> #define BTN_EN2 84</front>
<front id="pins_RAMBOH-173"> #define BTN_ENC 83  //the click switch</front>
<front id="pins_RAMBOH-174"></front>
<front id="pins_RAMBOH-175"> #define SD_DETECT_PIN -1 // Pin 72 if using easy adapter board   </front>
<front id="pins_RAMBOH-176"></front>
<front id="pins_RAMBOH-177">  #if ENABLED(TEMP_STAT_LEDS)</front>
<front id="pins_RAMBOH-178">   #define STAT_LED_RED      22</front>
<front id="pins_RAMBOH-179">   #define STAT_LED_BLUE     32 </front>
<front id="pins_RAMBOH-180">  #endif</front>
<front id="pins_RAMBOH-181">#endif // VIKI2/miniVIKI</front>
<front id="pins_RAMBOH-182"></front>
<front id="pins_RAMBOH-183">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="pins_RAMBOH-184">  //Filip added pin for Filament sensor analog input </front>
<front id="pins_RAMBOH-185">  #define FILWIDTH_PIN        3</front>
<front id="pins_RAMBOH-186">#endif</front>
 </pre>
<h1 id="pins_RAMPS_13Htitle" >pins_RAMPS_13.h</h1>
<pre id="pins_RAMPS_13H"  class="prettyprint linenums"><front id="pins_RAMPS_13H-1">/**</front>
<front id="pins_RAMPS_13H-2"> * Arduino Mega with RAMPS v1.3 pin assignments</front>
<front id="pins_RAMPS_13H-3"> *</front>
<front id="pins_RAMPS_13H-4"> * Applies to the following boards:</front>
<front id="pins_RAMPS_13H-5"> *</front>
<front id="pins_RAMPS_13H-6"> *  RAMPS_13_EFB (Extruder, Fan, Bed)</front>
<front id="pins_RAMPS_13H-7"> *  RAMPS_13_EEB (Extruder, Extruder, Bed)</front>
<front id="pins_RAMPS_13H-8"> *  RAMPS_13_EFF (Extruder, Fan, Fan)</front>
<front id="pins_RAMPS_13H-9"> *  RAMPS_13_EEF (Extruder, Extruder, Fan)</front>
<front id="pins_RAMPS_13H-10"> *  RAMPS_13_SF  (Spindle, Controller Fan)</front>
<front id="pins_RAMPS_13H-11"> *</front>
<front id="pins_RAMPS_13H-12"> *  Other pins_MYBOARD.h files may override these defaults</front>
<front id="pins_RAMPS_13H-13"> */</front>
<front id="pins_RAMPS_13H-14"></front>
<front id="pins_RAMPS_13H-15">#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)</front>
<front id="pins_RAMPS_13H-16">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_RAMPS_13H-17">#endif</front>
<front id="pins_RAMPS_13H-18"></front>
<front id="pins_RAMPS_13H-19">#define LARGE_FLASH true</front>
<front id="pins_RAMPS_13H-20"></front>
<front id="pins_RAMPS_13H-21">#define SERVO0_PIN         11</front>
<front id="pins_RAMPS_13H-22">#define SERVO1_PIN          6</front>
<front id="pins_RAMPS_13H-23">#define SERVO2_PIN          5</front>
<front id="pins_RAMPS_13H-24">#define SERVO3_PIN          4</front>
<front id="pins_RAMPS_13H-25"></front>
<front id="pins_RAMPS_13H-26">#define X_STEP_PIN         54</front>
<front id="pins_RAMPS_13H-27">#define X_DIR_PIN          55</front>
<front id="pins_RAMPS_13H-28">#define X_ENABLE_PIN       38</front>
<front id="pins_RAMPS_13H-29">#define X_MIN_PIN           3</front>
<front id="pins_RAMPS_13H-30">#define X_MAX_PIN           2</front>
<front id="pins_RAMPS_13H-31"></front>
<front id="pins_RAMPS_13H-32">#define Y_STEP_PIN         60</front>
<front id="pins_RAMPS_13H-33">#define Y_DIR_PIN          61</front>
<front id="pins_RAMPS_13H-34">#define Y_ENABLE_PIN       56</front>
<front id="pins_RAMPS_13H-35">#define Y_MIN_PIN          14</front>
<front id="pins_RAMPS_13H-36">#define Y_MAX_PIN          15</front>
<front id="pins_RAMPS_13H-37"></front>
<front id="pins_RAMPS_13H-38">#define Z_STEP_PIN         46</front>
<front id="pins_RAMPS_13H-39">#define Z_DIR_PIN          48</front>
<front id="pins_RAMPS_13H-40">#define Z_ENABLE_PIN       62</front>
<front id="pins_RAMPS_13H-41">#define Z_MIN_PIN          18</front>
<front id="pins_RAMPS_13H-42">#define Z_MAX_PIN          19</front>
<front id="pins_RAMPS_13H-43"></front>
<front id="pins_RAMPS_13H-44">#define E0_STEP_PIN        26</front>
<front id="pins_RAMPS_13H-45">#define E0_DIR_PIN         28</front>
<front id="pins_RAMPS_13H-46">#define E0_ENABLE_PIN      24</front>
<front id="pins_RAMPS_13H-47"></front>
<front id="pins_RAMPS_13H-48">#define E1_STEP_PIN        36</front>
<front id="pins_RAMPS_13H-49">#define E1_DIR_PIN         34</front>
<front id="pins_RAMPS_13H-50">#define E1_ENABLE_PIN      30</front>
<front id="pins_RAMPS_13H-51"></front>
<front id="pins_RAMPS_13H-52">#define SDPOWER            -1</front>
<front id="pins_RAMPS_13H-53">#define SDSS               53</front>
<front id="pins_RAMPS_13H-54">#define LED_PIN            13</front>
<front id="pins_RAMPS_13H-55"></front>
<front id="pins_RAMPS_13H-56">#if ENABLED(FILAMENT_SENSOR)  // FMM added for Filament Extruder</front>
<front id="pins_RAMPS_13H-57">  // define analog pin for the filament width sensor input</front>
<front id="pins_RAMPS_13H-58">  // Use the RAMPS 1.4 Analog input 5 on the AUX2 connector</front>
<front id="pins_RAMPS_13H-59">  #define FILWIDTH_PIN      5</front>
<front id="pins_RAMPS_13H-60">#endif</front>
<front id="pins_RAMPS_13H-61"></front>
<front id="pins_RAMPS_13H-62">#if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="pins_RAMPS_13H-63">  // Define a pin to use as the signal pin on Arduino for the Z_PROBE endstop.</front>
<front id="pins_RAMPS_13H-64">  #define Z_MIN_PROBE_PIN  32</front>
<front id="pins_RAMPS_13H-65">#endif</front>
<front id="pins_RAMPS_13H-66"></front>
<front id="pins_RAMPS_13H-67">#if ENABLED(FILAMENT_RUNOUT_SENSOR)</front>
<front id="pins_RAMPS_13H-68">  // define digital pin 4 for the filament runout sensor. Use the RAMPS 1.4 digital input 4 on the servos connector</front>
<front id="pins_RAMPS_13H-69">  #define FILRUNOUT_PIN     4</front>
<front id="pins_RAMPS_13H-70">#endif</front>
<front id="pins_RAMPS_13H-71"></front>
<front id="pins_RAMPS_13H-72">#if MB(RAMPS_13_EFF) || ENABLED(IS_RAMPS_EFB)</front>
<front id="pins_RAMPS_13H-73">  #define FAN_PIN           9 // (Sprinter config)</front>
<front id="pins_RAMPS_13H-74">  #if MB(RAMPS_13_EFF)</front>
<front id="pins_RAMPS_13H-75">    #define CONTROLLERFAN_PIN  -1 // Pin used for the fan to cool controller</front>
<front id="pins_RAMPS_13H-76">  #endif</front>
<front id="pins_RAMPS_13H-77">#elif MB(RAMPS_13_EEF) || MB(RAMPS_13_SF)</front>
<front id="pins_RAMPS_13H-78">  #define FAN_PIN           8</front>
<front id="pins_RAMPS_13H-79">#else</front>
<front id="pins_RAMPS_13H-80">  #define FAN_PIN           4 // IO pin. Buffer needed</front>
<front id="pins_RAMPS_13H-81">#endif</front>
<front id="pins_RAMPS_13H-82"></front>
<front id="pins_RAMPS_13H-83">#define PS_ON_PIN          12</front>
<front id="pins_RAMPS_13H-84"></front>
<front id="pins_RAMPS_13H-85">#if ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER) || ENABLED(G3D_PANEL)</front>
<front id="pins_RAMPS_13H-86">  #define KILL_PIN         41</front>
<front id="pins_RAMPS_13H-87">#else</front>
<front id="pins_RAMPS_13H-88">  #define KILL_PIN         -1</front>
<front id="pins_RAMPS_13H-89">#endif</front>
<front id="pins_RAMPS_13H-90"></front>
<front id="pins_RAMPS_13H-91">#if MB(RAMPS_13_EFF)</front>
<front id="pins_RAMPS_13H-92">  #define HEATER_0_PIN      8</front>
<front id="pins_RAMPS_13H-93">#else</front>
<front id="pins_RAMPS_13H-94">  #define HEATER_0_PIN     10   // EXTRUDER 1</front>
<front id="pins_RAMPS_13H-95">#endif</front>
<front id="pins_RAMPS_13H-96"></front>
<front id="pins_RAMPS_13H-97">#if MB(RAMPS_13_SF) || ENABLED(IS_RAMPS_EFB)</front>
<front id="pins_RAMPS_13H-98">  #define HEATER_1_PIN     -1</front>
<front id="pins_RAMPS_13H-99">#else</front>
<front id="pins_RAMPS_13H-100">  #define HEATER_1_PIN      9   // EXTRUDER 2 (FAN On Sprinter)</front>
<front id="pins_RAMPS_13H-101">#endif</front>
<front id="pins_RAMPS_13H-102"></front>
<front id="pins_RAMPS_13H-103">#define HEATER_2_PIN       -1</front>
<front id="pins_RAMPS_13H-104"></front>
<front id="pins_RAMPS_13H-105">#define TEMP_0_PIN         13   // ANALOG NUMBERING</front>
<front id="pins_RAMPS_13H-106">#define TEMP_1_PIN         15   // ANALOG NUMBERING</front>
<front id="pins_RAMPS_13H-107">#define TEMP_2_PIN         -1   // ANALOG NUMBERING</front>
<front id="pins_RAMPS_13H-108"></front>
<front id="pins_RAMPS_13H-109">#if MB(RAMPS_13_EFF) || MB(RAMPS_13_EEF) || MB(RAMPS_13_SF)</front>
<front id="pins_RAMPS_13H-110">  #define HEATER_BED_PIN   -1    // NO BED</front>
<front id="pins_RAMPS_13H-111">#else</front>
<front id="pins_RAMPS_13H-112">  #define HEATER_BED_PIN    8    // BED</front>
<front id="pins_RAMPS_13H-113">#endif</front>
<front id="pins_RAMPS_13H-114"></front>
<front id="pins_RAMPS_13H-115">#define TEMP_BED_PIN         14   // ANALOG NUMBERING</front>
<front id="pins_RAMPS_13H-116"></front>
<front id="pins_RAMPS_13H-117">#if ENABLED(Z_PROBE_SLED)</front>
<front id="pins_RAMPS_13H-118">  #define SLED_PIN           -1</front>
<front id="pins_RAMPS_13H-119">#endif</front>
<front id="pins_RAMPS_13H-120"></front>
<front id="pins_RAMPS_13H-121">#if ENABLED(ULTRA_LCD)</front>
<front id="pins_RAMPS_13H-122"></front>
<front id="pins_RAMPS_13H-123">  #if ENABLED(NEWPANEL)</front>
<front id="pins_RAMPS_13H-124">    #if ENABLED(PANEL_ONE)</front>
<front id="pins_RAMPS_13H-125">      #define LCD_PINS_RS 40</front>
<front id="pins_RAMPS_13H-126">      #define LCD_PINS_ENABLE 42</front>
<front id="pins_RAMPS_13H-127">      #define LCD_PINS_D4 65</front>
<front id="pins_RAMPS_13H-128">      #define LCD_PINS_D5 66</front>
<front id="pins_RAMPS_13H-129">      #define LCD_PINS_D6 44</front>
<front id="pins_RAMPS_13H-130">      #define LCD_PINS_D7 64</front>
<front id="pins_RAMPS_13H-131">    #else</front>
<front id="pins_RAMPS_13H-132">      #define LCD_PINS_RS 16</front>
<front id="pins_RAMPS_13H-133">      #define LCD_PINS_ENABLE 17</front>
<front id="pins_RAMPS_13H-134">      #define LCD_PINS_D4 23</front>
<front id="pins_RAMPS_13H-135">      #define LCD_PINS_D5 25</front>
<front id="pins_RAMPS_13H-136">      #define LCD_PINS_D6 27</front>
<front id="pins_RAMPS_13H-137">      #define LCD_PINS_D7 29</front>
<front id="pins_RAMPS_13H-138">    #endif</front>
<front id="pins_RAMPS_13H-139"></front>
<front id="pins_RAMPS_13H-140">    #if ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER)</front>
<front id="pins_RAMPS_13H-141">      #define BEEPER_PIN 37</front>
<front id="pins_RAMPS_13H-142"></front>
<front id="pins_RAMPS_13H-143">      #define BTN_EN1 31</front>
<front id="pins_RAMPS_13H-144">      #define BTN_EN2 33</front>
<front id="pins_RAMPS_13H-145">      #define BTN_ENC 35</front>
<front id="pins_RAMPS_13H-146"></front>
<front id="pins_RAMPS_13H-147">      #define SD_DETECT_PIN 49</front>
<front id="pins_RAMPS_13H-148">    #elif ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="pins_RAMPS_13H-149">      #define BTN_EN1 47  // reverse if the encoder turns the wrong way.</front>
<front id="pins_RAMPS_13H-150">      #define BTN_EN2 43</front>
<front id="pins_RAMPS_13H-151">      #define BTN_ENC 32</front>
<front id="pins_RAMPS_13H-152">      #define LCD_SDSS 53</front>
<front id="pins_RAMPS_13H-153">      #define SD_DETECT_PIN -1</front>
<front id="pins_RAMPS_13H-154">      #define KILL_PIN 41</front>
<front id="pins_RAMPS_13H-155">    #elif ENABLED(LCD_I2C_VIKI)</front>
<front id="pins_RAMPS_13H-156">      #define BTN_EN1 22  // reverse if the encoder turns the wrong way.</front>
<front id="pins_RAMPS_13H-157">      #define BTN_EN2 7</front>
<front id="pins_RAMPS_13H-158">      #define BTN_ENC -1</front>
<front id="pins_RAMPS_13H-159">      #define LCD_SDSS 53</front>
<front id="pins_RAMPS_13H-160">      #define SD_DETECT_PIN 49</front>
<front id="pins_RAMPS_13H-161">    #elif ENABLED(ELB_FULL_GRAPHIC_CONTROLLER)</front>
<front id="pins_RAMPS_13H-162">      #define BTN_EN1 35  // reverse if the encoder turns the wrong way.</front>
<front id="pins_RAMPS_13H-163">      #define BTN_EN2 37</front>
<front id="pins_RAMPS_13H-164">      #define BTN_ENC 31</front>
<front id="pins_RAMPS_13H-165">      #define SD_DETECT_PIN 49</front>
<front id="pins_RAMPS_13H-166">      #define LCD_SDSS 53</front>
<front id="pins_RAMPS_13H-167">      #define KILL_PIN 41</front>
<front id="pins_RAMPS_13H-168">      #define BEEPER_PIN 23</front>
<front id="pins_RAMPS_13H-169">      #define DOGLCD_CS 29</front>
<front id="pins_RAMPS_13H-170">      #define DOGLCD_A0 27</front>
<front id="pins_RAMPS_13H-171">      #define LCD_PIN_BL 33</front>
<front id="pins_RAMPS_13H-172">    #elif ENABLED(MINIPANEL)</front>
<front id="pins_RAMPS_13H-173">       #define BEEPER_PIN 42</front>
<front id="pins_RAMPS_13H-174">       // Pins for DOGM SPI LCD Support</front>
<front id="pins_RAMPS_13H-175">       #define DOGLCD_A0  44</front>
<front id="pins_RAMPS_13H-176">       #define DOGLCD_CS  66</front>
<front id="pins_RAMPS_13H-177">       #define LCD_PIN_BL	65	// backlight LED on A11/D65</front>
<front id="pins_RAMPS_13H-178">       #define SDSS   53</front>
<front id="pins_RAMPS_13H-179">       </front>
<front id="pins_RAMPS_13H-180">       #define KILL_PIN 64</front>
<front id="pins_RAMPS_13H-181">       // GLCD features</front>
<front id="pins_RAMPS_13H-182">       //#define LCD_CONTRAST 190</front>
<front id="pins_RAMPS_13H-183">       // Uncomment screen orientation</front>
<front id="pins_RAMPS_13H-184">         // #define LCD_SCREEN_ROT_90</front>
<front id="pins_RAMPS_13H-185">         // #define LCD_SCREEN_ROT_180</front>
<front id="pins_RAMPS_13H-186">         // #define LCD_SCREEN_ROT_270</front>
<front id="pins_RAMPS_13H-187">       //The encoder and click button</front>
<front id="pins_RAMPS_13H-188">       #define BTN_EN1 40</front>
<front id="pins_RAMPS_13H-189">       #define BTN_EN2 63</front>
<front id="pins_RAMPS_13H-190">       #define BTN_ENC 59  //the click switch</front>
<front id="pins_RAMPS_13H-191">       //not connected to a pin</front>
<front id="pins_RAMPS_13H-192">       #define SD_DETECT_PIN 49</front>
<front id="pins_RAMPS_13H-193"></front>
<front id="pins_RAMPS_13H-194">    #else</front>
<front id="pins_RAMPS_13H-195"></front>
<front id="pins_RAMPS_13H-196">      #define BEEPER_PIN 33  // Beeper on AUX-4</front>
<front id="pins_RAMPS_13H-197"></front>
<front id="pins_RAMPS_13H-198">      // buttons are directly attached using AUX-2</front>
<front id="pins_RAMPS_13H-199">      #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="pins_RAMPS_13H-200">        #define BTN_EN1 64 // encoder</front>
<front id="pins_RAMPS_13H-201">        #define BTN_EN2 59 // encoder</front>
<front id="pins_RAMPS_13H-202">        #define BTN_ENC 63 // enter button</front>
<front id="pins_RAMPS_13H-203">        #define SHIFT_OUT 40 // shift register</front>
<front id="pins_RAMPS_13H-204">        #define SHIFT_CLK 44 // shift register</front>
<front id="pins_RAMPS_13H-205">        #define SHIFT_LD 42 // shift register</front>
<front id="pins_RAMPS_13H-206">      #elif ENABLED(PANEL_ONE)</front>
<front id="pins_RAMPS_13H-207">        #define BTN_EN1 59 // AUX2 PIN 3</front>
<front id="pins_RAMPS_13H-208">        #define BTN_EN2 63 // AUX2 PIN 4</front>
<front id="pins_RAMPS_13H-209">        #define BTN_ENC 49 // AUX3 PIN 7</front>
<front id="pins_RAMPS_13H-210">      #else</front>
<front id="pins_RAMPS_13H-211">        #define BTN_EN1 37</front>
<front id="pins_RAMPS_13H-212">        #define BTN_EN2 35</front>
<front id="pins_RAMPS_13H-213">        #define BTN_ENC 31  // the click</front>
<front id="pins_RAMPS_13H-214">      #endif</front>
<front id="pins_RAMPS_13H-215"></front>
<front id="pins_RAMPS_13H-216">      #if ENABLED(G3D_PANEL)</front>
<front id="pins_RAMPS_13H-217">        #define SD_DETECT_PIN 49</front>
<front id="pins_RAMPS_13H-218">      #else</front>
<front id="pins_RAMPS_13H-219">        #define SD_DETECT_PIN -1  // Ramps doesn't use this</front>
<front id="pins_RAMPS_13H-220">      #endif</front>
<front id="pins_RAMPS_13H-221"></front>
<front id="pins_RAMPS_13H-222">    #endif</front>
<front id="pins_RAMPS_13H-223">  #else // !NEWPANEL (Old-style panel with shift register)</front>
<front id="pins_RAMPS_13H-224"></front>
<front id="pins_RAMPS_13H-225">    #define BEEPER_PIN 33   // No Beeper added</front>
<front id="pins_RAMPS_13H-226"></front>
<front id="pins_RAMPS_13H-227">    // Buttons are attached to a shift register</front>
<front id="pins_RAMPS_13H-228">    // Not wired yet</front>
<front id="pins_RAMPS_13H-229">    // #define SHIFT_CLK 38</front>
<front id="pins_RAMPS_13H-230">    // #define SHIFT_LD 42</front>
<front id="pins_RAMPS_13H-231">    // #define SHIFT_OUT 40</front>
<front id="pins_RAMPS_13H-232">    // #define SHIFT_EN 17</front>
<front id="pins_RAMPS_13H-233"></front>
<front id="pins_RAMPS_13H-234">    #define LCD_PINS_RS 16</front>
<front id="pins_RAMPS_13H-235">    #define LCD_PINS_ENABLE 17</front>
<front id="pins_RAMPS_13H-236">    #define LCD_PINS_D4 23</front>
<front id="pins_RAMPS_13H-237">    #define LCD_PINS_D5 25</front>
<front id="pins_RAMPS_13H-238">    #define LCD_PINS_D6 27</front>
<front id="pins_RAMPS_13H-239">    #define LCD_PINS_D7 29</front>
<front id="pins_RAMPS_13H-240"></front>
<front id="pins_RAMPS_13H-241">  #endif // !NEWPANEL</front>
<front id="pins_RAMPS_13H-242"></front>
<front id="pins_RAMPS_13H-243">#endif // ULTRA_LCD</front>
<front id="pins_RAMPS_13H-244"></front>
<front id="pins_RAMPS_13H-245">// SPI for Max6675 Thermocouple</front>
<front id="pins_RAMPS_13H-246">#if DISABLED(SDSUPPORT)</front>
<front id="pins_RAMPS_13H-247">  #define MAX6675_SS       66 // Do not use pin 53 if there is even the remote possibility of using Display/SD card</front>
<front id="pins_RAMPS_13H-248">#else</front>
<front id="pins_RAMPS_13H-249">  #define MAX6675_SS       66 // Do not use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present</front>
<front id="pins_RAMPS_13H-250">#endif</front>
<front id="pins_RAMPS_13H-251"></front>
<front id="pins_RAMPS_13H-252">#if DISABLED(SDSUPPORT)</front>
<front id="pins_RAMPS_13H-253">  // these pins are defined in the SD library if building with SD support</front>
<front id="pins_RAMPS_13H-254">  #define SCK_PIN          52</front>
<front id="pins_RAMPS_13H-255">  #define MISO_PIN         50</front>
<front id="pins_RAMPS_13H-256">  #define MOSI_PIN         51</front>
<front id="pins_RAMPS_13H-257">#endif</front>
 </pre>
<h1 id="pins_RAMPS_13_EFBHtitle" >pins_RAMPS_13_EFB.h</h1>
<pre id="pins_RAMPS_13_EFBH"  class="prettyprint linenums"><front id="pins_RAMPS_13_EFBH-1">/**</front>
<front id="pins_RAMPS_13_EFBH-2"> * Arduino Mega with RAMPS v1.3 pin assignments</front>
<front id="pins_RAMPS_13_EFBH-3"> *</front>
<front id="pins_RAMPS_13_EFBH-4"> *  RAMPS_13_EFB (Extruder, Fan, Bed)</front>
<front id="pins_RAMPS_13_EFBH-5"> */</front>
<front id="pins_RAMPS_13_EFBH-6"></front>
<front id="pins_RAMPS_13_EFBH-7">#define IS_RAMPS_EFB</front>
<front id="pins_RAMPS_13_EFBH-8"></front>
<front id="pins_RAMPS_13_EFBH-9">#include "pins_RAMPS_13.h"</front>
 </pre>
<h1 id="pins_RAMPS_OLDHtitle" >pins_RAMPS_OLD.h</h1>
<pre id="pins_RAMPS_OLDH"  class="prettyprint linenums"><front id="pins_RAMPS_OLDH-1">/**</front>
<front id="pins_RAMPS_OLDH-2"> * Arduino Mega with RAMPS v1.0, v1.1, v1.2 pin assignments</front>
<front id="pins_RAMPS_OLDH-3"> */</front>
<front id="pins_RAMPS_OLDH-4"></front>
<front id="pins_RAMPS_OLDH-5">#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)</front>
<front id="pins_RAMPS_OLDH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_RAMPS_OLDH-7">#endif</front>
<front id="pins_RAMPS_OLDH-8"></front>
<front id="pins_RAMPS_OLDH-9">// Uncomment the following line for RAMPS v1.0</front>
<front id="pins_RAMPS_OLDH-10">//#define RAMPS_V_1_0</front>
<front id="pins_RAMPS_OLDH-11"></front>
<front id="pins_RAMPS_OLDH-12">#define X_STEP_PIN         26</front>
<front id="pins_RAMPS_OLDH-13">#define X_DIR_PIN          28</front>
<front id="pins_RAMPS_OLDH-14">#define X_ENABLE_PIN       24</front>
<front id="pins_RAMPS_OLDH-15">#define X_MIN_PIN           3</front>
<front id="pins_RAMPS_OLDH-16">#define X_MAX_PIN           2</front>
<front id="pins_RAMPS_OLDH-17"></front>
<front id="pins_RAMPS_OLDH-18">#define Y_STEP_PIN         38</front>
<front id="pins_RAMPS_OLDH-19">#define Y_DIR_PIN          40</front>
<front id="pins_RAMPS_OLDH-20">#define Y_ENABLE_PIN       36</front>
<front id="pins_RAMPS_OLDH-21">#define Y_MIN_PIN          16</front>
<front id="pins_RAMPS_OLDH-22">#define Y_MAX_PIN          17</front>
<front id="pins_RAMPS_OLDH-23"></front>
<front id="pins_RAMPS_OLDH-24">#define Z_STEP_PIN         44</front>
<front id="pins_RAMPS_OLDH-25">#define Z_DIR_PIN          46</front>
<front id="pins_RAMPS_OLDH-26">#define Z_ENABLE_PIN       42</front>
<front id="pins_RAMPS_OLDH-27">#define Z_MIN_PIN          18</front>
<front id="pins_RAMPS_OLDH-28">#define Z_MAX_PIN          19</front>
<front id="pins_RAMPS_OLDH-29"></front>
<front id="pins_RAMPS_OLDH-30">#define E0_STEP_PIN        32</front>
<front id="pins_RAMPS_OLDH-31">#define E0_DIR_PIN         34</front>
<front id="pins_RAMPS_OLDH-32">#define E0_ENABLE_PIN      30</front>
<front id="pins_RAMPS_OLDH-33"></front>
<front id="pins_RAMPS_OLDH-34">#define SDPOWER            48</front>
<front id="pins_RAMPS_OLDH-35">#define SDSS               53</front>
<front id="pins_RAMPS_OLDH-36">#define LED_PIN            13</front>
<front id="pins_RAMPS_OLDH-37">#define PS_ON_PIN          -1</front>
<front id="pins_RAMPS_OLDH-38">#define KILL_PIN           -1</front>
<front id="pins_RAMPS_OLDH-39"></front>
<front id="pins_RAMPS_OLDH-40">#if ENABLED(RAMPS_V_1_0) // RAMPS_V_1_0</front>
<front id="pins_RAMPS_OLDH-41">  #define HEATER_0_PIN     12    // RAMPS 1.0</front>
<front id="pins_RAMPS_OLDH-42">  #define HEATER_BED_PIN   -1    // RAMPS 1.0</front>
<front id="pins_RAMPS_OLDH-43">  #define FAN_PIN          11    // RAMPS 1.0</front>
<front id="pins_RAMPS_OLDH-44">#else // RAMPS_V_1_1 or RAMPS_V_1_2</front>
<front id="pins_RAMPS_OLDH-45">  #define HEATER_0_PIN     10    // RAMPS 1.1</front>
<front id="pins_RAMPS_OLDH-46">  #define HEATER_BED_PIN    8    // RAMPS 1.1</front>
<front id="pins_RAMPS_OLDH-47">  #define FAN_PIN           9    // RAMPS 1.1</front>
<front id="pins_RAMPS_OLDH-48">#endif</front>
<front id="pins_RAMPS_OLDH-49"></front>
<front id="pins_RAMPS_OLDH-50">#define HEATER_1_PIN        -1</front>
<front id="pins_RAMPS_OLDH-51">#define HEATER_2_PIN        -1</front>
<front id="pins_RAMPS_OLDH-52">#define TEMP_0_PIN          2    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_RAMPS_OLDH-53">#define TEMP_1_PIN          -1</front>
<front id="pins_RAMPS_OLDH-54">#define TEMP_2_PIN          -1</front>
<front id="pins_RAMPS_OLDH-55">#define TEMP_BED_PIN        1    // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!!</front>
<front id="pins_RAMPS_OLDH-56"></front>
<front id="pins_RAMPS_OLDH-57">// SPI for Max6675 Thermocouple</front>
<front id="pins_RAMPS_OLDH-58">#if DISABLED(SDSUPPORT)</front>
<front id="pins_RAMPS_OLDH-59">  #define MAX6675_SS       66// Do not use pin 53 if there is even the remote possibility of using Display/SD card</front>
<front id="pins_RAMPS_OLDH-60">#else</front>
<front id="pins_RAMPS_OLDH-61">  #define MAX6675_SS       66// Do not use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present</front>
<front id="pins_RAMPS_OLDH-62">#endif</front>
<front id="pins_RAMPS_OLDH-63"></front>
<front id="pins_RAMPS_OLDH-64">#if DISABLED(SDSUPPORT)</front>
<front id="pins_RAMPS_OLDH-65">  // these pins are defined in the SD library if building with SD support</front>
<front id="pins_RAMPS_OLDH-66">  #define SCK_PIN          52</front>
<front id="pins_RAMPS_OLDH-67">  #define MISO_PIN         50</front>
<front id="pins_RAMPS_OLDH-68">  #define MOSI_PIN         51</front>
<front id="pins_RAMPS_OLDH-69">#endif</front>
 </pre>
<h1 id="pins_RIGIDBOARDHtitle" >pins_RIGIDBOARD.h</h1>
<pre id="pins_RIGIDBOARDH"  class="prettyprint linenums"><front id="pins_RIGIDBOARDH-1">/**</front>
<front id="pins_RIGIDBOARDH-2"> * RIGIDBOARD Arduino Mega with RAMPS v1.3 pin assignments</front>
<front id="pins_RIGIDBOARDH-3"> */</front>
<front id="pins_RIGIDBOARDH-4"></front>
<front id="pins_RIGIDBOARDH-5">#include "pins_RAMPS_13.h"</front>
<front id="pins_RIGIDBOARDH-6"></front>
<front id="pins_RIGIDBOARDH-7">#if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="pins_RIGIDBOARDH-8">  #define Z_MIN_PROBE_PIN  19</front>
<front id="pins_RIGIDBOARDH-9">#endif</front>
<front id="pins_RIGIDBOARDH-10"></front>
<front id="pins_RIGIDBOARDH-11">#undef HEATER_0_PIN</front>
<front id="pins_RIGIDBOARDH-12">#undef HEATER_1_PIN</front>
<front id="pins_RIGIDBOARDH-13">#define HEATER_0_PIN        9    // EXTRUDER 1</front>
<front id="pins_RIGIDBOARDH-14">#define HEATER_1_PIN       12    // EXTRUDER 2 (FAN On Sprinter)</front>
<front id="pins_RIGIDBOARDH-15"></front>
<front id="pins_RIGIDBOARDH-16">#undef TEMP_0_PIN</front>
<front id="pins_RIGIDBOARDH-17">#undef TEMP_1_PIN</front>
<front id="pins_RIGIDBOARDH-18">#define TEMP_0_PIN         14   // ANALOG NUMBERING</front>
<front id="pins_RIGIDBOARDH-19">#define TEMP_1_PIN         13   // ANALOG NUMBERING</front>
<front id="pins_RIGIDBOARDH-20"></front>
<front id="pins_RIGIDBOARDH-21">// LCD Panel options for the RigidBoard</front>
<front id="pins_RIGIDBOARDH-22"></front>
<front id="pins_RIGIDBOARDH-23">#if ENABLED(RIGIDBOT_PANEL)</front>
<front id="pins_RIGIDBOARDH-24"></front>
<front id="pins_RIGIDBOARDH-25">  #undef BEEPER_PIN</front>
<front id="pins_RIGIDBOARDH-26">  #define BEEPER_PIN -1</front>
<front id="pins_RIGIDBOARDH-27"></front>
<front id="pins_RIGIDBOARDH-28">  #undef SD_DETECT_PIN</front>
<front id="pins_RIGIDBOARDH-29">  #define SD_DETECT_PIN 22</front>
<front id="pins_RIGIDBOARDH-30"></front>
<front id="pins_RIGIDBOARDH-31">  // Extra button definitions, substitute for EN1 / EN2</front>
<front id="pins_RIGIDBOARDH-32">  #define BTN_UP  37 // BTN_EN1</front>
<front id="pins_RIGIDBOARDH-33">  #define BTN_DWN 35 // BTN_EN2</front>
<front id="pins_RIGIDBOARDH-34">  #define BTN_LFT 33</front>
<front id="pins_RIGIDBOARDH-35">  #define BTN_RT  32</front>
<front id="pins_RIGIDBOARDH-36"></front>
<front id="pins_RIGIDBOARDH-37">  // Marlin can respond to UP/DOWN by default</front>
<front id="pins_RIGIDBOARDH-38">  // #undef  BTN_EN1</front>
<front id="pins_RIGIDBOARDH-39">  // #undef  BTN_EN2</front>
<front id="pins_RIGIDBOARDH-40">  // #define BTN_EN1 -1</front>
<front id="pins_RIGIDBOARDH-41">  // #define BTN_EN2 -1</front>
<front id="pins_RIGIDBOARDH-42"></front>
<front id="pins_RIGIDBOARDH-43">  #undef  BTN_ENC</front>
<front id="pins_RIGIDBOARDH-44">  #define BTN_ENC 31</front>
<front id="pins_RIGIDBOARDH-45"></front>
<front id="pins_RIGIDBOARDH-46">  #undef  SD_DETECT_PIN</front>
<front id="pins_RIGIDBOARDH-47">  #define SD_DETECT_PIN 22</front>
<front id="pins_RIGIDBOARDH-48"></front>
<front id="pins_RIGIDBOARDH-49">#elif ENABLED(REPRAP_DISCOUNT_SMART_CONTROLLER)</front>
<front id="pins_RIGIDBOARDH-50"></front>
<front id="pins_RIGIDBOARDH-51">  #undef BEEPER_PIN</front>
<front id="pins_RIGIDBOARDH-52">  #define BEEPER_PIN -1</front>
<front id="pins_RIGIDBOARDH-53"></front>
<front id="pins_RIGIDBOARDH-54">  #undef  SD_DETECT_PIN</front>
<front id="pins_RIGIDBOARDH-55">  #define SD_DETECT_PIN 22</front>
<front id="pins_RIGIDBOARDH-56"></front>
<front id="pins_RIGIDBOARDH-57">  #undef  KILL_PIN</front>
<front id="pins_RIGIDBOARDH-58">  #define KILL_PIN 32</front>
<front id="pins_RIGIDBOARDH-59"></front>
<front id="pins_RIGIDBOARDH-60">#endif</front>
<front id="pins_RIGIDBOARDH-61"></front>
<front id="pins_RIGIDBOARDH-62">// SPI for Max6675 Thermocouple</front>
<front id="pins_RIGIDBOARDH-63">#undef MAX6675_SS</front>
<front id="pins_RIGIDBOARDH-64">#if ENABLED(SDSUPPORT)</front>
<front id="pins_RIGIDBOARDH-65">  #define MAX6675_SS       49 // Don't use pin 49 as this is tied to the switch inside the SD card socket to detect if there is an SD card present</front>
<front id="pins_RIGIDBOARDH-66">#else</front>
<front id="pins_RIGIDBOARDH-67">  #define MAX6675_SS       53 // Don't use pin 53 if there is even the remote possibility of using Display/SD card</front>
<front id="pins_RIGIDBOARDH-68">#endif</front>
<front id="pins_RIGIDBOARDH-69"></front>
<front id="pins_RIGIDBOARDH-70">// RigidBot swaps E0 / E1 plugs vs RAMPS 1.3</front>
<front id="pins_RIGIDBOARDH-71"></front>
<front id="pins_RIGIDBOARDH-72">#undef E0_STEP_PIN</front>
<front id="pins_RIGIDBOARDH-73">#undef E0_DIR_PIN</front>
<front id="pins_RIGIDBOARDH-74">#undef E0_ENABLE_PIN</front>
<front id="pins_RIGIDBOARDH-75">#define E0_STEP_PIN        36</front>
<front id="pins_RIGIDBOARDH-76">#define E0_DIR_PIN         34</front>
<front id="pins_RIGIDBOARDH-77">#define E0_ENABLE_PIN      30</front>
<front id="pins_RIGIDBOARDH-78"></front>
<front id="pins_RIGIDBOARDH-79">#undef E1_STEP_PIN</front>
<front id="pins_RIGIDBOARDH-80">#undef E1_DIR_PIN</front>
<front id="pins_RIGIDBOARDH-81">#undef E1_ENABLE_PIN</front>
<front id="pins_RIGIDBOARDH-82">#define E1_STEP_PIN        26</front>
<front id="pins_RIGIDBOARDH-83">#define E1_DIR_PIN         28</front>
<front id="pins_RIGIDBOARDH-84">#define E1_ENABLE_PIN      24</front>
<front id="pins_RIGIDBOARDH-85"></front>
<front id="pins_RIGIDBOARDH-86">#undef  FAN_PIN</front>
<front id="pins_RIGIDBOARDH-87">#define FAN_PIN             8 // Same as RAMPS_13_EEF</front>
<front id="pins_RIGIDBOARDH-88"></front>
<front id="pins_RIGIDBOARDH-89">#undef  PS_ON_PIN</front>
<front id="pins_RIGIDBOARDH-90">#define PS_ON_PIN          -1</front>
<front id="pins_RIGIDBOARDH-91"></front>
<front id="pins_RIGIDBOARDH-92">#undef  HEATER_BED_PIN</front>
<front id="pins_RIGIDBOARDH-93">#define HEATER_BED_PIN     10</front>
<front id="pins_RIGIDBOARDH-94"></front>
<front id="pins_RIGIDBOARDH-95">#undef  TEMP_BED_PIN</front>
<front id="pins_RIGIDBOARDH-96">#define TEMP_BED_PIN       15   // ANALOG NUMBERING</front>
<front id="pins_RIGIDBOARDH-97"></front>
<front id="pins_RIGIDBOARDH-98">#define STEPPER_RESET_PIN  41   // Stepper drivers have a reset on RigidBot</front>
 </pre>
<h1 id="pins_RUMBAHtitle" >pins_RUMBA.h</h1>
<pre id="pins_RUMBAH"  class="prettyprint linenums"><front id="pins_RUMBAH-1">/**</front>
<front id="pins_RUMBAH-2"> * RUMBA pin assignments</front>
<front id="pins_RUMBAH-3"> */</front>
<front id="pins_RUMBAH-4"></front>
<front id="pins_RUMBAH-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_RUMBAH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_RUMBAH-7">#endif</front>
<front id="pins_RUMBAH-8"></front>
<front id="pins_RUMBAH-9">#if EXTRUDERS &gt; 3</front>
<front id="pins_RUMBAH-10">  #error RUMBA supports up to 3 extruders. Comment this line to keep going.</front>
<front id="pins_RUMBAH-11">#endif</front>
<front id="pins_RUMBAH-12"></front>
<front id="pins_RUMBAH-13">#define X_STEP_PIN         17</front>
<front id="pins_RUMBAH-14">#define X_DIR_PIN          16</front>
<front id="pins_RUMBAH-15">#define X_ENABLE_PIN       48</front>
<front id="pins_RUMBAH-16">#define X_MIN_PIN          37</front>
<front id="pins_RUMBAH-17">#define X_MAX_PIN          36</front>
<front id="pins_RUMBAH-18"></front>
<front id="pins_RUMBAH-19">#define Y_STEP_PIN         54</front>
<front id="pins_RUMBAH-20">#define Y_DIR_PIN          47</front>
<front id="pins_RUMBAH-21">#define Y_ENABLE_PIN       55</front>
<front id="pins_RUMBAH-22">#define Y_MIN_PIN          35</front>
<front id="pins_RUMBAH-23">#define Y_MAX_PIN          34</front>
<front id="pins_RUMBAH-24"></front>
<front id="pins_RUMBAH-25">#define Z_STEP_PIN         57</front>
<front id="pins_RUMBAH-26">#define Z_DIR_PIN          56</front>
<front id="pins_RUMBAH-27">#define Z_ENABLE_PIN       62</front>
<front id="pins_RUMBAH-28">#define Z_MIN_PIN          33</front>
<front id="pins_RUMBAH-29">#define Z_MAX_PIN          32</front>
<front id="pins_RUMBAH-30"></front>
<front id="pins_RUMBAH-31">#if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="pins_RUMBAH-32">  // Define a pin to use as the signal pin on Arduino for the Z probe endstop.</front>
<front id="pins_RUMBAH-33">  #define Z_MIN_PROBE_PIN  33</front>
<front id="pins_RUMBAH-34">#endif</front>
<front id="pins_RUMBAH-35"></front>
<front id="pins_RUMBAH-36">#define E0_STEP_PIN        23</front>
<front id="pins_RUMBAH-37">#define E0_DIR_PIN         22</front>
<front id="pins_RUMBAH-38">#define E0_ENABLE_PIN      24</front>
<front id="pins_RUMBAH-39"></front>
<front id="pins_RUMBAH-40">#define E1_STEP_PIN        26</front>
<front id="pins_RUMBAH-41">#define E1_DIR_PIN         25</front>
<front id="pins_RUMBAH-42">#define E1_ENABLE_PIN      27</front>
<front id="pins_RUMBAH-43"></front>
<front id="pins_RUMBAH-44">#define E2_STEP_PIN        29</front>
<front id="pins_RUMBAH-45">#define E2_DIR_PIN         28</front>
<front id="pins_RUMBAH-46">#define E2_ENABLE_PIN      39</front>
<front id="pins_RUMBAH-47"></front>
<front id="pins_RUMBAH-48">#define LED_PIN            13</front>
<front id="pins_RUMBAH-49"></front>
<front id="pins_RUMBAH-50">#define FAN_PIN             7</front>
<front id="pins_RUMBAH-51">#define FAN1_PIN            8</front>
<front id="pins_RUMBAH-52"></front>
<front id="pins_RUMBAH-53">#define PS_ON_PIN          45</front>
<front id="pins_RUMBAH-54">#define KILL_PIN           46</front>
<front id="pins_RUMBAH-55"></front>
<front id="pins_RUMBAH-56">#if TEMP_SENSOR_0 == 0</front>
<front id="pins_RUMBAH-57">  #define TEMP_0_PIN           -1</front>
<front id="pins_RUMBAH-58">  #define HEATER_0_PIN         -1</front>
<front id="pins_RUMBAH-59">#else</front>
<front id="pins_RUMBAH-60">  #define HEATER_0_PIN          2   // EXTRUDER 1</front>
<front id="pins_RUMBAH-61">  #if TEMP_SENSOR_0 == -1</front>
<front id="pins_RUMBAH-62">    #define TEMP_0_PIN          6   // ANALOG NUMBERING - connector *K1* on RUMBA thermocouple ADD ON is used</front>
<front id="pins_RUMBAH-63">  #else</front>
<front id="pins_RUMBAH-64">    #define TEMP_0_PIN         15   // ANALOG NUMBERING - default connector for thermistor *T0* on rumba board is used</front>
<front id="pins_RUMBAH-65">  #endif</front>
<front id="pins_RUMBAH-66">#endif</front>
<front id="pins_RUMBAH-67"></front>
<front id="pins_RUMBAH-68">#if TEMP_SENSOR_1 == 0</front>
<front id="pins_RUMBAH-69">  #define TEMP_1_PIN           -1</front>
<front id="pins_RUMBAH-70">  #define HEATER_1_PIN         -1</front>
<front id="pins_RUMBAH-71">#else</front>
<front id="pins_RUMBAH-72">  #define HEATER_1_PIN          3   // EXTRUDER 2</front>
<front id="pins_RUMBAH-73">  #if TEMP_SENSOR_1 == -1</front>
<front id="pins_RUMBAH-74">    #define TEMP_1_PIN          5   // ANALOG NUMBERING - connector *K2* on RUMBA thermocouple ADD ON is used</front>
<front id="pins_RUMBAH-75">  #else</front>
<front id="pins_RUMBAH-76">    #define TEMP_1_PIN         14   // ANALOG NUMBERING - default connector for thermistor *T1* on rumba board is used</front>
<front id="pins_RUMBAH-77">  #endif</front>
<front id="pins_RUMBAH-78">#endif</front>
<front id="pins_RUMBAH-79"></front>
<front id="pins_RUMBAH-80">#if TEMP_SENSOR_2 == 0</front>
<front id="pins_RUMBAH-81">  #define TEMP_2_PIN          -1</front>
<front id="pins_RUMBAH-82">  #define HEATER_2_PIN        -1</front>
<front id="pins_RUMBAH-83">#else</front>
<front id="pins_RUMBAH-84">  #define HEATER_2_PIN         6    // EXTRUDER 3</front>
<front id="pins_RUMBAH-85">  #if TEMP_SENSOR_2 == -1</front>
<front id="pins_RUMBAH-86">    #define TEMP_2_PIN         7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used &lt;-- this can not be used when TEMP_SENSOR_BED is defined as thermocouple</front>
<front id="pins_RUMBAH-87">  #else</front>
<front id="pins_RUMBAH-88">    #define TEMP_2_PIN         13   // ANALOG NUMBERING - default connector for thermistor *T2* on rumba board is used</front>
<front id="pins_RUMBAH-89">  #endif</front>
<front id="pins_RUMBAH-90">#endif</front>
<front id="pins_RUMBAH-91"></front>
<front id="pins_RUMBAH-92">//optional for extruder 4 or chamber: #define TEMP_X_PIN         12   // ANALOG NUMBERING - default connector for thermistor *T3* on rumba board is used</front>
<front id="pins_RUMBAH-93">//optional FAN1 can be used as 4th heater output: #define HEATER_3_PIN       8    // EXTRUDER 4</front>
<front id="pins_RUMBAH-94"></front>
<front id="pins_RUMBAH-95">#if TEMP_SENSOR_BED == 0</front>
<front id="pins_RUMBAH-96">  #define TEMP_BED_PIN        -1</front>
<front id="pins_RUMBAH-97">  #define HEATER_BED_PIN      -1</front>
<front id="pins_RUMBAH-98">#else</front>
<front id="pins_RUMBAH-99">  #define HEATER_BED_PIN       9    // BED</front>
<front id="pins_RUMBAH-100">  #if TEMP_SENSOR_BED == -1</front>
<front id="pins_RUMBAH-101">    #define TEMP_BED_PIN       7    // ANALOG NUMBERING - connector *K3* on RUMBA thermocouple ADD ON is used &lt;-- this can not be used when TEMP_SENSOR_2 is defined as thermocouple</front>
<front id="pins_RUMBAH-102">  #else</front>
<front id="pins_RUMBAH-103">    #define TEMP_BED_PIN      11    // ANALOG NUMBERING - default connector for thermistor *THB* on rumba board is used</front>
<front id="pins_RUMBAH-104">  #endif</front>
<front id="pins_RUMBAH-105">#endif</front>
<front id="pins_RUMBAH-106"></front>
<front id="pins_RUMBAH-107">#define SDPOWER            -1</front>
<front id="pins_RUMBAH-108">#define SDSS               53</front>
<front id="pins_RUMBAH-109">#define SD_DETECT_PIN      49</front>
<front id="pins_RUMBAH-110">#define BEEPER_PIN         44</front>
<front id="pins_RUMBAH-111">#define LCD_PINS_RS        19</front>
<front id="pins_RUMBAH-112">#define LCD_PINS_ENABLE    42</front>
<front id="pins_RUMBAH-113">#define LCD_PINS_D4        18</front>
<front id="pins_RUMBAH-114">#define LCD_PINS_D5        38</front>
<front id="pins_RUMBAH-115">#define LCD_PINS_D6        41</front>
<front id="pins_RUMBAH-116">#define LCD_PINS_D7        40</front>
<front id="pins_RUMBAH-117">#define BTN_EN1            11</front>
<front id="pins_RUMBAH-118">#define BTN_EN2            12</front>
<front id="pins_RUMBAH-119">#define BTN_ENC            43</front>
<front id="pins_RUMBAH-120"></front>
<front id="pins_RUMBAH-121">#define SERVO0_PIN         5</front>
<front id="pins_RUMBAH-122"></front>
 </pre>
<h1 id="pins_SANGUINOLOLU_11Htitle" >pins_SANGUINOLOLU_11.h</h1>
<pre id="pins_SANGUINOLOLU_11H"  class="prettyprint linenums"><front id="pins_SANGUINOLOLU_11H-1">/**</front>
<front id="pins_SANGUINOLOLU_11H-2"> * Sanguinololu board pin assignments</front>
<front id="pins_SANGUINOLOLU_11H-3"> */</front>
<front id="pins_SANGUINOLOLU_11H-4"></front>
<front id="pins_SANGUINOLOLU_11H-5">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pins_SANGUINOLOLU_11H-6">  #error Oops!  Make sure you have 'Sanguino' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_SANGUINOLOLU_11H-7">#endif</front>
<front id="pins_SANGUINOLOLU_11H-8"></front>
<front id="pins_SANGUINOLOLU_11H-9">#define X_STEP_PIN         15</front>
<front id="pins_SANGUINOLOLU_11H-10">#define X_DIR_PIN          21</front>
<front id="pins_SANGUINOLOLU_11H-11">#define X_STOP_PIN         18</front>
<front id="pins_SANGUINOLOLU_11H-12"></front>
<front id="pins_SANGUINOLOLU_11H-13">#define Y_STEP_PIN         22</front>
<front id="pins_SANGUINOLOLU_11H-14">#define Y_DIR_PIN          23</front>
<front id="pins_SANGUINOLOLU_11H-15">#define Y_STOP_PIN         19</front>
<front id="pins_SANGUINOLOLU_11H-16"></front>
<front id="pins_SANGUINOLOLU_11H-17">#define Z_STEP_PIN          3</front>
<front id="pins_SANGUINOLOLU_11H-18">#define Z_DIR_PIN           2</front>
<front id="pins_SANGUINOLOLU_11H-19">#define Z_STOP_PIN         20</front>
<front id="pins_SANGUINOLOLU_11H-20"></front>
<front id="pins_SANGUINOLOLU_11H-21">#define E0_STEP_PIN         1</front>
<front id="pins_SANGUINOLOLU_11H-22">#define E0_DIR_PIN          0</front>
<front id="pins_SANGUINOLOLU_11H-23"></front>
<front id="pins_SANGUINOLOLU_11H-24">#define LED_PIN            -1</front>
<front id="pins_SANGUINOLOLU_11H-25">#define FAN_PIN            -1</front>
<front id="pins_SANGUINOLOLU_11H-26"></front>
<front id="pins_SANGUINOLOLU_11H-27">#if MB(AZTEEG_X1) || MB(STB_11) || MB(MELZI)</front>
<front id="pins_SANGUINOLOLU_11H-28">  #define FAN_PIN           4 // Works for Panelolu2 too</front>
<front id="pins_SANGUINOLOLU_11H-29">  #if MB(MELZI)</front>
<front id="pins_SANGUINOLOLU_11H-30">    #define LED_PIN        27 // On some broken versions of the Sanguino libraries the pin definitions are wrong, so LED_PIN needs to be 28. But you should upgrade your Sanguino libraries! See #368.</front>
<front id="pins_SANGUINOLOLU_11H-31">  #elif MB(STB_11)</front>
<front id="pins_SANGUINOLOLU_11H-32">    #define LCD_PIN_BL     17 // LCD backlight LED</front>
<front id="pins_SANGUINOLOLU_11H-33">  #endif</front>
<front id="pins_SANGUINOLOLU_11H-34">#endif</front>
<front id="pins_SANGUINOLOLU_11H-35"></front>
<front id="pins_SANGUINOLOLU_11H-36">#if ENABLED(Z_PROBE_SLED)</front>
<front id="pins_SANGUINOLOLU_11H-37">  #define SLED_PIN         -1</front>
<front id="pins_SANGUINOLOLU_11H-38">#endif</front>
<front id="pins_SANGUINOLOLU_11H-39"></front>
<front id="pins_SANGUINOLOLU_11H-40">#define PS_ON_PIN          -1</front>
<front id="pins_SANGUINOLOLU_11H-41">#define KILL_PIN           -1</front>
<front id="pins_SANGUINOLOLU_11H-42"></front>
<front id="pins_SANGUINOLOLU_11H-43">#define HEATER_0_PIN       13 // (extruder)</front>
<front id="pins_SANGUINOLOLU_11H-44">#define HEATER_1_PIN       -1</front>
<front id="pins_SANGUINOLOLU_11H-45">#define HEATER_2_PIN       -1</front>
<front id="pins_SANGUINOLOLU_11H-46"></front>
<front id="pins_SANGUINOLOLU_11H-47">#if ENABLED(SANGUINOLOLU_V_1_2)</front>
<front id="pins_SANGUINOLOLU_11H-48"></front>
<front id="pins_SANGUINOLOLU_11H-49">  #define HEATER_BED_PIN   12 // (bed)</front>
<front id="pins_SANGUINOLOLU_11H-50">  #define X_ENABLE_PIN     14</front>
<front id="pins_SANGUINOLOLU_11H-51">  #define Y_ENABLE_PIN     14</front>
<front id="pins_SANGUINOLOLU_11H-52">  #define Z_ENABLE_PIN     26</front>
<front id="pins_SANGUINOLOLU_11H-53">  #define E0_ENABLE_PIN    14</front>
<front id="pins_SANGUINOLOLU_11H-54"></front>
<front id="pins_SANGUINOLOLU_11H-55">  #if ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="pins_SANGUINOLOLU_11H-56">    #define FAN_PIN         4 // Uses Transistor1 (PWM) on Panelolu2's Sanguino Adapter Board to drive the fan</front>
<front id="pins_SANGUINOLOLU_11H-57">  #endif</front>
<front id="pins_SANGUINOLOLU_11H-58"></front>
<front id="pins_SANGUINOLOLU_11H-59">#else</front>
<front id="pins_SANGUINOLOLU_11H-60"></front>
<front id="pins_SANGUINOLOLU_11H-61">  #define HEATER_BED_PIN   14  // (bed)</front>
<front id="pins_SANGUINOLOLU_11H-62">  #define X_ENABLE_PIN     -1</front>
<front id="pins_SANGUINOLOLU_11H-63">  #define Y_ENABLE_PIN     -1</front>
<front id="pins_SANGUINOLOLU_11H-64">  #define Z_ENABLE_PIN     -1</front>
<front id="pins_SANGUINOLOLU_11H-65">  #define E0_ENABLE_PIN    -1</front>
<front id="pins_SANGUINOLOLU_11H-66"></front>
<front id="pins_SANGUINOLOLU_11H-67">#endif</front>
<front id="pins_SANGUINOLOLU_11H-68"></front>
<front id="pins_SANGUINOLOLU_11H-69">#define TEMP_0_PIN          7   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 33 extruder)</front>
<front id="pins_SANGUINOLOLU_11H-70">#define TEMP_1_PIN         -1</front>
<front id="pins_SANGUINOLOLU_11H-71">#define TEMP_2_PIN         -1</front>
<front id="pins_SANGUINOLOLU_11H-72">#define TEMP_BED_PIN        6   // MUST USE ANALOG INPUT NUMBERING NOT DIGITAL OUTPUT NUMBERING!!!!!!!!! (pin 34 bed)</front>
<front id="pins_SANGUINOLOLU_11H-73">#define SDPOWER            -1</front>
<front id="pins_SANGUINOLOLU_11H-74">#define SDSS               31</front>
<front id="pins_SANGUINOLOLU_11H-75"></front>
<front id="pins_SANGUINOLOLU_11H-76">/**</front>
<front id="pins_SANGUINOLOLU_11H-77"> * On some broken versions of the Sanguino libraries the pin definitions are wrong,</front>
<front id="pins_SANGUINOLOLU_11H-78"> * which then needs SDSS as pin 24. But you should upgrade your Sanguino libraries! See #368.</front>
<front id="pins_SANGUINOLOLU_11H-79"> */</front>
<front id="pins_SANGUINOLOLU_11H-80">//#define SDSS               24</front>
<front id="pins_SANGUINOLOLU_11H-81"></front>
<front id="pins_SANGUINOLOLU_11H-82">#if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)</front>
<front id="pins_SANGUINOLOLU_11H-83"></front>
<front id="pins_SANGUINOLOLU_11H-84">  // No buzzer installed</front>
<front id="pins_SANGUINOLOLU_11H-85">  #define BEEPER_PIN -1</front>
<front id="pins_SANGUINOLOLU_11H-86"></front>
<front id="pins_SANGUINOLOLU_11H-87">  // LCD Pins</front>
<front id="pins_SANGUINOLOLU_11H-88">  #if ENABLED(DOGLCD)</front>
<front id="pins_SANGUINOLOLU_11H-89"></front>
<front id="pins_SANGUINOLOLU_11H-90">    #if ENABLED(U8GLIB_ST7920) //SPI GLCD 12864 ST7920 ( like [www.digole.com] ) For Melzi V2.0</front>
<front id="pins_SANGUINOLOLU_11H-91"></front>
<front id="pins_SANGUINOLOLU_11H-92">      #if MB(MELZI) // Melzi board</front>
<front id="pins_SANGUINOLOLU_11H-93">        #define LCD_PINS_RS     30 //CS chip select /SS chip slave select</front>
<front id="pins_SANGUINOLOLU_11H-94">        #define LCD_PINS_ENABLE 29 //SID (MOSI)</front>
<front id="pins_SANGUINOLOLU_11H-95">        #define LCD_PINS_D4     17 //SCK (CLK) clock</front>
<front id="pins_SANGUINOLOLU_11H-96">        #define BEEPER_PIN      27 // Pin 27 is taken by LED_PIN, but Melzi LED does nothing with Marlin so this can be used for BEEPER_PIN. You can use this pin with M42 instead of BEEPER_PIN.</front>
<front id="pins_SANGUINOLOLU_11H-97">      #else         // Sanguinololu 1.3</front>
<front id="pins_SANGUINOLOLU_11H-98">        #define LCD_PINS_RS      4 </front>
<front id="pins_SANGUINOLOLU_11H-99">        #define LCD_PINS_ENABLE 17 </front>
<front id="pins_SANGUINOLOLU_11H-100">        #define LCD_PINS_D4     30 </front>
<front id="pins_SANGUINOLOLU_11H-101">        #define LCD_PINS_D5     29</front>
<front id="pins_SANGUINOLOLU_11H-102">        #define LCD_PINS_D6     28</front>
<front id="pins_SANGUINOLOLU_11H-103">        #define LCD_PINS_D7     27</front>
<front id="pins_SANGUINOLOLU_11H-104">      #endif</front>
<front id="pins_SANGUINOLOLU_11H-105"></front>
<front id="pins_SANGUINOLOLU_11H-106">    #else // DOGM SPI LCD Support</front>
<front id="pins_SANGUINOLOLU_11H-107"></front>
<front id="pins_SANGUINOLOLU_11H-108">      #define DOGLCD_A0         30</front>
<front id="pins_SANGUINOLOLU_11H-109">      #define DOGLCD_CS         29</front>
<front id="pins_SANGUINOLOLU_11H-110">      #define LCD_CONTRAST       1</front>
<front id="pins_SANGUINOLOLU_11H-111"></front>
<front id="pins_SANGUINOLOLU_11H-112">    #endif</front>
<front id="pins_SANGUINOLOLU_11H-113">  </front>
<front id="pins_SANGUINOLOLU_11H-114">    // Uncomment screen orientation</front>
<front id="pins_SANGUINOLOLU_11H-115">    #define LCD_SCREEN_ROT_0</front>
<front id="pins_SANGUINOLOLU_11H-116">    // #define LCD_SCREEN_ROT_90</front>
<front id="pins_SANGUINOLOLU_11H-117">    // #define LCD_SCREEN_ROT_180</front>
<front id="pins_SANGUINOLOLU_11H-118">    // #define LCD_SCREEN_ROT_270</front>
<front id="pins_SANGUINOLOLU_11H-119"></front>
<front id="pins_SANGUINOLOLU_11H-120">  #else // !DOGLCD - Standard Hitachi LCD controller</front>
<front id="pins_SANGUINOLOLU_11H-121"></front>
<front id="pins_SANGUINOLOLU_11H-122">    #define LCD_PINS_RS          4</front>
<front id="pins_SANGUINOLOLU_11H-123">    #define LCD_PINS_ENABLE     17</front>
<front id="pins_SANGUINOLOLU_11H-124">    #define LCD_PINS_D4         30</front>
<front id="pins_SANGUINOLOLU_11H-125">    #define LCD_PINS_D5         29</front>
<front id="pins_SANGUINOLOLU_11H-126">    #define LCD_PINS_D6         28</front>
<front id="pins_SANGUINOLOLU_11H-127">    #define LCD_PINS_D7         27</front>
<front id="pins_SANGUINOLOLU_11H-128"></front>
<front id="pins_SANGUINOLOLU_11H-129">  #endif // !DOGLCD</front>
<front id="pins_SANGUINOLOLU_11H-130"></front>
<front id="pins_SANGUINOLOLU_11H-131">  //The encoder and click button</front>
<front id="pins_SANGUINOLOLU_11H-132">  #define BTN_EN1               11</front>
<front id="pins_SANGUINOLOLU_11H-133">  #define BTN_EN2               10</front>
<front id="pins_SANGUINOLOLU_11H-134">  #if ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="pins_SANGUINOLOLU_11H-135">    #if MB(MELZI)</front>
<front id="pins_SANGUINOLOLU_11H-136">      #define BTN_ENC           29</front>
<front id="pins_SANGUINOLOLU_11H-137">      #define LCD_SDSS          30 // Panelolu2 SD card reader rather than the Melzi</front>
<front id="pins_SANGUINOLOLU_11H-138">    #else</front>
<front id="pins_SANGUINOLOLU_11H-139">      #define BTN_ENC           30</front>
<front id="pins_SANGUINOLOLU_11H-140">    #endif</front>
<front id="pins_SANGUINOLOLU_11H-141">  #else</front>
<front id="pins_SANGUINOLOLU_11H-142">    #define BTN_ENC             16</front>
<front id="pins_SANGUINOLOLU_11H-143">    #define LCD_SDSS            28 // Smart Controller SD card reader rather than the Melzi</front>
<front id="pins_SANGUINOLOLU_11H-144">  #endif //Panelolu2</front>
<front id="pins_SANGUINOLOLU_11H-145"></front>
<front id="pins_SANGUINOLOLU_11H-146">  #define SD_DETECT_PIN         -1</front>
<front id="pins_SANGUINOLOLU_11H-147"></front>
<front id="pins_SANGUINOLOLU_11H-148">#elif ENABLED(MAKRPANEL)</front>
<front id="pins_SANGUINOLOLU_11H-149"></front>
<front id="pins_SANGUINOLOLU_11H-150">  #define BEEPER_PIN            29</front>
<front id="pins_SANGUINOLOLU_11H-151"></front>
<front id="pins_SANGUINOLOLU_11H-152">  // Pins for DOGM SPI LCD Support</front>
<front id="pins_SANGUINOLOLU_11H-153">  #define DOGLCD_A0             30</front>
<front id="pins_SANGUINOLOLU_11H-154">  #define DOGLCD_CS             17</front>
<front id="pins_SANGUINOLOLU_11H-155">  #define LCD_PIN_BL            28 // backlight LED on PA3</front>
<front id="pins_SANGUINOLOLU_11H-156">  // GLCD features</front>
<front id="pins_SANGUINOLOLU_11H-157">  #define LCD_CONTRAST           1</front>
<front id="pins_SANGUINOLOLU_11H-158">  // Uncomment screen orientation</front>
<front id="pins_SANGUINOLOLU_11H-159">  #define LCD_SCREEN_ROT_0</front>
<front id="pins_SANGUINOLOLU_11H-160">  // #define LCD_SCREEN_ROT_90</front>
<front id="pins_SANGUINOLOLU_11H-161">  // #define LCD_SCREEN_ROT_180</front>
<front id="pins_SANGUINOLOLU_11H-162">  // #define LCD_SCREEN_ROT_270</front>
<front id="pins_SANGUINOLOLU_11H-163">  //The encoder and click button</front>
<front id="pins_SANGUINOLOLU_11H-164">  #define BTN_EN1               11</front>
<front id="pins_SANGUINOLOLU_11H-165">  #define BTN_EN2               10</front>
<front id="pins_SANGUINOLOLU_11H-166">  #define BTN_ENC               16</front>
<front id="pins_SANGUINOLOLU_11H-167"></front>
<front id="pins_SANGUINOLOLU_11H-168">  #define SD_DETECT_PIN         -1</front>
<front id="pins_SANGUINOLOLU_11H-169"></front>
<front id="pins_SANGUINOLOLU_11H-170">#endif // MAKRPANEL</front>
<front id="pins_SANGUINOLOLU_11H-171"></front>
<front id="pins_SANGUINOLOLU_11H-172">// #if FAN_PIN == 12 || FAN_PIN ==13</front>
<front id="pins_SANGUINOLOLU_11H-173">//   #define FAN_SOFT_PWM</front>
<front id="pins_SANGUINOLOLU_11H-174">// #endif</front>
 </pre>
<h1 id="pins_SANGUINOLOLU_12Htitle" >pins_SANGUINOLOLU_12.h</h1>
<pre id="pins_SANGUINOLOLU_12H"  class="prettyprint linenums"><front id="pins_SANGUINOLOLU_12H-1">/**</front>
<front id="pins_SANGUINOLOLU_12H-2"> * Sanguinololu V1.2 pin assignments</front>
<front id="pins_SANGUINOLOLU_12H-3"> *</front>
<front id="pins_SANGUINOLOLU_12H-4"> * Applies to the following boards:</front>
<front id="pins_SANGUINOLOLU_12H-5"> *</front>
<front id="pins_SANGUINOLOLU_12H-6"> *  AZTEEG_X1</front>
<front id="pins_SANGUINOLOLU_12H-7"> *  MELZI</front>
<front id="pins_SANGUINOLOLU_12H-8"> *  MELZI_MAKR3D</front>
<front id="pins_SANGUINOLOLU_12H-9"> *  SANGUINOLOLU_12</front>
<front id="pins_SANGUINOLOLU_12H-10"> *  STB_11</front>
<front id="pins_SANGUINOLOLU_12H-11"> */</front>
<front id="pins_SANGUINOLOLU_12H-12"></front>
<front id="pins_SANGUINOLOLU_12H-13">#define SANGUINOLOLU_V_1_2</front>
<front id="pins_SANGUINOLOLU_12H-14"></front>
<front id="pins_SANGUINOLOLU_12H-15">#if defined(__AVR_ATmega1284P__)</front>
<front id="pins_SANGUINOLOLU_12H-16">  #define LARGE_FLASH true</front>
<front id="pins_SANGUINOLOLU_12H-17">#endif</front>
<front id="pins_SANGUINOLOLU_12H-18"></front>
<front id="pins_SANGUINOLOLU_12H-19">#include "pins_SANGUINOLOLU_11.h"</front>
 </pre>
<h1 id="pins_SAV_MKIHtitle" >pins_SAV_MKI.h</h1>
<pre id="pins_SAV_MKIH"  class="prettyprint linenums"><front id="pins_SAV_MKIH-1">/**</front>
<front id="pins_SAV_MKIH-2"> * SAV MkI pin assignments (AT90USB1286)</front>
<front id="pins_SAV_MKIH-3"> * Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!</front>
<front id="pins_SAV_MKIH-4"> * http://www.pjrc.com/teensy/teensyduino.html</front>
<front id="pins_SAV_MKIH-5"> * RepRap Clone Wars project board.</front>
<front id="pins_SAV_MKIH-6"> */</front>
<front id="pins_SAV_MKIH-7"></front>
<front id="pins_SAV_MKIH-8">#ifndef __AVR_AT90USB1286__</front>
<front id="pins_SAV_MKIH-9">  #error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_SAV_MKIH-10">#endif</front>
<front id="pins_SAV_MKIH-11"></front>
<front id="pins_SAV_MKIH-12">#define LARGE_FLASH        true</front>
<front id="pins_SAV_MKIH-13"></front>
<front id="pins_SAV_MKIH-14">#define X_STEP_PIN         0</front>
<front id="pins_SAV_MKIH-15">#define X_DIR_PIN          1</front>
<front id="pins_SAV_MKIH-16">#define X_ENABLE_PIN       39</front>
<front id="pins_SAV_MKIH-17"></front>
<front id="pins_SAV_MKIH-18">#define Y_STEP_PIN         2</front>
<front id="pins_SAV_MKIH-19">#define Y_DIR_PIN          3</front>
<front id="pins_SAV_MKIH-20">#define Y_ENABLE_PIN       38</front>
<front id="pins_SAV_MKIH-21"></front>
<front id="pins_SAV_MKIH-22">#define Z_STEP_PIN         4</front>
<front id="pins_SAV_MKIH-23">#define Z_DIR_PIN          5</front>
<front id="pins_SAV_MKIH-24">#define Z_ENABLE_PIN       23</front>
<front id="pins_SAV_MKIH-25"></front>
<front id="pins_SAV_MKIH-26">#define E0_STEP_PIN        6</front>
<front id="pins_SAV_MKIH-27">#define E0_DIR_PIN         7</front>
<front id="pins_SAV_MKIH-28">#define E0_ENABLE_PIN      19</front>
<front id="pins_SAV_MKIH-29"></front>
<front id="pins_SAV_MKIH-30">#define HEATER_0_PIN       21  // Extruder</front>
<front id="pins_SAV_MKIH-31">#define HEATER_1_PIN       -1</front>
<front id="pins_SAV_MKIH-32">#define HEATER_2_PIN       -1</front>
<front id="pins_SAV_MKIH-33">#define HEATER_BED_PIN     20  // Bed</front>
<front id="pins_SAV_MKIH-34">#define FAN_PIN            16  // Fan   -- from Teensyduino environment.</front>
<front id="pins_SAV_MKIH-35">                               // For the fan and Teensyduino uses a different pin mapping.</front>
<front id="pins_SAV_MKIH-36"></front>
<front id="pins_SAV_MKIH-37">#define X_STOP_PIN         13</front>
<front id="pins_SAV_MKIH-38">#define Y_STOP_PIN         14</front>
<front id="pins_SAV_MKIH-39">//#define Z_STOP_PIN         15</front>
<front id="pins_SAV_MKIH-40">#define Z_STOP_PIN         36  // For inductive sensor.</front>
<front id="pins_SAV_MKIH-41"></front>
<front id="pins_SAV_MKIH-42">#define TEMP_0_PIN          7  // Extruder / Analog pin numbering</front>
<front id="pins_SAV_MKIH-43">#define TEMP_BED_PIN        6  // Bed / Analog pin numbering</front>
<front id="pins_SAV_MKIH-44"></front>
<front id="pins_SAV_MKIH-45">#define TEMP_1_PIN         -1</front>
<front id="pins_SAV_MKIH-46">#define TEMP_2_PIN         -1</front>
<front id="pins_SAV_MKIH-47"></front>
<front id="pins_SAV_MKIH-48">#if DISABLED(SDSUPPORT)</front>
<front id="pins_SAV_MKIH-49">   // these pins are defined in the SD library if building with SD support</front>
<front id="pins_SAV_MKIH-50">  #define SCK_PIN          9</front>
<front id="pins_SAV_MKIH-51">  #define MISO_PIN         11</front>
<front id="pins_SAV_MKIH-52">  #define MOSI_PIN         10</front>
<front id="pins_SAV_MKIH-53">#endif</front>
<front id="pins_SAV_MKIH-54">#define SDSS               20         // PB0 - 8 in marlin env.</front>
<front id="pins_SAV_MKIH-55"></front>
<front id="pins_SAV_MKIH-56">// Extension header pin mapping</front>
<front id="pins_SAV_MKIH-57">// ----------------------------</front>
<front id="pins_SAV_MKIH-58">//  SCL (I2C)-D0    A0 (An), IO</front>
<front id="pins_SAV_MKIH-59">//  SDA (I2C)-D1    A1 (An), IO</front>
<front id="pins_SAV_MKIH-60">//  RX1-D2          A2 (An), IO</front>
<front id="pins_SAV_MKIH-61">//  TX1-D3          A3 (An), IO</front>
<front id="pins_SAV_MKIH-62">//  PWM-D24         A4 (An), IO</front>
<front id="pins_SAV_MKIH-63">//  5V              GND</front>
<front id="pins_SAV_MKIH-64">//  12V             GND</front>
<front id="pins_SAV_MKIH-65">#define EXT_AUX_SCL_D0            0  // 0 (teensy), 24 (marlin)</front>
<front id="pins_SAV_MKIH-66">#define EXT_AUX_SDA_D1            1  // 1 (teensy), 25 (marlin)</front>
<front id="pins_SAV_MKIH-67">#define EXT_AUX_RX1_D2            26 // 2 (teensy), 26 (marlin)</front>
<front id="pins_SAV_MKIH-68">#define EXT_AUX_TX1_D3            27 // 3 (teensy), 27 (marlin)</front>
<front id="pins_SAV_MKIH-69">#define EXT_AUX_PWM_D24           12 // 24 (teensy), 12 (marlin)</front>
<front id="pins_SAV_MKIH-70">#define EXT_AUX_A0                 0 // Analog</front>
<front id="pins_SAV_MKIH-71">#define EXT_AUX_A0_IO             40 // Digital IO, 38 (teensy), 40 (marlin)</front>
<front id="pins_SAV_MKIH-72">#define EXT_AUX_A1                 1 // Analog</front>
<front id="pins_SAV_MKIH-73">#define EXT_AUX_A1_IO             41 // Digital IO, 39 (teensy), 41 (marlin)</front>
<front id="pins_SAV_MKIH-74">#define EXT_AUX_A2                 2 // Analog</front>
<front id="pins_SAV_MKIH-75">#define EXT_AUX_A2_IO             42 // Digital IO, 40 (teensy), 42 (marlin)</front>
<front id="pins_SAV_MKIH-76">#define EXT_AUX_A3                 3 // Analog</front>
<front id="pins_SAV_MKIH-77">#define EXT_AUX_A3_IO             43 // Digital IO, 41 (teensy), 43 (marlin)</front>
<front id="pins_SAV_MKIH-78">#define EXT_AUX_A4                 4 // Analog</front>
<front id="pins_SAV_MKIH-79">#define EXT_AUX_A4_IO             44 // Digital IO, 42 (teensy), 44 (marlin)</front>
<front id="pins_SAV_MKIH-80"></front>
<front id="pins_SAV_MKIH-81"></front>
<front id="pins_SAV_MKIH-82">#define SDPOWER            -1</front>
<front id="pins_SAV_MKIH-83">#define LED_PIN            -1</front>
<front id="pins_SAV_MKIH-84">#define PS_ON_PIN          -1</front>
<front id="pins_SAV_MKIH-85">#define ALARM_PIN          -1</front>
<front id="pins_SAV_MKIH-86">#define SD_DETECT_PIN      -1</front>
<front id="pins_SAV_MKIH-87"></front>
<front id="pins_SAV_MKIH-88">#define BEEPER_PIN         -1</front>
<front id="pins_SAV_MKIH-89">#define LCD_PINS_RS        -1</front>
<front id="pins_SAV_MKIH-90">#define LCD_PINS_ENABLE    -1</front>
<front id="pins_SAV_MKIH-91">#define LCD_PINS_D4        -1</front>
<front id="pins_SAV_MKIH-92">#define LCD_PINS_D5        -1</front>
<front id="pins_SAV_MKIH-93">#define LCD_PINS_D6        -1</front>
<front id="pins_SAV_MKIH-94">#define LCD_PINS_D7        -1</front>
<front id="pins_SAV_MKIH-95"></front>
<front id="pins_SAV_MKIH-96">#if ENABLED(SAV_3DLCD)</front>
<front id="pins_SAV_MKIH-97">  // For LCD SHIFT register LCD</front>
<front id="pins_SAV_MKIH-98">  #define SR_DATA_PIN         EXT_AUX_SDA_D1</front>
<front id="pins_SAV_MKIH-99">  #define SR_CLK_PIN          EXT_AUX_SCL_D0</front>
<front id="pins_SAV_MKIH-100">#endif  // SAV_3DLCD</front>
<front id="pins_SAV_MKIH-101"></front>
<front id="pins_SAV_MKIH-102">#if ENABLED(SAV_3DLCD) || ENABLED(SAV_3DGLCD)</front>
<front id="pins_SAV_MKIH-103">  #define BTN_EN1            EXT_AUX_A1_IO</front>
<front id="pins_SAV_MKIH-104">  #define BTN_EN2            EXT_AUX_A0_IO</front>
<front id="pins_SAV_MKIH-105">  #define BTN_ENC            EXT_AUX_PWM_D24</front>
<front id="pins_SAV_MKIH-106"></front>
<front id="pins_SAV_MKIH-107">  #define KILL_PIN           EXT_AUX_A2_IO</front>
<front id="pins_SAV_MKIH-108">  #define HOME_PIN           EXT_AUX_A4_IO</front>
<front id="pins_SAV_MKIH-109">#endif // SAV_3DLCD || SAV_3DGLCD</front>
<front id="pins_SAV_MKIH-110"></front>
<front id="pins_SAV_MKIH-111">#define SERVO0_PIN         41 // In teensy's pin definition for pinMode (in servo.cpp)</front>
 </pre>
<h1 id="pins_SETHIHtitle" >pins_SETHI.h</h1>
<pre id="pins_SETHIH"  class="prettyprint linenums"><front id="pins_SETHIH-1">/**</front>
<front id="pins_SETHIH-2"> * Sethi 3D_1 pin assignments - www.sethi3d.com.br</front>
<front id="pins_SETHIH-3"> */</front>
<front id="pins_SETHIH-4"></front>
<front id="pins_SETHIH-5">#if !defined(__AVR_ATmega644P__) && !defined(__AVR_ATmega644__) && !defined(__AVR_ATmega1284P__)</front>
<front id="pins_SETHIH-6">  #error Oops!  Make sure you have 'Sethi 3D' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_SETHIH-7">#endif</front>
<front id="pins_SETHIH-8"></front>
<front id="pins_SETHIH-9">#ifndef GEN7_VERSION</front>
<front id="pins_SETHIH-10">  #define GEN7_VERSION 12 // v1.x</front>
<front id="pins_SETHIH-11">#endif</front>
<front id="pins_SETHIH-12"></front>
<front id="pins_SETHIH-13">//x axis pins</front>
<front id="pins_SETHIH-14">#define X_STEP_PIN 19</front>
<front id="pins_SETHIH-15">#define X_DIR_PIN 18</front>
<front id="pins_SETHIH-16">#define X_ENABLE_PIN 24</front>
<front id="pins_SETHIH-17">#define X_STOP_PIN 2</front>
<front id="pins_SETHIH-18"></front>
<front id="pins_SETHIH-19">//y axis pins</front>
<front id="pins_SETHIH-20">#define Y_STEP_PIN 23</front>
<front id="pins_SETHIH-21">#define Y_DIR_PIN 22</front>
<front id="pins_SETHIH-22">#define Y_ENABLE_PIN 24</front>
<front id="pins_SETHIH-23">#define Y_STOP_PIN 0</front>
<front id="pins_SETHIH-24"></front>
<front id="pins_SETHIH-25">//z axis pins</front>
<front id="pins_SETHIH-26">#define Z_STEP_PIN 26</front>
<front id="pins_SETHIH-27">#define Z_DIR_PIN 25</front>
<front id="pins_SETHIH-28">#define Z_ENABLE_PIN 24</front>
<front id="pins_SETHIH-29">#define Z_MIN_PIN 1</front>
<front id="pins_SETHIH-30">#define Z_MAX_PIN 0</front>
<front id="pins_SETHIH-31"></front>
<front id="pins_SETHIH-32">//extruder pins</front>
<front id="pins_SETHIH-33">#define E0_STEP_PIN 28</front>
<front id="pins_SETHIH-34">#define E0_DIR_PIN 27</front>
<front id="pins_SETHIH-35">#define E0_ENABLE_PIN 24</front>
<front id="pins_SETHIH-36"></front>
<front id="pins_SETHIH-37">#define TEMP_0_PIN 1</front>
<front id="pins_SETHIH-38">#define TEMP_1_PIN -1</front>
<front id="pins_SETHIH-39">#define TEMP_2_PIN -1</front>
<front id="pins_SETHIH-40">#define TEMP_BED_PIN 2</front>
<front id="pins_SETHIH-41"></front>
<front id="pins_SETHIH-42">#define HEATER_0_PIN 4</front>
<front id="pins_SETHIH-43">#define HEATER_1_PIN -1</front>
<front id="pins_SETHIH-44">#define HEATER_2_PIN -1</front>
<front id="pins_SETHIH-45">#define HEATER_BED_PIN 3</front>
<front id="pins_SETHIH-46"></front>
<front id="pins_SETHIH-47">#define KILL_PIN -1</front>
<front id="pins_SETHIH-48"></front>
<front id="pins_SETHIH-49">#define SDPOWER -1</front>
<front id="pins_SETHIH-50">#define SDSS -1 // SCL pin of I2C header</front>
<front id="pins_SETHIH-51">#define LED_PIN -1</front>
<front id="pins_SETHIH-52"></front>
<front id="pins_SETHIH-53">#if (GEN7_VERSION &gt;= 13)</front>
<front id="pins_SETHIH-54">  // Gen7 v1.3 removed the fan pin</front>
<front id="pins_SETHIH-55">  #define FAN_PIN -1</front>
<front id="pins_SETHIH-56">#else</front>
<front id="pins_SETHIH-57">  #define FAN_PIN 31</front>
<front id="pins_SETHIH-58">#endif</front>
<front id="pins_SETHIH-59"></front>
<front id="pins_SETHIH-60">#define PS_ON_PIN 15</front>
<front id="pins_SETHIH-61"></front>
<front id="pins_SETHIH-62">//All these generations of Gen7 supply thermistor power</front>
<front id="pins_SETHIH-63">//via PS_ON, so ignore bad thermistor readings</front>
<front id="pins_SETHIH-64">#define BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</front>
<front id="pins_SETHIH-65"></front>
<front id="pins_SETHIH-66">//our pin for debugging.</front>
<front id="pins_SETHIH-67">#define DEBUG_PIN 0</front>
<front id="pins_SETHIH-68"></front>
<front id="pins_SETHIH-69">//our RS485 pins</front>
<front id="pins_SETHIH-70">#define TX_ENABLE_PIN 12</front>
<front id="pins_SETHIH-71">#define RX_ENABLE_PIN 13</front>
 </pre>
<h1 id="pins_STB_11Htitle" >pins_STB_11.h</h1>
<pre id="pins_STB_11H"  class="prettyprint linenums"><front id="pins_STB_11H-1">/**</front>
<front id="pins_STB_11H-2"> * STB V1.1 pin assignments</front>
<front id="pins_STB_11H-3"> */</front>
<front id="pins_STB_11H-4"></front>
<front id="pins_STB_11H-5">#define SANGUINOLOLU_V_1_2</front>
<front id="pins_STB_11H-6"></front>
<front id="pins_STB_11H-7">#if defined(__AVR_ATmega1284P__)</front>
<front id="pins_STB_11H-8">  #define LARGE_FLASH true</front>
<front id="pins_STB_11H-9">#endif</front>
<front id="pins_STB_11H-10"></front>
<front id="pins_STB_11H-11">#include "pins_SANGUINOLOLU_11.h"</front>
 </pre>
<h1 id="pins_TEENSY2Htitle" >pins_TEENSY2.h</h1>
<pre id="pins_TEENSY2H"  class="prettyprint linenums"><front id="pins_TEENSY2H-1">/**</front>
<front id="pins_TEENSY2H-2"> * Teensy++ 2.0 Breadboard pin assignments (AT90USB1286)</front>
<front id="pins_TEENSY2H-3"> * Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!</front>
<front id="pins_TEENSY2H-4"> * http://www.pjrc.com/teensy/teensyduino.html</front>
<front id="pins_TEENSY2H-5"> * See http://reprap.org/wiki/Printrboard for more info</front>
<front id="pins_TEENSY2H-6"> *</front>
<front id="pins_TEENSY2H-7"> * CLI build: DEFINES=AT90USBxx_TEENSYPP_ASSIGNMENTS HARDWARE_MOTHERBOARD=84 make</front>
<front id="pins_TEENSY2H-8"> *</front>
<front id="pins_TEENSY2H-9"> *  DaveX plan for Teensylu/printrboard-type pinouts for a TeensyBreadboard:</front>
<front id="pins_TEENSY2H-10"> *  (ref teensylu & sprinter)</front>
<front id="pins_TEENSY2H-11"> *</front>
<front id="pins_TEENSY2H-12"> *                               USB</front>
<front id="pins_TEENSY2H-13"> *           GND       GND |-----#####-----| +5V              ATX +5SB</front>
<front id="pins_TEENSY2H-14"> *     ATX PS_ON    PWM 27 |b7   #####   b6| 26    PWM*       Stepper Enable </front>
<front id="pins_TEENSY2H-15"> *                  PWM  0 |d0           b5| 25    PWM*        </front>
<front id="pins_TEENSY2H-16"> *                  PWM  1 |d1           b4| 24    PWM        </front>
<front id="pins_TEENSY2H-17"> *         X_MIN         2 |d2           b3| 23               MISO_PIN</front>
<front id="pins_TEENSY2H-18"> *         Y_MIN         3 |d3           b2| 22               MOSI_PIN</front>
<front id="pins_TEENSY2H-19"> *         Z_MIN         4 |d4  * *      b1| 21               SCK_PIN       </front>
<front id="pins_TEENSY2H-20"> *                       5 |d5  e e      b0| 20               SDSS              </front>
<front id="pins_TEENSY2H-21"> *                LED    6 |d6  5 4      e7| 19               </front>
<front id="pins_TEENSY2H-22"> *                       7 |d7           e6| 18               </front>
<front id="pins_TEENSY2H-23"> *       LCD  RS         8 |e0             | GND              </front>
<front id="pins_TEENSY2H-24"> *       LCD  EN         9 |e1   a4 a0    R| AREF             </front>
<front id="pins_TEENSY2H-25"> *       LCD  D4        10 |c0   a5 a1   f0| 38 A0            ENC_1           </front>
<front id="pins_TEENSY2H-26"> *       LCD  D5        11 |c1   a6 a2   f1| 39 A1            ENC_2</front>
<front id="pins_TEENSY2H-27"> *       LCD  D6        12 |c2   a7 a3   f2| 40 A2            ENC_CLK</front>
<front id="pins_TEENSY2H-28"> *       LCD  D6        13 |c3           f3| 41 A3            </front>
<front id="pins_TEENSY2H-29"> *      Bed Heat    PWM 14 |c4   V G R   f4| 42 A4            </front>
<front id="pins_TEENSY2H-30"> * Extruder Heat    PWM 15 |c5   c n S   f5| 43 A5            </front>
<front id="pins_TEENSY2H-31"> *           Fan    PWM 16 |c6   c d T   f6| 44 A6            Bed TC</front>
<front id="pins_TEENSY2H-32"> *                      17 |c7   * * *   f7| 45 A7            Extruder TC * 4.7k * +5        </front>
<front id="pins_TEENSY2H-33"> *                         -----------------                  </front>
<front id="pins_TEENSY2H-34"> *</front>
<front id="pins_TEENSY2H-35"> *      Interior E4: 36, INT4</front>
<front id="pins_TEENSY2H-36"> *      Interior E5: 37, INT5</front>
<front id="pins_TEENSY2H-37"> *      Interior PA0-7: 28-35  -- Printrboard and Teensylu use these pins for step & direction:</front>
<front id="pins_TEENSY2H-38"> *             T++ PA Signal  Marlin</front>
<front id="pins_TEENSY2H-39"> *    </front>
<front id="pins_TEENSY2H-40"> *       Z STEP  32 a4  a0 28 X STEP</front>
<front id="pins_TEENSY2H-41"> *       Z DIR   33 a5  a1 29 X DIR</front>
<front id="pins_TEENSY2H-42"> *       E STEP  34 a6  a2 30 Y STEP</front>
<front id="pins_TEENSY2H-43"> *       E DIR   35 a7  a3 31 Y DIR</front>
<front id="pins_TEENSY2H-44"> */</front>
<front id="pins_TEENSY2H-45"></front>
<front id="pins_TEENSY2H-46">#ifndef __AVR_AT90USB1286__</front>
<front id="pins_TEENSY2H-47">  #error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_TEENSY2H-48">#endif</front>
<front id="pins_TEENSY2H-49"></front>
<front id="pins_TEENSY2H-50">#ifndef AT90USBxx_TEENSYPP_ASSIGNMENTS  // use Teensyduino Teensy++2.0 pin assignments instead of Marlin alphabetical.</front>
<front id="pins_TEENSY2H-51">  #error  Uncomment #define AT90USBxx_TEENSYPP_ASSIGNMENTS in fastio.h for this config</front>
<front id="pins_TEENSY2H-52">  // (or build from command line)</front>
<front id="pins_TEENSY2H-53">#endif</front>
<front id="pins_TEENSY2H-54"></front>
<front id="pins_TEENSY2H-55">#define LARGE_FLASH        true</front>
<front id="pins_TEENSY2H-56"></front>
<front id="pins_TEENSY2H-57">#define X_STEP_PIN         28 //  0 Marlin</front>
<front id="pins_TEENSY2H-58">#define X_DIR_PIN          29 //  1 Marlin</front>
<front id="pins_TEENSY2H-59">#define X_ENABLE_PIN       26 </front>
<front id="pins_TEENSY2H-60"></front>
<front id="pins_TEENSY2H-61">#define Y_STEP_PIN         30 //  2 Marlin</front>
<front id="pins_TEENSY2H-62">#define Y_DIR_PIN          31 //  3</front>
<front id="pins_TEENSY2H-63">#define Y_ENABLE_PIN       26     // Shared w/x</front>
<front id="pins_TEENSY2H-64"></front>
<front id="pins_TEENSY2H-65">#define Z_STEP_PIN         32 //  4</front>
<front id="pins_TEENSY2H-66">#define Z_DIR_PIN          33 //  5</front>
<front id="pins_TEENSY2H-67">#define Z_ENABLE_PIN       26 // Shared w/x</front>
<front id="pins_TEENSY2H-68"></front>
<front id="pins_TEENSY2H-69">#define E0_STEP_PIN        34 //  6</front>
<front id="pins_TEENSY2H-70">#define E0_DIR_PIN         35 //  7</front>
<front id="pins_TEENSY2H-71">#define E0_ENABLE_PIN      26 // Shared w/x</front>
<front id="pins_TEENSY2H-72"></front>
<front id="pins_TEENSY2H-73">#define HEATER_0_PIN       15 //  21  // Extruder</front>
<front id="pins_TEENSY2H-74">#define HEATER_1_PIN       -1</front>
<front id="pins_TEENSY2H-75">#define HEATER_2_PIN       -1</front>
<front id="pins_TEENSY2H-76">#define HEATER_BED_PIN     14 // 20  // Bed</front>
<front id="pins_TEENSY2H-77">#define FAN_PIN            16 // 22  // Fan</front>
<front id="pins_TEENSY2H-78"></front>
<front id="pins_TEENSY2H-79">#define X_STOP_PIN          2</front>
<front id="pins_TEENSY2H-80">#define Y_STOP_PIN          3</front>
<front id="pins_TEENSY2H-81">#define Z_STOP_PIN          4</front>
<front id="pins_TEENSY2H-82"></front>
<front id="pins_TEENSY2H-83">#define TEMP_0_PIN          7 // Extruder / Analog pin numbering</front>
<front id="pins_TEENSY2H-84">#define TEMP_BED_PIN        6 // Bed / Analog pin numbering</front>
<front id="pins_TEENSY2H-85">#define TEMP_1_PIN         -1</front>
<front id="pins_TEENSY2H-86">#define TEMP_2_PIN         -1</front>
<front id="pins_TEENSY2H-87"></front>
<front id="pins_TEENSY2H-88">#define SDPOWER            -1</front>
<front id="pins_TEENSY2H-89">#define SD_DETECT_PIN      -1   </front>
<front id="pins_TEENSY2H-90">#define SDSS               20 // 8</front>
<front id="pins_TEENSY2H-91">#define LED_PIN             6</front>
<front id="pins_TEENSY2H-92">#define PS_ON_PIN          27</front>
<front id="pins_TEENSY2H-93">#define KILL_PIN           -1</front>
<front id="pins_TEENSY2H-94">#define ALARM_PIN          -1</front>
<front id="pins_TEENSY2H-95"></front>
<front id="pins_TEENSY2H-96">#if DISABLED(SDSUPPORT)</front>
<front id="pins_TEENSY2H-97">// these pins are defined in the SD library if building with SD support</front>
<front id="pins_TEENSY2H-98">  #define SCK_PIN         21 // 9</front>
<front id="pins_TEENSY2H-99">  #define MISO_PIN        23 // 11</front>
<front id="pins_TEENSY2H-100">  #define MOSI_PIN        22 // 10</front>
<front id="pins_TEENSY2H-101">#endif</front>
<front id="pins_TEENSY2H-102"></front>
<front id="pins_TEENSY2H-103">#if ENABLED(ULTIPANEL)</front>
<front id="pins_TEENSY2H-104">  #define LCD_PINS_RS         8</front>
<front id="pins_TEENSY2H-105">  #define LCD_PINS_ENABLE     9</front>
<front id="pins_TEENSY2H-106">  #define LCD_PINS_D4        10</front>
<front id="pins_TEENSY2H-107">  #define LCD_PINS_D5        11</front>
<front id="pins_TEENSY2H-108">  #define LCD_PINS_D6        12</front>
<front id="pins_TEENSY2H-109">  #define LCD_PINS_D7        13</front>
<front id="pins_TEENSY2H-110">  #define BTN_EN1            38</front>
<front id="pins_TEENSY2H-111">  #define BTN_EN2            39</front>
<front id="pins_TEENSY2H-112">  #define BTN_ENC            40</front>
<front id="pins_TEENSY2H-113">#endif</front>
 </pre>
<h1 id="pins_TEENSYLUHtitle" >pins_TEENSYLU.h</h1>
<pre id="pins_TEENSYLUH"  class="prettyprint linenums"><front id="pins_TEENSYLUH-1">/**</front>
<front id="pins_TEENSYLUH-2"> * Teensylu 0.7 pin assignments (AT90USB1286)</front>
<front id="pins_TEENSYLUH-3"> * Requires the Teensyduino software with Teensy++ 2.0 selected in Arduino IDE!</front>
<front id="pins_TEENSYLUH-4"> * http://www.pjrc.com/teensy/teensyduino.html</front>
<front id="pins_TEENSYLUH-5"> * See http://reprap.org/wiki/Printrboard for more info</front>
<front id="pins_TEENSYLUH-6"> */</front>
<front id="pins_TEENSYLUH-7"></front>
<front id="pins_TEENSYLUH-8">#ifndef __AVR_AT90USB1286__</front>
<front id="pins_TEENSYLUH-9">  #error Oops!  Make sure you have 'Teensy++ 2.0' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_TEENSYLUH-10">#endif</front>
<front id="pins_TEENSYLUH-11"></front>
<front id="pins_TEENSYLUH-12">#if ENABLED(AT90USBxx_TEENSYPP_ASSIGNMENTS)  // use Teensyduino Teensy++2.0 pin assignments instead of Marlin traditional.</front>
<front id="pins_TEENSYLUH-13">  #error These Teensylu assignments depend on traditional Marlin assignments, not AT90USBxx_TEENSYPP_ASSIGNMENTS in fastio.h</front>
<front id="pins_TEENSYLUH-14">#endif</front>
<front id="pins_TEENSYLUH-15"></front>
<front id="pins_TEENSYLUH-16">#define LARGE_FLASH        true</front>
<front id="pins_TEENSYLUH-17"></front>
<front id="pins_TEENSYLUH-18">#define X_STEP_PIN          0</front>
<front id="pins_TEENSYLUH-19">#define X_DIR_PIN           1</front>
<front id="pins_TEENSYLUH-20">#define X_ENABLE_PIN       39</front>
<front id="pins_TEENSYLUH-21"></front>
<front id="pins_TEENSYLUH-22">#define Y_STEP_PIN          2</front>
<front id="pins_TEENSYLUH-23">#define Y_DIR_PIN           3</front>
<front id="pins_TEENSYLUH-24">#define Y_ENABLE_PIN       38</front>
<front id="pins_TEENSYLUH-25"></front>
<front id="pins_TEENSYLUH-26">#define Z_STEP_PIN          4</front>
<front id="pins_TEENSYLUH-27">#define Z_DIR_PIN           5</front>
<front id="pins_TEENSYLUH-28">#define Z_ENABLE_PIN       23</front>
<front id="pins_TEENSYLUH-29"></front>
<front id="pins_TEENSYLUH-30">#define E0_STEP_PIN         6</front>
<front id="pins_TEENSYLUH-31">#define E0_DIR_PIN          7</front>
<front id="pins_TEENSYLUH-32">#define E0_ENABLE_PIN      19</front>
<front id="pins_TEENSYLUH-33"></front>
<front id="pins_TEENSYLUH-34">#define HEATER_0_PIN       21  // Extruder</front>
<front id="pins_TEENSYLUH-35">#define HEATER_1_PIN       46</front>
<front id="pins_TEENSYLUH-36">#define HEATER_2_PIN       47</front>
<front id="pins_TEENSYLUH-37">#define HEATER_BED_PIN     20</front>
<front id="pins_TEENSYLUH-38"></front>
<front id="pins_TEENSYLUH-39">// If soft or fast PWM is off then use Teensyduino pin numbering, Marlin</front>
<front id="pins_TEENSYLUH-40">// fastio pin numbering otherwise</front>
<front id="pins_TEENSYLUH-41">#if ENABLED(FAN_SOFT_PWM) || ENABLED(FAST_PWM_FAN)</front>
<front id="pins_TEENSYLUH-42">  #define FAN_PIN          22</front>
<front id="pins_TEENSYLUH-43">#else</front>
<front id="pins_TEENSYLUH-44">  #define FAN_PIN          16</front>
<front id="pins_TEENSYLUH-45">#endif</front>
<front id="pins_TEENSYLUH-46"></front>
<front id="pins_TEENSYLUH-47">#define X_STOP_PIN         13</front>
<front id="pins_TEENSYLUH-48">#define Y_STOP_PIN         14</front>
<front id="pins_TEENSYLUH-49">#define Z_STOP_PIN         15</front>
<front id="pins_TEENSYLUH-50">#define TEMP_0_PIN          7  // Extruder / Analog pin numbering</front>
<front id="pins_TEENSYLUH-51">#define TEMP_BED_PIN        6  // Bed / Analog pin numbering</front>
<front id="pins_TEENSYLUH-52"></front>
<front id="pins_TEENSYLUH-53">#define TEMP_1_PIN         -1</front>
<front id="pins_TEENSYLUH-54">#define TEMP_2_PIN         -1</front>
<front id="pins_TEENSYLUH-55"></front>
<front id="pins_TEENSYLUH-56">#define SDPOWER            -1</front>
<front id="pins_TEENSYLUH-57">#define SDSS                8</front>
<front id="pins_TEENSYLUH-58">#define LED_PIN            -1</front>
<front id="pins_TEENSYLUH-59">#define PS_ON_PIN          -1</front>
<front id="pins_TEENSYLUH-60">#define KILL_PIN           -1</front>
<front id="pins_TEENSYLUH-61">#define ALARM_PIN          -1</front>
<front id="pins_TEENSYLUH-62"></front>
<front id="pins_TEENSYLUH-63">#if DISABLED(SDSUPPORT)</front>
<front id="pins_TEENSYLUH-64">// these pins are defined in the SD library if building with SD support</front>
<front id="pins_TEENSYLUH-65">  #define SCK_PIN           9</front>
<front id="pins_TEENSYLUH-66">  #define MISO_PIN         11</front>
<front id="pins_TEENSYLUH-67">  #define MOSI_PIN         10</front>
<front id="pins_TEENSYLUH-68">#endif</front>
<front id="pins_TEENSYLUH-69"></front>
<front id="pins_TEENSYLUH-70">#if ENABLED(ULTRA_LCD) && ENABLED(NEWPANEL)</front>
<front id="pins_TEENSYLUH-71"></front>
<front id="pins_TEENSYLUH-72">  #define BEEPER_PIN       -1</front>
<front id="pins_TEENSYLUH-73"></front>
<front id="pins_TEENSYLUH-74">  #if ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="pins_TEENSYLUH-75">    #define BTN_EN1        27  //RX1 - fastio.h pin mapping 27</front>
<front id="pins_TEENSYLUH-76">    #define BTN_EN2        26  //TX1 - fastio.h pin mapping 26</front>
<front id="pins_TEENSYLUH-77">    #define BTN_ENC        43  //A3  - fastio.h pin mapping 43</front>
<front id="pins_TEENSYLUH-78">    #define SDSS           40  //use SD card on Panelolu2 (Teensyduino pin mapping)</front>
<front id="pins_TEENSYLUH-79">  #endif // LCD_I2C_PANELOLU2</front>
<front id="pins_TEENSYLUH-80"></front>
<front id="pins_TEENSYLUH-81">  #define SD_DETECT_PIN    -1    </front>
<front id="pins_TEENSYLUH-82"></front>
<front id="pins_TEENSYLUH-83">#endif // ULTRA_LCD && NEWPANEL</front>
<front id="pins_TEENSYLUH-84"></front>
 </pre>
<h1 id="pins_ULTIMAIN_2Htitle" >pins_ULTIMAIN_2.h</h1>
<pre id="pins_ULTIMAIN_2H"  class="prettyprint linenums"><front id="pins_ULTIMAIN_2H-1">/**</front>
<front id="pins_ULTIMAIN_2H-2"> * Ultiboard v2.0 pin assignments</front>
<front id="pins_ULTIMAIN_2H-3"> */</front>
<front id="pins_ULTIMAIN_2H-4"></front>
<front id="pins_ULTIMAIN_2H-5">#ifndef __AVR_ATmega2560__</front>
<front id="pins_ULTIMAIN_2H-6">  #error Oops!  Make sure you have 'Arduino Mega 2560' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_ULTIMAIN_2H-7">#endif</front>
<front id="pins_ULTIMAIN_2H-8"></front>
<front id="pins_ULTIMAIN_2H-9">#define X_STEP_PIN 25</front>
<front id="pins_ULTIMAIN_2H-10">#define X_DIR_PIN 23</front>
<front id="pins_ULTIMAIN_2H-11">#define X_STOP_PIN 22</front>
<front id="pins_ULTIMAIN_2H-12">#define X_ENABLE_PIN 27</front>
<front id="pins_ULTIMAIN_2H-13"></front>
<front id="pins_ULTIMAIN_2H-14">#define Y_STEP_PIN 32</front>
<front id="pins_ULTIMAIN_2H-15">#define Y_DIR_PIN 33</front>
<front id="pins_ULTIMAIN_2H-16">#define Y_STOP_PIN 26</front>
<front id="pins_ULTIMAIN_2H-17">#define Y_ENABLE_PIN 31</front>
<front id="pins_ULTIMAIN_2H-18"></front>
<front id="pins_ULTIMAIN_2H-19">#define Z_STEP_PIN 35</front>
<front id="pins_ULTIMAIN_2H-20">#define Z_DIR_PIN 36</front>
<front id="pins_ULTIMAIN_2H-21">#define Z_STOP_PIN 29</front>
<front id="pins_ULTIMAIN_2H-22">#define Z_ENABLE_PIN 34</front>
<front id="pins_ULTIMAIN_2H-23"></front>
<front id="pins_ULTIMAIN_2H-24">#define HEATER_BED_PIN 4</front>
<front id="pins_ULTIMAIN_2H-25">#define TEMP_BED_PIN 10</front>
<front id="pins_ULTIMAIN_2H-26"></front>
<front id="pins_ULTIMAIN_2H-27">#define HEATER_0_PIN  2</front>
<front id="pins_ULTIMAIN_2H-28">#define TEMP_0_PIN 8</front>
<front id="pins_ULTIMAIN_2H-29"></front>
<front id="pins_ULTIMAIN_2H-30">#define HEATER_1_PIN 3</front>
<front id="pins_ULTIMAIN_2H-31">#define TEMP_1_PIN 9</front>
<front id="pins_ULTIMAIN_2H-32"></front>
<front id="pins_ULTIMAIN_2H-33">#define HEATER_2_PIN -1</front>
<front id="pins_ULTIMAIN_2H-34">#define TEMP_2_PIN -1</front>
<front id="pins_ULTIMAIN_2H-35"></front>
<front id="pins_ULTIMAIN_2H-36">#define E0_STEP_PIN         42</front>
<front id="pins_ULTIMAIN_2H-37">#define E0_DIR_PIN          43</front>
<front id="pins_ULTIMAIN_2H-38">#define E0_ENABLE_PIN       37</front>
<front id="pins_ULTIMAIN_2H-39"></front>
<front id="pins_ULTIMAIN_2H-40">#define E1_STEP_PIN         49</front>
<front id="pins_ULTIMAIN_2H-41">#define E1_DIR_PIN          47</front>
<front id="pins_ULTIMAIN_2H-42">#define E1_ENABLE_PIN       48</front>
<front id="pins_ULTIMAIN_2H-43"></front>
<front id="pins_ULTIMAIN_2H-44">#define SDPOWER            -1</front>
<front id="pins_ULTIMAIN_2H-45">#define SDSS               53</front>
<front id="pins_ULTIMAIN_2H-46">#define LED_PIN            8</front>
<front id="pins_ULTIMAIN_2H-47">#define FAN_PIN            7</front>
<front id="pins_ULTIMAIN_2H-48">#define PS_ON_PIN          -1</front>
<front id="pins_ULTIMAIN_2H-49">#define KILL_PIN           -1</front>
<front id="pins_ULTIMAIN_2H-50">#define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pins_ULTIMAIN_2H-51">#define SAFETY_TRIGGERED_PIN     28 //PIN to detect the safety circuit has triggered</front>
<front id="pins_ULTIMAIN_2H-52">#define MAIN_VOLTAGE_MEASURE_PIN 14 //Analogue PIN to measure the main voltage, with a 100k - 4k7 resitor divider.</front>
<front id="pins_ULTIMAIN_2H-53"></front>
<front id="pins_ULTIMAIN_2H-54">#define MOTOR_CURRENT_PWM_XY_PIN 44</front>
<front id="pins_ULTIMAIN_2H-55">#define MOTOR_CURRENT_PWM_Z_PIN 45</front>
<front id="pins_ULTIMAIN_2H-56">#define MOTOR_CURRENT_PWM_E_PIN 46</front>
<front id="pins_ULTIMAIN_2H-57">//Motor current PWM conversion, PWM value = MotorCurrentSetting * 255 / range</front>
<front id="pins_ULTIMAIN_2H-58">#define MOTOR_CURRENT_PWM_RANGE 2000</front>
<front id="pins_ULTIMAIN_2H-59">#define DEFAULT_PWM_MOTOR_CURRENT  {1300, 1300, 1250}</front>
<front id="pins_ULTIMAIN_2H-60"></front>
<front id="pins_ULTIMAIN_2H-61">#define BEEPER_PIN 18</front>
<front id="pins_ULTIMAIN_2H-62"></front>
<front id="pins_ULTIMAIN_2H-63">#define LCD_PINS_RS 20</front>
<front id="pins_ULTIMAIN_2H-64">#define LCD_PINS_ENABLE 15</front>
<front id="pins_ULTIMAIN_2H-65">#define LCD_PINS_D4 14</front>
<front id="pins_ULTIMAIN_2H-66">#define LCD_PINS_D5 21</front>
<front id="pins_ULTIMAIN_2H-67">#define LCD_PINS_D6 5</front>
<front id="pins_ULTIMAIN_2H-68">#define LCD_PINS_D7 6</front>
<front id="pins_ULTIMAIN_2H-69"></front>
<front id="pins_ULTIMAIN_2H-70">//buttons are directly attached</front>
<front id="pins_ULTIMAIN_2H-71">#define BTN_EN1 40</front>
<front id="pins_ULTIMAIN_2H-72">#define BTN_EN2 41</front>
<front id="pins_ULTIMAIN_2H-73">#define BTN_ENC 19  //the click</front>
<front id="pins_ULTIMAIN_2H-74"></front>
<front id="pins_ULTIMAIN_2H-75">#define BLEN_C 2</front>
<front id="pins_ULTIMAIN_2H-76">#define BLEN_B 1</front>
<front id="pins_ULTIMAIN_2H-77">#define BLEN_A 0</front>
<front id="pins_ULTIMAIN_2H-78"></front>
<front id="pins_ULTIMAIN_2H-79">#define SD_DETECT_PIN 39</front>
 </pre>
<h1 id="pins_ULTIMAKERHtitle" >pins_ULTIMAKER.h</h1>
<pre id="pins_ULTIMAKERH"  class="prettyprint linenums"><front id="pins_ULTIMAKERH-1">/**</front>
<front id="pins_ULTIMAKERH-2"> * Ultimaker pin assignments</front>
<front id="pins_ULTIMAKERH-3"> */</front>
<front id="pins_ULTIMAKERH-4"></front>
<front id="pins_ULTIMAKERH-5">#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)</front>
<front id="pins_ULTIMAKERH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_ULTIMAKERH-7">#endif</front>
<front id="pins_ULTIMAKERH-8"></front>
<front id="pins_ULTIMAKERH-9">#define LARGE_FLASH true</front>
<front id="pins_ULTIMAKERH-10"></front>
<front id="pins_ULTIMAKERH-11">#define SERVO0_PIN 13 // untested</front>
<front id="pins_ULTIMAKERH-12"></front>
<front id="pins_ULTIMAKERH-13">#define X_STEP_PIN 25</front>
<front id="pins_ULTIMAKERH-14">#define X_DIR_PIN 23</front>
<front id="pins_ULTIMAKERH-15">#define X_MIN_PIN 22</front>
<front id="pins_ULTIMAKERH-16">#define X_MAX_PIN 24</front>
<front id="pins_ULTIMAKERH-17">#define X_ENABLE_PIN 27</front>
<front id="pins_ULTIMAKERH-18"></front>
<front id="pins_ULTIMAKERH-19">#define Y_STEP_PIN 31</front>
<front id="pins_ULTIMAKERH-20">#define Y_DIR_PIN 33</front>
<front id="pins_ULTIMAKERH-21">#define Y_MIN_PIN 26</front>
<front id="pins_ULTIMAKERH-22">#define Y_MAX_PIN 28</front>
<front id="pins_ULTIMAKERH-23">#define Y_ENABLE_PIN 29</front>
<front id="pins_ULTIMAKERH-24"></front>
<front id="pins_ULTIMAKERH-25">#define Z_STEP_PIN 37</front>
<front id="pins_ULTIMAKERH-26">#define Z_DIR_PIN 39</front>
<front id="pins_ULTIMAKERH-27">#define Z_MIN_PIN 30</front>
<front id="pins_ULTIMAKERH-28">#define Z_MAX_PIN 32</front>
<front id="pins_ULTIMAKERH-29">#define Z_ENABLE_PIN 35</front>
<front id="pins_ULTIMAKERH-30"></front>
<front id="pins_ULTIMAKERH-31">#define HEATER_BED_PIN 4</front>
<front id="pins_ULTIMAKERH-32">#define TEMP_BED_PIN 10</front>
<front id="pins_ULTIMAKERH-33"></front>
<front id="pins_ULTIMAKERH-34">#define HEATER_0_PIN  2</front>
<front id="pins_ULTIMAKERH-35">#define TEMP_0_PIN 8</front>
<front id="pins_ULTIMAKERH-36"></front>
<front id="pins_ULTIMAKERH-37">#define HEATER_1_PIN 3</front>
<front id="pins_ULTIMAKERH-38">#define TEMP_1_PIN 9</front>
<front id="pins_ULTIMAKERH-39"></front>
<front id="pins_ULTIMAKERH-40">#define HEATER_2_PIN -1</front>
<front id="pins_ULTIMAKERH-41">#define TEMP_2_PIN -1</front>
<front id="pins_ULTIMAKERH-42"></front>
<front id="pins_ULTIMAKERH-43">#define E0_STEP_PIN         43</front>
<front id="pins_ULTIMAKERH-44">#define E0_DIR_PIN          45</front>
<front id="pins_ULTIMAKERH-45">#define E0_ENABLE_PIN       41</front>
<front id="pins_ULTIMAKERH-46"></front>
<front id="pins_ULTIMAKERH-47">#define E1_STEP_PIN         49</front>
<front id="pins_ULTIMAKERH-48">#define E1_DIR_PIN          47</front>
<front id="pins_ULTIMAKERH-49">#define E1_ENABLE_PIN       48</front>
<front id="pins_ULTIMAKERH-50"></front>
<front id="pins_ULTIMAKERH-51">#define SDPOWER            -1</front>
<front id="pins_ULTIMAKERH-52">#define SDSS               53</front>
<front id="pins_ULTIMAKERH-53">#define LED_PIN            13</front>
<front id="pins_ULTIMAKERH-54">#define FAN_PIN            7</front>
<front id="pins_ULTIMAKERH-55">#define PS_ON_PIN          12</front>
<front id="pins_ULTIMAKERH-56">#define KILL_PIN           -1</front>
<front id="pins_ULTIMAKERH-57">#define SUICIDE_PIN        54  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pins_ULTIMAKERH-58"></front>
<front id="pins_ULTIMAKERH-59">#if ENABLED(ULTRA_LCD)</front>
<front id="pins_ULTIMAKERH-60"></front>
<front id="pins_ULTIMAKERH-61">  #define BEEPER_PIN 18</front>
<front id="pins_ULTIMAKERH-62"></front>
<front id="pins_ULTIMAKERH-63">  #if ENABLED(NEWPANEL)</front>
<front id="pins_ULTIMAKERH-64"></front>
<front id="pins_ULTIMAKERH-65">    #define LCD_PINS_RS 20</front>
<front id="pins_ULTIMAKERH-66">    #define LCD_PINS_ENABLE 17</front>
<front id="pins_ULTIMAKERH-67">    #define LCD_PINS_D4 16</front>
<front id="pins_ULTIMAKERH-68">    #define LCD_PINS_D5 21</front>
<front id="pins_ULTIMAKERH-69">    #define LCD_PINS_D6 5</front>
<front id="pins_ULTIMAKERH-70">    #define LCD_PINS_D7 6</front>
<front id="pins_ULTIMAKERH-71"></front>
<front id="pins_ULTIMAKERH-72">    //buttons are directly attached</front>
<front id="pins_ULTIMAKERH-73">    #define BTN_EN1 40</front>
<front id="pins_ULTIMAKERH-74">    #define BTN_EN2 42</front>
<front id="pins_ULTIMAKERH-75">    #define BTN_ENC 19</front>
<front id="pins_ULTIMAKERH-76"></front>
<front id="pins_ULTIMAKERH-77">    #define SD_DETECT_PIN 38</front>
<front id="pins_ULTIMAKERH-78"></front>
<front id="pins_ULTIMAKERH-79">  #else //!NEWPANEL - Old style panel with shift register</front>
<front id="pins_ULTIMAKERH-80"></front>
<front id="pins_ULTIMAKERH-81">    //buttons are attached to a shift register</front>
<front id="pins_ULTIMAKERH-82">    #define SHIFT_CLK 38</front>
<front id="pins_ULTIMAKERH-83">    #define SHIFT_LD 42</front>
<front id="pins_ULTIMAKERH-84">    #define SHIFT_OUT 40</front>
<front id="pins_ULTIMAKERH-85">    #define SHIFT_EN 17</front>
<front id="pins_ULTIMAKERH-86"></front>
<front id="pins_ULTIMAKERH-87">    #define LCD_PINS_RS 16</front>
<front id="pins_ULTIMAKERH-88">    #define LCD_PINS_ENABLE 5</front>
<front id="pins_ULTIMAKERH-89">    #define LCD_PINS_D4 6</front>
<front id="pins_ULTIMAKERH-90">    #define LCD_PINS_D5 21</front>
<front id="pins_ULTIMAKERH-91">    #define LCD_PINS_D6 20</front>
<front id="pins_ULTIMAKERH-92">    #define LCD_PINS_D7 19</front>
<front id="pins_ULTIMAKERH-93"></front>
<front id="pins_ULTIMAKERH-94">    #define SD_DETECT_PIN -1</front>
<front id="pins_ULTIMAKERH-95"></front>
<front id="pins_ULTIMAKERH-96">  #endif // !NEWPANEL</front>
<front id="pins_ULTIMAKERH-97"></front>
<front id="pins_ULTIMAKERH-98">#endif // ULTRA_LCD</front>
 </pre>
<h1 id="pins_ULTIMAKER_OLDHtitle" >pins_ULTIMAKER_OLD.h</h1>
<pre id="pins_ULTIMAKER_OLDH"  class="prettyprint linenums"><front id="pins_ULTIMAKER_OLDH-1">/**</front>
<front id="pins_ULTIMAKER_OLDH-2"> * Ultimaker pin assignments (Old electronics)</front>
<front id="pins_ULTIMAKER_OLDH-3"> */</front>
<front id="pins_ULTIMAKER_OLDH-4"></front>
<front id="pins_ULTIMAKER_OLDH-5">#if !defined(__AVR_ATmega1280__) && !defined(__AVR_ATmega2560__)</front>
<front id="pins_ULTIMAKER_OLDH-6">  #error Oops!  Make sure you have 'Arduino Mega' selected from the 'Tools -&gt; Boards' menu.</front>
<front id="pins_ULTIMAKER_OLDH-7">#endif</front>
<front id="pins_ULTIMAKER_OLDH-8"></front>
<front id="pins_ULTIMAKER_OLDH-9">#define LARGE_FLASH true</front>
<front id="pins_ULTIMAKER_OLDH-10"></front>
<front id="pins_ULTIMAKER_OLDH-11">#define X_STEP_PIN 25</front>
<front id="pins_ULTIMAKER_OLDH-12">#define X_DIR_PIN 23</front>
<front id="pins_ULTIMAKER_OLDH-13">#define X_MIN_PIN 15</front>
<front id="pins_ULTIMAKER_OLDH-14">#define X_MAX_PIN 14</front>
<front id="pins_ULTIMAKER_OLDH-15">#define X_ENABLE_PIN 27</front>
<front id="pins_ULTIMAKER_OLDH-16"></front>
<front id="pins_ULTIMAKER_OLDH-17">#define Y_STEP_PIN 31</front>
<front id="pins_ULTIMAKER_OLDH-18">#define Y_DIR_PIN 33</front>
<front id="pins_ULTIMAKER_OLDH-19">#define Y_MIN_PIN 17</front>
<front id="pins_ULTIMAKER_OLDH-20">#define Y_MAX_PIN 16</front>
<front id="pins_ULTIMAKER_OLDH-21">#define Y_ENABLE_PIN 29</front>
<front id="pins_ULTIMAKER_OLDH-22"></front>
<front id="pins_ULTIMAKER_OLDH-23">#define Z_STEP_PIN 37</front>
<front id="pins_ULTIMAKER_OLDH-24">#define Z_DIR_PIN 39</front>
<front id="pins_ULTIMAKER_OLDH-25">#define Z_MIN_PIN 19</front>
<front id="pins_ULTIMAKER_OLDH-26">#define Z_MAX_PIN 18</front>
<front id="pins_ULTIMAKER_OLDH-27">#define Z_ENABLE_PIN 35</front>
<front id="pins_ULTIMAKER_OLDH-28"></front>
<front id="pins_ULTIMAKER_OLDH-29">#define HEATER_BED_PIN -1</front>
<front id="pins_ULTIMAKER_OLDH-30">#define TEMP_BED_PIN -1</front>
<front id="pins_ULTIMAKER_OLDH-31"></front>
<front id="pins_ULTIMAKER_OLDH-32">#define HEATER_0_PIN  2</front>
<front id="pins_ULTIMAKER_OLDH-33">#define TEMP_0_PIN 8</front>
<front id="pins_ULTIMAKER_OLDH-34"></front>
<front id="pins_ULTIMAKER_OLDH-35">#define HEATER_1_PIN 1</front>
<front id="pins_ULTIMAKER_OLDH-36">#define TEMP_1_PIN 1</front>
<front id="pins_ULTIMAKER_OLDH-37"></front>
<front id="pins_ULTIMAKER_OLDH-38">#define HEATER_2_PIN -1</front>
<front id="pins_ULTIMAKER_OLDH-39">#define TEMP_2_PIN -1</front>
<front id="pins_ULTIMAKER_OLDH-40"></front>
<front id="pins_ULTIMAKER_OLDH-41">#define E0_STEP_PIN         43</front>
<front id="pins_ULTIMAKER_OLDH-42">#define E0_DIR_PIN          45</front>
<front id="pins_ULTIMAKER_OLDH-43">#define E0_ENABLE_PIN       41</front>
<front id="pins_ULTIMAKER_OLDH-44"></front>
<front id="pins_ULTIMAKER_OLDH-45">#define E1_STEP_PIN         -1</front>
<front id="pins_ULTIMAKER_OLDH-46">#define E1_DIR_PIN          -1</front>
<front id="pins_ULTIMAKER_OLDH-47">#define E1_ENABLE_PIN       -1</front>
<front id="pins_ULTIMAKER_OLDH-48"></front>
<front id="pins_ULTIMAKER_OLDH-49">#define SDPOWER            -1</front>
<front id="pins_ULTIMAKER_OLDH-50">#define SDSS               -1</front>
<front id="pins_ULTIMAKER_OLDH-51">#define LED_PIN            -1</front>
<front id="pins_ULTIMAKER_OLDH-52">#define FAN_PIN            -1</front>
<front id="pins_ULTIMAKER_OLDH-53">#define PS_ON_PIN          -1</front>
<front id="pins_ULTIMAKER_OLDH-54">#define KILL_PIN           -1</front>
<front id="pins_ULTIMAKER_OLDH-55">#define SUICIDE_PIN        -1  //PIN that has to be turned on right after start, to keep power flowing.</front>
<front id="pins_ULTIMAKER_OLDH-56"></front>
<front id="pins_ULTIMAKER_OLDH-57">#define LCD_PINS_RS 24</front>
<front id="pins_ULTIMAKER_OLDH-58">#define LCD_PINS_ENABLE 22</front>
<front id="pins_ULTIMAKER_OLDH-59">#define LCD_PINS_D4 36</front>
<front id="pins_ULTIMAKER_OLDH-60">#define LCD_PINS_D5 34</front>
<front id="pins_ULTIMAKER_OLDH-61">#define LCD_PINS_D6 32</front>
<front id="pins_ULTIMAKER_OLDH-62">#define LCD_PINS_D7 30</front>
 </pre>
<h1 id="plannerCPPtitle" >planner.cpp</h1>
<pre id="plannerCPP"  class="prettyprint linenums"><front id="plannerCPP-1">/**</front>
<front id="plannerCPP-2"> * planner.cpp - Buffer movement commands and manage the acceleration profile plan</front>
<front id="plannerCPP-3"> * Part of Grbl</front>
<front id="plannerCPP-4"> *</front>
<front id="plannerCPP-5"> * Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="plannerCPP-6"> *</front>
<front id="plannerCPP-7"> * Grbl is free software: you can redistribute it and/or modify</front>
<front id="plannerCPP-8"> * it under the terms of the GNU General Public License as published by</front>
<front id="plannerCPP-9"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="plannerCPP-10"> * (at your option) any later version.</front>
<front id="plannerCPP-11"> *</front>
<front id="plannerCPP-12"> * Grbl is distributed in the hope that it will be useful,</front>
<front id="plannerCPP-13"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="plannerCPP-14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="plannerCPP-15"> * GNU General Public License for more details.</front>
<front id="plannerCPP-16"> *</front>
<front id="plannerCPP-17"> * You should have received a copy of the GNU General Public License</front>
<front id="plannerCPP-18"> * along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="plannerCPP-19"> *</front>
<front id="plannerCPP-20"> *</front>
<front id="plannerCPP-21"> * The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis.</front>
<front id="plannerCPP-22"> *</front>
<front id="plannerCPP-23"> *</front>
<front id="plannerCPP-24"> * Reasoning behind the mathematics in this module (in the key of 'Mathematica'):</front>
<front id="plannerCPP-25"> *</front>
<front id="plannerCPP-26"> * s == speed, a == acceleration, t == time, d == distance</front>
<front id="plannerCPP-27"> *</front>
<front id="plannerCPP-28"> * Basic definitions:</front>
<front id="plannerCPP-29"> *   Speed[s_, a_, t_] := s + (a*t)</front>
<front id="plannerCPP-30"> *   Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]</front>
<front id="plannerCPP-31"> *</front>
<front id="plannerCPP-32"> * Distance to reach a specific speed with a constant acceleration:</front>
<front id="plannerCPP-33"> *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]</front>
<front id="plannerCPP-34"> *   d -&gt; (m^2 - s^2)/(2 a) --&gt; estimate_acceleration_distance()</front>
<front id="plannerCPP-35"> *</front>
<front id="plannerCPP-36"> * Speed after a given distance of travel with constant acceleration:</front>
<front id="plannerCPP-37"> *   Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]</front>
<front id="plannerCPP-38"> *   m -&gt; Sqrt[2 a d + s^2]</front>
<front id="plannerCPP-39"> *</front>
<front id="plannerCPP-40"> * DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]</front>
<front id="plannerCPP-41"> *</front>
<front id="plannerCPP-42"> * When to start braking (di) to reach a specified destination speed (s2) after accelerating</front>
<front id="plannerCPP-43"> * from initial speed s1 without ever stopping at a plateau:</front>
<front id="plannerCPP-44"> *   Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]</front>
<front id="plannerCPP-45"> *   di -&gt; (2 a d - s1^2 + s2^2)/(4 a) --&gt; intersection_distance()</front>
<front id="plannerCPP-46"> *</front>
<front id="plannerCPP-47"> * IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)</front>
<front id="plannerCPP-48"> *</front>
<front id="plannerCPP-49"> */</front>
<front id="plannerCPP-50"></front>
<front id="plannerCPP-51">#include "Marlin.h"</front>
<front id="plannerCPP-52">#include "planner.h"</front>
<front id="plannerCPP-53">#include "stepper.h"</front>
<front id="plannerCPP-54">#include "temperature.h"</front>
<front id="plannerCPP-55">#include "ultralcd.h"</front>
<front id="plannerCPP-56">#include "language.h"</front>
<front id="plannerCPP-57"></front>
<front id="plannerCPP-58">#if ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-59">  #include "mesh_bed_leveling.h"</front>
<front id="plannerCPP-60">#endif</front>
<front id="plannerCPP-61"></front>
<front id="plannerCPP-62">//===========================================================================</front>
<front id="plannerCPP-63">//============================= public variables ============================</front>
<front id="plannerCPP-64">//===========================================================================</front>
<front id="plannerCPP-65"></front>
<front id="plannerCPP-66">millis_t minsegmenttime;</front>
<front id="plannerCPP-67">float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute</front>
<front id="plannerCPP-68">float axis_steps_per_unit[NUM_AXIS];</front>
<front id="plannerCPP-69">unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software</front>
<front id="plannerCPP-70">float minimumfeedrate;</front>
<front id="plannerCPP-71">float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX</front>
<front id="plannerCPP-72">float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX</front>
<front id="plannerCPP-73">float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX</front>
<front id="plannerCPP-74">float max_xy_jerk;          // The largest speed change requiring no acceleration</front>
<front id="plannerCPP-75">float max_z_jerk;</front>
<front id="plannerCPP-76">float max_e_jerk;</front>
<front id="plannerCPP-77">float mintravelfeedrate;</front>
<front id="plannerCPP-78">unsigned long axis_steps_per_sqr_second[NUM_AXIS];</front>
<front id="plannerCPP-79">#ifdef RESUME_FEATURE</front>
<front id="plannerCPP-80">  float planner_disabled_below_z = 0;</front>
<front id="plannerCPP-81">  float last_z = 0;</front>
<front id="plannerCPP-82">  bool z_reached = false;</front>
<front id="plannerCPP-83">  bool layer_reached = false;</front>
<front id="plannerCPP-84">  bool hops = false;</front>
<front id="plannerCPP-85">  bool gone_up = false;</front>
<front id="plannerCPP-86">#endif //RESUME_FEATURE</front>
<front id="plannerCPP-87">#ifdef TRACK_LAYER</front>
<front id="plannerCPP-88">  unsigned short current_layer = 0;</front>
<front id="plannerCPP-89">  float last_layer_z = 0;</front>
<front id="plannerCPP-90">  #ifndef RESUME_FEATURE</front>
<front id="plannerCPP-91">    bool gone_up = false;</front>
<front id="plannerCPP-92">    float last_z = 0;</front>
<front id="plannerCPP-93">  #endif //RESUME_FEATURE</front>
<front id="plannerCPP-94">#endif //TRACK_LAYER</front>
<front id="plannerCPP-95"></front>
<front id="plannerCPP-96">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerCPP-97">  // Transform required to compensate for bed level</front>
<front id="plannerCPP-98">  matrix_3x3 plan_bed_level_matrix = {</front>
<front id="plannerCPP-99">    1.0, 0.0, 0.0,</front>
<front id="plannerCPP-100">    0.0, 1.0, 0.0,</front>
<front id="plannerCPP-101">    0.0, 0.0, 1.0</front>
<front id="plannerCPP-102">  };</front>
<front id="plannerCPP-103">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="plannerCPP-104"></front>
<front id="plannerCPP-105">#if ENABLED(AUTOTEMP)</front>
<front id="plannerCPP-106">  float autotemp_max = 250;</front>
<front id="plannerCPP-107">  float autotemp_min = 210;</front>
<front id="plannerCPP-108">  float autotemp_factor = 0.1;</front>
<front id="plannerCPP-109">  bool autotemp_enabled = false;</front>
<front id="plannerCPP-110">#endif</front>
<front id="plannerCPP-111"></front>
<front id="plannerCPP-112">//===========================================================================</front>
<front id="plannerCPP-113">//============ semi-private variables, used in inline functions =============</front>
<front id="plannerCPP-114">//===========================================================================</front>
<front id="plannerCPP-115"></front>
<front id="plannerCPP-116">block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instfructions</front>
<front id="plannerCPP-117">volatile unsigned char block_buffer_head;           // Index of the next block to be pushed</front>
<front id="plannerCPP-118">volatile unsigned char block_buffer_tail;           // Index of the block to process now</front>
<front id="plannerCPP-119"></front>
<front id="plannerCPP-120">//===========================================================================</front>
<front id="plannerCPP-121">//============================ private variables ============================</front>
<front id="plannerCPP-122">//===========================================================================</front>
<front id="plannerCPP-123"></front>
<front id="plannerCPP-124">// The current position of the tool in absolute steps</front>
<front id="plannerCPP-125">long position[NUM_AXIS];               // Rescaled from extern when axis_steps_per_unit are changed by gcode</front>
<front id="plannerCPP-126">static float previous_speed[NUM_AXIS]; // Speed of previous path line segment</front>
<front id="plannerCPP-127">static float previous_nominal_speed;   // Nominal speed of previous path line segment</front>
<front id="plannerCPP-128"></front>
<front id="plannerCPP-129">unsigned char g_uc_extruder_last_move[4] = {0,0,0,0};</front>
<front id="plannerCPP-130"></front>
<front id="plannerCPP-131">#ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-132">  // Used for the frequency limit</front>
<front id="plannerCPP-133">  #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)</front>
<front id="plannerCPP-134">  // Old direction bits. Used for speed calculations</front>
<front id="plannerCPP-135">  static unsigned char old_direction_bits = 0;</front>
<front id="plannerCPP-136">  // Segment times (in s). Used for speed calculations</front>
<front id="plannerCPP-137">  static long axis_segment_time[2][3] = { {MAX_FREQ_TIME+1,0,0}, {MAX_FREQ_TIME+1,0,0} };</front>
<front id="plannerCPP-138">#endif</front>
<front id="plannerCPP-139"></front>
<front id="plannerCPP-140">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="plannerCPP-141">  static char meas_sample; //temporary variable to hold filament measurement sample</front>
<front id="plannerCPP-142">#endif</front>
<front id="plannerCPP-143"></front>
<front id="plannerCPP-144">//===========================================================================</front>
<front id="plannerCPP-145">//================================ functions ================================</front>
<front id="plannerCPP-146">//===========================================================================</front>
<front id="plannerCPP-147"></front>
<front id="plannerCPP-148">// Get the next / previous index of the next block in the ring buffer</front>
<front id="plannerCPP-149">// NOTE: Using & here (not %) because BLOCK_BUFFER_SIZE is always a power of 2</front>
<front id="plannerCPP-150">FORCE_INLINE int8_t next_block_index(int8_t block_index) { return BLOCK_MOD(block_index + 1); }</front>
<front id="plannerCPP-151">FORCE_INLINE int8_t prev_block_index(int8_t block_index) { return BLOCK_MOD(block_index - 1); }</front>
<front id="plannerCPP-152"></front>
<front id="plannerCPP-153">// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the</front>
<front id="plannerCPP-154">// given acceleration:</front>
<front id="plannerCPP-155">FORCE_INLINE float estimate_acceleration_distance(float initial_rate, float target_rate, float acceleration) {</front>
<front id="plannerCPP-156">  if (acceleration == 0) return 0; // acceleration was 0, set acceleration distance to 0</front>
<front id="plannerCPP-157">  return (target_rate * target_rate - initial_rate * initial_rate) / (acceleration * 2);</front>
<front id="plannerCPP-158">}</front>
<front id="plannerCPP-159"></front>
<front id="plannerCPP-160">// This function gives you the point at which you must start braking (at the rate of -acceleration) if</front>
<front id="plannerCPP-161">// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after</front>
<front id="plannerCPP-162">// a total travel of distance. This can be used to compute the intersection point between acceleration and</front>
<front id="plannerCPP-163">// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)</front>
<front id="plannerCPP-164"></front>
<front id="plannerCPP-165">FORCE_INLINE float intersection_distance(float initial_rate, float final_rate, float acceleration, float distance) {</front>
<front id="plannerCPP-166">  if (acceleration == 0) return 0; // acceleration was 0, set intersection distance to 0</front>
<front id="plannerCPP-167">  return (acceleration * 2 * distance - initial_rate * initial_rate + final_rate * final_rate) / (acceleration * 4);</front>
<front id="plannerCPP-168">}</front>
<front id="plannerCPP-169"></front>
<front id="plannerCPP-170">// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.</front>
<front id="plannerCPP-171"></front>
<front id="plannerCPP-172">void calculate_trapezoid_for_block(block_t *block, float entry_factor, float exit_factor) {</front>
<front id="plannerCPP-173">  unsigned long initial_rate = ceil(block-&gt;nominal_rate * entry_factor); // (step/min)</front>
<front id="plannerCPP-174">  unsigned long final_rate = ceil(block-&gt;nominal_rate * exit_factor); // (step/min)</front>
<front id="plannerCPP-175"></front>
<front id="plannerCPP-176">  // Limit minimal step rate (Otherwise the timer will overflow.)</front>
<front id="plannerCPP-177">  NOLESS(initial_rate, 120);</front>
<front id="plannerCPP-178">  NOLESS(final_rate, 120);</front>
<front id="plannerCPP-179"></front>
<front id="plannerCPP-180">  long acceleration = block-&gt;acceleration_st;</front>
<front id="plannerCPP-181">  int32_t accelerate_steps = ceil(estimate_acceleration_distance(initial_rate, block-&gt;nominal_rate, acceleration));</front>
<front id="plannerCPP-182">  int32_t decelerate_steps = floor(estimate_acceleration_distance(block-&gt;nominal_rate, final_rate, -acceleration));</front>
<front id="plannerCPP-183"></front>
<front id="plannerCPP-184">  // Calculate the size of Plateau of Nominal Rate.</front>
<front id="plannerCPP-185">  int32_t plateau_steps = block-&gt;step_event_count - accelerate_steps - decelerate_steps;</front>
<front id="plannerCPP-186"></front>
<front id="plannerCPP-187">  // Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will</front>
<front id="plannerCPP-188">  // have to use intersection_distance() to calculate when to abort acceleration and start braking</front>
<front id="plannerCPP-189">  // in order to reach the final_rate exactly at the end of this block.</front>
<front id="plannerCPP-190">  if (plateau_steps &lt; 0) {</front>
<front id="plannerCPP-191">    accelerate_steps = ceil(intersection_distance(initial_rate, final_rate, acceleration, block-&gt;step_event_count));</front>
<front id="plannerCPP-192">    accelerate_steps = max(accelerate_steps, 0); // Check limits due to numerical round-off</front>
<front id="plannerCPP-193">    accelerate_steps = min((uint32_t)accelerate_steps, block-&gt;step_event_count);//(We can cast here to unsigned, because the above line ensures that we are above zero)</front>
<front id="plannerCPP-194">    plateau_steps = 0;</front>
<front id="plannerCPP-195">  }</front>
<front id="plannerCPP-196"></front>
<front id="plannerCPP-197">#if ENABLED(ADVANCE)</front>
<front id="plannerCPP-198">  volatile long initial_advance = block-&gt;advance * entry_factor * entry_factor;</front>
<front id="plannerCPP-199">  volatile long final_advance = block-&gt;advance * exit_factor * exit_factor;</front>
<front id="plannerCPP-200">#endif // ADVANCE</front>
<front id="plannerCPP-201"></front>
<front id="plannerCPP-202">  // block-&gt;accelerate_until = accelerate_steps;</front>
<front id="plannerCPP-203">  // block-&gt;decelerate_after = accelerate_steps+plateau_steps;</front>
<front id="plannerCPP-204">  CRITICAL_SECTION_START;  // Fill variables used by the stepper in a critical section</front>
<front id="plannerCPP-205">  if (!block-&gt;busy) { // Don't update variables if block is busy.</front>
<front id="plannerCPP-206">    block-&gt;accelerate_until = accelerate_steps;</front>
<front id="plannerCPP-207">    block-&gt;decelerate_after = accelerate_steps+plateau_steps;</front>
<front id="plannerCPP-208">    block-&gt;initial_rate = initial_rate;</front>
<front id="plannerCPP-209">    block-&gt;final_rate = final_rate;</front>
<front id="plannerCPP-210">    #if ENABLED(ADVANCE)</front>
<front id="plannerCPP-211">      block-&gt;initial_advance = initial_advance;</front>
<front id="plannerCPP-212">      block-&gt;final_advance = final_advance;</front>
<front id="plannerCPP-213">    #endif</front>
<front id="plannerCPP-214">  }</front>
<front id="plannerCPP-215">  CRITICAL_SECTION_END;</front>
<front id="plannerCPP-216">}</front>
<front id="plannerCPP-217"></front>
<front id="plannerCPP-218">// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the</front>
<front id="plannerCPP-219">// acceleration within the allotted distance.</front>
<front id="plannerCPP-220">FORCE_INLINE float max_allowable_speed(float acceleration, float target_velocity, float distance) {</front>
<front id="plannerCPP-221">  return sqrt(target_velocity * target_velocity - 2 * acceleration * distance);</front>
<front id="plannerCPP-222">}</front>
<front id="plannerCPP-223"></front>
<front id="plannerCPP-224">// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.</front>
<front id="plannerCPP-225">// This method will calculate the junction jerk as the euclidean distance between the nominal</front>
<front id="plannerCPP-226">// velocities of the respective blocks.</front>
<front id="plannerCPP-227">//inline float junction_jerk(block_t *before, block_t *after) {</front>
<front id="plannerCPP-228">//  return sqrt(</front>
<front id="plannerCPP-229">//    pow((before-&gt;speed_x-after-&gt;speed_x), 2)+pow((before-&gt;speed_y-after-&gt;speed_y), 2));</front>
<front id="plannerCPP-230">//}</front>
<front id="plannerCPP-231"></front>
<front id="plannerCPP-232"></front>
<front id="plannerCPP-233">// The kernel called by planner_recalculate() when scanning the plan from last to first entry.</front>
<front id="plannerCPP-234">void planner_reverse_pass_kernel(block_t *previous, block_t *current, block_t *next) {</front>
<front id="plannerCPP-235">  if (!current) return;</front>
<front id="plannerCPP-236">  UNUSED(previous);</front>
<front id="plannerCPP-237"></front>
<front id="plannerCPP-238">  if (next) {</front>
<front id="plannerCPP-239">    // If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.</front>
<front id="plannerCPP-240">    // If not, block in state of acceleration or deceleration. Reset entry speed to maximum and</front>
<front id="plannerCPP-241">    // check for maximum allowable speed reductions to ensure maximum possible planned speed.</front>
<front id="plannerCPP-242">    if (current-&gt;entry_speed != current-&gt;max_entry_speed) {</front>
<front id="plannerCPP-243"></front>
<front id="plannerCPP-244">      // If nominal length true, max junction speed is guaranteed to be reached. Only compute</front>
<front id="plannerCPP-245">      // for max allowable speed if block is decelerating and nominal length is false.</front>
<front id="plannerCPP-246">      if (!current-&gt;nominal_length_flag && current-&gt;max_entry_speed &gt; next-&gt;entry_speed) {</front>
<front id="plannerCPP-247">        current-&gt;entry_speed = min(current-&gt;max_entry_speed,</front>
<front id="plannerCPP-248">          max_allowable_speed(-current-&gt;acceleration, next-&gt;entry_speed, current-&gt;millimeters));</front>
<front id="plannerCPP-249">      }</front>
<front id="plannerCPP-250">      else {</front>
<front id="plannerCPP-251">        current-&gt;entry_speed = current-&gt;max_entry_speed;</front>
<front id="plannerCPP-252">      }</front>
<front id="plannerCPP-253">      current-&gt;recalculate_flag = true;</front>
<front id="plannerCPP-254"></front>
<front id="plannerCPP-255">    }</front>
<front id="plannerCPP-256">  } // Skip last block. Already initialized and set for recalculation.</front>
<front id="plannerCPP-257">}</front>
<front id="plannerCPP-258"></front>
<front id="plannerCPP-259">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This</front>
<front id="plannerCPP-260">// implements the reverse pass.</front>
<front id="plannerCPP-261">void planner_reverse_pass() {</front>
<front id="plannerCPP-262">  uint8_t block_index = block_buffer_head;</front>
<front id="plannerCPP-263"></front>
<front id="plannerCPP-264">  //Make a local copy of block_buffer_tail, because the interrupt can alter it</front>
<front id="plannerCPP-265">  CRITICAL_SECTION_START;</front>
<front id="plannerCPP-266">    unsigned char tail = block_buffer_tail;</front>
<front id="plannerCPP-267">  CRITICAL_SECTION_END</front>
<front id="plannerCPP-268"></front>
<front id="plannerCPP-269">  if (BLOCK_MOD(block_buffer_head - tail + BLOCK_BUFFER_SIZE) &gt; 3) { // moves queued</front>
<front id="plannerCPP-270">    block_index = BLOCK_MOD(block_buffer_head - 3);</front>
<front id="plannerCPP-271">    block_t *block[3] = { NULL, NULL, NULL };</front>
<front id="plannerCPP-272">    while (block_index != tail) {</front>
<front id="plannerCPP-273">      block_index = prev_block_index(block_index);</front>
<front id="plannerCPP-274">      block[2]= block[1];</front>
<front id="plannerCPP-275">      block[1]= block[0];</front>
<front id="plannerCPP-276">      block[0] = &block_buffer[block_index];</front>
<front id="plannerCPP-277">      planner_reverse_pass_kernel(block[0], block[1], block[2]);</front>
<front id="plannerCPP-278">    }</front>
<front id="plannerCPP-279">  }</front>
<front id="plannerCPP-280">}</front>
<front id="plannerCPP-281"></front>
<front id="plannerCPP-282">// The kernel called by planner_recalculate() when scanning the plan from first to last entry.</front>
<front id="plannerCPP-283">void planner_forward_pass_kernel(block_t *previous, block_t *current, block_t *next) {</front>
<front id="plannerCPP-284">  if (!previous) return;</front>
<front id="plannerCPP-285">  UNUSED(next);</front>
<front id="plannerCPP-286"></front>
<front id="plannerCPP-287">  // If the previous block is an acceleration block, but it is not long enough to complete the</front>
<front id="plannerCPP-288">  // full speed change within the block, we need to adjust the entry speed accordingly. Entry</front>
<front id="plannerCPP-289">  // speeds have already been reset, maximized, and reverse planned by reverse planner.</front>
<front id="plannerCPP-290">  // If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.</front>
<front id="plannerCPP-291">  if (!previous-&gt;nominal_length_flag) {</front>
<front id="plannerCPP-292">    if (previous-&gt;entry_speed &lt; current-&gt;entry_speed) {</front>
<front id="plannerCPP-293">      double entry_speed = min(current-&gt;entry_speed,</front>
<front id="plannerCPP-294">        max_allowable_speed(-previous-&gt;acceleration, previous-&gt;entry_speed, previous-&gt;millimeters));</front>
<front id="plannerCPP-295"></front>
<front id="plannerCPP-296">      // Check for junction speed change</front>
<front id="plannerCPP-297">      if (current-&gt;entry_speed != entry_speed) {</front>
<front id="plannerCPP-298">        current-&gt;entry_speed = entry_speed;</front>
<front id="plannerCPP-299">        current-&gt;recalculate_flag = true;</front>
<front id="plannerCPP-300">      }</front>
<front id="plannerCPP-301">    }</front>
<front id="plannerCPP-302">  }</front>
<front id="plannerCPP-303">}</front>
<front id="plannerCPP-304"></front>
<front id="plannerCPP-305">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This</front>
<front id="plannerCPP-306">// implements the forward pass.</front>
<front id="plannerCPP-307">void planner_forward_pass() {</front>
<front id="plannerCPP-308">  uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-309">  block_t *block[3] = { NULL, NULL, NULL };</front>
<front id="plannerCPP-310"></front>
<front id="plannerCPP-311">  while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-312">    block[0] = block[1];</front>
<front id="plannerCPP-313">    block[1] = block[2];</front>
<front id="plannerCPP-314">    block[2] = &block_buffer[block_index];</front>
<front id="plannerCPP-315">    planner_forward_pass_kernel(block[0], block[1], block[2]);</front>
<front id="plannerCPP-316">    block_index = next_block_index(block_index);</front>
<front id="plannerCPP-317">  }</front>
<front id="plannerCPP-318">  planner_forward_pass_kernel(block[1], block[2], NULL);</front>
<front id="plannerCPP-319">}</front>
<front id="plannerCPP-320"></front>
<front id="plannerCPP-321">// Recalculates the trapezoid speed profiles for all blocks in the plan according to the</front>
<front id="plannerCPP-322">// entry_factor for each junction. Must be called by planner_recalculate() after</front>
<front id="plannerCPP-323">// updating the blocks.</front>
<front id="plannerCPP-324">void planner_recalculate_trapezoids() {</front>
<front id="plannerCPP-325">  int8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-326">  block_t *current;</front>
<front id="plannerCPP-327">  block_t *next = NULL;</front>
<front id="plannerCPP-328"></front>
<front id="plannerCPP-329">  while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-330">    current = next;</front>
<front id="plannerCPP-331">    next = &block_buffer[block_index];</front>
<front id="plannerCPP-332">    if (current) {</front>
<front id="plannerCPP-333">      // Recalculate if current block entry or exit junction speed has changed.</front>
<front id="plannerCPP-334">      if (current-&gt;recalculate_flag || next-&gt;recalculate_flag) {</front>
<front id="plannerCPP-335">        // NOTE: Entry and exit factors always &gt; 0 by all previous logic operations.</front>
<front id="plannerCPP-336">        float nom = current-&gt;nominal_speed;</front>
<front id="plannerCPP-337">        calculate_trapezoid_for_block(current, current-&gt;entry_speed / nom, next-&gt;entry_speed / nom);</front>
<front id="plannerCPP-338">        current-&gt;recalculate_flag = false; // Reset current only to ensure next trapezoid is computed</front>
<front id="plannerCPP-339">      }</front>
<front id="plannerCPP-340">    }</front>
<front id="plannerCPP-341">    block_index = next_block_index( block_index );</front>
<front id="plannerCPP-342">  }</front>
<front id="plannerCPP-343">  // Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.</front>
<front id="plannerCPP-344">  if (next) {</front>
<front id="plannerCPP-345">    float nom = next-&gt;nominal_speed;</front>
<front id="plannerCPP-346">    calculate_trapezoid_for_block(next, next-&gt;entry_speed / nom, MINIMUM_PLANNER_SPEED / nom);</front>
<front id="plannerCPP-347">    next-&gt;recalculate_flag = false;</front>
<front id="plannerCPP-348">  }</front>
<front id="plannerCPP-349">}</front>
<front id="plannerCPP-350"></front>
<front id="plannerCPP-351">// Recalculates the motion plan according to the following algorithm:</front>
<front id="plannerCPP-352">//</front>
<front id="plannerCPP-353">//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor)</front>
<front id="plannerCPP-354">//      so that:</front>
<front id="plannerCPP-355">//     a. The junction jerk is within the set limit</front>
<front id="plannerCPP-356">//     b. No speed reduction within one block requires faster deceleration than the one, true constant</front>
<front id="plannerCPP-357">//        acceleration.</front>
<front id="plannerCPP-358">//   2. Go over every block in chronological order and dial down junction speed reduction values if</front>
<front id="plannerCPP-359">//     a. The speed increase within one block would require faster acceleration than the one, true</front>
<front id="plannerCPP-360">//        constant acceleration.</front>
<front id="plannerCPP-361">//</front>
<front id="plannerCPP-362">// When these stages are complete all blocks have an entry_factor that will allow all speed changes to</front>
<front id="plannerCPP-363">// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than</front>
<front id="plannerCPP-364">// the set limit. Finally it will:</front>
<front id="plannerCPP-365">//</front>
<front id="plannerCPP-366">//   3. Recalculate trapezoids for all blocks.</front>
<front id="plannerCPP-367"></front>
<front id="plannerCPP-368">void planner_recalculate() {</front>
<front id="plannerCPP-369">  planner_reverse_pass();</front>
<front id="plannerCPP-370">  planner_forward_pass();</front>
<front id="plannerCPP-371">  planner_recalculate_trapezoids();</front>
<front id="plannerCPP-372">}</front>
<front id="plannerCPP-373"></front>
<front id="plannerCPP-374">void plan_init() {</front>
<front id="plannerCPP-375">  block_buffer_head = block_buffer_tail = 0;</front>
<front id="plannerCPP-376">  memset(position, 0, sizeof(position)); // clear position</front>
<front id="plannerCPP-377">  for (int i=0; i&lt;NUM_AXIS; i++) previous_speed[i] = 0.0;</front>
<front id="plannerCPP-378">  previous_nominal_speed = 0.0;</front>
<front id="plannerCPP-379">}</front>
<front id="plannerCPP-380"></front>
<front id="plannerCPP-381"></front>
<front id="plannerCPP-382">#if ENABLED(AUTOTEMP)</front>
<front id="plannerCPP-383">  void getHighESpeed() {</front>
<front id="plannerCPP-384">    static float oldt = 0;</front>
<front id="plannerCPP-385"></front>
<front id="plannerCPP-386">    if (!autotemp_enabled) return;</front>
<front id="plannerCPP-387">    if (degTargetHotend0() + 2 &lt; autotemp_min) return; // probably temperature set to zero.</front>
<front id="plannerCPP-388"></front>
<front id="plannerCPP-389">    float high = 0.0;</front>
<front id="plannerCPP-390">    uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-391"></front>
<front id="plannerCPP-392">    while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-393">      block_t *block = &block_buffer[block_index];</front>
<front id="plannerCPP-394">      if (block-&gt;steps[X_AXIS] || block-&gt;steps[Y_AXIS] || block-&gt;steps[Z_AXIS]) {</front>
<front id="plannerCPP-395">        float se = (float)block-&gt;steps[E_AXIS] / block-&gt;step_event_count * block-&gt;nominal_speed; // mm/sec;</front>
<front id="plannerCPP-396">        if (se &gt; high) high = se;</front>
<front id="plannerCPP-397">      }</front>
<front id="plannerCPP-398">      block_index = next_block_index(block_index);</front>
<front id="plannerCPP-399">    }</front>
<front id="plannerCPP-400"></front>
<front id="plannerCPP-401">    float t = autotemp_min + high * autotemp_factor;</front>
<front id="plannerCPP-402">    t = constrain(t, autotemp_min, autotemp_max);</front>
<front id="plannerCPP-403">    if (oldt &gt; t) {</front>
<front id="plannerCPP-404">      t *= (1 - AUTOTEMP_OLDWEIGHT);</front>
<front id="plannerCPP-405">      t += AUTOTEMP_OLDWEIGHT * oldt;</front>
<front id="plannerCPP-406">    }</front>
<front id="plannerCPP-407">    oldt = t;</front>
<front id="plannerCPP-408">    setTargetHotend0(t);</front>
<front id="plannerCPP-409">  }</front>
<front id="plannerCPP-410">#endif</front>
<front id="plannerCPP-411"></front>
<front id="plannerCPP-412">void check_axes_activity() {</front>
<front id="plannerCPP-413">  unsigned char axis_active[NUM_AXIS] = { 0 },</front>
<front id="plannerCPP-414">                tail_fan_speed = fanSpeed;</front>
<front id="plannerCPP-415">  #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-416">    unsigned char tail_valve_pressure = ValvePressure,</front>
<front id="plannerCPP-417">                  tail_e_to_p_pressure = EtoPPressure;</front>
<front id="plannerCPP-418">  #endif</front>
<front id="plannerCPP-419"></front>
<front id="plannerCPP-420">  block_t *block;</front>
<front id="plannerCPP-421"></front>
<front id="plannerCPP-422">  if (blocks_queued()) {</front>
<front id="plannerCPP-423">    uint8_t block_index = block_buffer_tail;</front>
<front id="plannerCPP-424">    tail_fan_speed = block_buffer[block_index].fan_speed;</front>
<front id="plannerCPP-425">    #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-426">      block = &block_buffer[block_index];</front>
<front id="plannerCPP-427">      tail_valve_pressure = block-&gt;valve_pressure;</front>
<front id="plannerCPP-428">      tail_e_to_p_pressure = block-&gt;e_to_p_pressure;</front>
<front id="plannerCPP-429">    #endif</front>
<front id="plannerCPP-430">    while (block_index != block_buffer_head) {</front>
<front id="plannerCPP-431">      block = &block_buffer[block_index];</front>
<front id="plannerCPP-432">      for (int i=0; i&lt;NUM_AXIS; i++) if (block-&gt;steps[i]) axis_active[i]++;</front>
<front id="plannerCPP-433">      block_index = next_block_index(block_index);</front>
<front id="plannerCPP-434">    }</front>
<front id="plannerCPP-435">  }</front>
<front id="plannerCPP-436">  if (DISABLE_X && !axis_active[X_AXIS]) disable_x();</front>
<front id="plannerCPP-437">  if (DISABLE_Y && !axis_active[Y_AXIS]) disable_y();</front>
<front id="plannerCPP-438">  if (DISABLE_Z && !axis_active[Z_AXIS]) disable_z();</front>
<front id="plannerCPP-439">  if (DISABLE_E && !axis_active[E_AXIS]) {</front>
<front id="plannerCPP-440">    disable_e0();</front>
<front id="plannerCPP-441">    disable_e1();</front>
<front id="plannerCPP-442">    disable_e2();</front>
<front id="plannerCPP-443">    disable_e3();</front>
<front id="plannerCPP-444">  }</front>
<front id="plannerCPP-445"></front>
<front id="plannerCPP-446">  #if HAS_FAN</front>
<front id="plannerCPP-447">    #ifdef FAN_KICKSTART_TIME</front>
<front id="plannerCPP-448">      static millis_t fan_kick_end;</front>
<front id="plannerCPP-449">      if (tail_fan_speed) {</front>
<front id="plannerCPP-450">        millis_t ms = millis();</front>
<front id="plannerCPP-451">        if (fan_kick_end == 0) {</front>
<front id="plannerCPP-452">          // Just starting up fan - run at full power.</front>
<front id="plannerCPP-453">          fan_kick_end = ms + FAN_KICKSTART_TIME;</front>
<front id="plannerCPP-454">          tail_fan_speed = 255;</front>
<front id="plannerCPP-455">        } else if (fan_kick_end &gt; ms)</front>
<front id="plannerCPP-456">          // Fan still spinning up.</front>
<front id="plannerCPP-457">          tail_fan_speed = 255;</front>
<front id="plannerCPP-458">        } else {</front>
<front id="plannerCPP-459">          fan_kick_end = 0;</front>
<front id="plannerCPP-460">        }</front>
<front id="plannerCPP-461">    #endif //FAN_KICKSTART_TIME</front>
<front id="plannerCPP-462">    #if ENABLED(FAN_MIN_PWM)</front>
<front id="plannerCPP-463">      #define CALC_FAN_SPEED (tail_fan_speed ? ( FAN_MIN_PWM + (tail_fan_speed * (255 - FAN_MIN_PWM)) / 255 ) : 0)</front>
<front id="plannerCPP-464">    #else</front>
<front id="plannerCPP-465">      #define CALC_FAN_SPEED tail_fan_speed</front>
<front id="plannerCPP-466">    #endif // FAN_MIN_PWM</front>
<front id="plannerCPP-467">    #if ENABLED(FAN_SOFT_PWM)</front>
<front id="plannerCPP-468">      fanSpeedSoftPwm = CALC_FAN_SPEED;</front>
<front id="plannerCPP-469">    #else</front>
<front id="plannerCPP-470">      analogWrite(FAN_PIN, CALC_FAN_SPEED);</front>
<front id="plannerCPP-471">    #endif // FAN_SOFT_PWM</front>
<front id="plannerCPP-472">  #endif // HAS_FAN</front>
<front id="plannerCPP-473"></front>
<front id="plannerCPP-474">  #if ENABLED(AUTOTEMP)</front>
<front id="plannerCPP-475">    getHighESpeed();</front>
<front id="plannerCPP-476">  #endif</front>
<front id="plannerCPP-477"></front>
<front id="plannerCPP-478">  #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-479">    #if HAS_HEATER_1</front>
<front id="plannerCPP-480">      analogWrite(HEATER_1_PIN,tail_valve_pressure);</front>
<front id="plannerCPP-481">    #endif</front>
<front id="plannerCPP-482">    #if HAS_HEATER_2</front>
<front id="plannerCPP-483">      analogWrite(HEATER_2_PIN,tail_e_to_p_pressure);</front>
<front id="plannerCPP-484">    #endif</front>
<front id="plannerCPP-485">  #endif</front>
<front id="plannerCPP-486">}</front>
<front id="plannerCPP-487"></front>
<front id="plannerCPP-488">#ifdef RESUME_FEATURE</front>
<front id="plannerCPP-489">  void floor_z(const float &z)</front>
<front id="plannerCPP-490">  {</front>
<front id="plannerCPP-491">    // filter out moves below a given floor height and attempt to ignore any hops/travels</front>
<front id="plannerCPP-492">    if (planner_disabled_below_z && !layer_reached) {</front>
<front id="plannerCPP-493">      if (z &lt; planner_disabled_below_z) {</front>
<front id="plannerCPP-494">        if (z &gt; last_z && !gone_up) // up once</front>
<front id="plannerCPP-495">          gone_up = true;</front>
<front id="plannerCPP-496">        else if (z &lt; last_z) { // back down</front>
<front id="plannerCPP-497">          #ifdef TRACK_LAYER</front>
<front id="plannerCPP-498">            if (z &gt; last_layer_z)</front>
<front id="plannerCPP-499">              current_layer++;</front>
<front id="plannerCPP-500">            else if (z &lt; last_layer_z && z != 0)</front>
<front id="plannerCPP-501">              current_layer = 1; // if it goes lower than what we would think was the previous layer then we might as well assume it's printing another object</front>
<front id="plannerCPP-502">            else if (z == 0)</front>
<front id="plannerCPP-503">              current_layer = 0;</front>
<front id="plannerCPP-504">            last_layer_z = z;</front>
<front id="plannerCPP-505">          #endif //TRACK_LAYER</front>
<front id="plannerCPP-506">          hops = true;</front>
<front id="plannerCPP-507">          gone_up = false;</front>
<front id="plannerCPP-508">        }</front>
<front id="plannerCPP-509">        else if (z &gt; last_z && gone_up) { // up twice</front>
<front id="plannerCPP-510">          #ifdef TRACK_LAYER</front>
<front id="plannerCPP-511">            current_layer++; // be careful with prints like the spiral vase</front>
<front id="plannerCPP-512">          #endif //TRACK_LAYER</front>
<front id="plannerCPP-513">          hops = false;</front>
<front id="plannerCPP-514">        }</front>
<front id="plannerCPP-515">        z_reached = false;</front>
<front id="plannerCPP-516">        last_z = z;</front>
<front id="plannerCPP-517">        return;</front>
<front id="plannerCPP-518">      }</front>
<front id="plannerCPP-519">      else if (hops && !z_reached) {</front>
<front id="plannerCPP-520">        z_reached = true;</front>
<front id="plannerCPP-521">        last_z = z;</front>
<front id="plannerCPP-522">        return;</front>
<front id="plannerCPP-523">      }</front>
<front id="plannerCPP-524">      else if (hops && z == last_z)</front>
<front id="plannerCPP-525">        return;</front>
<front id="plannerCPP-526">      else</front>
<front id="plannerCPP-527">        layer_reached = true;</front>
<front id="plannerCPP-528">    }</front>
<front id="plannerCPP-529">    else if (planner_disabled_below_z && z &lt; planner_disabled_below_z) {</front>
<front id="plannerCPP-530">      z_reached = false;</front>
<front id="plannerCPP-531">      layer_reached = false;</front>
<front id="plannerCPP-532">      return;</front>
<front id="plannerCPP-533">    }</front>
<front id="plannerCPP-534">  }</front>
<front id="plannerCPP-535">#endif //RESUME_FEATURE</front>
<front id="plannerCPP-536"></front>
<front id="plannerCPP-537">#ifdef TRACK_LAYER</front>
<front id="plannerCPP-538">  void layer_count(const float &z)</front>
<front id="plannerCPP-539">  {</front>
<front id="plannerCPP-540">    if (z &gt; last_z && !gone_up) // up once</front>
<front id="plannerCPP-541">      gone_up = true;</front>
<front id="plannerCPP-542">    else if (z &lt; last_z) { // back down</front>
<front id="plannerCPP-543">      if (z &gt; last_layer_z)</front>
<front id="plannerCPP-544">        current_layer++;</front>
<front id="plannerCPP-545">      else if (z &lt; last_layer_z && z != 0)</front>
<front id="plannerCPP-546">        current_layer = 1; // if it goes lower than what we would think was the previous layer then we might as well assume it's printing another object</front>
<front id="plannerCPP-547">      else if (z == 0)</front>
<front id="plannerCPP-548">        current_layer = 0;</front>
<front id="plannerCPP-549">      last_layer_z = z;</front>
<front id="plannerCPP-550">      gone_up = false;</front>
<front id="plannerCPP-551">    }</front>
<front id="plannerCPP-552">    else if (z &gt; last_z && gone_up) // up twice</front>
<front id="plannerCPP-553">      current_layer++; // be careful with prints like the spiral vase</front>
<front id="plannerCPP-554"></front>
<front id="plannerCPP-555">    last_z = z;</front>
<front id="plannerCPP-556">  }</front>
<front id="plannerCPP-557">#endif //TRACK_LAYER</front>
<front id="plannerCPP-558"></front>
<front id="plannerCPP-559">float junction_deviation = 0.1;</front>
<front id="plannerCPP-560">// Add a new linear movement to the buffer. steps[X_AXIS], _y and _z is the absolute position in </front>
<front id="plannerCPP-561">// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration</front>
<front id="plannerCPP-562">// calculation the caller must also provide the physical length of the line in millimeters.</front>
<front id="plannerCPP-563">#if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-564">  void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t extruder)</front>
<front id="plannerCPP-565">#else</front>
<front id="plannerCPP-566">  void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t extruder)</front>
<front id="plannerCPP-567">#endif  // AUTO_BED_LEVELING_FEATURE</front>
<front id="plannerCPP-568">{</front>
<front id="plannerCPP-569">  #ifdef RESUME_FEATURE</front>
<front id="plannerCPP-570">    floor_z(z);</front>
<front id="plannerCPP-571">  #endif</front>
<front id="plannerCPP-572"></front>
<front id="plannerCPP-573">  #ifdef TRACK_LAYER</front>
<front id="plannerCPP-574">    layer_count(z);</front>
<front id="plannerCPP-575">  #endif //TRACK_LAYER</front>
<front id="plannerCPP-576"></front>
<front id="plannerCPP-577">  // Calculate the buffer head after we push this byte</front>
<front id="plannerCPP-578">  int next_buffer_head = next_block_index(block_buffer_head);</front>
<front id="plannerCPP-579"></front>
<front id="plannerCPP-580">  // If the buffer is full: good! That means we are well ahead of the robot.</front>
<front id="plannerCPP-581">  // Rest here until there is room in the buffer.</front>
<front id="plannerCPP-582">  while (block_buffer_tail == next_buffer_head) idle();</front>
<front id="plannerCPP-583"></front>
<front id="plannerCPP-584">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-585">    if (mbl.active) z += mbl.get_z(x, y);</front>
<front id="plannerCPP-586">  #elif ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerCPP-587">    apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</front>
<front id="plannerCPP-588">  #endif</front>
<front id="plannerCPP-589"></front>
<front id="plannerCPP-590">  // The target position of the tool in absolute steps</front>
<front id="plannerCPP-591">  // Calculate target position in absolute steps</front>
<front id="plannerCPP-592">  //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow</front>
<front id="plannerCPP-593">  long target[NUM_AXIS];</front>
<front id="plannerCPP-594">  target[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]);</front>
<front id="plannerCPP-595">  target[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]);</front>
<front id="plannerCPP-596">  target[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]);</front>
<front id="plannerCPP-597">  target[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-598"></front>
<front id="plannerCPP-599">  float dx = target[X_AXIS] - position[X_AXIS],</front>
<front id="plannerCPP-600">        dy = target[Y_AXIS] - position[Y_AXIS],</front>
<front id="plannerCPP-601">        dz = target[Z_AXIS] - position[Z_AXIS];</front>
<front id="plannerCPP-602"></front>
<front id="plannerCPP-603">  // DRYRUN ignores all temperature constraints and assures that the extruder is instantly satisfied</front>
<front id="plannerCPP-604">  if (marlin_debug_flags & DEBUG_DRYRUN)</front>
<front id="plannerCPP-605">    position[E_AXIS] = target[E_AXIS];</front>
<front id="plannerCPP-606"></front>
<front id="plannerCPP-607">  float de = target[E_AXIS] - position[E_AXIS];</front>
<front id="plannerCPP-608"></front>
<front id="plannerCPP-609">  #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)</front>
<front id="plannerCPP-610">    if (de) {</front>
<front id="plannerCPP-611">      if (degHotend(extruder) &lt; extrude_min_temp) {</front>
<front id="plannerCPP-612">        position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part</front>
<front id="plannerCPP-613">        de = 0; // no difference</front>
<front id="plannerCPP-614">        SERIAL_ECHO_START;</front>
<front id="plannerCPP-615">        SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);</front>
<front id="plannerCPP-616">      }</front>
<front id="plannerCPP-617">      #if ENABLED(PREVENT_LENGTHY_EXTRUDE)</front>
<front id="plannerCPP-618">        if (labs(de) &gt; axis_steps_per_unit[E_AXIS] * EXTRUDE_MAXLENGTH) {</front>
<front id="plannerCPP-619">          position[E_AXIS] = target[E_AXIS]; // Behave as if the move really took place, but ignore E part</front>
<front id="plannerCPP-620">          de = 0; // no difference</front>
<front id="plannerCPP-621">          SERIAL_ECHO_START;</front>
<front id="plannerCPP-622">          SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);</front>
<front id="plannerCPP-623">        }</front>
<front id="plannerCPP-624">      #endif</front>
<front id="plannerCPP-625">    }</front>
<front id="plannerCPP-626">  #endif</front>
<front id="plannerCPP-627"></front>
<front id="plannerCPP-628">  // Prepare to set up new block</front>
<front id="plannerCPP-629">  block_t *block = &block_buffer[block_buffer_head];</front>
<front id="plannerCPP-630"></front>
<front id="plannerCPP-631">  // Mark block as not busy (Not executed by the stepper interrupt)</front>
<front id="plannerCPP-632">  block-&gt;busy = false;</front>
<front id="plannerCPP-633"></front>
<front id="plannerCPP-634">  // Number of steps for each axis</front>
<front id="plannerCPP-635">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-636">    // corexy planning</front>
<front id="plannerCPP-637">    // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html</front>
<front id="plannerCPP-638">    block-&gt;steps[A_AXIS] = labs(dx + dy);</front>
<front id="plannerCPP-639">    block-&gt;steps[B_AXIS] = labs(dx - dy);</front>
<front id="plannerCPP-640">    block-&gt;steps[Z_AXIS] = labs(dz);</front>
<front id="plannerCPP-641">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-642">    // corexz planning</front>
<front id="plannerCPP-643">    block-&gt;steps[A_AXIS] = labs(dx + dz);</front>
<front id="plannerCPP-644">    block-&gt;steps[Y_AXIS] = labs(dy);</front>
<front id="plannerCPP-645">    block-&gt;steps[C_AXIS] = labs(dx - dz);</front>
<front id="plannerCPP-646">  #else</front>
<front id="plannerCPP-647">    // default non-h-bot planning</front>
<front id="plannerCPP-648">    block-&gt;steps[X_AXIS] = labs(dx);</front>
<front id="plannerCPP-649">    block-&gt;steps[Y_AXIS] = labs(dy);</front>
<front id="plannerCPP-650">    block-&gt;steps[Z_AXIS] = labs(dz);</front>
<front id="plannerCPP-651">  #endif</front>
<front id="plannerCPP-652"></front>
<front id="plannerCPP-653">  block-&gt;steps[E_AXIS] = labs(de);</front>
<front id="plannerCPP-654">  block-&gt;steps[E_AXIS] *= volumetric_multiplier[extruder];</front>
<front id="plannerCPP-655">  block-&gt;steps[E_AXIS] *= extruder_multiplier[extruder];</front>
<front id="plannerCPP-656">  block-&gt;steps[E_AXIS] /= 100;</front>
<front id="plannerCPP-657">  block-&gt;step_event_count = max(block-&gt;steps[X_AXIS], max(block-&gt;steps[Y_AXIS], max(block-&gt;steps[Z_AXIS], block-&gt;steps[E_AXIS])));</front>
<front id="plannerCPP-658"></front>
<front id="plannerCPP-659">  // Bail if this is a zero-length block</front>
<front id="plannerCPP-660">  if (block-&gt;step_event_count &lt;= dropsegments) return;</front>
<front id="plannerCPP-661"></front>
<front id="plannerCPP-662">  block-&gt;fan_speed = fanSpeed;</front>
<front id="plannerCPP-663">  #if ENABLED(BARICUDA)</front>
<front id="plannerCPP-664">    block-&gt;valve_pressure = ValvePressure;</front>
<front id="plannerCPP-665">    block-&gt;e_to_p_pressure = EtoPPressure;</front>
<front id="plannerCPP-666">  #endif</front>
<front id="plannerCPP-667"></front>
<front id="plannerCPP-668">  // Compute direction bits for this block</front>
<front id="plannerCPP-669">  uint8_t db = 0;</front>
<front id="plannerCPP-670">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-671">    if (dx &lt; 0) db |= BIT(X_HEAD); // Save the real Extruder (head) direction in X Axis</front>
<front id="plannerCPP-672">    if (dy &lt; 0) db |= BIT(Y_HEAD); // ...and Y</front>
<front id="plannerCPP-673">    if (dz &lt; 0) db |= BIT(Z_AXIS);</front>
<front id="plannerCPP-674">    if (dx + dy &lt; 0) db |= BIT(A_AXIS); // Motor A direction</front>
<front id="plannerCPP-675">    if (dx - dy &lt; 0) db |= BIT(B_AXIS); // Motor B direction</front>
<front id="plannerCPP-676">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-677">    if (dx &lt; 0) db |= BIT(X_HEAD); // Save the real Extruder (head) direction in X Axis</front>
<front id="plannerCPP-678">    if (dy &lt; 0) db |= BIT(Y_AXIS);</front>
<front id="plannerCPP-679">    if (dz &lt; 0) db |= BIT(Z_HEAD); // ...and Z</front>
<front id="plannerCPP-680">    if (dx + dz &lt; 0) db |= BIT(A_AXIS); // Motor A direction</front>
<front id="plannerCPP-681">    if (dx - dz &lt; 0) db |= BIT(C_AXIS); // Motor B direction</front>
<front id="plannerCPP-682">  #else</front>
<front id="plannerCPP-683">    if (dx &lt; 0) db |= BIT(X_AXIS);</front>
<front id="plannerCPP-684">    if (dy &lt; 0) db |= BIT(Y_AXIS);</front>
<front id="plannerCPP-685">    if (dz &lt; 0) db |= BIT(Z_AXIS);</front>
<front id="plannerCPP-686">  #endif</front>
<front id="plannerCPP-687">  if (de &lt; 0) db |= BIT(E_AXIS);</front>
<front id="plannerCPP-688">  block-&gt;direction_bits = db;</front>
<front id="plannerCPP-689"></front>
<front id="plannerCPP-690">  block-&gt;active_extruder = extruder;</front>
<front id="plannerCPP-691"></front>
<front id="plannerCPP-692">  //enable active axes</front>
<front id="plannerCPP-693">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-694">    if (block-&gt;steps[A_AXIS] || block-&gt;steps[B_AXIS]) {</front>
<front id="plannerCPP-695">      enable_x();</front>
<front id="plannerCPP-696">      enable_y();</front>
<front id="plannerCPP-697">    }</front>
<front id="plannerCPP-698">    #if DISABLED(Z_LATE_ENABLE)</front>
<front id="plannerCPP-699">      if (block-&gt;steps[Z_AXIS]) enable_z();</front>
<front id="plannerCPP-700">    #endif</front>
<front id="plannerCPP-701">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-702">    if (block-&gt;steps[A_AXIS] || block-&gt;steps[C_AXIS]) {</front>
<front id="plannerCPP-703">      enable_x();</front>
<front id="plannerCPP-704">      enable_z();</front>
<front id="plannerCPP-705">    }</front>
<front id="plannerCPP-706">    if (block-&gt;steps[Y_AXIS]) enable_y();</front>
<front id="plannerCPP-707">  #else</front>
<front id="plannerCPP-708">    if (block-&gt;steps[X_AXIS]) enable_x();</front>
<front id="plannerCPP-709">    if (block-&gt;steps[Y_AXIS]) enable_y();</front>
<front id="plannerCPP-710">    #if DISABLED(Z_LATE_ENABLE)</front>
<front id="plannerCPP-711">      if (block-&gt;steps[Z_AXIS]) enable_z();</front>
<front id="plannerCPP-712">    #endif</front>
<front id="plannerCPP-713">  #endif</front>
<front id="plannerCPP-714"></front>
<front id="plannerCPP-715">  // Enable extruder(s)</front>
<front id="plannerCPP-716">  if (block-&gt;steps[E_AXIS]) {</front>
<front id="plannerCPP-717">    if (DISABLE_INACTIVE_EXTRUDER) { //enable only selected extruder</front>
<front id="plannerCPP-718"></front>
<front id="plannerCPP-719">      for (int i=0; i&lt;EXTRUDERS; i++)</front>
<front id="plannerCPP-720">        if (g_uc_extruder_last_move[i] &gt; 0) g_uc_extruder_last_move[i]--;</front>
<front id="plannerCPP-721"></front>
<front id="plannerCPP-722">      switch(extruder) {</front>
<front id="plannerCPP-723">        case 0:</front>
<front id="plannerCPP-724">          enable_e0();</front>
<front id="plannerCPP-725">          g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-726">          #if EXTRUDERS &gt; 1</front>
<front id="plannerCPP-727">            if (g_uc_extruder_last_move[1] == 0) disable_e1();</front>
<front id="plannerCPP-728">            #if EXTRUDERS &gt; 2</front>
<front id="plannerCPP-729">              if (g_uc_extruder_last_move[2] == 0) disable_e2();</front>
<front id="plannerCPP-730">              #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-731">                if (g_uc_extruder_last_move[3] == 0) disable_e3();</front>
<front id="plannerCPP-732">              #endif</front>
<front id="plannerCPP-733">            #endif</front>
<front id="plannerCPP-734">          #endif</front>
<front id="plannerCPP-735">        break;</front>
<front id="plannerCPP-736">        #if EXTRUDERS &gt; 1</front>
<front id="plannerCPP-737">          case 1:</front>
<front id="plannerCPP-738">            enable_e1();</front>
<front id="plannerCPP-739">            g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-740">            if (g_uc_extruder_last_move[0] == 0) disable_e0();</front>
<front id="plannerCPP-741">            #if EXTRUDERS &gt; 2</front>
<front id="plannerCPP-742">              if (g_uc_extruder_last_move[2] == 0) disable_e2();</front>
<front id="plannerCPP-743">              #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-744">                if (g_uc_extruder_last_move[3] == 0) disable_e3();</front>
<front id="plannerCPP-745">              #endif</front>
<front id="plannerCPP-746">            #endif</front>
<front id="plannerCPP-747">          break;</front>
<front id="plannerCPP-748">          #if EXTRUDERS &gt; 2</front>
<front id="plannerCPP-749">            case 2:</front>
<front id="plannerCPP-750">              enable_e2();</front>
<front id="plannerCPP-751">              g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-752">              if (g_uc_extruder_last_move[0] == 0) disable_e0();</front>
<front id="plannerCPP-753">              if (g_uc_extruder_last_move[1] == 0) disable_e1();</front>
<front id="plannerCPP-754">              #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-755">                if (g_uc_extruder_last_move[3] == 0) disable_e3();</front>
<front id="plannerCPP-756">              #endif</front>
<front id="plannerCPP-757">            break;</front>
<front id="plannerCPP-758">            #if EXTRUDERS &gt; 3</front>
<front id="plannerCPP-759">              case 3:</front>
<front id="plannerCPP-760">                enable_e3();</front>
<front id="plannerCPP-761">                g_uc_extruder_last_move[3] = BLOCK_BUFFER_SIZE * 2;</front>
<front id="plannerCPP-762">                if (g_uc_extruder_last_move[0] == 0) disable_e0();</front>
<front id="plannerCPP-763">                if (g_uc_extruder_last_move[1] == 0) disable_e1();</front>
<front id="plannerCPP-764">                if (g_uc_extruder_last_move[2] == 0) disable_e2();</front>
<front id="plannerCPP-765">              break;</front>
<front id="plannerCPP-766">            #endif // EXTRUDERS &gt; 3</front>
<front id="plannerCPP-767">          #endif // EXTRUDERS &gt; 2</front>
<front id="plannerCPP-768">        #endif // EXTRUDERS &gt; 1</front>
<front id="plannerCPP-769">      }</front>
<front id="plannerCPP-770">    }</front>
<front id="plannerCPP-771">    else { // enable all</front>
<front id="plannerCPP-772">      enable_e0();</front>
<front id="plannerCPP-773">      enable_e1();</front>
<front id="plannerCPP-774">      enable_e2();</front>
<front id="plannerCPP-775">      enable_e3();</front>
<front id="plannerCPP-776">    }</front>
<front id="plannerCPP-777">  }</front>
<front id="plannerCPP-778"></front>
<front id="plannerCPP-779">  if (block-&gt;steps[E_AXIS])</front>
<front id="plannerCPP-780">    NOLESS(feed_rate, minimumfeedrate);</front>
<front id="plannerCPP-781">  else</front>
<front id="plannerCPP-782">    NOLESS(feed_rate, mintravelfeedrate);</front>
<front id="plannerCPP-783"></front>
<front id="plannerCPP-784">  /**</front>
<front id="plannerCPP-785">   * This part of the code calculates the total length of the movement.</front>
<front id="plannerCPP-786">   * For cartesian bots, the X_AXIS is the real X movement and same for Y_AXIS.</front>
<front id="plannerCPP-787">   * But for corexy bots, that is not true. The "X_AXIS" and "Y_AXIS" motors (that should be named to A_AXIS</front>
<front id="plannerCPP-788">   * and B_AXIS) cannot be used for X and Y length, because A=X+Y and B=X-Y.</front>
<front id="plannerCPP-789">   * So we need to create other 2 "AXIS", named X_HEAD and Y_HEAD, meaning the real displacement of the Head.</front>
<front id="plannerCPP-790">   * Having the real displacement of the head, we can calculate the total movement length and apply the desired speed.</front>
<front id="plannerCPP-791">   */</front>
<front id="plannerCPP-792">  #if ENABLED(COREXY)</front>
<front id="plannerCPP-793">    float delta_mm[6];</front>
<front id="plannerCPP-794">    delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-795">    delta_mm[Y_HEAD] = dy / axis_steps_per_unit[B_AXIS];</front>
<front id="plannerCPP-796">    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];</front>
<front id="plannerCPP-797">    delta_mm[A_AXIS] = (dx + dy) / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-798">    delta_mm[B_AXIS] = (dx - dy) / axis_steps_per_unit[B_AXIS];</front>
<front id="plannerCPP-799">  #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-800">    float delta_mm[6];</front>
<front id="plannerCPP-801">    delta_mm[X_HEAD] = dx / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-802">    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];</front>
<front id="plannerCPP-803">    delta_mm[Z_HEAD] = dz / axis_steps_per_unit[C_AXIS];</front>
<front id="plannerCPP-804">    delta_mm[A_AXIS] = (dx + dz) / axis_steps_per_unit[A_AXIS];</front>
<front id="plannerCPP-805">    delta_mm[C_AXIS] = (dx - dz) / axis_steps_per_unit[C_AXIS];</front>
<front id="plannerCPP-806">  #else</front>
<front id="plannerCPP-807">    float delta_mm[4];</front>
<front id="plannerCPP-808">    delta_mm[X_AXIS] = dx / axis_steps_per_unit[X_AXIS];</front>
<front id="plannerCPP-809">    delta_mm[Y_AXIS] = dy / axis_steps_per_unit[Y_AXIS];</front>
<front id="plannerCPP-810">    delta_mm[Z_AXIS] = dz / axis_steps_per_unit[Z_AXIS];</front>
<front id="plannerCPP-811">  #endif</front>
<front id="plannerCPP-812">  delta_mm[E_AXIS] = (de / axis_steps_per_unit[E_AXIS]) * volumetric_multiplier[extruder] * extruder_multiplier[extruder] / 100.0;</front>
<front id="plannerCPP-813"></front>
<front id="plannerCPP-814">  if (block-&gt;steps[X_AXIS] &lt;= dropsegments && block-&gt;steps[Y_AXIS] &lt;= dropsegments && block-&gt;steps[Z_AXIS] &lt;= dropsegments) {</front>
<front id="plannerCPP-815">    block-&gt;millimeters = fabs(delta_mm[E_AXIS]);</front>
<front id="plannerCPP-816">  }</front>
<front id="plannerCPP-817">  else {</front>
<front id="plannerCPP-818">    block-&gt;millimeters = sqrt(</front>
<front id="plannerCPP-819">      #if ENABLED(COREXY)</front>
<front id="plannerCPP-820">        square(delta_mm[X_HEAD]) + square(delta_mm[Y_HEAD]) + square(delta_mm[Z_AXIS])</front>
<front id="plannerCPP-821">      #elif ENABLED(COREXZ)</front>
<front id="plannerCPP-822">        square(delta_mm[X_HEAD]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_HEAD])</front>
<front id="plannerCPP-823">      #else</front>
<front id="plannerCPP-824">        square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS])</front>
<front id="plannerCPP-825">      #endif</front>
<front id="plannerCPP-826">    );</front>
<front id="plannerCPP-827">  }</front>
<front id="plannerCPP-828">  float inverse_millimeters = 1.0 / block-&gt;millimeters;  // Inverse millimeters to remove multiple divides</front>
<front id="plannerCPP-829"></front>
<front id="plannerCPP-830">  // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.</front>
<front id="plannerCPP-831">  float inverse_second = feed_rate * inverse_millimeters;</front>
<front id="plannerCPP-832"></front>
<front id="plannerCPP-833">  int moves_queued = movesplanned();</front>
<front id="plannerCPP-834"></front>
<front id="plannerCPP-835">  // Slow down when the buffer starts to empty, rather than wait at the corner for a buffer refill</front>
<front id="plannerCPP-836">  #if ENABLED(OLD_SLOWDOWN) || ENABLED(SLOWDOWN)</front>
<front id="plannerCPP-837">    bool mq = moves_queued &gt; 1 && moves_queued &lt; BLOCK_BUFFER_SIZE / 2;</front>
<front id="plannerCPP-838">    #if ENABLED(OLD_SLOWDOWN)</front>
<front id="plannerCPP-839">      if (mq) feed_rate *= 2.0 * moves_queued / BLOCK_BUFFER_SIZE;</front>
<front id="plannerCPP-840">    #endif</front>
<front id="plannerCPP-841">    #if ENABLED(SLOWDOWN)</front>
<front id="plannerCPP-842">      //  segment time im micro seconds</front>
<front id="plannerCPP-843">      unsigned long segment_time = lround(1000000.0/inverse_second);</front>
<front id="plannerCPP-844">      if (mq) {</front>
<front id="plannerCPP-845">        if (segment_time &lt; minsegmenttime) {</front>
<front id="plannerCPP-846">          // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.</front>
<front id="plannerCPP-847">          inverse_second = 1000000.0 / (segment_time + lround(2 * (minsegmenttime - segment_time) / moves_queued));</front>
<front id="plannerCPP-848">          #ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-849">            segment_time = lround(1000000.0 / inverse_second);</front>
<front id="plannerCPP-850">          #endif</front>
<front id="plannerCPP-851">        }</front>
<front id="plannerCPP-852">      }</front>
<front id="plannerCPP-853">    #endif</front>
<front id="plannerCPP-854">  #endif</front>
<front id="plannerCPP-855"></front>
<front id="plannerCPP-856">  block-&gt;nominal_speed = block-&gt;millimeters * inverse_second; // (mm/sec) Always &gt; 0</front>
<front id="plannerCPP-857">  block-&gt;nominal_rate = ceil(block-&gt;step_event_count * inverse_second); // (step/sec) Always &gt; 0</front>
<front id="plannerCPP-858"></front>
<front id="plannerCPP-859">  #if ENABLED(FILAMENT_SENSOR)</front>
<front id="plannerCPP-860">    //FMM update ring buffer used for delay with filament measurements</front>
<front id="plannerCPP-861"></front>
<front id="plannerCPP-862">    if (extruder == FILAMENT_SENSOR_EXTRUDER_NUM && delay_index2 &gt; -1) {  //only for extruder with filament sensor and if ring buffer is initialized</front>
<front id="plannerCPP-863"></front>
<front id="plannerCPP-864">      const int MMD = MAX_MEASUREMENT_DELAY + 1, MMD10 = MMD * 10;</front>
<front id="plannerCPP-865"></front>
<front id="plannerCPP-866">      delay_dist += delta_mm[E_AXIS];  // increment counter with next move in e axis</front>
<front id="plannerCPP-867">      while (delay_dist &gt;= MMD10) delay_dist -= MMD10; // loop around the buffer</front>
<front id="plannerCPP-868">      while (delay_dist &lt; 0) delay_dist += MMD10;</front>
<front id="plannerCPP-869"></front>
<front id="plannerCPP-870">      delay_index1 = delay_dist / 10.0;  // calculate index</front>
<front id="plannerCPP-871">      delay_index1 = constrain(delay_index1, 0, MAX_MEASUREMENT_DELAY); // (already constrained above)</front>
<front id="plannerCPP-872"></front>
<front id="plannerCPP-873">      if (delay_index1 != delay_index2) { // moved index</front>
<front id="plannerCPP-874">        meas_sample = widthFil_to_size_ratio() - 100;  // Subtract 100 to reduce magnitude - to store in a signed char</front>
<front id="plannerCPP-875">        while (delay_index1 != delay_index2) {</front>
<front id="plannerCPP-876">          // Increment and loop around buffer</front>
<front id="plannerCPP-877">          if (++delay_index2 &gt;= MMD) delay_index2 -= MMD;</front>
<front id="plannerCPP-878">          delay_index2 = constrain(delay_index2, 0, MAX_MEASUREMENT_DELAY);</front>
<front id="plannerCPP-879">          measurement_delay[delay_index2] = meas_sample;</front>
<front id="plannerCPP-880">        }</front>
<front id="plannerCPP-881">      }</front>
<front id="plannerCPP-882">    }</front>
<front id="plannerCPP-883">  #endif</front>
<front id="plannerCPP-884"></front>
<front id="plannerCPP-885">  // Calculate and limit speed in mm/sec for each axis</front>
<front id="plannerCPP-886">  float current_speed[NUM_AXIS];</front>
<front id="plannerCPP-887">  float speed_factor = 1.0; //factor &lt;=1 do decrease speed</front>
<front id="plannerCPP-888">  for (int i = 0; i &lt; NUM_AXIS; i++) {</front>
<front id="plannerCPP-889">    current_speed[i] = delta_mm[i] * inverse_second;</front>
<front id="plannerCPP-890">    float cs = fabs(current_speed[i]), mf = max_feedrate[i];</front>
<front id="plannerCPP-891">    if (cs &gt; mf) speed_factor = min(speed_factor, mf / cs);</front>
<front id="plannerCPP-892">  }</front>
<front id="plannerCPP-893"></front>
<front id="plannerCPP-894">  // Max segement time in us.</front>
<front id="plannerCPP-895">  #ifdef XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-896"></front>
<front id="plannerCPP-897">    // Check and limit the xy direction change frequency</front>
<front id="plannerCPP-898">    unsigned char direction_change = block-&gt;direction_bits ^ old_direction_bits;</front>
<front id="plannerCPP-899">    old_direction_bits = block-&gt;direction_bits;</front>
<front id="plannerCPP-900">    segment_time = lround((float)segment_time / speed_factor);</front>
<front id="plannerCPP-901"></front>
<front id="plannerCPP-902">    long xs0 = axis_segment_time[X_AXIS][0],</front>
<front id="plannerCPP-903">         xs1 = axis_segment_time[X_AXIS][1],</front>
<front id="plannerCPP-904">         xs2 = axis_segment_time[X_AXIS][2],</front>
<front id="plannerCPP-905">         ys0 = axis_segment_time[Y_AXIS][0],</front>
<front id="plannerCPP-906">         ys1 = axis_segment_time[Y_AXIS][1],</front>
<front id="plannerCPP-907">         ys2 = axis_segment_time[Y_AXIS][2];</front>
<front id="plannerCPP-908"></front>
<front id="plannerCPP-909">    if ((direction_change & BIT(X_AXIS)) != 0) {</front>
<front id="plannerCPP-910">      xs2 = axis_segment_time[X_AXIS][2] = xs1;</front>
<front id="plannerCPP-911">      xs1 = axis_segment_time[X_AXIS][1] = xs0;</front>
<front id="plannerCPP-912">      xs0 = 0;</front>
<front id="plannerCPP-913">    }</front>
<front id="plannerCPP-914">    xs0 = axis_segment_time[X_AXIS][0] = xs0 + segment_time;</front>
<front id="plannerCPP-915"></front>
<front id="plannerCPP-916">    if ((direction_change & BIT(Y_AXIS)) != 0) {</front>
<front id="plannerCPP-917">      ys2 = axis_segment_time[Y_AXIS][2] = axis_segment_time[Y_AXIS][1];</front>
<front id="plannerCPP-918">      ys1 = axis_segment_time[Y_AXIS][1] = axis_segment_time[Y_AXIS][0];</front>
<front id="plannerCPP-919">      ys0 = 0;</front>
<front id="plannerCPP-920">    }</front>
<front id="plannerCPP-921">    ys0 = axis_segment_time[Y_AXIS][0] = ys0 + segment_time;</front>
<front id="plannerCPP-922"></front>
<front id="plannerCPP-923">    long max_x_segment_time = max(xs0, max(xs1, xs2)),</front>
<front id="plannerCPP-924">         max_y_segment_time = max(ys0, max(ys1, ys2)),</front>
<front id="plannerCPP-925">         min_xy_segment_time = min(max_x_segment_time, max_y_segment_time);</front>
<front id="plannerCPP-926">    if (min_xy_segment_time &lt; MAX_FREQ_TIME) {</front>
<front id="plannerCPP-927">      float low_sf = speed_factor * min_xy_segment_time / MAX_FREQ_TIME;</front>
<front id="plannerCPP-928">      speed_factor = min(speed_factor, low_sf);</front>
<front id="plannerCPP-929">    }</front>
<front id="plannerCPP-930">  #endif // XY_FREQUENCY_LIMIT</front>
<front id="plannerCPP-931"></front>
<front id="plannerCPP-932">  // Correct the speed</front>
<front id="plannerCPP-933">  if (speed_factor &lt; 1.0) {</front>
<front id="plannerCPP-934">    for (unsigned char i = 0; i &lt; NUM_AXIS; i++) current_speed[i] *= speed_factor;</front>
<front id="plannerCPP-935">    block-&gt;nominal_speed *= speed_factor;</front>
<front id="plannerCPP-936">    block-&gt;nominal_rate *= speed_factor;</front>
<front id="plannerCPP-937">  }</front>
<front id="plannerCPP-938"></front>
<front id="plannerCPP-939">  // Compute and limit the acceleration rate for the trapezoid generator.</front>
<front id="plannerCPP-940">  float steps_per_mm = block-&gt;step_event_count / block-&gt;millimeters;</front>
<front id="plannerCPP-941">  long bsx = block-&gt;steps[X_AXIS], bsy = block-&gt;steps[Y_AXIS], bsz = block-&gt;steps[Z_AXIS], bse = block-&gt;steps[E_AXIS];</front>
<front id="plannerCPP-942">  if (bsx == 0 && bsy == 0 && bsz == 0) {</front>
<front id="plannerCPP-943">    block-&gt;acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-944">  }</front>
<front id="plannerCPP-945">  else if (bse == 0) {</front>
<front id="plannerCPP-946">    block-&gt;acceleration_st = ceil(travel_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-947">  }</front>
<front id="plannerCPP-948">  else {</front>
<front id="plannerCPP-949">    block-&gt;acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</front>
<front id="plannerCPP-950">  }</front>
<front id="plannerCPP-951">  // Limit acceleration per axis</front>
<front id="plannerCPP-952">  unsigned long acc_st = block-&gt;acceleration_st,</front>
<front id="plannerCPP-953">                xsteps = axis_steps_per_sqr_second[X_AXIS],</front>
<front id="plannerCPP-954">                ysteps = axis_steps_per_sqr_second[Y_AXIS],</front>
<front id="plannerCPP-955">                zsteps = axis_steps_per_sqr_second[Z_AXIS],</front>
<front id="plannerCPP-956">                esteps = axis_steps_per_sqr_second[E_AXIS];</front>
<front id="plannerCPP-957">  if ((float)acc_st * bsx / block-&gt;step_event_count &gt; xsteps) acc_st = xsteps;</front>
<front id="plannerCPP-958">  if ((float)acc_st * bsy / block-&gt;step_event_count &gt; ysteps) acc_st = ysteps;</front>
<front id="plannerCPP-959">  if ((float)acc_st * bsz / block-&gt;step_event_count &gt; zsteps) acc_st = zsteps;</front>
<front id="plannerCPP-960">  if ((float)acc_st * bse / block-&gt;step_event_count &gt; esteps) acc_st = esteps;</front>
<front id="plannerCPP-961"></front>
<front id="plannerCPP-962">  block-&gt;acceleration_st = acc_st;</front>
<front id="plannerCPP-963">  block-&gt;acceleration = acc_st / steps_per_mm;</front>
<front id="plannerCPP-964">  block-&gt;acceleration_rate = (long)(acc_st * 16777216.0 / (F_CPU / 8.0));</front>
<front id="plannerCPP-965"></front>
<front id="plannerCPP-966">  #if 0  // Use old jerk for now</front>
<front id="plannerCPP-967">    // Compute path unit vector</front>
<front id="plannerCPP-968">    double unit_vec[3];</front>
<front id="plannerCPP-969"></front>
<front id="plannerCPP-970">    unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-971">    unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-972">    unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;</front>
<front id="plannerCPP-973"></front>
<front id="plannerCPP-974">    // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.</front>
<front id="plannerCPP-975">    // Let a circle be tangent to both previous and current path line segments, where the junction</front>
<front id="plannerCPP-976">    // deviation is defined as the distance from the junction to the closest edge of the circle,</front>
<front id="plannerCPP-977">    // colinear with the circle center. The circular segment joining the two paths represents the</front>
<front id="plannerCPP-978">    // path of centripetal acceleration. Solve for max velocity based on max acceleration about the</front>
<front id="plannerCPP-979">    // radius of the circle, defined indirectly by junction deviation. This may be also viewed as</front>
<front id="plannerCPP-980">    // path width or max_jerk in the previous grbl version. This approach does not actually deviate</front>
<front id="plannerCPP-981">    // from path, but used as a robust way to compute cornering speeds, as it takes into account the</front>
<front id="plannerCPP-982">    // nonlinearities of both the junction angle and junction velocity.</front>
<front id="plannerCPP-983">    double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed</front>
<front id="plannerCPP-984"></front>
<front id="plannerCPP-985">    // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.</front>
<front id="plannerCPP-986">    if ((block_buffer_head != block_buffer_tail) && (previous_nominal_speed &gt; 0.0)) {</front>
<front id="plannerCPP-987">      // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)</front>
<front id="plannerCPP-988">      // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.</front>
<front id="plannerCPP-989">      double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]</front>
<front id="plannerCPP-990">        - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]</front>
<front id="plannerCPP-991">        - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;</front>
<front id="plannerCPP-992"></front>
<front id="plannerCPP-993">      // Skip and use default max junction speed for 0 degree acute junction.</front>
<front id="plannerCPP-994">      if (cos_theta &lt; 0.95) {</front>
<front id="plannerCPP-995">        vmax_junction = min(previous_nominal_speed,block-&gt;nominal_speed);</front>
<front id="plannerCPP-996">        // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.</front>
<front id="plannerCPP-997">        if (cos_theta &gt; -0.95) {</front>
<front id="plannerCPP-998">          // Compute maximum junction velocity based on maximum acceleration and junction deviation</front>
<front id="plannerCPP-999">          double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.</front>
<front id="plannerCPP-1000">          vmax_junction = min(vmax_junction,</front>
<front id="plannerCPP-1001">          sqrt(block-&gt;acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );</front>
<front id="plannerCPP-1002">        }</front>
<front id="plannerCPP-1003">      }</front>
<front id="plannerCPP-1004">    }</front>
<front id="plannerCPP-1005">  #endif</front>
<front id="plannerCPP-1006"></front>
<front id="plannerCPP-1007">  // Start with a safe speed</front>
<front id="plannerCPP-1008">  float vmax_junction = max_xy_jerk / 2;</front>
<front id="plannerCPP-1009">  float vmax_junction_factor = 1.0;</front>
<front id="plannerCPP-1010">  float mz2 = max_z_jerk / 2, me2 = max_e_jerk / 2;</front>
<front id="plannerCPP-1011">  float csz = current_speed[Z_AXIS], cse = current_speed[E_AXIS];</front>
<front id="plannerCPP-1012">  if (fabs(csz) &gt; mz2) vmax_junction = min(vmax_junction, mz2);</front>
<front id="plannerCPP-1013">  if (fabs(cse) &gt; me2) vmax_junction = min(vmax_junction, me2);</front>
<front id="plannerCPP-1014">  vmax_junction = min(vmax_junction, block-&gt;nominal_speed);</front>
<front id="plannerCPP-1015">  float safe_speed = vmax_junction;</front>
<front id="plannerCPP-1016"></front>
<front id="plannerCPP-1017">  if ((moves_queued &gt; 1) && (previous_nominal_speed &gt; 0.0001)) {</front>
<front id="plannerCPP-1018">    float dx = current_speed[X_AXIS] - previous_speed[X_AXIS],</front>
<front id="plannerCPP-1019">          dy = current_speed[Y_AXIS] - previous_speed[Y_AXIS],</front>
<front id="plannerCPP-1020">          dz = fabs(csz - previous_speed[Z_AXIS]),</front>
<front id="plannerCPP-1021">          de = fabs(cse - previous_speed[E_AXIS]),</front>
<front id="plannerCPP-1022">          jerk = sqrt(dx * dx + dy * dy);</front>
<front id="plannerCPP-1023"></front>
<front id="plannerCPP-1024">    //    if ((fabs(previous_speed[X_AXIS]) &gt; 0.0001) || (fabs(previous_speed[Y_AXIS]) &gt; 0.0001)) {</front>
<front id="plannerCPP-1025">    vmax_junction = block-&gt;nominal_speed;</front>
<front id="plannerCPP-1026">    //    }</front>
<front id="plannerCPP-1027">    if (jerk &gt; max_xy_jerk) vmax_junction_factor = max_xy_jerk / jerk;</front>
<front id="plannerCPP-1028">    if (dz &gt; max_z_jerk) vmax_junction_factor = min(vmax_junction_factor, max_z_jerk / dz);</front>
<front id="plannerCPP-1029">    if (de &gt; max_e_jerk) vmax_junction_factor = min(vmax_junction_factor, max_e_jerk / de);</front>
<front id="plannerCPP-1030"></front>
<front id="plannerCPP-1031">    vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed</front>
<front id="plannerCPP-1032">  }</front>
<front id="plannerCPP-1033">  block-&gt;max_entry_speed = vmax_junction;</front>
<front id="plannerCPP-1034"></front>
<front id="plannerCPP-1035">  // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.</front>
<front id="plannerCPP-1036">  double v_allowable = max_allowable_speed(-block-&gt;acceleration, MINIMUM_PLANNER_SPEED, block-&gt;millimeters);</front>
<front id="plannerCPP-1037">  block-&gt;entry_speed = min(vmax_junction, v_allowable);</front>
<front id="plannerCPP-1038"></front>
<front id="plannerCPP-1039">  // Initialize planner efficiency flags</front>
<front id="plannerCPP-1040">  // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.</front>
<front id="plannerCPP-1041">  // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then</front>
<front id="plannerCPP-1042">  // the current block and next block junction speeds are guaranteed to always be at their maximum</front>
<front id="plannerCPP-1043">  // junction speeds in deceleration and acceleration, respectively. This is due to how the current</front>
<front id="plannerCPP-1044">  // block nominal speed limits both the current and next maximum junction speeds. Hence, in both</front>
<front id="plannerCPP-1045">  // the reverse and forward planners, the corresponding block junction speed will always be at the</front>
<front id="plannerCPP-1046">  // the maximum junction speed and may always be ignored for any speed reduction checks.</front>
<front id="plannerCPP-1047">  block-&gt;nominal_length_flag = (block-&gt;nominal_speed &lt;= v_allowable);</front>
<front id="plannerCPP-1048">  block-&gt;recalculate_flag = true; // Always calculate trapezoid for new block</front>
<front id="plannerCPP-1049"></front>
<front id="plannerCPP-1050">  // Update previous path unit_vector and nominal speed</front>
<front id="plannerCPP-1051">  for (int i = 0; i &lt; NUM_AXIS; i++) previous_speed[i] = current_speed[i];</front>
<front id="plannerCPP-1052">  previous_nominal_speed = block-&gt;nominal_speed;</front>
<front id="plannerCPP-1053"></front>
<front id="plannerCPP-1054">  #if ENABLED(ADVANCE)</front>
<front id="plannerCPP-1055">    // Calculate advance rate</front>
<front id="plannerCPP-1056">    if (!bse || (!bsx && !bsy && !bsz)) {</front>
<front id="plannerCPP-1057">      block-&gt;advance_rate = 0;</front>
<front id="plannerCPP-1058">      block-&gt;advance = 0;</front>
<front id="plannerCPP-1059">    }</front>
<front id="plannerCPP-1060">    else {</front>
<front id="plannerCPP-1061">      long acc_dist = estimate_acceleration_distance(0, block-&gt;nominal_rate, block-&gt;acceleration_st);</front>
<front id="plannerCPP-1062">      float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * (cse * cse * EXTRUSION_AREA * EXTRUSION_AREA) * 256;</front>
<front id="plannerCPP-1063">      block-&gt;advance = advance;</front>
<front id="plannerCPP-1064">      block-&gt;advance_rate = acc_dist ? advance / (float)acc_dist : 0;</front>
<front id="plannerCPP-1065">    }</front>
<front id="plannerCPP-1066">    /*</front>
<front id="plannerCPP-1067">      SERIAL_ECHO_START;</front>
<front id="plannerCPP-1068">     SERIAL_ECHOPGM("advance :");</front>
<front id="plannerCPP-1069">     SERIAL_ECHO(block-&gt;advance/256.0);</front>
<front id="plannerCPP-1070">     SERIAL_ECHOPGM("advance rate :");</front>
<front id="plannerCPP-1071">     SERIAL_ECHOLN(block-&gt;advance_rate/256.0);</front>
<front id="plannerCPP-1072">     */</front>
<front id="plannerCPP-1073">  #endif // ADVANCE</front>
<front id="plannerCPP-1074"></front>
<front id="plannerCPP-1075">  calculate_trapezoid_for_block(block, block-&gt;entry_speed / block-&gt;nominal_speed, safe_speed / block-&gt;nominal_speed);</front>
<front id="plannerCPP-1076"></front>
<front id="plannerCPP-1077">  // Move buffer head</front>
<front id="plannerCPP-1078">  block_buffer_head = next_buffer_head;</front>
<front id="plannerCPP-1079"></front>
<front id="plannerCPP-1080">  // Update position</front>
<front id="plannerCPP-1081">  for (int i = 0; i &lt; NUM_AXIS; i++) position[i] = target[i];</front>
<front id="plannerCPP-1082"></front>
<front id="plannerCPP-1083">  planner_recalculate();</front>
<front id="plannerCPP-1084"></front>
<front id="plannerCPP-1085">  st_wake_up();</front>
<front id="plannerCPP-1086"></front>
<front id="plannerCPP-1087">} // plan_buffer_line()</front>
<front id="plannerCPP-1088"></front>
<front id="plannerCPP-1089">#if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(DELTA)</front>
<front id="plannerCPP-1090">  vector_3 plan_get_position() {</front>
<front id="plannerCPP-1091">    vector_3 position = vector_3(st_get_position_mm(X_AXIS), st_get_position_mm(Y_AXIS), st_get_position_mm(Z_AXIS));</front>
<front id="plannerCPP-1092"></front>
<front id="plannerCPP-1093">    //position.debug("in plan_get position");</front>
<front id="plannerCPP-1094">    //plan_bed_level_matrix.debug("in plan_get_position");</front>
<front id="plannerCPP-1095">    matrix_3x3 inverse = matrix_3x3::transpose(plan_bed_level_matrix);</front>
<front id="plannerCPP-1096">    //inverse.debug("in plan_get inverse");</front>
<front id="plannerCPP-1097">    position.apply_rotation(inverse);</front>
<front id="plannerCPP-1098">    //position.debug("after rotation");</front>
<front id="plannerCPP-1099"></front>
<front id="plannerCPP-1100">    return position;</front>
<front id="plannerCPP-1101">  }</front>
<front id="plannerCPP-1102">#endif // AUTO_BED_LEVELING_FEATURE && !DELTA</front>
<front id="plannerCPP-1103"></front>
<front id="plannerCPP-1104">#if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-1105">  void plan_set_position(float x, float y, float z, const float &e)</front>
<front id="plannerCPP-1106">#else</front>
<front id="plannerCPP-1107">  void plan_set_position(const float &x, const float &y, const float &z, const float &e)</front>
<front id="plannerCPP-1108">#endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING</front>
<front id="plannerCPP-1109">  {</front>
<front id="plannerCPP-1110">    #if ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerCPP-1111">      if (mbl.active) z += mbl.get_z(x, y);</front>
<front id="plannerCPP-1112">    #elif ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerCPP-1113">      apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</front>
<front id="plannerCPP-1114">    #endif</front>
<front id="plannerCPP-1115"></front>
<front id="plannerCPP-1116">    float nx = position[X_AXIS] = lround(x * axis_steps_per_unit[X_AXIS]),</front>
<front id="plannerCPP-1117">          ny = position[Y_AXIS] = lround(y * axis_steps_per_unit[Y_AXIS]),</front>
<front id="plannerCPP-1118">          nz = position[Z_AXIS] = lround(z * axis_steps_per_unit[Z_AXIS]),</front>
<front id="plannerCPP-1119">          ne = position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-1120">    st_set_position(nx, ny, nz, ne);</front>
<front id="plannerCPP-1121">    previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.</front>
<front id="plannerCPP-1122"></front>
<front id="plannerCPP-1123">    for (int i=0; i&lt;NUM_AXIS; i++) previous_speed[i] = 0.0;</front>
<front id="plannerCPP-1124">  }</front>
<front id="plannerCPP-1125"></front>
<front id="plannerCPP-1126">void plan_set_e_position(const float &e) {</front>
<front id="plannerCPP-1127">  position[E_AXIS] = lround(e * axis_steps_per_unit[E_AXIS]);</front>
<front id="plannerCPP-1128">  st_set_e_position(position[E_AXIS]);</front>
<front id="plannerCPP-1129">}</front>
<front id="plannerCPP-1130"></front>
<front id="plannerCPP-1131">// Calculate the steps/s^2 acceleration rates, based on the mm/s^s</front>
<front id="plannerCPP-1132">void reset_acceleration_rates() {</front>
<front id="plannerCPP-1133">  for (int i = 0; i &lt; NUM_AXIS; i++)</front>
<front id="plannerCPP-1134">    axis_steps_per_sqr_second[i] = max_acceleration_units_per_sq_second[i] * axis_steps_per_unit[i];</front>
<front id="plannerCPP-1135">}</front>
 </pre>
<h1 id="plannerHtitle" >planner.h</h1>
<pre id="plannerH"  class="prettyprint linenums"><front id="plannerH-1">/*</front>
<front id="plannerH-2">  planner.h - buffers movement commands and manages the acceleration profile plan</front>
<front id="plannerH-3">  Part of Grbl</front>
<front id="plannerH-4"></front>
<front id="plannerH-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="plannerH-6"></front>
<front id="plannerH-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="plannerH-8">  it under the terms of the GNU General Public License as published by</front>
<front id="plannerH-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="plannerH-10">  (at your option) any later version.</front>
<front id="plannerH-11"></front>
<front id="plannerH-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="plannerH-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="plannerH-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="plannerH-15">  GNU General Public License for more details.</front>
<front id="plannerH-16"></front>
<front id="plannerH-17">  You should have received a copy of the GNU General Public License</front>
<front id="plannerH-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="plannerH-19">*/</front>
<front id="plannerH-20"></front>
<front id="plannerH-21">// This module is to be considered a sub-module of stepper.c. Please don't include </front>
<front id="plannerH-22">// this file from any other module.</front>
<front id="plannerH-23"></front>
<front id="plannerH-24">#ifndef PLANNER_H</front>
<front id="plannerH-25">#define PLANNER_H</front>
<front id="plannerH-26"></front>
<front id="plannerH-27">#include "Marlin.h"</front>
<front id="plannerH-28"></front>
<front id="plannerH-29">// This struct is used when buffering the setup for each linear movement "nominal" values are as specified in </front>
<front id="plannerH-30">// the source g-code and may never actually be reached if acceleration management is active.</front>
<front id="plannerH-31">typedef struct {</front>
<front id="plannerH-32">  // Fields used by the bresenham algorithm for tracing the line</front>
<front id="plannerH-33">  long steps[NUM_AXIS];                     // Step count along each axis</front>
<front id="plannerH-34">  unsigned long step_event_count;           // The number of step events required to complete this block</front>
<front id="plannerH-35">  long accelerate_until;                    // The index of the step event on which to stop acceleration</front>
<front id="plannerH-36">  long decelerate_after;                    // The index of the step event on which to start decelerating</front>
<front id="plannerH-37">  long acceleration_rate;                   // The acceleration rate used for acceleration calculation</front>
<front id="plannerH-38">  unsigned char direction_bits;             // The direction bit set for this block (refers to *_DIRECTION_BIT in config.h)</front>
<front id="plannerH-39">  unsigned char active_extruder;            // Selects the active extruder</front>
<front id="plannerH-40">  #if ENABLED(ADVANCE)</front>
<front id="plannerH-41">    long advance_rate;</front>
<front id="plannerH-42">    volatile long initial_advance;</front>
<front id="plannerH-43">    volatile long final_advance;</front>
<front id="plannerH-44">    float advance;</front>
<front id="plannerH-45">  #endif</front>
<front id="plannerH-46"></front>
<front id="plannerH-47">  // Fields used by the motion planner to manage acceleration</front>
<front id="plannerH-48">  // float speed_x, speed_y, speed_z, speed_e;          // Nominal mm/sec for each axis</front>
<front id="plannerH-49">  float nominal_speed;                               // The nominal speed for this block in mm/sec </front>
<front id="plannerH-50">  float entry_speed;                                 // Entry speed at previous-current junction in mm/sec</front>
<front id="plannerH-51">  float max_entry_speed;                             // Maximum allowable junction entry speed in mm/sec</front>
<front id="plannerH-52">  float millimeters;                                 // The total travel of this block in mm</front>
<front id="plannerH-53">  float acceleration;                                // acceleration mm/sec^2</front>
<front id="plannerH-54">  unsigned char recalculate_flag;                    // Planner flag to recalculate trapezoids on entry junction</front>
<front id="plannerH-55">  unsigned char nominal_length_flag;                 // Planner flag for nominal speed always reached</front>
<front id="plannerH-56"></front>
<front id="plannerH-57">  // Settings for the trapezoid generator</front>
<front id="plannerH-58">  unsigned long nominal_rate;                        // The nominal step rate for this block in step_events/sec </front>
<front id="plannerH-59">  unsigned long initial_rate;                        // The jerk-adjusted step rate at start of block  </front>
<front id="plannerH-60">  unsigned long final_rate;                          // The minimal rate at exit</front>
<front id="plannerH-61">  unsigned long acceleration_st;                     // acceleration steps/sec^2</front>
<front id="plannerH-62">  unsigned long fan_speed;</front>
<front id="plannerH-63">  #if ENABLED(BARICUDA)</front>
<front id="plannerH-64">    unsigned long valve_pressure;</front>
<front id="plannerH-65">    unsigned long e_to_p_pressure;</front>
<front id="plannerH-66">  #endif</front>
<front id="plannerH-67">  volatile char busy;</front>
<front id="plannerH-68">} block_t;</front>
<front id="plannerH-69"></front>
<front id="plannerH-70">#define BLOCK_MOD(n) ((n)&(BLOCK_BUFFER_SIZE-1))</front>
<front id="plannerH-71"></front>
<front id="plannerH-72">// Initialize the motion plan subsystem      </front>
<front id="plannerH-73">void plan_init();</front>
<front id="plannerH-74"></front>
<front id="plannerH-75">void check_axes_activity();</front>
<front id="plannerH-76"></front>
<front id="plannerH-77">// Get the number of buffered moves</front>
<front id="plannerH-78">extern volatile unsigned char block_buffer_head;</front>
<front id="plannerH-79">extern volatile unsigned char block_buffer_tail;</front>
<front id="plannerH-80">FORCE_INLINE uint8_t movesplanned() { return BLOCK_MOD(block_buffer_head - block_buffer_tail + BLOCK_BUFFER_SIZE); }</front>
<front id="plannerH-81"></front>
<front id="plannerH-82">#if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)</front>
<front id="plannerH-83"></front>
<front id="plannerH-84">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="plannerH-85">    #include "vector_3.h"</front>
<front id="plannerH-86"></front>
<front id="plannerH-87">    // Transform required to compensate for bed level</front>
<front id="plannerH-88">    extern matrix_3x3 plan_bed_level_matrix;</front>
<front id="plannerH-89"></front>
<front id="plannerH-90">    /**</front>
<front id="plannerH-91">     * Get the position applying the bed level matrix</front>
<front id="plannerH-92">     */</front>
<front id="plannerH-93">    vector_3 plan_get_position();</front>
<front id="plannerH-94">  #endif  // AUTO_BED_LEVELING_FEATURE</front>
<front id="plannerH-95"></front>
<front id="plannerH-96">  /**</front>
<front id="plannerH-97">   * Add a new linear movement to the buffer. x, y, z are the signed, absolute target position in</front>
<front id="plannerH-98">   * millimeters. Feed rate specifies the (target) speed of the motion.</front>
<front id="plannerH-99">   */</front>
<front id="plannerH-100">  void plan_buffer_line(float x, float y, float z, const float &e, float feed_rate, const uint8_t extruder);</front>
<front id="plannerH-101"></front>
<front id="plannerH-102">  /**</front>
<front id="plannerH-103">   * Set the planner positions. Used for G92 instructions.</front>
<front id="plannerH-104">   * Multiplies by axis_steps_per_unit[] to set stepper positions.</front>
<front id="plannerH-105">   * Clears previous speed values.</front>
<front id="plannerH-106">   */</front>
<front id="plannerH-107">  void plan_set_position(float x, float y, float z, const float &e);</front>
<front id="plannerH-108"></front>
<front id="plannerH-109">#else</front>
<front id="plannerH-110"></front>
<front id="plannerH-111">  void plan_buffer_line(const float &x, const float &y, const float &z, const float &e, float feed_rate, const uint8_t extruder);</front>
<front id="plannerH-112">  void plan_set_position(const float &x, const float &y, const float &z, const float &e);</front>
<front id="plannerH-113"></front>
<front id="plannerH-114">#endif // AUTO_BED_LEVELING_FEATURE || MESH_BED_LEVELING</front>
<front id="plannerH-115"></front>
<front id="plannerH-116">void plan_set_e_position(const float &e);</front>
<front id="plannerH-117"></front>
<front id="plannerH-118">//===========================================================================</front>
<front id="plannerH-119">//============================= public variables ============================</front>
<front id="plannerH-120">//===========================================================================</front>
<front id="plannerH-121"></front>
<front id="plannerH-122">extern millis_t minsegmenttime;</front>
<front id="plannerH-123">extern float max_feedrate[NUM_AXIS]; // Max speeds in mm per minute</front>
<front id="plannerH-124">extern float axis_steps_per_unit[NUM_AXIS];</front>
<front id="plannerH-125">extern unsigned long max_acceleration_units_per_sq_second[NUM_AXIS]; // Use M201 to override by software</front>
<front id="plannerH-126">extern float minimumfeedrate;</front>
<front id="plannerH-127">extern float acceleration;         // Normal acceleration mm/s^2  DEFAULT ACCELERATION for all printing moves. M204 SXXXX</front>
<front id="plannerH-128">extern float retract_acceleration; // Retract acceleration mm/s^2 filament pull-back and push-forward while standing still in the other axes M204 TXXXX</front>
<front id="plannerH-129">extern float travel_acceleration;  // Travel acceleration mm/s^2  DEFAULT ACCELERATION for all NON printing moves. M204 MXXXX</front>
<front id="plannerH-130">extern float max_xy_jerk;          // The largest speed change requiring no acceleration</front>
<front id="plannerH-131">extern float max_z_jerk;</front>
<front id="plannerH-132">extern float max_e_jerk;</front>
<front id="plannerH-133">extern float mintravelfeedrate;</front>
<front id="plannerH-134">extern unsigned long axis_steps_per_sqr_second[NUM_AXIS];</front>
<front id="plannerH-135"></front>
<front id="plannerH-136">#if ENABLED(AUTOTEMP)</front>
<front id="plannerH-137">  extern bool autotemp_enabled;</front>
<front id="plannerH-138">  extern float autotemp_max;</front>
<front id="plannerH-139">  extern float autotemp_min;</front>
<front id="plannerH-140">  extern float autotemp_factor;</front>
<front id="plannerH-141">#endif</front>
<front id="plannerH-142"></front>
<front id="plannerH-143">extern block_t block_buffer[BLOCK_BUFFER_SIZE];            // A ring buffer for motion instructions</front>
<front id="plannerH-144">extern volatile unsigned char block_buffer_head;           // Index of the next block to be pushed</front>
<front id="plannerH-145">extern volatile unsigned char block_buffer_tail; </front>
<front id="plannerH-146"></front>
<front id="plannerH-147">// Returns true if the buffer has a queued block, false otherwise</front>
<front id="plannerH-148">FORCE_INLINE bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }</front>
<front id="plannerH-149"></front>
<front id="plannerH-150">// Called when the current block is no longer needed. Discards</front>
<front id="plannerH-151">// the block and makes the memory available for new blocks.</front>
<front id="plannerH-152">FORCE_INLINE void plan_discard_current_block() {</front>
<front id="plannerH-153">  if (blocks_queued())</front>
<front id="plannerH-154">    block_buffer_tail = BLOCK_MOD(block_buffer_tail + 1);</front>
<front id="plannerH-155">}</front>
<front id="plannerH-156"></front>
<front id="plannerH-157">// Gets the current block. Returns NULL if buffer empty</front>
<front id="plannerH-158">FORCE_INLINE block_t *plan_get_current_block() {</front>
<front id="plannerH-159">  if (blocks_queued()) {</front>
<front id="plannerH-160">    block_t *block = &block_buffer[block_buffer_tail];</front>
<front id="plannerH-161">    block-&gt;busy = true;</front>
<front id="plannerH-162">    return block;</front>
<front id="plannerH-163">  }</front>
<front id="plannerH-164">  else</front>
<front id="plannerH-165">    return NULL;</front>
<front id="plannerH-166">}</front>
<front id="plannerH-167"></front>
<front id="plannerH-168">void reset_acceleration_rates();</front>
<front id="plannerH-169"></front>
<front id="plannerH-170">#endif // PLANNER_H</front>
 </pre>
<h1 id="qr_solveCPPtitle" >qr_solve.cpp</h1>
<pre id="qr_solveCPP"  class="prettyprint linenums"><front id="qr_solveCPP-1">#include "qr_solve.h"</front>
<front id="qr_solveCPP-2"></front>
<front id="qr_solveCPP-3">#if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="qr_solveCPP-4"></front>
<front id="qr_solveCPP-5">#include &lt;stdlib.h&gt;</front>
<front id="qr_solveCPP-6">#include &lt;math.h&gt;</front>
<front id="qr_solveCPP-7"></front>
<front id="qr_solveCPP-8">//# include "r8lib.h"</front>
<front id="qr_solveCPP-9"></front>
<front id="qr_solveCPP-10">int i4_min ( int i1, int i2 )</front>
<front id="qr_solveCPP-11"></front>
<front id="qr_solveCPP-12">/******************************************************************************/</front>
<front id="qr_solveCPP-13">/*</front>
<front id="qr_solveCPP-14">  Purpose:</front>
<front id="qr_solveCPP-15"></front>
<front id="qr_solveCPP-16">    I4_MIN returns the smaller of two I4's.</front>
<front id="qr_solveCPP-17"></front>
<front id="qr_solveCPP-18">  Licensing:</front>
<front id="qr_solveCPP-19"></front>
<front id="qr_solveCPP-20">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-21"></front>
<front id="qr_solveCPP-22">  Modified:</front>
<front id="qr_solveCPP-23"></front>
<front id="qr_solveCPP-24">    29 August 2006</front>
<front id="qr_solveCPP-25"></front>
<front id="qr_solveCPP-26">  Author:</front>
<front id="qr_solveCPP-27"></front>
<front id="qr_solveCPP-28">    John Burkardt</front>
<front id="qr_solveCPP-29"></front>
<front id="qr_solveCPP-30">  Parameters:</front>
<front id="qr_solveCPP-31"></front>
<front id="qr_solveCPP-32">    Input, int I1, I2, two integers to be compared.</front>
<front id="qr_solveCPP-33"></front>
<front id="qr_solveCPP-34">    Output, int I4_MIN, the smaller of I1 and I2.</front>
<front id="qr_solveCPP-35">*/</front>
<front id="qr_solveCPP-36">{</front>
<front id="qr_solveCPP-37">  int value;</front>
<front id="qr_solveCPP-38"></front>
<front id="qr_solveCPP-39">  if ( i1 &lt; i2 )</front>
<front id="qr_solveCPP-40">  {</front>
<front id="qr_solveCPP-41">    value = i1;</front>
<front id="qr_solveCPP-42">  }</front>
<front id="qr_solveCPP-43">  else</front>
<front id="qr_solveCPP-44">  {</front>
<front id="qr_solveCPP-45">    value = i2;</front>
<front id="qr_solveCPP-46">  }</front>
<front id="qr_solveCPP-47">  return value;</front>
<front id="qr_solveCPP-48">}</front>
<front id="qr_solveCPP-49"></front>
<front id="qr_solveCPP-50">double r8_epsilon ( void )</front>
<front id="qr_solveCPP-51"></front>
<front id="qr_solveCPP-52">/******************************************************************************/</front>
<front id="qr_solveCPP-53">/*</front>
<front id="qr_solveCPP-54">  Purpose:</front>
<front id="qr_solveCPP-55"></front>
<front id="qr_solveCPP-56">    R8_EPSILON returns the R8 round off unit.</front>
<front id="qr_solveCPP-57"></front>
<front id="qr_solveCPP-58">  Discussion:</front>
<front id="qr_solveCPP-59"></front>
<front id="qr_solveCPP-60">    R8_EPSILON is a number R which is a power of 2 with the property that,</front>
<front id="qr_solveCPP-61">    to the precision of the computer's arithmetic,</front>
<front id="qr_solveCPP-62">      1 &lt; 1 + R</front>
<front id="qr_solveCPP-63">    but</front>
<front id="qr_solveCPP-64">      1 = ( 1 + R / 2 )</front>
<front id="qr_solveCPP-65"></front>
<front id="qr_solveCPP-66">  Licensing:</front>
<front id="qr_solveCPP-67"></front>
<front id="qr_solveCPP-68">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-69"></front>
<front id="qr_solveCPP-70">  Modified:</front>
<front id="qr_solveCPP-71"></front>
<front id="qr_solveCPP-72">    01 September 2012</front>
<front id="qr_solveCPP-73"></front>
<front id="qr_solveCPP-74">  Author:</front>
<front id="qr_solveCPP-75"></front>
<front id="qr_solveCPP-76">    John Burkardt</front>
<front id="qr_solveCPP-77"></front>
<front id="qr_solveCPP-78">  Parameters:</front>
<front id="qr_solveCPP-79"></front>
<front id="qr_solveCPP-80">    Output, double R8_EPSILON, the R8 round-off unit.</front>
<front id="qr_solveCPP-81">*/</front>
<front id="qr_solveCPP-82">{</front>
<front id="qr_solveCPP-83">  const double value = 2.220446049250313E-016;</front>
<front id="qr_solveCPP-84"></front>
<front id="qr_solveCPP-85">  return value;</front>
<front id="qr_solveCPP-86">}</front>
<front id="qr_solveCPP-87"></front>
<front id="qr_solveCPP-88">double r8_max ( double x, double y )</front>
<front id="qr_solveCPP-89"></front>
<front id="qr_solveCPP-90">/******************************************************************************/</front>
<front id="qr_solveCPP-91">/*</front>
<front id="qr_solveCPP-92">  Purpose:</front>
<front id="qr_solveCPP-93"></front>
<front id="qr_solveCPP-94">    R8_MAX returns the maximum of two R8's.</front>
<front id="qr_solveCPP-95"></front>
<front id="qr_solveCPP-96">  Licensing:</front>
<front id="qr_solveCPP-97"></front>
<front id="qr_solveCPP-98">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-99"></front>
<front id="qr_solveCPP-100">  Modified:</front>
<front id="qr_solveCPP-101"></front>
<front id="qr_solveCPP-102">    07 May 2006</front>
<front id="qr_solveCPP-103"></front>
<front id="qr_solveCPP-104">  Author:</front>
<front id="qr_solveCPP-105"></front>
<front id="qr_solveCPP-106">    John Burkardt</front>
<front id="qr_solveCPP-107"></front>
<front id="qr_solveCPP-108">  Parameters:</front>
<front id="qr_solveCPP-109"></front>
<front id="qr_solveCPP-110">    Input, double X, Y, the quantities to compare.</front>
<front id="qr_solveCPP-111"></front>
<front id="qr_solveCPP-112">    Output, double R8_MAX, the maximum of X and Y.</front>
<front id="qr_solveCPP-113">*/</front>
<front id="qr_solveCPP-114">{</front>
<front id="qr_solveCPP-115">  double value;</front>
<front id="qr_solveCPP-116"></front>
<front id="qr_solveCPP-117">  if ( y &lt; x )</front>
<front id="qr_solveCPP-118">  {</front>
<front id="qr_solveCPP-119">    value = x;</front>
<front id="qr_solveCPP-120">  }</front>
<front id="qr_solveCPP-121">  else</front>
<front id="qr_solveCPP-122">  {</front>
<front id="qr_solveCPP-123">    value = y;</front>
<front id="qr_solveCPP-124">  }</front>
<front id="qr_solveCPP-125">  return value;</front>
<front id="qr_solveCPP-126">}</front>
<front id="qr_solveCPP-127"></front>
<front id="qr_solveCPP-128">double r8_abs ( double x )</front>
<front id="qr_solveCPP-129"></front>
<front id="qr_solveCPP-130">/******************************************************************************/</front>
<front id="qr_solveCPP-131">/*</front>
<front id="qr_solveCPP-132">  Purpose:</front>
<front id="qr_solveCPP-133"></front>
<front id="qr_solveCPP-134">    R8_ABS returns the absolute value of an R8.</front>
<front id="qr_solveCPP-135"></front>
<front id="qr_solveCPP-136">  Licensing:</front>
<front id="qr_solveCPP-137"></front>
<front id="qr_solveCPP-138">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-139"></front>
<front id="qr_solveCPP-140">  Modified:</front>
<front id="qr_solveCPP-141"></front>
<front id="qr_solveCPP-142">    07 May 2006</front>
<front id="qr_solveCPP-143"></front>
<front id="qr_solveCPP-144">  Author:</front>
<front id="qr_solveCPP-145"></front>
<front id="qr_solveCPP-146">    John Burkardt</front>
<front id="qr_solveCPP-147"></front>
<front id="qr_solveCPP-148">  Parameters:</front>
<front id="qr_solveCPP-149"></front>
<front id="qr_solveCPP-150">    Input, double X, the quantity whose absolute value is desired.</front>
<front id="qr_solveCPP-151"></front>
<front id="qr_solveCPP-152">    Output, double R8_ABS, the absolute value of X.</front>
<front id="qr_solveCPP-153">*/</front>
<front id="qr_solveCPP-154">{</front>
<front id="qr_solveCPP-155">  double value;</front>
<front id="qr_solveCPP-156"></front>
<front id="qr_solveCPP-157">  if ( 0.0 &lt;= x )</front>
<front id="qr_solveCPP-158">  {</front>
<front id="qr_solveCPP-159">    value = + x;</front>
<front id="qr_solveCPP-160">  }</front>
<front id="qr_solveCPP-161">  else</front>
<front id="qr_solveCPP-162">  {</front>
<front id="qr_solveCPP-163">    value = - x;</front>
<front id="qr_solveCPP-164">  }</front>
<front id="qr_solveCPP-165">  return value;</front>
<front id="qr_solveCPP-166">}</front>
<front id="qr_solveCPP-167"></front>
<front id="qr_solveCPP-168">double r8_sign ( double x )</front>
<front id="qr_solveCPP-169"></front>
<front id="qr_solveCPP-170">/******************************************************************************/</front>
<front id="qr_solveCPP-171">/*</front>
<front id="qr_solveCPP-172">  Purpose:</front>
<front id="qr_solveCPP-173"></front>
<front id="qr_solveCPP-174">    R8_SIGN returns the sign of an R8.</front>
<front id="qr_solveCPP-175"></front>
<front id="qr_solveCPP-176">  Licensing:</front>
<front id="qr_solveCPP-177"></front>
<front id="qr_solveCPP-178">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-179"></front>
<front id="qr_solveCPP-180">  Modified:</front>
<front id="qr_solveCPP-181"></front>
<front id="qr_solveCPP-182">    08 May 2006</front>
<front id="qr_solveCPP-183"></front>
<front id="qr_solveCPP-184">  Author:</front>
<front id="qr_solveCPP-185"></front>
<front id="qr_solveCPP-186">    John Burkardt</front>
<front id="qr_solveCPP-187"></front>
<front id="qr_solveCPP-188">  Parameters:</front>
<front id="qr_solveCPP-189"></front>
<front id="qr_solveCPP-190">    Input, double X, the number whose sign is desired.</front>
<front id="qr_solveCPP-191"></front>
<front id="qr_solveCPP-192">    Output, double R8_SIGN, the sign of X.</front>
<front id="qr_solveCPP-193">*/</front>
<front id="qr_solveCPP-194">{</front>
<front id="qr_solveCPP-195">  double value;</front>
<front id="qr_solveCPP-196"></front>
<front id="qr_solveCPP-197">  if ( x &lt; 0.0 )</front>
<front id="qr_solveCPP-198">  {</front>
<front id="qr_solveCPP-199">    value = - 1.0;</front>
<front id="qr_solveCPP-200">  }</front>
<front id="qr_solveCPP-201">  else</front>
<front id="qr_solveCPP-202">  {</front>
<front id="qr_solveCPP-203">    value = + 1.0;</front>
<front id="qr_solveCPP-204">  }</front>
<front id="qr_solveCPP-205">  return value;</front>
<front id="qr_solveCPP-206">}</front>
<front id="qr_solveCPP-207"></front>
<front id="qr_solveCPP-208">double r8mat_amax ( int m, int n, double a[] )</front>
<front id="qr_solveCPP-209"></front>
<front id="qr_solveCPP-210">/******************************************************************************/</front>
<front id="qr_solveCPP-211">/*</front>
<front id="qr_solveCPP-212">  Purpose:</front>
<front id="qr_solveCPP-213"></front>
<front id="qr_solveCPP-214">    R8MAT_AMAX returns the maximum absolute value entry of an R8MAT.</front>
<front id="qr_solveCPP-215"></front>
<front id="qr_solveCPP-216">  Discussion:</front>
<front id="qr_solveCPP-217"></front>
<front id="qr_solveCPP-218">    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector</front>
<front id="qr_solveCPP-219">    in column-major order.</front>
<front id="qr_solveCPP-220"></front>
<front id="qr_solveCPP-221">  Licensing:</front>
<front id="qr_solveCPP-222"></front>
<front id="qr_solveCPP-223">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-224"></front>
<front id="qr_solveCPP-225">  Modified:</front>
<front id="qr_solveCPP-226"></front>
<front id="qr_solveCPP-227">    07 September 2012</front>
<front id="qr_solveCPP-228"></front>
<front id="qr_solveCPP-229">  Author:</front>
<front id="qr_solveCPP-230"></front>
<front id="qr_solveCPP-231">    John Burkardt</front>
<front id="qr_solveCPP-232"></front>
<front id="qr_solveCPP-233">  Parameters:</front>
<front id="qr_solveCPP-234"></front>
<front id="qr_solveCPP-235">    Input, int M, the number of rows in A.</front>
<front id="qr_solveCPP-236"></front>
<front id="qr_solveCPP-237">    Input, int N, the number of columns in A.</front>
<front id="qr_solveCPP-238"></front>
<front id="qr_solveCPP-239">    Input, double A[M*N], the M by N matrix.</front>
<front id="qr_solveCPP-240"></front>
<front id="qr_solveCPP-241">    Output, double R8MAT_AMAX, the maximum absolute value entry of A.</front>
<front id="qr_solveCPP-242">*/</front>
<front id="qr_solveCPP-243">{</front>
<front id="qr_solveCPP-244">  int i;</front>
<front id="qr_solveCPP-245">  int j;</front>
<front id="qr_solveCPP-246">  double value;</front>
<front id="qr_solveCPP-247"></front>
<front id="qr_solveCPP-248">  value = r8_abs ( a[0+0*m] );</front>
<front id="qr_solveCPP-249"></front>
<front id="qr_solveCPP-250">  for ( j = 0; j &lt; n; j++ )</front>
<front id="qr_solveCPP-251">  {</front>
<front id="qr_solveCPP-252">    for ( i = 0; i &lt; m; i++ )</front>
<front id="qr_solveCPP-253">    {</front>
<front id="qr_solveCPP-254">      if ( value &lt; r8_abs ( a[i+j*m] ) )</front>
<front id="qr_solveCPP-255">      {</front>
<front id="qr_solveCPP-256">        value = r8_abs ( a[i+j*m] );</front>
<front id="qr_solveCPP-257">      }</front>
<front id="qr_solveCPP-258">    }</front>
<front id="qr_solveCPP-259">  }</front>
<front id="qr_solveCPP-260">  return value;</front>
<front id="qr_solveCPP-261">}</front>
<front id="qr_solveCPP-262"></front>
<front id="qr_solveCPP-263">void r8mat_copy( double a2[], int m, int n, double a1[] )</front>
<front id="qr_solveCPP-264"></front>
<front id="qr_solveCPP-265">/******************************************************************************/</front>
<front id="qr_solveCPP-266">/*</front>
<front id="qr_solveCPP-267">  Purpose:</front>
<front id="qr_solveCPP-268"></front>
<front id="qr_solveCPP-269">    R8MAT_COPY_NEW copies one R8MAT to a "new" R8MAT.</front>
<front id="qr_solveCPP-270"></front>
<front id="qr_solveCPP-271">  Discussion:</front>
<front id="qr_solveCPP-272"></front>
<front id="qr_solveCPP-273">    An R8MAT is a doubly dimensioned array of R8 values, stored as a vector</front>
<front id="qr_solveCPP-274">    in column-major order.</front>
<front id="qr_solveCPP-275"></front>
<front id="qr_solveCPP-276">  Licensing:</front>
<front id="qr_solveCPP-277"></front>
<front id="qr_solveCPP-278">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-279"></front>
<front id="qr_solveCPP-280">  Modified:</front>
<front id="qr_solveCPP-281"></front>
<front id="qr_solveCPP-282">    26 July 2008</front>
<front id="qr_solveCPP-283"></front>
<front id="qr_solveCPP-284">  Author:</front>
<front id="qr_solveCPP-285"></front>
<front id="qr_solveCPP-286">    John Burkardt</front>
<front id="qr_solveCPP-287"></front>
<front id="qr_solveCPP-288">  Parameters:</front>
<front id="qr_solveCPP-289"></front>
<front id="qr_solveCPP-290">    Input, int M, N, the number of rows and columns.</front>
<front id="qr_solveCPP-291"></front>
<front id="qr_solveCPP-292">    Input, double A1[M*N], the matrix to be copied.</front>
<front id="qr_solveCPP-293"></front>
<front id="qr_solveCPP-294">    Output, double R8MAT_COPY_NEW[M*N], the copy of A1.</front>
<front id="qr_solveCPP-295">*/</front>
<front id="qr_solveCPP-296">{</front>
<front id="qr_solveCPP-297">  int i;</front>
<front id="qr_solveCPP-298">  int j;</front>
<front id="qr_solveCPP-299"></front>
<front id="qr_solveCPP-300">  for ( j = 0; j &lt; n; j++ )</front>
<front id="qr_solveCPP-301">  {</front>
<front id="qr_solveCPP-302">    for ( i = 0; i &lt; m; i++ )</front>
<front id="qr_solveCPP-303">    {</front>
<front id="qr_solveCPP-304">      a2[i+j*m] = a1[i+j*m];</front>
<front id="qr_solveCPP-305">    }</front>
<front id="qr_solveCPP-306">  }</front>
<front id="qr_solveCPP-307">}</front>
<front id="qr_solveCPP-308"></front>
<front id="qr_solveCPP-309">/******************************************************************************/</front>
<front id="qr_solveCPP-310"></front>
<front id="qr_solveCPP-311">void daxpy ( int n, double da, double dx[], int incx, double dy[], int incy )</front>
<front id="qr_solveCPP-312"></front>
<front id="qr_solveCPP-313">/******************************************************************************/</front>
<front id="qr_solveCPP-314">/*</front>
<front id="qr_solveCPP-315">  Purpose:</front>
<front id="qr_solveCPP-316"></front>
<front id="qr_solveCPP-317">    DAXPY computes constant times a vector plus a vector.</front>
<front id="qr_solveCPP-318"></front>
<front id="qr_solveCPP-319">  Discussion:</front>
<front id="qr_solveCPP-320"></front>
<front id="qr_solveCPP-321">    This routine uses unrolled loops for increments equal to one.</front>
<front id="qr_solveCPP-322"></front>
<front id="qr_solveCPP-323">  Licensing:</front>
<front id="qr_solveCPP-324"></front>
<front id="qr_solveCPP-325">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-326"></front>
<front id="qr_solveCPP-327">  Modified:</front>
<front id="qr_solveCPP-328"></front>
<front id="qr_solveCPP-329">    30 March 2007</front>
<front id="qr_solveCPP-330"></front>
<front id="qr_solveCPP-331">  Author:</front>
<front id="qr_solveCPP-332"></front>
<front id="qr_solveCPP-333">    C version by John Burkardt</front>
<front id="qr_solveCPP-334"></front>
<front id="qr_solveCPP-335">  Reference:</front>
<front id="qr_solveCPP-336"></front>
<front id="qr_solveCPP-337">    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,</front>
<front id="qr_solveCPP-338">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-339">    SIAM, 1979.</front>
<front id="qr_solveCPP-340"></front>
<front id="qr_solveCPP-341">    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,</front>
<front id="qr_solveCPP-342">    Basic Linear Algebra Subprograms for Fortran Usage,</front>
<front id="qr_solveCPP-343">    Algorithm 539, </front>
<front id="qr_solveCPP-344">    ACM Transactions on Mathematical Software, </front>
<front id="qr_solveCPP-345">    Volume 5, Number 3, September 1979, pages 308-323.</front>
<front id="qr_solveCPP-346"></front>
<front id="qr_solveCPP-347">  Parameters:</front>
<front id="qr_solveCPP-348"></front>
<front id="qr_solveCPP-349">    Input, int N, the number of elements in DX and DY.</front>
<front id="qr_solveCPP-350"></front>
<front id="qr_solveCPP-351">    Input, double DA, the multiplier of DX.</front>
<front id="qr_solveCPP-352"></front>
<front id="qr_solveCPP-353">    Input, double DX[*], the first vector.</front>
<front id="qr_solveCPP-354"></front>
<front id="qr_solveCPP-355">    Input, int INCX, the increment between successive entries of DX.</front>
<front id="qr_solveCPP-356"></front>
<front id="qr_solveCPP-357">    Input/output, double DY[*], the second vector.</front>
<front id="qr_solveCPP-358">    On output, DY[*] has been replaced by DY[*] + DA * DX[*].</front>
<front id="qr_solveCPP-359"></front>
<front id="qr_solveCPP-360">    Input, int INCY, the increment between successive entries of DY.</front>
<front id="qr_solveCPP-361">*/</front>
<front id="qr_solveCPP-362">{</front>
<front id="qr_solveCPP-363">  int i;</front>
<front id="qr_solveCPP-364">  int ix;</front>
<front id="qr_solveCPP-365">  int iy;</front>
<front id="qr_solveCPP-366">  int m;</front>
<front id="qr_solveCPP-367"></front>
<front id="qr_solveCPP-368">  if ( n &lt;= 0 )</front>
<front id="qr_solveCPP-369">  {</front>
<front id="qr_solveCPP-370">    return;</front>
<front id="qr_solveCPP-371">  }</front>
<front id="qr_solveCPP-372"></front>
<front id="qr_solveCPP-373">  if ( da == 0.0 )</front>
<front id="qr_solveCPP-374">  {</front>
<front id="qr_solveCPP-375">    return;</front>
<front id="qr_solveCPP-376">  }</front>
<front id="qr_solveCPP-377">/*</front>
<front id="qr_solveCPP-378">  Code for unequal increments or equal increments</front>
<front id="qr_solveCPP-379">  not equal to 1.</front>
<front id="qr_solveCPP-380">*/</front>
<front id="qr_solveCPP-381">  if ( incx != 1 || incy != 1 )</front>
<front id="qr_solveCPP-382">  {</front>
<front id="qr_solveCPP-383">    if ( 0 &lt;= incx )</front>
<front id="qr_solveCPP-384">    {</front>
<front id="qr_solveCPP-385">      ix = 0;</front>
<front id="qr_solveCPP-386">    }</front>
<front id="qr_solveCPP-387">    else</front>
<front id="qr_solveCPP-388">    {</front>
<front id="qr_solveCPP-389">      ix = ( - n + 1 ) * incx;</front>
<front id="qr_solveCPP-390">    }</front>
<front id="qr_solveCPP-391"></front>
<front id="qr_solveCPP-392">    if ( 0 &lt;= incy )</front>
<front id="qr_solveCPP-393">    {</front>
<front id="qr_solveCPP-394">      iy = 0;</front>
<front id="qr_solveCPP-395">    }</front>
<front id="qr_solveCPP-396">    else</front>
<front id="qr_solveCPP-397">    {</front>
<front id="qr_solveCPP-398">      iy = ( - n + 1 ) * incy;</front>
<front id="qr_solveCPP-399">    }</front>
<front id="qr_solveCPP-400"></front>
<front id="qr_solveCPP-401">    for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-402">    {</front>
<front id="qr_solveCPP-403">      dy[iy] = dy[iy] + da * dx[ix];</front>
<front id="qr_solveCPP-404">      ix = ix + incx;</front>
<front id="qr_solveCPP-405">      iy = iy + incy;</front>
<front id="qr_solveCPP-406">    }</front>
<front id="qr_solveCPP-407">  }</front>
<front id="qr_solveCPP-408">/*</front>
<front id="qr_solveCPP-409">  Code for both increments equal to 1.</front>
<front id="qr_solveCPP-410">*/</front>
<front id="qr_solveCPP-411">  else</front>
<front id="qr_solveCPP-412">  {</front>
<front id="qr_solveCPP-413">    m = n % 4;</front>
<front id="qr_solveCPP-414"></front>
<front id="qr_solveCPP-415">    for ( i = 0; i &lt; m; i++ )</front>
<front id="qr_solveCPP-416">    {</front>
<front id="qr_solveCPP-417">      dy[i] = dy[i] + da * dx[i];</front>
<front id="qr_solveCPP-418">    }</front>
<front id="qr_solveCPP-419"></front>
<front id="qr_solveCPP-420">    for ( i = m; i &lt; n; i = i + 4 )</front>
<front id="qr_solveCPP-421">    {</front>
<front id="qr_solveCPP-422">      dy[i  ] = dy[i  ] + da * dx[i  ];</front>
<front id="qr_solveCPP-423">      dy[i+1] = dy[i+1] + da * dx[i+1];</front>
<front id="qr_solveCPP-424">      dy[i+2] = dy[i+2] + da * dx[i+2];</front>
<front id="qr_solveCPP-425">      dy[i+3] = dy[i+3] + da * dx[i+3];</front>
<front id="qr_solveCPP-426">    }</front>
<front id="qr_solveCPP-427">  }</front>
<front id="qr_solveCPP-428">  return;</front>
<front id="qr_solveCPP-429">}</front>
<front id="qr_solveCPP-430">/******************************************************************************/</front>
<front id="qr_solveCPP-431"></front>
<front id="qr_solveCPP-432">double ddot ( int n, double dx[], int incx, double dy[], int incy )</front>
<front id="qr_solveCPP-433"></front>
<front id="qr_solveCPP-434">/******************************************************************************/</front>
<front id="qr_solveCPP-435">/*</front>
<front id="qr_solveCPP-436">  Purpose:</front>
<front id="qr_solveCPP-437"></front>
<front id="qr_solveCPP-438">    DDOT forms the dot product of two vectors.</front>
<front id="qr_solveCPP-439"></front>
<front id="qr_solveCPP-440">  Discussion:</front>
<front id="qr_solveCPP-441"></front>
<front id="qr_solveCPP-442">    This routine uses unrolled loops for increments equal to one.</front>
<front id="qr_solveCPP-443"></front>
<front id="qr_solveCPP-444">  Licensing:</front>
<front id="qr_solveCPP-445"></front>
<front id="qr_solveCPP-446">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-447"></front>
<front id="qr_solveCPP-448">  Modified:</front>
<front id="qr_solveCPP-449"></front>
<front id="qr_solveCPP-450">    30 March 2007</front>
<front id="qr_solveCPP-451"></front>
<front id="qr_solveCPP-452">  Author:</front>
<front id="qr_solveCPP-453"></front>
<front id="qr_solveCPP-454">    C version by John Burkardt</front>
<front id="qr_solveCPP-455"></front>
<front id="qr_solveCPP-456">  Reference:</front>
<front id="qr_solveCPP-457"></front>
<front id="qr_solveCPP-458">    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,</front>
<front id="qr_solveCPP-459">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-460">    SIAM, 1979.</front>
<front id="qr_solveCPP-461"></front>
<front id="qr_solveCPP-462">    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,</front>
<front id="qr_solveCPP-463">    Basic Linear Algebra Subprograms for Fortran Usage,</front>
<front id="qr_solveCPP-464">    Algorithm 539, </front>
<front id="qr_solveCPP-465">    ACM Transactions on Mathematical Software, </front>
<front id="qr_solveCPP-466">    Volume 5, Number 3, September 1979, pages 308-323.</front>
<front id="qr_solveCPP-467"></front>
<front id="qr_solveCPP-468">  Parameters:</front>
<front id="qr_solveCPP-469"></front>
<front id="qr_solveCPP-470">    Input, int N, the number of entries in the vectors.</front>
<front id="qr_solveCPP-471"></front>
<front id="qr_solveCPP-472">    Input, double DX[*], the first vector.</front>
<front id="qr_solveCPP-473"></front>
<front id="qr_solveCPP-474">    Input, int INCX, the increment between successive entries in DX.</front>
<front id="qr_solveCPP-475"></front>
<front id="qr_solveCPP-476">    Input, double DY[*], the second vector.</front>
<front id="qr_solveCPP-477"></front>
<front id="qr_solveCPP-478">    Input, int INCY, the increment between successive entries in DY.</front>
<front id="qr_solveCPP-479"></front>
<front id="qr_solveCPP-480">    Output, double DDOT, the sum of the product of the corresponding</front>
<front id="qr_solveCPP-481">    entries of DX and DY.</front>
<front id="qr_solveCPP-482">*/</front>
<front id="qr_solveCPP-483">{</front>
<front id="qr_solveCPP-484">  double dtemp;</front>
<front id="qr_solveCPP-485">  int i;</front>
<front id="qr_solveCPP-486">  int ix;</front>
<front id="qr_solveCPP-487">  int iy;</front>
<front id="qr_solveCPP-488">  int m;</front>
<front id="qr_solveCPP-489"></front>
<front id="qr_solveCPP-490">  dtemp = 0.0;</front>
<front id="qr_solveCPP-491"></front>
<front id="qr_solveCPP-492">  if ( n &lt;= 0 )</front>
<front id="qr_solveCPP-493">  {</front>
<front id="qr_solveCPP-494">    return dtemp;</front>
<front id="qr_solveCPP-495">  }</front>
<front id="qr_solveCPP-496">/*</front>
<front id="qr_solveCPP-497">  Code for unequal increments or equal increments</front>
<front id="qr_solveCPP-498">  not equal to 1.</front>
<front id="qr_solveCPP-499">*/</front>
<front id="qr_solveCPP-500">  if ( incx != 1 || incy != 1 )</front>
<front id="qr_solveCPP-501">  {</front>
<front id="qr_solveCPP-502">    if ( 0 &lt;= incx )</front>
<front id="qr_solveCPP-503">    {</front>
<front id="qr_solveCPP-504">      ix = 0;</front>
<front id="qr_solveCPP-505">    }</front>
<front id="qr_solveCPP-506">    else</front>
<front id="qr_solveCPP-507">    {</front>
<front id="qr_solveCPP-508">      ix = ( - n + 1 ) * incx;</front>
<front id="qr_solveCPP-509">    }</front>
<front id="qr_solveCPP-510"></front>
<front id="qr_solveCPP-511">    if ( 0 &lt;= incy )</front>
<front id="qr_solveCPP-512">    {</front>
<front id="qr_solveCPP-513">      iy = 0;</front>
<front id="qr_solveCPP-514">    }</front>
<front id="qr_solveCPP-515">    else</front>
<front id="qr_solveCPP-516">    {</front>
<front id="qr_solveCPP-517">      iy = ( - n + 1 ) * incy;</front>
<front id="qr_solveCPP-518">    }</front>
<front id="qr_solveCPP-519"></front>
<front id="qr_solveCPP-520">    for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-521">    {</front>
<front id="qr_solveCPP-522">      dtemp = dtemp + dx[ix] * dy[iy];</front>
<front id="qr_solveCPP-523">      ix = ix + incx;</front>
<front id="qr_solveCPP-524">      iy = iy + incy;</front>
<front id="qr_solveCPP-525">    }</front>
<front id="qr_solveCPP-526">  }</front>
<front id="qr_solveCPP-527">/*</front>
<front id="qr_solveCPP-528">  Code for both increments equal to 1.</front>
<front id="qr_solveCPP-529">*/</front>
<front id="qr_solveCPP-530">  else</front>
<front id="qr_solveCPP-531">  {</front>
<front id="qr_solveCPP-532">    m = n % 5;</front>
<front id="qr_solveCPP-533"></front>
<front id="qr_solveCPP-534">    for ( i = 0; i &lt; m; i++ )</front>
<front id="qr_solveCPP-535">    {</front>
<front id="qr_solveCPP-536">      dtemp = dtemp + dx[i] * dy[i];</front>
<front id="qr_solveCPP-537">    }</front>
<front id="qr_solveCPP-538"></front>
<front id="qr_solveCPP-539">    for ( i = m; i &lt; n; i = i + 5 )</front>
<front id="qr_solveCPP-540">    {</front>
<front id="qr_solveCPP-541">      dtemp = dtemp + dx[i  ] * dy[i  ] </front>
<front id="qr_solveCPP-542">                    + dx[i+1] * dy[i+1] </front>
<front id="qr_solveCPP-543">                    + dx[i+2] * dy[i+2] </front>
<front id="qr_solveCPP-544">                    + dx[i+3] * dy[i+3] </front>
<front id="qr_solveCPP-545">                    + dx[i+4] * dy[i+4];</front>
<front id="qr_solveCPP-546">    }</front>
<front id="qr_solveCPP-547">  }</front>
<front id="qr_solveCPP-548">  return dtemp;</front>
<front id="qr_solveCPP-549">}</front>
<front id="qr_solveCPP-550">/******************************************************************************/</front>
<front id="qr_solveCPP-551"></front>
<front id="qr_solveCPP-552">double dnrm2 ( int n, double x[], int incx )</front>
<front id="qr_solveCPP-553"></front>
<front id="qr_solveCPP-554">/******************************************************************************/</front>
<front id="qr_solveCPP-555">/*</front>
<front id="qr_solveCPP-556">  Purpose:</front>
<front id="qr_solveCPP-557"></front>
<front id="qr_solveCPP-558">    DNRM2 returns the euclidean norm of a vector.</front>
<front id="qr_solveCPP-559"></front>
<front id="qr_solveCPP-560">  Discussion:</front>
<front id="qr_solveCPP-561"></front>
<front id="qr_solveCPP-562">     DNRM2 ( X ) = sqrt ( X' * X )</front>
<front id="qr_solveCPP-563"></front>
<front id="qr_solveCPP-564">  Licensing:</front>
<front id="qr_solveCPP-565"></front>
<front id="qr_solveCPP-566">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-567"></front>
<front id="qr_solveCPP-568">  Modified:</front>
<front id="qr_solveCPP-569"></front>
<front id="qr_solveCPP-570">    30 March 2007</front>
<front id="qr_solveCPP-571"></front>
<front id="qr_solveCPP-572">  Author:</front>
<front id="qr_solveCPP-573"></front>
<front id="qr_solveCPP-574">    C version by John Burkardt</front>
<front id="qr_solveCPP-575"></front>
<front id="qr_solveCPP-576">  Reference:</front>
<front id="qr_solveCPP-577"></front>
<front id="qr_solveCPP-578">    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,</front>
<front id="qr_solveCPP-579">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-580">    SIAM, 1979.</front>
<front id="qr_solveCPP-581"></front>
<front id="qr_solveCPP-582">    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,</front>
<front id="qr_solveCPP-583">    Basic Linear Algebra Subprograms for Fortran Usage,</front>
<front id="qr_solveCPP-584">    Algorithm 539,</front>
<front id="qr_solveCPP-585">    ACM Transactions on Mathematical Software,</front>
<front id="qr_solveCPP-586">    Volume 5, Number 3, September 1979, pages 308-323.</front>
<front id="qr_solveCPP-587"></front>
<front id="qr_solveCPP-588">  Parameters:</front>
<front id="qr_solveCPP-589"></front>
<front id="qr_solveCPP-590">    Input, int N, the number of entries in the vector.</front>
<front id="qr_solveCPP-591"></front>
<front id="qr_solveCPP-592">    Input, double X[*], the vector whose norm is to be computed.</front>
<front id="qr_solveCPP-593"></front>
<front id="qr_solveCPP-594">    Input, int INCX, the increment between successive entries of X.</front>
<front id="qr_solveCPP-595"></front>
<front id="qr_solveCPP-596">    Output, double DNRM2, the Euclidean norm of X.</front>
<front id="qr_solveCPP-597">*/</front>
<front id="qr_solveCPP-598">{</front>
<front id="qr_solveCPP-599">  double absxi;</front>
<front id="qr_solveCPP-600">  int i;</front>
<front id="qr_solveCPP-601">  int ix;</front>
<front id="qr_solveCPP-602">  double norm;</front>
<front id="qr_solveCPP-603">  double scale;</front>
<front id="qr_solveCPP-604">  double ssq;</front>
<front id="qr_solveCPP-605"></front>
<front id="qr_solveCPP-606">  if ( n &lt; 1 || incx &lt; 1 )</front>
<front id="qr_solveCPP-607">  {</front>
<front id="qr_solveCPP-608">    norm = 0.0;</front>
<front id="qr_solveCPP-609">  }</front>
<front id="qr_solveCPP-610">  else if ( n == 1 )</front>
<front id="qr_solveCPP-611">  {</front>
<front id="qr_solveCPP-612">    norm = r8_abs ( x[0] );</front>
<front id="qr_solveCPP-613">  }</front>
<front id="qr_solveCPP-614">  else</front>
<front id="qr_solveCPP-615">  {</front>
<front id="qr_solveCPP-616">    scale = 0.0;</front>
<front id="qr_solveCPP-617">    ssq = 1.0;</front>
<front id="qr_solveCPP-618">    ix = 0;</front>
<front id="qr_solveCPP-619"></front>
<front id="qr_solveCPP-620">    for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-621">    {</front>
<front id="qr_solveCPP-622">      if ( x[ix] != 0.0 )</front>
<front id="qr_solveCPP-623">      {</front>
<front id="qr_solveCPP-624">        absxi = r8_abs ( x[ix] );</front>
<front id="qr_solveCPP-625">        if ( scale &lt; absxi )</front>
<front id="qr_solveCPP-626">        {</front>
<front id="qr_solveCPP-627">          ssq = 1.0 + ssq * ( scale / absxi ) * ( scale / absxi );</front>
<front id="qr_solveCPP-628">          scale = absxi;</front>
<front id="qr_solveCPP-629">        }</front>
<front id="qr_solveCPP-630">        else</front>
<front id="qr_solveCPP-631">        {</front>
<front id="qr_solveCPP-632">          ssq = ssq + ( absxi / scale ) * ( absxi / scale );</front>
<front id="qr_solveCPP-633">        }</front>
<front id="qr_solveCPP-634">      }</front>
<front id="qr_solveCPP-635">      ix = ix + incx;</front>
<front id="qr_solveCPP-636">    }</front>
<front id="qr_solveCPP-637"></front>
<front id="qr_solveCPP-638">    norm  = scale * sqrt ( ssq );</front>
<front id="qr_solveCPP-639">  }</front>
<front id="qr_solveCPP-640"></front>
<front id="qr_solveCPP-641">  return norm;</front>
<front id="qr_solveCPP-642">}</front>
<front id="qr_solveCPP-643">/******************************************************************************/</front>
<front id="qr_solveCPP-644"></front>
<front id="qr_solveCPP-645">void dqrank ( double a[], int lda, int m, int n, double tol, int *kr, </front>
<front id="qr_solveCPP-646">  int jpvt[], double qraux[] )</front>
<front id="qr_solveCPP-647"></front>
<front id="qr_solveCPP-648">/******************************************************************************/</front>
<front id="qr_solveCPP-649">/*</front>
<front id="qr_solveCPP-650">  Purpose:</front>
<front id="qr_solveCPP-651"></front>
<front id="qr_solveCPP-652">    DQRANK computes the QR factorization of a rectangular matrix.</front>
<front id="qr_solveCPP-653"></front>
<front id="qr_solveCPP-654">  Discussion:</front>
<front id="qr_solveCPP-655"></front>
<front id="qr_solveCPP-656">    This routine is used in conjunction with DQRLSS to solve</front>
<front id="qr_solveCPP-657">    overdetermined, underdetermined and singular linear systems</front>
<front id="qr_solveCPP-658">    in a least squares sense.</front>
<front id="qr_solveCPP-659"></front>
<front id="qr_solveCPP-660">    DQRANK uses the LINPACK subroutine DQRDC to compute the QR</front>
<front id="qr_solveCPP-661">    factorization, with column pivoting, of an M by N matrix A.</front>
<front id="qr_solveCPP-662">    The numerical rank is determined using the tolerance TOL.</front>
<front id="qr_solveCPP-663"></front>
<front id="qr_solveCPP-664">    Note that on output, ABS ( A(1,1) ) / ABS ( A(KR,KR) ) is an estimate</front>
<front id="qr_solveCPP-665">    of the condition number of the matrix of independent columns,</front>
<front id="qr_solveCPP-666">    and of R.  This estimate will be &lt;= 1/TOL.</front>
<front id="qr_solveCPP-667"></front>
<front id="qr_solveCPP-668">  Licensing:</front>
<front id="qr_solveCPP-669"></front>
<front id="qr_solveCPP-670">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-671"></front>
<front id="qr_solveCPP-672">  Modified:</front>
<front id="qr_solveCPP-673"></front>
<front id="qr_solveCPP-674">    21 April 2012</front>
<front id="qr_solveCPP-675"></front>
<front id="qr_solveCPP-676">  Author:</front>
<front id="qr_solveCPP-677"></front>
<front id="qr_solveCPP-678">    C version by John Burkardt.</front>
<front id="qr_solveCPP-679"></front>
<front id="qr_solveCPP-680">  Reference:</front>
<front id="qr_solveCPP-681"></front>
<front id="qr_solveCPP-682">    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,</front>
<front id="qr_solveCPP-683">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-684">    SIAM, 1979,</front>
<front id="qr_solveCPP-685">    ISBN13: 978-0-898711-72-1,</front>
<front id="qr_solveCPP-686">    LC: QA214.L56.</front>
<front id="qr_solveCPP-687"></front>
<front id="qr_solveCPP-688">  Parameters:</front>
<front id="qr_solveCPP-689"></front>
<front id="qr_solveCPP-690">    Input/output, double A[LDA*N].  On input, the matrix whose</front>
<front id="qr_solveCPP-691">    decomposition is to be computed.  On output, the information from DQRDC.</front>
<front id="qr_solveCPP-692">    The triangular matrix R of the QR factorization is contained in the</front>
<front id="qr_solveCPP-693">    upper triangle and information needed to recover the orthogonal</front>
<front id="qr_solveCPP-694">    matrix Q is stored below the diagonal in A and in the vector QRAUX.</front>
<front id="qr_solveCPP-695"></front>
<front id="qr_solveCPP-696">    Input, int LDA, the leading dimension of A, which must</front>
<front id="qr_solveCPP-697">    be at least M.</front>
<front id="qr_solveCPP-698"></front>
<front id="qr_solveCPP-699">    Input, int M, the number of rows of A.</front>
<front id="qr_solveCPP-700"></front>
<front id="qr_solveCPP-701">    Input, int N, the number of columns of A.</front>
<front id="qr_solveCPP-702"></front>
<front id="qr_solveCPP-703">    Input, double TOL, a relative tolerance used to determine the</front>
<front id="qr_solveCPP-704">    numerical rank.  The problem should be scaled so that all the elements</front>
<front id="qr_solveCPP-705">    of A have roughly the same absolute accuracy, EPS.  Then a reasonable</front>
<front id="qr_solveCPP-706">    value for TOL is roughly EPS divided by the magnitude of the largest</front>
<front id="qr_solveCPP-707">    element.</front>
<front id="qr_solveCPP-708"></front>
<front id="qr_solveCPP-709">    Output, int *KR, the numerical rank.</front>
<front id="qr_solveCPP-710"></front>
<front id="qr_solveCPP-711">    Output, int JPVT[N], the pivot information from DQRDC.</front>
<front id="qr_solveCPP-712">    Columns JPVT(1), ..., JPVT(KR) of the original matrix are linearly</front>
<front id="qr_solveCPP-713">    independent to within the tolerance TOL and the remaining columns</front>
<front id="qr_solveCPP-714">    are linearly dependent.</front>
<front id="qr_solveCPP-715"></front>
<front id="qr_solveCPP-716">    Output, double QRAUX[N], will contain extra information defining</front>
<front id="qr_solveCPP-717">    the QR factorization.</front>
<front id="qr_solveCPP-718">*/</front>
<front id="qr_solveCPP-719">{</front>
<front id="qr_solveCPP-720">  int i;</front>
<front id="qr_solveCPP-721">  int j;</front>
<front id="qr_solveCPP-722">  int job;</front>
<front id="qr_solveCPP-723">  int k;</front>
<front id="qr_solveCPP-724">  double work[n];</front>
<front id="qr_solveCPP-725"></front>
<front id="qr_solveCPP-726">  for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-727">  {</front>
<front id="qr_solveCPP-728">    jpvt[i] = 0;</front>
<front id="qr_solveCPP-729">  }</front>
<front id="qr_solveCPP-730"></front>
<front id="qr_solveCPP-731">  job = 1;</front>
<front id="qr_solveCPP-732"></front>
<front id="qr_solveCPP-733">  dqrdc ( a, lda, m, n, qraux, jpvt, work, job );</front>
<front id="qr_solveCPP-734"></front>
<front id="qr_solveCPP-735">  *kr = 0;</front>
<front id="qr_solveCPP-736">  k = i4_min ( m, n );</front>
<front id="qr_solveCPP-737"></front>
<front id="qr_solveCPP-738">  for ( j = 0; j &lt; k; j++ )</front>
<front id="qr_solveCPP-739">  {</front>
<front id="qr_solveCPP-740">    if ( r8_abs ( a[j+j*lda] ) &lt;= tol * r8_abs ( a[0+0*lda] ) )</front>
<front id="qr_solveCPP-741">    {</front>
<front id="qr_solveCPP-742">      return;</front>
<front id="qr_solveCPP-743">    }</front>
<front id="qr_solveCPP-744">    *kr = j + 1;</front>
<front id="qr_solveCPP-745">  }</front>
<front id="qr_solveCPP-746"></front>
<front id="qr_solveCPP-747">  return;</front>
<front id="qr_solveCPP-748">}</front>
<front id="qr_solveCPP-749">/******************************************************************************/</front>
<front id="qr_solveCPP-750"></front>
<front id="qr_solveCPP-751">void dqrdc ( double a[], int lda, int n, int p, double qraux[], int jpvt[], </front>
<front id="qr_solveCPP-752">  double work[], int job )</front>
<front id="qr_solveCPP-753"></front>
<front id="qr_solveCPP-754">/******************************************************************************/</front>
<front id="qr_solveCPP-755">/*</front>
<front id="qr_solveCPP-756">  Purpose:</front>
<front id="qr_solveCPP-757"></front>
<front id="qr_solveCPP-758">    DQRDC computes the QR factorization of a real rectangular matrix.</front>
<front id="qr_solveCPP-759"></front>
<front id="qr_solveCPP-760">  Discussion:</front>
<front id="qr_solveCPP-761"></front>
<front id="qr_solveCPP-762">    DQRDC uses Householder transformations.</front>
<front id="qr_solveCPP-763"></front>
<front id="qr_solveCPP-764">    Column pivoting based on the 2-norms of the reduced columns may be</front>
<front id="qr_solveCPP-765">    performed at the user's option.</front>
<front id="qr_solveCPP-766"></front>
<front id="qr_solveCPP-767">  Licensing:</front>
<front id="qr_solveCPP-768"></front>
<front id="qr_solveCPP-769">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-770"></front>
<front id="qr_solveCPP-771">  Modified:</front>
<front id="qr_solveCPP-772"></front>
<front id="qr_solveCPP-773">    07 June 2005</front>
<front id="qr_solveCPP-774"></front>
<front id="qr_solveCPP-775">  Author:</front>
<front id="qr_solveCPP-776"></front>
<front id="qr_solveCPP-777">    C version by John Burkardt.</front>
<front id="qr_solveCPP-778"></front>
<front id="qr_solveCPP-779">  Reference:</front>
<front id="qr_solveCPP-780"></front>
<front id="qr_solveCPP-781">    Jack Dongarra, Cleve Moler, Jim Bunch and Pete Stewart,</front>
<front id="qr_solveCPP-782">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-783">    SIAM, (Society for Industrial and Applied Mathematics),</front>
<front id="qr_solveCPP-784">    3600 University City Science Center,</front>
<front id="qr_solveCPP-785">    Philadelphia, PA, 19104-2688.</front>
<front id="qr_solveCPP-786">    ISBN 0-89871-172-X</front>
<front id="qr_solveCPP-787"></front>
<front id="qr_solveCPP-788">  Parameters:</front>
<front id="qr_solveCPP-789"></front>
<front id="qr_solveCPP-790">    Input/output, double A(LDA,P).  On input, the N by P matrix</front>
<front id="qr_solveCPP-791">    whose decomposition is to be computed.  On output, A contains in</front>
<front id="qr_solveCPP-792">    its upper triangle the upper triangular matrix R of the QR</front>
<front id="qr_solveCPP-793">    factorization.  Below its diagonal A contains information from</front>
<front id="qr_solveCPP-794">    which the orthogonal part of the decomposition can be recovered.</front>
<front id="qr_solveCPP-795">    Note that if pivoting has been requested, the decomposition is not that</front>
<front id="qr_solveCPP-796">    of the original matrix A but that of A with its columns permuted</front>
<front id="qr_solveCPP-797">    as described by JPVT.</front>
<front id="qr_solveCPP-798"></front>
<front id="qr_solveCPP-799">    Input, int LDA, the leading dimension of the array A.  LDA must</front>
<front id="qr_solveCPP-800">    be at least N.</front>
<front id="qr_solveCPP-801"></front>
<front id="qr_solveCPP-802">    Input, int N, the number of rows of the matrix A.</front>
<front id="qr_solveCPP-803"></front>
<front id="qr_solveCPP-804">    Input, int P, the number of columns of the matrix A.</front>
<front id="qr_solveCPP-805"></front>
<front id="qr_solveCPP-806">    Output, double QRAUX[P], contains further information required</front>
<front id="qr_solveCPP-807">    to recover the orthogonal part of the decomposition.</front>
<front id="qr_solveCPP-808"></front>
<front id="qr_solveCPP-809">    Input/output, integer JPVT[P].  On input, JPVT contains integers that</front>
<front id="qr_solveCPP-810">    control the selection of the pivot columns.  The K-th column A(*,K) of A</front>
<front id="qr_solveCPP-811">    is placed in one of three classes according to the value of JPVT(K).</front>
<front id="qr_solveCPP-812">      &gt; 0, then A(K) is an initial column.</front>
<front id="qr_solveCPP-813">      = 0, then A(K) is a free column.</front>
<front id="qr_solveCPP-814">      &lt; 0, then A(K) is a final column.</front>
<front id="qr_solveCPP-815">    Before the decomposition is computed, initial columns are moved to</front>
<front id="qr_solveCPP-816">    the beginning of the array A and final columns to the end.  Both</front>
<front id="qr_solveCPP-817">    initial and final columns are frozen in place during the computation</front>
<front id="qr_solveCPP-818">    and only free columns are moved.  At the K-th stage of the</front>
<front id="qr_solveCPP-819">    reduction, if A(*,K) is occupied by a free column it is interchanged</front>
<front id="qr_solveCPP-820">    with the free column of largest reduced norm.  JPVT is not referenced</front>
<front id="qr_solveCPP-821">    if JOB == 0.  On output, JPVT(K) contains the index of the column of the</front>
<front id="qr_solveCPP-822">    original matrix that has been interchanged into the K-th column, if</front>
<front id="qr_solveCPP-823">    pivoting was requested.</front>
<front id="qr_solveCPP-824"></front>
<front id="qr_solveCPP-825">    Workspace, double WORK[P].  WORK is not referenced if JOB == 0.</front>
<front id="qr_solveCPP-826"></front>
<front id="qr_solveCPP-827">    Input, int JOB, initiates column pivoting.</front>
<front id="qr_solveCPP-828">    0, no pivoting is done.</front>
<front id="qr_solveCPP-829">    nonzero, pivoting is done.</front>
<front id="qr_solveCPP-830">*/</front>
<front id="qr_solveCPP-831">{</front>
<front id="qr_solveCPP-832">  int j;</front>
<front id="qr_solveCPP-833">  int jp;</front>
<front id="qr_solveCPP-834">  int l;</front>
<front id="qr_solveCPP-835">  int lup;</front>
<front id="qr_solveCPP-836">  int maxj;</front>
<front id="qr_solveCPP-837">  double maxnrm;</front>
<front id="qr_solveCPP-838">  double nrmxl;</front>
<front id="qr_solveCPP-839">  int pl;</front>
<front id="qr_solveCPP-840">  int pu;</front>
<front id="qr_solveCPP-841">  int swapj;</front>
<front id="qr_solveCPP-842">  double t;</front>
<front id="qr_solveCPP-843">  double tt;</front>
<front id="qr_solveCPP-844"></front>
<front id="qr_solveCPP-845">  pl = 1;</front>
<front id="qr_solveCPP-846">  pu = 0;</front>
<front id="qr_solveCPP-847">/*</front>
<front id="qr_solveCPP-848">  If pivoting is requested, rearrange the columns.</front>
<front id="qr_solveCPP-849">*/</front>
<front id="qr_solveCPP-850">  if ( job != 0 )</front>
<front id="qr_solveCPP-851">  {</front>
<front id="qr_solveCPP-852">    for ( j = 1; j &lt;= p; j++ )</front>
<front id="qr_solveCPP-853">    {</front>
<front id="qr_solveCPP-854">      swapj = ( 0 &lt; jpvt[j-1] );</front>
<front id="qr_solveCPP-855"></front>
<front id="qr_solveCPP-856">      if ( jpvt[j-1] &lt; 0 )</front>
<front id="qr_solveCPP-857">      {</front>
<front id="qr_solveCPP-858">        jpvt[j-1] = -j;</front>
<front id="qr_solveCPP-859">      }</front>
<front id="qr_solveCPP-860">      else</front>
<front id="qr_solveCPP-861">      {</front>
<front id="qr_solveCPP-862">        jpvt[j-1] = j;</front>
<front id="qr_solveCPP-863">      }</front>
<front id="qr_solveCPP-864"></front>
<front id="qr_solveCPP-865">      if ( swapj )</front>
<front id="qr_solveCPP-866">      {</front>
<front id="qr_solveCPP-867">        if ( j != pl )</front>
<front id="qr_solveCPP-868">        {</front>
<front id="qr_solveCPP-869">          dswap ( n, a+0+(pl-1)*lda, 1, a+0+(j-1), 1 );</front>
<front id="qr_solveCPP-870">        }</front>
<front id="qr_solveCPP-871">        jpvt[j-1] = jpvt[pl-1];</front>
<front id="qr_solveCPP-872">        jpvt[pl-1] = j;</front>
<front id="qr_solveCPP-873">        pl = pl + 1;</front>
<front id="qr_solveCPP-874">      }</front>
<front id="qr_solveCPP-875">    }</front>
<front id="qr_solveCPP-876">    pu = p;</front>
<front id="qr_solveCPP-877"></front>
<front id="qr_solveCPP-878">    for ( j = p; 1 &lt;= j; j-- )</front>
<front id="qr_solveCPP-879">    {</front>
<front id="qr_solveCPP-880">      if ( jpvt[j-1] &lt; 0 )</front>
<front id="qr_solveCPP-881">      {</front>
<front id="qr_solveCPP-882">        jpvt[j-1] = -jpvt[j-1];</front>
<front id="qr_solveCPP-883"></front>
<front id="qr_solveCPP-884">        if ( j != pu )</front>
<front id="qr_solveCPP-885">        {</front>
<front id="qr_solveCPP-886">          dswap ( n, a+0+(pu-1)*lda, 1, a+0+(j-1)*lda, 1 );</front>
<front id="qr_solveCPP-887">          jp = jpvt[pu-1];</front>
<front id="qr_solveCPP-888">          jpvt[pu-1] = jpvt[j-1];</front>
<front id="qr_solveCPP-889">          jpvt[j-1] = jp;</front>
<front id="qr_solveCPP-890">        }</front>
<front id="qr_solveCPP-891">        pu = pu - 1;</front>
<front id="qr_solveCPP-892">      }</front>
<front id="qr_solveCPP-893">    }</front>
<front id="qr_solveCPP-894">  }</front>
<front id="qr_solveCPP-895">/*</front>
<front id="qr_solveCPP-896">  Compute the norms of the free columns.</front>
<front id="qr_solveCPP-897">*/</front>
<front id="qr_solveCPP-898">  for ( j = pl; j &lt;= pu; j++ )</front>
<front id="qr_solveCPP-899">  {</front>
<front id="qr_solveCPP-900">    qraux[j-1] = dnrm2 ( n, a+0+(j-1)*lda, 1 );</front>
<front id="qr_solveCPP-901">  }</front>
<front id="qr_solveCPP-902"></front>
<front id="qr_solveCPP-903">  for ( j = pl; j &lt;= pu; j++ )</front>
<front id="qr_solveCPP-904">  {</front>
<front id="qr_solveCPP-905">    work[j-1] = qraux[j-1];</front>
<front id="qr_solveCPP-906">  }</front>
<front id="qr_solveCPP-907">/*</front>
<front id="qr_solveCPP-908">  Perform the Householder reduction of A.</front>
<front id="qr_solveCPP-909">*/</front>
<front id="qr_solveCPP-910">  lup = i4_min ( n, p );</front>
<front id="qr_solveCPP-911"></front>
<front id="qr_solveCPP-912">  for ( l = 1; l &lt;= lup; l++ )</front>
<front id="qr_solveCPP-913">  {</front>
<front id="qr_solveCPP-914">/*</front>
<front id="qr_solveCPP-915">  Bring the column of largest norm into the pivot position.</front>
<front id="qr_solveCPP-916">*/</front>
<front id="qr_solveCPP-917">    if ( pl &lt;= l && l &lt; pu )</front>
<front id="qr_solveCPP-918">    {</front>
<front id="qr_solveCPP-919">      maxnrm = 0.0;</front>
<front id="qr_solveCPP-920">      maxj = l;</front>
<front id="qr_solveCPP-921">      for ( j = l; j &lt;= pu; j++ )</front>
<front id="qr_solveCPP-922">      {</front>
<front id="qr_solveCPP-923">        if ( maxnrm &lt; qraux[j-1] )</front>
<front id="qr_solveCPP-924">        {</front>
<front id="qr_solveCPP-925">          maxnrm = qraux[j-1];</front>
<front id="qr_solveCPP-926">          maxj = j;</front>
<front id="qr_solveCPP-927">        }</front>
<front id="qr_solveCPP-928">      }</front>
<front id="qr_solveCPP-929"></front>
<front id="qr_solveCPP-930">      if ( maxj != l )</front>
<front id="qr_solveCPP-931">      {</front>
<front id="qr_solveCPP-932">        dswap ( n, a+0+(l-1)*lda, 1, a+0+(maxj-1)*lda, 1 );</front>
<front id="qr_solveCPP-933">        qraux[maxj-1] = qraux[l-1];</front>
<front id="qr_solveCPP-934">        work[maxj-1] = work[l-1];</front>
<front id="qr_solveCPP-935">        jp = jpvt[maxj-1];</front>
<front id="qr_solveCPP-936">        jpvt[maxj-1] = jpvt[l-1];</front>
<front id="qr_solveCPP-937">        jpvt[l-1] = jp;</front>
<front id="qr_solveCPP-938">      }</front>
<front id="qr_solveCPP-939">    }</front>
<front id="qr_solveCPP-940">/*</front>
<front id="qr_solveCPP-941">  Compute the Householder transformation for column L.</front>
<front id="qr_solveCPP-942">*/</front>
<front id="qr_solveCPP-943">    qraux[l-1] = 0.0;</front>
<front id="qr_solveCPP-944"></front>
<front id="qr_solveCPP-945">    if ( l != n )</front>
<front id="qr_solveCPP-946">    {</front>
<front id="qr_solveCPP-947">      nrmxl = dnrm2 ( n-l+1, a+l-1+(l-1)*lda, 1 );</front>
<front id="qr_solveCPP-948"></front>
<front id="qr_solveCPP-949">      if ( nrmxl != 0.0 )</front>
<front id="qr_solveCPP-950">      {</front>
<front id="qr_solveCPP-951">        if ( a[l-1+(l-1)*lda] != 0.0 )</front>
<front id="qr_solveCPP-952">        {</front>
<front id="qr_solveCPP-953">          nrmxl = nrmxl * r8_sign ( a[l-1+(l-1)*lda] );</front>
<front id="qr_solveCPP-954">        }</front>
<front id="qr_solveCPP-955"></front>
<front id="qr_solveCPP-956">        dscal ( n-l+1, 1.0 / nrmxl, a+l-1+(l-1)*lda, 1 );</front>
<front id="qr_solveCPP-957">        a[l-1+(l-1)*lda] = 1.0 + a[l-1+(l-1)*lda];</front>
<front id="qr_solveCPP-958">/*</front>
<front id="qr_solveCPP-959">  Apply the transformation to the remaining columns, updating the norms.</front>
<front id="qr_solveCPP-960">*/</front>
<front id="qr_solveCPP-961">        for ( j = l + 1; j &lt;= p; j++ )</front>
<front id="qr_solveCPP-962">        {</front>
<front id="qr_solveCPP-963">          t = -ddot ( n-l+1, a+l-1+(l-1)*lda, 1, a+l-1+(j-1)*lda, 1 ) </front>
<front id="qr_solveCPP-964">            / a[l-1+(l-1)*lda];</front>
<front id="qr_solveCPP-965">          daxpy ( n-l+1, t, a+l-1+(l-1)*lda, 1, a+l-1+(j-1)*lda, 1 );</front>
<front id="qr_solveCPP-966"></front>
<front id="qr_solveCPP-967">          if ( pl &lt;= j && j &lt;= pu )</front>
<front id="qr_solveCPP-968">          {</front>
<front id="qr_solveCPP-969">            if ( qraux[j-1] != 0.0 )</front>
<front id="qr_solveCPP-970">            {</front>
<front id="qr_solveCPP-971">              tt = 1.0 - pow ( r8_abs ( a[l-1+(j-1)*lda] ) / qraux[j-1], 2 );</front>
<front id="qr_solveCPP-972">              tt = r8_max ( tt, 0.0 );</front>
<front id="qr_solveCPP-973">              t = tt;</front>
<front id="qr_solveCPP-974">              tt = 1.0 + 0.05 * tt * pow ( qraux[j-1] / work[j-1], 2 );</front>
<front id="qr_solveCPP-975"></front>
<front id="qr_solveCPP-976">              if ( tt != 1.0 )</front>
<front id="qr_solveCPP-977">              {</front>
<front id="qr_solveCPP-978">                qraux[j-1] = qraux[j-1] * sqrt ( t );</front>
<front id="qr_solveCPP-979">              }</front>
<front id="qr_solveCPP-980">              else</front>
<front id="qr_solveCPP-981">              {</front>
<front id="qr_solveCPP-982">                qraux[j-1] = dnrm2 ( n-l, a+l+(j-1)*lda, 1 );</front>
<front id="qr_solveCPP-983">                work[j-1] = qraux[j-1];</front>
<front id="qr_solveCPP-984">              }</front>
<front id="qr_solveCPP-985">            }</front>
<front id="qr_solveCPP-986">          }</front>
<front id="qr_solveCPP-987">        }</front>
<front id="qr_solveCPP-988">/*</front>
<front id="qr_solveCPP-989">  Save the transformation.</front>
<front id="qr_solveCPP-990">*/</front>
<front id="qr_solveCPP-991">        qraux[l-1] = a[l-1+(l-1)*lda];</front>
<front id="qr_solveCPP-992">        a[l-1+(l-1)*lda] = -nrmxl;</front>
<front id="qr_solveCPP-993">      }</front>
<front id="qr_solveCPP-994">    }</front>
<front id="qr_solveCPP-995">  }</front>
<front id="qr_solveCPP-996">  return;</front>
<front id="qr_solveCPP-997">}</front>
<front id="qr_solveCPP-998">/******************************************************************************/</front>
<front id="qr_solveCPP-999"></front>
<front id="qr_solveCPP-1000">int dqrls ( double a[], int lda, int m, int n, double tol, int *kr, double b[], </front>
<front id="qr_solveCPP-1001">  double x[], double rsd[], int jpvt[], double qraux[], int itask )</front>
<front id="qr_solveCPP-1002"></front>
<front id="qr_solveCPP-1003">/******************************************************************************/</front>
<front id="qr_solveCPP-1004">/*</front>
<front id="qr_solveCPP-1005">  Purpose:</front>
<front id="qr_solveCPP-1006"></front>
<front id="qr_solveCPP-1007">    DQRLS factors and solves a linear system in the least squares sense.</front>
<front id="qr_solveCPP-1008"></front>
<front id="qr_solveCPP-1009">  Discussion:</front>
<front id="qr_solveCPP-1010"></front>
<front id="qr_solveCPP-1011">    The linear system may be overdetermined, underdetermined or singular.</front>
<front id="qr_solveCPP-1012">    The solution is obtained using a QR factorization of the</front>
<front id="qr_solveCPP-1013">    coefficient matrix.</front>
<front id="qr_solveCPP-1014"></front>
<front id="qr_solveCPP-1015">    DQRLS can be efficiently used to solve several least squares</front>
<front id="qr_solveCPP-1016">    problems with the same matrix A.  The first system is solved</front>
<front id="qr_solveCPP-1017">    with ITASK = 1.  The subsequent systems are solved with</front>
<front id="qr_solveCPP-1018">    ITASK = 2, to avoid the recomputation of the matrix factors.</front>
<front id="qr_solveCPP-1019">    The parameters KR, JPVT, and QRAUX must not be modified</front>
<front id="qr_solveCPP-1020">    between calls to DQRLS.</front>
<front id="qr_solveCPP-1021"></front>
<front id="qr_solveCPP-1022">    DQRLS is used to solve in a least squares sense</front>
<front id="qr_solveCPP-1023">    overdetermined, underdetermined and singular linear systems.</front>
<front id="qr_solveCPP-1024">    The system is A*X approximates B where A is M by N.</front>
<front id="qr_solveCPP-1025">    B is a given M-vector, and X is the N-vector to be computed.</front>
<front id="qr_solveCPP-1026">    A solution X is found which minimimzes the sum of squares (2-norm)</front>
<front id="qr_solveCPP-1027">    of the residual,  A*X - B.</front>
<front id="qr_solveCPP-1028"></front>
<front id="qr_solveCPP-1029">    The numerical rank of A is determined using the tolerance TOL.</front>
<front id="qr_solveCPP-1030"></front>
<front id="qr_solveCPP-1031">    DQRLS uses the LINPACK subroutine DQRDC to compute the QR</front>
<front id="qr_solveCPP-1032">    factorization, with column pivoting, of an M by N matrix A.</front>
<front id="qr_solveCPP-1033"></front>
<front id="qr_solveCPP-1034">  Licensing:</front>
<front id="qr_solveCPP-1035"></front>
<front id="qr_solveCPP-1036">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-1037"></front>
<front id="qr_solveCPP-1038">  Modified:</front>
<front id="qr_solveCPP-1039"></front>
<front id="qr_solveCPP-1040">    10 September 2012</front>
<front id="qr_solveCPP-1041"></front>
<front id="qr_solveCPP-1042">  Author:</front>
<front id="qr_solveCPP-1043"></front>
<front id="qr_solveCPP-1044">    C version by John Burkardt.</front>
<front id="qr_solveCPP-1045"></front>
<front id="qr_solveCPP-1046">  Reference:</front>
<front id="qr_solveCPP-1047"></front>
<front id="qr_solveCPP-1048">    David Kahaner, Cleve Moler, Steven Nash,</front>
<front id="qr_solveCPP-1049">    Numerical Methods and Software,</front>
<front id="qr_solveCPP-1050">    Prentice Hall, 1989,</front>
<front id="qr_solveCPP-1051">    ISBN: 0-13-627258-4,</front>
<front id="qr_solveCPP-1052">    LC: TA345.K34.</front>
<front id="qr_solveCPP-1053"></front>
<front id="qr_solveCPP-1054">  Parameters:</front>
<front id="qr_solveCPP-1055"></front>
<front id="qr_solveCPP-1056">    Input/output, double A[LDA*N], an M by N matrix.</front>
<front id="qr_solveCPP-1057">    On input, the matrix whose decomposition is to be computed.</front>
<front id="qr_solveCPP-1058">    In a least squares data fitting problem, A(I,J) is the</front>
<front id="qr_solveCPP-1059">    value of the J-th basis (model) function at the I-th data point.</front>
<front id="qr_solveCPP-1060">    On output, A contains the output from DQRDC.  The triangular matrix R</front>
<front id="qr_solveCPP-1061">    of the QR factorization is contained in the upper triangle and</front>
<front id="qr_solveCPP-1062">    information needed to recover the orthogonal matrix Q is stored</front>
<front id="qr_solveCPP-1063">    below the diagonal in A and in the vector QRAUX.</front>
<front id="qr_solveCPP-1064"></front>
<front id="qr_solveCPP-1065">    Input, int LDA, the leading dimension of A.</front>
<front id="qr_solveCPP-1066"></front>
<front id="qr_solveCPP-1067">    Input, int M, the number of rows of A.</front>
<front id="qr_solveCPP-1068"></front>
<front id="qr_solveCPP-1069">    Input, int N, the number of columns of A.</front>
<front id="qr_solveCPP-1070"></front>
<front id="qr_solveCPP-1071">    Input, double TOL, a relative tolerance used to determine the</front>
<front id="qr_solveCPP-1072">    numerical rank.  The problem should be scaled so that all the elements</front>
<front id="qr_solveCPP-1073">    of A have roughly the same absolute accuracy EPS.  Then a reasonable</front>
<front id="qr_solveCPP-1074">    value for TOL is roughly EPS divided by the magnitude of the largest</front>
<front id="qr_solveCPP-1075">    element.</front>
<front id="qr_solveCPP-1076"></front>
<front id="qr_solveCPP-1077">    Output, int *KR, the numerical rank.</front>
<front id="qr_solveCPP-1078"></front>
<front id="qr_solveCPP-1079">    Input, double B[M], the right hand side of the linear system.</front>
<front id="qr_solveCPP-1080"></front>
<front id="qr_solveCPP-1081">    Output, double X[N], a least squares solution to the linear</front>
<front id="qr_solveCPP-1082">    system.</front>
<front id="qr_solveCPP-1083"></front>
<front id="qr_solveCPP-1084">    Output, double RSD[M], the residual, B - A*X.  RSD may</front>
<front id="qr_solveCPP-1085">    overwrite B.</front>
<front id="qr_solveCPP-1086"></front>
<front id="qr_solveCPP-1087">    Workspace, int JPVT[N], required if ITASK = 1.</front>
<front id="qr_solveCPP-1088">    Columns JPVT(1), ..., JPVT(KR) of the original matrix are linearly</front>
<front id="qr_solveCPP-1089">    independent to within the tolerance TOL and the remaining columns</front>
<front id="qr_solveCPP-1090">    are linearly dependent.  ABS ( A(1,1) ) / ABS ( A(KR,KR) ) is an estimate</front>
<front id="qr_solveCPP-1091">    of the condition number of the matrix of independent columns,</front>
<front id="qr_solveCPP-1092">    and of R.  This estimate will be &lt;= 1/TOL.</front>
<front id="qr_solveCPP-1093"></front>
<front id="qr_solveCPP-1094">    Workspace, double QRAUX[N], required if ITASK = 1.</front>
<front id="qr_solveCPP-1095"></front>
<front id="qr_solveCPP-1096">    Input, int ITASK.</front>
<front id="qr_solveCPP-1097">    1, DQRLS factors the matrix A and solves the least squares problem.</front>
<front id="qr_solveCPP-1098">    2, DQRLS assumes that the matrix A was factored with an earlier</front>
<front id="qr_solveCPP-1099">       call to DQRLS, and only solves the least squares problem.</front>
<front id="qr_solveCPP-1100"></front>
<front id="qr_solveCPP-1101">    Output, int DQRLS, error code.</front>
<front id="qr_solveCPP-1102">    0:  no error</front>
<front id="qr_solveCPP-1103">    -1: LDA &lt; M   (fatal error)</front>
<front id="qr_solveCPP-1104">    -2: N &lt; 1     (fatal error)</front>
<front id="qr_solveCPP-1105">    -3: ITASK &lt; 1 (fatal error)</front>
<front id="qr_solveCPP-1106">*/</front>
<front id="qr_solveCPP-1107">{</front>
<front id="qr_solveCPP-1108">  int ind;</front>
<front id="qr_solveCPP-1109"></front>
<front id="qr_solveCPP-1110">  if ( lda &lt; m )</front>
<front id="qr_solveCPP-1111">  {</front>
<front id="qr_solveCPP-1112">    /*fprintf ( stderr, "\n" );</front>
<front id="qr_solveCPP-1113">    fprintf ( stderr, "DQRLS - Fatal error!\n" );</front>
<front id="qr_solveCPP-1114">    fprintf ( stderr, "  LDA &lt; M.\n" );*/</front>
<front id="qr_solveCPP-1115">    ind = -1;</front>
<front id="qr_solveCPP-1116">    return ind;</front>
<front id="qr_solveCPP-1117">  }</front>
<front id="qr_solveCPP-1118"></front>
<front id="qr_solveCPP-1119">  if ( n &lt;= 0 )</front>
<front id="qr_solveCPP-1120">  {</front>
<front id="qr_solveCPP-1121">    /*fprintf ( stderr, "\n" );</front>
<front id="qr_solveCPP-1122">    fprintf ( stderr, "DQRLS - Fatal error!\n" );</front>
<front id="qr_solveCPP-1123">    fprintf ( stderr, "  N &lt;= 0.\n" );*/</front>
<front id="qr_solveCPP-1124">    ind = -2;</front>
<front id="qr_solveCPP-1125">    return ind;</front>
<front id="qr_solveCPP-1126">  }</front>
<front id="qr_solveCPP-1127"></front>
<front id="qr_solveCPP-1128">  if ( itask &lt; 1 )</front>
<front id="qr_solveCPP-1129">  {</front>
<front id="qr_solveCPP-1130">    /*fprintf ( stderr, "\n" );</front>
<front id="qr_solveCPP-1131">    fprintf ( stderr, "DQRLS - Fatal error!\n" );</front>
<front id="qr_solveCPP-1132">    fprintf ( stderr, "  ITASK &lt; 1.\n" );*/</front>
<front id="qr_solveCPP-1133">    ind = -3;</front>
<front id="qr_solveCPP-1134">    return ind;</front>
<front id="qr_solveCPP-1135">  }</front>
<front id="qr_solveCPP-1136"></front>
<front id="qr_solveCPP-1137">  ind = 0;</front>
<front id="qr_solveCPP-1138">/*</front>
<front id="qr_solveCPP-1139">  Factor the matrix.</front>
<front id="qr_solveCPP-1140">*/</front>
<front id="qr_solveCPP-1141">  if ( itask == 1 )</front>
<front id="qr_solveCPP-1142">  {</front>
<front id="qr_solveCPP-1143">    dqrank ( a, lda, m, n, tol, kr, jpvt, qraux );</front>
<front id="qr_solveCPP-1144">  }</front>
<front id="qr_solveCPP-1145">/*</front>
<front id="qr_solveCPP-1146">  Solve the least-squares problem.</front>
<front id="qr_solveCPP-1147">*/</front>
<front id="qr_solveCPP-1148">  dqrlss ( a, lda, m, n, *kr, b, x, rsd, jpvt, qraux );</front>
<front id="qr_solveCPP-1149"></front>
<front id="qr_solveCPP-1150">  return ind;</front>
<front id="qr_solveCPP-1151">}</front>
<front id="qr_solveCPP-1152">/******************************************************************************/</front>
<front id="qr_solveCPP-1153"></front>
<front id="qr_solveCPP-1154">void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[], </front>
<front id="qr_solveCPP-1155">  double rsd[], int jpvt[], double qraux[] )</front>
<front id="qr_solveCPP-1156"></front>
<front id="qr_solveCPP-1157">/******************************************************************************/</front>
<front id="qr_solveCPP-1158">/*</front>
<front id="qr_solveCPP-1159">  Purpose:</front>
<front id="qr_solveCPP-1160"></front>
<front id="qr_solveCPP-1161">    DQRLSS solves a linear system in a least squares sense.</front>
<front id="qr_solveCPP-1162"></front>
<front id="qr_solveCPP-1163">  Discussion:</front>
<front id="qr_solveCPP-1164"></front>
<front id="qr_solveCPP-1165">    DQRLSS must be preceded by a call to DQRANK.</front>
<front id="qr_solveCPP-1166"></front>
<front id="qr_solveCPP-1167">    The system is to be solved is</front>
<front id="qr_solveCPP-1168">      A * X = B</front>
<front id="qr_solveCPP-1169">    where</front>
<front id="qr_solveCPP-1170">      A is an M by N matrix with rank KR, as determined by DQRANK,</front>
<front id="qr_solveCPP-1171">      B is a given M-vector,</front>
<front id="qr_solveCPP-1172">      X is the N-vector to be computed.</front>
<front id="qr_solveCPP-1173"></front>
<front id="qr_solveCPP-1174">    A solution X, with at most KR nonzero components, is found which</front>
<front id="qr_solveCPP-1175">    minimizes the 2-norm of the residual (A*X-B).</front>
<front id="qr_solveCPP-1176"></front>
<front id="qr_solveCPP-1177">    Once the matrix A has been formed, DQRANK should be</front>
<front id="qr_solveCPP-1178">    called once to decompose it.  Then, for each right hand</front>
<front id="qr_solveCPP-1179">    side B, DQRLSS should be called once to obtain the</front>
<front id="qr_solveCPP-1180">    solution and residual.</front>
<front id="qr_solveCPP-1181"></front>
<front id="qr_solveCPP-1182">  Licensing:</front>
<front id="qr_solveCPP-1183"></front>
<front id="qr_solveCPP-1184">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-1185"></front>
<front id="qr_solveCPP-1186">  Modified:</front>
<front id="qr_solveCPP-1187"></front>
<front id="qr_solveCPP-1188">    10 September 2012</front>
<front id="qr_solveCPP-1189"></front>
<front id="qr_solveCPP-1190">  Author:</front>
<front id="qr_solveCPP-1191"></front>
<front id="qr_solveCPP-1192">    C version by John Burkardt</front>
<front id="qr_solveCPP-1193"></front>
<front id="qr_solveCPP-1194">  Parameters:</front>
<front id="qr_solveCPP-1195"></front>
<front id="qr_solveCPP-1196">    Input, double A[LDA*N], the QR factorization information</front>
<front id="qr_solveCPP-1197">    from DQRANK.  The triangular matrix R of the QR factorization is</front>
<front id="qr_solveCPP-1198">    contained in the upper triangle and information needed to recover</front>
<front id="qr_solveCPP-1199">    the orthogonal matrix Q is stored below the diagonal in A and in</front>
<front id="qr_solveCPP-1200">    the vector QRAUX.</front>
<front id="qr_solveCPP-1201"></front>
<front id="qr_solveCPP-1202">    Input, int LDA, the leading dimension of A, which must</front>
<front id="qr_solveCPP-1203">    be at least M.</front>
<front id="qr_solveCPP-1204"></front>
<front id="qr_solveCPP-1205">    Input, int M, the number of rows of A.</front>
<front id="qr_solveCPP-1206"></front>
<front id="qr_solveCPP-1207">    Input, int N, the number of columns of A.</front>
<front id="qr_solveCPP-1208"></front>
<front id="qr_solveCPP-1209">    Input, int KR, the rank of the matrix, as estimated by DQRANK.</front>
<front id="qr_solveCPP-1210"></front>
<front id="qr_solveCPP-1211">    Input, double B[M], the right hand side of the linear system.</front>
<front id="qr_solveCPP-1212"></front>
<front id="qr_solveCPP-1213">    Output, double X[N], a least squares solution to the</front>
<front id="qr_solveCPP-1214">    linear system.</front>
<front id="qr_solveCPP-1215"></front>
<front id="qr_solveCPP-1216">    Output, double RSD[M], the residual, B - A*X.  RSD may</front>
<front id="qr_solveCPP-1217">    overwrite B.</front>
<front id="qr_solveCPP-1218"></front>
<front id="qr_solveCPP-1219">    Input, int JPVT[N], the pivot information from DQRANK.</front>
<front id="qr_solveCPP-1220">    Columns JPVT[0], ..., JPVT[KR-1] of the original matrix are linearly</front>
<front id="qr_solveCPP-1221">    independent to within the tolerance TOL and the remaining columns</front>
<front id="qr_solveCPP-1222">    are linearly dependent.</front>
<front id="qr_solveCPP-1223"></front>
<front id="qr_solveCPP-1224">    Input, double QRAUX[N], auxiliary information from DQRANK</front>
<front id="qr_solveCPP-1225">    defining the QR factorization.</front>
<front id="qr_solveCPP-1226">*/</front>
<front id="qr_solveCPP-1227">{</front>
<front id="qr_solveCPP-1228">  int i;</front>
<front id="qr_solveCPP-1229">  int info;</front>
<front id="qr_solveCPP-1230">  int j;</front>
<front id="qr_solveCPP-1231">  int job;</front>
<front id="qr_solveCPP-1232">  int k;</front>
<front id="qr_solveCPP-1233">  double t;</front>
<front id="qr_solveCPP-1234"></front>
<front id="qr_solveCPP-1235">  if ( kr != 0 )</front>
<front id="qr_solveCPP-1236">  {</front>
<front id="qr_solveCPP-1237">    job = 110;</front>
<front id="qr_solveCPP-1238">    info = dqrsl ( a, lda, m, kr, qraux, b, rsd, rsd, x, rsd, rsd, job );</front>
<front id="qr_solveCPP-1239">  }</front>
<front id="qr_solveCPP-1240"></front>
<front id="qr_solveCPP-1241">  for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-1242">  {</front>
<front id="qr_solveCPP-1243">    jpvt[i] = - jpvt[i];</front>
<front id="qr_solveCPP-1244">  }</front>
<front id="qr_solveCPP-1245"></front>
<front id="qr_solveCPP-1246">  for ( i = kr; i &lt; n; i++ )</front>
<front id="qr_solveCPP-1247">  {</front>
<front id="qr_solveCPP-1248">    x[i] = 0.0;</front>
<front id="qr_solveCPP-1249">  }</front>
<front id="qr_solveCPP-1250"></front>
<front id="qr_solveCPP-1251">  for ( j = 1; j &lt;= n; j++ )</front>
<front id="qr_solveCPP-1252">  {</front>
<front id="qr_solveCPP-1253">    if ( jpvt[j-1] &lt;= 0 )</front>
<front id="qr_solveCPP-1254">    {</front>
<front id="qr_solveCPP-1255">      k = - jpvt[j-1];</front>
<front id="qr_solveCPP-1256">      jpvt[j-1] = k;</front>
<front id="qr_solveCPP-1257"></front>
<front id="qr_solveCPP-1258">      while ( k != j )</front>
<front id="qr_solveCPP-1259">      {</front>
<front id="qr_solveCPP-1260">        t = x[j-1];</front>
<front id="qr_solveCPP-1261">        x[j-1] = x[k-1];</front>
<front id="qr_solveCPP-1262">        x[k-1] = t;</front>
<front id="qr_solveCPP-1263">        jpvt[k-1] = -jpvt[k-1];</front>
<front id="qr_solveCPP-1264">        k = jpvt[k-1];</front>
<front id="qr_solveCPP-1265">      }</front>
<front id="qr_solveCPP-1266">    }</front>
<front id="qr_solveCPP-1267">  }</front>
<front id="qr_solveCPP-1268">  return;</front>
<front id="qr_solveCPP-1269">}</front>
<front id="qr_solveCPP-1270">/******************************************************************************/</front>
<front id="qr_solveCPP-1271"></front>
<front id="qr_solveCPP-1272">int dqrsl ( double a[], int lda, int n, int k, double qraux[], double y[], </front>
<front id="qr_solveCPP-1273">  double qy[], double qty[], double b[], double rsd[], double ab[], int job )</front>
<front id="qr_solveCPP-1274"></front>
<front id="qr_solveCPP-1275">/******************************************************************************/</front>
<front id="qr_solveCPP-1276">/*</front>
<front id="qr_solveCPP-1277">  Purpose:</front>
<front id="qr_solveCPP-1278"></front>
<front id="qr_solveCPP-1279">    DQRSL computes transformations, projections, and least squares solutions.</front>
<front id="qr_solveCPP-1280"></front>
<front id="qr_solveCPP-1281">  Discussion:</front>
<front id="qr_solveCPP-1282"></front>
<front id="qr_solveCPP-1283">    DQRSL requires the output of DQRDC.</front>
<front id="qr_solveCPP-1284"></front>
<front id="qr_solveCPP-1285">    For K &lt;= min(N,P), let AK be the matrix</front>
<front id="qr_solveCPP-1286"></front>
<front id="qr_solveCPP-1287">      AK = ( A(JPVT[0]), A(JPVT(2)), ..., A(JPVT(K)) )</front>
<front id="qr_solveCPP-1288"></front>
<front id="qr_solveCPP-1289">    formed from columns JPVT[0], ..., JPVT(K) of the original</front>
<front id="qr_solveCPP-1290">    N by P matrix A that was input to DQRDC.  If no pivoting was</front>
<front id="qr_solveCPP-1291">    done, AK consists of the first K columns of A in their</front>
<front id="qr_solveCPP-1292">    original order.  DQRDC produces a factored orthogonal matrix Q</front>
<front id="qr_solveCPP-1293">    and an upper triangular matrix R such that</front>
<front id="qr_solveCPP-1294"></front>
<front id="qr_solveCPP-1295">      AK = Q * (R)</front>
<front id="qr_solveCPP-1296">               (0)</front>
<front id="qr_solveCPP-1297"></front>
<front id="qr_solveCPP-1298">    This information is contained in coded form in the arrays</front>
<front id="qr_solveCPP-1299">    A and QRAUX.</front>
<front id="qr_solveCPP-1300"></front>
<front id="qr_solveCPP-1301">    The parameters QY, QTY, B, RSD, and AB are not referenced</front>
<front id="qr_solveCPP-1302">    if their computation is not requested and in this case</front>
<front id="qr_solveCPP-1303">    can be replaced by dummy variables in the calling program.</front>
<front id="qr_solveCPP-1304">    To save storage, the user may in some cases use the same</front>
<front id="qr_solveCPP-1305">    array for different parameters in the calling sequence.  A</front>
<front id="qr_solveCPP-1306">    frequently occurring example is when one wishes to compute</front>
<front id="qr_solveCPP-1307">    any of B, RSD, or AB and does not need Y or QTY.  In this</front>
<front id="qr_solveCPP-1308">    case one may identify Y, QTY, and one of B, RSD, or AB, while</front>
<front id="qr_solveCPP-1309">    providing separate arrays for anything else that is to be</front>
<front id="qr_solveCPP-1310">    computed.</front>
<front id="qr_solveCPP-1311"></front>
<front id="qr_solveCPP-1312">    Thus the calling sequence</front>
<front id="qr_solveCPP-1313"></front>
<front id="qr_solveCPP-1314">      dqrsl ( a, lda, n, k, qraux, y, dum, y, b, y, dum, 110, info )</front>
<front id="qr_solveCPP-1315"></front>
<front id="qr_solveCPP-1316">    will result in the computation of B and RSD, with RSD</front>
<front id="qr_solveCPP-1317">    overwriting Y.  More generally, each item in the following</front>
<front id="qr_solveCPP-1318">    list contains groups of permissible identifications for</front>
<front id="qr_solveCPP-1319">    a single calling sequence.</front>
<front id="qr_solveCPP-1320"></front>
<front id="qr_solveCPP-1321">      1. (Y,QTY,B) (RSD) (AB) (QY)</front>
<front id="qr_solveCPP-1322"></front>
<front id="qr_solveCPP-1323">      2. (Y,QTY,RSD) (B) (AB) (QY)</front>
<front id="qr_solveCPP-1324"></front>
<front id="qr_solveCPP-1325">      3. (Y,QTY,AB) (B) (RSD) (QY)</front>
<front id="qr_solveCPP-1326"></front>
<front id="qr_solveCPP-1327">      4. (Y,QY) (QTY,B) (RSD) (AB)</front>
<front id="qr_solveCPP-1328"></front>
<front id="qr_solveCPP-1329">      5. (Y,QY) (QTY,RSD) (B) (AB)</front>
<front id="qr_solveCPP-1330"></front>
<front id="qr_solveCPP-1331">      6. (Y,QY) (QTY,AB) (B) (RSD)</front>
<front id="qr_solveCPP-1332"></front>
<front id="qr_solveCPP-1333">    In any group the value returned in the array allocated to</front>
<front id="qr_solveCPP-1334">    the group corresponds to the last member of the group.</front>
<front id="qr_solveCPP-1335"></front>
<front id="qr_solveCPP-1336">  Licensing:</front>
<front id="qr_solveCPP-1337"></front>
<front id="qr_solveCPP-1338">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-1339"></front>
<front id="qr_solveCPP-1340">  Modified:</front>
<front id="qr_solveCPP-1341"></front>
<front id="qr_solveCPP-1342">    07 June 2005</front>
<front id="qr_solveCPP-1343"></front>
<front id="qr_solveCPP-1344">  Author:</front>
<front id="qr_solveCPP-1345"></front>
<front id="qr_solveCPP-1346">    C version by John Burkardt.</front>
<front id="qr_solveCPP-1347"></front>
<front id="qr_solveCPP-1348">  Reference:</front>
<front id="qr_solveCPP-1349"></front>
<front id="qr_solveCPP-1350">    Jack Dongarra, Cleve Moler, Jim Bunch and Pete Stewart,</front>
<front id="qr_solveCPP-1351">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-1352">    SIAM, (Society for Industrial and Applied Mathematics),</front>
<front id="qr_solveCPP-1353">    3600 University City Science Center,</front>
<front id="qr_solveCPP-1354">    Philadelphia, PA, 19104-2688.</front>
<front id="qr_solveCPP-1355">    ISBN 0-89871-172-X</front>
<front id="qr_solveCPP-1356"></front>
<front id="qr_solveCPP-1357">  Parameters:</front>
<front id="qr_solveCPP-1358"></front>
<front id="qr_solveCPP-1359">    Input, double A[LDA*P], contains the output of DQRDC.</front>
<front id="qr_solveCPP-1360"></front>
<front id="qr_solveCPP-1361">    Input, int LDA, the leading dimension of the array A.</front>
<front id="qr_solveCPP-1362"></front>
<front id="qr_solveCPP-1363">    Input, int N, the number of rows of the matrix AK.  It must</front>
<front id="qr_solveCPP-1364">    have the same value as N in DQRDC.</front>
<front id="qr_solveCPP-1365"></front>
<front id="qr_solveCPP-1366">    Input, int K, the number of columns of the matrix AK.  K</front>
<front id="qr_solveCPP-1367">    must not be greater than min(N,P), where P is the same as in the</front>
<front id="qr_solveCPP-1368">    calling sequence to DQRDC.</front>
<front id="qr_solveCPP-1369"></front>
<front id="qr_solveCPP-1370">    Input, double QRAUX[P], the auxiliary output from DQRDC.</front>
<front id="qr_solveCPP-1371"></front>
<front id="qr_solveCPP-1372">    Input, double Y[N], a vector to be manipulated by DQRSL.</front>
<front id="qr_solveCPP-1373"></front>
<front id="qr_solveCPP-1374">    Output, double QY[N], contains Q * Y, if requested.</front>
<front id="qr_solveCPP-1375"></front>
<front id="qr_solveCPP-1376">    Output, double QTY[N], contains Q' * Y, if requested.</front>
<front id="qr_solveCPP-1377"></front>
<front id="qr_solveCPP-1378">    Output, double B[K], the solution of the least squares problem</front>
<front id="qr_solveCPP-1379">      minimize norm2 ( Y - AK * B),</front>
<front id="qr_solveCPP-1380">    if its computation has been requested.  Note that if pivoting was</front>
<front id="qr_solveCPP-1381">    requested in DQRDC, the J-th component of B will be associated with</front>
<front id="qr_solveCPP-1382">    column JPVT(J) of the original matrix A that was input into DQRDC.</front>
<front id="qr_solveCPP-1383"></front>
<front id="qr_solveCPP-1384">    Output, double RSD[N], the least squares residual Y - AK * B,</front>
<front id="qr_solveCPP-1385">    if its computation has been requested.  RSD is also the orthogonal</front>
<front id="qr_solveCPP-1386">    projection of Y onto the orthogonal complement of the column space</front>
<front id="qr_solveCPP-1387">    of AK.</front>
<front id="qr_solveCPP-1388"></front>
<front id="qr_solveCPP-1389">    Output, double AB[N], the least squares approximation Ak * B,</front>
<front id="qr_solveCPP-1390">    if its computation has been requested.  AB is also the orthogonal</front>
<front id="qr_solveCPP-1391">    projection of Y onto the column space of A.</front>
<front id="qr_solveCPP-1392"></front>
<front id="qr_solveCPP-1393">    Input, integer JOB, specifies what is to be computed.  JOB has</front>
<front id="qr_solveCPP-1394">    the decimal expansion ABCDE, with the following meaning:</front>
<front id="qr_solveCPP-1395"></front>
<front id="qr_solveCPP-1396">      if A != 0, compute QY.</front>
<front id="qr_solveCPP-1397">      if B != 0, compute QTY.</front>
<front id="qr_solveCPP-1398">      if C != 0, compute QTY and B.</front>
<front id="qr_solveCPP-1399">      if D != 0, compute QTY and RSD.</front>
<front id="qr_solveCPP-1400">      if E != 0, compute QTY and AB.</front>
<front id="qr_solveCPP-1401"></front>
<front id="qr_solveCPP-1402">    Note that a request to compute B, RSD, or AB automatically triggers</front>
<front id="qr_solveCPP-1403">    the computation of QTY, for which an array must be provided in the</front>
<front id="qr_solveCPP-1404">    calling sequence.</front>
<front id="qr_solveCPP-1405"></front>
<front id="qr_solveCPP-1406">    Output, int DQRSL, is zero unless the computation of B has</front>
<front id="qr_solveCPP-1407">    been requested and R is exactly singular.  In this case, INFO is the</front>
<front id="qr_solveCPP-1408">    index of the first zero diagonal element of R, and B is left unaltered.</front>
<front id="qr_solveCPP-1409">*/</front>
<front id="qr_solveCPP-1410">{</front>
<front id="qr_solveCPP-1411">  int cab;</front>
<front id="qr_solveCPP-1412">  int cb;</front>
<front id="qr_solveCPP-1413">  int cqty;</front>
<front id="qr_solveCPP-1414">  int cqy;</front>
<front id="qr_solveCPP-1415">  int cr;</front>
<front id="qr_solveCPP-1416">  int i;</front>
<front id="qr_solveCPP-1417">  int info;</front>
<front id="qr_solveCPP-1418">  int j;</front>
<front id="qr_solveCPP-1419">  int jj;</front>
<front id="qr_solveCPP-1420">  int ju;</front>
<front id="qr_solveCPP-1421">  double t;</front>
<front id="qr_solveCPP-1422">  double temp;</front>
<front id="qr_solveCPP-1423">/*</front>
<front id="qr_solveCPP-1424">  Set INFO flag.</front>
<front id="qr_solveCPP-1425">*/</front>
<front id="qr_solveCPP-1426">  info = 0;</front>
<front id="qr_solveCPP-1427">/*</front>
<front id="qr_solveCPP-1428">  Determine what is to be computed.</front>
<front id="qr_solveCPP-1429">*/</front>
<front id="qr_solveCPP-1430">  cqy =  (   job / 10000          != 0 );</front>
<front id="qr_solveCPP-1431">  cqty = ( ( job %  10000 )       != 0 );</front>
<front id="qr_solveCPP-1432">  cb =   ( ( job %   1000 ) / 100 != 0 );</front>
<front id="qr_solveCPP-1433">  cr =   ( ( job %    100 ) /  10 != 0 );</front>
<front id="qr_solveCPP-1434">  cab =  ( ( job %     10 )       != 0 );</front>
<front id="qr_solveCPP-1435"></front>
<front id="qr_solveCPP-1436">  ju = i4_min ( k, n-1 );</front>
<front id="qr_solveCPP-1437">/*</front>
<front id="qr_solveCPP-1438">  Special action when N = 1.</front>
<front id="qr_solveCPP-1439">*/</front>
<front id="qr_solveCPP-1440">  if ( ju == 0 )</front>
<front id="qr_solveCPP-1441">  {</front>
<front id="qr_solveCPP-1442">    if ( cqy )</front>
<front id="qr_solveCPP-1443">    {</front>
<front id="qr_solveCPP-1444">      qy[0] = y[0];</front>
<front id="qr_solveCPP-1445">    }</front>
<front id="qr_solveCPP-1446"></front>
<front id="qr_solveCPP-1447">    if ( cqty )</front>
<front id="qr_solveCPP-1448">    {</front>
<front id="qr_solveCPP-1449">      qty[0] = y[0];</front>
<front id="qr_solveCPP-1450">    }</front>
<front id="qr_solveCPP-1451"></front>
<front id="qr_solveCPP-1452">    if ( cab )</front>
<front id="qr_solveCPP-1453">    {</front>
<front id="qr_solveCPP-1454">      ab[0] = y[0];</front>
<front id="qr_solveCPP-1455">    }</front>
<front id="qr_solveCPP-1456"></front>
<front id="qr_solveCPP-1457">    if ( cb )</front>
<front id="qr_solveCPP-1458">    {</front>
<front id="qr_solveCPP-1459">      if ( a[0+0*lda] == 0.0 )</front>
<front id="qr_solveCPP-1460">      {</front>
<front id="qr_solveCPP-1461">        info = 1;</front>
<front id="qr_solveCPP-1462">      }</front>
<front id="qr_solveCPP-1463">      else</front>
<front id="qr_solveCPP-1464">      {</front>
<front id="qr_solveCPP-1465">        b[0] = y[0] / a[0+0*lda];</front>
<front id="qr_solveCPP-1466">      }</front>
<front id="qr_solveCPP-1467">    }</front>
<front id="qr_solveCPP-1468"></front>
<front id="qr_solveCPP-1469">    if ( cr )</front>
<front id="qr_solveCPP-1470">    {</front>
<front id="qr_solveCPP-1471">      rsd[0] = 0.0;</front>
<front id="qr_solveCPP-1472">    }</front>
<front id="qr_solveCPP-1473">    return info;</front>
<front id="qr_solveCPP-1474">  }</front>
<front id="qr_solveCPP-1475">/*</front>
<front id="qr_solveCPP-1476">  Set up to compute QY or QTY.</front>
<front id="qr_solveCPP-1477">*/</front>
<front id="qr_solveCPP-1478">  if ( cqy )</front>
<front id="qr_solveCPP-1479">  {</front>
<front id="qr_solveCPP-1480">    for ( i = 1; i &lt;= n; i++ )</front>
<front id="qr_solveCPP-1481">    {</front>
<front id="qr_solveCPP-1482">      qy[i-1] = y[i-1];</front>
<front id="qr_solveCPP-1483">    }</front>
<front id="qr_solveCPP-1484">  }</front>
<front id="qr_solveCPP-1485"></front>
<front id="qr_solveCPP-1486">  if ( cqty )</front>
<front id="qr_solveCPP-1487">  {</front>
<front id="qr_solveCPP-1488">    for ( i = 1; i &lt;= n; i++ )</front>
<front id="qr_solveCPP-1489">    {</front>
<front id="qr_solveCPP-1490">      qty[i-1] = y[i-1];</front>
<front id="qr_solveCPP-1491">    }</front>
<front id="qr_solveCPP-1492">  }</front>
<front id="qr_solveCPP-1493">/*</front>
<front id="qr_solveCPP-1494">  Compute QY.</front>
<front id="qr_solveCPP-1495">*/</front>
<front id="qr_solveCPP-1496">  if ( cqy )</front>
<front id="qr_solveCPP-1497">  {</front>
<front id="qr_solveCPP-1498">    for ( jj = 1; jj &lt;= ju; jj++ )</front>
<front id="qr_solveCPP-1499">    {</front>
<front id="qr_solveCPP-1500">      j = ju - jj + 1;</front>
<front id="qr_solveCPP-1501"></front>
<front id="qr_solveCPP-1502">      if ( qraux[j-1] != 0.0 )</front>
<front id="qr_solveCPP-1503">      {</front>
<front id="qr_solveCPP-1504">        temp = a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1505">        a[j-1+(j-1)*lda] = qraux[j-1];</front>
<front id="qr_solveCPP-1506">        t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, qy+j-1, 1 ) / a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1507">        daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, qy+j-1, 1 );</front>
<front id="qr_solveCPP-1508">        a[j-1+(j-1)*lda] = temp;</front>
<front id="qr_solveCPP-1509">      }</front>
<front id="qr_solveCPP-1510">    }</front>
<front id="qr_solveCPP-1511">  }</front>
<front id="qr_solveCPP-1512">/*</front>
<front id="qr_solveCPP-1513">  Compute Q'*Y.</front>
<front id="qr_solveCPP-1514">*/</front>
<front id="qr_solveCPP-1515">  if ( cqty )</front>
<front id="qr_solveCPP-1516">  {</front>
<front id="qr_solveCPP-1517">    for ( j = 1; j &lt;= ju; j++ )</front>
<front id="qr_solveCPP-1518">    {</front>
<front id="qr_solveCPP-1519">      if ( qraux[j-1] != 0.0 )</front>
<front id="qr_solveCPP-1520">      {</front>
<front id="qr_solveCPP-1521">        temp = a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1522">        a[j-1+(j-1)*lda] = qraux[j-1];</front>
<front id="qr_solveCPP-1523">        t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, qty+j-1, 1 ) / a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1524">        daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, qty+j-1, 1 );</front>
<front id="qr_solveCPP-1525">        a[j-1+(j-1)*lda] = temp;</front>
<front id="qr_solveCPP-1526">      }</front>
<front id="qr_solveCPP-1527">    }</front>
<front id="qr_solveCPP-1528">  }</front>
<front id="qr_solveCPP-1529">/*</front>
<front id="qr_solveCPP-1530">  Set up to compute B, RSD, or AB.</front>
<front id="qr_solveCPP-1531">*/</front>
<front id="qr_solveCPP-1532">  if ( cb )</front>
<front id="qr_solveCPP-1533">  {</front>
<front id="qr_solveCPP-1534">    for ( i = 1; i &lt;= k; i++ )</front>
<front id="qr_solveCPP-1535">    {</front>
<front id="qr_solveCPP-1536">      b[i-1] = qty[i-1];</front>
<front id="qr_solveCPP-1537">    }</front>
<front id="qr_solveCPP-1538">  }</front>
<front id="qr_solveCPP-1539"></front>
<front id="qr_solveCPP-1540">  if ( cab )</front>
<front id="qr_solveCPP-1541">  {</front>
<front id="qr_solveCPP-1542">    for ( i = 1; i &lt;= k; i++ )</front>
<front id="qr_solveCPP-1543">    {</front>
<front id="qr_solveCPP-1544">      ab[i-1] = qty[i-1];</front>
<front id="qr_solveCPP-1545">    }</front>
<front id="qr_solveCPP-1546">  }</front>
<front id="qr_solveCPP-1547"></front>
<front id="qr_solveCPP-1548">  if ( cr && k &lt; n )</front>
<front id="qr_solveCPP-1549">  {</front>
<front id="qr_solveCPP-1550">    for ( i = k+1; i &lt;= n; i++ )</front>
<front id="qr_solveCPP-1551">    {</front>
<front id="qr_solveCPP-1552">      rsd[i-1] = qty[i-1];</front>
<front id="qr_solveCPP-1553">    }</front>
<front id="qr_solveCPP-1554">  }</front>
<front id="qr_solveCPP-1555"></front>
<front id="qr_solveCPP-1556">  if ( cab && k+1 &lt;= n )</front>
<front id="qr_solveCPP-1557">  {</front>
<front id="qr_solveCPP-1558">    for ( i = k+1; i &lt;= n; i++ )</front>
<front id="qr_solveCPP-1559">    {</front>
<front id="qr_solveCPP-1560">      ab[i-1] = 0.0;</front>
<front id="qr_solveCPP-1561">    }</front>
<front id="qr_solveCPP-1562">  }</front>
<front id="qr_solveCPP-1563"></front>
<front id="qr_solveCPP-1564">  if ( cr )</front>
<front id="qr_solveCPP-1565">  {</front>
<front id="qr_solveCPP-1566">    for ( i = 1; i &lt;= k; i++ )</front>
<front id="qr_solveCPP-1567">    {</front>
<front id="qr_solveCPP-1568">      rsd[i-1] = 0.0;</front>
<front id="qr_solveCPP-1569">    }</front>
<front id="qr_solveCPP-1570">  }</front>
<front id="qr_solveCPP-1571">/*</front>
<front id="qr_solveCPP-1572">  Compute B.</front>
<front id="qr_solveCPP-1573">*/</front>
<front id="qr_solveCPP-1574">  if ( cb )</front>
<front id="qr_solveCPP-1575">  {</front>
<front id="qr_solveCPP-1576">    for ( jj = 1; jj &lt;= k; jj++ )</front>
<front id="qr_solveCPP-1577">    {</front>
<front id="qr_solveCPP-1578">      j = k - jj + 1;</front>
<front id="qr_solveCPP-1579"></front>
<front id="qr_solveCPP-1580">      if ( a[j-1+(j-1)*lda] == 0.0 )</front>
<front id="qr_solveCPP-1581">      {</front>
<front id="qr_solveCPP-1582">        info = j;</front>
<front id="qr_solveCPP-1583">        break;</front>
<front id="qr_solveCPP-1584">      }</front>
<front id="qr_solveCPP-1585"></front>
<front id="qr_solveCPP-1586">      b[j-1] = b[j-1] / a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1587"></front>
<front id="qr_solveCPP-1588">      if ( j != 1 )</front>
<front id="qr_solveCPP-1589">      {</front>
<front id="qr_solveCPP-1590">        t = -b[j-1];</front>
<front id="qr_solveCPP-1591">        daxpy ( j-1, t, a+0+(j-1)*lda, 1, b, 1 );</front>
<front id="qr_solveCPP-1592">      }</front>
<front id="qr_solveCPP-1593">    }</front>
<front id="qr_solveCPP-1594">  }</front>
<front id="qr_solveCPP-1595">/*</front>
<front id="qr_solveCPP-1596">  Compute RSD or AB as required.</front>
<front id="qr_solveCPP-1597">*/</front>
<front id="qr_solveCPP-1598">  if ( cr || cab )</front>
<front id="qr_solveCPP-1599">  {</front>
<front id="qr_solveCPP-1600">    for ( jj = 1; jj &lt;= ju; jj++ )</front>
<front id="qr_solveCPP-1601">    {</front>
<front id="qr_solveCPP-1602">      j = ju - jj + 1;</front>
<front id="qr_solveCPP-1603"></front>
<front id="qr_solveCPP-1604">      if ( qraux[j-1] != 0.0 )</front>
<front id="qr_solveCPP-1605">      {</front>
<front id="qr_solveCPP-1606">        temp = a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1607">        a[j-1+(j-1)*lda] = qraux[j-1];</front>
<front id="qr_solveCPP-1608"></front>
<front id="qr_solveCPP-1609">        if ( cr )</front>
<front id="qr_solveCPP-1610">        {</front>
<front id="qr_solveCPP-1611">          t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, rsd+j-1, 1 ) </front>
<front id="qr_solveCPP-1612">            / a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1613">          daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, rsd+j-1, 1 );</front>
<front id="qr_solveCPP-1614">        }</front>
<front id="qr_solveCPP-1615"></front>
<front id="qr_solveCPP-1616">        if ( cab )</front>
<front id="qr_solveCPP-1617">        {</front>
<front id="qr_solveCPP-1618">          t = -ddot ( n-j+1, a+j-1+(j-1)*lda, 1, ab+j-1, 1 ) </front>
<front id="qr_solveCPP-1619">            / a[j-1+(j-1)*lda];</front>
<front id="qr_solveCPP-1620">          daxpy ( n-j+1, t, a+j-1+(j-1)*lda, 1, ab+j-1, 1 );</front>
<front id="qr_solveCPP-1621">        }</front>
<front id="qr_solveCPP-1622">        a[j-1+(j-1)*lda] = temp;</front>
<front id="qr_solveCPP-1623">      }</front>
<front id="qr_solveCPP-1624">    }</front>
<front id="qr_solveCPP-1625">  }</front>
<front id="qr_solveCPP-1626"></front>
<front id="qr_solveCPP-1627">  return info;</front>
<front id="qr_solveCPP-1628">}</front>
<front id="qr_solveCPP-1629">/******************************************************************************/</front>
<front id="qr_solveCPP-1630"></front>
<front id="qr_solveCPP-1631">/******************************************************************************/</front>
<front id="qr_solveCPP-1632"></front>
<front id="qr_solveCPP-1633">void dscal ( int n, double sa, double x[], int incx )</front>
<front id="qr_solveCPP-1634"></front>
<front id="qr_solveCPP-1635">/******************************************************************************/</front>
<front id="qr_solveCPP-1636">/*</front>
<front id="qr_solveCPP-1637">  Purpose:</front>
<front id="qr_solveCPP-1638"></front>
<front id="qr_solveCPP-1639">    DSCAL scales a vector by a constant.</front>
<front id="qr_solveCPP-1640"></front>
<front id="qr_solveCPP-1641">  Licensing:</front>
<front id="qr_solveCPP-1642"></front>
<front id="qr_solveCPP-1643">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-1644"></front>
<front id="qr_solveCPP-1645">  Modified:</front>
<front id="qr_solveCPP-1646"></front>
<front id="qr_solveCPP-1647">    30 March 2007</front>
<front id="qr_solveCPP-1648"></front>
<front id="qr_solveCPP-1649">  Author:</front>
<front id="qr_solveCPP-1650"></front>
<front id="qr_solveCPP-1651">    C version by John Burkardt</front>
<front id="qr_solveCPP-1652"></front>
<front id="qr_solveCPP-1653">  Reference:</front>
<front id="qr_solveCPP-1654"></front>
<front id="qr_solveCPP-1655">    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,</front>
<front id="qr_solveCPP-1656">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-1657">    SIAM, 1979.</front>
<front id="qr_solveCPP-1658"></front>
<front id="qr_solveCPP-1659">    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,</front>
<front id="qr_solveCPP-1660">    Basic Linear Algebra Subprograms for Fortran Usage,</front>
<front id="qr_solveCPP-1661">    Algorithm 539,</front>
<front id="qr_solveCPP-1662">    ACM Transactions on Mathematical Software,</front>
<front id="qr_solveCPP-1663">    Volume 5, Number 3, September 1979, pages 308-323.</front>
<front id="qr_solveCPP-1664"></front>
<front id="qr_solveCPP-1665">  Parameters:</front>
<front id="qr_solveCPP-1666"></front>
<front id="qr_solveCPP-1667">    Input, int N, the number of entries in the vector.</front>
<front id="qr_solveCPP-1668"></front>
<front id="qr_solveCPP-1669">    Input, double SA, the multiplier.</front>
<front id="qr_solveCPP-1670"></front>
<front id="qr_solveCPP-1671">    Input/output, double X[*], the vector to be scaled.</front>
<front id="qr_solveCPP-1672"></front>
<front id="qr_solveCPP-1673">    Input, int INCX, the increment between successive entries of X.</front>
<front id="qr_solveCPP-1674">*/</front>
<front id="qr_solveCPP-1675">{</front>
<front id="qr_solveCPP-1676">  int i;</front>
<front id="qr_solveCPP-1677">  int ix;</front>
<front id="qr_solveCPP-1678">  int m;</front>
<front id="qr_solveCPP-1679"></front>
<front id="qr_solveCPP-1680">  if ( n &lt;= 0 )</front>
<front id="qr_solveCPP-1681">  {</front>
<front id="qr_solveCPP-1682">  }</front>
<front id="qr_solveCPP-1683">  else if ( incx == 1 )</front>
<front id="qr_solveCPP-1684">  {</front>
<front id="qr_solveCPP-1685">    m = n % 5;</front>
<front id="qr_solveCPP-1686"></front>
<front id="qr_solveCPP-1687">    for ( i = 0; i &lt; m; i++ )</front>
<front id="qr_solveCPP-1688">    {</front>
<front id="qr_solveCPP-1689">      x[i] = sa * x[i];</front>
<front id="qr_solveCPP-1690">    }</front>
<front id="qr_solveCPP-1691"></front>
<front id="qr_solveCPP-1692">    for ( i = m; i &lt; n; i = i + 5 )</front>
<front id="qr_solveCPP-1693">    {</front>
<front id="qr_solveCPP-1694">      x[i]   = sa * x[i];</front>
<front id="qr_solveCPP-1695">      x[i+1] = sa * x[i+1];</front>
<front id="qr_solveCPP-1696">      x[i+2] = sa * x[i+2];</front>
<front id="qr_solveCPP-1697">      x[i+3] = sa * x[i+3];</front>
<front id="qr_solveCPP-1698">      x[i+4] = sa * x[i+4];</front>
<front id="qr_solveCPP-1699">    }</front>
<front id="qr_solveCPP-1700">  }</front>
<front id="qr_solveCPP-1701">  else</front>
<front id="qr_solveCPP-1702">  {</front>
<front id="qr_solveCPP-1703">    if ( 0 &lt;= incx )</front>
<front id="qr_solveCPP-1704">    {</front>
<front id="qr_solveCPP-1705">      ix = 0;</front>
<front id="qr_solveCPP-1706">    }</front>
<front id="qr_solveCPP-1707">    else</front>
<front id="qr_solveCPP-1708">    {</front>
<front id="qr_solveCPP-1709">      ix = ( - n + 1 ) * incx;</front>
<front id="qr_solveCPP-1710">    }</front>
<front id="qr_solveCPP-1711"></front>
<front id="qr_solveCPP-1712">    for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-1713">    {</front>
<front id="qr_solveCPP-1714">      x[ix] = sa * x[ix];</front>
<front id="qr_solveCPP-1715">      ix = ix + incx;</front>
<front id="qr_solveCPP-1716">    }</front>
<front id="qr_solveCPP-1717">  }</front>
<front id="qr_solveCPP-1718">  return;</front>
<front id="qr_solveCPP-1719">}</front>
<front id="qr_solveCPP-1720">/******************************************************************************/</front>
<front id="qr_solveCPP-1721"></front>
<front id="qr_solveCPP-1722"></front>
<front id="qr_solveCPP-1723">void dswap ( int n, double x[], int incx, double y[], int incy )</front>
<front id="qr_solveCPP-1724"></front>
<front id="qr_solveCPP-1725">/******************************************************************************/</front>
<front id="qr_solveCPP-1726">/*</front>
<front id="qr_solveCPP-1727">  Purpose:</front>
<front id="qr_solveCPP-1728"></front>
<front id="qr_solveCPP-1729">    DSWAP interchanges two vectors.</front>
<front id="qr_solveCPP-1730"></front>
<front id="qr_solveCPP-1731">  Licensing:</front>
<front id="qr_solveCPP-1732"></front>
<front id="qr_solveCPP-1733">    This code is distributed under the GNU LGPL license. </front>
<front id="qr_solveCPP-1734"></front>
<front id="qr_solveCPP-1735">  Modified:</front>
<front id="qr_solveCPP-1736"></front>
<front id="qr_solveCPP-1737">    30 March 2007</front>
<front id="qr_solveCPP-1738"></front>
<front id="qr_solveCPP-1739">  Author:</front>
<front id="qr_solveCPP-1740"></front>
<front id="qr_solveCPP-1741">    C version by John Burkardt</front>
<front id="qr_solveCPP-1742"></front>
<front id="qr_solveCPP-1743">  Reference:</front>
<front id="qr_solveCPP-1744"></front>
<front id="qr_solveCPP-1745">    Jack Dongarra, Cleve Moler, Jim Bunch, Pete Stewart,</front>
<front id="qr_solveCPP-1746">    LINPACK User's Guide,</front>
<front id="qr_solveCPP-1747">    SIAM, 1979.</front>
<front id="qr_solveCPP-1748"></front>
<front id="qr_solveCPP-1749">    Charles Lawson, Richard Hanson, David Kincaid, Fred Krogh,</front>
<front id="qr_solveCPP-1750">    Basic Linear Algebra Subprograms for Fortran Usage,</front>
<front id="qr_solveCPP-1751">    Algorithm 539, </front>
<front id="qr_solveCPP-1752">    ACM Transactions on Mathematical Software, </front>
<front id="qr_solveCPP-1753">    Volume 5, Number 3, September 1979, pages 308-323.</front>
<front id="qr_solveCPP-1754"></front>
<front id="qr_solveCPP-1755">  Parameters:</front>
<front id="qr_solveCPP-1756"></front>
<front id="qr_solveCPP-1757">    Input, int N, the number of entries in the vectors.</front>
<front id="qr_solveCPP-1758"></front>
<front id="qr_solveCPP-1759">    Input/output, double X[*], one of the vectors to swap.</front>
<front id="qr_solveCPP-1760"></front>
<front id="qr_solveCPP-1761">    Input, int INCX, the increment between successive entries of X.</front>
<front id="qr_solveCPP-1762"></front>
<front id="qr_solveCPP-1763">    Input/output, double Y[*], one of the vectors to swap.</front>
<front id="qr_solveCPP-1764"></front>
<front id="qr_solveCPP-1765">    Input, int INCY, the increment between successive elements of Y.</front>
<front id="qr_solveCPP-1766">*/</front>
<front id="qr_solveCPP-1767">{</front>
<front id="qr_solveCPP-1768">  int i;</front>
<front id="qr_solveCPP-1769">  int ix;</front>
<front id="qr_solveCPP-1770">  int iy;</front>
<front id="qr_solveCPP-1771">  int m;</front>
<front id="qr_solveCPP-1772">  double temp;</front>
<front id="qr_solveCPP-1773"></front>
<front id="qr_solveCPP-1774">  if ( n &lt;= 0 )</front>
<front id="qr_solveCPP-1775">  {</front>
<front id="qr_solveCPP-1776">  }</front>
<front id="qr_solveCPP-1777">  else if ( incx == 1 && incy == 1 )</front>
<front id="qr_solveCPP-1778">  {</front>
<front id="qr_solveCPP-1779">    m = n % 3;</front>
<front id="qr_solveCPP-1780"></front>
<front id="qr_solveCPP-1781">    for ( i = 0; i &lt; m; i++ )</front>
<front id="qr_solveCPP-1782">    {</front>
<front id="qr_solveCPP-1783">      temp = x[i];</front>
<front id="qr_solveCPP-1784">      x[i] = y[i];</front>
<front id="qr_solveCPP-1785">      y[i] = temp;</front>
<front id="qr_solveCPP-1786">    }</front>
<front id="qr_solveCPP-1787"></front>
<front id="qr_solveCPP-1788">    for ( i = m; i &lt; n; i = i + 3 )</front>
<front id="qr_solveCPP-1789">    {</front>
<front id="qr_solveCPP-1790">      temp = x[i];</front>
<front id="qr_solveCPP-1791">      x[i] = y[i];</front>
<front id="qr_solveCPP-1792">      y[i] = temp;</front>
<front id="qr_solveCPP-1793"></front>
<front id="qr_solveCPP-1794">      temp = x[i+1];</front>
<front id="qr_solveCPP-1795">      x[i+1] = y[i+1];</front>
<front id="qr_solveCPP-1796">      y[i+1] = temp;</front>
<front id="qr_solveCPP-1797"></front>
<front id="qr_solveCPP-1798">      temp = x[i+2];</front>
<front id="qr_solveCPP-1799">      x[i+2] = y[i+2];</front>
<front id="qr_solveCPP-1800">      y[i+2] = temp;</front>
<front id="qr_solveCPP-1801">    }</front>
<front id="qr_solveCPP-1802">  }</front>
<front id="qr_solveCPP-1803">  else</front>
<front id="qr_solveCPP-1804">  {</front>
<front id="qr_solveCPP-1805">    if ( 0 &lt;= incx )</front>
<front id="qr_solveCPP-1806">    {</front>
<front id="qr_solveCPP-1807">      ix = 0;</front>
<front id="qr_solveCPP-1808">    }</front>
<front id="qr_solveCPP-1809">    else</front>
<front id="qr_solveCPP-1810">    {</front>
<front id="qr_solveCPP-1811">      ix = ( - n + 1 ) * incx;</front>
<front id="qr_solveCPP-1812">    }</front>
<front id="qr_solveCPP-1813"></front>
<front id="qr_solveCPP-1814">    if ( 0 &lt;= incy )</front>
<front id="qr_solveCPP-1815">    {</front>
<front id="qr_solveCPP-1816">      iy = 0;</front>
<front id="qr_solveCPP-1817">    }</front>
<front id="qr_solveCPP-1818">    else</front>
<front id="qr_solveCPP-1819">    {</front>
<front id="qr_solveCPP-1820">      iy = ( - n + 1 ) * incy;</front>
<front id="qr_solveCPP-1821">    }</front>
<front id="qr_solveCPP-1822"></front>
<front id="qr_solveCPP-1823">    for ( i = 0; i &lt; n; i++ )</front>
<front id="qr_solveCPP-1824">    {</front>
<front id="qr_solveCPP-1825">      temp = x[ix];</front>
<front id="qr_solveCPP-1826">      x[ix] = y[iy];</front>
<front id="qr_solveCPP-1827">      y[iy] = temp;</front>
<front id="qr_solveCPP-1828">      ix = ix + incx;</front>
<front id="qr_solveCPP-1829">      iy = iy + incy;</front>
<front id="qr_solveCPP-1830">    }</front>
<front id="qr_solveCPP-1831"></front>
<front id="qr_solveCPP-1832">  }</front>
<front id="qr_solveCPP-1833"></front>
<front id="qr_solveCPP-1834">  return;</front>
<front id="qr_solveCPP-1835">}</front>
<front id="qr_solveCPP-1836">/******************************************************************************/</front>
<front id="qr_solveCPP-1837"></front>
<front id="qr_solveCPP-1838">/******************************************************************************/</front>
<front id="qr_solveCPP-1839"></front>
<front id="qr_solveCPP-1840">void qr_solve ( double x[], int m, int n, double a[], double b[] )</front>
<front id="qr_solveCPP-1841"></front>
<front id="qr_solveCPP-1842">/******************************************************************************/</front>
<front id="qr_solveCPP-1843">/*</front>
<front id="qr_solveCPP-1844">  Purpose:</front>
<front id="qr_solveCPP-1845"></front>
<front id="qr_solveCPP-1846">    QR_SOLVE solves a linear system in the least squares sense.</front>
<front id="qr_solveCPP-1847"></front>
<front id="qr_solveCPP-1848">  Discussion:</front>
<front id="qr_solveCPP-1849"></front>
<front id="qr_solveCPP-1850">    If the matrix A has full column rank, then the solution X should be the</front>
<front id="qr_solveCPP-1851">    unique vector that minimizes the Euclidean norm of the residual.</front>
<front id="qr_solveCPP-1852"></front>
<front id="qr_solveCPP-1853">    If the matrix A does not have full column rank, then the solution is</front>
<front id="qr_solveCPP-1854">    not unique; the vector X will minimize the residual norm, but so will</front>
<front id="qr_solveCPP-1855">    various other vectors.</front>
<front id="qr_solveCPP-1856"></front>
<front id="qr_solveCPP-1857">  Licensing:</front>
<front id="qr_solveCPP-1858"></front>
<front id="qr_solveCPP-1859">    This code is distributed under the GNU LGPL license.</front>
<front id="qr_solveCPP-1860"></front>
<front id="qr_solveCPP-1861">  Modified:</front>
<front id="qr_solveCPP-1862"></front>
<front id="qr_solveCPP-1863">    11 September 2012</front>
<front id="qr_solveCPP-1864"></front>
<front id="qr_solveCPP-1865">  Author:</front>
<front id="qr_solveCPP-1866"></front>
<front id="qr_solveCPP-1867">    John Burkardt</front>
<front id="qr_solveCPP-1868"></front>
<front id="qr_solveCPP-1869">  Reference:</front>
<front id="qr_solveCPP-1870"></front>
<front id="qr_solveCPP-1871">    David Kahaner, Cleve Moler, Steven Nash,</front>
<front id="qr_solveCPP-1872">    Numerical Methods and Software,</front>
<front id="qr_solveCPP-1873">    Prentice Hall, 1989,</front>
<front id="qr_solveCPP-1874">    ISBN: 0-13-627258-4,</front>
<front id="qr_solveCPP-1875">    LC: TA345.K34.</front>
<front id="qr_solveCPP-1876"></front>
<front id="qr_solveCPP-1877">  Parameters:</front>
<front id="qr_solveCPP-1878"></front>
<front id="qr_solveCPP-1879">    Input, int M, the number of rows of A.</front>
<front id="qr_solveCPP-1880"></front>
<front id="qr_solveCPP-1881">    Input, int N, the number of columns of A.</front>
<front id="qr_solveCPP-1882"></front>
<front id="qr_solveCPP-1883">    Input, double A[M*N], the matrix.</front>
<front id="qr_solveCPP-1884"></front>
<front id="qr_solveCPP-1885">    Input, double B[M], the right hand side.</front>
<front id="qr_solveCPP-1886"></front>
<front id="qr_solveCPP-1887">    Output, double QR_SOLVE[N], the least squares solution.</front>
<front id="qr_solveCPP-1888">*/</front>
<front id="qr_solveCPP-1889">{</front>
<front id="qr_solveCPP-1890">  double a_qr[n*m];</front>
<front id="qr_solveCPP-1891">  int ind;</front>
<front id="qr_solveCPP-1892">  int itask;</front>
<front id="qr_solveCPP-1893">  int jpvt[n];</front>
<front id="qr_solveCPP-1894">  int kr;</front>
<front id="qr_solveCPP-1895">  int lda;</front>
<front id="qr_solveCPP-1896">  double qraux[n];</front>
<front id="qr_solveCPP-1897">  double r[m];</front>
<front id="qr_solveCPP-1898">  double tol;</front>
<front id="qr_solveCPP-1899"></front>
<front id="qr_solveCPP-1900">  r8mat_copy( a_qr, m, n, a );</front>
<front id="qr_solveCPP-1901">  lda = m;</front>
<front id="qr_solveCPP-1902">  tol = r8_epsilon ( ) / r8mat_amax ( m, n, a_qr );</front>
<front id="qr_solveCPP-1903">  itask = 1;</front>
<front id="qr_solveCPP-1904"></front>
<front id="qr_solveCPP-1905">  ind = dqrls ( a_qr, lda, m, n, tol, &kr, b, x, r, jpvt, qraux, itask );</front>
<front id="qr_solveCPP-1906">}</front>
<front id="qr_solveCPP-1907">/******************************************************************************/</front>
<front id="qr_solveCPP-1908"></front>
<front id="qr_solveCPP-1909">#endif</front>
 </pre>
<h1 id="qr_solveHtitle" >qr_solve.h</h1>
<pre id="qr_solveH"  class="prettyprint linenums"><front id="qr_solveH-1">#include "Configuration.h"</front>
<front id="qr_solveH-2"></front>
<front id="qr_solveH-3">#if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="qr_solveH-4"></front>
<front id="qr_solveH-5">void daxpy ( int n, double da, double dx[], int incx, double dy[], int incy );</front>
<front id="qr_solveH-6">double ddot ( int n, double dx[], int incx, double dy[], int incy );</front>
<front id="qr_solveH-7">double dnrm2 ( int n, double x[], int incx );</front>
<front id="qr_solveH-8">void dqrank ( double a[], int lda, int m, int n, double tol, int *kr, </front>
<front id="qr_solveH-9">  int jpvt[], double qraux[] );</front>
<front id="qr_solveH-10">void dqrdc ( double a[], int lda, int n, int p, double qraux[], int jpvt[], </front>
<front id="qr_solveH-11">  double work[], int job );</front>
<front id="qr_solveH-12">int dqrls ( double a[], int lda, int m, int n, double tol, int *kr, double b[], </front>
<front id="qr_solveH-13">  double x[], double rsd[], int jpvt[], double qraux[], int itask );</front>
<front id="qr_solveH-14">void dqrlss ( double a[], int lda, int m, int n, int kr, double b[], double x[], </front>
<front id="qr_solveH-15">  double rsd[], int jpvt[], double qraux[] );</front>
<front id="qr_solveH-16">int dqrsl ( double a[], int lda, int n, int k, double qraux[], double y[], </front>
<front id="qr_solveH-17">  double qy[], double qty[], double b[], double rsd[], double ab[], int job );</front>
<front id="qr_solveH-18">void dscal ( int n, double sa, double x[], int incx );</front>
<front id="qr_solveH-19">void dswap ( int n, double x[], int incx, double y[], int incy );</front>
<front id="qr_solveH-20">void qr_solve ( double x[], int m, int n, double a[], double b[] );</front>
<front id="qr_solveH-21"></front>
<front id="qr_solveH-22">#endif</front>
 </pre>
<h1 id="SanityCheckHtitle" >SanityCheck.h</h1>
<pre id="SanityCheckH"  class="prettyprint linenums"><front id="SanityCheckH-1">/**</front>
<front id="SanityCheckH-2"> * SanityCheck.h</front>
<front id="SanityCheckH-3"> *</front>
<front id="SanityCheckH-4"> * Test configuration values for errors at compile-time.</front>
<front id="SanityCheckH-5"> */</front>
<front id="SanityCheckH-6">#ifndef SANITYCHECK_H</front>
<front id="SanityCheckH-7">  #define SANITYCHECK_H</front>
<front id="SanityCheckH-8"></front>
<front id="SanityCheckH-9">  /**</front>
<front id="SanityCheckH-10">   * Dual Stepper Drivers</front>
<front id="SanityCheckH-11">   */</front>
<front id="SanityCheckH-12">  #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && ENABLED(Y_DUAL_STEPPER_DRIVERS)</front>
<front id="SanityCheckH-13">    #error You cannot have dual stepper drivers for both Y and Z.</front>
<front id="SanityCheckH-14">  #endif</front>
<front id="SanityCheckH-15"></front>
<front id="SanityCheckH-16">  /**</front>
<front id="SanityCheckH-17">   * Progress Bar</front>
<front id="SanityCheckH-18">   */</front>
<front id="SanityCheckH-19">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="SanityCheckH-20">    #if DISABLED(SDSUPPORT)</front>
<front id="SanityCheckH-21">      #error LCD_PROGRESS_BAR requires SDSUPPORT.</front>
<front id="SanityCheckH-22">    #endif</front>
<front id="SanityCheckH-23">    #if ENABLED(DOGLCD)</front>
<front id="SanityCheckH-24">      #error LCD_PROGRESS_BAR does not apply to graphical displays.</front>
<front id="SanityCheckH-25">    #endif</front>
<front id="SanityCheckH-26">    #if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="SanityCheckH-27">      #error LCD_PROGRESS_BAR and FILAMENT_LCD_DISPLAY are not fully compatible. Comment out this line to use both.</front>
<front id="SanityCheckH-28">    #endif</front>
<front id="SanityCheckH-29">  #endif</front>
<front id="SanityCheckH-30"></front>
<front id="SanityCheckH-31">  /**</front>
<front id="SanityCheckH-32">   * Babystepping</front>
<front id="SanityCheckH-33">   */</front>
<front id="SanityCheckH-34">  #if ENABLED(BABYSTEPPING)</front>
<front id="SanityCheckH-35">    #if ENABLED(COREXY) && ENABLED(BABYSTEP_XY)</front>
<front id="SanityCheckH-36">      #error BABYSTEPPING only implemented for Z axis on CoreXY.</front>
<front id="SanityCheckH-37">    #endif</front>
<front id="SanityCheckH-38">    #if ENABLED(SCARA)</front>
<front id="SanityCheckH-39">      #error BABYSTEPPING is not implemented for SCARA yet.</front>
<front id="SanityCheckH-40">    #endif</front>
<front id="SanityCheckH-41">    #if ENABLED(DELTA) && ENABLED(BABYSTEP_XY)</front>
<front id="SanityCheckH-42">      #error BABYSTEPPING only implemented for Z axis on deltabots.</front>
<front id="SanityCheckH-43">    #endif</front>
<front id="SanityCheckH-44">  #endif</front>
<front id="SanityCheckH-45"></front>
<front id="SanityCheckH-46">  /**</front>
<front id="SanityCheckH-47">   * Filament Change with Extruder Runout Prevention</front>
<front id="SanityCheckH-48">   */</front>
<front id="SanityCheckH-49">  #if ENABLED(FILAMENTCHANGEENABLE) && ENABLED(EXTRUDER_RUNOUT_PREVENT)</front>
<front id="SanityCheckH-50">    #error EXTRUDER_RUNOUT_PREVENT currently incompatible with FILAMENTCHANGE.</front>
<front id="SanityCheckH-51">  #endif</front>
<front id="SanityCheckH-52"></front>
<front id="SanityCheckH-53">  /**</front>
<front id="SanityCheckH-54">   * Options only for EXTRUDERS &gt; 1</front>
<front id="SanityCheckH-55">   */</front>
<front id="SanityCheckH-56">  #if EXTRUDERS &gt; 1</front>
<front id="SanityCheckH-57"></front>
<front id="SanityCheckH-58">    #if EXTRUDERS &gt; 4</front>
<front id="SanityCheckH-59">      #error The maximum number of EXTRUDERS in Marlin is 4.</front>
<front id="SanityCheckH-60">    #endif</front>
<front id="SanityCheckH-61"></front>
<front id="SanityCheckH-62">    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="SanityCheckH-63">      #error EXTRUDERS must be 1 with TEMP_SENSOR_1_AS_REDUNDANT.</front>
<front id="SanityCheckH-64">    #endif</front>
<front id="SanityCheckH-65"></front>
<front id="SanityCheckH-66">    #if ENABLED(HEATERS_PARALLEL)</front>
<front id="SanityCheckH-67">      #error EXTRUDERS must be 1 with HEATERS_PARALLEL.</front>
<front id="SanityCheckH-68">    #endif</front>
<front id="SanityCheckH-69"></front>
<front id="SanityCheckH-70">    #if ENABLED(Y_DUAL_STEPPER_DRIVERS)</front>
<front id="SanityCheckH-71">      #error EXTRUDERS must be 1 with Y_DUAL_STEPPER_DRIVERS.</front>
<front id="SanityCheckH-72">    #endif</front>
<front id="SanityCheckH-73"></front>
<front id="SanityCheckH-74">    #if ENABLED(Z_DUAL_STEPPER_DRIVERS)</front>
<front id="SanityCheckH-75">      #error EXTRUDERS must be 1 with Z_DUAL_STEPPER_DRIVERS.</front>
<front id="SanityCheckH-76">    #endif</front>
<front id="SanityCheckH-77"></front>
<front id="SanityCheckH-78">  #endif // EXTRUDERS &gt; 1</front>
<front id="SanityCheckH-79"></front>
<front id="SanityCheckH-80">  /**</front>
<front id="SanityCheckH-81">   * Limited number of servos</front>
<front id="SanityCheckH-82">   */</front>
<front id="SanityCheckH-83">  #if NUM_SERVOS &gt; 4</front>
<front id="SanityCheckH-84">    #error The maximum number of SERVOS in Marlin is 4.</front>
<front id="SanityCheckH-85">  #endif</front>
<front id="SanityCheckH-86">  #if defined(NUM_SERVOS) && NUM_SERVOS &gt; 0</front>
<front id="SanityCheckH-87">    #if X_ENDSTOP_SERVO_NR &gt;= 0 || Y_ENDSTOP_SERVO_NR &gt;= 0 || Z_ENDSTOP_SERVO_NR &gt;= 0</front>
<front id="SanityCheckH-88">      #if X_ENDSTOP_SERVO_NR &gt;= NUM_SERVOS</front>
<front id="SanityCheckH-89">        #error X_ENDSTOP_SERVO_NR must be smaller than NUM_SERVOS.</front>
<front id="SanityCheckH-90">      #elif Y_ENDSTOP_SERVO_NR &gt;= NUM_SERVOS</front>
<front id="SanityCheckH-91">        #error Y_ENDSTOP_SERVO_NR must be smaller than NUM_SERVOS.</front>
<front id="SanityCheckH-92">      #elif Z_ENDSTOP_SERVO_NR &gt;= NUM_SERVOS</front>
<front id="SanityCheckH-93">        #error Z_ENDSTOP_SERVO_NR must be smaller than NUM_SERVOS.</front>
<front id="SanityCheckH-94">      #endif</front>
<front id="SanityCheckH-95">    #endif</front>
<front id="SanityCheckH-96">  #endif</front>
<front id="SanityCheckH-97"></front>
<front id="SanityCheckH-98">  /**</front>
<front id="SanityCheckH-99">   * Servo deactivation depends on servo endstops</front>
<front id="SanityCheckH-100">   */</front>
<front id="SanityCheckH-101">  #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE) && !HAS_SERVO_ENDSTOPS</front>
<front id="SanityCheckH-102">    #error At least one of the ?_ENDSTOP_SERVO_NR is required for DEACTIVATE_SERVOS_AFTER_MOVE.</front>
<front id="SanityCheckH-103">  #endif</front>
<front id="SanityCheckH-104"></front>
<front id="SanityCheckH-105">  /**</front>
<front id="SanityCheckH-106">   * Required LCD language</front>
<front id="SanityCheckH-107">   */</front>
<front id="SanityCheckH-108">  #if DISABLED(DOGLCD) && ENABLED(ULTRA_LCD) && DISABLED(DISPLAY_CHARSET_HD44780_JAPAN) && DISABLED(DISPLAY_CHARSET_HD44780_WESTERN) && DISABLED(DISPLAY_CHARSET_HD44780_CYRILLIC)</front>
<front id="SanityCheckH-109">    #error You must enable either DISPLAY_CHARSET_HD44780_JAPAN or DISPLAY_CHARSET_HD44780_WESTERN  or DISPLAY_CHARSET_HD44780_CYRILLIC for your LCD controller.</front>
<front id="SanityCheckH-110">  #endif</front>
<front id="SanityCheckH-111"></front>
<front id="SanityCheckH-112">  /**</front>
<front id="SanityCheckH-113">   * Mesh Bed Leveling</front>
<front id="SanityCheckH-114">   */</front>
<front id="SanityCheckH-115">  #if ENABLED(MESH_BED_LEVELING)</front>
<front id="SanityCheckH-116">    #if ENABLED(DELTA)</front>
<front id="SanityCheckH-117">      #error MESH_BED_LEVELING does not yet support DELTA printers.</front>
<front id="SanityCheckH-118">    #endif</front>
<front id="SanityCheckH-119">    #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="SanityCheckH-120">      #error Select AUTO_BED_LEVELING_FEATURE or MESH_BED_LEVELING, not both.</front>
<front id="SanityCheckH-121">    #endif</front>
<front id="SanityCheckH-122">    #if MESH_NUM_X_POINTS &gt; 7 || MESH_NUM_Y_POINTS &gt; 7</front>
<front id="SanityCheckH-123">      #error MESH_NUM_X_POINTS and MESH_NUM_Y_POINTS need to be less than 8.</front>
<front id="SanityCheckH-124">    #endif</front>
<front id="SanityCheckH-125">  #endif</front>
<front id="SanityCheckH-126"></front>
<front id="SanityCheckH-127">  /**</front>
<front id="SanityCheckH-128">   * Auto Bed Leveling</front>
<front id="SanityCheckH-129">   */</front>
<front id="SanityCheckH-130">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="SanityCheckH-131"></front>
<front id="SanityCheckH-132">    /**</front>
<front id="SanityCheckH-133">     * Require a Z min pin</front>
<front id="SanityCheckH-134">     */</front>
<front id="SanityCheckH-135">    #if !PIN_EXISTS(Z_MIN)</front>
<front id="SanityCheckH-136">      #if !PIN_EXISTS(Z_MIN_PROBE) || (DISABLED(Z_MIN_PROBE_ENDSTOP) || ENABLED(DISABLE_Z_MIN_PROBE_ENDSTOP)) // It's possible for someone to set a pin for the Z probe, but not enable it.</front>
<front id="SanityCheckH-137">        #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)</front>
<front id="SanityCheckH-138">          #error You must have a Z_MIN or Z_PROBE endstop to enable Z_MIN_PROBE_REPEATABILITY_TEST.</front>
<front id="SanityCheckH-139">        #else</front>
<front id="SanityCheckH-140">          #error AUTO_BED_LEVELING_FEATURE requires a Z_MIN or Z_PROBE endstop. Z_MIN_PIN or Z_MIN_PROBE_PIN must point to a valid hardware pin.</front>
<front id="SanityCheckH-141">        #endif</front>
<front id="SanityCheckH-142">      #endif</front>
<front id="SanityCheckH-143">    #endif</front>
<front id="SanityCheckH-144"></front>
<front id="SanityCheckH-145">    /**</front>
<front id="SanityCheckH-146">     * Require a Z probe pin if Z_MIN_PROBE_ENDSTOP is enabled.</front>
<front id="SanityCheckH-147">     */</front>
<front id="SanityCheckH-148">    #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="SanityCheckH-149">      #if !PIN_EXISTS(Z_MIN_PROBE)</front>
<front id="SanityCheckH-150">        #error You must have a Z_MIN_PROBE_PIN defined in your pins_XXXX.h file if you enable Z_MIN_PROBE_ENDSTOP.</front>
<front id="SanityCheckH-151">      #endif</front>
<front id="SanityCheckH-152">// Forcing Servo definitions can break some hall effect sensor setups. Leaving these here for further comment.</front>
<front id="SanityCheckH-153">//      #ifndef NUM_SERVOS</front>
<front id="SanityCheckH-154">//        #error You must have NUM_SERVOS defined and there must be at least 1 configured to use Z_MIN_PROBE_ENDSTOP.</front>
<front id="SanityCheckH-155">//      #endif</front>
<front id="SanityCheckH-156">//      #if defined(NUM_SERVOS) && NUM_SERVOS &lt; 1</front>
<front id="SanityCheckH-157">//        #error You must have at least 1 servo defined for NUM_SERVOS to use Z_MIN_PROBE_ENDSTOP.</front>
<front id="SanityCheckH-158">//      #endif</front>
<front id="SanityCheckH-159">//      #if Z_ENDSTOP_SERVO_NR &lt; 0</front>
<front id="SanityCheckH-160">//        #error You must have Z_ENDSTOP_SERVO_NR set to at least 0 or above to use Z_MIN_PROBE_ENDSTOP.</front>
<front id="SanityCheckH-161">//      #endif</front>
<front id="SanityCheckH-162">//      #ifndef SERVO_ENDSTOP_ANGLES</front>
<front id="SanityCheckH-163">//        #error You must have SERVO_ENDSTOP_ANGLES defined for Z Extend and Retract to use Z_MIN_PROBE_ENDSTOP.</front>
<front id="SanityCheckH-164">//      #endif</front>
<front id="SanityCheckH-165">    #endif</front>
<front id="SanityCheckH-166">    /**</front>
<front id="SanityCheckH-167">     * Check if Probe_Offset * Grid Points is greater than Probing Range</front>
<front id="SanityCheckH-168">     */</front>
<front id="SanityCheckH-169">    #if ENABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="SanityCheckH-170">      #ifndef DELTA_PROBABLE_RADIUS</front>
<front id="SanityCheckH-171">        // Be sure points are in the right order</front>
<front id="SanityCheckH-172">        #if LEFT_PROBE_BED_POSITION &gt; RIGHT_PROBE_BED_POSITION</front>
<front id="SanityCheckH-173">          #error LEFT_PROBE_BED_POSITION must be less than RIGHT_PROBE_BED_POSITION.</front>
<front id="SanityCheckH-174">        #elif FRONT_PROBE_BED_POSITION &gt; BACK_PROBE_BED_POSITION</front>
<front id="SanityCheckH-175">          #error FRONT_PROBE_BED_POSITION must be less than BACK_PROBE_BED_POSITION.</front>
<front id="SanityCheckH-176">        #endif</front>
<front id="SanityCheckH-177">        // Make sure probing points are reachable</front>
<front id="SanityCheckH-178">        #if LEFT_PROBE_BED_POSITION &lt; MIN_PROBE_X</front>
<front id="SanityCheckH-179">          #error "The given LEFT_PROBE_BED_POSITION can't be reached by the Z probe."</front>
<front id="SanityCheckH-180">        #elif RIGHT_PROBE_BED_POSITION &gt; MAX_PROBE_X</front>
<front id="SanityCheckH-181">          #error "The given RIGHT_PROBE_BED_POSITION can't be reached by the Z probe."</front>
<front id="SanityCheckH-182">        #elif FRONT_PROBE_BED_POSITION &lt; MIN_PROBE_Y</front>
<front id="SanityCheckH-183">          #error "The given FRONT_PROBE_BED_POSITION can't be reached by the Z probe."</front>
<front id="SanityCheckH-184">        #elif BACK_PROBE_BED_POSITION &gt; MAX_PROBE_Y</front>
<front id="SanityCheckH-185">          #error "The given BACK_PROBE_BED_POSITION can't be reached by the Z probe."</front>
<front id="SanityCheckH-186">        #endif</front>
<front id="SanityCheckH-187">      #endif</front>
<front id="SanityCheckH-188">    #else // !AUTO_BED_LEVELING_GRID</front>
<front id="SanityCheckH-189"></front>
<front id="SanityCheckH-190">      // Check the triangulation points</front>
<front id="SanityCheckH-191">      #if ABL_PROBE_PT_1_X &lt; MIN_PROBE_X || ABL_PROBE_PT_1_X &gt; MAX_PROBE_X</front>
<front id="SanityCheckH-192">        #error "The given ABL_PROBE_PT_1_X can't be reached by the Z probe."</front>
<front id="SanityCheckH-193">      #elif ABL_PROBE_PT_2_X &lt; MIN_PROBE_X || ABL_PROBE_PT_2_X &gt; MAX_PROBE_X</front>
<front id="SanityCheckH-194">        #error "The given ABL_PROBE_PT_2_X can't be reached by the Z probe."</front>
<front id="SanityCheckH-195">      #elif ABL_PROBE_PT_3_X &lt; MIN_PROBE_X || ABL_PROBE_PT_3_X &gt; MAX_PROBE_X</front>
<front id="SanityCheckH-196">        #error "The given ABL_PROBE_PT_3_X can't be reached by the Z probe."</front>
<front id="SanityCheckH-197">      #elif ABL_PROBE_PT_1_Y &lt; MIN_PROBE_Y || ABL_PROBE_PT_1_Y &gt; MAX_PROBE_Y</front>
<front id="SanityCheckH-198">        #error "The given ABL_PROBE_PT_1_Y can't be reached by the Z probe."</front>
<front id="SanityCheckH-199">      #elif ABL_PROBE_PT_2_Y &lt; MIN_PROBE_Y || ABL_PROBE_PT_2_Y &gt; MAX_PROBE_Y</front>
<front id="SanityCheckH-200">        #error "The given ABL_PROBE_PT_2_Y can't be reached by the Z probe."</front>
<front id="SanityCheckH-201">      #elif ABL_PROBE_PT_3_Y &lt; MIN_PROBE_Y || ABL_PROBE_PT_3_Y &gt; MAX_PROBE_Y</front>
<front id="SanityCheckH-202">        #error "The given ABL_PROBE_PT_3_Y can't be reached by the Z probe."</front>
<front id="SanityCheckH-203">      #endif</front>
<front id="SanityCheckH-204"></front>
<front id="SanityCheckH-205">    #endif // !AUTO_BED_LEVELING_GRID</front>
<front id="SanityCheckH-206"></front>
<front id="SanityCheckH-207">  #endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="SanityCheckH-208"></front>
<front id="SanityCheckH-209">  /**</front>
<front id="SanityCheckH-210">   * ULTIPANEL encoder</front>
<front id="SanityCheckH-211">   */</front>
<front id="SanityCheckH-212">  #if ENABLED(ULTIPANEL) && DISABLED(NEWPANEL) && DISABLED(SR_LCD_2W_NL) && !defined(SHIFT_CLK)</front>
<front id="SanityCheckH-213">    #error ULTIPANEL requires some kind of encoder.</front>
<front id="SanityCheckH-214">  #endif</front>
<front id="SanityCheckH-215"></front>
<front id="SanityCheckH-216">  /**</front>
<front id="SanityCheckH-217">   * Delta has limited bed leveling options</front>
<front id="SanityCheckH-218">   */</front>
<front id="SanityCheckH-219">  #if ENABLED(DELTA)</front>
<front id="SanityCheckH-220"></front>
<front id="SanityCheckH-221">    #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="SanityCheckH-222"></front>
<front id="SanityCheckH-223">      #if DISABLED(AUTO_BED_LEVELING_GRID)</front>
<front id="SanityCheckH-224">        #error Only AUTO_BED_LEVELING_GRID is supported with DELTA.</front>
<front id="SanityCheckH-225">      #endif</front>
<front id="SanityCheckH-226"></front>
<front id="SanityCheckH-227">      #if ENABLED(Z_PROBE_SLED)</front>
<front id="SanityCheckH-228">        #error You cannot use Z_PROBE_SLED with DELTA.</front>
<front id="SanityCheckH-229">      #endif</front>
<front id="SanityCheckH-230"></front>
<front id="SanityCheckH-231">      #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)</front>
<front id="SanityCheckH-232">        #error Z_MIN_PROBE_REPEATABILITY_TEST is not supported with DELTA yet.</front>
<front id="SanityCheckH-233">      #endif</front>
<front id="SanityCheckH-234"></front>
<front id="SanityCheckH-235">    #endif</front>
<front id="SanityCheckH-236"></front>
<front id="SanityCheckH-237">  #endif</front>
<front id="SanityCheckH-238"></front>
<front id="SanityCheckH-239">  /**</front>
<front id="SanityCheckH-240">   * Allen Key Z probe requires Auto Bed Leveling grid and Delta</front>
<front id="SanityCheckH-241">   */</front>
<front id="SanityCheckH-242">  #if ENABLED(Z_PROBE_ALLEN_KEY) && !(ENABLED(AUTO_BED_LEVELING_GRID) && ENABLED(DELTA))</front>
<front id="SanityCheckH-243">    #error Invalid use of Z_PROBE_ALLEN_KEY.</front>
<front id="SanityCheckH-244">  #endif</front>
<front id="SanityCheckH-245"></front>
<front id="SanityCheckH-246">  /**</front>
<front id="SanityCheckH-247">   * Dual X Carriage requirements</front>
<front id="SanityCheckH-248">   */</front>
<front id="SanityCheckH-249">  #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="SanityCheckH-250">    #if EXTRUDERS == 1 || ENABLED(COREXY) \</front>
<front id="SanityCheckH-251">        || !HAS_X2_ENABLE || !HAS_X2_STEP || !HAS_X2_DIR \</front>
<front id="SanityCheckH-252">        || !defined(X2_HOME_POS) || !defined(X2_MIN_POS) || !defined(X2_MAX_POS) \</front>
<front id="SanityCheckH-253">        || !HAS_X_MAX</front>
<front id="SanityCheckH-254">      #error Missing or invalid definitions for DUAL_X_CARRIAGE mode.</front>
<front id="SanityCheckH-255">    #endif</front>
<front id="SanityCheckH-256">    #if X_HOME_DIR != -1 || X2_HOME_DIR != 1</front>
<front id="SanityCheckH-257">      #error Please use canonical x-carriage assignment.</front>
<front id="SanityCheckH-258">    #endif</front>
<front id="SanityCheckH-259">  #endif // DUAL_X_CARRIAGE</front>
<front id="SanityCheckH-260"></front>
<front id="SanityCheckH-261">  /**</front>
<front id="SanityCheckH-262">   * Make sure auto fan pins don't conflict with the fan pin</front>
<front id="SanityCheckH-263">   */</front>
<front id="SanityCheckH-264">  #if HAS_AUTO_FAN && HAS_FAN</front>
<front id="SanityCheckH-265">    #if EXTRUDER_0_AUTO_FAN_PIN == FAN_PIN</front>
<front id="SanityCheckH-266">      #error You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN.</front>
<front id="SanityCheckH-267">    #elif EXTRUDER_1_AUTO_FAN_PIN == FAN_PIN</front>
<front id="SanityCheckH-268">      #error You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN.</front>
<front id="SanityCheckH-269">    #elif EXTRUDER_2_AUTO_FAN_PIN == FAN_PIN</front>
<front id="SanityCheckH-270">      #error You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN.</front>
<front id="SanityCheckH-271">    #elif EXTRUDER_3_AUTO_FAN_PIN == FAN_PIN</front>
<front id="SanityCheckH-272">      #error You cannot set EXTRUDER_3_AUTO_FAN_PIN equal to FAN_PIN.</front>
<front id="SanityCheckH-273">    #endif</front>
<front id="SanityCheckH-274">  #endif</front>
<front id="SanityCheckH-275"></front>
<front id="SanityCheckH-276">  #if HAS_FAN && CONTROLLERFAN_PIN == FAN_PIN</front>
<front id="SanityCheckH-277">    #error You cannot set CONTROLLERFAN_PIN equal to FAN_PIN.</front>
<front id="SanityCheckH-278">  #endif</front>
<front id="SanityCheckH-279"></front>
<front id="SanityCheckH-280">  /**</front>
<front id="SanityCheckH-281">   * Test Heater, Temp Sensor, and Extruder Pins; Sensor Type must also be set.</front>
<front id="SanityCheckH-282">   */</front>
<front id="SanityCheckH-283">  #if EXTRUDERS &gt; 3</front>
<front id="SanityCheckH-284">    #if !HAS_HEATER_3</front>
<front id="SanityCheckH-285">      #error HEATER_3_PIN not defined for this board.</front>
<front id="SanityCheckH-286">    #elif !PIN_EXISTS(TEMP_3)</front>
<front id="SanityCheckH-287">      #error TEMP_3_PIN not defined for this board.</front>
<front id="SanityCheckH-288">    #elif !PIN_EXISTS(E3_STEP) || !PIN_EXISTS(E3_DIR) || !PIN_EXISTS(E3_ENABLE)</front>
<front id="SanityCheckH-289">      #error E3_STEP_PIN, E3_DIR_PIN, or E3_ENABLE_PIN not defined for this board.</front>
<front id="SanityCheckH-290">    #elif TEMP_SENSOR_3 == 0</front>
<front id="SanityCheckH-291">      #error TEMP_SENSOR_3 is required with 4 EXTRUDERS.</front>
<front id="SanityCheckH-292">    #endif</front>
<front id="SanityCheckH-293">  #elif EXTRUDERS &gt; 2</front>
<front id="SanityCheckH-294">    #if !HAS_HEATER_2</front>
<front id="SanityCheckH-295">      #error HEATER_2_PIN not defined for this board.</front>
<front id="SanityCheckH-296">    #elif !PIN_EXISTS(TEMP_2)</front>
<front id="SanityCheckH-297">      #error TEMP_2_PIN not defined for this board.</front>
<front id="SanityCheckH-298">    #elif !PIN_EXISTS(E2_STEP) || !PIN_EXISTS(E2_DIR) || !PIN_EXISTS(E2_ENABLE)</front>
<front id="SanityCheckH-299">      #error E2_STEP_PIN, E2_DIR_PIN, or E2_ENABLE_PIN not defined for this board.</front>
<front id="SanityCheckH-300">    #elif TEMP_SENSOR_2 == 0</front>
<front id="SanityCheckH-301">      #error TEMP_SENSOR_2 is required with 3 or more EXTRUDERS.</front>
<front id="SanityCheckH-302">    #endif</front>
<front id="SanityCheckH-303">  #elif EXTRUDERS &gt; 1</front>
<front id="SanityCheckH-304">    #if !PIN_EXISTS(TEMP_1)</front>
<front id="SanityCheckH-305">      #error TEMP_1_PIN not defined for this board.</front>
<front id="SanityCheckH-306">    #elif !PIN_EXISTS(E1_STEP) || !PIN_EXISTS(E1_DIR) || !PIN_EXISTS(E1_ENABLE)</front>
<front id="SanityCheckH-307">      #error E1_STEP_PIN, E1_DIR_PIN, or E1_ENABLE_PIN not defined for this board.</front>
<front id="SanityCheckH-308">    #endif</front>
<front id="SanityCheckH-309">  #endif</front>
<front id="SanityCheckH-310"></front>
<front id="SanityCheckH-311">  #if EXTRUDERS &gt; 1 || ENABLED(HEATERS_PARALLEL)</front>
<front id="SanityCheckH-312">    #if !HAS_HEATER_1</front>
<front id="SanityCheckH-313">      #error HEATER_1_PIN not defined for this board.</front>
<front id="SanityCheckH-314">    #endif</front>
<front id="SanityCheckH-315">  #endif</front>
<front id="SanityCheckH-316"></front>
<front id="SanityCheckH-317">  #if TEMP_SENSOR_1 == 0</front>
<front id="SanityCheckH-318">    #if EXTRUDERS &gt; 1</front>
<front id="SanityCheckH-319">      #error TEMP_SENSOR_1 is required with 2 or more EXTRUDERS.</front>
<front id="SanityCheckH-320">    #elif ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="SanityCheckH-321">      #error TEMP_SENSOR_1 is required with TEMP_SENSOR_1_AS_REDUNDANT.</front>
<front id="SanityCheckH-322">    #endif</front>
<front id="SanityCheckH-323">  #endif</front>
<front id="SanityCheckH-324"></front>
<front id="SanityCheckH-325">  #if !HAS_HEATER_0</front>
<front id="SanityCheckH-326">    #error HEATER_0_PIN not defined for this board.</front>
<front id="SanityCheckH-327">  #elif !PIN_EXISTS(TEMP_0)</front>
<front id="SanityCheckH-328">    #error TEMP_0_PIN not defined for this board.</front>
<front id="SanityCheckH-329">  #elif !PIN_EXISTS(E0_STEP) || !PIN_EXISTS(E0_DIR) || !PIN_EXISTS(E0_ENABLE)</front>
<front id="SanityCheckH-330">    #error E0_STEP_PIN, E0_DIR_PIN, or E0_ENABLE_PIN not defined for this board.</front>
<front id="SanityCheckH-331">  #elif TEMP_SENSOR_0 == 0</front>
<front id="SanityCheckH-332">    #error TEMP_SENSOR_0 is required.</front>
<front id="SanityCheckH-333">  #endif</front>
<front id="SanityCheckH-334"></front>
<front id="SanityCheckH-335">  /**</front>
<front id="SanityCheckH-336">   * Warnings for old configurations</front>
<front id="SanityCheckH-337">   */</front>
<front id="SanityCheckH-338">  #if WATCH_TEMP_PERIOD &gt; 500</front>
<front id="SanityCheckH-339">    #error WATCH_TEMP_PERIOD now uses seconds instead of milliseconds.</front>
<front id="SanityCheckH-340">  #elif DISABLED(THERMAL_PROTECTION_HOTENDS) && (defined(WATCH_TEMP_PERIOD) || defined(THERMAL_PROTECTION_PERIOD))</front>
<front id="SanityCheckH-341">    #error Thermal Runaway Protection for hotends is now enabled with THERMAL_PROTECTION_HOTENDS.</front>
<front id="SanityCheckH-342">  #elif DISABLED(THERMAL_PROTECTION_BED) && defined(THERMAL_PROTECTION_BED_PERIOD)</front>
<front id="SanityCheckH-343">    #error Thermal Runaway Protection for the bed is now enabled with THERMAL_PROTECTION_BED.</front>
<front id="SanityCheckH-344">  #elif ENABLED(COREXZ) && ENABLED(Z_LATE_ENABLE)</front>
<front id="SanityCheckH-345">    #error "Z_LATE_ENABLE can't be used with COREXZ."</front>
<front id="SanityCheckH-346">  #elif defined(X_HOME_RETRACT_MM)</front>
<front id="SanityCheckH-347">    #error [XYZ]_HOME_RETRACT_MM settings have been renamed [XYZ]_HOME_BUMP_MM.</front>
<front id="SanityCheckH-348">  #elif defined(PROBE_SERVO_DEACTIVATION_DELAY)</front>
<front id="SanityCheckH-349">    #error PROBE_SERVO_DEACTIVATION_DELAY has been replaced with DEACTIVATE_SERVOS_AFTER_MOVE and SERVO_DEACTIVATION_DELAY.</front>
<front id="SanityCheckH-350">  #elif defined(BEEPER)</front>
<front id="SanityCheckH-351">    #error BEEPER is now BEEPER_PIN. Please update your pins definitions.</front>
<front id="SanityCheckH-352">  #elif defined(SDCARDDETECT)</front>
<front id="SanityCheckH-353">    #error SDCARDDETECT is now SD_DETECT_PIN. Please update your pins definitions.</front>
<front id="SanityCheckH-354">  #elif defined(SDCARDDETECTINVERTED)</front>
<front id="SanityCheckH-355">    #error SDCARDDETECTINVERTED is now SD_DETECT_INVERTED. Please update your configuration.</front>
<front id="SanityCheckH-356">  #elif defined(BTENABLED)</front>
<front id="SanityCheckH-357">    #error BTENABLED is now BLUETOOTH. Please update your configuration.</front>
<front id="SanityCheckH-358">  #elif defined(CUSTOM_MENDEL_NAME)</front>
<front id="SanityCheckH-359">    #error CUSTOM_MENDEL_NAME is now CUSTOM_MACHINE_NAME. Please update your configuration.</front>
<front id="SanityCheckH-360">  #elif defined(HAS_AUTOMATIC_VERSIONING)</front>
<front id="SanityCheckH-361">    #error HAS_AUTOMATIC_VERSIONING deprecated - use USE_AUTOMATIC_VERSIONING instead</front>
<front id="SanityCheckH-362">  #elif defined(ENABLE_AUTO_BED_LEVELING)</front>
<front id="SanityCheckH-363">    #error ENABLE_AUTO_BED_LEVELING deprecated - use AUTO_BED_LEVELING_FEATURE instead</front>
<front id="SanityCheckH-364">  #endif</front>
<front id="SanityCheckH-365"></front>
<front id="SanityCheckH-366">#endif //SANITYCHECK_H</front>
 </pre>
<h1 id="Sd2CardCPPtitle" >Sd2Card.cpp</h1>
<pre id="Sd2CardCPP"  class="prettyprint linenums"><front id="Sd2CardCPP-1">/* Arduino Sd2Card Library</front>
<front id="Sd2CardCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="Sd2CardCPP-3"> *</front>
<front id="Sd2CardCPP-4"> * This file is part of the Arduino Sd2Card Library</front>
<front id="Sd2CardCPP-5"> *</front>
<front id="Sd2CardCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="Sd2CardCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="Sd2CardCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Sd2CardCPP-9"> * (at your option) any later version.</front>
<front id="Sd2CardCPP-10"> *</front>
<front id="Sd2CardCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="Sd2CardCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Sd2CardCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Sd2CardCPP-14"> * GNU General Public License for more details.</front>
<front id="Sd2CardCPP-15"> *</front>
<front id="Sd2CardCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="Sd2CardCPP-17"> * along with the Arduino Sd2Card Library.  If not, see</front>
<front id="Sd2CardCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Sd2CardCPP-19"> */</front>
<front id="Sd2CardCPP-20">#include "Marlin.h"</front>
<front id="Sd2CardCPP-21"></front>
<front id="Sd2CardCPP-22">#if ENABLED(SDSUPPORT)</front>
<front id="Sd2CardCPP-23">#include "Sd2Card.h"</front>
<front id="Sd2CardCPP-24">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-25">#if DISABLED(SOFTWARE_SPI)</front>
<front id="Sd2CardCPP-26">// functions for hardware SPI</front>
<front id="Sd2CardCPP-27">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-28">// make sure SPCR rate is in expected bits</front>
<front id="Sd2CardCPP-29">#if (SPR0 != 0 || SPR1 != 1)</front>
<front id="Sd2CardCPP-30">#error unexpected SPCR bits</front>
<front id="Sd2CardCPP-31">#endif</front>
<front id="Sd2CardCPP-32">/**</front>
<front id="Sd2CardCPP-33"> * Initialize hardware SPI</front>
<front id="Sd2CardCPP-34"> * Set SCK rate to F_CPU/pow(2, 1 + spiRate) for spiRate [0,6]</front>
<front id="Sd2CardCPP-35"> */</front>
<front id="Sd2CardCPP-36">static void spiInit(uint8_t spiRate) {</front>
<front id="Sd2CardCPP-37">  // See avr processor documentation</front>
<front id="Sd2CardCPP-38">  SPCR = BIT(SPE) | BIT(MSTR) | (spiRate &gt;&gt; 1);</front>
<front id="Sd2CardCPP-39">  SPSR = spiRate & 1 || spiRate == 6 ? 0 : BIT(SPI2X);</front>
<front id="Sd2CardCPP-40">}</front>
<front id="Sd2CardCPP-41">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-42">/** SPI receive a byte */</front>
<front id="Sd2CardCPP-43">static uint8_t spiRec() {</front>
<front id="Sd2CardCPP-44">  SPDR = 0XFF;</front>
<front id="Sd2CardCPP-45">  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-46">  return SPDR;</front>
<front id="Sd2CardCPP-47">}</front>
<front id="Sd2CardCPP-48">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-49">/** SPI read data - only one call so force inline */</front>
<front id="Sd2CardCPP-50">static inline __attribute__((always_inline))</front>
<front id="Sd2CardCPP-51">void spiRead(uint8_t* buf, uint16_t nbyte) {</front>
<front id="Sd2CardCPP-52">  if (nbyte-- == 0) return;</front>
<front id="Sd2CardCPP-53">  SPDR = 0XFF;</front>
<front id="Sd2CardCPP-54">  for (uint16_t i = 0; i &lt; nbyte; i++) {</front>
<front id="Sd2CardCPP-55">    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-56">    buf[i] = SPDR;</front>
<front id="Sd2CardCPP-57">    SPDR = 0XFF;</front>
<front id="Sd2CardCPP-58">  }</front>
<front id="Sd2CardCPP-59">  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-60">  buf[nbyte] = SPDR;</front>
<front id="Sd2CardCPP-61">}</front>
<front id="Sd2CardCPP-62">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-63">/** SPI send a byte */</front>
<front id="Sd2CardCPP-64">static void spiSend(uint8_t b) {</front>
<front id="Sd2CardCPP-65">  SPDR = b;</front>
<front id="Sd2CardCPP-66">  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-67">}</front>
<front id="Sd2CardCPP-68">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-69">/** SPI send block - only one call so force inline */</front>
<front id="Sd2CardCPP-70">static inline __attribute__((always_inline))</front>
<front id="Sd2CardCPP-71">  void spiSendBlock(uint8_t token, const uint8_t* buf) {</front>
<front id="Sd2CardCPP-72">  SPDR = token;</front>
<front id="Sd2CardCPP-73">  for (uint16_t i = 0; i &lt; 512; i += 2) {</front>
<front id="Sd2CardCPP-74">    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-75">    SPDR = buf[i];</front>
<front id="Sd2CardCPP-76">    while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-77">    SPDR = buf[i + 1];</front>
<front id="Sd2CardCPP-78">  }</front>
<front id="Sd2CardCPP-79">  while (!TEST(SPSR, SPIF)) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-80">}</front>
<front id="Sd2CardCPP-81">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-82">#else  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-83">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-84">/** nop to tune soft SPI timing */</front>
<front id="Sd2CardCPP-85">#define nop asm volatile ("nop\n\t")</front>
<front id="Sd2CardCPP-86">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-87">/** Soft SPI receive byte */</front>
<front id="Sd2CardCPP-88">static uint8_t spiRec() {</front>
<front id="Sd2CardCPP-89">  uint8_t data = 0;</front>
<front id="Sd2CardCPP-90">  // no interrupts during byte receive - about 8 us</front>
<front id="Sd2CardCPP-91">  cli();</front>
<front id="Sd2CardCPP-92">  // output pin high - like sending 0XFF</front>
<front id="Sd2CardCPP-93">  fastDigitalWrite(SPI_MOSI_PIN, HIGH);</front>
<front id="Sd2CardCPP-94"></front>
<front id="Sd2CardCPP-95">  for (uint8_t i = 0; i &lt; 8; i++) {</front>
<front id="Sd2CardCPP-96">    fastDigitalWrite(SPI_SCK_PIN, HIGH);</front>
<front id="Sd2CardCPP-97"></front>
<front id="Sd2CardCPP-98">    // adjust so SCK is nice</front>
<front id="Sd2CardCPP-99">    nop;</front>
<front id="Sd2CardCPP-100">    nop;</front>
<front id="Sd2CardCPP-101"></front>
<front id="Sd2CardCPP-102">    data &lt;&lt;= 1;</front>
<front id="Sd2CardCPP-103"></front>
<front id="Sd2CardCPP-104">    if (fastDigitalRead(SPI_MISO_PIN)) data |= 1;</front>
<front id="Sd2CardCPP-105"></front>
<front id="Sd2CardCPP-106">    fastDigitalWrite(SPI_SCK_PIN, LOW);</front>
<front id="Sd2CardCPP-107">  }</front>
<front id="Sd2CardCPP-108">  // enable interrupts</front>
<front id="Sd2CardCPP-109">  sei();</front>
<front id="Sd2CardCPP-110">  return data;</front>
<front id="Sd2CardCPP-111">}</front>
<front id="Sd2CardCPP-112">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-113">/** Soft SPI read data */</front>
<front id="Sd2CardCPP-114">static void spiRead(uint8_t* buf, uint16_t nbyte) {</front>
<front id="Sd2CardCPP-115">  for (uint16_t i = 0; i &lt; nbyte; i++) {</front>
<front id="Sd2CardCPP-116">    buf[i] = spiRec();</front>
<front id="Sd2CardCPP-117">  }</front>
<front id="Sd2CardCPP-118">}</front>
<front id="Sd2CardCPP-119">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-120">/** Soft SPI send byte */</front>
<front id="Sd2CardCPP-121">static void spiSend(uint8_t data) {</front>
<front id="Sd2CardCPP-122">  // no interrupts during byte send - about 8 us</front>
<front id="Sd2CardCPP-123">  cli();</front>
<front id="Sd2CardCPP-124">  for (uint8_t i = 0; i &lt; 8; i++) {</front>
<front id="Sd2CardCPP-125">    fastDigitalWrite(SPI_SCK_PIN, LOW);</front>
<front id="Sd2CardCPP-126"></front>
<front id="Sd2CardCPP-127">    fastDigitalWrite(SPI_MOSI_PIN, data & 0X80);</front>
<front id="Sd2CardCPP-128"></front>
<front id="Sd2CardCPP-129">    data &lt;&lt;= 1;</front>
<front id="Sd2CardCPP-130"></front>
<front id="Sd2CardCPP-131">    fastDigitalWrite(SPI_SCK_PIN, HIGH);</front>
<front id="Sd2CardCPP-132">  }</front>
<front id="Sd2CardCPP-133">  // hold SCK high for a few ns</front>
<front id="Sd2CardCPP-134">  nop;</front>
<front id="Sd2CardCPP-135">  nop;</front>
<front id="Sd2CardCPP-136">  nop;</front>
<front id="Sd2CardCPP-137">  nop;</front>
<front id="Sd2CardCPP-138"></front>
<front id="Sd2CardCPP-139">  fastDigitalWrite(SPI_SCK_PIN, LOW);</front>
<front id="Sd2CardCPP-140">  // enable interrupts</front>
<front id="Sd2CardCPP-141">  sei();</front>
<front id="Sd2CardCPP-142">}</front>
<front id="Sd2CardCPP-143">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-144">/** Soft SPI send block */</front>
<front id="Sd2CardCPP-145">  void spiSendBlock(uint8_t token, const uint8_t* buf) {</front>
<front id="Sd2CardCPP-146">  spiSend(token);</front>
<front id="Sd2CardCPP-147">  for (uint16_t i = 0; i &lt; 512; i++) {</front>
<front id="Sd2CardCPP-148">    spiSend(buf[i]);</front>
<front id="Sd2CardCPP-149">  }</front>
<front id="Sd2CardCPP-150">}</front>
<front id="Sd2CardCPP-151">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-152">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-153">// send command and return error code.  Return zero for OK</front>
<front id="Sd2CardCPP-154">uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg) {</front>
<front id="Sd2CardCPP-155">  // select card</front>
<front id="Sd2CardCPP-156">  chipSelectLow();</front>
<front id="Sd2CardCPP-157"></front>
<front id="Sd2CardCPP-158">  // wait up to 300 ms if busy</front>
<front id="Sd2CardCPP-159">  waitNotBusy(300);</front>
<front id="Sd2CardCPP-160"></front>
<front id="Sd2CardCPP-161">  // send command</front>
<front id="Sd2CardCPP-162">  spiSend(cmd | 0x40);</front>
<front id="Sd2CardCPP-163"></front>
<front id="Sd2CardCPP-164">  // send argument</front>
<front id="Sd2CardCPP-165">  for (int8_t s = 24; s &gt;= 0; s -= 8) spiSend(arg &gt;&gt; s);</front>
<front id="Sd2CardCPP-166"></front>
<front id="Sd2CardCPP-167">  // send CRC</front>
<front id="Sd2CardCPP-168">  uint8_t crc = 0XFF;</front>
<front id="Sd2CardCPP-169">  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0</front>
<front id="Sd2CardCPP-170">  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA</front>
<front id="Sd2CardCPP-171">  spiSend(crc);</front>
<front id="Sd2CardCPP-172"></front>
<front id="Sd2CardCPP-173">  // skip stuff byte for stop read</front>
<front id="Sd2CardCPP-174">  if (cmd == CMD12) spiRec();</front>
<front id="Sd2CardCPP-175"></front>
<front id="Sd2CardCPP-176">  // wait for response</front>
<front id="Sd2CardCPP-177">  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++) { /* Intentionally left empty */ }</front>
<front id="Sd2CardCPP-178">  return status_;</front>
<front id="Sd2CardCPP-179">}</front>
<front id="Sd2CardCPP-180">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-181">/**</front>
<front id="Sd2CardCPP-182"> * Determine the size of an SD flash memory card.</front>
<front id="Sd2CardCPP-183"> *</front>
<front id="Sd2CardCPP-184"> * \return The number of 512 byte data blocks in the card</front>
<front id="Sd2CardCPP-185"> *         or zero if an error occurs.</front>
<front id="Sd2CardCPP-186"> */</front>
<front id="Sd2CardCPP-187">uint32_t Sd2Card::cardSize() {</front>
<front id="Sd2CardCPP-188">  csd_t csd;</front>
<front id="Sd2CardCPP-189">  if (!readCSD(&csd)) return 0;</front>
<front id="Sd2CardCPP-190">  if (csd.v1.csd_ver == 0) {</front>
<front id="Sd2CardCPP-191">    uint8_t read_bl_len = csd.v1.read_bl_len;</front>
<front id="Sd2CardCPP-192">    uint16_t c_size = (csd.v1.c_size_high &lt;&lt; 10)</front>
<front id="Sd2CardCPP-193">                      | (csd.v1.c_size_mid &lt;&lt; 2) | csd.v1.c_size_low;</front>
<front id="Sd2CardCPP-194">    uint8_t c_size_mult = (csd.v1.c_size_mult_high &lt;&lt; 1)</front>
<front id="Sd2CardCPP-195">                          | csd.v1.c_size_mult_low;</front>
<front id="Sd2CardCPP-196">    return (uint32_t)(c_size + 1) &lt;&lt; (c_size_mult + read_bl_len - 7);</front>
<front id="Sd2CardCPP-197">  } else if (csd.v2.csd_ver == 1) {</front>
<front id="Sd2CardCPP-198">    uint32_t c_size = ((uint32_t)csd.v2.c_size_high &lt;&lt; 16)</front>
<front id="Sd2CardCPP-199">                      | (csd.v2.c_size_mid &lt;&lt; 8) | csd.v2.c_size_low;</front>
<front id="Sd2CardCPP-200">    return (c_size + 1) &lt;&lt; 10;</front>
<front id="Sd2CardCPP-201">  } else {</front>
<front id="Sd2CardCPP-202">    error(SD_CARD_ERROR_BAD_CSD);</front>
<front id="Sd2CardCPP-203">    return 0;</front>
<front id="Sd2CardCPP-204">  }</front>
<front id="Sd2CardCPP-205">}</front>
<front id="Sd2CardCPP-206">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-207">void Sd2Card::chipSelectHigh() {</front>
<front id="Sd2CardCPP-208">  digitalWrite(chipSelectPin_, HIGH);</front>
<front id="Sd2CardCPP-209">}</front>
<front id="Sd2CardCPP-210">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-211">void Sd2Card::chipSelectLow() {</front>
<front id="Sd2CardCPP-212">#if DISABLED(SOFTWARE_SPI)</front>
<front id="Sd2CardCPP-213">  spiInit(spiRate_);</front>
<front id="Sd2CardCPP-214">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-215">  digitalWrite(chipSelectPin_, LOW);</front>
<front id="Sd2CardCPP-216">}</front>
<front id="Sd2CardCPP-217">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-218">/** Erase a range of blocks.</front>
<front id="Sd2CardCPP-219"> *</front>
<front id="Sd2CardCPP-220"> * \param[in] firstBlock The address of the first block in the range.</front>
<front id="Sd2CardCPP-221"> * \param[in] lastBlock The address of the last block in the range.</front>
<front id="Sd2CardCPP-222"> *</front>
<front id="Sd2CardCPP-223"> * \note This function requests the SD card to do a flash erase for a</front>
<front id="Sd2CardCPP-224"> * range of blocks.  The data on the card after an erase operation is</front>
<front id="Sd2CardCPP-225"> * either 0 or 1, depends on the card vendor.  The card must support</front>
<front id="Sd2CardCPP-226"> * single block erase.</front>
<front id="Sd2CardCPP-227"> *</front>
<front id="Sd2CardCPP-228"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-229"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-230"> */</front>
<front id="Sd2CardCPP-231">bool Sd2Card::erase(uint32_t firstBlock, uint32_t lastBlock) {</front>
<front id="Sd2CardCPP-232">  csd_t csd;</front>
<front id="Sd2CardCPP-233">  if (!readCSD(&csd)) goto fail;</front>
<front id="Sd2CardCPP-234">  // check for single block erase</front>
<front id="Sd2CardCPP-235">  if (!csd.v1.erase_blk_en) {</front>
<front id="Sd2CardCPP-236">    // erase size mask</front>
<front id="Sd2CardCPP-237">    uint8_t m = (csd.v1.sector_size_high &lt;&lt; 1) | csd.v1.sector_size_low;</front>
<front id="Sd2CardCPP-238">    if ((firstBlock & m) != 0 || ((lastBlock + 1) & m) != 0) {</front>
<front id="Sd2CardCPP-239">      // error card can't erase specified area</front>
<front id="Sd2CardCPP-240">      error(SD_CARD_ERROR_ERASE_SINGLE_BLOCK);</front>
<front id="Sd2CardCPP-241">      goto fail;</front>
<front id="Sd2CardCPP-242">    }</front>
<front id="Sd2CardCPP-243">  }</front>
<front id="Sd2CardCPP-244">  if (type_ != SD_CARD_TYPE_SDHC) {</front>
<front id="Sd2CardCPP-245">    firstBlock &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-246">    lastBlock &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-247">  }</front>
<front id="Sd2CardCPP-248">  if (cardCommand(CMD32, firstBlock)</front>
<front id="Sd2CardCPP-249">    || cardCommand(CMD33, lastBlock)</front>
<front id="Sd2CardCPP-250">    || cardCommand(CMD38, 0)) {</front>
<front id="Sd2CardCPP-251">      error(SD_CARD_ERROR_ERASE);</front>
<front id="Sd2CardCPP-252">      goto fail;</front>
<front id="Sd2CardCPP-253">  }</front>
<front id="Sd2CardCPP-254">  if (!waitNotBusy(SD_ERASE_TIMEOUT)) {</front>
<front id="Sd2CardCPP-255">    error(SD_CARD_ERROR_ERASE_TIMEOUT);</front>
<front id="Sd2CardCPP-256">    goto fail;</front>
<front id="Sd2CardCPP-257">  }</front>
<front id="Sd2CardCPP-258">  chipSelectHigh();</front>
<front id="Sd2CardCPP-259">  return true;</front>
<front id="Sd2CardCPP-260"></front>
<front id="Sd2CardCPP-261"> fail:</front>
<front id="Sd2CardCPP-262">  chipSelectHigh();</front>
<front id="Sd2CardCPP-263">  return false;</front>
<front id="Sd2CardCPP-264">}</front>
<front id="Sd2CardCPP-265">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-266">/** Determine if card supports single block erase.</front>
<front id="Sd2CardCPP-267"> *</front>
<front id="Sd2CardCPP-268"> * \return The value one, true, is returned if single block erase is supported.</front>
<front id="Sd2CardCPP-269"> * The value zero, false, is returned if single block erase is not supported.</front>
<front id="Sd2CardCPP-270"> */</front>
<front id="Sd2CardCPP-271">bool Sd2Card::eraseSingleBlockEnable() {</front>
<front id="Sd2CardCPP-272">  csd_t csd;</front>
<front id="Sd2CardCPP-273">  return readCSD(&csd) ? csd.v1.erase_blk_en : false;</front>
<front id="Sd2CardCPP-274">}</front>
<front id="Sd2CardCPP-275">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-276">/**</front>
<front id="Sd2CardCPP-277"> * Initialize an SD flash memory card.</front>
<front id="Sd2CardCPP-278"> *</front>
<front id="Sd2CardCPP-279"> * \param[in] sckRateID SPI clock rate selector. See setSckRate().</front>
<front id="Sd2CardCPP-280"> * \param[in] chipSelectPin SD chip select pin number.</front>
<front id="Sd2CardCPP-281"> *</front>
<front id="Sd2CardCPP-282"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-283"> * the value zero, false, is returned for failure.  The reason for failure</front>
<front id="Sd2CardCPP-284"> * can be determined by calling errorCode() and errorData().</front>
<front id="Sd2CardCPP-285"> */</front>
<front id="Sd2CardCPP-286">bool Sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin) {</front>
<front id="Sd2CardCPP-287">  errorCode_ = type_ = 0;</front>
<front id="Sd2CardCPP-288">  chipSelectPin_ = chipSelectPin;</front>
<front id="Sd2CardCPP-289">  // 16-bit init start time allows over a minute</front>
<front id="Sd2CardCPP-290">  uint16_t t0 = (uint16_t)millis();</front>
<front id="Sd2CardCPP-291">  uint32_t arg;</front>
<front id="Sd2CardCPP-292"></front>
<front id="Sd2CardCPP-293">  // set pin modes</front>
<front id="Sd2CardCPP-294">  pinMode(chipSelectPin_, OUTPUT);</front>
<front id="Sd2CardCPP-295">  chipSelectHigh();</front>
<front id="Sd2CardCPP-296">  pinMode(SPI_MISO_PIN, INPUT);</front>
<front id="Sd2CardCPP-297">  pinMode(SPI_MOSI_PIN, OUTPUT);</front>
<front id="Sd2CardCPP-298">  pinMode(SPI_SCK_PIN, OUTPUT);</front>
<front id="Sd2CardCPP-299"></front>
<front id="Sd2CardCPP-300">#if DISABLED(SOFTWARE_SPI)</front>
<front id="Sd2CardCPP-301">  // SS must be in output mode even it is not chip select</front>
<front id="Sd2CardCPP-302">  pinMode(SS_PIN, OUTPUT);</front>
<front id="Sd2CardCPP-303">  // set SS high - may be chip select for another SPI device</front>
<front id="Sd2CardCPP-304">#if SET_SPI_SS_HIGH</front>
<front id="Sd2CardCPP-305">  digitalWrite(SS_PIN, HIGH);</front>
<front id="Sd2CardCPP-306">#endif  // SET_SPI_SS_HIGH</front>
<front id="Sd2CardCPP-307">  // set SCK rate for initialization commands</front>
<front id="Sd2CardCPP-308">  spiRate_ = SPI_SD_INIT_RATE;</front>
<front id="Sd2CardCPP-309">  spiInit(spiRate_);</front>
<front id="Sd2CardCPP-310">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-311"></front>
<front id="Sd2CardCPP-312">  // must supply min of 74 clock cycles with CS high.</front>
<front id="Sd2CardCPP-313">  for (uint8_t i = 0; i &lt; 10; i++) spiSend(0XFF);</front>
<front id="Sd2CardCPP-314"></front>
<front id="Sd2CardCPP-315">  // command to go idle in SPI mode</front>
<front id="Sd2CardCPP-316">  while ((status_ = cardCommand(CMD0, 0)) != R1_IDLE_STATE) {</front>
<front id="Sd2CardCPP-317">    if (((uint16_t)millis() - t0) &gt; SD_INIT_TIMEOUT) {</front>
<front id="Sd2CardCPP-318">      error(SD_CARD_ERROR_CMD0);</front>
<front id="Sd2CardCPP-319">      goto fail;</front>
<front id="Sd2CardCPP-320">    }</front>
<front id="Sd2CardCPP-321">  }</front>
<front id="Sd2CardCPP-322">  // check SD version</front>
<front id="Sd2CardCPP-323">  if ((cardCommand(CMD8, 0x1AA) & R1_ILLEGAL_COMMAND)) {</front>
<front id="Sd2CardCPP-324">    type(SD_CARD_TYPE_SD1);</front>
<front id="Sd2CardCPP-325">  } else {</front>
<front id="Sd2CardCPP-326">    // only need last byte of r7 response</front>
<front id="Sd2CardCPP-327">    for (uint8_t i = 0; i &lt; 4; i++) status_ = spiRec();</front>
<front id="Sd2CardCPP-328">    if (status_ != 0XAA) {</front>
<front id="Sd2CardCPP-329">      error(SD_CARD_ERROR_CMD8);</front>
<front id="Sd2CardCPP-330">      goto fail;</front>
<front id="Sd2CardCPP-331">    }</front>
<front id="Sd2CardCPP-332">    type(SD_CARD_TYPE_SD2);</front>
<front id="Sd2CardCPP-333">  }</front>
<front id="Sd2CardCPP-334">  // initialize card and send host supports SDHC if SD2</front>
<front id="Sd2CardCPP-335">  arg = type() == SD_CARD_TYPE_SD2 ? 0X40000000 : 0;</front>
<front id="Sd2CardCPP-336"></front>
<front id="Sd2CardCPP-337">  while ((status_ = cardAcmd(ACMD41, arg)) != R1_READY_STATE) {</front>
<front id="Sd2CardCPP-338">    // check for timeout</front>
<front id="Sd2CardCPP-339">    if (((uint16_t)millis() - t0) &gt; SD_INIT_TIMEOUT) {</front>
<front id="Sd2CardCPP-340">      error(SD_CARD_ERROR_ACMD41);</front>
<front id="Sd2CardCPP-341">      goto fail;</front>
<front id="Sd2CardCPP-342">    }</front>
<front id="Sd2CardCPP-343">  }</front>
<front id="Sd2CardCPP-344">  // if SD2 read OCR register to check for SDHC card</front>
<front id="Sd2CardCPP-345">  if (type() == SD_CARD_TYPE_SD2) {</front>
<front id="Sd2CardCPP-346">    if (cardCommand(CMD58, 0)) {</front>
<front id="Sd2CardCPP-347">      error(SD_CARD_ERROR_CMD58);</front>
<front id="Sd2CardCPP-348">      goto fail;</front>
<front id="Sd2CardCPP-349">    }</front>
<front id="Sd2CardCPP-350">    if ((spiRec() & 0XC0) == 0XC0) type(SD_CARD_TYPE_SDHC);</front>
<front id="Sd2CardCPP-351">    // discard rest of ocr - contains allowed voltage range</front>
<front id="Sd2CardCPP-352">    for (uint8_t i = 0; i &lt; 3; i++) spiRec();</front>
<front id="Sd2CardCPP-353">  }</front>
<front id="Sd2CardCPP-354">  chipSelectHigh();</front>
<front id="Sd2CardCPP-355"></front>
<front id="Sd2CardCPP-356">#if DISABLED(SOFTWARE_SPI)</front>
<front id="Sd2CardCPP-357">  return setSckRate(sckRateID);</front>
<front id="Sd2CardCPP-358">#else  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-359">  return true;</front>
<front id="Sd2CardCPP-360">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardCPP-361"></front>
<front id="Sd2CardCPP-362"> fail:</front>
<front id="Sd2CardCPP-363">  chipSelectHigh();</front>
<front id="Sd2CardCPP-364">  return false;</front>
<front id="Sd2CardCPP-365">}</front>
<front id="Sd2CardCPP-366">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-367">/**</front>
<front id="Sd2CardCPP-368"> * Read a 512 byte block from an SD card.</front>
<front id="Sd2CardCPP-369"> *</front>
<front id="Sd2CardCPP-370"> * \param[in] blockNumber Logical block to be read.</front>
<front id="Sd2CardCPP-371"> * \param[out] dst Pointer to the location that will receive the data.</front>
<front id="Sd2CardCPP-372"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-373"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-374"> */</front>
<front id="Sd2CardCPP-375">bool Sd2Card::readBlock(uint32_t blockNumber, uint8_t* dst) {</front>
<front id="Sd2CardCPP-376">#if ENABLED(SD_CHECK_AND_RETRY)</front>
<front id="Sd2CardCPP-377">  uint8_t retryCnt = 3;</front>
<front id="Sd2CardCPP-378">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-379">  if (type()!= SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-380"> retry2:</front>
<front id="Sd2CardCPP-381">  retryCnt --;</front>
<front id="Sd2CardCPP-382">  if (cardCommand(CMD17, blockNumber)) {</front>
<front id="Sd2CardCPP-383">    error(SD_CARD_ERROR_CMD17);</front>
<front id="Sd2CardCPP-384">    if (retryCnt &gt; 0) goto retry;</front>
<front id="Sd2CardCPP-385">    goto fail;</front>
<front id="Sd2CardCPP-386">  }</front>
<front id="Sd2CardCPP-387">  if (!readData(dst, 512))</front>
<front id="Sd2CardCPP-388">  {</front>
<front id="Sd2CardCPP-389">    if (retryCnt &gt; 0) goto retry;</front>
<front id="Sd2CardCPP-390">    goto fail;</front>
<front id="Sd2CardCPP-391">  }</front>
<front id="Sd2CardCPP-392">  return true;</front>
<front id="Sd2CardCPP-393"> retry:</front>
<front id="Sd2CardCPP-394">   chipSelectHigh();</front>
<front id="Sd2CardCPP-395">   cardCommand(CMD12, 0);//Try sending a stop command, but ignore the result.</front>
<front id="Sd2CardCPP-396">   errorCode_ = 0;</front>
<front id="Sd2CardCPP-397">   goto retry2;</front>
<front id="Sd2CardCPP-398">#else</front>
<front id="Sd2CardCPP-399">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-400">  if (type()!= SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-401">  if (cardCommand(CMD17, blockNumber)) {</front>
<front id="Sd2CardCPP-402">    error(SD_CARD_ERROR_CMD17);</front>
<front id="Sd2CardCPP-403">    goto fail;</front>
<front id="Sd2CardCPP-404">  }</front>
<front id="Sd2CardCPP-405">  return readData(dst, 512);</front>
<front id="Sd2CardCPP-406">#endif</front>
<front id="Sd2CardCPP-407"></front>
<front id="Sd2CardCPP-408"> fail:</front>
<front id="Sd2CardCPP-409">  chipSelectHigh();</front>
<front id="Sd2CardCPP-410">  return false;</front>
<front id="Sd2CardCPP-411">}</front>
<front id="Sd2CardCPP-412">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-413">/** Read one data block in a multiple block read sequence</front>
<front id="Sd2CardCPP-414"> *</front>
<front id="Sd2CardCPP-415"> * \param[in] dst Pointer to the location for the data to be read.</front>
<front id="Sd2CardCPP-416"> *</front>
<front id="Sd2CardCPP-417"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-418"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-419"> */</front>
<front id="Sd2CardCPP-420">bool Sd2Card::readData(uint8_t *dst) {</front>
<front id="Sd2CardCPP-421">  chipSelectLow();</front>
<front id="Sd2CardCPP-422">  return readData(dst, 512);</front>
<front id="Sd2CardCPP-423">}</front>
<front id="Sd2CardCPP-424"></front>
<front id="Sd2CardCPP-425">#if ENABLED(SD_CHECK_AND_RETRY)</front>
<front id="Sd2CardCPP-426">static const uint16_t crctab[] PROGMEM = {</front>
<front id="Sd2CardCPP-427">  0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,</front>
<front id="Sd2CardCPP-428">  0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,</front>
<front id="Sd2CardCPP-429">  0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,</front>
<front id="Sd2CardCPP-430">  0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,</front>
<front id="Sd2CardCPP-431">  0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,</front>
<front id="Sd2CardCPP-432">  0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,</front>
<front id="Sd2CardCPP-433">  0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,</front>
<front id="Sd2CardCPP-434">  0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,</front>
<front id="Sd2CardCPP-435">  0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,</front>
<front id="Sd2CardCPP-436">  0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,</front>
<front id="Sd2CardCPP-437">  0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,</front>
<front id="Sd2CardCPP-438">  0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,</front>
<front id="Sd2CardCPP-439">  0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,</front>
<front id="Sd2CardCPP-440">  0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,</front>
<front id="Sd2CardCPP-441">  0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,</front>
<front id="Sd2CardCPP-442">  0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,</front>
<front id="Sd2CardCPP-443">  0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,</front>
<front id="Sd2CardCPP-444">  0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,</front>
<front id="Sd2CardCPP-445">  0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,</front>
<front id="Sd2CardCPP-446">  0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,</front>
<front id="Sd2CardCPP-447">  0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,</front>
<front id="Sd2CardCPP-448">  0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,</front>
<front id="Sd2CardCPP-449">  0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,</front>
<front id="Sd2CardCPP-450">  0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,</front>
<front id="Sd2CardCPP-451">  0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,</front>
<front id="Sd2CardCPP-452">  0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,</front>
<front id="Sd2CardCPP-453">  0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,</front>
<front id="Sd2CardCPP-454">  0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,</front>
<front id="Sd2CardCPP-455">  0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,</front>
<front id="Sd2CardCPP-456">  0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,</front>
<front id="Sd2CardCPP-457">  0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,</front>
<front id="Sd2CardCPP-458">  0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0</front>
<front id="Sd2CardCPP-459">};</front>
<front id="Sd2CardCPP-460">static uint16_t CRC_CCITT(const uint8_t* data, size_t n) {</front>
<front id="Sd2CardCPP-461">  uint16_t crc = 0;</front>
<front id="Sd2CardCPP-462">  for (size_t i = 0; i &lt; n; i++) {</front>
<front id="Sd2CardCPP-463">    crc = pgm_read_word(&crctab[(crc &gt;&gt; 8 ^ data[i]) & 0XFF]) ^ (crc &lt;&lt; 8);</front>
<front id="Sd2CardCPP-464">  }</front>
<front id="Sd2CardCPP-465">  return crc;</front>
<front id="Sd2CardCPP-466">}</front>
<front id="Sd2CardCPP-467">#endif</front>
<front id="Sd2CardCPP-468"></front>
<front id="Sd2CardCPP-469">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-470">bool Sd2Card::readData(uint8_t* dst, uint16_t count) {</front>
<front id="Sd2CardCPP-471">  // wait for start block token</front>
<front id="Sd2CardCPP-472">  uint16_t t0 = millis();</front>
<front id="Sd2CardCPP-473">  while ((status_ = spiRec()) == 0XFF) {</front>
<front id="Sd2CardCPP-474">    if (((uint16_t)millis() - t0) &gt; SD_READ_TIMEOUT) {</front>
<front id="Sd2CardCPP-475">      error(SD_CARD_ERROR_READ_TIMEOUT);</front>
<front id="Sd2CardCPP-476">      goto fail;</front>
<front id="Sd2CardCPP-477">    }</front>
<front id="Sd2CardCPP-478">  }</front>
<front id="Sd2CardCPP-479">  if (status_ != DATA_START_BLOCK) {</front>
<front id="Sd2CardCPP-480">    error(SD_CARD_ERROR_READ);</front>
<front id="Sd2CardCPP-481">    goto fail;</front>
<front id="Sd2CardCPP-482">  }</front>
<front id="Sd2CardCPP-483">  // transfer data</front>
<front id="Sd2CardCPP-484">  spiRead(dst, count);</front>
<front id="Sd2CardCPP-485"></front>
<front id="Sd2CardCPP-486">#if ENABLED(SD_CHECK_AND_RETRY)</front>
<front id="Sd2CardCPP-487">  {</front>
<front id="Sd2CardCPP-488">    uint16_t calcCrc = CRC_CCITT(dst, count);</front>
<front id="Sd2CardCPP-489">    uint16_t recvCrc = spiRec() &lt;&lt; 8;</front>
<front id="Sd2CardCPP-490">    recvCrc |= spiRec();</front>
<front id="Sd2CardCPP-491">    if (calcCrc != recvCrc)</front>
<front id="Sd2CardCPP-492">    {</front>
<front id="Sd2CardCPP-493">        error(SD_CARD_ERROR_CRC);</front>
<front id="Sd2CardCPP-494">        goto fail;</front>
<front id="Sd2CardCPP-495">    }</front>
<front id="Sd2CardCPP-496">  }</front>
<front id="Sd2CardCPP-497">#else</front>
<front id="Sd2CardCPP-498">  // discard CRC</front>
<front id="Sd2CardCPP-499">  spiRec();</front>
<front id="Sd2CardCPP-500">  spiRec();</front>
<front id="Sd2CardCPP-501">#endif</front>
<front id="Sd2CardCPP-502">  chipSelectHigh();</front>
<front id="Sd2CardCPP-503">  return true;</front>
<front id="Sd2CardCPP-504"></front>
<front id="Sd2CardCPP-505"> fail:</front>
<front id="Sd2CardCPP-506">  chipSelectHigh();</front>
<front id="Sd2CardCPP-507">  return false;</front>
<front id="Sd2CardCPP-508">}</front>
<front id="Sd2CardCPP-509">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-510">/** read CID or CSR register */</front>
<front id="Sd2CardCPP-511">bool Sd2Card::readRegister(uint8_t cmd, void* buf) {</front>
<front id="Sd2CardCPP-512">  uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(buf);</front>
<front id="Sd2CardCPP-513">  if (cardCommand(cmd, 0)) {</front>
<front id="Sd2CardCPP-514">    error(SD_CARD_ERROR_READ_REG);</front>
<front id="Sd2CardCPP-515">    goto fail;</front>
<front id="Sd2CardCPP-516">  }</front>
<front id="Sd2CardCPP-517">  return readData(dst, 16);</front>
<front id="Sd2CardCPP-518"></front>
<front id="Sd2CardCPP-519"> fail:</front>
<front id="Sd2CardCPP-520">  chipSelectHigh();</front>
<front id="Sd2CardCPP-521">  return false;</front>
<front id="Sd2CardCPP-522">}</front>
<front id="Sd2CardCPP-523">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-524">/** Start a read multiple blocks sequence.</front>
<front id="Sd2CardCPP-525"> *</front>
<front id="Sd2CardCPP-526"> * \param[in] blockNumber Address of first block in sequence.</front>
<front id="Sd2CardCPP-527"> *</front>
<front id="Sd2CardCPP-528"> * \note This function is used with readData() and readStop() for optimized</front>
<front id="Sd2CardCPP-529"> * multiple block reads.  SPI chipSelect must be low for the entire sequence.</front>
<front id="Sd2CardCPP-530"> *</front>
<front id="Sd2CardCPP-531"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-532"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-533"> */</front>
<front id="Sd2CardCPP-534">bool Sd2Card::readStart(uint32_t blockNumber) {</front>
<front id="Sd2CardCPP-535">  if (type()!= SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-536">  if (cardCommand(CMD18, blockNumber)) {</front>
<front id="Sd2CardCPP-537">    error(SD_CARD_ERROR_CMD18);</front>
<front id="Sd2CardCPP-538">    goto fail;</front>
<front id="Sd2CardCPP-539">  }</front>
<front id="Sd2CardCPP-540">  chipSelectHigh();</front>
<front id="Sd2CardCPP-541">  return true;</front>
<front id="Sd2CardCPP-542"></front>
<front id="Sd2CardCPP-543"> fail:</front>
<front id="Sd2CardCPP-544">  chipSelectHigh();</front>
<front id="Sd2CardCPP-545">  return false;</front>
<front id="Sd2CardCPP-546">}</front>
<front id="Sd2CardCPP-547">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-548">/** End a read multiple blocks sequence.</front>
<front id="Sd2CardCPP-549"> *</front>
<front id="Sd2CardCPP-550">* \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-551"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-552"> */</front>
<front id="Sd2CardCPP-553">bool Sd2Card::readStop() {</front>
<front id="Sd2CardCPP-554">  chipSelectLow();</front>
<front id="Sd2CardCPP-555">  if (cardCommand(CMD12, 0)) {</front>
<front id="Sd2CardCPP-556">    error(SD_CARD_ERROR_CMD12);</front>
<front id="Sd2CardCPP-557">    goto fail;</front>
<front id="Sd2CardCPP-558">  }</front>
<front id="Sd2CardCPP-559">  chipSelectHigh();</front>
<front id="Sd2CardCPP-560">  return true;</front>
<front id="Sd2CardCPP-561"></front>
<front id="Sd2CardCPP-562"> fail:</front>
<front id="Sd2CardCPP-563">  chipSelectHigh();</front>
<front id="Sd2CardCPP-564">  return false;</front>
<front id="Sd2CardCPP-565">}</front>
<front id="Sd2CardCPP-566">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-567">/**</front>
<front id="Sd2CardCPP-568"> * Set the SPI clock rate.</front>
<front id="Sd2CardCPP-569"> *</front>
<front id="Sd2CardCPP-570"> * \param[in] sckRateID A value in the range [0, 6].</front>
<front id="Sd2CardCPP-571"> *</front>
<front id="Sd2CardCPP-572"> * The SPI clock will be set to F_CPU/pow(2, 1 + sckRateID). The maximum</front>
<front id="Sd2CardCPP-573"> * SPI rate is F_CPU/2 for \a sckRateID = 0 and the minimum rate is F_CPU/128</front>
<front id="Sd2CardCPP-574"> * for \a scsRateID = 6.</front>
<front id="Sd2CardCPP-575"> *</front>
<front id="Sd2CardCPP-576"> * \return The value one, true, is returned for success and the value zero,</front>
<front id="Sd2CardCPP-577"> * false, is returned for an invalid value of \a sckRateID.</front>
<front id="Sd2CardCPP-578"> */</front>
<front id="Sd2CardCPP-579">bool Sd2Card::setSckRate(uint8_t sckRateID) {</front>
<front id="Sd2CardCPP-580">  if (sckRateID &gt; 6) {</front>
<front id="Sd2CardCPP-581">    error(SD_CARD_ERROR_SCK_RATE);</front>
<front id="Sd2CardCPP-582">    return false;</front>
<front id="Sd2CardCPP-583">  }</front>
<front id="Sd2CardCPP-584">  spiRate_ = sckRateID;</front>
<front id="Sd2CardCPP-585">  return true;</front>
<front id="Sd2CardCPP-586">}</front>
<front id="Sd2CardCPP-587">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-588">// wait for card to go not busy</front>
<front id="Sd2CardCPP-589">bool Sd2Card::waitNotBusy(uint16_t timeoutMillis) {</front>
<front id="Sd2CardCPP-590">  uint16_t t0 = millis();</front>
<front id="Sd2CardCPP-591">  while (spiRec() != 0XFF) {</front>
<front id="Sd2CardCPP-592">    if (((uint16_t)millis() - t0) &gt;= timeoutMillis) goto fail;</front>
<front id="Sd2CardCPP-593">  }</front>
<front id="Sd2CardCPP-594">  return true;</front>
<front id="Sd2CardCPP-595"></front>
<front id="Sd2CardCPP-596"> fail:</front>
<front id="Sd2CardCPP-597">  return false;</front>
<front id="Sd2CardCPP-598">}</front>
<front id="Sd2CardCPP-599">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-600">/**</front>
<front id="Sd2CardCPP-601"> * Writes a 512 byte block to an SD card.</front>
<front id="Sd2CardCPP-602"> *</front>
<front id="Sd2CardCPP-603"> * \param[in] blockNumber Logical block to be written.</front>
<front id="Sd2CardCPP-604"> * \param[in] src Pointer to the location of the data to be written.</front>
<front id="Sd2CardCPP-605"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-606"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-607"> */</front>
<front id="Sd2CardCPP-608">bool Sd2Card::writeBlock(uint32_t blockNumber, const uint8_t* src) {</front>
<front id="Sd2CardCPP-609">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-610">  if (type() != SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-611">  if (cardCommand(CMD24, blockNumber)) {</front>
<front id="Sd2CardCPP-612">    error(SD_CARD_ERROR_CMD24);</front>
<front id="Sd2CardCPP-613">    goto fail;</front>
<front id="Sd2CardCPP-614">  }</front>
<front id="Sd2CardCPP-615">  if (!writeData(DATA_START_BLOCK, src)) goto fail;</front>
<front id="Sd2CardCPP-616"></front>
<front id="Sd2CardCPP-617">  // wait for flash programming to complete</front>
<front id="Sd2CardCPP-618">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {</front>
<front id="Sd2CardCPP-619">    error(SD_CARD_ERROR_WRITE_TIMEOUT);</front>
<front id="Sd2CardCPP-620">    goto fail;</front>
<front id="Sd2CardCPP-621">  }</front>
<front id="Sd2CardCPP-622">  // response is r2 so get and check two bytes for nonzero</front>
<front id="Sd2CardCPP-623">  if (cardCommand(CMD13, 0) || spiRec()) {</front>
<front id="Sd2CardCPP-624">    error(SD_CARD_ERROR_WRITE_PROGRAMMING);</front>
<front id="Sd2CardCPP-625">    goto fail;</front>
<front id="Sd2CardCPP-626">  }</front>
<front id="Sd2CardCPP-627">  chipSelectHigh();</front>
<front id="Sd2CardCPP-628">  return true;</front>
<front id="Sd2CardCPP-629"></front>
<front id="Sd2CardCPP-630"> fail:</front>
<front id="Sd2CardCPP-631">  chipSelectHigh();</front>
<front id="Sd2CardCPP-632">  return false;</front>
<front id="Sd2CardCPP-633">}</front>
<front id="Sd2CardCPP-634">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-635">/** Write one data block in a multiple block write sequence</front>
<front id="Sd2CardCPP-636"> * \param[in] src Pointer to the location of the data to be written.</front>
<front id="Sd2CardCPP-637"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-638"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-639"> */</front>
<front id="Sd2CardCPP-640">bool Sd2Card::writeData(const uint8_t* src) {</front>
<front id="Sd2CardCPP-641">  chipSelectLow();</front>
<front id="Sd2CardCPP-642">  // wait for previous write to finish</front>
<front id="Sd2CardCPP-643">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;</front>
<front id="Sd2CardCPP-644">  if (!writeData(WRITE_MULTIPLE_TOKEN, src)) goto fail;</front>
<front id="Sd2CardCPP-645">  chipSelectHigh();</front>
<front id="Sd2CardCPP-646">  return true;</front>
<front id="Sd2CardCPP-647"></front>
<front id="Sd2CardCPP-648"> fail:</front>
<front id="Sd2CardCPP-649">  error(SD_CARD_ERROR_WRITE_MULTIPLE);</front>
<front id="Sd2CardCPP-650">  chipSelectHigh();</front>
<front id="Sd2CardCPP-651">  return false;</front>
<front id="Sd2CardCPP-652">}</front>
<front id="Sd2CardCPP-653">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-654">// send one block of data for write block or write multiple blocks</front>
<front id="Sd2CardCPP-655">bool Sd2Card::writeData(uint8_t token, const uint8_t* src) {</front>
<front id="Sd2CardCPP-656">  spiSendBlock(token, src);</front>
<front id="Sd2CardCPP-657"></front>
<front id="Sd2CardCPP-658">  spiSend(0xff);  // dummy crc</front>
<front id="Sd2CardCPP-659">  spiSend(0xff);  // dummy crc</front>
<front id="Sd2CardCPP-660"></front>
<front id="Sd2CardCPP-661">  status_ = spiRec();</front>
<front id="Sd2CardCPP-662">  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {</front>
<front id="Sd2CardCPP-663">    error(SD_CARD_ERROR_WRITE);</front>
<front id="Sd2CardCPP-664">    goto fail;</front>
<front id="Sd2CardCPP-665">  }</front>
<front id="Sd2CardCPP-666">  return true;</front>
<front id="Sd2CardCPP-667"></front>
<front id="Sd2CardCPP-668"> fail:</front>
<front id="Sd2CardCPP-669">  chipSelectHigh();</front>
<front id="Sd2CardCPP-670">  return false;</front>
<front id="Sd2CardCPP-671">}</front>
<front id="Sd2CardCPP-672">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-673">/** Start a write multiple blocks sequence.</front>
<front id="Sd2CardCPP-674"> *</front>
<front id="Sd2CardCPP-675"> * \param[in] blockNumber Address of first block in sequence.</front>
<front id="Sd2CardCPP-676"> * \param[in] eraseCount The number of blocks to be pre-erased.</front>
<front id="Sd2CardCPP-677"> *</front>
<front id="Sd2CardCPP-678"> * \note This function is used with writeData() and writeStop()</front>
<front id="Sd2CardCPP-679"> * for optimized multiple block writes.</front>
<front id="Sd2CardCPP-680"> *</front>
<front id="Sd2CardCPP-681"> * \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-682"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-683"> */</front>
<front id="Sd2CardCPP-684">bool Sd2Card::writeStart(uint32_t blockNumber, uint32_t eraseCount) {</front>
<front id="Sd2CardCPP-685">  // send pre-erase count</front>
<front id="Sd2CardCPP-686">  if (cardAcmd(ACMD23, eraseCount)) {</front>
<front id="Sd2CardCPP-687">    error(SD_CARD_ERROR_ACMD23);</front>
<front id="Sd2CardCPP-688">    goto fail;</front>
<front id="Sd2CardCPP-689">  }</front>
<front id="Sd2CardCPP-690">  // use address if not SDHC card</front>
<front id="Sd2CardCPP-691">  if (type() != SD_CARD_TYPE_SDHC) blockNumber &lt;&lt;= 9;</front>
<front id="Sd2CardCPP-692">  if (cardCommand(CMD25, blockNumber)) {</front>
<front id="Sd2CardCPP-693">    error(SD_CARD_ERROR_CMD25);</front>
<front id="Sd2CardCPP-694">    goto fail;</front>
<front id="Sd2CardCPP-695">  }</front>
<front id="Sd2CardCPP-696">  chipSelectHigh();</front>
<front id="Sd2CardCPP-697">  return true;</front>
<front id="Sd2CardCPP-698"></front>
<front id="Sd2CardCPP-699"> fail:</front>
<front id="Sd2CardCPP-700">  chipSelectHigh();</front>
<front id="Sd2CardCPP-701">  return false;</front>
<front id="Sd2CardCPP-702">}</front>
<front id="Sd2CardCPP-703">//------------------------------------------------------------------------------</front>
<front id="Sd2CardCPP-704">/** End a write multiple blocks sequence.</front>
<front id="Sd2CardCPP-705"> *</front>
<front id="Sd2CardCPP-706">* \return The value one, true, is returned for success and</front>
<front id="Sd2CardCPP-707"> * the value zero, false, is returned for failure.</front>
<front id="Sd2CardCPP-708"> */</front>
<front id="Sd2CardCPP-709">bool Sd2Card::writeStop() {</front>
<front id="Sd2CardCPP-710">  chipSelectLow();</front>
<front id="Sd2CardCPP-711">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;</front>
<front id="Sd2CardCPP-712">  spiSend(STOP_TRAN_TOKEN);</front>
<front id="Sd2CardCPP-713">  if (!waitNotBusy(SD_WRITE_TIMEOUT)) goto fail;</front>
<front id="Sd2CardCPP-714">  chipSelectHigh();</front>
<front id="Sd2CardCPP-715">  return true;</front>
<front id="Sd2CardCPP-716"></front>
<front id="Sd2CardCPP-717"> fail:</front>
<front id="Sd2CardCPP-718">  error(SD_CARD_ERROR_STOP_TRAN);</front>
<front id="Sd2CardCPP-719">  chipSelectHigh();</front>
<front id="Sd2CardCPP-720">  return false;</front>
<front id="Sd2CardCPP-721">}</front>
<front id="Sd2CardCPP-722"></front>
<front id="Sd2CardCPP-723">#endif</front>
 </pre>
<h1 id="Sd2CardHtitle" >Sd2Card.h</h1>
<pre id="Sd2CardH"  class="prettyprint linenums"><front id="Sd2CardH-1">/* Arduino Sd2Card Library</front>
<front id="Sd2CardH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="Sd2CardH-3"> *</front>
<front id="Sd2CardH-4"> * This file is part of the Arduino Sd2Card Library</front>
<front id="Sd2CardH-5"> *</front>
<front id="Sd2CardH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="Sd2CardH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="Sd2CardH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Sd2CardH-9"> * (at your option) any later version.</front>
<front id="Sd2CardH-10"> *</front>
<front id="Sd2CardH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="Sd2CardH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Sd2CardH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Sd2CardH-14"> * GNU General Public License for more details.</front>
<front id="Sd2CardH-15"> *</front>
<front id="Sd2CardH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="Sd2CardH-17"> * along with the Arduino Sd2Card Library.  If not, see</front>
<front id="Sd2CardH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Sd2CardH-19"> */</front>
<front id="Sd2CardH-20"></front>
<front id="Sd2CardH-21">#include "Marlin.h"</front>
<front id="Sd2CardH-22">#if ENABLED(SDSUPPORT)</front>
<front id="Sd2CardH-23"></front>
<front id="Sd2CardH-24">#ifndef Sd2Card_h</front>
<front id="Sd2CardH-25">#define Sd2Card_h</front>
<front id="Sd2CardH-26">/**</front>
<front id="Sd2CardH-27"> * \file</front>
<front id="Sd2CardH-28"> * \brief Sd2Card class for V2 SD/SDHC cards</front>
<front id="Sd2CardH-29"> */</front>
<front id="Sd2CardH-30">#include "SdFatConfig.h"</front>
<front id="Sd2CardH-31">#include "Sd2PinMap.h"</front>
<front id="Sd2CardH-32">#include "SdInfo.h"</front>
<front id="Sd2CardH-33">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-34">// SPI speed is F_CPU/2^(1 + index), 0 &lt;= index &lt;= 6</front>
<front id="Sd2CardH-35">/** Set SCK to max rate of F_CPU/2. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-36">uint8_t const SPI_FULL_SPEED = 0;</front>
<front id="Sd2CardH-37">/** Set SCK rate to F_CPU/4. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-38">uint8_t const SPI_HALF_SPEED = 1;</front>
<front id="Sd2CardH-39">/** Set SCK rate to F_CPU/8. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-40">uint8_t const SPI_QUARTER_SPEED = 2;</front>
<front id="Sd2CardH-41">/** Set SCK rate to F_CPU/16. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-42">uint8_t const SPI_EIGHTH_SPEED = 3;</front>
<front id="Sd2CardH-43">/** Set SCK rate to F_CPU/32. See Sd2Card::setSckRate(). */</front>
<front id="Sd2CardH-44">uint8_t const SPI_SIXTEENTH_SPEED = 4;</front>
<front id="Sd2CardH-45">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-46">/** init timeout ms */</front>
<front id="Sd2CardH-47">uint16_t const SD_INIT_TIMEOUT = 2000;</front>
<front id="Sd2CardH-48">/** erase timeout ms */</front>
<front id="Sd2CardH-49">uint16_t const SD_ERASE_TIMEOUT = 10000;</front>
<front id="Sd2CardH-50">/** read timeout ms */</front>
<front id="Sd2CardH-51">uint16_t const SD_READ_TIMEOUT = 300;</front>
<front id="Sd2CardH-52">/** write time out ms */</front>
<front id="Sd2CardH-53">uint16_t const SD_WRITE_TIMEOUT = 600;</front>
<front id="Sd2CardH-54">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-55">// SD card errors</front>
<front id="Sd2CardH-56">/** timeout error for command CMD0 (initialize card in SPI mode) */</front>
<front id="Sd2CardH-57">uint8_t const SD_CARD_ERROR_CMD0 = 0X1;</front>
<front id="Sd2CardH-58">/** CMD8 was not accepted - not a valid SD card*/</front>
<front id="Sd2CardH-59">uint8_t const SD_CARD_ERROR_CMD8 = 0X2;</front>
<front id="Sd2CardH-60">/** card returned an error response for CMD12 (write stop) */</front>
<front id="Sd2CardH-61">uint8_t const SD_CARD_ERROR_CMD12 = 0X3;</front>
<front id="Sd2CardH-62">/** card returned an error response for CMD17 (read block) */</front>
<front id="Sd2CardH-63">uint8_t const SD_CARD_ERROR_CMD17 = 0X4;</front>
<front id="Sd2CardH-64">/** card returned an error response for CMD18 (read multiple block) */</front>
<front id="Sd2CardH-65">uint8_t const SD_CARD_ERROR_CMD18 = 0X5;</front>
<front id="Sd2CardH-66">/** card returned an error response for CMD24 (write block) */</front>
<front id="Sd2CardH-67">uint8_t const SD_CARD_ERROR_CMD24 = 0X6;</front>
<front id="Sd2CardH-68">/**  WRITE_MULTIPLE_BLOCKS command failed */</front>
<front id="Sd2CardH-69">uint8_t const SD_CARD_ERROR_CMD25 = 0X7;</front>
<front id="Sd2CardH-70">/** card returned an error response for CMD58 (read OCR) */</front>
<front id="Sd2CardH-71">uint8_t const SD_CARD_ERROR_CMD58 = 0X8;</front>
<front id="Sd2CardH-72">/** SET_WR_BLK_ERASE_COUNT failed */</front>
<front id="Sd2CardH-73">uint8_t const SD_CARD_ERROR_ACMD23 = 0X9;</front>
<front id="Sd2CardH-74">/** ACMD41 initialization process timeout */</front>
<front id="Sd2CardH-75">uint8_t const SD_CARD_ERROR_ACMD41 = 0XA;</front>
<front id="Sd2CardH-76">/** card returned a bad CSR version field */</front>
<front id="Sd2CardH-77">uint8_t const SD_CARD_ERROR_BAD_CSD = 0XB;</front>
<front id="Sd2CardH-78">/** erase block group command failed */</front>
<front id="Sd2CardH-79">uint8_t const SD_CARD_ERROR_ERASE = 0XC;</front>
<front id="Sd2CardH-80">/** card not capable of single block erase */</front>
<front id="Sd2CardH-81">uint8_t const SD_CARD_ERROR_ERASE_SINGLE_BLOCK = 0XD;</front>
<front id="Sd2CardH-82">/** Erase sequence timed out */</front>
<front id="Sd2CardH-83">uint8_t const SD_CARD_ERROR_ERASE_TIMEOUT = 0XE;</front>
<front id="Sd2CardH-84">/** card returned an error token instead of read data */</front>
<front id="Sd2CardH-85">uint8_t const SD_CARD_ERROR_READ = 0XF;</front>
<front id="Sd2CardH-86">/** read CID or CSD failed */</front>
<front id="Sd2CardH-87">uint8_t const SD_CARD_ERROR_READ_REG = 0X10;</front>
<front id="Sd2CardH-88">/** timeout while waiting for start of read data */</front>
<front id="Sd2CardH-89">uint8_t const SD_CARD_ERROR_READ_TIMEOUT = 0X11;</front>
<front id="Sd2CardH-90">/** card did not accept STOP_TRAN_TOKEN */</front>
<front id="Sd2CardH-91">uint8_t const SD_CARD_ERROR_STOP_TRAN = 0X12;</front>
<front id="Sd2CardH-92">/** card returned an error token as a response to a write operation */</front>
<front id="Sd2CardH-93">uint8_t const SD_CARD_ERROR_WRITE = 0X13;</front>
<front id="Sd2CardH-94">/** attempt to write protected block zero */</front>
<front id="Sd2CardH-95">uint8_t const SD_CARD_ERROR_WRITE_BLOCK_ZERO = 0X14;  // REMOVE - not used</front>
<front id="Sd2CardH-96">/** card did not go ready for a multiple block write */</front>
<front id="Sd2CardH-97">uint8_t const SD_CARD_ERROR_WRITE_MULTIPLE = 0X15;</front>
<front id="Sd2CardH-98">/** card returned an error to a CMD13 status check after a write */</front>
<front id="Sd2CardH-99">uint8_t const SD_CARD_ERROR_WRITE_PROGRAMMING = 0X16;</front>
<front id="Sd2CardH-100">/** timeout occurred during write programming */</front>
<front id="Sd2CardH-101">uint8_t const SD_CARD_ERROR_WRITE_TIMEOUT = 0X17;</front>
<front id="Sd2CardH-102">/** incorrect rate selected */</front>
<front id="Sd2CardH-103">uint8_t const SD_CARD_ERROR_SCK_RATE = 0X18;</front>
<front id="Sd2CardH-104">/** init() not called */</front>
<front id="Sd2CardH-105">uint8_t const SD_CARD_ERROR_INIT_NOT_CALLED = 0X19;</front>
<front id="Sd2CardH-106">/** crc check error */</front>
<front id="Sd2CardH-107">uint8_t const SD_CARD_ERROR_CRC = 0X20;</front>
<front id="Sd2CardH-108">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-109">// card types</front>
<front id="Sd2CardH-110">/** Standard capacity V1 SD card */</front>
<front id="Sd2CardH-111">uint8_t const SD_CARD_TYPE_SD1  = 1;</front>
<front id="Sd2CardH-112">/** Standard capacity V2 SD card */</front>
<front id="Sd2CardH-113">uint8_t const SD_CARD_TYPE_SD2  = 2;</front>
<front id="Sd2CardH-114">/** High Capacity SD card */</front>
<front id="Sd2CardH-115">uint8_t const SD_CARD_TYPE_SDHC = 3;</front>
<front id="Sd2CardH-116">/**</front>
<front id="Sd2CardH-117"> * define SOFTWARE_SPI to use bit-bang SPI</front>
<front id="Sd2CardH-118"> */</front>
<front id="Sd2CardH-119">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-120">#if MEGA_SOFT_SPI && (defined(__AVR_ATmega1280__)||defined(__AVR_ATmega2560__))</front>
<front id="Sd2CardH-121">#define SOFTWARE_SPI</front>
<front id="Sd2CardH-122">#elif USE_SOFTWARE_SPI</front>
<front id="Sd2CardH-123">#define SOFTWARE_SPI</front>
<front id="Sd2CardH-124">#endif  // MEGA_SOFT_SPI</front>
<front id="Sd2CardH-125">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-126">// SPI pin definitions - do not edit here - change in SdFatConfig.h</front>
<front id="Sd2CardH-127">//</front>
<front id="Sd2CardH-128">#if DISABLED(SOFTWARE_SPI)</front>
<front id="Sd2CardH-129">// hardware pin defs</front>
<front id="Sd2CardH-130">/** The default chip select pin for the SD card is SS. */</front>
<front id="Sd2CardH-131">uint8_t const  SD_CHIP_SELECT_PIN = SS_PIN;</front>
<front id="Sd2CardH-132">// The following three pins must not be redefined for hardware SPI.</front>
<front id="Sd2CardH-133">/** SPI Master Out Slave In pin */</front>
<front id="Sd2CardH-134">uint8_t const  SPI_MOSI_PIN = MOSI_PIN;</front>
<front id="Sd2CardH-135">/** SPI Master In Slave Out pin */</front>
<front id="Sd2CardH-136">uint8_t const  SPI_MISO_PIN = MISO_PIN;</front>
<front id="Sd2CardH-137">/** SPI Clock pin */</front>
<front id="Sd2CardH-138">uint8_t const  SPI_SCK_PIN = SCK_PIN;</front>
<front id="Sd2CardH-139"></front>
<front id="Sd2CardH-140">#else  // SOFTWARE_SPI</front>
<front id="Sd2CardH-141"></front>
<front id="Sd2CardH-142">/** SPI chip select pin */</front>
<front id="Sd2CardH-143">uint8_t const SD_CHIP_SELECT_PIN = SOFT_SPI_CS_PIN;</front>
<front id="Sd2CardH-144">/** SPI Master Out Slave In pin */</front>
<front id="Sd2CardH-145">uint8_t const SPI_MOSI_PIN = SOFT_SPI_MOSI_PIN;</front>
<front id="Sd2CardH-146">/** SPI Master In Slave Out pin */</front>
<front id="Sd2CardH-147">uint8_t const SPI_MISO_PIN = SOFT_SPI_MISO_PIN;</front>
<front id="Sd2CardH-148">/** SPI Clock pin */</front>
<front id="Sd2CardH-149">uint8_t const SPI_SCK_PIN = SOFT_SPI_SCK_PIN;</front>
<front id="Sd2CardH-150">#endif  // SOFTWARE_SPI</front>
<front id="Sd2CardH-151">//------------------------------------------------------------------------------</front>
<front id="Sd2CardH-152">/**</front>
<front id="Sd2CardH-153"> * \class Sd2Card</front>
<front id="Sd2CardH-154"> * \brief Raw access to SD and SDHC flash memory cards.</front>
<front id="Sd2CardH-155"> */</front>
<front id="Sd2CardH-156">class Sd2Card {</front>
<front id="Sd2CardH-157"> public:</front>
<front id="Sd2CardH-158">  /** Construct an instance of Sd2Card. */</front>
<front id="Sd2CardH-159">  Sd2Card() : errorCode_(SD_CARD_ERROR_INIT_NOT_CALLED), type_(0) {}</front>
<front id="Sd2CardH-160">  uint32_t cardSize();</front>
<front id="Sd2CardH-161">  bool erase(uint32_t firstBlock, uint32_t lastBlock);</front>
<front id="Sd2CardH-162">  bool eraseSingleBlockEnable();</front>
<front id="Sd2CardH-163">  /**</front>
<front id="Sd2CardH-164">   *  Set SD error code.</front>
<front id="Sd2CardH-165">   *  \param[in] code value for error code.</front>
<front id="Sd2CardH-166">   */</front>
<front id="Sd2CardH-167">  void error(uint8_t code) {errorCode_ = code;}</front>
<front id="Sd2CardH-168">  /**</front>
<front id="Sd2CardH-169">   * \return error code for last error. See Sd2Card.h for a list of error codes.</front>
<front id="Sd2CardH-170">   */</front>
<front id="Sd2CardH-171">  int errorCode() const {return errorCode_;}</front>
<front id="Sd2CardH-172">  /** \return error data for last error. */</front>
<front id="Sd2CardH-173">  int errorData() const {return status_;}</front>
<front id="Sd2CardH-174">  /**</front>
<front id="Sd2CardH-175">   * Initialize an SD flash memory card with default clock rate and chip</front>
<front id="Sd2CardH-176">   * select pin.  See sd2Card::init(uint8_t sckRateID, uint8_t chipSelectPin).</front>
<front id="Sd2CardH-177">   *</front>
<front id="Sd2CardH-178">   * \return true for success or false for failure.</front>
<front id="Sd2CardH-179">   */</front>
<front id="Sd2CardH-180">  bool init(uint8_t sckRateID = SPI_FULL_SPEED,</front>
<front id="Sd2CardH-181">    uint8_t chipSelectPin = SD_CHIP_SELECT_PIN);</front>
<front id="Sd2CardH-182">  bool readBlock(uint32_t block, uint8_t* dst);</front>
<front id="Sd2CardH-183">  /**</front>
<front id="Sd2CardH-184">   * Read a card's CID register. The CID contains card identification</front>
<front id="Sd2CardH-185">   * information such as Manufacturer ID, Product name, Product serial</front>
<front id="Sd2CardH-186">   * number and Manufacturing date. </front>
<front id="Sd2CardH-187">   *</front>
<front id="Sd2CardH-188">   * \param[out] cid pointer to area for returned data.</front>
<front id="Sd2CardH-189">   *</front>
<front id="Sd2CardH-190">   * \return true for success or false for failure.</front>
<front id="Sd2CardH-191">   */</front>
<front id="Sd2CardH-192">  bool readCID(cid_t* cid) {</front>
<front id="Sd2CardH-193">    return readRegister(CMD10, cid);</front>
<front id="Sd2CardH-194">  }</front>
<front id="Sd2CardH-195">  /**</front>
<front id="Sd2CardH-196">   * Read a card's CSD register. The CSD contains Card-Specific Data that</front>
<front id="Sd2CardH-197">   * provides information regarding access to the card's contents.</front>
<front id="Sd2CardH-198">   *</front>
<front id="Sd2CardH-199">   * \param[out] csd pointer to area for returned data.</front>
<front id="Sd2CardH-200">   *</front>
<front id="Sd2CardH-201">   * \return true for success or false for failure.</front>
<front id="Sd2CardH-202">   */</front>
<front id="Sd2CardH-203">  bool readCSD(csd_t* csd) {</front>
<front id="Sd2CardH-204">    return readRegister(CMD9, csd);</front>
<front id="Sd2CardH-205">  }</front>
<front id="Sd2CardH-206">  bool readData(uint8_t *dst);</front>
<front id="Sd2CardH-207">  bool readStart(uint32_t blockNumber);</front>
<front id="Sd2CardH-208">  bool readStop();</front>
<front id="Sd2CardH-209">  bool setSckRate(uint8_t sckRateID);</front>
<front id="Sd2CardH-210">  /** Return the card type: SD V1, SD V2 or SDHC</front>
<front id="Sd2CardH-211">   * \return 0 - SD V1, 1 - SD V2, or 3 - SDHC.</front>
<front id="Sd2CardH-212">   */</front>
<front id="Sd2CardH-213">  int type() const {return type_;}</front>
<front id="Sd2CardH-214">  bool writeBlock(uint32_t blockNumber, const uint8_t* src);</front>
<front id="Sd2CardH-215">  bool writeData(const uint8_t* src);</front>
<front id="Sd2CardH-216">  bool writeStart(uint32_t blockNumber, uint32_t eraseCount);</front>
<front id="Sd2CardH-217">  bool writeStop();</front>
<front id="Sd2CardH-218"> private:</front>
<front id="Sd2CardH-219">  //----------------------------------------------------------------------------</front>
<front id="Sd2CardH-220">  uint8_t chipSelectPin_;</front>
<front id="Sd2CardH-221">  uint8_t errorCode_;</front>
<front id="Sd2CardH-222">  uint8_t spiRate_;</front>
<front id="Sd2CardH-223">  uint8_t status_;</front>
<front id="Sd2CardH-224">  uint8_t type_;</front>
<front id="Sd2CardH-225">  // private functions</front>
<front id="Sd2CardH-226">  uint8_t cardAcmd(uint8_t cmd, uint32_t arg) {</front>
<front id="Sd2CardH-227">    cardCommand(CMD55, 0);</front>
<front id="Sd2CardH-228">    return cardCommand(cmd, arg);</front>
<front id="Sd2CardH-229">  }</front>
<front id="Sd2CardH-230">  uint8_t cardCommand(uint8_t cmd, uint32_t arg);</front>
<front id="Sd2CardH-231"></front>
<front id="Sd2CardH-232">  bool readData(uint8_t* dst, uint16_t count);</front>
<front id="Sd2CardH-233">  bool readRegister(uint8_t cmd, void* buf);</front>
<front id="Sd2CardH-234">  void chipSelectHigh();</front>
<front id="Sd2CardH-235">  void chipSelectLow();</front>
<front id="Sd2CardH-236">  void type(uint8_t value) {type_ = value;}</front>
<front id="Sd2CardH-237">  bool waitNotBusy(uint16_t timeoutMillis);</front>
<front id="Sd2CardH-238">  bool writeData(uint8_t token, const uint8_t* src);</front>
<front id="Sd2CardH-239">};</front>
<front id="Sd2CardH-240">#endif  // Sd2Card_h</front>
<front id="Sd2CardH-241"></front>
<front id="Sd2CardH-242"></front>
<front id="Sd2CardH-243">#endif</front>
 </pre>
<h1 id="Sd2PinMapHtitle" >Sd2PinMap.h</h1>
<pre id="Sd2PinMapH"  class="prettyprint linenums"><front id="Sd2PinMapH-1">/* Arduino SdFat Library</front>
<front id="Sd2PinMapH-2"> * Copyright (C) 2010 by William Greiman</front>
<front id="Sd2PinMapH-3"> *</front>
<front id="Sd2PinMapH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="Sd2PinMapH-5"> *</front>
<front id="Sd2PinMapH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="Sd2PinMapH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="Sd2PinMapH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="Sd2PinMapH-9"> * (at your option) any later version.</front>
<front id="Sd2PinMapH-10"> *</front>
<front id="Sd2PinMapH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="Sd2PinMapH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="Sd2PinMapH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="Sd2PinMapH-14"> * GNU General Public License for more details.</front>
<front id="Sd2PinMapH-15"> *</front>
<front id="Sd2PinMapH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="Sd2PinMapH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="Sd2PinMapH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="Sd2PinMapH-19"> */</front>
<front id="Sd2PinMapH-20">// Warning this file was generated by a program.</front>
<front id="Sd2PinMapH-21">#include "Marlin.h"</front>
<front id="Sd2PinMapH-22">#include "macros.h"</front>
<front id="Sd2PinMapH-23"></front>
<front id="Sd2PinMapH-24">#if ENABLED(SDSUPPORT)</front>
<front id="Sd2PinMapH-25"></front>
<front id="Sd2PinMapH-26">#ifndef Sd2PinMap_h</front>
<front id="Sd2PinMapH-27">#define Sd2PinMap_h</front>
<front id="Sd2PinMapH-28">#include &lt;avr/io.h&gt;</front>
<front id="Sd2PinMapH-29">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-30">/** struct for mapping digital pins */</front>
<front id="Sd2PinMapH-31">struct pin_map_t {</front>
<front id="Sd2PinMapH-32">  volatile uint8_t* ddr;</front>
<front id="Sd2PinMapH-33">  volatile uint8_t* pin;</front>
<front id="Sd2PinMapH-34">  volatile uint8_t* port;</front>
<front id="Sd2PinMapH-35">  uint8_t bit;</front>
<front id="Sd2PinMapH-36">};</front>
<front id="Sd2PinMapH-37">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-38">#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) // Mega</front>
<front id="Sd2PinMapH-39"></front>
<front id="Sd2PinMapH-40">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-41">uint8_t const SDA_PIN = 20;  // D1</front>
<front id="Sd2PinMapH-42">uint8_t const SCL_PIN = 21;  // D0</front>
<front id="Sd2PinMapH-43"></front>
<front id="Sd2PinMapH-44">#undef MOSI_PIN</front>
<front id="Sd2PinMapH-45">#undef MISO_PIN</front>
<front id="Sd2PinMapH-46">#undef SCK_PIN</front>
<front id="Sd2PinMapH-47">// SPI port</front>
<front id="Sd2PinMapH-48">uint8_t const SS_PIN = 53;    // B0</front>
<front id="Sd2PinMapH-49">uint8_t const MOSI_PIN = 51;  // B2</front>
<front id="Sd2PinMapH-50">uint8_t const MISO_PIN = 50;  // B3</front>
<front id="Sd2PinMapH-51">uint8_t const SCK_PIN = 52;   // B1</front>
<front id="Sd2PinMapH-52"></front>
<front id="Sd2PinMapH-53">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-54">  {&DDRE, &PINE, &PORTE, 0},  // E0  0</front>
<front id="Sd2PinMapH-55">  {&DDRE, &PINE, &PORTE, 1},  // E1  1</front>
<front id="Sd2PinMapH-56">  {&DDRE, &PINE, &PORTE, 4},  // E4  2</front>
<front id="Sd2PinMapH-57">  {&DDRE, &PINE, &PORTE, 5},  // E5  3</front>
<front id="Sd2PinMapH-58">  {&DDRG, &PING, &PORTG, 5},  // G5  4</front>
<front id="Sd2PinMapH-59">  {&DDRE, &PINE, &PORTE, 3},  // E3  5</front>
<front id="Sd2PinMapH-60">  {&DDRH, &PINH, &PORTH, 3},  // H3  6</front>
<front id="Sd2PinMapH-61">  {&DDRH, &PINH, &PORTH, 4},  // H4  7</front>
<front id="Sd2PinMapH-62">  {&DDRH, &PINH, &PORTH, 5},  // H5  8</front>
<front id="Sd2PinMapH-63">  {&DDRH, &PINH, &PORTH, 6},  // H6  9</front>
<front id="Sd2PinMapH-64">  {&DDRB, &PINB, &PORTB, 4},  // B4 10</front>
<front id="Sd2PinMapH-65">  {&DDRB, &PINB, &PORTB, 5},  // B5 11</front>
<front id="Sd2PinMapH-66">  {&DDRB, &PINB, &PORTB, 6},  // B6 12</front>
<front id="Sd2PinMapH-67">  {&DDRB, &PINB, &PORTB, 7},  // B7 13</front>
<front id="Sd2PinMapH-68">  {&DDRJ, &PINJ, &PORTJ, 1},  // J1 14</front>
<front id="Sd2PinMapH-69">  {&DDRJ, &PINJ, &PORTJ, 0},  // J0 15</front>
<front id="Sd2PinMapH-70">  {&DDRH, &PINH, &PORTH, 1},  // H1 16</front>
<front id="Sd2PinMapH-71">  {&DDRH, &PINH, &PORTH, 0},  // H0 17</front>
<front id="Sd2PinMapH-72">  {&DDRD, &PIND, &PORTD, 3},  // D3 18</front>
<front id="Sd2PinMapH-73">  {&DDRD, &PIND, &PORTD, 2},  // D2 19</front>
<front id="Sd2PinMapH-74">  {&DDRD, &PIND, &PORTD, 1},  // D1 20</front>
<front id="Sd2PinMapH-75">  {&DDRD, &PIND, &PORTD, 0},  // D0 21</front>
<front id="Sd2PinMapH-76">  {&DDRA, &PINA, &PORTA, 0},  // A0 22</front>
<front id="Sd2PinMapH-77">  {&DDRA, &PINA, &PORTA, 1},  // A1 23</front>
<front id="Sd2PinMapH-78">  {&DDRA, &PINA, &PORTA, 2},  // A2 24</front>
<front id="Sd2PinMapH-79">  {&DDRA, &PINA, &PORTA, 3},  // A3 25</front>
<front id="Sd2PinMapH-80">  {&DDRA, &PINA, &PORTA, 4},  // A4 26</front>
<front id="Sd2PinMapH-81">  {&DDRA, &PINA, &PORTA, 5},  // A5 27</front>
<front id="Sd2PinMapH-82">  {&DDRA, &PINA, &PORTA, 6},  // A6 28</front>
<front id="Sd2PinMapH-83">  {&DDRA, &PINA, &PORTA, 7},  // A7 29</front>
<front id="Sd2PinMapH-84">  {&DDRC, &PINC, &PORTC, 7},  // C7 30</front>
<front id="Sd2PinMapH-85">  {&DDRC, &PINC, &PORTC, 6},  // C6 31</front>
<front id="Sd2PinMapH-86">  {&DDRC, &PINC, &PORTC, 5},  // C5 32</front>
<front id="Sd2PinMapH-87">  {&DDRC, &PINC, &PORTC, 4},  // C4 33</front>
<front id="Sd2PinMapH-88">  {&DDRC, &PINC, &PORTC, 3},  // C3 34</front>
<front id="Sd2PinMapH-89">  {&DDRC, &PINC, &PORTC, 2},  // C2 35</front>
<front id="Sd2PinMapH-90">  {&DDRC, &PINC, &PORTC, 1},  // C1 36</front>
<front id="Sd2PinMapH-91">  {&DDRC, &PINC, &PORTC, 0},  // C0 37</front>
<front id="Sd2PinMapH-92">  {&DDRD, &PIND, &PORTD, 7},  // D7 38</front>
<front id="Sd2PinMapH-93">  {&DDRG, &PING, &PORTG, 2},  // G2 39</front>
<front id="Sd2PinMapH-94">  {&DDRG, &PING, &PORTG, 1},  // G1 40</front>
<front id="Sd2PinMapH-95">  {&DDRG, &PING, &PORTG, 0},  // G0 41</front>
<front id="Sd2PinMapH-96">  {&DDRL, &PINL, &PORTL, 7},  // L7 42</front>
<front id="Sd2PinMapH-97">  {&DDRL, &PINL, &PORTL, 6},  // L6 43</front>
<front id="Sd2PinMapH-98">  {&DDRL, &PINL, &PORTL, 5},  // L5 44</front>
<front id="Sd2PinMapH-99">  {&DDRL, &PINL, &PORTL, 4},  // L4 45</front>
<front id="Sd2PinMapH-100">  {&DDRL, &PINL, &PORTL, 3},  // L3 46</front>
<front id="Sd2PinMapH-101">  {&DDRL, &PINL, &PORTL, 2},  // L2 47</front>
<front id="Sd2PinMapH-102">  {&DDRL, &PINL, &PORTL, 1},  // L1 48</front>
<front id="Sd2PinMapH-103">  {&DDRL, &PINL, &PORTL, 0},  // L0 49</front>
<front id="Sd2PinMapH-104">  {&DDRB, &PINB, &PORTB, 3},  // B3 50</front>
<front id="Sd2PinMapH-105">  {&DDRB, &PINB, &PORTB, 2},  // B2 51</front>
<front id="Sd2PinMapH-106">  {&DDRB, &PINB, &PORTB, 1},  // B1 52</front>
<front id="Sd2PinMapH-107">  {&DDRB, &PINB, &PORTB, 0},  // B0 53</front>
<front id="Sd2PinMapH-108">  {&DDRF, &PINF, &PORTF, 0},  // F0 54</front>
<front id="Sd2PinMapH-109">  {&DDRF, &PINF, &PORTF, 1},  // F1 55</front>
<front id="Sd2PinMapH-110">  {&DDRF, &PINF, &PORTF, 2},  // F2 56</front>
<front id="Sd2PinMapH-111">  {&DDRF, &PINF, &PORTF, 3},  // F3 57</front>
<front id="Sd2PinMapH-112">  {&DDRF, &PINF, &PORTF, 4},  // F4 58</front>
<front id="Sd2PinMapH-113">  {&DDRF, &PINF, &PORTF, 5},  // F5 59</front>
<front id="Sd2PinMapH-114">  {&DDRF, &PINF, &PORTF, 6},  // F6 60</front>
<front id="Sd2PinMapH-115">  {&DDRF, &PINF, &PORTF, 7},  // F7 61</front>
<front id="Sd2PinMapH-116">  {&DDRK, &PINK, &PORTK, 0},  // K0 62</front>
<front id="Sd2PinMapH-117">  {&DDRK, &PINK, &PORTK, 1},  // K1 63</front>
<front id="Sd2PinMapH-118">  {&DDRK, &PINK, &PORTK, 2},  // K2 64</front>
<front id="Sd2PinMapH-119">  {&DDRK, &PINK, &PORTK, 3},  // K3 65</front>
<front id="Sd2PinMapH-120">  {&DDRK, &PINK, &PORTK, 4},  // K4 66</front>
<front id="Sd2PinMapH-121">  {&DDRK, &PINK, &PORTK, 5},  // K5 67</front>
<front id="Sd2PinMapH-122">  {&DDRK, &PINK, &PORTK, 6},  // K6 68</front>
<front id="Sd2PinMapH-123">  {&DDRK, &PINK, &PORTK, 7}   // K7 69</front>
<front id="Sd2PinMapH-124">};</front>
<front id="Sd2PinMapH-125">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-126">#elif defined(__AVR_ATmega644P__)\</front>
<front id="Sd2PinMapH-127">|| defined(__AVR_ATmega644__)\</front>
<front id="Sd2PinMapH-128">|| defined(__AVR_ATmega1284P__)</front>
<front id="Sd2PinMapH-129">// Sanguino</front>
<front id="Sd2PinMapH-130"></front>
<front id="Sd2PinMapH-131">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-132">uint8_t const SDA_PIN = 17;  // C1</front>
<front id="Sd2PinMapH-133">uint8_t const SCL_PIN = 18;  // C2</front>
<front id="Sd2PinMapH-134"></front>
<front id="Sd2PinMapH-135">// SPI port</front>
<front id="Sd2PinMapH-136">uint8_t const SS_PIN = 4;    // B4</front>
<front id="Sd2PinMapH-137">uint8_t const MOSI_PIN = 5;  // B5</front>
<front id="Sd2PinMapH-138">uint8_t const MISO_PIN = 6;  // B6</front>
<front id="Sd2PinMapH-139">uint8_t const SCK_PIN = 7;   // B7</front>
<front id="Sd2PinMapH-140"></front>
<front id="Sd2PinMapH-141">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-142">  {&DDRB, &PINB, &PORTB, 0},  // B0  0</front>
<front id="Sd2PinMapH-143">  {&DDRB, &PINB, &PORTB, 1},  // B1  1</front>
<front id="Sd2PinMapH-144">  {&DDRB, &PINB, &PORTB, 2},  // B2  2</front>
<front id="Sd2PinMapH-145">  {&DDRB, &PINB, &PORTB, 3},  // B3  3</front>
<front id="Sd2PinMapH-146">  {&DDRB, &PINB, &PORTB, 4},  // B4  4</front>
<front id="Sd2PinMapH-147">  {&DDRB, &PINB, &PORTB, 5},  // B5  5</front>
<front id="Sd2PinMapH-148">  {&DDRB, &PINB, &PORTB, 6},  // B6  6</front>
<front id="Sd2PinMapH-149">  {&DDRB, &PINB, &PORTB, 7},  // B7  7</front>
<front id="Sd2PinMapH-150">  {&DDRD, &PIND, &PORTD, 0},  // D0  8</front>
<front id="Sd2PinMapH-151">  {&DDRD, &PIND, &PORTD, 1},  // D1  9</front>
<front id="Sd2PinMapH-152">  {&DDRD, &PIND, &PORTD, 2},  // D2 10</front>
<front id="Sd2PinMapH-153">  {&DDRD, &PIND, &PORTD, 3},  // D3 11</front>
<front id="Sd2PinMapH-154">  {&DDRD, &PIND, &PORTD, 4},  // D4 12</front>
<front id="Sd2PinMapH-155">  {&DDRD, &PIND, &PORTD, 5},  // D5 13</front>
<front id="Sd2PinMapH-156">  {&DDRD, &PIND, &PORTD, 6},  // D6 14</front>
<front id="Sd2PinMapH-157">  {&DDRD, &PIND, &PORTD, 7},  // D7 15</front>
<front id="Sd2PinMapH-158">  {&DDRC, &PINC, &PORTC, 0},  // C0 16</front>
<front id="Sd2PinMapH-159">  {&DDRC, &PINC, &PORTC, 1},  // C1 17</front>
<front id="Sd2PinMapH-160">  {&DDRC, &PINC, &PORTC, 2},  // C2 18</front>
<front id="Sd2PinMapH-161">  {&DDRC, &PINC, &PORTC, 3},  // C3 19</front>
<front id="Sd2PinMapH-162">  {&DDRC, &PINC, &PORTC, 4},  // C4 20</front>
<front id="Sd2PinMapH-163">  {&DDRC, &PINC, &PORTC, 5},  // C5 21</front>
<front id="Sd2PinMapH-164">  {&DDRC, &PINC, &PORTC, 6},  // C6 22</front>
<front id="Sd2PinMapH-165">  {&DDRC, &PINC, &PORTC, 7},  // C7 23</front>
<front id="Sd2PinMapH-166">  {&DDRA, &PINA, &PORTA, 7},  // A7 24</front>
<front id="Sd2PinMapH-167">  {&DDRA, &PINA, &PORTA, 6},  // A6 25</front>
<front id="Sd2PinMapH-168">  {&DDRA, &PINA, &PORTA, 5},  // A5 26</front>
<front id="Sd2PinMapH-169">  {&DDRA, &PINA, &PORTA, 4},  // A4 27</front>
<front id="Sd2PinMapH-170">  {&DDRA, &PINA, &PORTA, 3},  // A3 28</front>
<front id="Sd2PinMapH-171">  {&DDRA, &PINA, &PORTA, 2},  // A2 29</front>
<front id="Sd2PinMapH-172">  {&DDRA, &PINA, &PORTA, 1},  // A1 30</front>
<front id="Sd2PinMapH-173">  {&DDRA, &PINA, &PORTA, 0}   // A0 31</front>
<front id="Sd2PinMapH-174">};</front>
<front id="Sd2PinMapH-175">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-176">#elif defined(__AVR_ATmega32U4__)</front>
<front id="Sd2PinMapH-177">// Teensy 2.0</front>
<front id="Sd2PinMapH-178"></front>
<front id="Sd2PinMapH-179">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-180">uint8_t const SDA_PIN = 6;  // D1</front>
<front id="Sd2PinMapH-181">uint8_t const SCL_PIN = 5;  // D0</front>
<front id="Sd2PinMapH-182"></front>
<front id="Sd2PinMapH-183">// SPI port</front>
<front id="Sd2PinMapH-184">uint8_t const SS_PIN = 0;    // B0</front>
<front id="Sd2PinMapH-185">uint8_t const MOSI_PIN = 2;  // B2</front>
<front id="Sd2PinMapH-186">uint8_t const MISO_PIN = 3;  // B3</front>
<front id="Sd2PinMapH-187">uint8_t const SCK_PIN = 1;   // B1</front>
<front id="Sd2PinMapH-188"></front>
<front id="Sd2PinMapH-189">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-190">  {&DDRB, &PINB, &PORTB, 0},  // B0  0</front>
<front id="Sd2PinMapH-191">  {&DDRB, &PINB, &PORTB, 1},  // B1  1</front>
<front id="Sd2PinMapH-192">  {&DDRB, &PINB, &PORTB, 2},  // B2  2</front>
<front id="Sd2PinMapH-193">  {&DDRB, &PINB, &PORTB, 3},  // B3  3</front>
<front id="Sd2PinMapH-194">  {&DDRB, &PINB, &PORTB, 7},  // B7  4</front>
<front id="Sd2PinMapH-195">  {&DDRD, &PIND, &PORTD, 0},  // D0  5</front>
<front id="Sd2PinMapH-196">  {&DDRD, &PIND, &PORTD, 1},  // D1  6</front>
<front id="Sd2PinMapH-197">  {&DDRD, &PIND, &PORTD, 2},  // D2  7</front>
<front id="Sd2PinMapH-198">  {&DDRD, &PIND, &PORTD, 3},  // D3  8</front>
<front id="Sd2PinMapH-199">  {&DDRC, &PINC, &PORTC, 6},  // C6  9</front>
<front id="Sd2PinMapH-200">  {&DDRC, &PINC, &PORTC, 7},  // C7 10</front>
<front id="Sd2PinMapH-201">  {&DDRD, &PIND, &PORTD, 6},  // D6 11</front>
<front id="Sd2PinMapH-202">  {&DDRD, &PIND, &PORTD, 7},  // D7 12</front>
<front id="Sd2PinMapH-203">  {&DDRB, &PINB, &PORTB, 4},  // B4 13</front>
<front id="Sd2PinMapH-204">  {&DDRB, &PINB, &PORTB, 5},  // B5 14</front>
<front id="Sd2PinMapH-205">  {&DDRB, &PINB, &PORTB, 6},  // B6 15</front>
<front id="Sd2PinMapH-206">  {&DDRF, &PINF, &PORTF, 7},  // F7 16</front>
<front id="Sd2PinMapH-207">  {&DDRF, &PINF, &PORTF, 6},  // F6 17</front>
<front id="Sd2PinMapH-208">  {&DDRF, &PINF, &PORTF, 5},  // F5 18</front>
<front id="Sd2PinMapH-209">  {&DDRF, &PINF, &PORTF, 4},  // F4 19</front>
<front id="Sd2PinMapH-210">  {&DDRF, &PINF, &PORTF, 1},  // F1 20</front>
<front id="Sd2PinMapH-211">  {&DDRF, &PINF, &PORTF, 0},  // F0 21</front>
<front id="Sd2PinMapH-212">  {&DDRD, &PIND, &PORTD, 4},  // D4 22</front>
<front id="Sd2PinMapH-213">  {&DDRD, &PIND, &PORTD, 5},  // D5 23</front>
<front id="Sd2PinMapH-214">  {&DDRE, &PINE, &PORTE, 6}   // E6 24</front>
<front id="Sd2PinMapH-215">};</front>
<front id="Sd2PinMapH-216">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-217">#elif defined(__AVR_AT90USB646__)\</front>
<front id="Sd2PinMapH-218">|| defined(__AVR_AT90USB1286__)</front>
<front id="Sd2PinMapH-219">// Teensy++ 1.0 & 2.0</front>
<front id="Sd2PinMapH-220"></front>
<front id="Sd2PinMapH-221">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-222">uint8_t const SDA_PIN = 1;  // D1</front>
<front id="Sd2PinMapH-223">uint8_t const SCL_PIN = 0;  // D0</front>
<front id="Sd2PinMapH-224"></front>
<front id="Sd2PinMapH-225">// SPI port</front>
<front id="Sd2PinMapH-226">uint8_t const SS_PIN    = 20;    // B0</front>
<front id="Sd2PinMapH-227">uint8_t const MOSI_PIN  = 22;    // B2</front>
<front id="Sd2PinMapH-228">uint8_t const MISO_PIN  = 23;    // B3</front>
<front id="Sd2PinMapH-229">uint8_t const SCK_PIN   = 21;    // B1</front>
<front id="Sd2PinMapH-230"></front>
<front id="Sd2PinMapH-231">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-232">  {&DDRD, &PIND, &PORTD, 0},  // D0  0</front>
<front id="Sd2PinMapH-233">  {&DDRD, &PIND, &PORTD, 1},  // D1  1</front>
<front id="Sd2PinMapH-234">  {&DDRD, &PIND, &PORTD, 2},  // D2  2</front>
<front id="Sd2PinMapH-235">  {&DDRD, &PIND, &PORTD, 3},  // D3  3</front>
<front id="Sd2PinMapH-236">  {&DDRD, &PIND, &PORTD, 4},  // D4  4</front>
<front id="Sd2PinMapH-237">  {&DDRD, &PIND, &PORTD, 5},  // D5  5</front>
<front id="Sd2PinMapH-238">  {&DDRD, &PIND, &PORTD, 6},  // D6  6</front>
<front id="Sd2PinMapH-239">  {&DDRD, &PIND, &PORTD, 7},  // D7  7</front>
<front id="Sd2PinMapH-240">  {&DDRE, &PINE, &PORTE, 0},  // E0  8</front>
<front id="Sd2PinMapH-241">  {&DDRE, &PINE, &PORTE, 1},  // E1  9</front>
<front id="Sd2PinMapH-242">  {&DDRC, &PINC, &PORTC, 0},  // C0 10</front>
<front id="Sd2PinMapH-243">  {&DDRC, &PINC, &PORTC, 1},  // C1 11</front>
<front id="Sd2PinMapH-244">  {&DDRC, &PINC, &PORTC, 2},  // C2 12</front>
<front id="Sd2PinMapH-245">  {&DDRC, &PINC, &PORTC, 3},  // C3 13</front>
<front id="Sd2PinMapH-246">  {&DDRC, &PINC, &PORTC, 4},  // C4 14</front>
<front id="Sd2PinMapH-247">  {&DDRC, &PINC, &PORTC, 5},  // C5 15</front>
<front id="Sd2PinMapH-248">  {&DDRC, &PINC, &PORTC, 6},  // C6 16</front>
<front id="Sd2PinMapH-249">  {&DDRC, &PINC, &PORTC, 7},  // C7 17</front>
<front id="Sd2PinMapH-250">  {&DDRE, &PINE, &PORTE, 6},  // E6 18</front>
<front id="Sd2PinMapH-251">  {&DDRE, &PINE, &PORTE, 7},  // E7 19</front>
<front id="Sd2PinMapH-252">  {&DDRB, &PINB, &PORTB, 0},  // B0 20</front>
<front id="Sd2PinMapH-253">  {&DDRB, &PINB, &PORTB, 1},  // B1 21</front>
<front id="Sd2PinMapH-254">  {&DDRB, &PINB, &PORTB, 2},  // B2 22</front>
<front id="Sd2PinMapH-255">  {&DDRB, &PINB, &PORTB, 3},  // B3 23</front>
<front id="Sd2PinMapH-256">  {&DDRB, &PINB, &PORTB, 4},  // B4 24</front>
<front id="Sd2PinMapH-257">  {&DDRB, &PINB, &PORTB, 5},  // B5 25</front>
<front id="Sd2PinMapH-258">  {&DDRB, &PINB, &PORTB, 6},  // B6 26</front>
<front id="Sd2PinMapH-259">  {&DDRB, &PINB, &PORTB, 7},  // B7 27</front>
<front id="Sd2PinMapH-260">  {&DDRA, &PINA, &PORTA, 0},  // A0 28</front>
<front id="Sd2PinMapH-261">  {&DDRA, &PINA, &PORTA, 1},  // A1 29</front>
<front id="Sd2PinMapH-262">  {&DDRA, &PINA, &PORTA, 2},  // A2 30</front>
<front id="Sd2PinMapH-263">  {&DDRA, &PINA, &PORTA, 3},  // A3 31</front>
<front id="Sd2PinMapH-264">  {&DDRA, &PINA, &PORTA, 4},  // A4 32</front>
<front id="Sd2PinMapH-265">  {&DDRA, &PINA, &PORTA, 5},  // A5 33</front>
<front id="Sd2PinMapH-266">  {&DDRA, &PINA, &PORTA, 6},  // A6 34</front>
<front id="Sd2PinMapH-267">  {&DDRA, &PINA, &PORTA, 7},  // A7 35</front>
<front id="Sd2PinMapH-268">  {&DDRE, &PINE, &PORTE, 4},  // E4 36</front>
<front id="Sd2PinMapH-269">  {&DDRE, &PINE, &PORTE, 5},  // E5 37</front>
<front id="Sd2PinMapH-270">  {&DDRF, &PINF, &PORTF, 0},  // F0 38</front>
<front id="Sd2PinMapH-271">  {&DDRF, &PINF, &PORTF, 1},  // F1 39</front>
<front id="Sd2PinMapH-272">  {&DDRF, &PINF, &PORTF, 2},  // F2 40</front>
<front id="Sd2PinMapH-273">  {&DDRF, &PINF, &PORTF, 3},  // F3 41</front>
<front id="Sd2PinMapH-274">  {&DDRF, &PINF, &PORTF, 4},  // F4 42</front>
<front id="Sd2PinMapH-275">  {&DDRF, &PINF, &PORTF, 5},  // F5 43</front>
<front id="Sd2PinMapH-276">  {&DDRF, &PINF, &PORTF, 6},  // F6 44</front>
<front id="Sd2PinMapH-277">  {&DDRF, &PINF, &PORTF, 7}   // F7 45</front>
<front id="Sd2PinMapH-278">};</front>
<front id="Sd2PinMapH-279">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-280">#elif defined(__AVR_ATmega168__)\</front>
<front id="Sd2PinMapH-281">||defined(__AVR_ATmega168P__)\</front>
<front id="Sd2PinMapH-282">||defined(__AVR_ATmega328P__)</front>
<front id="Sd2PinMapH-283">// 168 and 328 Arduinos</front>
<front id="Sd2PinMapH-284"></front>
<front id="Sd2PinMapH-285">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-286">uint8_t const SDA_PIN = 18;  // C4</front>
<front id="Sd2PinMapH-287">uint8_t const SCL_PIN = 19;  // C5</front>
<front id="Sd2PinMapH-288"></front>
<front id="Sd2PinMapH-289">// SPI port</front>
<front id="Sd2PinMapH-290">uint8_t const SS_PIN = 10;    // B2</front>
<front id="Sd2PinMapH-291">uint8_t const MOSI_PIN = 11;  // B3</front>
<front id="Sd2PinMapH-292">uint8_t const MISO_PIN = 12;  // B4</front>
<front id="Sd2PinMapH-293">uint8_t const SCK_PIN = 13;   // B5</front>
<front id="Sd2PinMapH-294"></front>
<front id="Sd2PinMapH-295">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-296">  {&DDRD, &PIND, &PORTD, 0},  // D0  0</front>
<front id="Sd2PinMapH-297">  {&DDRD, &PIND, &PORTD, 1},  // D1  1</front>
<front id="Sd2PinMapH-298">  {&DDRD, &PIND, &PORTD, 2},  // D2  2</front>
<front id="Sd2PinMapH-299">  {&DDRD, &PIND, &PORTD, 3},  // D3  3</front>
<front id="Sd2PinMapH-300">  {&DDRD, &PIND, &PORTD, 4},  // D4  4</front>
<front id="Sd2PinMapH-301">  {&DDRD, &PIND, &PORTD, 5},  // D5  5</front>
<front id="Sd2PinMapH-302">  {&DDRD, &PIND, &PORTD, 6},  // D6  6</front>
<front id="Sd2PinMapH-303">  {&DDRD, &PIND, &PORTD, 7},  // D7  7</front>
<front id="Sd2PinMapH-304">  {&DDRB, &PINB, &PORTB, 0},  // B0  8</front>
<front id="Sd2PinMapH-305">  {&DDRB, &PINB, &PORTB, 1},  // B1  9</front>
<front id="Sd2PinMapH-306">  {&DDRB, &PINB, &PORTB, 2},  // B2 10</front>
<front id="Sd2PinMapH-307">  {&DDRB, &PINB, &PORTB, 3},  // B3 11</front>
<front id="Sd2PinMapH-308">  {&DDRB, &PINB, &PORTB, 4},  // B4 12</front>
<front id="Sd2PinMapH-309">  {&DDRB, &PINB, &PORTB, 5},  // B5 13</front>
<front id="Sd2PinMapH-310">  {&DDRC, &PINC, &PORTC, 0},  // C0 14</front>
<front id="Sd2PinMapH-311">  {&DDRC, &PINC, &PORTC, 1},  // C1 15</front>
<front id="Sd2PinMapH-312">  {&DDRC, &PINC, &PORTC, 2},  // C2 16</front>
<front id="Sd2PinMapH-313">  {&DDRC, &PINC, &PORTC, 3},  // C3 17</front>
<front id="Sd2PinMapH-314">  {&DDRC, &PINC, &PORTC, 4},  // C4 18</front>
<front id="Sd2PinMapH-315">  {&DDRC, &PINC, &PORTC, 5}   // C5 19</front>
<front id="Sd2PinMapH-316">};</front>
<front id="Sd2PinMapH-317">#elif defined(__AVR_ATmega1281__)</front>
<front id="Sd2PinMapH-318">// Waspmote</front>
<front id="Sd2PinMapH-319"> </front>
<front id="Sd2PinMapH-320">// Two Wire (aka I2C) ports</front>
<front id="Sd2PinMapH-321">uint8_t const SDA_PIN = 41;</front>
<front id="Sd2PinMapH-322">uint8_t const SCL_PIN = 40;</front>
<front id="Sd2PinMapH-323"> </front>
<front id="Sd2PinMapH-324"> </front>
<front id="Sd2PinMapH-325">#undef MOSI_PIN</front>
<front id="Sd2PinMapH-326">#undef MISO_PIN</front>
<front id="Sd2PinMapH-327">// SPI port</front>
<front id="Sd2PinMapH-328">uint8_t const SS_PIN = 16;    // B0</front>
<front id="Sd2PinMapH-329">uint8_t const MOSI_PIN = 11;  // B2</front>
<front id="Sd2PinMapH-330">uint8_t const MISO_PIN = 12;  // B3</front>
<front id="Sd2PinMapH-331">uint8_t const SCK_PIN = 10;   // B1</front>
<front id="Sd2PinMapH-332"> </front>
<front id="Sd2PinMapH-333">static const pin_map_t digitalPinMap[] = {</front>
<front id="Sd2PinMapH-334">    {&DDRE, &PINE, &PORTE, 0}, // E0 0</front>
<front id="Sd2PinMapH-335">    {&DDRE, &PINE, &PORTE, 1}, // E1 1</front>
<front id="Sd2PinMapH-336">    {&DDRE, &PINE, &PORTE, 3}, // E3 2</front>
<front id="Sd2PinMapH-337">    {&DDRE, &PINE, &PORTE, 4}, // E4 3</front>
<front id="Sd2PinMapH-338">    {&DDRC, &PINC, &PORTC, 4}, // C4 4</front>
<front id="Sd2PinMapH-339">    {&DDRC, &PINC, &PORTC, 5}, // C5 5</front>
<front id="Sd2PinMapH-340">    {&DDRC, &PINC, &PORTC, 6}, // C6 6</front>
<front id="Sd2PinMapH-341">    {&DDRC, &PINC, &PORTC, 7}, // C7 7</front>
<front id="Sd2PinMapH-342">    {&DDRA, &PINA, &PORTA, 2}, // A2 8</front>
<front id="Sd2PinMapH-343">    {&DDRA, &PINA, &PORTA, 3}, // A3 9</front>
<front id="Sd2PinMapH-344">    {&DDRA, &PINA, &PORTA, 4}, // A4 10</front>
<front id="Sd2PinMapH-345">    {&DDRD, &PIND, &PORTD, 5}, // D5 11</front>
<front id="Sd2PinMapH-346">    {&DDRD, &PIND, &PORTD, 6}, // D6 12</front>
<front id="Sd2PinMapH-347">    {&DDRC, &PINC, &PORTC, 1}, // C1 13</front>
<front id="Sd2PinMapH-348">    {&DDRF, &PINF, &PORTF, 1}, // F1 14</front>
<front id="Sd2PinMapH-349">    {&DDRF, &PINF, &PORTF, 2}, // F2 15</front>
<front id="Sd2PinMapH-350">    {&DDRF, &PINF, &PORTF, 3}, // F3 16</front>
<front id="Sd2PinMapH-351">    {&DDRF, &PINF, &PORTF, 4}, // F4 17</front>
<front id="Sd2PinMapH-352">    {&DDRF, &PINF, &PORTF, 5}, // F5 18</front>
<front id="Sd2PinMapH-353">    {&DDRF, &PINF, &PORTF, 6}, // F6 19</front>
<front id="Sd2PinMapH-354">    {&DDRF, &PINF, &PORTF, 7}, // F7 20</front>
<front id="Sd2PinMapH-355">    {&DDRF, &PINF, &PORTF, 0}, // F0 21</front>
<front id="Sd2PinMapH-356">    {&DDRA, &PINA, &PORTA, 1}, // A1 22</front>
<front id="Sd2PinMapH-357">    {&DDRD, &PIND, &PORTD, 7}, // D7 23</front>
<front id="Sd2PinMapH-358">    {&DDRE, &PINE, &PORTE, 5}, // E5 24</front>
<front id="Sd2PinMapH-359">    {&DDRA, &PINA, &PORTA, 6}, // A6 25</front>
<front id="Sd2PinMapH-360">    {&DDRE, &PINE, &PORTE, 2}, // E2 26</front>
<front id="Sd2PinMapH-361">    {&DDRA, &PINA, &PORTA, 5}, // A5 27</front>
<front id="Sd2PinMapH-362">    {&DDRC, &PINC, &PORTC, 0}, // C0 28</front>
<front id="Sd2PinMapH-363">    {&DDRB, &PINB, &PORTB, 0}, // B0 29</front>
<front id="Sd2PinMapH-364">    {&DDRB, &PINB, &PORTB, 1}, // B1 30</front>
<front id="Sd2PinMapH-365">    {&DDRB, &PINB, &PORTB, 2}, // B2 31</front>
<front id="Sd2PinMapH-366">    {&DDRB, &PINB, &PORTB, 3}, // B3 32</front>
<front id="Sd2PinMapH-367">    {&DDRB, &PINB, &PORTB, 4}, // B4 33</front>
<front id="Sd2PinMapH-368">    {&DDRB, &PINB, &PORTB, 5}, // B5 34</front>
<front id="Sd2PinMapH-369">    {&DDRA, &PINA, &PORTA, 0}, // A0 35</front>
<front id="Sd2PinMapH-370">    {&DDRB, &PINB, &PORTB, 6}, // B6 36</front>
<front id="Sd2PinMapH-371">    {&DDRB, &PINB, &PORTB, 7}, // B7 37</front>
<front id="Sd2PinMapH-372">    {&DDRE, &PINE, &PORTE, 6}, // E6 38</front>
<front id="Sd2PinMapH-373">    {&DDRE, &PINE, &PORTE, 7}, // E7 39</front>
<front id="Sd2PinMapH-374">    {&DDRD, &PIND, &PORTD, 0}, // D0 40</front>
<front id="Sd2PinMapH-375">    {&DDRD, &PIND, &PORTD, 1}, // D1 41</front>
<front id="Sd2PinMapH-376">    {&DDRC, &PINC, &PORTC, 3}, // C3 42</front>
<front id="Sd2PinMapH-377">    {&DDRD, &PIND, &PORTD, 2}, // D2 43</front>
<front id="Sd2PinMapH-378">    {&DDRD, &PIND, &PORTD, 3}, // D3 44</front>
<front id="Sd2PinMapH-379">    {&DDRA, &PINA, &PORTA, 7}, // A7 45</front>
<front id="Sd2PinMapH-380">    {&DDRC, &PINC, &PORTC, 2}, // C2 46</front>
<front id="Sd2PinMapH-381">    {&DDRD, &PIND, &PORTD, 4}, // D4 47</front>
<front id="Sd2PinMapH-382">    {&DDRG, &PING, &PORTG, 2}, // G2 48</front>
<front id="Sd2PinMapH-383">    {&DDRG, &PING, &PORTG, 1}, // G1 49</front>
<front id="Sd2PinMapH-384">    {&DDRG, &PING, &PORTG, 0}, // G0 50</front>
<front id="Sd2PinMapH-385">};</front>
<front id="Sd2PinMapH-386">#else  // defined(__AVR_ATmega1280__)</front>
<front id="Sd2PinMapH-387">#error unknown chip</front>
<front id="Sd2PinMapH-388">#endif  // defined(__AVR_ATmega1280__)</front>
<front id="Sd2PinMapH-389">//------------------------------------------------------------------------------</front>
<front id="Sd2PinMapH-390">static const uint8_t digitalPinCount = COUNT(digitalPinMap);</front>
<front id="Sd2PinMapH-391"></front>
<front id="Sd2PinMapH-392">uint8_t badPinNumber(void)</front>
<front id="Sd2PinMapH-393">  __attribute__((error("Pin number is too large or not a constant")));</front>
<front id="Sd2PinMapH-394"></front>
<front id="Sd2PinMapH-395">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-396">  bool getPinMode(uint8_t pin) {</front>
<front id="Sd2PinMapH-397">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-398">    return (*digitalPinMap[pin].ddr &gt;&gt; digitalPinMap[pin].bit) & 1;</front>
<front id="Sd2PinMapH-399">  } else {</front>
<front id="Sd2PinMapH-400">    return badPinNumber();</front>
<front id="Sd2PinMapH-401">  }</front>
<front id="Sd2PinMapH-402">}</front>
<front id="Sd2PinMapH-403">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-404">  void setPinMode(uint8_t pin, uint8_t mode) {</front>
<front id="Sd2PinMapH-405">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-406">    if (mode) {</front>
<front id="Sd2PinMapH-407">      *digitalPinMap[pin].ddr |= BIT(digitalPinMap[pin].bit);</front>
<front id="Sd2PinMapH-408">    } else {</front>
<front id="Sd2PinMapH-409">      *digitalPinMap[pin].ddr &= ~BIT(digitalPinMap[pin].bit);</front>
<front id="Sd2PinMapH-410">    }</front>
<front id="Sd2PinMapH-411">  } else {</front>
<front id="Sd2PinMapH-412">    badPinNumber();</front>
<front id="Sd2PinMapH-413">  }</front>
<front id="Sd2PinMapH-414">}</front>
<front id="Sd2PinMapH-415">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-416">  bool fastDigitalRead(uint8_t pin) {</front>
<front id="Sd2PinMapH-417">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-418">    return (*digitalPinMap[pin].pin &gt;&gt; digitalPinMap[pin].bit) & 1;</front>
<front id="Sd2PinMapH-419">  } else {</front>
<front id="Sd2PinMapH-420">    return badPinNumber();</front>
<front id="Sd2PinMapH-421">  }</front>
<front id="Sd2PinMapH-422">}</front>
<front id="Sd2PinMapH-423">static inline __attribute__((always_inline))</front>
<front id="Sd2PinMapH-424">  void fastDigitalWrite(uint8_t pin, uint8_t value) {</front>
<front id="Sd2PinMapH-425">  if (__builtin_constant_p(pin) && pin &lt; digitalPinCount) {</front>
<front id="Sd2PinMapH-426">    if (value) {</front>
<front id="Sd2PinMapH-427">      *digitalPinMap[pin].port |= BIT(digitalPinMap[pin].bit);</front>
<front id="Sd2PinMapH-428">    } else {</front>
<front id="Sd2PinMapH-429">      *digitalPinMap[pin].port &= ~BIT(digitalPinMap[pin].bit);</front>
<front id="Sd2PinMapH-430">    }</front>
<front id="Sd2PinMapH-431">  } else {</front>
<front id="Sd2PinMapH-432">    badPinNumber();</front>
<front id="Sd2PinMapH-433">  }</front>
<front id="Sd2PinMapH-434">}</front>
<front id="Sd2PinMapH-435">#endif  // Sd2PinMap_h</front>
<front id="Sd2PinMapH-436"></front>
<front id="Sd2PinMapH-437"></front>
<front id="Sd2PinMapH-438">#endif</front>
 </pre>
<h1 id="SdBaseFileCPPtitle" >SdBaseFile.cpp</h1>
<pre id="SdBaseFileCPP"  class="prettyprint linenums"><front id="SdBaseFileCPP-1">/* Arduino SdFat Library</front>
<front id="SdBaseFileCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdBaseFileCPP-3"> *</front>
<front id="SdBaseFileCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdBaseFileCPP-5"> *</front>
<front id="SdBaseFileCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdBaseFileCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdBaseFileCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdBaseFileCPP-9"> * (at your option) any later version.</front>
<front id="SdBaseFileCPP-10"> *</front>
<front id="SdBaseFileCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdBaseFileCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdBaseFileCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdBaseFileCPP-14"> * GNU General Public License for more details.</front>
<front id="SdBaseFileCPP-15"> *</front>
<front id="SdBaseFileCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdBaseFileCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdBaseFileCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdBaseFileCPP-19"> */</front>
<front id="SdBaseFileCPP-20"></front>
<front id="SdBaseFileCPP-21">#include "Marlin.h"</front>
<front id="SdBaseFileCPP-22">#if ENABLED(SDSUPPORT)</front>
<front id="SdBaseFileCPP-23"></front>
<front id="SdBaseFileCPP-24">#include "SdBaseFile.h"</front>
<front id="SdBaseFileCPP-25">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-26">// pointer to cwd directory</front>
<front id="SdBaseFileCPP-27">SdBaseFile* SdBaseFile::cwd_ = 0;</front>
<front id="SdBaseFileCPP-28">// callback function for date/time</front>
<front id="SdBaseFileCPP-29">void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;</front>
<front id="SdBaseFileCPP-30">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-31">// add a cluster to a file</front>
<front id="SdBaseFileCPP-32">bool SdBaseFile::addCluster() {</front>
<front id="SdBaseFileCPP-33">  if (!vol_-&gt;allocContiguous(1, &curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-34"></front>
<front id="SdBaseFileCPP-35">  // if first cluster of file link to directory entry</front>
<front id="SdBaseFileCPP-36">  if (firstCluster_ == 0) {</front>
<front id="SdBaseFileCPP-37">    firstCluster_ = curCluster_;</front>
<front id="SdBaseFileCPP-38">    flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-39">  }</front>
<front id="SdBaseFileCPP-40">  return true;</front>
<front id="SdBaseFileCPP-41"></front>
<front id="SdBaseFileCPP-42"> fail:</front>
<front id="SdBaseFileCPP-43">  return false;</front>
<front id="SdBaseFileCPP-44">}</front>
<front id="SdBaseFileCPP-45">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-46">// Add a cluster to a directory file and zero the cluster.</front>
<front id="SdBaseFileCPP-47">// return with first block of cluster in the cache</front>
<front id="SdBaseFileCPP-48">bool SdBaseFile::addDirCluster() {</front>
<front id="SdBaseFileCPP-49">  uint32_t block;</front>
<front id="SdBaseFileCPP-50">  // max folder size</front>
<front id="SdBaseFileCPP-51">  if (fileSize_/sizeof(dir_t) &gt;= 0XFFFF) goto fail;</front>
<front id="SdBaseFileCPP-52"></front>
<front id="SdBaseFileCPP-53">  if (!addCluster()) goto fail;</front>
<front id="SdBaseFileCPP-54">  if (!vol_-&gt;cacheFlush()) goto fail;</front>
<front id="SdBaseFileCPP-55"></front>
<front id="SdBaseFileCPP-56">  block = vol_-&gt;clusterStartBlock(curCluster_);</front>
<front id="SdBaseFileCPP-57"></front>
<front id="SdBaseFileCPP-58">  // set cache to first block of cluster</front>
<front id="SdBaseFileCPP-59">  vol_-&gt;cacheSetBlockNumber(block, true);</front>
<front id="SdBaseFileCPP-60"></front>
<front id="SdBaseFileCPP-61">  // zero first block of cluster</front>
<front id="SdBaseFileCPP-62">  memset(vol_-&gt;cacheBuffer_.data, 0, 512);</front>
<front id="SdBaseFileCPP-63"></front>
<front id="SdBaseFileCPP-64">  // zero rest of cluster</front>
<front id="SdBaseFileCPP-65">  for (uint8_t i = 1; i &lt; vol_-&gt;blocksPerCluster_; i++) {</front>
<front id="SdBaseFileCPP-66">    if (!vol_-&gt;writeBlock(block + i, vol_-&gt;cacheBuffer_.data)) goto fail;</front>
<front id="SdBaseFileCPP-67">  }</front>
<front id="SdBaseFileCPP-68">  // Increase directory file size by cluster size</front>
<front id="SdBaseFileCPP-69">  fileSize_ += 512UL &lt;&lt; vol_-&gt;clusterSizeShift_;</front>
<front id="SdBaseFileCPP-70">  return true;</front>
<front id="SdBaseFileCPP-71"></front>
<front id="SdBaseFileCPP-72"> fail:</front>
<front id="SdBaseFileCPP-73">  return false;</front>
<front id="SdBaseFileCPP-74">}</front>
<front id="SdBaseFileCPP-75">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-76">// cache a file's directory entry</front>
<front id="SdBaseFileCPP-77">// return pointer to cached entry or null for failure</front>
<front id="SdBaseFileCPP-78">dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {</front>
<front id="SdBaseFileCPP-79">  if (!vol_-&gt;cacheRawBlock(dirBlock_, action)) goto fail;</front>
<front id="SdBaseFileCPP-80">  return vol_-&gt;cache()-&gt;dir + dirIndex_;</front>
<front id="SdBaseFileCPP-81"></front>
<front id="SdBaseFileCPP-82"> fail:</front>
<front id="SdBaseFileCPP-83">  return 0;</front>
<front id="SdBaseFileCPP-84">}</front>
<front id="SdBaseFileCPP-85">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-86">/** Close a file and force cached data and directory information</front>
<front id="SdBaseFileCPP-87"> *  to be written to the storage device.</front>
<front id="SdBaseFileCPP-88"> *</front>
<front id="SdBaseFileCPP-89"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-90"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-91"> * Reasons for failure include no file is open or an I/O error.</front>
<front id="SdBaseFileCPP-92"> */</front>
<front id="SdBaseFileCPP-93">bool SdBaseFile::close() {</front>
<front id="SdBaseFileCPP-94">  bool rtn = sync();</front>
<front id="SdBaseFileCPP-95">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-96">  return rtn;</front>
<front id="SdBaseFileCPP-97">}</front>
<front id="SdBaseFileCPP-98">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-99">/** Check for contiguous file and return its raw block range.</front>
<front id="SdBaseFileCPP-100"> *</front>
<front id="SdBaseFileCPP-101"> * \param[out] bgnBlock the first block address for the file.</front>
<front id="SdBaseFileCPP-102"> * \param[out] endBlock the last  block address for the file.</front>
<front id="SdBaseFileCPP-103"> *</front>
<front id="SdBaseFileCPP-104"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-105"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-106"> * Reasons for failure include file is not contiguous, file has zero length</front>
<front id="SdBaseFileCPP-107"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-108"> */</front>
<front id="SdBaseFileCPP-109">bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {</front>
<front id="SdBaseFileCPP-110">  // error if no blocks</front>
<front id="SdBaseFileCPP-111">  if (firstCluster_ == 0) goto fail;</front>
<front id="SdBaseFileCPP-112"></front>
<front id="SdBaseFileCPP-113">  for (uint32_t c = firstCluster_; ; c++) {</front>
<front id="SdBaseFileCPP-114">    uint32_t next;</front>
<front id="SdBaseFileCPP-115">    if (!vol_-&gt;fatGet(c, &next)) goto fail;</front>
<front id="SdBaseFileCPP-116"></front>
<front id="SdBaseFileCPP-117">    // check for contiguous</front>
<front id="SdBaseFileCPP-118">    if (next != (c + 1)) {</front>
<front id="SdBaseFileCPP-119">      // error if not end of chain</front>
<front id="SdBaseFileCPP-120">      if (!vol_-&gt;isEOC(next)) goto fail;</front>
<front id="SdBaseFileCPP-121">      *bgnBlock = vol_-&gt;clusterStartBlock(firstCluster_);</front>
<front id="SdBaseFileCPP-122">      *endBlock = vol_-&gt;clusterStartBlock(c)</front>
<front id="SdBaseFileCPP-123">                  + vol_-&gt;blocksPerCluster_ - 1;</front>
<front id="SdBaseFileCPP-124">      return true;</front>
<front id="SdBaseFileCPP-125">    }</front>
<front id="SdBaseFileCPP-126">  }</front>
<front id="SdBaseFileCPP-127"></front>
<front id="SdBaseFileCPP-128"> fail:</front>
<front id="SdBaseFileCPP-129">  return false;</front>
<front id="SdBaseFileCPP-130">}</front>
<front id="SdBaseFileCPP-131">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-132">/** Create and open a new contiguous file of a specified size.</front>
<front id="SdBaseFileCPP-133"> *</front>
<front id="SdBaseFileCPP-134"> * \note This function only supports short DOS 8.3 names.</front>
<front id="SdBaseFileCPP-135"> * See open() for more information.</front>
<front id="SdBaseFileCPP-136"> *</front>
<front id="SdBaseFileCPP-137"> * \param[in] dirFile The directory where the file will be created.</front>
<front id="SdBaseFileCPP-138"> * \param[in] path A path with a valid DOS 8.3 file name.</front>
<front id="SdBaseFileCPP-139"> * \param[in] size The desired file size.</front>
<front id="SdBaseFileCPP-140"> *</front>
<front id="SdBaseFileCPP-141"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-142"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-143"> * Reasons for failure include \a path contains</front>
<front id="SdBaseFileCPP-144"> * an invalid DOS 8.3 file name, the FAT volume has not been initialized,</front>
<front id="SdBaseFileCPP-145"> * a file is already open, the file already exists, the root</front>
<front id="SdBaseFileCPP-146"> * directory is full or an I/O error.</front>
<front id="SdBaseFileCPP-147"> *</front>
<front id="SdBaseFileCPP-148"> */</front>
<front id="SdBaseFileCPP-149">bool SdBaseFile::createContiguous(SdBaseFile* dirFile,</front>
<front id="SdBaseFileCPP-150">        const char* path, uint32_t size) {</front>
<front id="SdBaseFileCPP-151">  uint32_t count;</front>
<front id="SdBaseFileCPP-152">  // don't allow zero length file</front>
<front id="SdBaseFileCPP-153">  if (size == 0) goto fail;</front>
<front id="SdBaseFileCPP-154">  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto fail;</front>
<front id="SdBaseFileCPP-155"></front>
<front id="SdBaseFileCPP-156">  // calculate number of clusters needed</front>
<front id="SdBaseFileCPP-157">  count = ((size - 1) &gt;&gt; (vol_-&gt;clusterSizeShift_ + 9)) + 1;</front>
<front id="SdBaseFileCPP-158"></front>
<front id="SdBaseFileCPP-159">  // allocate clusters</front>
<front id="SdBaseFileCPP-160">  if (!vol_-&gt;allocContiguous(count, &firstCluster_)) {</front>
<front id="SdBaseFileCPP-161">    remove();</front>
<front id="SdBaseFileCPP-162">    goto fail;</front>
<front id="SdBaseFileCPP-163">  }</front>
<front id="SdBaseFileCPP-164">  fileSize_ = size;</front>
<front id="SdBaseFileCPP-165"></front>
<front id="SdBaseFileCPP-166">  // insure sync() will update dir entry</front>
<front id="SdBaseFileCPP-167">  flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-168"></front>
<front id="SdBaseFileCPP-169">  return sync();</front>
<front id="SdBaseFileCPP-170"></front>
<front id="SdBaseFileCPP-171"> fail:</front>
<front id="SdBaseFileCPP-172">  return false;</front>
<front id="SdBaseFileCPP-173">}</front>
<front id="SdBaseFileCPP-174">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-175">/** Return a file's directory entry.</front>
<front id="SdBaseFileCPP-176"> *</front>
<front id="SdBaseFileCPP-177"> * \param[out] dir Location for return of the file's directory entry.</front>
<front id="SdBaseFileCPP-178"> *</front>
<front id="SdBaseFileCPP-179"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-180"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-181"> */</front>
<front id="SdBaseFileCPP-182">bool SdBaseFile::dirEntry(dir_t* dir) {</front>
<front id="SdBaseFileCPP-183">  dir_t* p;</front>
<front id="SdBaseFileCPP-184">  // make sure fields on SD are correct</front>
<front id="SdBaseFileCPP-185">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-186"></front>
<front id="SdBaseFileCPP-187">  // read entry</front>
<front id="SdBaseFileCPP-188">  p = cacheDirEntry(SdVolume::CACHE_FOR_READ);</front>
<front id="SdBaseFileCPP-189">  if (!p) goto fail;</front>
<front id="SdBaseFileCPP-190"></front>
<front id="SdBaseFileCPP-191">  // copy to caller's struct</front>
<front id="SdBaseFileCPP-192">  memcpy(dir, p, sizeof(dir_t));</front>
<front id="SdBaseFileCPP-193">  return true;</front>
<front id="SdBaseFileCPP-194"></front>
<front id="SdBaseFileCPP-195"> fail:</front>
<front id="SdBaseFileCPP-196">  return false;</front>
<front id="SdBaseFileCPP-197">}</front>
<front id="SdBaseFileCPP-198">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-199">/** Format the name field of \a dir into the 13 byte array</front>
<front id="SdBaseFileCPP-200"> * \a name in standard 8.3 short name format.</front>
<front id="SdBaseFileCPP-201"> *</front>
<front id="SdBaseFileCPP-202"> * \param[in] dir The directory structure containing the name.</front>
<front id="SdBaseFileCPP-203"> * \param[out] name A 13 byte char array for the formatted name.</front>
<front id="SdBaseFileCPP-204"> */</front>
<front id="SdBaseFileCPP-205">void SdBaseFile::dirName(const dir_t& dir, char* name) {</front>
<front id="SdBaseFileCPP-206">  uint8_t j = 0;</front>
<front id="SdBaseFileCPP-207">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="SdBaseFileCPP-208">    if (dir.name[i] == ' ')continue;</front>
<front id="SdBaseFileCPP-209">    if (i == 8) name[j++] = '.';</front>
<front id="SdBaseFileCPP-210">    name[j++] = dir.name[i];</front>
<front id="SdBaseFileCPP-211">  }</front>
<front id="SdBaseFileCPP-212">  name[j] = 0;</front>
<front id="SdBaseFileCPP-213">}</front>
<front id="SdBaseFileCPP-214">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-215">/** Test for the existence of a file in a directory</front>
<front id="SdBaseFileCPP-216"> *</front>
<front id="SdBaseFileCPP-217"> * \param[in] name Name of the file to be tested for.</front>
<front id="SdBaseFileCPP-218"> *</front>
<front id="SdBaseFileCPP-219"> * The calling instance must be an open directory file.</front>
<front id="SdBaseFileCPP-220"> *</front>
<front id="SdBaseFileCPP-221"> * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory</front>
<front id="SdBaseFileCPP-222"> * dirFile.</front>
<front id="SdBaseFileCPP-223"> *</front>
<front id="SdBaseFileCPP-224"> * \return true if the file exists else false.</front>
<front id="SdBaseFileCPP-225"> */</front>
<front id="SdBaseFileCPP-226">bool SdBaseFile::exists(const char* name) {</front>
<front id="SdBaseFileCPP-227">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-228">  return file.open(this, name, O_READ);</front>
<front id="SdBaseFileCPP-229">}</front>
<front id="SdBaseFileCPP-230">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-231">/**</front>
<front id="SdBaseFileCPP-232"> * Get a string from a file.</front>
<front id="SdBaseFileCPP-233"> *</front>
<front id="SdBaseFileCPP-234"> * fgets() reads bytes from a file into the array pointed to by \a str, until</front>
<front id="SdBaseFileCPP-235"> * \a num - 1 bytes are read, or a delimiter is read and transferred to \a str,</front>
<front id="SdBaseFileCPP-236"> * or end-of-file is encountered. The string is then terminated</front>
<front id="SdBaseFileCPP-237"> * with a null byte.</front>
<front id="SdBaseFileCPP-238"> *</front>
<front id="SdBaseFileCPP-239"> * fgets() deletes CR, '\\r', from the string.  This insures only a '\\n'</front>
<front id="SdBaseFileCPP-240"> * terminates the string for Windows text files which use CRLF for newline.</front>
<front id="SdBaseFileCPP-241"> *</front>
<front id="SdBaseFileCPP-242"> * \param[out] str Pointer to the array where the string is stored.</front>
<front id="SdBaseFileCPP-243"> * \param[in] num Maximum number of characters to be read</front>
<front id="SdBaseFileCPP-244"> * (including the final null byte). Usually the length</front>
<front id="SdBaseFileCPP-245"> * of the array \a str is used.</front>
<front id="SdBaseFileCPP-246"> * \param[in] delim Optional set of delimiters. The default is "\n".</front>
<front id="SdBaseFileCPP-247"> *</front>
<front id="SdBaseFileCPP-248"> * \return For success fgets() returns the length of the string in \a str.</front>
<front id="SdBaseFileCPP-249"> * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.</front>
<front id="SdBaseFileCPP-250"> **/</front>
<front id="SdBaseFileCPP-251">int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {</front>
<front id="SdBaseFileCPP-252">  char ch;</front>
<front id="SdBaseFileCPP-253">  int16_t n = 0;</front>
<front id="SdBaseFileCPP-254">  int16_t r = -1;</front>
<front id="SdBaseFileCPP-255">  while ((n + 1) &lt; num && (r = read(&ch, 1)) == 1) {</front>
<front id="SdBaseFileCPP-256">    // delete CR</front>
<front id="SdBaseFileCPP-257">    if (ch == '\r') continue;</front>
<front id="SdBaseFileCPP-258">    str[n++] = ch;</front>
<front id="SdBaseFileCPP-259">    if (!delim) {</front>
<front id="SdBaseFileCPP-260">      if (ch == '\n') break;</front>
<front id="SdBaseFileCPP-261">    } else {</front>
<front id="SdBaseFileCPP-262">      if (strchr(delim, ch)) break;</front>
<front id="SdBaseFileCPP-263">    }</front>
<front id="SdBaseFileCPP-264">  }</front>
<front id="SdBaseFileCPP-265">  if (r &lt; 0) {</front>
<front id="SdBaseFileCPP-266">    // read error</front>
<front id="SdBaseFileCPP-267">    return -1;</front>
<front id="SdBaseFileCPP-268">  }</front>
<front id="SdBaseFileCPP-269">  str[n] = '\0';</front>
<front id="SdBaseFileCPP-270">  return n;</front>
<front id="SdBaseFileCPP-271">}</front>
<front id="SdBaseFileCPP-272">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-273">/** Get a file's name</front>
<front id="SdBaseFileCPP-274"> *</front>
<front id="SdBaseFileCPP-275"> * \param[out] name An array of 13 characters for the file's name.</front>
<front id="SdBaseFileCPP-276"> *</front>
<front id="SdBaseFileCPP-277"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-278"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-279"> */</front>
<front id="SdBaseFileCPP-280">bool SdBaseFile::getFilename(char* name) {</front>
<front id="SdBaseFileCPP-281">  if (!isOpen()) return false;</front>
<front id="SdBaseFileCPP-282"></front>
<front id="SdBaseFileCPP-283">  if (isRoot()) {</front>
<front id="SdBaseFileCPP-284">    name[0] = '/';</front>
<front id="SdBaseFileCPP-285">    name[1] = '\0';</front>
<front id="SdBaseFileCPP-286">    return true;</front>
<front id="SdBaseFileCPP-287">  }</front>
<front id="SdBaseFileCPP-288">  // cache entry</front>
<front id="SdBaseFileCPP-289">  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);</front>
<front id="SdBaseFileCPP-290">  if (!p) return false;</front>
<front id="SdBaseFileCPP-291"></front>
<front id="SdBaseFileCPP-292">  // format name</front>
<front id="SdBaseFileCPP-293">  dirName(*p, name);</front>
<front id="SdBaseFileCPP-294">  return true;</front>
<front id="SdBaseFileCPP-295">}</front>
<front id="SdBaseFileCPP-296">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-297">void SdBaseFile::getpos(fpos_t* pos) {</front>
<front id="SdBaseFileCPP-298">  pos-&gt;position = curPosition_;</front>
<front id="SdBaseFileCPP-299">  pos-&gt;cluster = curCluster_;</front>
<front id="SdBaseFileCPP-300">}</front>
<front id="SdBaseFileCPP-301"></front>
<front id="SdBaseFileCPP-302">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-303">/** List directory contents.</front>
<front id="SdBaseFileCPP-304"> *</front>
<front id="SdBaseFileCPP-305"> * \param[in] pr Print stream for list.</front>
<front id="SdBaseFileCPP-306"> *</front>
<front id="SdBaseFileCPP-307"> * \param[in] flags The inclusive OR of</front>
<front id="SdBaseFileCPP-308"> *</front>
<front id="SdBaseFileCPP-309"> * LS_DATE - %Print file modification date</front>
<front id="SdBaseFileCPP-310"> *</front>
<front id="SdBaseFileCPP-311"> * LS_SIZE - %Print file size.</front>
<front id="SdBaseFileCPP-312"> *</front>
<front id="SdBaseFileCPP-313"> * LS_R - Recursive list of subdirectories.</front>
<front id="SdBaseFileCPP-314"> *</front>
<front id="SdBaseFileCPP-315"> * \param[in] indent Amount of space before file name. Used for recursive</front>
<front id="SdBaseFileCPP-316"> * list to indicate subdirectory level.</front>
<front id="SdBaseFileCPP-317"> */</front>
<front id="SdBaseFileCPP-318">void SdBaseFile::ls(uint8_t flags, uint8_t indent) {</front>
<front id="SdBaseFileCPP-319">  rewind();</front>
<front id="SdBaseFileCPP-320">  int8_t status;</front>
<front id="SdBaseFileCPP-321">  while ((status = lsPrintNext( flags, indent))) {</front>
<front id="SdBaseFileCPP-322">    if (status &gt; 1 && (flags & LS_R)) {</front>
<front id="SdBaseFileCPP-323">      uint16_t index = curPosition()/32 - 1;</front>
<front id="SdBaseFileCPP-324">      SdBaseFile s;</front>
<front id="SdBaseFileCPP-325">      if (s.open(this, index, O_READ)) s.ls( flags, indent + 2);</front>
<front id="SdBaseFileCPP-326">      seekSet(32 * (index + 1));</front>
<front id="SdBaseFileCPP-327">    }</front>
<front id="SdBaseFileCPP-328">  }</front>
<front id="SdBaseFileCPP-329">}</front>
<front id="SdBaseFileCPP-330">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-331">// saves 32 bytes on stack for ls recursion</front>
<front id="SdBaseFileCPP-332">// return 0 - EOF, 1 - normal file, or 2 - directory</front>
<front id="SdBaseFileCPP-333">int8_t SdBaseFile::lsPrintNext( uint8_t flags, uint8_t indent) {</front>
<front id="SdBaseFileCPP-334">  dir_t dir;</front>
<front id="SdBaseFileCPP-335">  uint8_t w = 0;</front>
<front id="SdBaseFileCPP-336"></front>
<front id="SdBaseFileCPP-337">  while (1) {</front>
<front id="SdBaseFileCPP-338">    if (read(&dir, sizeof(dir)) != sizeof(dir)) return 0;</front>
<front id="SdBaseFileCPP-339">    if (dir.name[0] == DIR_NAME_FREE) return 0;</front>
<front id="SdBaseFileCPP-340"></front>
<front id="SdBaseFileCPP-341">    // skip deleted entry and entries for . and  ..</front>
<front id="SdBaseFileCPP-342">    if (dir.name[0] != DIR_NAME_DELETED && dir.name[0] != '.'</front>
<front id="SdBaseFileCPP-343">      && DIR_IS_FILE_OR_SUBDIR(&dir)) break;</front>
<front id="SdBaseFileCPP-344">  }</front>
<front id="SdBaseFileCPP-345">  // indent for dir level</front>
<front id="SdBaseFileCPP-346">  for (uint8_t i = 0; i &lt; indent; i++) MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-347"></front>
<front id="SdBaseFileCPP-348">  // print name</front>
<front id="SdBaseFileCPP-349">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="SdBaseFileCPP-350">    if (dir.name[i] == ' ')continue;</front>
<front id="SdBaseFileCPP-351">    if (i == 8) {</front>
<front id="SdBaseFileCPP-352">      MYSERIAL.write('.');</front>
<front id="SdBaseFileCPP-353">      w++;</front>
<front id="SdBaseFileCPP-354">    }</front>
<front id="SdBaseFileCPP-355">    MYSERIAL.write(dir.name[i]);</front>
<front id="SdBaseFileCPP-356">    w++;</front>
<front id="SdBaseFileCPP-357">  }</front>
<front id="SdBaseFileCPP-358">  if (DIR_IS_SUBDIR(&dir)) {</front>
<front id="SdBaseFileCPP-359">    MYSERIAL.write('/');</front>
<front id="SdBaseFileCPP-360">    w++;</front>
<front id="SdBaseFileCPP-361">  }</front>
<front id="SdBaseFileCPP-362">  if (flags & (LS_DATE | LS_SIZE)) {</front>
<front id="SdBaseFileCPP-363">    while (w++ &lt; 14) MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-364">  }</front>
<front id="SdBaseFileCPP-365">  // print modify date/time if requested</front>
<front id="SdBaseFileCPP-366">  if (flags & LS_DATE) {</front>
<front id="SdBaseFileCPP-367">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-368">    printFatDate( dir.lastWriteDate);</front>
<front id="SdBaseFileCPP-369">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-370">    printFatTime( dir.lastWriteTime);</front>
<front id="SdBaseFileCPP-371">  }</front>
<front id="SdBaseFileCPP-372">  // print size if requested</front>
<front id="SdBaseFileCPP-373">  if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {</front>
<front id="SdBaseFileCPP-374">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-375">    MYSERIAL.print(dir.fileSize);</front>
<front id="SdBaseFileCPP-376">  }</front>
<front id="SdBaseFileCPP-377">  MYSERIAL.println();</front>
<front id="SdBaseFileCPP-378">  return DIR_IS_FILE(&dir) ? 1 : 2;</front>
<front id="SdBaseFileCPP-379">}</front>
<front id="SdBaseFileCPP-380">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-381">// format directory name field from a 8.3 name string</front>
<front id="SdBaseFileCPP-382">bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {</front>
<front id="SdBaseFileCPP-383">  uint8_t c;</front>
<front id="SdBaseFileCPP-384">  uint8_t n = 7;  // max index for part before dot</front>
<front id="SdBaseFileCPP-385">  uint8_t i = 0;</front>
<front id="SdBaseFileCPP-386">  // blank fill name and extension</front>
<front id="SdBaseFileCPP-387">  while (i &lt; 11) name[i++] = ' ';</front>
<front id="SdBaseFileCPP-388">  i = 0;</front>
<front id="SdBaseFileCPP-389">  while (*str != '\0' && *str != '/') {</front>
<front id="SdBaseFileCPP-390">    c = *str++;</front>
<front id="SdBaseFileCPP-391">    if (c == '.') {</front>
<front id="SdBaseFileCPP-392">      if (n == 10) goto fail;  // only one dot allowed</front>
<front id="SdBaseFileCPP-393">      n = 10;  // max index for full 8.3 name</front>
<front id="SdBaseFileCPP-394">      i = 8;   // place for extension</front>
<front id="SdBaseFileCPP-395">    } else {</front>
<front id="SdBaseFileCPP-396">      // illegal FAT characters</front>
<front id="SdBaseFileCPP-397">      PGM_P p = PSTR("|&lt;&gt;^+=?/[];,*\"\\");</front>
<front id="SdBaseFileCPP-398">      uint8_t b;</front>
<front id="SdBaseFileCPP-399">      while ((b = pgm_read_byte(p++))) if (b == c) goto fail;</front>
<front id="SdBaseFileCPP-400">      // check size and only allow ASCII printable characters</front>
<front id="SdBaseFileCPP-401">      if (i &gt; n || c &lt; 0X21 || c &gt; 0X7E)goto fail;</front>
<front id="SdBaseFileCPP-402">      // only upper case allowed in 8.3 names - convert lower to upper</front>
<front id="SdBaseFileCPP-403">      name[i++] = (c &lt; 'a' || c &gt; 'z') ?  (c) : (c + ('A' - 'a'));</front>
<front id="SdBaseFileCPP-404">    }</front>
<front id="SdBaseFileCPP-405">  }</front>
<front id="SdBaseFileCPP-406">  *ptr = str;</front>
<front id="SdBaseFileCPP-407">  // must have a file name, extension is optional</front>
<front id="SdBaseFileCPP-408">  return name[0] != ' ';</front>
<front id="SdBaseFileCPP-409"></front>
<front id="SdBaseFileCPP-410"> fail:</front>
<front id="SdBaseFileCPP-411">  return false;</front>
<front id="SdBaseFileCPP-412">}</front>
<front id="SdBaseFileCPP-413">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-414">/** Make a new directory.</front>
<front id="SdBaseFileCPP-415"> *</front>
<front id="SdBaseFileCPP-416"> * \param[in] parent An open SdFat instance for the directory that will contain</front>
<front id="SdBaseFileCPP-417"> * the new directory.</front>
<front id="SdBaseFileCPP-418"> *</front>
<front id="SdBaseFileCPP-419"> * \param[in] path A path with a valid 8.3 DOS name for the new directory.</front>
<front id="SdBaseFileCPP-420"> *</front>
<front id="SdBaseFileCPP-421"> * \param[in] pFlag Create missing parent directories if true.</front>
<front id="SdBaseFileCPP-422"> *</front>
<front id="SdBaseFileCPP-423"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-424"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-425"> * Reasons for failure include this file is already open, \a parent is not a</front>
<front id="SdBaseFileCPP-426"> * directory, \a path is invalid or already exists in \a parent.</front>
<front id="SdBaseFileCPP-427"> */</front>
<front id="SdBaseFileCPP-428">bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {</front>
<front id="SdBaseFileCPP-429">  uint8_t dname[11];</front>
<front id="SdBaseFileCPP-430">  SdBaseFile dir1, dir2;</front>
<front id="SdBaseFileCPP-431">  SdBaseFile* sub = &dir1;</front>
<front id="SdBaseFileCPP-432">  SdBaseFile* start = parent;</front>
<front id="SdBaseFileCPP-433"></front>
<front id="SdBaseFileCPP-434">  if (!parent || isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-435"></front>
<front id="SdBaseFileCPP-436">  if (*path == '/') {</front>
<front id="SdBaseFileCPP-437">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-438">    if (!parent-&gt;isRoot()) {</front>
<front id="SdBaseFileCPP-439">      if (!dir2.openRoot(parent-&gt;vol_)) goto fail;</front>
<front id="SdBaseFileCPP-440">      parent = &dir2;</front>
<front id="SdBaseFileCPP-441">    }</front>
<front id="SdBaseFileCPP-442">  }</front>
<front id="SdBaseFileCPP-443">  while (1) {</front>
<front id="SdBaseFileCPP-444">    if (!make83Name(path, dname, &path)) goto fail;</front>
<front id="SdBaseFileCPP-445">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-446">    if (!*path) break;</front>
<front id="SdBaseFileCPP-447">    if (!sub-&gt;open(parent, dname, O_READ)) {</front>
<front id="SdBaseFileCPP-448">      if (!pFlag || !sub-&gt;mkdir(parent, dname)) {</front>
<front id="SdBaseFileCPP-449">        goto fail;</front>
<front id="SdBaseFileCPP-450">      }</front>
<front id="SdBaseFileCPP-451">    }</front>
<front id="SdBaseFileCPP-452">    if (parent != start) parent-&gt;close();</front>
<front id="SdBaseFileCPP-453">    parent = sub;</front>
<front id="SdBaseFileCPP-454">    sub = parent != &dir1 ? &dir1 : &dir2;</front>
<front id="SdBaseFileCPP-455">  }</front>
<front id="SdBaseFileCPP-456">  return mkdir(parent, dname);</front>
<front id="SdBaseFileCPP-457"></front>
<front id="SdBaseFileCPP-458">  fail:</front>
<front id="SdBaseFileCPP-459">  return false;</front>
<front id="SdBaseFileCPP-460">}</front>
<front id="SdBaseFileCPP-461">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-462">bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {</front>
<front id="SdBaseFileCPP-463">  uint32_t block;</front>
<front id="SdBaseFileCPP-464">  dir_t d;</front>
<front id="SdBaseFileCPP-465">  dir_t* p;</front>
<front id="SdBaseFileCPP-466"></front>
<front id="SdBaseFileCPP-467">  if (!parent-&gt;isDir()) goto fail;</front>
<front id="SdBaseFileCPP-468"></front>
<front id="SdBaseFileCPP-469">  // create a normal file</front>
<front id="SdBaseFileCPP-470">  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto fail;</front>
<front id="SdBaseFileCPP-471"></front>
<front id="SdBaseFileCPP-472">  // convert file to directory</front>
<front id="SdBaseFileCPP-473">  flags_ = O_READ;</front>
<front id="SdBaseFileCPP-474">  type_ = FAT_FILE_TYPE_SUBDIR;</front>
<front id="SdBaseFileCPP-475"></front>
<front id="SdBaseFileCPP-476">  // allocate and zero first cluster</front>
<front id="SdBaseFileCPP-477">  if (!addDirCluster())goto fail;</front>
<front id="SdBaseFileCPP-478"></front>
<front id="SdBaseFileCPP-479">  // force entry to SD</front>
<front id="SdBaseFileCPP-480">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-481"></front>
<front id="SdBaseFileCPP-482">  // cache entry - should already be in cache due to sync() call</front>
<front id="SdBaseFileCPP-483">  p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-484">  if (!p) goto fail;</front>
<front id="SdBaseFileCPP-485"></front>
<front id="SdBaseFileCPP-486">  // change directory entry  attribute</front>
<front id="SdBaseFileCPP-487">  p-&gt;attributes = DIR_ATT_DIRECTORY;</front>
<front id="SdBaseFileCPP-488"></front>
<front id="SdBaseFileCPP-489">  // make entry for '.'</front>
<front id="SdBaseFileCPP-490">  memcpy(&d, p, sizeof(d));</front>
<front id="SdBaseFileCPP-491">  d.name[0] = '.';</front>
<front id="SdBaseFileCPP-492">  for (uint8_t i = 1; i &lt; 11; i++) d.name[i] = ' ';</front>
<front id="SdBaseFileCPP-493"></front>
<front id="SdBaseFileCPP-494">  // cache block for '.'  and '..'</front>
<front id="SdBaseFileCPP-495">  block = vol_-&gt;clusterStartBlock(firstCluster_);</front>
<front id="SdBaseFileCPP-496">  if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-497"></front>
<front id="SdBaseFileCPP-498">  // copy '.' to block</front>
<front id="SdBaseFileCPP-499">  memcpy(&vol_-&gt;cache()-&gt;dir[0], &d, sizeof(d));</front>
<front id="SdBaseFileCPP-500"></front>
<front id="SdBaseFileCPP-501">  // make entry for '..'</front>
<front id="SdBaseFileCPP-502">  d.name[1] = '.';</front>
<front id="SdBaseFileCPP-503">  if (parent-&gt;isRoot()) {</front>
<front id="SdBaseFileCPP-504">    d.firstClusterLow = 0;</front>
<front id="SdBaseFileCPP-505">    d.firstClusterHigh = 0;</front>
<front id="SdBaseFileCPP-506">  } else {</front>
<front id="SdBaseFileCPP-507">    d.firstClusterLow = parent-&gt;firstCluster_ & 0XFFFF;</front>
<front id="SdBaseFileCPP-508">    d.firstClusterHigh = parent-&gt;firstCluster_ &gt;&gt; 16;</front>
<front id="SdBaseFileCPP-509">  }</front>
<front id="SdBaseFileCPP-510">  // copy '..' to block</front>
<front id="SdBaseFileCPP-511">  memcpy(&vol_-&gt;cache()-&gt;dir[1], &d, sizeof(d));</front>
<front id="SdBaseFileCPP-512"></front>
<front id="SdBaseFileCPP-513">  // write first block</front>
<front id="SdBaseFileCPP-514">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-515"></front>
<front id="SdBaseFileCPP-516"> fail:</front>
<front id="SdBaseFileCPP-517">  return false;</front>
<front id="SdBaseFileCPP-518">}</front>
<front id="SdBaseFileCPP-519">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-520"> /** Open a file in the current working directory.</front>
<front id="SdBaseFileCPP-521">  *</front>
<front id="SdBaseFileCPP-522">  * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileCPP-523">  *</front>
<front id="SdBaseFileCPP-524">  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-525">  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).</front>
<front id="SdBaseFileCPP-526">  *</front>
<front id="SdBaseFileCPP-527">  * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-528">  * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-529">  */</front>
<front id="SdBaseFileCPP-530">  bool SdBaseFile::open(const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-531">    return open(cwd_, path, oflag);</front>
<front id="SdBaseFileCPP-532">  }</front>
<front id="SdBaseFileCPP-533">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-534">/** Open a file or directory by name.</front>
<front id="SdBaseFileCPP-535"> *</front>
<front id="SdBaseFileCPP-536"> * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileCPP-537"> * file to be opened.</front>
<front id="SdBaseFileCPP-538"> *</front>
<front id="SdBaseFileCPP-539"> * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileCPP-540"> *</front>
<front id="SdBaseFileCPP-541"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-542"> * OR of flags from the following list</front>
<front id="SdBaseFileCPP-543"> *</front>
<front id="SdBaseFileCPP-544"> * O_READ - Open for reading.</front>
<front id="SdBaseFileCPP-545"> *</front>
<front id="SdBaseFileCPP-546"> * O_RDONLY - Same as O_READ.</front>
<front id="SdBaseFileCPP-547"> *</front>
<front id="SdBaseFileCPP-548"> * O_WRITE - Open for writing.</front>
<front id="SdBaseFileCPP-549"> *</front>
<front id="SdBaseFileCPP-550"> * O_WRONLY - Same as O_WRITE.</front>
<front id="SdBaseFileCPP-551"> *</front>
<front id="SdBaseFileCPP-552"> * O_RDWR - Open for reading and writing.</front>
<front id="SdBaseFileCPP-553"> *</front>
<front id="SdBaseFileCPP-554"> * O_APPEND - If set, the file offset shall be set to the end of the</front>
<front id="SdBaseFileCPP-555"> * file prior to each write.</front>
<front id="SdBaseFileCPP-556"> *</front>
<front id="SdBaseFileCPP-557"> * O_AT_END - Set the initial position at the end of the file.</front>
<front id="SdBaseFileCPP-558"> *</front>
<front id="SdBaseFileCPP-559"> * O_CREAT - If the file exists, this flag has no effect except as noted</front>
<front id="SdBaseFileCPP-560"> * under O_EXCL below. Otherwise, the file shall be created</front>
<front id="SdBaseFileCPP-561"> *</front>
<front id="SdBaseFileCPP-562"> * O_EXCL - If O_CREAT and O_EXCL are set, open() shall fail if the file exists.</front>
<front id="SdBaseFileCPP-563"> *</front>
<front id="SdBaseFileCPP-564"> * O_SYNC - Call sync() after each write.  This flag should not be used with</front>
<front id="SdBaseFileCPP-565"> * write(uint8_t), write_P(PGM_P), writeln_P(PGM_P), or the Arduino Print class.</front>
<front id="SdBaseFileCPP-566"> * These functions do character at a time writes so sync() will be called</front>
<front id="SdBaseFileCPP-567"> * after each byte.</front>
<front id="SdBaseFileCPP-568"> *</front>
<front id="SdBaseFileCPP-569"> * O_TRUNC - If the file exists and is a regular file, and the file is</front>
<front id="SdBaseFileCPP-570"> * successfully opened and is not read only, its length shall be truncated to 0.</front>
<front id="SdBaseFileCPP-571"> *</front>
<front id="SdBaseFileCPP-572"> * WARNING: A given file must not be opened by more than one SdBaseFile object</front>
<front id="SdBaseFileCPP-573"> * of file corruption may occur.</front>
<front id="SdBaseFileCPP-574"> *</front>
<front id="SdBaseFileCPP-575"> * \note Directory files must be opened read only.  Write and truncation is</front>
<front id="SdBaseFileCPP-576"> * not allowed for directory files.</front>
<front id="SdBaseFileCPP-577"> *</front>
<front id="SdBaseFileCPP-578"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-579"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-580"> * Reasons for failure include this file is already open, \a dirFile is not</front>
<front id="SdBaseFileCPP-581"> * a directory, \a path is invalid, the file does not exist</front>
<front id="SdBaseFileCPP-582"> * or can't be opened in the access mode specified by oflag.</front>
<front id="SdBaseFileCPP-583"> */</front>
<front id="SdBaseFileCPP-584">bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-585">  uint8_t dname[11];</front>
<front id="SdBaseFileCPP-586">  SdBaseFile dir1, dir2;</front>
<front id="SdBaseFileCPP-587">  SdBaseFile *parent = dirFile;</front>
<front id="SdBaseFileCPP-588">  SdBaseFile *sub = &dir1;</front>
<front id="SdBaseFileCPP-589"></front>
<front id="SdBaseFileCPP-590">  if (!dirFile) goto fail;</front>
<front id="SdBaseFileCPP-591"></front>
<front id="SdBaseFileCPP-592">  // error if already open</front>
<front id="SdBaseFileCPP-593">  if (isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-594"></front>
<front id="SdBaseFileCPP-595">  if (*path == '/') {</front>
<front id="SdBaseFileCPP-596">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-597">    if (!dirFile-&gt;isRoot()) {</front>
<front id="SdBaseFileCPP-598">      if (!dir2.openRoot(dirFile-&gt;vol_)) goto fail;</front>
<front id="SdBaseFileCPP-599">      parent = &dir2;</front>
<front id="SdBaseFileCPP-600">    }</front>
<front id="SdBaseFileCPP-601">  }</front>
<front id="SdBaseFileCPP-602">  while (1) {</front>
<front id="SdBaseFileCPP-603">    if (!make83Name(path, dname, &path)) goto fail;</front>
<front id="SdBaseFileCPP-604">    while (*path == '/') path++;</front>
<front id="SdBaseFileCPP-605">    if (!*path) break;</front>
<front id="SdBaseFileCPP-606">    if (!sub-&gt;open(parent, dname, O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-607">    if (parent != dirFile) parent-&gt;close();</front>
<front id="SdBaseFileCPP-608">    parent = sub;</front>
<front id="SdBaseFileCPP-609">    sub = parent != &dir1 ? &dir1 : &dir2;</front>
<front id="SdBaseFileCPP-610">  }</front>
<front id="SdBaseFileCPP-611">  return open(parent, dname, oflag);</front>
<front id="SdBaseFileCPP-612"></front>
<front id="SdBaseFileCPP-613"> fail:</front>
<front id="SdBaseFileCPP-614">  return false;</front>
<front id="SdBaseFileCPP-615">}</front>
<front id="SdBaseFileCPP-616">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-617">// open with filename in dname</front>
<front id="SdBaseFileCPP-618">bool SdBaseFile::open(SdBaseFile* dirFile,</front>
<front id="SdBaseFileCPP-619">  const uint8_t dname[11], uint8_t oflag) {</front>
<front id="SdBaseFileCPP-620">  bool emptyFound = false;</front>
<front id="SdBaseFileCPP-621">  bool fileFound = false;</front>
<front id="SdBaseFileCPP-622">  uint8_t index;</front>
<front id="SdBaseFileCPP-623">  dir_t* p;</front>
<front id="SdBaseFileCPP-624"></front>
<front id="SdBaseFileCPP-625">  vol_ = dirFile-&gt;vol_;</front>
<front id="SdBaseFileCPP-626"></front>
<front id="SdBaseFileCPP-627">  dirFile-&gt;rewind();</front>
<front id="SdBaseFileCPP-628">  // search for file</front>
<front id="SdBaseFileCPP-629"></front>
<front id="SdBaseFileCPP-630">  while (dirFile-&gt;curPosition_ &lt; dirFile-&gt;fileSize_) {</front>
<front id="SdBaseFileCPP-631">    index = 0XF & (dirFile-&gt;curPosition_ &gt;&gt; 5);</front>
<front id="SdBaseFileCPP-632">    p = dirFile-&gt;readDirCache();</front>
<front id="SdBaseFileCPP-633">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-634"></front>
<front id="SdBaseFileCPP-635">    if (p-&gt;name[0] == DIR_NAME_FREE || p-&gt;name[0] == DIR_NAME_DELETED) {</front>
<front id="SdBaseFileCPP-636">      // remember first empty slot</front>
<front id="SdBaseFileCPP-637">      if (!emptyFound) {</front>
<front id="SdBaseFileCPP-638">        dirBlock_ = dirFile-&gt;vol_-&gt;cacheBlockNumber();</front>
<front id="SdBaseFileCPP-639">        dirIndex_ = index;</front>
<front id="SdBaseFileCPP-640">        emptyFound = true;</front>
<front id="SdBaseFileCPP-641">      }</front>
<front id="SdBaseFileCPP-642">      // done if no entries follow</front>
<front id="SdBaseFileCPP-643">      if (p-&gt;name[0] == DIR_NAME_FREE) break;</front>
<front id="SdBaseFileCPP-644">    } else if (!memcmp(dname, p-&gt;name, 11)) {</front>
<front id="SdBaseFileCPP-645">      fileFound = true;</front>
<front id="SdBaseFileCPP-646">      break;</front>
<front id="SdBaseFileCPP-647">    }</front>
<front id="SdBaseFileCPP-648">  }</front>
<front id="SdBaseFileCPP-649">  if (fileFound) {</front>
<front id="SdBaseFileCPP-650">    // don't open existing file if O_EXCL</front>
<front id="SdBaseFileCPP-651">    if (oflag & O_EXCL) goto fail;</front>
<front id="SdBaseFileCPP-652">  } else {</front>
<front id="SdBaseFileCPP-653">    // don't create unless O_CREAT and O_WRITE</front>
<front id="SdBaseFileCPP-654">    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-655">    if (emptyFound) {</front>
<front id="SdBaseFileCPP-656">      index = dirIndex_;</front>
<front id="SdBaseFileCPP-657">      p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-658">      if (!p) goto fail;</front>
<front id="SdBaseFileCPP-659">    } else {</front>
<front id="SdBaseFileCPP-660">      if (dirFile-&gt;type_ == FAT_FILE_TYPE_ROOT_FIXED) goto fail;</front>
<front id="SdBaseFileCPP-661"></front>
<front id="SdBaseFileCPP-662">      // add and zero cluster for dirFile - first cluster is in cache for write</front>
<front id="SdBaseFileCPP-663">      if (!dirFile-&gt;addDirCluster()) goto fail;</front>
<front id="SdBaseFileCPP-664"></front>
<front id="SdBaseFileCPP-665">      // use first entry in cluster</front>
<front id="SdBaseFileCPP-666">      p = dirFile-&gt;vol_-&gt;cache()-&gt;dir;</front>
<front id="SdBaseFileCPP-667">      index = 0;</front>
<front id="SdBaseFileCPP-668">    }</front>
<front id="SdBaseFileCPP-669">    // initialize as empty file</front>
<front id="SdBaseFileCPP-670">    memset(p, 0, sizeof(dir_t));</front>
<front id="SdBaseFileCPP-671">    memcpy(p-&gt;name, dname, 11);</front>
<front id="SdBaseFileCPP-672"></front>
<front id="SdBaseFileCPP-673">    // set timestamps</front>
<front id="SdBaseFileCPP-674">    if (dateTime_) {</front>
<front id="SdBaseFileCPP-675">      // call user date/time function</front>
<front id="SdBaseFileCPP-676">      dateTime_(&p-&gt;creationDate, &p-&gt;creationTime);</front>
<front id="SdBaseFileCPP-677">    } else {</front>
<front id="SdBaseFileCPP-678">      // use default date/time</front>
<front id="SdBaseFileCPP-679">      p-&gt;creationDate = FAT_DEFAULT_DATE;</front>
<front id="SdBaseFileCPP-680">      p-&gt;creationTime = FAT_DEFAULT_TIME;</front>
<front id="SdBaseFileCPP-681">    }</front>
<front id="SdBaseFileCPP-682">    p-&gt;lastAccessDate = p-&gt;creationDate;</front>
<front id="SdBaseFileCPP-683">    p-&gt;lastWriteDate = p-&gt;creationDate;</front>
<front id="SdBaseFileCPP-684">    p-&gt;lastWriteTime = p-&gt;creationTime;</front>
<front id="SdBaseFileCPP-685"></front>
<front id="SdBaseFileCPP-686">    // write entry to SD</front>
<front id="SdBaseFileCPP-687">    if (!dirFile-&gt;vol_-&gt;cacheFlush()) goto fail;</front>
<front id="SdBaseFileCPP-688">  }</front>
<front id="SdBaseFileCPP-689">  // open entry in cache</front>
<front id="SdBaseFileCPP-690">  return openCachedEntry(index, oflag);</front>
<front id="SdBaseFileCPP-691"></front>
<front id="SdBaseFileCPP-692"> fail:</front>
<front id="SdBaseFileCPP-693">  return false;</front>
<front id="SdBaseFileCPP-694">}</front>
<front id="SdBaseFileCPP-695">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-696">/** Open a file by index.</front>
<front id="SdBaseFileCPP-697"> *</front>
<front id="SdBaseFileCPP-698"> * \param[in] dirFile An open SdFat instance for the directory.</front>
<front id="SdBaseFileCPP-699"> *</front>
<front id="SdBaseFileCPP-700"> * \param[in] index The \a index of the directory entry for the file to be</front>
<front id="SdBaseFileCPP-701"> * opened.  The value for \a index is (directory file position)/32.</front>
<front id="SdBaseFileCPP-702"> *</front>
<front id="SdBaseFileCPP-703"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-704"> * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileCPP-705"> *</front>
<front id="SdBaseFileCPP-706"> * See open() by path for definition of flags.</front>
<front id="SdBaseFileCPP-707"> * \return true for success or false for failure.</front>
<front id="SdBaseFileCPP-708"> */</front>
<front id="SdBaseFileCPP-709">bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-710">  dir_t* p;</front>
<front id="SdBaseFileCPP-711"></front>
<front id="SdBaseFileCPP-712">  vol_ = dirFile-&gt;vol_;</front>
<front id="SdBaseFileCPP-713"></front>
<front id="SdBaseFileCPP-714">  // error if already open</front>
<front id="SdBaseFileCPP-715">  if (isOpen() || !dirFile) goto fail;</front>
<front id="SdBaseFileCPP-716"></front>
<front id="SdBaseFileCPP-717">  // don't open existing file if O_EXCL - user call error</front>
<front id="SdBaseFileCPP-718">  if (oflag & O_EXCL) goto fail;</front>
<front id="SdBaseFileCPP-719"></front>
<front id="SdBaseFileCPP-720">  // seek to location of entry</front>
<front id="SdBaseFileCPP-721">  if (!dirFile-&gt;seekSet(32 * index)) goto fail;</front>
<front id="SdBaseFileCPP-722"></front>
<front id="SdBaseFileCPP-723">  // read entry into cache</front>
<front id="SdBaseFileCPP-724">  p = dirFile-&gt;readDirCache();</front>
<front id="SdBaseFileCPP-725">  if (!p) goto fail;</front>
<front id="SdBaseFileCPP-726"></front>
<front id="SdBaseFileCPP-727">  // error if empty slot or '.' or '..'</front>
<front id="SdBaseFileCPP-728">  if (p-&gt;name[0] == DIR_NAME_FREE ||</front>
<front id="SdBaseFileCPP-729">      p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') {</front>
<front id="SdBaseFileCPP-730">    goto fail;</front>
<front id="SdBaseFileCPP-731">  }</front>
<front id="SdBaseFileCPP-732">  // open cached entry</front>
<front id="SdBaseFileCPP-733">  return openCachedEntry(index & 0XF, oflag);</front>
<front id="SdBaseFileCPP-734"></front>
<front id="SdBaseFileCPP-735"> fail:</front>
<front id="SdBaseFileCPP-736">  return false;</front>
<front id="SdBaseFileCPP-737">}</front>
<front id="SdBaseFileCPP-738">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-739">// open a cached directory entry. Assumes vol_ is initialized</front>
<front id="SdBaseFileCPP-740">bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-741">  // location of entry in cache</front>
<front id="SdBaseFileCPP-742">  dir_t* p = &vol_-&gt;cache()-&gt;dir[dirIndex];</front>
<front id="SdBaseFileCPP-743"></front>
<front id="SdBaseFileCPP-744">  // write or truncate is an error for a directory or read-only file</front>
<front id="SdBaseFileCPP-745">  if (p-&gt;attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {</front>
<front id="SdBaseFileCPP-746">    if (oflag & (O_WRITE | O_TRUNC)) goto fail;</front>
<front id="SdBaseFileCPP-747">  }</front>
<front id="SdBaseFileCPP-748">  // remember location of directory entry on SD</front>
<front id="SdBaseFileCPP-749">  dirBlock_ = vol_-&gt;cacheBlockNumber();</front>
<front id="SdBaseFileCPP-750">  dirIndex_ = dirIndex;</front>
<front id="SdBaseFileCPP-751"></front>
<front id="SdBaseFileCPP-752">  // copy first cluster number for directory fields</front>
<front id="SdBaseFileCPP-753">  firstCluster_ = (uint32_t)p-&gt;firstClusterHigh &lt;&lt; 16;</front>
<front id="SdBaseFileCPP-754">  firstCluster_ |= p-&gt;firstClusterLow;</front>
<front id="SdBaseFileCPP-755"></front>
<front id="SdBaseFileCPP-756">  // make sure it is a normal file or subdirectory</front>
<front id="SdBaseFileCPP-757">  if (DIR_IS_FILE(p)) {</front>
<front id="SdBaseFileCPP-758">    fileSize_ = p-&gt;fileSize;</front>
<front id="SdBaseFileCPP-759">    type_ = FAT_FILE_TYPE_NORMAL;</front>
<front id="SdBaseFileCPP-760">  } else if (DIR_IS_SUBDIR(p)) {</front>
<front id="SdBaseFileCPP-761">    if (!vol_-&gt;chainSize(firstCluster_, &fileSize_)) goto fail;</front>
<front id="SdBaseFileCPP-762">    type_ = FAT_FILE_TYPE_SUBDIR;</front>
<front id="SdBaseFileCPP-763">  } else {</front>
<front id="SdBaseFileCPP-764">    goto fail;</front>
<front id="SdBaseFileCPP-765">  }</front>
<front id="SdBaseFileCPP-766">  // save open flags for read/write</front>
<front id="SdBaseFileCPP-767">  flags_ = oflag & F_OFLAG;</front>
<front id="SdBaseFileCPP-768"></front>
<front id="SdBaseFileCPP-769">  // set to start of file</front>
<front id="SdBaseFileCPP-770">  curCluster_ = 0;</front>
<front id="SdBaseFileCPP-771">  curPosition_ = 0;</front>
<front id="SdBaseFileCPP-772">  if ((oflag & O_TRUNC) && !truncate(0)) return false;</front>
<front id="SdBaseFileCPP-773">  return oflag & O_AT_END ? seekEnd(0) : true;</front>
<front id="SdBaseFileCPP-774"></front>
<front id="SdBaseFileCPP-775"> fail:</front>
<front id="SdBaseFileCPP-776">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-777">  return false;</front>
<front id="SdBaseFileCPP-778">}</front>
<front id="SdBaseFileCPP-779">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-780">/** Open the next file or subdirectory in a directory.</front>
<front id="SdBaseFileCPP-781"> *</front>
<front id="SdBaseFileCPP-782"> * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileCPP-783"> * file to be opened.</front>
<front id="SdBaseFileCPP-784"> *</front>
<front id="SdBaseFileCPP-785"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-786"> * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileCPP-787"> *</front>
<front id="SdBaseFileCPP-788"> * See open() by path for definition of flags.</front>
<front id="SdBaseFileCPP-789"> * \return true for success or false for failure.</front>
<front id="SdBaseFileCPP-790"> */</front>
<front id="SdBaseFileCPP-791">bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-792">  dir_t* p;</front>
<front id="SdBaseFileCPP-793">  uint8_t index;</front>
<front id="SdBaseFileCPP-794"></front>
<front id="SdBaseFileCPP-795">  if (!dirFile) goto fail;</front>
<front id="SdBaseFileCPP-796"></front>
<front id="SdBaseFileCPP-797">  // error if already open</front>
<front id="SdBaseFileCPP-798">  if (isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-799"></front>
<front id="SdBaseFileCPP-800">  vol_ = dirFile-&gt;vol_;</front>
<front id="SdBaseFileCPP-801"></front>
<front id="SdBaseFileCPP-802">  while (1) {</front>
<front id="SdBaseFileCPP-803">    index = 0XF & (dirFile-&gt;curPosition_ &gt;&gt; 5);</front>
<front id="SdBaseFileCPP-804"></front>
<front id="SdBaseFileCPP-805">    // read entry into cache</front>
<front id="SdBaseFileCPP-806">    p = dirFile-&gt;readDirCache();</front>
<front id="SdBaseFileCPP-807">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-808"></front>
<front id="SdBaseFileCPP-809">    // done if last entry</front>
<front id="SdBaseFileCPP-810">    if (p-&gt;name[0] == DIR_NAME_FREE) goto fail;</front>
<front id="SdBaseFileCPP-811"></front>
<front id="SdBaseFileCPP-812">    // skip empty slot or '.' or '..'</front>
<front id="SdBaseFileCPP-813">    if (p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') {</front>
<front id="SdBaseFileCPP-814">      continue;</front>
<front id="SdBaseFileCPP-815">    }</front>
<front id="SdBaseFileCPP-816">    // must be file or dir</front>
<front id="SdBaseFileCPP-817">    if (DIR_IS_FILE_OR_SUBDIR(p)) {</front>
<front id="SdBaseFileCPP-818">      return openCachedEntry(index, oflag);</front>
<front id="SdBaseFileCPP-819">    }</front>
<front id="SdBaseFileCPP-820">  }</front>
<front id="SdBaseFileCPP-821"></front>
<front id="SdBaseFileCPP-822"> fail:</front>
<front id="SdBaseFileCPP-823">  return false;</front>
<front id="SdBaseFileCPP-824">}</front>
<front id="SdBaseFileCPP-825">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-826">/** Open a directory's parent directory.</front>
<front id="SdBaseFileCPP-827"> *</front>
<front id="SdBaseFileCPP-828"> * \param[in] dir Parent of this directory will be opened.  Must not be root.</front>
<front id="SdBaseFileCPP-829"> *</front>
<front id="SdBaseFileCPP-830"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-831"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-832"> */</front>
<front id="SdBaseFileCPP-833">bool SdBaseFile::openParent(SdBaseFile* dir) {</front>
<front id="SdBaseFileCPP-834">  dir_t entry;</front>
<front id="SdBaseFileCPP-835">  dir_t* p;</front>
<front id="SdBaseFileCPP-836">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-837">  uint32_t c;</front>
<front id="SdBaseFileCPP-838">  uint32_t cluster;</front>
<front id="SdBaseFileCPP-839">  uint32_t lbn;</front>
<front id="SdBaseFileCPP-840">  // error if already open or dir is root or dir is not a directory</front>
<front id="SdBaseFileCPP-841">  if (isOpen() || !dir || dir-&gt;isRoot() || !dir-&gt;isDir()) goto fail;</front>
<front id="SdBaseFileCPP-842">  vol_ = dir-&gt;vol_;</front>
<front id="SdBaseFileCPP-843">  // position to '..'</front>
<front id="SdBaseFileCPP-844">  if (!dir-&gt;seekSet(32)) goto fail;</front>
<front id="SdBaseFileCPP-845">  // read '..' entry</front>
<front id="SdBaseFileCPP-846">  if (dir-&gt;read(&entry, sizeof(entry)) != 32) goto fail;</front>
<front id="SdBaseFileCPP-847">  // verify it is '..'</front>
<front id="SdBaseFileCPP-848">  if (entry.name[0] != '.' || entry.name[1] != '.') goto fail;</front>
<front id="SdBaseFileCPP-849">  // start cluster for '..'</front>
<front id="SdBaseFileCPP-850">  cluster = entry.firstClusterLow;</front>
<front id="SdBaseFileCPP-851">  cluster |= (uint32_t)entry.firstClusterHigh &lt;&lt; 16;</front>
<front id="SdBaseFileCPP-852">  if (cluster == 0) return openRoot(vol_);</front>
<front id="SdBaseFileCPP-853">  // start block for '..'</front>
<front id="SdBaseFileCPP-854">  lbn = vol_-&gt;clusterStartBlock(cluster);</front>
<front id="SdBaseFileCPP-855">  // first block of parent dir</front>
<front id="SdBaseFileCPP-856">  if (!vol_-&gt;cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {</front>
<front id="SdBaseFileCPP-857">    goto fail;</front>
<front id="SdBaseFileCPP-858">  }</front>
<front id="SdBaseFileCPP-859">  p = &vol_-&gt;cacheBuffer_.dir[1];</front>
<front id="SdBaseFileCPP-860">  // verify name for '../..'</front>
<front id="SdBaseFileCPP-861">  if (p-&gt;name[0] != '.' || p-&gt;name[1] != '.') goto fail;</front>
<front id="SdBaseFileCPP-862">  // '..' is pointer to first cluster of parent. open '../..' to find parent</front>
<front id="SdBaseFileCPP-863">  if (p-&gt;firstClusterHigh == 0 && p-&gt;firstClusterLow == 0) {</front>
<front id="SdBaseFileCPP-864">    if (!file.openRoot(dir-&gt;volume())) goto fail;</front>
<front id="SdBaseFileCPP-865">  } else {</front>
<front id="SdBaseFileCPP-866">    if (!file.openCachedEntry(1, O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-867">  }</front>
<front id="SdBaseFileCPP-868">  // search for parent in '../..'</front>
<front id="SdBaseFileCPP-869">  do {</front>
<front id="SdBaseFileCPP-870">    if (file.readDir(&entry, NULL) != 32) goto fail;</front>
<front id="SdBaseFileCPP-871">    c = entry.firstClusterLow;</front>
<front id="SdBaseFileCPP-872">    c |= (uint32_t)entry.firstClusterHigh &lt;&lt; 16;</front>
<front id="SdBaseFileCPP-873">  } while (c != cluster);</front>
<front id="SdBaseFileCPP-874">  // open parent</front>
<front id="SdBaseFileCPP-875">  return open(&file, file.curPosition()/32 - 1, O_READ);</front>
<front id="SdBaseFileCPP-876"></front>
<front id="SdBaseFileCPP-877"> fail:</front>
<front id="SdBaseFileCPP-878">  return false;</front>
<front id="SdBaseFileCPP-879">}</front>
<front id="SdBaseFileCPP-880">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-881">/** Open a volume's root directory.</front>
<front id="SdBaseFileCPP-882"> *</front>
<front id="SdBaseFileCPP-883"> * \param[in] vol The FAT volume containing the root directory to be opened.</front>
<front id="SdBaseFileCPP-884"> *</front>
<front id="SdBaseFileCPP-885"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-886"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-887"> * Reasons for failure include the file is already open, the FAT volume has</front>
<front id="SdBaseFileCPP-888"> * not been initialized or it a FAT12 volume.</front>
<front id="SdBaseFileCPP-889"> */</front>
<front id="SdBaseFileCPP-890">bool SdBaseFile::openRoot(SdVolume* vol) {</front>
<front id="SdBaseFileCPP-891">  // error if file is already open</front>
<front id="SdBaseFileCPP-892">  if (isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-893"></front>
<front id="SdBaseFileCPP-894">  if (vol-&gt;fatType() == 16 || (FAT12_SUPPORT && vol-&gt;fatType() == 12)) {</front>
<front id="SdBaseFileCPP-895">    type_ = FAT_FILE_TYPE_ROOT_FIXED;</front>
<front id="SdBaseFileCPP-896">    firstCluster_ = 0;</front>
<front id="SdBaseFileCPP-897">    fileSize_ = 32 * vol-&gt;rootDirEntryCount();</front>
<front id="SdBaseFileCPP-898">  } else if (vol-&gt;fatType() == 32) {</front>
<front id="SdBaseFileCPP-899">    type_ = FAT_FILE_TYPE_ROOT32;</front>
<front id="SdBaseFileCPP-900">    firstCluster_ = vol-&gt;rootDirStart();</front>
<front id="SdBaseFileCPP-901">    if (!vol-&gt;chainSize(firstCluster_, &fileSize_)) goto fail;</front>
<front id="SdBaseFileCPP-902">  } else {</front>
<front id="SdBaseFileCPP-903">    // volume is not initialized, invalid, or FAT12 without support</front>
<front id="SdBaseFileCPP-904">    return false;</front>
<front id="SdBaseFileCPP-905">  }</front>
<front id="SdBaseFileCPP-906">  vol_ = vol;</front>
<front id="SdBaseFileCPP-907">  // read only</front>
<front id="SdBaseFileCPP-908">  flags_ = O_READ;</front>
<front id="SdBaseFileCPP-909"></front>
<front id="SdBaseFileCPP-910">  // set to start of file</front>
<front id="SdBaseFileCPP-911">  curCluster_ = 0;</front>
<front id="SdBaseFileCPP-912">  curPosition_ = 0;</front>
<front id="SdBaseFileCPP-913"></front>
<front id="SdBaseFileCPP-914">  // root has no directory entry</front>
<front id="SdBaseFileCPP-915">  dirBlock_ = 0;</front>
<front id="SdBaseFileCPP-916">  dirIndex_ = 0;</front>
<front id="SdBaseFileCPP-917">  return true;</front>
<front id="SdBaseFileCPP-918"></front>
<front id="SdBaseFileCPP-919"> fail:</front>
<front id="SdBaseFileCPP-920">  return false;</front>
<front id="SdBaseFileCPP-921">}</front>
<front id="SdBaseFileCPP-922">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-923">/** Return the next available byte without consuming it.</front>
<front id="SdBaseFileCPP-924"> *</front>
<front id="SdBaseFileCPP-925"> * \return The byte if no error and not at eof else -1;</front>
<front id="SdBaseFileCPP-926"> */</front>
<front id="SdBaseFileCPP-927">int SdBaseFile::peek() {</front>
<front id="SdBaseFileCPP-928">  fpos_t pos;</front>
<front id="SdBaseFileCPP-929">  getpos(&pos);</front>
<front id="SdBaseFileCPP-930">  int c = read();</front>
<front id="SdBaseFileCPP-931">  if (c &gt;= 0) setpos(&pos);</front>
<front id="SdBaseFileCPP-932">  return c;</front>
<front id="SdBaseFileCPP-933">}</front>
<front id="SdBaseFileCPP-934"></front>
<front id="SdBaseFileCPP-935">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-936">/** %Print the name field of a directory entry in 8.3 format.</front>
<front id="SdBaseFileCPP-937"> * \param[in] pr Print stream for output.</front>
<front id="SdBaseFileCPP-938"> * \param[in] dir The directory structure containing the name.</front>
<front id="SdBaseFileCPP-939"> * \param[in] width Blank fill name if length is less than \a width.</front>
<front id="SdBaseFileCPP-940"> * \param[in] printSlash Print '/' after directory names if true.</front>
<front id="SdBaseFileCPP-941"> */</front>
<front id="SdBaseFileCPP-942">void SdBaseFile::printDirName(const dir_t& dir,</front>
<front id="SdBaseFileCPP-943">  uint8_t width, bool printSlash) {</front>
<front id="SdBaseFileCPP-944">  uint8_t w = 0;</front>
<front id="SdBaseFileCPP-945">  for (uint8_t i = 0; i &lt; 11; i++) {</front>
<front id="SdBaseFileCPP-946">    if (dir.name[i] == ' ')continue;</front>
<front id="SdBaseFileCPP-947">    if (i == 8) {</front>
<front id="SdBaseFileCPP-948">      MYSERIAL.write('.');</front>
<front id="SdBaseFileCPP-949">      w++;</front>
<front id="SdBaseFileCPP-950">    }</front>
<front id="SdBaseFileCPP-951">    MYSERIAL.write(dir.name[i]);</front>
<front id="SdBaseFileCPP-952">    w++;</front>
<front id="SdBaseFileCPP-953">  }</front>
<front id="SdBaseFileCPP-954">  if (DIR_IS_SUBDIR(&dir) && printSlash) {</front>
<front id="SdBaseFileCPP-955">    MYSERIAL.write('/');</front>
<front id="SdBaseFileCPP-956">    w++;</front>
<front id="SdBaseFileCPP-957">  }</front>
<front id="SdBaseFileCPP-958">  while (w &lt; width) {</front>
<front id="SdBaseFileCPP-959">    MYSERIAL.write(' ');</front>
<front id="SdBaseFileCPP-960">    w++;</front>
<front id="SdBaseFileCPP-961">  }</front>
<front id="SdBaseFileCPP-962">}</front>
<front id="SdBaseFileCPP-963">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-964">// print uint8_t with width 2</front>
<front id="SdBaseFileCPP-965">static void print2u( uint8_t v) {</front>
<front id="SdBaseFileCPP-966">  if (v &lt; 10) MYSERIAL.write('0');</front>
<front id="SdBaseFileCPP-967">  MYSERIAL.print(v, DEC);</front>
<front id="SdBaseFileCPP-968">}</front>
<front id="SdBaseFileCPP-969">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-970">/** %Print a directory date field to Serial.</front>
<front id="SdBaseFileCPP-971"> *</front>
<front id="SdBaseFileCPP-972"> *  Format is yyyy-mm-dd.</front>
<front id="SdBaseFileCPP-973"> *</front>
<front id="SdBaseFileCPP-974"> * \param[in] fatDate The date field from a directory entry.</front>
<front id="SdBaseFileCPP-975"> */</front>
<front id="SdBaseFileCPP-976"></front>
<front id="SdBaseFileCPP-977">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-978">/** %Print a directory date field.</front>
<front id="SdBaseFileCPP-979"> *</front>
<front id="SdBaseFileCPP-980"> *  Format is yyyy-mm-dd.</front>
<front id="SdBaseFileCPP-981"> *</front>
<front id="SdBaseFileCPP-982"> * \param[in] pr Print stream for output.</front>
<front id="SdBaseFileCPP-983"> * \param[in] fatDate The date field from a directory entry.</front>
<front id="SdBaseFileCPP-984"> */</front>
<front id="SdBaseFileCPP-985">void SdBaseFile::printFatDate(uint16_t fatDate) {</front>
<front id="SdBaseFileCPP-986">  MYSERIAL.print(FAT_YEAR(fatDate));</front>
<front id="SdBaseFileCPP-987">  MYSERIAL.write('-');</front>
<front id="SdBaseFileCPP-988">  print2u( FAT_MONTH(fatDate));</front>
<front id="SdBaseFileCPP-989">  MYSERIAL.write('-');</front>
<front id="SdBaseFileCPP-990">  print2u( FAT_DAY(fatDate));</front>
<front id="SdBaseFileCPP-991">}</front>
<front id="SdBaseFileCPP-992"></front>
<front id="SdBaseFileCPP-993">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-994">/** %Print a directory time field.</front>
<front id="SdBaseFileCPP-995"> *</front>
<front id="SdBaseFileCPP-996"> * Format is hh:mm:ss.</front>
<front id="SdBaseFileCPP-997"> *</front>
<front id="SdBaseFileCPP-998"> * \param[in] pr Print stream for output.</front>
<front id="SdBaseFileCPP-999"> * \param[in] fatTime The time field from a directory entry.</front>
<front id="SdBaseFileCPP-1000"> */</front>
<front id="SdBaseFileCPP-1001">void SdBaseFile::printFatTime( uint16_t fatTime) {</front>
<front id="SdBaseFileCPP-1002">  print2u( FAT_HOUR(fatTime));</front>
<front id="SdBaseFileCPP-1003">  MYSERIAL.write(':');</front>
<front id="SdBaseFileCPP-1004">  print2u( FAT_MINUTE(fatTime));</front>
<front id="SdBaseFileCPP-1005">  MYSERIAL.write(':');</front>
<front id="SdBaseFileCPP-1006">  print2u( FAT_SECOND(fatTime));</front>
<front id="SdBaseFileCPP-1007">}</front>
<front id="SdBaseFileCPP-1008">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1009">/** Print a file's name to Serial</front>
<front id="SdBaseFileCPP-1010"> *</front>
<front id="SdBaseFileCPP-1011"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1012"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1013"> */</front>
<front id="SdBaseFileCPP-1014">bool SdBaseFile::printName() {</front>
<front id="SdBaseFileCPP-1015">  char name[FILENAME_LENGTH];</front>
<front id="SdBaseFileCPP-1016">  if (!getFilename(name)) return false;</front>
<front id="SdBaseFileCPP-1017">  MYSERIAL.print(name);</front>
<front id="SdBaseFileCPP-1018">  return true;</front>
<front id="SdBaseFileCPP-1019">}</front>
<front id="SdBaseFileCPP-1020">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1021">/** Read the next byte from a file.</front>
<front id="SdBaseFileCPP-1022"> *</front>
<front id="SdBaseFileCPP-1023"> * \return For success read returns the next byte in the file as an int.</front>
<front id="SdBaseFileCPP-1024"> * If an error occurs or end of file is reached -1 is returned.</front>
<front id="SdBaseFileCPP-1025"> */</front>
<front id="SdBaseFileCPP-1026">int16_t SdBaseFile::read() {</front>
<front id="SdBaseFileCPP-1027">  uint8_t b;</front>
<front id="SdBaseFileCPP-1028">  return read(&b, 1) == 1 ? b : -1;</front>
<front id="SdBaseFileCPP-1029">}</front>
<front id="SdBaseFileCPP-1030">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1031">/** Read data from a file starting at the current position.</front>
<front id="SdBaseFileCPP-1032"> *</front>
<front id="SdBaseFileCPP-1033"> * \param[out] buf Pointer to the location that will receive the data.</front>
<front id="SdBaseFileCPP-1034"> *</front>
<front id="SdBaseFileCPP-1035"> * \param[in] nbyte Maximum number of bytes to read.</front>
<front id="SdBaseFileCPP-1036"> *</front>
<front id="SdBaseFileCPP-1037"> * \return For success read() returns the number of bytes read.</front>
<front id="SdBaseFileCPP-1038"> * A value less than \a nbyte, including zero, will be returned</front>
<front id="SdBaseFileCPP-1039"> * if end of file is reached.</front>
<front id="SdBaseFileCPP-1040"> * If an error occurs, read() returns -1.  Possible errors include</front>
<front id="SdBaseFileCPP-1041"> * read() called before a file has been opened, corrupt file system</front>
<front id="SdBaseFileCPP-1042"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1043"> */</front>
<front id="SdBaseFileCPP-1044">int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {</front>
<front id="SdBaseFileCPP-1045">  uint8_t* dst = reinterpret_cast&lt;uint8_t*&gt;(buf);</front>
<front id="SdBaseFileCPP-1046">  uint16_t offset;</front>
<front id="SdBaseFileCPP-1047">  uint16_t toRead;</front>
<front id="SdBaseFileCPP-1048">  uint32_t block;  // raw device block number</front>
<front id="SdBaseFileCPP-1049"></front>
<front id="SdBaseFileCPP-1050">  // error if not open or write only</front>
<front id="SdBaseFileCPP-1051">  if (!isOpen() || !(flags_ & O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1052"></front>
<front id="SdBaseFileCPP-1053">  // max bytes left in file</front>
<front id="SdBaseFileCPP-1054">  if (nbyte &gt;= (fileSize_ - curPosition_)) {</front>
<front id="SdBaseFileCPP-1055">    nbyte = fileSize_ - curPosition_;</front>
<front id="SdBaseFileCPP-1056">  }</front>
<front id="SdBaseFileCPP-1057">  // amount left to read</front>
<front id="SdBaseFileCPP-1058">  toRead = nbyte;</front>
<front id="SdBaseFileCPP-1059">  while (toRead &gt; 0) {</front>
<front id="SdBaseFileCPP-1060">    offset = curPosition_ & 0X1FF;  // offset in block</front>
<front id="SdBaseFileCPP-1061">    if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {</front>
<front id="SdBaseFileCPP-1062">      block = vol_-&gt;rootDirStart() + (curPosition_ &gt;&gt; 9);</front>
<front id="SdBaseFileCPP-1063">    } else {</front>
<front id="SdBaseFileCPP-1064">      uint8_t blockOfCluster = vol_-&gt;blockOfCluster(curPosition_);</front>
<front id="SdBaseFileCPP-1065">      if (offset == 0 && blockOfCluster == 0) {</front>
<front id="SdBaseFileCPP-1066">        // start of new cluster</front>
<front id="SdBaseFileCPP-1067">        if (curPosition_ == 0) {</front>
<front id="SdBaseFileCPP-1068">          // use first cluster in file</front>
<front id="SdBaseFileCPP-1069">          curCluster_ = firstCluster_;</front>
<front id="SdBaseFileCPP-1070">        } else {</front>
<front id="SdBaseFileCPP-1071">          // get next cluster from FAT</front>
<front id="SdBaseFileCPP-1072">          if (!vol_-&gt;fatGet(curCluster_, &curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1073">        }</front>
<front id="SdBaseFileCPP-1074">      }</front>
<front id="SdBaseFileCPP-1075">      block = vol_-&gt;clusterStartBlock(curCluster_) + blockOfCluster;</front>
<front id="SdBaseFileCPP-1076">    }</front>
<front id="SdBaseFileCPP-1077">    uint16_t n = toRead;</front>
<front id="SdBaseFileCPP-1078"></front>
<front id="SdBaseFileCPP-1079">    // amount to be read from current block</front>
<front id="SdBaseFileCPP-1080">    if (n &gt; (512 - offset)) n = 512 - offset;</front>
<front id="SdBaseFileCPP-1081"></front>
<front id="SdBaseFileCPP-1082">    // no buffering needed if n == 512</front>
<front id="SdBaseFileCPP-1083">    if (n == 512 && block != vol_-&gt;cacheBlockNumber()) {</front>
<front id="SdBaseFileCPP-1084">      if (!vol_-&gt;readBlock(block, dst)) goto fail;</front>
<front id="SdBaseFileCPP-1085">    } else {</front>
<front id="SdBaseFileCPP-1086">      // read block to cache and copy data to caller</front>
<front id="SdBaseFileCPP-1087">      if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1088">      uint8_t* src = vol_-&gt;cache()-&gt;data + offset;</front>
<front id="SdBaseFileCPP-1089">      memcpy(dst, src, n);</front>
<front id="SdBaseFileCPP-1090">    }</front>
<front id="SdBaseFileCPP-1091">    dst += n;</front>
<front id="SdBaseFileCPP-1092">    curPosition_ += n;</front>
<front id="SdBaseFileCPP-1093">    toRead -= n;</front>
<front id="SdBaseFileCPP-1094">  }</front>
<front id="SdBaseFileCPP-1095">  return nbyte;</front>
<front id="SdBaseFileCPP-1096"></front>
<front id="SdBaseFileCPP-1097"> fail:</front>
<front id="SdBaseFileCPP-1098">  return -1;</front>
<front id="SdBaseFileCPP-1099">}</front>
<front id="SdBaseFileCPP-1100"></front>
<front id="SdBaseFileCPP-1101">/**</front>
<front id="SdBaseFileCPP-1102"> * Read the next entry in a directory.</front>
<front id="SdBaseFileCPP-1103"> *</front>
<front id="SdBaseFileCPP-1104"> * \param[out] dir The dir_t struct that will receive the data.</front>
<front id="SdBaseFileCPP-1105"> *</front>
<front id="SdBaseFileCPP-1106"> * \return For success readDir() returns the number of bytes read.</front>
<front id="SdBaseFileCPP-1107"> * A value of zero will be returned if end of file is reached.</front>
<front id="SdBaseFileCPP-1108"> * If an error occurs, readDir() returns -1.  Possible errors include</front>
<front id="SdBaseFileCPP-1109"> * readDir() called before a directory has been opened, this is not</front>
<front id="SdBaseFileCPP-1110"> * a directory file or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1111"> */</front>
<front id="SdBaseFileCPP-1112">int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {</front>
<front id="SdBaseFileCPP-1113">  int16_t n;</front>
<front id="SdBaseFileCPP-1114">  // if not a directory file or miss-positioned return an error</front>
<front id="SdBaseFileCPP-1115">  if (!isDir() || (0X1F & curPosition_)) return -1;</front>
<front id="SdBaseFileCPP-1116">  </front>
<front id="SdBaseFileCPP-1117">  //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.</front>
<front id="SdBaseFileCPP-1118">  if (longFilename != NULL) longFilename[0] = '\0';</front>
<front id="SdBaseFileCPP-1119"></front>
<front id="SdBaseFileCPP-1120">  while (1) {</front>
<front id="SdBaseFileCPP-1121"></front>
<front id="SdBaseFileCPP-1122">    n = read(dir, sizeof(dir_t));</front>
<front id="SdBaseFileCPP-1123">    if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;</front>
<front id="SdBaseFileCPP-1124"></front>
<front id="SdBaseFileCPP-1125">    // last entry if DIR_NAME_FREE</front>
<front id="SdBaseFileCPP-1126">    if (dir-&gt;name[0] == DIR_NAME_FREE) return 0;</front>
<front id="SdBaseFileCPP-1127"></front>
<front id="SdBaseFileCPP-1128">    // skip empty entries and entry for .  and ..</front>
<front id="SdBaseFileCPP-1129">    if (dir-&gt;name[0] == DIR_NAME_DELETED || dir-&gt;name[0] == '.') continue;</front>
<front id="SdBaseFileCPP-1130"></front>
<front id="SdBaseFileCPP-1131">    // Fill the long filename if we have a long filename entry.</front>
<front id="SdBaseFileCPP-1132">    // Long filename entries are stored before the short filename.</front>
<front id="SdBaseFileCPP-1133">    if (longFilename != NULL && DIR_IS_LONG_NAME(dir)) {</front>
<front id="SdBaseFileCPP-1134">      vfat_t *VFAT = (vfat_t*)dir;</front>
<front id="SdBaseFileCPP-1135">      // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0</front>
<front id="SdBaseFileCPP-1136">      if (VFAT-&gt;firstClusterLow == 0 && (VFAT-&gt;sequenceNumber & 0x1F) &gt; 0 && (VFAT-&gt;sequenceNumber & 0x1F) &lt;= MAX_VFAT_ENTRIES) {</front>
<front id="SdBaseFileCPP-1137">        // TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.</front>
<front id="SdBaseFileCPP-1138">        n = ((VFAT-&gt;sequenceNumber & 0x1F) - 1) * FILENAME_LENGTH;</front>
<front id="SdBaseFileCPP-1139">        for (uint8_t i=0; i&lt;FILENAME_LENGTH; i++)</front>
<front id="SdBaseFileCPP-1140">          longFilename[n+i] = (i &lt; 5) ? VFAT-&gt;name1[i] : (i &lt; 11) ? VFAT-&gt;name2[i-5] : VFAT-&gt;name3[i-11];</front>
<front id="SdBaseFileCPP-1141">        // If this VFAT entry is the last one, add a NUL terminator at the end of the string</front>
<front id="SdBaseFileCPP-1142">        if (VFAT-&gt;sequenceNumber & 0x40) longFilename[n+FILENAME_LENGTH] = '\0';</front>
<front id="SdBaseFileCPP-1143">      }</front>
<front id="SdBaseFileCPP-1144">    }</front>
<front id="SdBaseFileCPP-1145">    // Return if normal file or subdirectory</front>
<front id="SdBaseFileCPP-1146">    if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;</front>
<front id="SdBaseFileCPP-1147">  }</front>
<front id="SdBaseFileCPP-1148">}</front>
<front id="SdBaseFileCPP-1149"></front>
<front id="SdBaseFileCPP-1150">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1151">// Read next directory entry into the cache</front>
<front id="SdBaseFileCPP-1152">// Assumes file is correctly positioned</front>
<front id="SdBaseFileCPP-1153">dir_t* SdBaseFile::readDirCache() {</front>
<front id="SdBaseFileCPP-1154">  uint8_t i;</front>
<front id="SdBaseFileCPP-1155">  // error if not directory</front>
<front id="SdBaseFileCPP-1156">  if (!isDir()) goto fail;</front>
<front id="SdBaseFileCPP-1157"></front>
<front id="SdBaseFileCPP-1158">  // index of entry in cache</front>
<front id="SdBaseFileCPP-1159">  i = (curPosition_ &gt;&gt; 5) & 0XF;</front>
<front id="SdBaseFileCPP-1160"></front>
<front id="SdBaseFileCPP-1161">  // use read to locate and cache block</front>
<front id="SdBaseFileCPP-1162">  if (read() &lt; 0) goto fail;</front>
<front id="SdBaseFileCPP-1163"></front>
<front id="SdBaseFileCPP-1164">  // advance to next entry</front>
<front id="SdBaseFileCPP-1165">  curPosition_ += 31;</front>
<front id="SdBaseFileCPP-1166"></front>
<front id="SdBaseFileCPP-1167">  // return pointer to entry</front>
<front id="SdBaseFileCPP-1168">  return vol_-&gt;cache()-&gt;dir + i;</front>
<front id="SdBaseFileCPP-1169"></front>
<front id="SdBaseFileCPP-1170"> fail:</front>
<front id="SdBaseFileCPP-1171">  return 0;</front>
<front id="SdBaseFileCPP-1172">}</front>
<front id="SdBaseFileCPP-1173">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1174">/** Remove a file.</front>
<front id="SdBaseFileCPP-1175"> *</front>
<front id="SdBaseFileCPP-1176"> * The directory entry and all data for the file are deleted.</front>
<front id="SdBaseFileCPP-1177"> *</front>
<front id="SdBaseFileCPP-1178"> * \note This function should not be used to delete the 8.3 version of a</front>
<front id="SdBaseFileCPP-1179"> * file that has a long name. For example if a file has the long name</front>
<front id="SdBaseFileCPP-1180"> * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".</front>
<front id="SdBaseFileCPP-1181"> *</front>
<front id="SdBaseFileCPP-1182"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1183"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1184"> * Reasons for failure include the file read-only, is a directory,</front>
<front id="SdBaseFileCPP-1185"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1186"> */</front>
<front id="SdBaseFileCPP-1187">bool SdBaseFile::remove() {</front>
<front id="SdBaseFileCPP-1188">  dir_t* d;</front>
<front id="SdBaseFileCPP-1189">  // free any clusters - will fail if read-only or directory</front>
<front id="SdBaseFileCPP-1190">  if (!truncate(0)) goto fail;</front>
<front id="SdBaseFileCPP-1191"></front>
<front id="SdBaseFileCPP-1192">  // cache directory entry</front>
<front id="SdBaseFileCPP-1193">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1194">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1195"></front>
<front id="SdBaseFileCPP-1196">  // mark entry deleted</front>
<front id="SdBaseFileCPP-1197">  d-&gt;name[0] = DIR_NAME_DELETED;</front>
<front id="SdBaseFileCPP-1198"></front>
<front id="SdBaseFileCPP-1199">  // set this file closed</front>
<front id="SdBaseFileCPP-1200">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-1201"></front>
<front id="SdBaseFileCPP-1202">  // write entry to SD</front>
<front id="SdBaseFileCPP-1203">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1204">  return true;</front>
<front id="SdBaseFileCPP-1205"></front>
<front id="SdBaseFileCPP-1206"> fail:</front>
<front id="SdBaseFileCPP-1207">  return false;</front>
<front id="SdBaseFileCPP-1208">}</front>
<front id="SdBaseFileCPP-1209">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1210">/** Remove a file.</front>
<front id="SdBaseFileCPP-1211"> *</front>
<front id="SdBaseFileCPP-1212"> * The directory entry and all data for the file are deleted.</front>
<front id="SdBaseFileCPP-1213"> *</front>
<front id="SdBaseFileCPP-1214"> * \param[in] dirFile The directory that contains the file.</front>
<front id="SdBaseFileCPP-1215"> * \param[in] path Path for the file to be removed.</front>
<front id="SdBaseFileCPP-1216"> *</front>
<front id="SdBaseFileCPP-1217"> * \note This function should not be used to delete the 8.3 version of a</front>
<front id="SdBaseFileCPP-1218"> * file that has a long name. For example if a file has the long name</front>
<front id="SdBaseFileCPP-1219"> * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".</front>
<front id="SdBaseFileCPP-1220"> *</front>
<front id="SdBaseFileCPP-1221"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1222"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1223"> * Reasons for failure include the file is a directory, is read only,</front>
<front id="SdBaseFileCPP-1224"> * \a dirFile is not a directory, \a path is not found</front>
<front id="SdBaseFileCPP-1225"> * or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1226"> */</front>
<front id="SdBaseFileCPP-1227">bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {</front>
<front id="SdBaseFileCPP-1228">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-1229">  if (!file.open(dirFile, path, O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1230">  return file.remove();</front>
<front id="SdBaseFileCPP-1231"></front>
<front id="SdBaseFileCPP-1232"> fail:</front>
<front id="SdBaseFileCPP-1233">  // can't set iostate - static function</front>
<front id="SdBaseFileCPP-1234">  return false;</front>
<front id="SdBaseFileCPP-1235">}</front>
<front id="SdBaseFileCPP-1236">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1237">/** Rename a file or subdirectory.</front>
<front id="SdBaseFileCPP-1238"> *</front>
<front id="SdBaseFileCPP-1239"> * \param[in] dirFile Directory for the new path.</front>
<front id="SdBaseFileCPP-1240"> * \param[in] newPath New path name for the file/directory.</front>
<front id="SdBaseFileCPP-1241"> *</front>
<front id="SdBaseFileCPP-1242"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1243"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1244"> * Reasons for failure include \a dirFile is not open or is not a directory</front>
<front id="SdBaseFileCPP-1245"> * file, newPath is invalid or already exists, or an I/O error occurs.</front>
<front id="SdBaseFileCPP-1246"> */</front>
<front id="SdBaseFileCPP-1247">bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {</front>
<front id="SdBaseFileCPP-1248">  dir_t entry;</front>
<front id="SdBaseFileCPP-1249">  uint32_t dirCluster = 0;</front>
<front id="SdBaseFileCPP-1250">  SdBaseFile file;</front>
<front id="SdBaseFileCPP-1251">  dir_t* d;</front>
<front id="SdBaseFileCPP-1252"></front>
<front id="SdBaseFileCPP-1253">  // must be an open file or subdirectory</front>
<front id="SdBaseFileCPP-1254">  if (!(isFile() || isSubDir())) goto fail;</front>
<front id="SdBaseFileCPP-1255"></front>
<front id="SdBaseFileCPP-1256">  // can't move file</front>
<front id="SdBaseFileCPP-1257">  if (vol_ != dirFile-&gt;vol_) goto fail;</front>
<front id="SdBaseFileCPP-1258"></front>
<front id="SdBaseFileCPP-1259">  // sync() and cache directory entry</front>
<front id="SdBaseFileCPP-1260">  sync();</front>
<front id="SdBaseFileCPP-1261">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1262">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1263"></front>
<front id="SdBaseFileCPP-1264">  // save directory entry</front>
<front id="SdBaseFileCPP-1265">  memcpy(&entry, d, sizeof(entry));</front>
<front id="SdBaseFileCPP-1266"></front>
<front id="SdBaseFileCPP-1267">  // mark entry deleted</front>
<front id="SdBaseFileCPP-1268">  d-&gt;name[0] = DIR_NAME_DELETED;</front>
<front id="SdBaseFileCPP-1269"></front>
<front id="SdBaseFileCPP-1270">  // make directory entry for new path</front>
<front id="SdBaseFileCPP-1271">  if (isFile()) {</front>
<front id="SdBaseFileCPP-1272">    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {</front>
<front id="SdBaseFileCPP-1273">      goto restore;</front>
<front id="SdBaseFileCPP-1274">    }</front>
<front id="SdBaseFileCPP-1275">  } else {</front>
<front id="SdBaseFileCPP-1276">    // don't create missing path prefix components</front>
<front id="SdBaseFileCPP-1277">    if (!file.mkdir(dirFile, newPath, false)) {</front>
<front id="SdBaseFileCPP-1278">      goto restore;</front>
<front id="SdBaseFileCPP-1279">    }</front>
<front id="SdBaseFileCPP-1280">    // save cluster containing new dot dot</front>
<front id="SdBaseFileCPP-1281">    dirCluster = file.firstCluster_;</front>
<front id="SdBaseFileCPP-1282">  }</front>
<front id="SdBaseFileCPP-1283">  // change to new directory entry</front>
<front id="SdBaseFileCPP-1284">  dirBlock_ = file.dirBlock_;</front>
<front id="SdBaseFileCPP-1285">  dirIndex_ = file.dirIndex_;</front>
<front id="SdBaseFileCPP-1286"></front>
<front id="SdBaseFileCPP-1287">  // mark closed to avoid possible destructor close call</front>
<front id="SdBaseFileCPP-1288">  file.type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-1289"></front>
<front id="SdBaseFileCPP-1290">  // cache new directory entry</front>
<front id="SdBaseFileCPP-1291">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1292">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1293"></front>
<front id="SdBaseFileCPP-1294">  // copy all but name field to new directory entry</front>
<front id="SdBaseFileCPP-1295">  memcpy(&d-&gt;attributes, &entry.attributes, sizeof(entry) - sizeof(d-&gt;name));</front>
<front id="SdBaseFileCPP-1296"></front>
<front id="SdBaseFileCPP-1297">  // update dot dot if directory</front>
<front id="SdBaseFileCPP-1298">  if (dirCluster) {</front>
<front id="SdBaseFileCPP-1299">    // get new dot dot</front>
<front id="SdBaseFileCPP-1300">    uint32_t block = vol_-&gt;clusterStartBlock(dirCluster);</front>
<front id="SdBaseFileCPP-1301">    if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1302">    memcpy(&entry, &vol_-&gt;cache()-&gt;dir[1], sizeof(entry));</front>
<front id="SdBaseFileCPP-1303"></front>
<front id="SdBaseFileCPP-1304">    // free unused cluster</front>
<front id="SdBaseFileCPP-1305">    if (!vol_-&gt;freeChain(dirCluster)) goto fail;</front>
<front id="SdBaseFileCPP-1306"></front>
<front id="SdBaseFileCPP-1307">    // store new dot dot</front>
<front id="SdBaseFileCPP-1308">    block = vol_-&gt;clusterStartBlock(firstCluster_);</front>
<front id="SdBaseFileCPP-1309">    if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1310">    memcpy(&vol_-&gt;cache()-&gt;dir[1], &entry, sizeof(entry));</front>
<front id="SdBaseFileCPP-1311">  }</front>
<front id="SdBaseFileCPP-1312">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1313"></front>
<front id="SdBaseFileCPP-1314"> restore:</front>
<front id="SdBaseFileCPP-1315">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1316">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1317">  // restore entry</front>
<front id="SdBaseFileCPP-1318">  d-&gt;name[0] = entry.name[0];</front>
<front id="SdBaseFileCPP-1319">  vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1320"></front>
<front id="SdBaseFileCPP-1321"> fail:</front>
<front id="SdBaseFileCPP-1322">  return false;</front>
<front id="SdBaseFileCPP-1323">}</front>
<front id="SdBaseFileCPP-1324">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1325">/** Remove a directory file.</front>
<front id="SdBaseFileCPP-1326"> *</front>
<front id="SdBaseFileCPP-1327"> * The directory file will be removed only if it is empty and is not the</front>
<front id="SdBaseFileCPP-1328"> * root directory.  rmdir() follows DOS and Windows and ignores the</front>
<front id="SdBaseFileCPP-1329"> * read-only attribute for the directory.</front>
<front id="SdBaseFileCPP-1330"> *</front>
<front id="SdBaseFileCPP-1331"> * \note This function should not be used to delete the 8.3 version of a</front>
<front id="SdBaseFileCPP-1332"> * directory that has a long name. For example if a directory has the</front>
<front id="SdBaseFileCPP-1333"> * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".</front>
<front id="SdBaseFileCPP-1334"> *</front>
<front id="SdBaseFileCPP-1335"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1336"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1337"> * Reasons for failure include the file is not a directory, is the root</front>
<front id="SdBaseFileCPP-1338"> * directory, is not empty, or an I/O error occurred.</front>
<front id="SdBaseFileCPP-1339"> */</front>
<front id="SdBaseFileCPP-1340">bool SdBaseFile::rmdir() {</front>
<front id="SdBaseFileCPP-1341">  // must be open subdirectory</front>
<front id="SdBaseFileCPP-1342">  if (!isSubDir()) goto fail;</front>
<front id="SdBaseFileCPP-1343"></front>
<front id="SdBaseFileCPP-1344">  rewind();</front>
<front id="SdBaseFileCPP-1345"></front>
<front id="SdBaseFileCPP-1346">  // make sure directory is empty</front>
<front id="SdBaseFileCPP-1347">  while (curPosition_ &lt; fileSize_) {</front>
<front id="SdBaseFileCPP-1348">    dir_t* p = readDirCache();</front>
<front id="SdBaseFileCPP-1349">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-1350">    // done if past last used entry</front>
<front id="SdBaseFileCPP-1351">    if (p-&gt;name[0] == DIR_NAME_FREE) break;</front>
<front id="SdBaseFileCPP-1352">    // skip empty slot, '.' or '..'</front>
<front id="SdBaseFileCPP-1353">    if (p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') continue;</front>
<front id="SdBaseFileCPP-1354">    // error not empty</front>
<front id="SdBaseFileCPP-1355">    if (DIR_IS_FILE_OR_SUBDIR(p)) goto fail;</front>
<front id="SdBaseFileCPP-1356">  }</front>
<front id="SdBaseFileCPP-1357">  // convert empty directory to normal file for remove</front>
<front id="SdBaseFileCPP-1358">  type_ = FAT_FILE_TYPE_NORMAL;</front>
<front id="SdBaseFileCPP-1359">  flags_ |= O_WRITE;</front>
<front id="SdBaseFileCPP-1360">  return remove();</front>
<front id="SdBaseFileCPP-1361"></front>
<front id="SdBaseFileCPP-1362"> fail:</front>
<front id="SdBaseFileCPP-1363">  return false;</front>
<front id="SdBaseFileCPP-1364">}</front>
<front id="SdBaseFileCPP-1365">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1366">/** Recursively delete a directory and all contained files.</front>
<front id="SdBaseFileCPP-1367"> *</front>
<front id="SdBaseFileCPP-1368"> * This is like the Unix/Linux 'rm -rf *' if called with the root directory</front>
<front id="SdBaseFileCPP-1369"> * hence the name.</front>
<front id="SdBaseFileCPP-1370"> *</front>
<front id="SdBaseFileCPP-1371"> * Warning - This will remove all contents of the directory including</front>
<front id="SdBaseFileCPP-1372"> * subdirectories.  The directory will then be removed if it is not root.</front>
<front id="SdBaseFileCPP-1373"> * The read-only attribute for files will be ignored.</front>
<front id="SdBaseFileCPP-1374"> *</front>
<front id="SdBaseFileCPP-1375"> * \note This function should not be used to delete the 8.3 version of</front>
<front id="SdBaseFileCPP-1376"> * a directory that has a long name.  See remove() and rmdir().</front>
<front id="SdBaseFileCPP-1377"> *</front>
<front id="SdBaseFileCPP-1378"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1379"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1380"> */</front>
<front id="SdBaseFileCPP-1381">bool SdBaseFile::rmRfStar() {</front>
<front id="SdBaseFileCPP-1382">  uint16_t index;</front>
<front id="SdBaseFileCPP-1383">  SdBaseFile f;</front>
<front id="SdBaseFileCPP-1384">  rewind();</front>
<front id="SdBaseFileCPP-1385">  while (curPosition_ &lt; fileSize_) {</front>
<front id="SdBaseFileCPP-1386">    // remember position</front>
<front id="SdBaseFileCPP-1387">    index = curPosition_/32;</front>
<front id="SdBaseFileCPP-1388"></front>
<front id="SdBaseFileCPP-1389">    dir_t* p = readDirCache();</front>
<front id="SdBaseFileCPP-1390">    if (!p) goto fail;</front>
<front id="SdBaseFileCPP-1391"></front>
<front id="SdBaseFileCPP-1392">    // done if past last entry</front>
<front id="SdBaseFileCPP-1393">    if (p-&gt;name[0] == DIR_NAME_FREE) break;</front>
<front id="SdBaseFileCPP-1394"></front>
<front id="SdBaseFileCPP-1395">    // skip empty slot or '.' or '..'</front>
<front id="SdBaseFileCPP-1396">    if (p-&gt;name[0] == DIR_NAME_DELETED || p-&gt;name[0] == '.') continue;</front>
<front id="SdBaseFileCPP-1397"></front>
<front id="SdBaseFileCPP-1398">    // skip if part of long file name or volume label in root</front>
<front id="SdBaseFileCPP-1399">    if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;</front>
<front id="SdBaseFileCPP-1400"></front>
<front id="SdBaseFileCPP-1401">    if (!f.open(this, index, O_READ)) goto fail;</front>
<front id="SdBaseFileCPP-1402">    if (f.isSubDir()) {</front>
<front id="SdBaseFileCPP-1403">      // recursively delete</front>
<front id="SdBaseFileCPP-1404">      if (!f.rmRfStar()) goto fail;</front>
<front id="SdBaseFileCPP-1405">    } else {</front>
<front id="SdBaseFileCPP-1406">      // ignore read-only</front>
<front id="SdBaseFileCPP-1407">      f.flags_ |= O_WRITE;</front>
<front id="SdBaseFileCPP-1408">      if (!f.remove()) goto fail;</front>
<front id="SdBaseFileCPP-1409">    }</front>
<front id="SdBaseFileCPP-1410">    // position to next entry if required</front>
<front id="SdBaseFileCPP-1411">    if (curPosition_ != (32*(index + 1))) {</front>
<front id="SdBaseFileCPP-1412">      if (!seekSet(32*(index + 1))) goto fail;</front>
<front id="SdBaseFileCPP-1413">    }</front>
<front id="SdBaseFileCPP-1414">  }</front>
<front id="SdBaseFileCPP-1415">  // don't try to delete root</front>
<front id="SdBaseFileCPP-1416">  if (!isRoot()) {</front>
<front id="SdBaseFileCPP-1417">    if (!rmdir()) goto fail;</front>
<front id="SdBaseFileCPP-1418">  }</front>
<front id="SdBaseFileCPP-1419">  return true;</front>
<front id="SdBaseFileCPP-1420"></front>
<front id="SdBaseFileCPP-1421"> fail:</front>
<front id="SdBaseFileCPP-1422">  return false;</front>
<front id="SdBaseFileCPP-1423">}</front>
<front id="SdBaseFileCPP-1424">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1425">/**  Create a file object and open it in the current working directory.</front>
<front id="SdBaseFileCPP-1426"> *</front>
<front id="SdBaseFileCPP-1427"> * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileCPP-1428"> *</front>
<front id="SdBaseFileCPP-1429"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-1430"> * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).</front>
<front id="SdBaseFileCPP-1431"> */</front>
<front id="SdBaseFileCPP-1432">SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileCPP-1433">  type_ = FAT_FILE_TYPE_CLOSED;</front>
<front id="SdBaseFileCPP-1434">  writeError = false;</front>
<front id="SdBaseFileCPP-1435">  open(path, oflag);</front>
<front id="SdBaseFileCPP-1436">}</front>
<front id="SdBaseFileCPP-1437">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1438">/** Sets a file's position.</front>
<front id="SdBaseFileCPP-1439"> *</front>
<front id="SdBaseFileCPP-1440"> * \param[in] pos The new position in bytes from the beginning of the file.</front>
<front id="SdBaseFileCPP-1441"> *</front>
<front id="SdBaseFileCPP-1442"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1443"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1444"> */</front>
<front id="SdBaseFileCPP-1445">bool SdBaseFile::seekSet(uint32_t pos) {</front>
<front id="SdBaseFileCPP-1446">  uint32_t nCur;</front>
<front id="SdBaseFileCPP-1447">  uint32_t nNew;</front>
<front id="SdBaseFileCPP-1448">  // error if file not open or seek past end of file</front>
<front id="SdBaseFileCPP-1449">  if (!isOpen() || pos &gt; fileSize_) goto fail;</front>
<front id="SdBaseFileCPP-1450"></front>
<front id="SdBaseFileCPP-1451">  if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {</front>
<front id="SdBaseFileCPP-1452">    curPosition_ = pos;</front>
<front id="SdBaseFileCPP-1453">    goto done;</front>
<front id="SdBaseFileCPP-1454">  }</front>
<front id="SdBaseFileCPP-1455">  if (pos == 0) {</front>
<front id="SdBaseFileCPP-1456">    // set position to start of file</front>
<front id="SdBaseFileCPP-1457">    curCluster_ = 0;</front>
<front id="SdBaseFileCPP-1458">    curPosition_ = 0;</front>
<front id="SdBaseFileCPP-1459">    goto done;</front>
<front id="SdBaseFileCPP-1460">  }</front>
<front id="SdBaseFileCPP-1461">  // calculate cluster index for cur and new position</front>
<front id="SdBaseFileCPP-1462">  nCur = (curPosition_ - 1) &gt;&gt; (vol_-&gt;clusterSizeShift_ + 9);</front>
<front id="SdBaseFileCPP-1463">  nNew = (pos - 1) &gt;&gt; (vol_-&gt;clusterSizeShift_ + 9);</front>
<front id="SdBaseFileCPP-1464"></front>
<front id="SdBaseFileCPP-1465">  if (nNew &lt; nCur || curPosition_ == 0) {</front>
<front id="SdBaseFileCPP-1466">    // must follow chain from first cluster</front>
<front id="SdBaseFileCPP-1467">    curCluster_ = firstCluster_;</front>
<front id="SdBaseFileCPP-1468">  } else {</front>
<front id="SdBaseFileCPP-1469">    // advance from curPosition</front>
<front id="SdBaseFileCPP-1470">    nNew -= nCur;</front>
<front id="SdBaseFileCPP-1471">  }</front>
<front id="SdBaseFileCPP-1472">  while (nNew--) {</front>
<front id="SdBaseFileCPP-1473">    if (!vol_-&gt;fatGet(curCluster_, &curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1474">  }</front>
<front id="SdBaseFileCPP-1475">  curPosition_ = pos;</front>
<front id="SdBaseFileCPP-1476"></front>
<front id="SdBaseFileCPP-1477"> done:</front>
<front id="SdBaseFileCPP-1478">  return true;</front>
<front id="SdBaseFileCPP-1479"></front>
<front id="SdBaseFileCPP-1480"> fail:</front>
<front id="SdBaseFileCPP-1481">  return false;</front>
<front id="SdBaseFileCPP-1482">}</front>
<front id="SdBaseFileCPP-1483">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1484">void SdBaseFile::setpos(fpos_t* pos) {</front>
<front id="SdBaseFileCPP-1485">  curPosition_ = pos-&gt;position;</front>
<front id="SdBaseFileCPP-1486">  curCluster_ = pos-&gt;cluster;</front>
<front id="SdBaseFileCPP-1487">}</front>
<front id="SdBaseFileCPP-1488">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1489">/** The sync() call causes all modified data and directory fields</front>
<front id="SdBaseFileCPP-1490"> * to be written to the storage device.</front>
<front id="SdBaseFileCPP-1491"> *</front>
<front id="SdBaseFileCPP-1492"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1493"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1494"> * Reasons for failure include a call to sync() before a file has been</front>
<front id="SdBaseFileCPP-1495"> * opened or an I/O error.</front>
<front id="SdBaseFileCPP-1496"> */</front>
<front id="SdBaseFileCPP-1497">bool SdBaseFile::sync() {</front>
<front id="SdBaseFileCPP-1498">  // only allow open files and directories</front>
<front id="SdBaseFileCPP-1499">  if (!isOpen()) goto fail;</front>
<front id="SdBaseFileCPP-1500"></front>
<front id="SdBaseFileCPP-1501">  if (flags_ & F_FILE_DIR_DIRTY) {</front>
<front id="SdBaseFileCPP-1502">    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1503">    // check for deleted by another open file object</front>
<front id="SdBaseFileCPP-1504">    if (!d || d-&gt;name[0] == DIR_NAME_DELETED) goto fail;</front>
<front id="SdBaseFileCPP-1505"></front>
<front id="SdBaseFileCPP-1506">    // do not set filesize for dir files</front>
<front id="SdBaseFileCPP-1507">    if (!isDir()) d-&gt;fileSize = fileSize_;</front>
<front id="SdBaseFileCPP-1508"></front>
<front id="SdBaseFileCPP-1509">    // update first cluster fields</front>
<front id="SdBaseFileCPP-1510">    d-&gt;firstClusterLow = firstCluster_ & 0XFFFF;</front>
<front id="SdBaseFileCPP-1511">    d-&gt;firstClusterHigh = firstCluster_ &gt;&gt; 16;</front>
<front id="SdBaseFileCPP-1512"></front>
<front id="SdBaseFileCPP-1513">    // set modify time if user supplied a callback date/time function</front>
<front id="SdBaseFileCPP-1514">    if (dateTime_) {</front>
<front id="SdBaseFileCPP-1515">      dateTime_(&d-&gt;lastWriteDate, &d-&gt;lastWriteTime);</front>
<front id="SdBaseFileCPP-1516">      d-&gt;lastAccessDate = d-&gt;lastWriteDate;</front>
<front id="SdBaseFileCPP-1517">    }</front>
<front id="SdBaseFileCPP-1518">    // clear directory dirty</front>
<front id="SdBaseFileCPP-1519">    flags_ &= ~F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1520">  }</front>
<front id="SdBaseFileCPP-1521">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1522"></front>
<front id="SdBaseFileCPP-1523"> fail:</front>
<front id="SdBaseFileCPP-1524">  writeError = true;</front>
<front id="SdBaseFileCPP-1525">  return false;</front>
<front id="SdBaseFileCPP-1526">}</front>
<front id="SdBaseFileCPP-1527">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1528">/** Copy a file's timestamps</front>
<front id="SdBaseFileCPP-1529"> *</front>
<front id="SdBaseFileCPP-1530"> * \param[in] file File to copy timestamps from.</front>
<front id="SdBaseFileCPP-1531"> *</front>
<front id="SdBaseFileCPP-1532"> * \note</front>
<front id="SdBaseFileCPP-1533"> * Modify and access timestamps may be overwritten if a date time callback</front>
<front id="SdBaseFileCPP-1534"> * function has been set by dateTimeCallback().</front>
<front id="SdBaseFileCPP-1535"> *</front>
<front id="SdBaseFileCPP-1536"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1537"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1538"> */</front>
<front id="SdBaseFileCPP-1539">bool SdBaseFile::timestamp(SdBaseFile* file) {</front>
<front id="SdBaseFileCPP-1540">  dir_t* d;</front>
<front id="SdBaseFileCPP-1541">  dir_t dir;</front>
<front id="SdBaseFileCPP-1542"></front>
<front id="SdBaseFileCPP-1543">  // get timestamps</front>
<front id="SdBaseFileCPP-1544">  if (!file-&gt;dirEntry(&dir)) goto fail;</front>
<front id="SdBaseFileCPP-1545"></front>
<front id="SdBaseFileCPP-1546">  // update directory fields</front>
<front id="SdBaseFileCPP-1547">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1548"></front>
<front id="SdBaseFileCPP-1549">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1550">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1551"></front>
<front id="SdBaseFileCPP-1552">  // copy timestamps</front>
<front id="SdBaseFileCPP-1553">  d-&gt;lastAccessDate = dir.lastAccessDate;</front>
<front id="SdBaseFileCPP-1554">  d-&gt;creationDate = dir.creationDate;</front>
<front id="SdBaseFileCPP-1555">  d-&gt;creationTime = dir.creationTime;</front>
<front id="SdBaseFileCPP-1556">  d-&gt;creationTimeTenths = dir.creationTimeTenths;</front>
<front id="SdBaseFileCPP-1557">  d-&gt;lastWriteDate = dir.lastWriteDate;</front>
<front id="SdBaseFileCPP-1558">  d-&gt;lastWriteTime = dir.lastWriteTime;</front>
<front id="SdBaseFileCPP-1559"></front>
<front id="SdBaseFileCPP-1560">  // write back entry</front>
<front id="SdBaseFileCPP-1561">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1562"></front>
<front id="SdBaseFileCPP-1563"> fail:</front>
<front id="SdBaseFileCPP-1564">  return false;</front>
<front id="SdBaseFileCPP-1565">}</front>
<front id="SdBaseFileCPP-1566">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1567">/** Set a file's timestamps in its directory entry.</front>
<front id="SdBaseFileCPP-1568"> *</front>
<front id="SdBaseFileCPP-1569"> * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileCPP-1570"> * OR of flags from the following list</front>
<front id="SdBaseFileCPP-1571"> *</front>
<front id="SdBaseFileCPP-1572"> * T_ACCESS - Set the file's last access date.</front>
<front id="SdBaseFileCPP-1573"> *</front>
<front id="SdBaseFileCPP-1574"> * T_CREATE - Set the file's creation date and time.</front>
<front id="SdBaseFileCPP-1575"> *</front>
<front id="SdBaseFileCPP-1576"> * T_WRITE - Set the file's last write/modification date and time.</front>
<front id="SdBaseFileCPP-1577"> *</front>
<front id="SdBaseFileCPP-1578"> * \param[in] year Valid range 1980 - 2107 inclusive.</front>
<front id="SdBaseFileCPP-1579"> *</front>
<front id="SdBaseFileCPP-1580"> * \param[in] month Valid range 1 - 12 inclusive.</front>
<front id="SdBaseFileCPP-1581"> *</front>
<front id="SdBaseFileCPP-1582"> * \param[in] day Valid range 1 - 31 inclusive.</front>
<front id="SdBaseFileCPP-1583"> *</front>
<front id="SdBaseFileCPP-1584"> * \param[in] hour Valid range 0 - 23 inclusive.</front>
<front id="SdBaseFileCPP-1585"> *</front>
<front id="SdBaseFileCPP-1586"> * \param[in] minute Valid range 0 - 59 inclusive.</front>
<front id="SdBaseFileCPP-1587"> *</front>
<front id="SdBaseFileCPP-1588"> * \param[in] second Valid range 0 - 59 inclusive</front>
<front id="SdBaseFileCPP-1589"> *</front>
<front id="SdBaseFileCPP-1590"> * \note It is possible to set an invalid date since there is no check for</front>
<front id="SdBaseFileCPP-1591"> * the number of days in a month.</front>
<front id="SdBaseFileCPP-1592"> *</front>
<front id="SdBaseFileCPP-1593"> * \note</front>
<front id="SdBaseFileCPP-1594"> * Modify and access timestamps may be overwritten if a date time callback</front>
<front id="SdBaseFileCPP-1595"> * function has been set by dateTimeCallback().</front>
<front id="SdBaseFileCPP-1596"> *</front>
<front id="SdBaseFileCPP-1597"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1598"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1599"> */</front>
<front id="SdBaseFileCPP-1600">bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,</front>
<front id="SdBaseFileCPP-1601">         uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {</front>
<front id="SdBaseFileCPP-1602">  uint16_t dirDate;</front>
<front id="SdBaseFileCPP-1603">  uint16_t dirTime;</front>
<front id="SdBaseFileCPP-1604">  dir_t* d;</front>
<front id="SdBaseFileCPP-1605"></front>
<front id="SdBaseFileCPP-1606">  if (!isOpen()</front>
<front id="SdBaseFileCPP-1607">    || year &lt; 1980</front>
<front id="SdBaseFileCPP-1608">    || year &gt; 2107</front>
<front id="SdBaseFileCPP-1609">    || month &lt; 1</front>
<front id="SdBaseFileCPP-1610">    || month &gt; 12</front>
<front id="SdBaseFileCPP-1611">    || day &lt; 1</front>
<front id="SdBaseFileCPP-1612">    || day &gt; 31</front>
<front id="SdBaseFileCPP-1613">    || hour &gt; 23</front>
<front id="SdBaseFileCPP-1614">    || minute &gt; 59</front>
<front id="SdBaseFileCPP-1615">    || second &gt; 59) {</front>
<front id="SdBaseFileCPP-1616">      goto fail;</front>
<front id="SdBaseFileCPP-1617">  }</front>
<front id="SdBaseFileCPP-1618">  // update directory entry</front>
<front id="SdBaseFileCPP-1619">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1620"></front>
<front id="SdBaseFileCPP-1621">  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);</front>
<front id="SdBaseFileCPP-1622">  if (!d) goto fail;</front>
<front id="SdBaseFileCPP-1623"></front>
<front id="SdBaseFileCPP-1624">  dirDate = FAT_DATE(year, month, day);</front>
<front id="SdBaseFileCPP-1625">  dirTime = FAT_TIME(hour, minute, second);</front>
<front id="SdBaseFileCPP-1626">  if (flags & T_ACCESS) {</front>
<front id="SdBaseFileCPP-1627">    d-&gt;lastAccessDate = dirDate;</front>
<front id="SdBaseFileCPP-1628">  }</front>
<front id="SdBaseFileCPP-1629">  if (flags & T_CREATE) {</front>
<front id="SdBaseFileCPP-1630">    d-&gt;creationDate = dirDate;</front>
<front id="SdBaseFileCPP-1631">    d-&gt;creationTime = dirTime;</front>
<front id="SdBaseFileCPP-1632">    // seems to be units of 1/100 second not 1/10 as Microsoft states</front>
<front id="SdBaseFileCPP-1633">    d-&gt;creationTimeTenths = second & 1 ? 100 : 0;</front>
<front id="SdBaseFileCPP-1634">  }</front>
<front id="SdBaseFileCPP-1635">  if (flags & T_WRITE) {</front>
<front id="SdBaseFileCPP-1636">    d-&gt;lastWriteDate = dirDate;</front>
<front id="SdBaseFileCPP-1637">    d-&gt;lastWriteTime = dirTime;</front>
<front id="SdBaseFileCPP-1638">  }</front>
<front id="SdBaseFileCPP-1639">  return vol_-&gt;cacheFlush();</front>
<front id="SdBaseFileCPP-1640"></front>
<front id="SdBaseFileCPP-1641"> fail:</front>
<front id="SdBaseFileCPP-1642">  return false;</front>
<front id="SdBaseFileCPP-1643">}</front>
<front id="SdBaseFileCPP-1644">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1645">/** Truncate a file to a specified length.  The current file position</front>
<front id="SdBaseFileCPP-1646"> * will be maintained if it is less than or equal to \a length otherwise</front>
<front id="SdBaseFileCPP-1647"> * it will be set to end of file.</front>
<front id="SdBaseFileCPP-1648"> *</front>
<front id="SdBaseFileCPP-1649"> * \param[in] length The desired length for the file.</front>
<front id="SdBaseFileCPP-1650"> *</front>
<front id="SdBaseFileCPP-1651"> * \return The value one, true, is returned for success and</front>
<front id="SdBaseFileCPP-1652"> * the value zero, false, is returned for failure.</front>
<front id="SdBaseFileCPP-1653"> * Reasons for failure include file is read only, file is a directory,</front>
<front id="SdBaseFileCPP-1654"> * \a length is greater than the current file size or an I/O error occurs.</front>
<front id="SdBaseFileCPP-1655"> */</front>
<front id="SdBaseFileCPP-1656">bool SdBaseFile::truncate(uint32_t length) {</front>
<front id="SdBaseFileCPP-1657">  uint32_t newPos;</front>
<front id="SdBaseFileCPP-1658">  // error if not a normal file or read-only</front>
<front id="SdBaseFileCPP-1659">  if (!isFile() || !(flags_ & O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1660"></front>
<front id="SdBaseFileCPP-1661">  // error if length is greater than current size</front>
<front id="SdBaseFileCPP-1662">  if (length &gt; fileSize_) goto fail;</front>
<front id="SdBaseFileCPP-1663"></front>
<front id="SdBaseFileCPP-1664">  // fileSize and length are zero - nothing to do</front>
<front id="SdBaseFileCPP-1665">  if (fileSize_ == 0) return true;</front>
<front id="SdBaseFileCPP-1666"></front>
<front id="SdBaseFileCPP-1667">  // remember position for seek after truncation</front>
<front id="SdBaseFileCPP-1668">  newPos = curPosition_ &gt; length ? length : curPosition_;</front>
<front id="SdBaseFileCPP-1669"></front>
<front id="SdBaseFileCPP-1670">  // position to last cluster in truncated file</front>
<front id="SdBaseFileCPP-1671">  if (!seekSet(length)) goto fail;</front>
<front id="SdBaseFileCPP-1672"></front>
<front id="SdBaseFileCPP-1673">  if (length == 0) {</front>
<front id="SdBaseFileCPP-1674">    // free all clusters</front>
<front id="SdBaseFileCPP-1675">    if (!vol_-&gt;freeChain(firstCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1676">    firstCluster_ = 0;</front>
<front id="SdBaseFileCPP-1677">  } else {</front>
<front id="SdBaseFileCPP-1678">    uint32_t toFree;</front>
<front id="SdBaseFileCPP-1679">    if (!vol_-&gt;fatGet(curCluster_, &toFree)) goto fail;</front>
<front id="SdBaseFileCPP-1680"></front>
<front id="SdBaseFileCPP-1681">    if (!vol_-&gt;isEOC(toFree)) {</front>
<front id="SdBaseFileCPP-1682">      // free extra clusters</front>
<front id="SdBaseFileCPP-1683">      if (!vol_-&gt;freeChain(toFree)) goto fail;</front>
<front id="SdBaseFileCPP-1684"></front>
<front id="SdBaseFileCPP-1685">      // current cluster is end of chain</front>
<front id="SdBaseFileCPP-1686">      if (!vol_-&gt;fatPutEOC(curCluster_)) goto fail;</front>
<front id="SdBaseFileCPP-1687">    }</front>
<front id="SdBaseFileCPP-1688">  }</front>
<front id="SdBaseFileCPP-1689">  fileSize_ = length;</front>
<front id="SdBaseFileCPP-1690"></front>
<front id="SdBaseFileCPP-1691">  // need to update directory entry</front>
<front id="SdBaseFileCPP-1692">  flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1693"></front>
<front id="SdBaseFileCPP-1694">  if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1695"></front>
<front id="SdBaseFileCPP-1696">  // set file to correct position</front>
<front id="SdBaseFileCPP-1697">  return seekSet(newPos);</front>
<front id="SdBaseFileCPP-1698"></front>
<front id="SdBaseFileCPP-1699"> fail:</front>
<front id="SdBaseFileCPP-1700">  return false;</front>
<front id="SdBaseFileCPP-1701">}</front>
<front id="SdBaseFileCPP-1702">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1703">/** Write data to an open file.</front>
<front id="SdBaseFileCPP-1704"> *</front>
<front id="SdBaseFileCPP-1705"> * \note Data is moved to the cache but may not be written to the</front>
<front id="SdBaseFileCPP-1706"> * storage device until sync() is called.</front>
<front id="SdBaseFileCPP-1707"> *</front>
<front id="SdBaseFileCPP-1708"> * \param[in] buf Pointer to the location of the data to be written.</front>
<front id="SdBaseFileCPP-1709"> *</front>
<front id="SdBaseFileCPP-1710"> * \param[in] nbyte Number of bytes to write.</front>
<front id="SdBaseFileCPP-1711"> *</front>
<front id="SdBaseFileCPP-1712"> * \return For success write() returns the number of bytes written, always</front>
<front id="SdBaseFileCPP-1713"> * \a nbyte.  If an error occurs, write() returns -1.  Possible errors</front>
<front id="SdBaseFileCPP-1714"> * include write() is called before a file has been opened, write is called</front>
<front id="SdBaseFileCPP-1715"> * for a read-only file, device is full, a corrupt file system or an I/O error.</front>
<front id="SdBaseFileCPP-1716"> *</front>
<front id="SdBaseFileCPP-1717"> */</front>
<front id="SdBaseFileCPP-1718">int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {</front>
<front id="SdBaseFileCPP-1719">  // convert void* to uint8_t*  -  must be before goto statements</front>
<front id="SdBaseFileCPP-1720">  const uint8_t* src = reinterpret_cast&lt;const uint8_t*&gt;(buf);</front>
<front id="SdBaseFileCPP-1721"></front>
<front id="SdBaseFileCPP-1722">  // number of bytes left to write  -  must be before goto statements</front>
<front id="SdBaseFileCPP-1723">  uint16_t nToWrite = nbyte;</front>
<front id="SdBaseFileCPP-1724"></front>
<front id="SdBaseFileCPP-1725">  // error if not a normal file or is read-only</front>
<front id="SdBaseFileCPP-1726">  if (!isFile() || !(flags_ & O_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1727"></front>
<front id="SdBaseFileCPP-1728">  // seek to end of file if append flag</front>
<front id="SdBaseFileCPP-1729">  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {</front>
<front id="SdBaseFileCPP-1730">    if (!seekEnd()) goto fail;</front>
<front id="SdBaseFileCPP-1731">  }</front>
<front id="SdBaseFileCPP-1732"></front>
<front id="SdBaseFileCPP-1733">  while (nToWrite &gt; 0) {</front>
<front id="SdBaseFileCPP-1734">    uint8_t blockOfCluster = vol_-&gt;blockOfCluster(curPosition_);</front>
<front id="SdBaseFileCPP-1735">    uint16_t blockOffset = curPosition_ & 0X1FF;</front>
<front id="SdBaseFileCPP-1736">    if (blockOfCluster == 0 && blockOffset == 0) {</front>
<front id="SdBaseFileCPP-1737">      // start of new cluster</front>
<front id="SdBaseFileCPP-1738">      if (curCluster_ == 0) {</front>
<front id="SdBaseFileCPP-1739">        if (firstCluster_ == 0) {</front>
<front id="SdBaseFileCPP-1740">          // allocate first cluster of file</front>
<front id="SdBaseFileCPP-1741">          if (!addCluster()) goto fail;</front>
<front id="SdBaseFileCPP-1742">        } else {</front>
<front id="SdBaseFileCPP-1743">          curCluster_ = firstCluster_;</front>
<front id="SdBaseFileCPP-1744">        }</front>
<front id="SdBaseFileCPP-1745">      } else {</front>
<front id="SdBaseFileCPP-1746">        uint32_t next;</front>
<front id="SdBaseFileCPP-1747">        if (!vol_-&gt;fatGet(curCluster_, &next)) goto fail;</front>
<front id="SdBaseFileCPP-1748">        if (vol_-&gt;isEOC(next)) {</front>
<front id="SdBaseFileCPP-1749">          // add cluster if at end of chain</front>
<front id="SdBaseFileCPP-1750">          if (!addCluster()) goto fail;</front>
<front id="SdBaseFileCPP-1751">        } else {</front>
<front id="SdBaseFileCPP-1752">          curCluster_ = next;</front>
<front id="SdBaseFileCPP-1753">        }</front>
<front id="SdBaseFileCPP-1754">      }</front>
<front id="SdBaseFileCPP-1755">    }</front>
<front id="SdBaseFileCPP-1756">    // max space in block</front>
<front id="SdBaseFileCPP-1757">    uint16_t n = 512 - blockOffset;</front>
<front id="SdBaseFileCPP-1758"></front>
<front id="SdBaseFileCPP-1759">    // lesser of space and amount to write</front>
<front id="SdBaseFileCPP-1760">    if (n &gt; nToWrite) n = nToWrite;</front>
<front id="SdBaseFileCPP-1761"></front>
<front id="SdBaseFileCPP-1762">    // block for data write</front>
<front id="SdBaseFileCPP-1763">    uint32_t block = vol_-&gt;clusterStartBlock(curCluster_) + blockOfCluster;</front>
<front id="SdBaseFileCPP-1764">    if (n == 512) {</front>
<front id="SdBaseFileCPP-1765">      // full block - don't need to use cache</front>
<front id="SdBaseFileCPP-1766">      if (vol_-&gt;cacheBlockNumber() == block) {</front>
<front id="SdBaseFileCPP-1767">        // invalidate cache if block is in cache</front>
<front id="SdBaseFileCPP-1768">        vol_-&gt;cacheSetBlockNumber(0XFFFFFFFF, false);</front>
<front id="SdBaseFileCPP-1769">      }</front>
<front id="SdBaseFileCPP-1770">      if (!vol_-&gt;writeBlock(block, src)) goto fail;</front>
<front id="SdBaseFileCPP-1771">    } else {</front>
<front id="SdBaseFileCPP-1772">      if (blockOffset == 0 && curPosition_ &gt;= fileSize_) {</front>
<front id="SdBaseFileCPP-1773">        // start of new block don't need to read into cache</front>
<front id="SdBaseFileCPP-1774">        if (!vol_-&gt;cacheFlush()) goto fail;</front>
<front id="SdBaseFileCPP-1775">        // set cache dirty and SD address of block</front>
<front id="SdBaseFileCPP-1776">        vol_-&gt;cacheSetBlockNumber(block, true);</front>
<front id="SdBaseFileCPP-1777">      } else {</front>
<front id="SdBaseFileCPP-1778">        // rewrite part of block</front>
<front id="SdBaseFileCPP-1779">        if (!vol_-&gt;cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdBaseFileCPP-1780">      }</front>
<front id="SdBaseFileCPP-1781">      uint8_t* dst = vol_-&gt;cache()-&gt;data + blockOffset;</front>
<front id="SdBaseFileCPP-1782">      memcpy(dst, src, n);</front>
<front id="SdBaseFileCPP-1783">    }</front>
<front id="SdBaseFileCPP-1784">    curPosition_ += n;</front>
<front id="SdBaseFileCPP-1785">    src += n;</front>
<front id="SdBaseFileCPP-1786">    nToWrite -= n;</front>
<front id="SdBaseFileCPP-1787">  }</front>
<front id="SdBaseFileCPP-1788">  if (curPosition_ &gt; fileSize_) {</front>
<front id="SdBaseFileCPP-1789">    // update fileSize and insure sync will update dir entry</front>
<front id="SdBaseFileCPP-1790">    fileSize_ = curPosition_;</front>
<front id="SdBaseFileCPP-1791">    flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1792">  } else if (dateTime_ && nbyte) {</front>
<front id="SdBaseFileCPP-1793">    // insure sync will update modified date and time</front>
<front id="SdBaseFileCPP-1794">    flags_ |= F_FILE_DIR_DIRTY;</front>
<front id="SdBaseFileCPP-1795">  }</front>
<front id="SdBaseFileCPP-1796"></front>
<front id="SdBaseFileCPP-1797">  if (flags_ & O_SYNC) {</front>
<front id="SdBaseFileCPP-1798">    if (!sync()) goto fail;</front>
<front id="SdBaseFileCPP-1799">  }</front>
<front id="SdBaseFileCPP-1800">  return nbyte;</front>
<front id="SdBaseFileCPP-1801"></front>
<front id="SdBaseFileCPP-1802"> fail:</front>
<front id="SdBaseFileCPP-1803">  // return for write error</front>
<front id="SdBaseFileCPP-1804">  writeError = true;</front>
<front id="SdBaseFileCPP-1805">  return -1;</front>
<front id="SdBaseFileCPP-1806">}</front>
<front id="SdBaseFileCPP-1807">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileCPP-1808">// suppress cpplint warnings with NOLINT comment</front>
<front id="SdBaseFileCPP-1809">#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)</front>
<front id="SdBaseFileCPP-1810">void (*SdBaseFile::oldDateTime_)(uint16_t& date, uint16_t& time) = 0;  // NOLINT</front>
<front id="SdBaseFileCPP-1811">#endif  // ALLOW_DEPRECATED_FUNCTIONS</front>
<front id="SdBaseFileCPP-1812"></front>
<front id="SdBaseFileCPP-1813"></front>
<front id="SdBaseFileCPP-1814">#endif</front>
 </pre>
<h1 id="SdBaseFileHtitle" >SdBaseFile.h</h1>
<pre id="SdBaseFileH"  class="prettyprint linenums"><front id="SdBaseFileH-1">/* Arduino SdFat Library</front>
<front id="SdBaseFileH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdBaseFileH-3"> *</front>
<front id="SdBaseFileH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdBaseFileH-5"> *</front>
<front id="SdBaseFileH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdBaseFileH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdBaseFileH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdBaseFileH-9"> * (at your option) any later version.</front>
<front id="SdBaseFileH-10"> *</front>
<front id="SdBaseFileH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdBaseFileH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdBaseFileH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdBaseFileH-14"> * GNU General Public License for more details.</front>
<front id="SdBaseFileH-15"> *</front>
<front id="SdBaseFileH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdBaseFileH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdBaseFileH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdBaseFileH-19"> */</front>
<front id="SdBaseFileH-20">#include "Marlin.h"</front>
<front id="SdBaseFileH-21">#if ENABLED(SDSUPPORT)</front>
<front id="SdBaseFileH-22"></front>
<front id="SdBaseFileH-23">#ifndef SdBaseFile_h</front>
<front id="SdBaseFileH-24">#define SdBaseFile_h</front>
<front id="SdBaseFileH-25">/**</front>
<front id="SdBaseFileH-26"> * \file</front>
<front id="SdBaseFileH-27"> * \brief SdBaseFile class</front>
<front id="SdBaseFileH-28"> */</front>
<front id="SdBaseFileH-29">#include "Marlin.h"</front>
<front id="SdBaseFileH-30">#include "SdFatConfig.h"</front>
<front id="SdBaseFileH-31">#include "SdVolume.h"</front>
<front id="SdBaseFileH-32">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-33">/**</front>
<front id="SdBaseFileH-34"> * \struct fpos_t</front>
<front id="SdBaseFileH-35"> * \brief internal type for istream</front>
<front id="SdBaseFileH-36"> * do not use in user apps</front>
<front id="SdBaseFileH-37"> */</front>
<front id="SdBaseFileH-38">struct fpos_t {</front>
<front id="SdBaseFileH-39">  /** stream position */</front>
<front id="SdBaseFileH-40">  uint32_t position;</front>
<front id="SdBaseFileH-41">  /** cluster for position */</front>
<front id="SdBaseFileH-42">  uint32_t cluster;</front>
<front id="SdBaseFileH-43">  fpos_t() : position(0), cluster(0) {}</front>
<front id="SdBaseFileH-44">};</front>
<front id="SdBaseFileH-45"></front>
<front id="SdBaseFileH-46">// use the gnu style oflag in open()</front>
<front id="SdBaseFileH-47">/** open() oflag for reading */</front>
<front id="SdBaseFileH-48">uint8_t const O_READ = 0X01;</front>
<front id="SdBaseFileH-49">/** open() oflag - same as O_IN */</front>
<front id="SdBaseFileH-50">uint8_t const O_RDONLY = O_READ;</front>
<front id="SdBaseFileH-51">/** open() oflag for write */</front>
<front id="SdBaseFileH-52">uint8_t const O_WRITE = 0X02;</front>
<front id="SdBaseFileH-53">/** open() oflag - same as O_WRITE */</front>
<front id="SdBaseFileH-54">uint8_t const O_WRONLY = O_WRITE;</front>
<front id="SdBaseFileH-55">/** open() oflag for reading and writing */</front>
<front id="SdBaseFileH-56">uint8_t const O_RDWR = (O_READ | O_WRITE);</front>
<front id="SdBaseFileH-57">/** open() oflag mask for access modes */</front>
<front id="SdBaseFileH-58">uint8_t const O_ACCMODE = (O_READ | O_WRITE);</front>
<front id="SdBaseFileH-59">/** The file offset shall be set to the end of the file prior to each write. */</front>
<front id="SdBaseFileH-60">uint8_t const O_APPEND = 0X04;</front>
<front id="SdBaseFileH-61">/** synchronous writes - call sync() after each write */</front>
<front id="SdBaseFileH-62">uint8_t const O_SYNC = 0X08;</front>
<front id="SdBaseFileH-63">/** truncate the file to zero length */</front>
<front id="SdBaseFileH-64">uint8_t const O_TRUNC = 0X10;</front>
<front id="SdBaseFileH-65">/** set the initial position at the end of the file */</front>
<front id="SdBaseFileH-66">uint8_t const O_AT_END = 0X20;</front>
<front id="SdBaseFileH-67">/** create the file if nonexistent */</front>
<front id="SdBaseFileH-68">uint8_t const O_CREAT = 0X40;</front>
<front id="SdBaseFileH-69">/** If O_CREAT and O_EXCL are set, open() shall fail if the file exists */</front>
<front id="SdBaseFileH-70">uint8_t const O_EXCL = 0X80;</front>
<front id="SdBaseFileH-71"></front>
<front id="SdBaseFileH-72">// SdBaseFile class static and const definitions</front>
<front id="SdBaseFileH-73">// flags for ls()</front>
<front id="SdBaseFileH-74">/** ls() flag to print modify date */</front>
<front id="SdBaseFileH-75">uint8_t const LS_DATE = 1;</front>
<front id="SdBaseFileH-76">/** ls() flag to print file size */</front>
<front id="SdBaseFileH-77">uint8_t const LS_SIZE = 2;</front>
<front id="SdBaseFileH-78">/** ls() flag for recursive list of subdirectories */</front>
<front id="SdBaseFileH-79">uint8_t const LS_R = 4;</front>
<front id="SdBaseFileH-80"></front>
<front id="SdBaseFileH-81"></front>
<front id="SdBaseFileH-82">// flags for timestamp</front>
<front id="SdBaseFileH-83">/** set the file's last access date */</front>
<front id="SdBaseFileH-84">uint8_t const T_ACCESS = 1;</front>
<front id="SdBaseFileH-85">/** set the file's creation date and time */</front>
<front id="SdBaseFileH-86">uint8_t const T_CREATE = 2;</front>
<front id="SdBaseFileH-87">/** Set the file's write date and time */</front>
<front id="SdBaseFileH-88">uint8_t const T_WRITE = 4;</front>
<front id="SdBaseFileH-89">// values for type_</front>
<front id="SdBaseFileH-90">/** This file has not been opened. */</front>
<front id="SdBaseFileH-91">uint8_t const FAT_FILE_TYPE_CLOSED = 0;</front>
<front id="SdBaseFileH-92">/** A normal file */</front>
<front id="SdBaseFileH-93">uint8_t const FAT_FILE_TYPE_NORMAL = 1;</front>
<front id="SdBaseFileH-94">/** A FAT12 or FAT16 root directory */</front>
<front id="SdBaseFileH-95">uint8_t const FAT_FILE_TYPE_ROOT_FIXED = 2;</front>
<front id="SdBaseFileH-96">/** A FAT32 root directory */</front>
<front id="SdBaseFileH-97">uint8_t const FAT_FILE_TYPE_ROOT32 = 3;</front>
<front id="SdBaseFileH-98">/** A subdirectory file*/</front>
<front id="SdBaseFileH-99">uint8_t const FAT_FILE_TYPE_SUBDIR = 4;</front>
<front id="SdBaseFileH-100">/** Test value for directory type */</front>
<front id="SdBaseFileH-101">uint8_t const FAT_FILE_TYPE_MIN_DIR = FAT_FILE_TYPE_ROOT_FIXED;</front>
<front id="SdBaseFileH-102"></front>
<front id="SdBaseFileH-103">/** date field for FAT directory entry</front>
<front id="SdBaseFileH-104"> * \param[in] year [1980,2107]</front>
<front id="SdBaseFileH-105"> * \param[in] month [1,12]</front>
<front id="SdBaseFileH-106"> * \param[in] day [1,31]</front>
<front id="SdBaseFileH-107"> *</front>
<front id="SdBaseFileH-108"> * \return Packed date for dir_t entry.</front>
<front id="SdBaseFileH-109"> */</front>
<front id="SdBaseFileH-110">static inline uint16_t FAT_DATE(uint16_t year, uint8_t month, uint8_t day) {</front>
<front id="SdBaseFileH-111">  return (year - 1980) &lt;&lt; 9 | month &lt;&lt; 5 | day;</front>
<front id="SdBaseFileH-112">}</front>
<front id="SdBaseFileH-113">/** year part of FAT directory date field</front>
<front id="SdBaseFileH-114"> * \param[in] fatDate Date in packed dir format.</front>
<front id="SdBaseFileH-115"> *</front>
<front id="SdBaseFileH-116"> * \return Extracted year [1980,2107]</front>
<front id="SdBaseFileH-117"> */</front>
<front id="SdBaseFileH-118">static inline uint16_t FAT_YEAR(uint16_t fatDate) {</front>
<front id="SdBaseFileH-119">  return 1980 + (fatDate &gt;&gt; 9);</front>
<front id="SdBaseFileH-120">}</front>
<front id="SdBaseFileH-121">/** month part of FAT directory date field</front>
<front id="SdBaseFileH-122"> * \param[in] fatDate Date in packed dir format.</front>
<front id="SdBaseFileH-123"> *</front>
<front id="SdBaseFileH-124"> * \return Extracted month [1,12]</front>
<front id="SdBaseFileH-125"> */</front>
<front id="SdBaseFileH-126">static inline uint8_t FAT_MONTH(uint16_t fatDate) {</front>
<front id="SdBaseFileH-127">  return (fatDate &gt;&gt; 5) & 0XF;</front>
<front id="SdBaseFileH-128">}</front>
<front id="SdBaseFileH-129">/** day part of FAT directory date field</front>
<front id="SdBaseFileH-130"> * \param[in] fatDate Date in packed dir format.</front>
<front id="SdBaseFileH-131"> *</front>
<front id="SdBaseFileH-132"> * \return Extracted day [1,31]</front>
<front id="SdBaseFileH-133"> */</front>
<front id="SdBaseFileH-134">static inline uint8_t FAT_DAY(uint16_t fatDate) {</front>
<front id="SdBaseFileH-135">  return fatDate & 0X1F;</front>
<front id="SdBaseFileH-136">}</front>
<front id="SdBaseFileH-137">/** time field for FAT directory entry</front>
<front id="SdBaseFileH-138"> * \param[in] hour [0,23]</front>
<front id="SdBaseFileH-139"> * \param[in] minute [0,59]</front>
<front id="SdBaseFileH-140"> * \param[in] second [0,59]</front>
<front id="SdBaseFileH-141"> *</front>
<front id="SdBaseFileH-142"> * \return Packed time for dir_t entry.</front>
<front id="SdBaseFileH-143"> */</front>
<front id="SdBaseFileH-144">static inline uint16_t FAT_TIME(uint8_t hour, uint8_t minute, uint8_t second) {</front>
<front id="SdBaseFileH-145">  return hour &lt;&lt; 11 | minute &lt;&lt; 5 | second &gt;&gt; 1;</front>
<front id="SdBaseFileH-146">}</front>
<front id="SdBaseFileH-147">/** hour part of FAT directory time field</front>
<front id="SdBaseFileH-148"> * \param[in] fatTime Time in packed dir format.</front>
<front id="SdBaseFileH-149"> *</front>
<front id="SdBaseFileH-150"> * \return Extracted hour [0,23]</front>
<front id="SdBaseFileH-151"> */</front>
<front id="SdBaseFileH-152">static inline uint8_t FAT_HOUR(uint16_t fatTime) {</front>
<front id="SdBaseFileH-153">  return fatTime &gt;&gt; 11;</front>
<front id="SdBaseFileH-154">}</front>
<front id="SdBaseFileH-155">/** minute part of FAT directory time field</front>
<front id="SdBaseFileH-156"> * \param[in] fatTime Time in packed dir format.</front>
<front id="SdBaseFileH-157"> *</front>
<front id="SdBaseFileH-158"> * \return Extracted minute [0,59]</front>
<front id="SdBaseFileH-159"> */</front>
<front id="SdBaseFileH-160">static inline uint8_t FAT_MINUTE(uint16_t fatTime) {</front>
<front id="SdBaseFileH-161">  return(fatTime &gt;&gt; 5) & 0X3F;</front>
<front id="SdBaseFileH-162">}</front>
<front id="SdBaseFileH-163">/** second part of FAT directory time field</front>
<front id="SdBaseFileH-164"> * Note second/2 is stored in packed time.</front>
<front id="SdBaseFileH-165"> *</front>
<front id="SdBaseFileH-166"> * \param[in] fatTime Time in packed dir format.</front>
<front id="SdBaseFileH-167"> *</front>
<front id="SdBaseFileH-168"> * \return Extracted second [0,58]</front>
<front id="SdBaseFileH-169"> */</front>
<front id="SdBaseFileH-170">static inline uint8_t FAT_SECOND(uint16_t fatTime) {</front>
<front id="SdBaseFileH-171">  return 2*(fatTime & 0X1F);</front>
<front id="SdBaseFileH-172">}</front>
<front id="SdBaseFileH-173">/** Default date for file timestamps is 1 Jan 2000 */</front>
<front id="SdBaseFileH-174">uint16_t const FAT_DEFAULT_DATE = ((2000 - 1980) &lt;&lt; 9) | (1 &lt;&lt; 5) | 1;</front>
<front id="SdBaseFileH-175">/** Default time for file timestamp is 1 am */</front>
<front id="SdBaseFileH-176">uint16_t const FAT_DEFAULT_TIME = (1 &lt;&lt; 11);</front>
<front id="SdBaseFileH-177">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-178">/**</front>
<front id="SdBaseFileH-179"> * \class SdBaseFile</front>
<front id="SdBaseFileH-180"> * \brief Base class for SdFile with Print and C++ streams.</front>
<front id="SdBaseFileH-181"> */</front>
<front id="SdBaseFileH-182">class SdBaseFile {</front>
<front id="SdBaseFileH-183"> public:</front>
<front id="SdBaseFileH-184">  /** Create an instance. */</front>
<front id="SdBaseFileH-185">  SdBaseFile() : writeError(false), type_(FAT_FILE_TYPE_CLOSED) {}</front>
<front id="SdBaseFileH-186">  SdBaseFile(const char* path, uint8_t oflag);</front>
<front id="SdBaseFileH-187">  ~SdBaseFile() {if(isOpen()) close();}</front>
<front id="SdBaseFileH-188">  /**</front>
<front id="SdBaseFileH-189">   * writeError is set to true if an error occurs during a write().</front>
<front id="SdBaseFileH-190">   * Set writeError to false before calling print() and/or write() and check</front>
<front id="SdBaseFileH-191">   * for true after calls to print() and/or write().</front>
<front id="SdBaseFileH-192">   */</front>
<front id="SdBaseFileH-193">  bool writeError;</front>
<front id="SdBaseFileH-194">  //----------------------------------------------------------------------------</front>
<front id="SdBaseFileH-195">  // helpers for stream classes</front>
<front id="SdBaseFileH-196">  /** get position for streams</front>
<front id="SdBaseFileH-197">   * \param[out] pos struct to receive position</front>
<front id="SdBaseFileH-198">   */</front>
<front id="SdBaseFileH-199">  void getpos(fpos_t* pos);</front>
<front id="SdBaseFileH-200">  /** set position for streams</front>
<front id="SdBaseFileH-201">   * \param[out] pos struct with value for new position</front>
<front id="SdBaseFileH-202">   */</front>
<front id="SdBaseFileH-203">  void setpos(fpos_t* pos);</front>
<front id="SdBaseFileH-204">  //----------------------------------------------------------------------------</front>
<front id="SdBaseFileH-205">  bool close();</front>
<front id="SdBaseFileH-206">  bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);</front>
<front id="SdBaseFileH-207">  bool createContiguous(SdBaseFile* dirFile,</front>
<front id="SdBaseFileH-208">          const char* path, uint32_t size);</front>
<front id="SdBaseFileH-209">  /** \return The current cluster number for a file or directory. */</front>
<front id="SdBaseFileH-210">  uint32_t curCluster() const {return curCluster_;}</front>
<front id="SdBaseFileH-211">  /** \return The current position for a file or directory. */</front>
<front id="SdBaseFileH-212">  uint32_t curPosition() const {return curPosition_;}</front>
<front id="SdBaseFileH-213">  /** \return Current working directory */</front>
<front id="SdBaseFileH-214">  static SdBaseFile* cwd() {return cwd_;}</front>
<front id="SdBaseFileH-215">  /** Set the date/time callback function</front>
<front id="SdBaseFileH-216">   *</front>
<front id="SdBaseFileH-217">   * \param[in] dateTime The user's call back function.  The callback</front>
<front id="SdBaseFileH-218">   * function is of the form:</front>
<front id="SdBaseFileH-219">   *</front>
<front id="SdBaseFileH-220">   * \code</front>
<front id="SdBaseFileH-221">   * void dateTime(uint16_t* date, uint16_t* time) {</front>
<front id="SdBaseFileH-222">   *   uint16_t year;</front>
<front id="SdBaseFileH-223">   *   uint8_t month, day, hour, minute, second;</front>
<front id="SdBaseFileH-224">   *</front>
<front id="SdBaseFileH-225">   *   // User gets date and time from GPS or real-time clock here</front>
<front id="SdBaseFileH-226">   *</front>
<front id="SdBaseFileH-227">   *   // return date using FAT_DATE macro to format fields</front>
<front id="SdBaseFileH-228">   *   *date = FAT_DATE(year, month, day);</front>
<front id="SdBaseFileH-229">   *</front>
<front id="SdBaseFileH-230">   *   // return time using FAT_TIME macro to format fields</front>
<front id="SdBaseFileH-231">   *   *time = FAT_TIME(hour, minute, second);</front>
<front id="SdBaseFileH-232">   * }</front>
<front id="SdBaseFileH-233">   * \endcode</front>
<front id="SdBaseFileH-234">   *</front>
<front id="SdBaseFileH-235">   * Sets the function that is called when a file is created or when</front>
<front id="SdBaseFileH-236">   * a file's directory entry is modified by sync(). All timestamps,</front>
<front id="SdBaseFileH-237">   * access, creation, and modify, are set when a file is created.</front>
<front id="SdBaseFileH-238">   * sync() maintains the last access date and last modify date/time.</front>
<front id="SdBaseFileH-239">   *</front>
<front id="SdBaseFileH-240">   * See the timestamp() function.</front>
<front id="SdBaseFileH-241">   */</front>
<front id="SdBaseFileH-242">  static void dateTimeCallback(</front>
<front id="SdBaseFileH-243">    void (*dateTime)(uint16_t* date, uint16_t* time)) {</front>
<front id="SdBaseFileH-244">    dateTime_ = dateTime;</front>
<front id="SdBaseFileH-245">  }</front>
<front id="SdBaseFileH-246">  /**  Cancel the date/time callback function. */</front>
<front id="SdBaseFileH-247">  static void dateTimeCallbackCancel() {dateTime_ = 0;}</front>
<front id="SdBaseFileH-248">  bool dirEntry(dir_t* dir);</front>
<front id="SdBaseFileH-249">  static void dirName(const dir_t& dir, char* name);</front>
<front id="SdBaseFileH-250">  bool exists(const char* name);</front>
<front id="SdBaseFileH-251">  int16_t fgets(char* str, int16_t num, char* delim = 0);</front>
<front id="SdBaseFileH-252">  /** \return The total number of bytes in a file or directory. */</front>
<front id="SdBaseFileH-253">  uint32_t fileSize() const {return fileSize_;}</front>
<front id="SdBaseFileH-254">  /** \return The first cluster number for a file or directory. */</front>
<front id="SdBaseFileH-255">  uint32_t firstCluster() const {return firstCluster_;}</front>
<front id="SdBaseFileH-256">  bool getFilename(char* name);</front>
<front id="SdBaseFileH-257">  /** \return True if this is a directory else false. */</front>
<front id="SdBaseFileH-258">  bool isDir() const {return type_ &gt;= FAT_FILE_TYPE_MIN_DIR;}</front>
<front id="SdBaseFileH-259">  /** \return True if this is a normal file else false. */</front>
<front id="SdBaseFileH-260">  bool isFile() const {return type_ == FAT_FILE_TYPE_NORMAL;}</front>
<front id="SdBaseFileH-261">  /** \return True if this is an open file/directory else false. */</front>
<front id="SdBaseFileH-262">  bool isOpen() const {return type_ != FAT_FILE_TYPE_CLOSED;}</front>
<front id="SdBaseFileH-263">  /** \return True if this is a subdirectory else false. */</front>
<front id="SdBaseFileH-264">  bool isSubDir() const {return type_ == FAT_FILE_TYPE_SUBDIR;}</front>
<front id="SdBaseFileH-265">  /** \return True if this is the root directory. */</front>
<front id="SdBaseFileH-266">  bool isRoot() const {</front>
<front id="SdBaseFileH-267">    return type_ == FAT_FILE_TYPE_ROOT_FIXED || type_ == FAT_FILE_TYPE_ROOT32;</front>
<front id="SdBaseFileH-268">  }</front>
<front id="SdBaseFileH-269">  void ls( uint8_t flags = 0, uint8_t indent = 0);</front>
<front id="SdBaseFileH-270">  bool mkdir(SdBaseFile* dir, const char* path, bool pFlag = true);</front>
<front id="SdBaseFileH-271">  // alias for backward compactability</front>
<front id="SdBaseFileH-272">  bool makeDir(SdBaseFile* dir, const char* path) {</front>
<front id="SdBaseFileH-273">    return mkdir(dir, path, false);</front>
<front id="SdBaseFileH-274">  }</front>
<front id="SdBaseFileH-275">  bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);</front>
<front id="SdBaseFileH-276">  bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);</front>
<front id="SdBaseFileH-277">  bool open(const char* path, uint8_t oflag = O_READ);</front>
<front id="SdBaseFileH-278">  bool openNext(SdBaseFile* dirFile, uint8_t oflag);</front>
<front id="SdBaseFileH-279">  bool openRoot(SdVolume* vol);</front>
<front id="SdBaseFileH-280">  int peek();</front>
<front id="SdBaseFileH-281">  static void printFatDate(uint16_t fatDate);</front>
<front id="SdBaseFileH-282">  static void printFatTime( uint16_t fatTime);</front>
<front id="SdBaseFileH-283">  bool printName();</front>
<front id="SdBaseFileH-284">  int16_t read();</front>
<front id="SdBaseFileH-285">  int16_t read(void* buf, uint16_t nbyte);</front>
<front id="SdBaseFileH-286">  int8_t readDir(dir_t* dir, char* longFilename);</front>
<front id="SdBaseFileH-287">  static bool remove(SdBaseFile* dirFile, const char* path);</front>
<front id="SdBaseFileH-288">  bool remove();</front>
<front id="SdBaseFileH-289">  /** Set the file's current position to zero. */</front>
<front id="SdBaseFileH-290">  void rewind() {seekSet(0);}</front>
<front id="SdBaseFileH-291">  bool rename(SdBaseFile* dirFile, const char* newPath);</front>
<front id="SdBaseFileH-292">  bool rmdir();</front>
<front id="SdBaseFileH-293">  // for backward compatibility</front>
<front id="SdBaseFileH-294">  bool rmDir() {return rmdir();}</front>
<front id="SdBaseFileH-295">  bool rmRfStar();</front>
<front id="SdBaseFileH-296">  /** Set the files position to current position + \a pos. See seekSet().</front>
<front id="SdBaseFileH-297">   * \param[in] offset The new position in bytes from the current position.</front>
<front id="SdBaseFileH-298">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-299">   */</front>
<front id="SdBaseFileH-300">  bool seekCur(int32_t offset) {</front>
<front id="SdBaseFileH-301">    return seekSet(curPosition_ + offset);</front>
<front id="SdBaseFileH-302">  }</front>
<front id="SdBaseFileH-303">  /** Set the files position to end-of-file + \a offset. See seekSet().</front>
<front id="SdBaseFileH-304">   * \param[in] offset The new position in bytes from end-of-file.</front>
<front id="SdBaseFileH-305">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-306">   */</front>
<front id="SdBaseFileH-307">  bool seekEnd(int32_t offset = 0) {return seekSet(fileSize_ + offset);}</front>
<front id="SdBaseFileH-308">  bool seekSet(uint32_t pos);</front>
<front id="SdBaseFileH-309">  bool sync();</front>
<front id="SdBaseFileH-310">  bool timestamp(SdBaseFile* file);</front>
<front id="SdBaseFileH-311">  bool timestamp(uint8_t flag, uint16_t year, uint8_t month, uint8_t day,</front>
<front id="SdBaseFileH-312">          uint8_t hour, uint8_t minute, uint8_t second);</front>
<front id="SdBaseFileH-313">  /** Type of file.  You should use isFile() or isDir() instead of type()</front>
<front id="SdBaseFileH-314">   * if possible.</front>
<front id="SdBaseFileH-315">   *</front>
<front id="SdBaseFileH-316">   * \return The file or directory type.</front>
<front id="SdBaseFileH-317">   */</front>
<front id="SdBaseFileH-318">  uint8_t type() const {return type_;}</front>
<front id="SdBaseFileH-319">  bool truncate(uint32_t size);</front>
<front id="SdBaseFileH-320">  /** \return SdVolume that contains this file. */</front>
<front id="SdBaseFileH-321">  SdVolume* volume() const {return vol_;}</front>
<front id="SdBaseFileH-322">  int16_t write(const void* buf, uint16_t nbyte);</front>
<front id="SdBaseFileH-323">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-324"> private:</front>
<front id="SdBaseFileH-325">  // allow SdFat to set cwd_</front>
<front id="SdBaseFileH-326">  friend class SdFat;</front>
<front id="SdBaseFileH-327">  // global pointer to cwd dir</front>
<front id="SdBaseFileH-328">  static SdBaseFile* cwd_;</front>
<front id="SdBaseFileH-329">  // data time callback function</front>
<front id="SdBaseFileH-330">  static void (*dateTime_)(uint16_t* date, uint16_t* time);</front>
<front id="SdBaseFileH-331">  // bits defined in flags_</front>
<front id="SdBaseFileH-332">  // should be 0X0F</front>
<front id="SdBaseFileH-333">  static uint8_t const F_OFLAG = (O_ACCMODE | O_APPEND | O_SYNC);</front>
<front id="SdBaseFileH-334">  // sync of directory entry required</front>
<front id="SdBaseFileH-335">  static uint8_t const F_FILE_DIR_DIRTY = 0X80;</front>
<front id="SdBaseFileH-336"></front>
<front id="SdBaseFileH-337">  // private data</front>
<front id="SdBaseFileH-338">  uint8_t   flags_;         // See above for definition of flags_ bits</front>
<front id="SdBaseFileH-339">  uint8_t   fstate_;        // error and eof indicator</front>
<front id="SdBaseFileH-340">  uint8_t   type_;          // type of file see above for values</front>
<front id="SdBaseFileH-341">  uint32_t  curCluster_;    // cluster for current file position</front>
<front id="SdBaseFileH-342">  uint32_t  curPosition_;   // current file position in bytes from beginning</front>
<front id="SdBaseFileH-343">  uint32_t  dirBlock_;      // block for this files directory entry</front>
<front id="SdBaseFileH-344">  uint8_t   dirIndex_;      // index of directory entry in dirBlock</front>
<front id="SdBaseFileH-345">  uint32_t  fileSize_;      // file size in bytes</front>
<front id="SdBaseFileH-346">  uint32_t  firstCluster_;  // first cluster of file</front>
<front id="SdBaseFileH-347">  SdVolume* vol_;           // volume where file is located</front>
<front id="SdBaseFileH-348"></front>
<front id="SdBaseFileH-349">  /** experimental don't use */</front>
<front id="SdBaseFileH-350">  bool openParent(SdBaseFile* dir);</front>
<front id="SdBaseFileH-351">  // private functions</front>
<front id="SdBaseFileH-352">  bool addCluster();</front>
<front id="SdBaseFileH-353">  bool addDirCluster();</front>
<front id="SdBaseFileH-354">  dir_t* cacheDirEntry(uint8_t action);</front>
<front id="SdBaseFileH-355">  int8_t lsPrintNext( uint8_t flags, uint8_t indent);</front>
<front id="SdBaseFileH-356">  static bool make83Name(const char* str, uint8_t* name, const char** ptr);</front>
<front id="SdBaseFileH-357">  bool mkdir(SdBaseFile* parent, const uint8_t dname[11]);</front>
<front id="SdBaseFileH-358">  bool open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag);</front>
<front id="SdBaseFileH-359">  bool openCachedEntry(uint8_t cacheIndex, uint8_t oflags);</front>
<front id="SdBaseFileH-360">  dir_t* readDirCache();</front>
<front id="SdBaseFileH-361">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-362">// to be deleted</front>
<front id="SdBaseFileH-363">  static void printDirName( const dir_t& dir,</front>
<front id="SdBaseFileH-364">    uint8_t width, bool printSlash);</front>
<front id="SdBaseFileH-365">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-366">// Deprecated functions  - suppress cpplint warnings with NOLINT comment</front>
<front id="SdBaseFileH-367">#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)</front>
<front id="SdBaseFileH-368"> public:</front>
<front id="SdBaseFileH-369">  /** \deprecated Use:</front>
<front id="SdBaseFileH-370">   * bool contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock);</front>
<front id="SdBaseFileH-371">   * \param[out] bgnBlock the first block address for the file.</front>
<front id="SdBaseFileH-372">   * \param[out] endBlock the last  block address for the file.</front>
<front id="SdBaseFileH-373">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-374">   */</front>
<front id="SdBaseFileH-375">  bool contiguousRange(uint32_t& bgnBlock, uint32_t& endBlock) {  // NOLINT</front>
<front id="SdBaseFileH-376">    return contiguousRange(&bgnBlock, &endBlock);</front>
<front id="SdBaseFileH-377">  }</front>
<front id="SdBaseFileH-378"> /** \deprecated Use:</front>
<front id="SdBaseFileH-379">   * bool createContiguous(SdBaseFile* dirFile,</front>
<front id="SdBaseFileH-380">   *   const char* path, uint32_t size)</front>
<front id="SdBaseFileH-381">   * \param[in] dirFile The directory where the file will be created.</front>
<front id="SdBaseFileH-382">   * \param[in] path A path with a valid DOS 8.3 file name.</front>
<front id="SdBaseFileH-383">   * \param[in] size The desired file size.</front>
<front id="SdBaseFileH-384">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-385">   */</front>
<front id="SdBaseFileH-386">  bool createContiguous(SdBaseFile& dirFile,  // NOLINT</front>
<front id="SdBaseFileH-387">    const char* path, uint32_t size) {</front>
<front id="SdBaseFileH-388">    return createContiguous(&dirFile, path, size);</front>
<front id="SdBaseFileH-389">  }</front>
<front id="SdBaseFileH-390">  /** \deprecated Use:</front>
<front id="SdBaseFileH-391">   * static void dateTimeCallback(</front>
<front id="SdBaseFileH-392">   *   void (*dateTime)(uint16_t* date, uint16_t* time));</front>
<front id="SdBaseFileH-393">   * \param[in] dateTime The user's call back function.</front>
<front id="SdBaseFileH-394">   */</front>
<front id="SdBaseFileH-395">  static void dateTimeCallback(</front>
<front id="SdBaseFileH-396">    void (*dateTime)(uint16_t& date, uint16_t& time)) {  // NOLINT</front>
<front id="SdBaseFileH-397">    oldDateTime_ = dateTime;</front>
<front id="SdBaseFileH-398">    dateTime_ = dateTime ? oldToNew : 0;</front>
<front id="SdBaseFileH-399">  }</front>
<front id="SdBaseFileH-400">  /** \deprecated Use: bool dirEntry(dir_t* dir);</front>
<front id="SdBaseFileH-401">   * \param[out] dir Location for return of the file's directory entry.</front>
<front id="SdBaseFileH-402">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-403">   */</front>
<front id="SdBaseFileH-404">  bool dirEntry(dir_t& dir) {return dirEntry(&dir);}  // NOLINT</front>
<front id="SdBaseFileH-405">  /** \deprecated Use:</front>
<front id="SdBaseFileH-406">   * bool mkdir(SdBaseFile* dir, const char* path);</front>
<front id="SdBaseFileH-407">   * \param[in] dir An open SdFat instance for the directory that will contain</front>
<front id="SdBaseFileH-408">   * the new directory.</front>
<front id="SdBaseFileH-409">   * \param[in] path A path with a valid 8.3 DOS name for the new directory.</front>
<front id="SdBaseFileH-410">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-411">   */</front>
<front id="SdBaseFileH-412">  bool mkdir(SdBaseFile& dir, const char* path) {  // NOLINT</front>
<front id="SdBaseFileH-413">    return mkdir(&dir, path);</front>
<front id="SdBaseFileH-414">  }</front>
<front id="SdBaseFileH-415">  /** \deprecated Use:</front>
<front id="SdBaseFileH-416">   * bool open(SdBaseFile* dirFile, const char* path, uint8_t oflag);</front>
<front id="SdBaseFileH-417">   * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileH-418">   * file to be opened.</front>
<front id="SdBaseFileH-419">   * \param[in] path A path with a valid 8.3 DOS name for the file.</front>
<front id="SdBaseFileH-420">   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileH-421">   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileH-422">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-423">   */</front>
<front id="SdBaseFileH-424">  bool open(SdBaseFile& dirFile, // NOLINT</front>
<front id="SdBaseFileH-425">    const char* path, uint8_t oflag) {</front>
<front id="SdBaseFileH-426">    return open(&dirFile, path, oflag);</front>
<front id="SdBaseFileH-427">  }</front>
<front id="SdBaseFileH-428">  /** \deprecated  Do not use in new apps</front>
<front id="SdBaseFileH-429">   * \param[in] dirFile An open SdFat instance for the directory containing the</front>
<front id="SdBaseFileH-430">   * file to be opened.</front>
<front id="SdBaseFileH-431">   * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdBaseFileH-432">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-433">   */</front>
<front id="SdBaseFileH-434">  bool open(SdBaseFile& dirFile, const char* path) {  // NOLINT</front>
<front id="SdBaseFileH-435">    return open(dirFile, path, O_RDWR);</front>
<front id="SdBaseFileH-436">  }</front>
<front id="SdBaseFileH-437">  /** \deprecated Use:</front>
<front id="SdBaseFileH-438">   * bool open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag);</front>
<front id="SdBaseFileH-439">   * \param[in] dirFile An open SdFat instance for the directory.</front>
<front id="SdBaseFileH-440">   * \param[in] index The \a index of the directory entry for the file to be</front>
<front id="SdBaseFileH-441">   * opened.  The value for \a index is (directory file position)/32.</front>
<front id="SdBaseFileH-442">   * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdBaseFileH-443">   * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.</front>
<front id="SdBaseFileH-444">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-445">   */</front>
<front id="SdBaseFileH-446">  bool open(SdBaseFile& dirFile, uint16_t index, uint8_t oflag) {  // NOLINT</front>
<front id="SdBaseFileH-447">    return open(&dirFile, index, oflag);</front>
<front id="SdBaseFileH-448">  }</front>
<front id="SdBaseFileH-449">  /** \deprecated Use: bool openRoot(SdVolume* vol);</front>
<front id="SdBaseFileH-450">   * \param[in] vol The FAT volume containing the root directory to be opened.</front>
<front id="SdBaseFileH-451">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-452">   */</front>
<front id="SdBaseFileH-453">  bool openRoot(SdVolume& vol) {return openRoot(&vol);}  // NOLINT</front>
<front id="SdBaseFileH-454">  /** \deprecated Use: int8_t readDir(dir_t* dir);</front>
<front id="SdBaseFileH-455">   * \param[out] dir The dir_t struct that will receive the data.</front>
<front id="SdBaseFileH-456">   * \return bytes read for success zero for eof or -1 for failure.</front>
<front id="SdBaseFileH-457">   */</front>
<front id="SdBaseFileH-458">  int8_t readDir(dir_t& dir, char* longFilename) {return readDir(&dir, longFilename);}  // NOLINT</front>
<front id="SdBaseFileH-459">  /** \deprecated Use:</front>
<front id="SdBaseFileH-460">   * static uint8_t remove(SdBaseFile* dirFile, const char* path);</front>
<front id="SdBaseFileH-461">   * \param[in] dirFile The directory that contains the file.</front>
<front id="SdBaseFileH-462">   * \param[in] path The name of the file to be removed.</front>
<front id="SdBaseFileH-463">   * \return true for success or false for failure.</front>
<front id="SdBaseFileH-464">   */</front>
<front id="SdBaseFileH-465">  static bool remove(SdBaseFile& dirFile, const char* path) {  // NOLINT</front>
<front id="SdBaseFileH-466">    return remove(&dirFile, path);</front>
<front id="SdBaseFileH-467">  }</front>
<front id="SdBaseFileH-468">//------------------------------------------------------------------------------</front>
<front id="SdBaseFileH-469">// rest are private</front>
<front id="SdBaseFileH-470"> private:</front>
<front id="SdBaseFileH-471">  static void (*oldDateTime_)(uint16_t& date, uint16_t& time);  // NOLINT</front>
<front id="SdBaseFileH-472">  static void oldToNew(uint16_t* date, uint16_t* time) {</front>
<front id="SdBaseFileH-473">    uint16_t d;</front>
<front id="SdBaseFileH-474">    uint16_t t;</front>
<front id="SdBaseFileH-475">    oldDateTime_(d, t);</front>
<front id="SdBaseFileH-476">    *date = d;</front>
<front id="SdBaseFileH-477">    *time = t;</front>
<front id="SdBaseFileH-478">  }</front>
<front id="SdBaseFileH-479">#endif  // ALLOW_DEPRECATED_FUNCTIONS</front>
<front id="SdBaseFileH-480">};</front>
<front id="SdBaseFileH-481"></front>
<front id="SdBaseFileH-482">#endif  // SdBaseFile_h</front>
<front id="SdBaseFileH-483">#endif</front>
 </pre>
<h1 id="SdFatConfigHtitle" >SdFatConfig.h</h1>
<pre id="SdFatConfigH"  class="prettyprint linenums"><front id="SdFatConfigH-1">/* Arduino SdFat Library</front>
<front id="SdFatConfigH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFatConfigH-3"> *</front>
<front id="SdFatConfigH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatConfigH-5"> *</front>
<front id="SdFatConfigH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatConfigH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatConfigH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatConfigH-9"> * (at your option) any later version.</front>
<front id="SdFatConfigH-10"> *</front>
<front id="SdFatConfigH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatConfigH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatConfigH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatConfigH-14"> * GNU General Public License for more details.</front>
<front id="SdFatConfigH-15"> *</front>
<front id="SdFatConfigH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatConfigH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatConfigH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatConfigH-19"> */</front>
<front id="SdFatConfigH-20">/**</front>
<front id="SdFatConfigH-21"> * \file</front>
<front id="SdFatConfigH-22"> * \brief configuration definitions</front>
<front id="SdFatConfigH-23"> */</front>
<front id="SdFatConfigH-24">#include "Marlin.h"</front>
<front id="SdFatConfigH-25">#if ENABLED(SDSUPPORT)</front>
<front id="SdFatConfigH-26"></front>
<front id="SdFatConfigH-27">#ifndef SdFatConfig_h</front>
<front id="SdFatConfigH-28">#define SdFatConfig_h</front>
<front id="SdFatConfigH-29">#include &lt;stdint.h&gt;</front>
<front id="SdFatConfigH-30">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-31">/**</front>
<front id="SdFatConfigH-32"> * To use multiple SD cards set USE_MULTIPLE_CARDS nonzero.</front>
<front id="SdFatConfigH-33"> *</front>
<front id="SdFatConfigH-34"> * Using multiple cards costs 400 - 500  bytes of flash.</front>
<front id="SdFatConfigH-35"> *</front>
<front id="SdFatConfigH-36"> * Each card requires about 550 bytes of SRAM so use of a Mega is recommended.</front>
<front id="SdFatConfigH-37"> */</front>
<front id="SdFatConfigH-38">#define USE_MULTIPLE_CARDS 0</front>
<front id="SdFatConfigH-39">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-40">/**</front>
<front id="SdFatConfigH-41"> * Call flush for endl if ENDL_CALLS_FLUSH is nonzero</front>
<front id="SdFatConfigH-42"> *</front>
<front id="SdFatConfigH-43"> * The standard for iostreams is to call flush.  This is very costly for</front>
<front id="SdFatConfigH-44"> * SdFat.  Each call to flush causes 2048 bytes of I/O to the SD.</front>
<front id="SdFatConfigH-45"> *</front>
<front id="SdFatConfigH-46"> * SdFat has a single 512 byte buffer for SD I/O so it must write the current</front>
<front id="SdFatConfigH-47"> * data block to the SD, read the directory block from the SD, update the</front>
<front id="SdFatConfigH-48"> * directory entry, write the directory block to the SD and read the data</front>
<front id="SdFatConfigH-49"> * block back into the buffer.</front>
<front id="SdFatConfigH-50"> *</front>
<front id="SdFatConfigH-51"> * The SD flash memory controller is not designed for this many rewrites</front>
<front id="SdFatConfigH-52"> * so performance may be reduced by more than a factor of 100.</front>
<front id="SdFatConfigH-53"> *</front>
<front id="SdFatConfigH-54"> * If ENDL_CALLS_FLUSH is zero, you must call flush and/or close to force</front>
<front id="SdFatConfigH-55"> * all data to be written to the SD.</front>
<front id="SdFatConfigH-56"> */</front>
<front id="SdFatConfigH-57">#define ENDL_CALLS_FLUSH 0</front>
<front id="SdFatConfigH-58">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-59">/**</front>
<front id="SdFatConfigH-60"> * Allow use of deprecated functions if ALLOW_DEPRECATED_FUNCTIONS is nonzero</front>
<front id="SdFatConfigH-61"> */</front>
<front id="SdFatConfigH-62">#define ALLOW_DEPRECATED_FUNCTIONS 1</front>
<front id="SdFatConfigH-63">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-64">/**</front>
<front id="SdFatConfigH-65"> * Allow FAT12 volumes if FAT12_SUPPORT is nonzero.</front>
<front id="SdFatConfigH-66"> * FAT12 has not been well tested.</front>
<front id="SdFatConfigH-67"> */</front>
<front id="SdFatConfigH-68">#define FAT12_SUPPORT 0</front>
<front id="SdFatConfigH-69">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-70">/**</front>
<front id="SdFatConfigH-71"> * SPI init rate for SD initialization commands. Must be 5 (F_CPU/64)</front>
<front id="SdFatConfigH-72"> * or 6 (F_CPU/128).</front>
<front id="SdFatConfigH-73"> */</front>
<front id="SdFatConfigH-74">#define SPI_SD_INIT_RATE 5</front>
<front id="SdFatConfigH-75">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-76">/**</front>
<front id="SdFatConfigH-77"> * Set the SS pin high for hardware SPI.  If SS is chip select for another SPI</front>
<front id="SdFatConfigH-78"> * device this will disable that device during the SD init phase.</front>
<front id="SdFatConfigH-79"> */</front>
<front id="SdFatConfigH-80">#define SET_SPI_SS_HIGH 1</front>
<front id="SdFatConfigH-81">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-82">/**</front>
<front id="SdFatConfigH-83"> * Define MEGA_SOFT_SPI nonzero to use software SPI on Mega Arduinos.</front>
<front id="SdFatConfigH-84"> * Pins used are SS 10, MOSI 11, MISO 12, and SCK 13.</front>
<front id="SdFatConfigH-85"> *</front>
<front id="SdFatConfigH-86"> * MEGA_SOFT_SPI allows an unmodified Adafruit GPS Shield to be used</front>
<front id="SdFatConfigH-87"> * on Mega Arduinos.  Software SPI works well with GPS Shield V1.1</front>
<front id="SdFatConfigH-88"> * but many SD cards will fail with GPS Shield V1.0.</front>
<front id="SdFatConfigH-89"> */</front>
<front id="SdFatConfigH-90">#define MEGA_SOFT_SPI 0</front>
<front id="SdFatConfigH-91">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-92">/**</front>
<front id="SdFatConfigH-93"> * Set USE_SOFTWARE_SPI nonzero to always use software SPI.</front>
<front id="SdFatConfigH-94"> */</front>
<front id="SdFatConfigH-95">#define USE_SOFTWARE_SPI 0</front>
<front id="SdFatConfigH-96">// define software SPI pins so Mega can use unmodified 168/328 shields</front>
<front id="SdFatConfigH-97">/** Software SPI chip select pin for the SD */</front>
<front id="SdFatConfigH-98">uint8_t const SOFT_SPI_CS_PIN = 10;</front>
<front id="SdFatConfigH-99">/** Software SPI Master Out Slave In pin */</front>
<front id="SdFatConfigH-100">uint8_t const SOFT_SPI_MOSI_PIN = 11;</front>
<front id="SdFatConfigH-101">/** Software SPI Master In Slave Out pin */</front>
<front id="SdFatConfigH-102">uint8_t const SOFT_SPI_MISO_PIN = 12;</front>
<front id="SdFatConfigH-103">/** Software SPI Clock pin */</front>
<front id="SdFatConfigH-104">uint8_t const SOFT_SPI_SCK_PIN = 13;</front>
<front id="SdFatConfigH-105">//------------------------------------------------------------------------------</front>
<front id="SdFatConfigH-106">/**</front>
<front id="SdFatConfigH-107"> * The __cxa_pure_virtual function is an error handler that is invoked when</front>
<front id="SdFatConfigH-108"> * a pure virtual function is called.</front>
<front id="SdFatConfigH-109"> */</front>
<front id="SdFatConfigH-110">#define USE_CXA_PURE_VIRTUAL 1</front>
<front id="SdFatConfigH-111"></front>
<front id="SdFatConfigH-112">/** Number of UTF-16 characters per entry */</front>
<front id="SdFatConfigH-113">#define FILENAME_LENGTH 13</front>
<front id="SdFatConfigH-114"></front>
<front id="SdFatConfigH-115">/**</front>
<front id="SdFatConfigH-116"> * Defines for long (vfat) filenames</front>
<front id="SdFatConfigH-117"> */</front>
<front id="SdFatConfigH-118">/** Number of VFAT entries used. Every entry has 13 UTF-16 characters */</front>
<front id="SdFatConfigH-119">#define MAX_VFAT_ENTRIES (2)</front>
<front id="SdFatConfigH-120">/** Total size of the buffer used to store the long filenames */</front>
<front id="SdFatConfigH-121">#define LONG_FILENAME_LENGTH (FILENAME_LENGTH*MAX_VFAT_ENTRIES+1)</front>
<front id="SdFatConfigH-122">#endif  // SdFatConfig_h</front>
<front id="SdFatConfigH-123"></front>
<front id="SdFatConfigH-124"></front>
<front id="SdFatConfigH-125">#endif</front>
 </pre>
<h1 id="SdFatStructsHtitle" >SdFatStructs.h</h1>
<pre id="SdFatStructsH"  class="prettyprint linenums"><front id="SdFatStructsH-1">/* Arduino SdFat Library</front>
<front id="SdFatStructsH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFatStructsH-3"> *</front>
<front id="SdFatStructsH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatStructsH-5"> *</front>
<front id="SdFatStructsH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatStructsH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatStructsH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatStructsH-9"> * (at your option) any later version.</front>
<front id="SdFatStructsH-10"> *</front>
<front id="SdFatStructsH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatStructsH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatStructsH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatStructsH-14"> * GNU General Public License for more details.</front>
<front id="SdFatStructsH-15"> *</front>
<front id="SdFatStructsH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatStructsH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatStructsH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatStructsH-19"> */</front>
<front id="SdFatStructsH-20">#include "Marlin.h"</front>
<front id="SdFatStructsH-21">#if ENABLED(SDSUPPORT)</front>
<front id="SdFatStructsH-22"></front>
<front id="SdFatStructsH-23">#ifndef SdFatStructs_h</front>
<front id="SdFatStructsH-24">#define SdFatStructs_h</front>
<front id="SdFatStructsH-25"></front>
<front id="SdFatStructsH-26">#define PACKED __attribute__((__packed__))</front>
<front id="SdFatStructsH-27">/**</front>
<front id="SdFatStructsH-28"> * \file</front>
<front id="SdFatStructsH-29"> * \brief FAT file structures</front>
<front id="SdFatStructsH-30"> */</front>
<front id="SdFatStructsH-31">/*</front>
<front id="SdFatStructsH-32"> * mostly from Microsoft document fatgen103.doc</front>
<front id="SdFatStructsH-33"> * http://www.microsoft.com/whdc/system/platform/firmware/fatgen.mspx</front>
<front id="SdFatStructsH-34"> */</front>
<front id="SdFatStructsH-35">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-36">/** Value for byte 510 of boot block or MBR */</front>
<front id="SdFatStructsH-37">uint8_t const BOOTSIG0 = 0X55;</front>
<front id="SdFatStructsH-38">/** Value for byte 511 of boot block or MBR */</front>
<front id="SdFatStructsH-39">uint8_t const BOOTSIG1 = 0XAA;</front>
<front id="SdFatStructsH-40">/** Value for bootSignature field int FAT/FAT32 boot sector */</front>
<front id="SdFatStructsH-41">uint8_t const EXTENDED_BOOT_SIG = 0X29;</front>
<front id="SdFatStructsH-42">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-43">/**</front>
<front id="SdFatStructsH-44"> * \struct partitionTable</front>
<front id="SdFatStructsH-45"> * \brief MBR partition table entry</front>
<front id="SdFatStructsH-46"> *</front>
<front id="SdFatStructsH-47"> * A partition table entry for a MBR formatted storage device.</front>
<front id="SdFatStructsH-48"> * The MBR partition table has four entries.</front>
<front id="SdFatStructsH-49"> */</front>
<front id="SdFatStructsH-50">struct partitionTable {</front>
<front id="SdFatStructsH-51">          /**</front>
<front id="SdFatStructsH-52">           * Boot Indicator . Indicates whether the volume is the active</front>
<front id="SdFatStructsH-53">           * partition.  Legal values include: 0X00. Do not use for booting.</front>
<front id="SdFatStructsH-54">           * 0X80 Active partition.</front>
<front id="SdFatStructsH-55">           */</front>
<front id="SdFatStructsH-56">  uint8_t  boot;</front>
<front id="SdFatStructsH-57">          /**</front>
<front id="SdFatStructsH-58">            * Head part of Cylinder-head-sector address of the first block in</front>
<front id="SdFatStructsH-59">            * the partition. Legal values are 0-255. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-60">            */</front>
<front id="SdFatStructsH-61">  uint8_t  beginHead;</front>
<front id="SdFatStructsH-62">          /**</front>
<front id="SdFatStructsH-63">           * Sector part of Cylinder-head-sector address of the first block in</front>
<front id="SdFatStructsH-64">           * the partition. Legal values are 1-63. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-65">           */</front>
<front id="SdFatStructsH-66">  unsigned beginSector : 6;</front>
<front id="SdFatStructsH-67">           /** High bits cylinder for first block in partition. */</front>
<front id="SdFatStructsH-68">  unsigned beginCylinderHigh : 2;</front>
<front id="SdFatStructsH-69">          /**</front>
<front id="SdFatStructsH-70">           * Combine beginCylinderLow with beginCylinderHigh. Legal values</front>
<front id="SdFatStructsH-71">           * are 0-1023.  Only used in old PC BIOS.</front>
<front id="SdFatStructsH-72">           */</front>
<front id="SdFatStructsH-73">  uint8_t  beginCylinderLow;</front>
<front id="SdFatStructsH-74">          /**</front>
<front id="SdFatStructsH-75">           * Partition type. See defines that begin with PART_TYPE_ for</front>
<front id="SdFatStructsH-76">           * some Microsoft partition types.</front>
<front id="SdFatStructsH-77">           */</front>
<front id="SdFatStructsH-78">  uint8_t  type;</front>
<front id="SdFatStructsH-79">          /**</front>
<front id="SdFatStructsH-80">           * head part of cylinder-head-sector address of the last sector in the</front>
<front id="SdFatStructsH-81">           * partition.  Legal values are 0-255. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-82">           */</front>
<front id="SdFatStructsH-83">  uint8_t  endHead;</front>
<front id="SdFatStructsH-84">          /**</front>
<front id="SdFatStructsH-85">           * Sector part of cylinder-head-sector address of the last sector in</front>
<front id="SdFatStructsH-86">           * the partition.  Legal values are 1-63. Only used in old PC BIOS.</front>
<front id="SdFatStructsH-87">           */</front>
<front id="SdFatStructsH-88">  unsigned endSector : 6;</front>
<front id="SdFatStructsH-89">           /** High bits of end cylinder */</front>
<front id="SdFatStructsH-90">  unsigned endCylinderHigh : 2;</front>
<front id="SdFatStructsH-91">          /**</front>
<front id="SdFatStructsH-92">           * Combine endCylinderLow with endCylinderHigh. Legal values</front>
<front id="SdFatStructsH-93">           * are 0-1023.  Only used in old PC BIOS.</front>
<front id="SdFatStructsH-94">           */</front>
<front id="SdFatStructsH-95">  uint8_t  endCylinderLow;</front>
<front id="SdFatStructsH-96">           /** Logical block address of the first block in the partition. */</front>
<front id="SdFatStructsH-97">  uint32_t firstSector;</front>
<front id="SdFatStructsH-98">           /** Length of the partition, in blocks. */</front>
<front id="SdFatStructsH-99">  uint32_t totalSectors;</front>
<front id="SdFatStructsH-100">} PACKED;</front>
<front id="SdFatStructsH-101">/** Type name for partitionTable */</front>
<front id="SdFatStructsH-102">typedef struct partitionTable part_t;</front>
<front id="SdFatStructsH-103">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-104">/**</front>
<front id="SdFatStructsH-105"> * \struct masterBootRecord</front>
<front id="SdFatStructsH-106"> *</front>
<front id="SdFatStructsH-107"> * \brief Master Boot Record</front>
<front id="SdFatStructsH-108"> *</front>
<front id="SdFatStructsH-109"> * The first block of a storage device that is formatted with a MBR.</front>
<front id="SdFatStructsH-110"> */</front>
<front id="SdFatStructsH-111">struct masterBootRecord {</front>
<front id="SdFatStructsH-112">           /** Code Area for master boot program. */</front>
<front id="SdFatStructsH-113">  uint8_t  codeArea[440];</front>
<front id="SdFatStructsH-114">           /** Optional Windows NT disk signature. May contain boot code. */</front>
<front id="SdFatStructsH-115">  uint32_t diskSignature;</front>
<front id="SdFatStructsH-116">           /** Usually zero but may be more boot code. */</front>
<front id="SdFatStructsH-117">  uint16_t usuallyZero;</front>
<front id="SdFatStructsH-118">           /** Partition tables. */</front>
<front id="SdFatStructsH-119">  part_t   part[4];</front>
<front id="SdFatStructsH-120">           /** First MBR signature byte. Must be 0X55 */</front>
<front id="SdFatStructsH-121">  uint8_t  mbrSig0;</front>
<front id="SdFatStructsH-122">           /** Second MBR signature byte. Must be 0XAA */</front>
<front id="SdFatStructsH-123">  uint8_t  mbrSig1;</front>
<front id="SdFatStructsH-124">} PACKED;</front>
<front id="SdFatStructsH-125">/** Type name for masterBootRecord */</front>
<front id="SdFatStructsH-126">typedef struct masterBootRecord mbr_t;</front>
<front id="SdFatStructsH-127">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-128">/**</front>
<front id="SdFatStructsH-129"> * \struct fat_boot</front>
<front id="SdFatStructsH-130"> *</front>
<front id="SdFatStructsH-131"> * \brief Boot sector for a FAT12/FAT16 volume.</front>
<front id="SdFatStructsH-132"> *</front>
<front id="SdFatStructsH-133"> */</front>
<front id="SdFatStructsH-134">struct fat_boot {</front>
<front id="SdFatStructsH-135">         /**</front>
<front id="SdFatStructsH-136">          * The first three bytes of the boot sector must be valid,</front>
<front id="SdFatStructsH-137">          * executable x 86-based CPU instructions. This includes a</front>
<front id="SdFatStructsH-138">          * jump instruction that skips the next nonexecutable bytes.</front>
<front id="SdFatStructsH-139">          */</front>
<front id="SdFatStructsH-140">  uint8_t jump[3];</front>
<front id="SdFatStructsH-141">         /**</front>
<front id="SdFatStructsH-142">          * This is typically a string of characters that identifies</front>
<front id="SdFatStructsH-143">          * the operating system that formatted the volume.</front>
<front id="SdFatStructsH-144">          */</front>
<front id="SdFatStructsH-145">  char    oemId[8];</front>
<front id="SdFatStructsH-146">          /**</front>
<front id="SdFatStructsH-147">           * The size of a hardware sector. Valid decimal values for this</front>
<front id="SdFatStructsH-148">           * field are 512, 1024, 2048, and 4096. For most disks used in</front>
<front id="SdFatStructsH-149">           * the United States, the value of this field is 512.</front>
<front id="SdFatStructsH-150">           */</front>
<front id="SdFatStructsH-151">  uint16_t bytesPerSector;</front>
<front id="SdFatStructsH-152">          /**</front>
<front id="SdFatStructsH-153">           * Number of sectors per allocation unit. This value must be a</front>
<front id="SdFatStructsH-154">           * power of 2 that is greater than 0. The legal values are</front>
<front id="SdFatStructsH-155">           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.</front>
<front id="SdFatStructsH-156">           */</front>
<front id="SdFatStructsH-157">  uint8_t  sectorsPerCluster;</front>
<front id="SdFatStructsH-158">          /**</front>
<front id="SdFatStructsH-159">           * The number of sectors preceding the start of the first FAT,</front>
<front id="SdFatStructsH-160">           * including the boot sector. The value of this field is always 1.</front>
<front id="SdFatStructsH-161">           */</front>
<front id="SdFatStructsH-162">  uint16_t reservedSectorCount;</front>
<front id="SdFatStructsH-163">          /**</front>
<front id="SdFatStructsH-164">           * The number of copies of the FAT on the volume.</front>
<front id="SdFatStructsH-165">           * The value of this field is always 2.</front>
<front id="SdFatStructsH-166">           */</front>
<front id="SdFatStructsH-167">  uint8_t  fatCount;</front>
<front id="SdFatStructsH-168">          /**</front>
<front id="SdFatStructsH-169">           * For FAT12 and FAT16 volumes, this field contains the count of</front>
<front id="SdFatStructsH-170">           * 32-byte directory entries in the root directory. For FAT32 volumes,</front>
<front id="SdFatStructsH-171">           * this field must be set to 0. For FAT12 and FAT16 volumes, this</front>
<front id="SdFatStructsH-172">           * value should always specify a count that when multiplied by 32</front>
<front id="SdFatStructsH-173">           * results in a multiple of bytesPerSector.  FAT16 volumes should</front>
<front id="SdFatStructsH-174">           * use the value 512.</front>
<front id="SdFatStructsH-175">           */</front>
<front id="SdFatStructsH-176">  uint16_t rootDirEntryCount;</front>
<front id="SdFatStructsH-177">          /**</front>
<front id="SdFatStructsH-178">           * This field is the old 16-bit total count of sectors on the volume.</front>
<front id="SdFatStructsH-179">           * This count includes the count of all sectors in all four regions</front>
<front id="SdFatStructsH-180">           * of the volume. This field can be 0; if it is 0, then totalSectors32</front>
<front id="SdFatStructsH-181">           * must be nonzero.  For FAT32 volumes, this field must be 0. For</front>
<front id="SdFatStructsH-182">           * FAT12 and FAT16 volumes, this field contains the sector count, and</front>
<front id="SdFatStructsH-183">           * totalSectors32 is 0 if the total sector count fits</front>
<front id="SdFatStructsH-184">           * (is less than 0x10000).</front>
<front id="SdFatStructsH-185">           */</front>
<front id="SdFatStructsH-186">  uint16_t totalSectors16;</front>
<front id="SdFatStructsH-187">          /**</front>
<front id="SdFatStructsH-188">           * This dates back to the old MS-DOS 1.x media determination and is</front>
<front id="SdFatStructsH-189">           * no longer usually used for anything.  0xF8 is the standard value</front>
<front id="SdFatStructsH-190">           * for fixed (nonremovable) media. For removable media, 0xF0 is</front>
<front id="SdFatStructsH-191">           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.</front>
<front id="SdFatStructsH-192">           */</front>
<front id="SdFatStructsH-193">  uint8_t  mediaType;</front>
<front id="SdFatStructsH-194">          /**</front>
<front id="SdFatStructsH-195">           * Count of sectors occupied by one FAT on FAT12/FAT16 volumes.</front>
<front id="SdFatStructsH-196">           * On FAT32 volumes this field must be 0, and sectorsPerFat32</front>
<front id="SdFatStructsH-197">           * contains the FAT size count.</front>
<front id="SdFatStructsH-198">           */</front>
<front id="SdFatStructsH-199">  uint16_t sectorsPerFat16;</front>
<front id="SdFatStructsH-200">           /** Sectors per track for interrupt 0x13. Not used otherwise. */</front>
<front id="SdFatStructsH-201">  uint16_t sectorsPerTrack;</front>
<front id="SdFatStructsH-202">           /** Number of heads for interrupt 0x13.  Not used otherwise. */</front>
<front id="SdFatStructsH-203">  uint16_t headCount;</front>
<front id="SdFatStructsH-204">          /**</front>
<front id="SdFatStructsH-205">           * Count of hidden sectors preceding the partition that contains this</front>
<front id="SdFatStructsH-206">           * FAT volume. This field is generally only relevant for media</front>
<front id="SdFatStructsH-207">           * visible on interrupt 0x13.</front>
<front id="SdFatStructsH-208">           */</front>
<front id="SdFatStructsH-209">  uint32_t hidddenSectors;</front>
<front id="SdFatStructsH-210">          /**</front>
<front id="SdFatStructsH-211">           * This field is the new 32-bit total count of sectors on the volume.</front>
<front id="SdFatStructsH-212">           * This count includes the count of all sectors in all four regions</front>
<front id="SdFatStructsH-213">           * of the volume.  This field can be 0; if it is 0, then</front>
<front id="SdFatStructsH-214">           * totalSectors16 must be nonzero.</front>
<front id="SdFatStructsH-215">           */</front>
<front id="SdFatStructsH-216">  uint32_t totalSectors32;</front>
<front id="SdFatStructsH-217">           /**</front>
<front id="SdFatStructsH-218">            * Related to the BIOS physical drive number. Floppy drives are</front>
<front id="SdFatStructsH-219">            * identified as 0x00 and physical hard disks are identified as</front>
<front id="SdFatStructsH-220">            * 0x80, regardless of the number of physical disk drives.</front>
<front id="SdFatStructsH-221">            * Typically, this value is set prior to issuing an INT 13h BIOS</front>
<front id="SdFatStructsH-222">            * call to specify the device to access. The value is only</front>
<front id="SdFatStructsH-223">            * relevant if the device is a boot device.</front>
<front id="SdFatStructsH-224">            */</front>
<front id="SdFatStructsH-225">  uint8_t  driveNumber;</front>
<front id="SdFatStructsH-226">           /** used by Windows NT - should be zero for FAT */</front>
<front id="SdFatStructsH-227">  uint8_t  reserved1;</front>
<front id="SdFatStructsH-228">           /** 0X29 if next three fields are valid */</front>
<front id="SdFatStructsH-229">  uint8_t  bootSignature;</front>
<front id="SdFatStructsH-230">           /**</front>
<front id="SdFatStructsH-231">            * A random serial number created when formatting a disk,</front>
<front id="SdFatStructsH-232">            * which helps to distinguish between disks.</front>
<front id="SdFatStructsH-233">            * Usually generated by combining date and time.</front>
<front id="SdFatStructsH-234">            */</front>
<front id="SdFatStructsH-235">  uint32_t volumeSerialNumber;</front>
<front id="SdFatStructsH-236">           /**</front>
<front id="SdFatStructsH-237">            * A field once used to store the volume label. The volume label</front>
<front id="SdFatStructsH-238">            * is now stored as a special file in the root directory.</front>
<front id="SdFatStructsH-239">            */</front>
<front id="SdFatStructsH-240">  char     volumeLabel[11];</front>
<front id="SdFatStructsH-241">           /**</front>
<front id="SdFatStructsH-242">            * A field with a value of either FAT, FAT12 or FAT16,</front>
<front id="SdFatStructsH-243">            * depending on the disk format.</front>
<front id="SdFatStructsH-244">            */</front>
<front id="SdFatStructsH-245">  char     fileSystemType[8];</front>
<front id="SdFatStructsH-246">           /** X86 boot code */</front>
<front id="SdFatStructsH-247">  uint8_t  bootCode[448];</front>
<front id="SdFatStructsH-248">           /** must be 0X55 */</front>
<front id="SdFatStructsH-249">  uint8_t  bootSectorSig0;</front>
<front id="SdFatStructsH-250">           /** must be 0XAA */</front>
<front id="SdFatStructsH-251">  uint8_t  bootSectorSig1;</front>
<front id="SdFatStructsH-252">} PACKED;</front>
<front id="SdFatStructsH-253">/** Type name for FAT Boot Sector */</front>
<front id="SdFatStructsH-254">typedef struct fat_boot fat_boot_t;</front>
<front id="SdFatStructsH-255">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-256">/**</front>
<front id="SdFatStructsH-257"> * \struct fat32_boot</front>
<front id="SdFatStructsH-258"> *</front>
<front id="SdFatStructsH-259"> * \brief Boot sector for a FAT32 volume.</front>
<front id="SdFatStructsH-260"> *</front>
<front id="SdFatStructsH-261"> */</front>
<front id="SdFatStructsH-262">struct fat32_boot {</front>
<front id="SdFatStructsH-263">         /**</front>
<front id="SdFatStructsH-264">          * The first three bytes of the boot sector must be valid,</front>
<front id="SdFatStructsH-265">          * executable x 86-based CPU instructions. This includes a</front>
<front id="SdFatStructsH-266">          * jump instruction that skips the next nonexecutable bytes.</front>
<front id="SdFatStructsH-267">          */</front>
<front id="SdFatStructsH-268">  uint8_t jump[3];</front>
<front id="SdFatStructsH-269">         /**</front>
<front id="SdFatStructsH-270">          * This is typically a string of characters that identifies</front>
<front id="SdFatStructsH-271">          * the operating system that formatted the volume.</front>
<front id="SdFatStructsH-272">          */</front>
<front id="SdFatStructsH-273">  char    oemId[8];</front>
<front id="SdFatStructsH-274">          /**</front>
<front id="SdFatStructsH-275">           * The size of a hardware sector. Valid decimal values for this</front>
<front id="SdFatStructsH-276">           * field are 512, 1024, 2048, and 4096. For most disks used in</front>
<front id="SdFatStructsH-277">           * the United States, the value of this field is 512.</front>
<front id="SdFatStructsH-278">           */</front>
<front id="SdFatStructsH-279">  uint16_t bytesPerSector;</front>
<front id="SdFatStructsH-280">          /**</front>
<front id="SdFatStructsH-281">           * Number of sectors per allocation unit. This value must be a</front>
<front id="SdFatStructsH-282">           * power of 2 that is greater than 0. The legal values are</front>
<front id="SdFatStructsH-283">           * 1, 2, 4, 8, 16, 32, 64, and 128.  128 should be avoided.</front>
<front id="SdFatStructsH-284">           */</front>
<front id="SdFatStructsH-285">  uint8_t  sectorsPerCluster;</front>
<front id="SdFatStructsH-286">          /**</front>
<front id="SdFatStructsH-287">           * The number of sectors preceding the start of the first FAT,</front>
<front id="SdFatStructsH-288">           * including the boot sector. Must not be zero</front>
<front id="SdFatStructsH-289">           */</front>
<front id="SdFatStructsH-290">  uint16_t reservedSectorCount;</front>
<front id="SdFatStructsH-291">          /**</front>
<front id="SdFatStructsH-292">           * The number of copies of the FAT on the volume.</front>
<front id="SdFatStructsH-293">           * The value of this field is always 2.</front>
<front id="SdFatStructsH-294">           */</front>
<front id="SdFatStructsH-295">  uint8_t  fatCount;</front>
<front id="SdFatStructsH-296">          /**</front>
<front id="SdFatStructsH-297">           * FAT12/FAT16 only. For FAT32 volumes, this field must be set to 0.</front>
<front id="SdFatStructsH-298">           */</front>
<front id="SdFatStructsH-299">  uint16_t rootDirEntryCount;</front>
<front id="SdFatStructsH-300">          /**</front>
<front id="SdFatStructsH-301">           * For FAT32 volumes, this field must be 0.</front>
<front id="SdFatStructsH-302">           */</front>
<front id="SdFatStructsH-303">  uint16_t totalSectors16;</front>
<front id="SdFatStructsH-304">          /**</front>
<front id="SdFatStructsH-305">           * This dates back to the old MS-DOS 1.x media determination and is</front>
<front id="SdFatStructsH-306">           * no longer usually used for anything.  0xF8 is the standard value</front>
<front id="SdFatStructsH-307">           * for fixed (nonremovable) media. For removable media, 0xF0 is</front>
<front id="SdFatStructsH-308">           * frequently used. Legal values are 0xF0 or 0xF8-0xFF.</front>
<front id="SdFatStructsH-309">           */</front>
<front id="SdFatStructsH-310">  uint8_t  mediaType;</front>
<front id="SdFatStructsH-311">          /**</front>
<front id="SdFatStructsH-312">           * On FAT32 volumes this field must be 0, and sectorsPerFat32</front>
<front id="SdFatStructsH-313">           * contains the FAT size count.</front>
<front id="SdFatStructsH-314">           */</front>
<front id="SdFatStructsH-315">  uint16_t sectorsPerFat16;</front>
<front id="SdFatStructsH-316">           /** Sectors per track for interrupt 0x13. Not used otherwise. */</front>
<front id="SdFatStructsH-317">  uint16_t sectorsPerTrack;</front>
<front id="SdFatStructsH-318">           /** Number of heads for interrupt 0x13.  Not used otherwise. */</front>
<front id="SdFatStructsH-319">  uint16_t headCount;</front>
<front id="SdFatStructsH-320">          /**</front>
<front id="SdFatStructsH-321">           * Count of hidden sectors preceding the partition that contains this</front>
<front id="SdFatStructsH-322">           * FAT volume. This field is generally only relevant for media</front>
<front id="SdFatStructsH-323">           * visible on interrupt 0x13.</front>
<front id="SdFatStructsH-324">           */</front>
<front id="SdFatStructsH-325">  uint32_t hidddenSectors;</front>
<front id="SdFatStructsH-326">          /**</front>
<front id="SdFatStructsH-327">           * Contains the total number of sectors in the FAT32 volume.</front>
<front id="SdFatStructsH-328">           */</front>
<front id="SdFatStructsH-329">  uint32_t totalSectors32;</front>
<front id="SdFatStructsH-330">         /**</front>
<front id="SdFatStructsH-331">           * Count of sectors occupied by one FAT on FAT32 volumes.</front>
<front id="SdFatStructsH-332">           */</front>
<front id="SdFatStructsH-333">  uint32_t sectorsPerFat32;</front>
<front id="SdFatStructsH-334">          /**</front>
<front id="SdFatStructsH-335">           * This field is only defined for FAT32 media and does not exist on</front>
<front id="SdFatStructsH-336">           * FAT12 and FAT16 media.</front>
<front id="SdFatStructsH-337">           * Bits 0-3 -- Zero-based number of active FAT.</front>
<front id="SdFatStructsH-338">           *             Only valid if mirroring is disabled.</front>
<front id="SdFatStructsH-339">           * Bits 4-6 -- Reserved.</front>
<front id="SdFatStructsH-340">           * Bit 7	-- 0 means the FAT is mirrored at runtime into all FATs.</front>
<front id="SdFatStructsH-341">	         *        -- 1 means only one FAT is active; it is the one referenced</front>
<front id="SdFatStructsH-342">	         *             in bits 0-3.</front>
<front id="SdFatStructsH-343">           * Bits 8-15 	-- Reserved.</front>
<front id="SdFatStructsH-344">           */</front>
<front id="SdFatStructsH-345">  uint16_t fat32Flags;</front>
<front id="SdFatStructsH-346">          /**</front>
<front id="SdFatStructsH-347">           * FAT32 version. High byte is major revision number.</front>
<front id="SdFatStructsH-348">           * Low byte is minor revision number. Only 0.0 define.</front>
<front id="SdFatStructsH-349">           */</front>
<front id="SdFatStructsH-350">  uint16_t fat32Version;</front>
<front id="SdFatStructsH-351">          /**</front>
<front id="SdFatStructsH-352">           * Cluster number of the first cluster of the root directory for FAT32.</front>
<front id="SdFatStructsH-353">           * This usually 2 but not required to be 2.</front>
<front id="SdFatStructsH-354">           */</front>
<front id="SdFatStructsH-355">  uint32_t fat32RootCluster;</front>
<front id="SdFatStructsH-356">          /**</front>
<front id="SdFatStructsH-357">           * Sector number of FSINFO structure in the reserved area of the</front>
<front id="SdFatStructsH-358">           * FAT32 volume. Usually 1.</front>
<front id="SdFatStructsH-359">           */</front>
<front id="SdFatStructsH-360">  uint16_t fat32FSInfo;</front>
<front id="SdFatStructsH-361">          /**</front>
<front id="SdFatStructsH-362">           * If nonzero, indicates the sector number in the reserved area</front>
<front id="SdFatStructsH-363">           * of the volume of a copy of the boot record. Usually 6.</front>
<front id="SdFatStructsH-364">           * No value other than 6 is recommended.</front>
<front id="SdFatStructsH-365">           */</front>
<front id="SdFatStructsH-366">  uint16_t fat32BackBootBlock;</front>
<front id="SdFatStructsH-367">          /**</front>
<front id="SdFatStructsH-368">           * Reserved for future expansion. Code that formats FAT32 volumes</front>
<front id="SdFatStructsH-369">           * should always set all of the bytes of this field to 0.</front>
<front id="SdFatStructsH-370">           */</front>
<front id="SdFatStructsH-371">  uint8_t  fat32Reserved[12];</front>
<front id="SdFatStructsH-372">           /**</front>
<front id="SdFatStructsH-373">            * Related to the BIOS physical drive number. Floppy drives are</front>
<front id="SdFatStructsH-374">            * identified as 0x00 and physical hard disks are identified as</front>
<front id="SdFatStructsH-375">            * 0x80, regardless of the number of physical disk drives.</front>
<front id="SdFatStructsH-376">            * Typically, this value is set prior to issuing an INT 13h BIOS</front>
<front id="SdFatStructsH-377">            * call to specify the device to access. The value is only</front>
<front id="SdFatStructsH-378">            * relevant if the device is a boot device.</front>
<front id="SdFatStructsH-379">            */</front>
<front id="SdFatStructsH-380">  uint8_t  driveNumber;</front>
<front id="SdFatStructsH-381">           /** used by Windows NT - should be zero for FAT */</front>
<front id="SdFatStructsH-382">  uint8_t  reserved1;</front>
<front id="SdFatStructsH-383">           /** 0X29 if next three fields are valid */</front>
<front id="SdFatStructsH-384">  uint8_t  bootSignature;</front>
<front id="SdFatStructsH-385">           /**</front>
<front id="SdFatStructsH-386">            * A random serial number created when formatting a disk,</front>
<front id="SdFatStructsH-387">            * which helps to distinguish between disks.</front>
<front id="SdFatStructsH-388">            * Usually generated by combining date and time.</front>
<front id="SdFatStructsH-389">            */</front>
<front id="SdFatStructsH-390">  uint32_t volumeSerialNumber;</front>
<front id="SdFatStructsH-391">           /**</front>
<front id="SdFatStructsH-392">            * A field once used to store the volume label. The volume label</front>
<front id="SdFatStructsH-393">            * is now stored as a special file in the root directory.</front>
<front id="SdFatStructsH-394">            */</front>
<front id="SdFatStructsH-395">  char     volumeLabel[11];</front>
<front id="SdFatStructsH-396">           /**</front>
<front id="SdFatStructsH-397">            * A text field with a value of FAT32.</front>
<front id="SdFatStructsH-398">            */</front>
<front id="SdFatStructsH-399">  char     fileSystemType[8];</front>
<front id="SdFatStructsH-400">           /** X86 boot code */</front>
<front id="SdFatStructsH-401">  uint8_t  bootCode[420];</front>
<front id="SdFatStructsH-402">           /** must be 0X55 */</front>
<front id="SdFatStructsH-403">  uint8_t  bootSectorSig0;</front>
<front id="SdFatStructsH-404">           /** must be 0XAA */</front>
<front id="SdFatStructsH-405">  uint8_t  bootSectorSig1;</front>
<front id="SdFatStructsH-406">} PACKED;</front>
<front id="SdFatStructsH-407">/** Type name for FAT32 Boot Sector */</front>
<front id="SdFatStructsH-408">typedef struct fat32_boot fat32_boot_t;</front>
<front id="SdFatStructsH-409">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-410">/** Lead signature for a FSINFO sector */</front>
<front id="SdFatStructsH-411">uint32_t const FSINFO_LEAD_SIG = 0x41615252;</front>
<front id="SdFatStructsH-412">/** Struct signature for a FSINFO sector */</front>
<front id="SdFatStructsH-413">uint32_t const FSINFO_STRUCT_SIG = 0x61417272;</front>
<front id="SdFatStructsH-414">/**</front>
<front id="SdFatStructsH-415"> * \struct fat32_fsinfo</front>
<front id="SdFatStructsH-416"> *</front>
<front id="SdFatStructsH-417"> * \brief FSINFO sector for a FAT32 volume.</front>
<front id="SdFatStructsH-418"> *</front>
<front id="SdFatStructsH-419"> */</front>
<front id="SdFatStructsH-420">struct fat32_fsinfo {</front>
<front id="SdFatStructsH-421">           /** must be 0X52, 0X52, 0X61, 0X41 */</front>
<front id="SdFatStructsH-422">  uint32_t  leadSignature;</front>
<front id="SdFatStructsH-423">           /** must be zero */</front>
<front id="SdFatStructsH-424">  uint8_t  reserved1[480];</front>
<front id="SdFatStructsH-425">           /** must be 0X72, 0X72, 0X41, 0X61 */</front>
<front id="SdFatStructsH-426">  uint32_t  structSignature;</front>
<front id="SdFatStructsH-427">          /**</front>
<front id="SdFatStructsH-428">           * Contains the last known free cluster count on the volume.</front>
<front id="SdFatStructsH-429">           * If the value is 0xFFFFFFFF, then the free count is unknown</front>
<front id="SdFatStructsH-430">           * and must be computed. Any other value can be used, but is</front>
<front id="SdFatStructsH-431">           * not necessarily correct. It should be range checked at least</front>
<front id="SdFatStructsH-432">           * to make sure it is &lt;= volume cluster count.</front>
<front id="SdFatStructsH-433">           */</front>
<front id="SdFatStructsH-434">  uint32_t freeCount;</front>
<front id="SdFatStructsH-435">          /**</front>
<front id="SdFatStructsH-436">           * This is a hint for the FAT driver. It indicates the cluster</front>
<front id="SdFatStructsH-437">           * number at which the driver should start looking for free clusters.</front>
<front id="SdFatStructsH-438">           * If the value is 0xFFFFFFFF, then there is no hint and the driver</front>
<front id="SdFatStructsH-439">           * should start looking at cluster 2.</front>
<front id="SdFatStructsH-440">           */</front>
<front id="SdFatStructsH-441">  uint32_t nextFree;</front>
<front id="SdFatStructsH-442">           /** must be zero */</front>
<front id="SdFatStructsH-443">  uint8_t  reserved2[12];</front>
<front id="SdFatStructsH-444">           /** must be 0X00, 0X00, 0X55, 0XAA */</front>
<front id="SdFatStructsH-445">  uint8_t  tailSignature[4];</front>
<front id="SdFatStructsH-446">} PACKED;</front>
<front id="SdFatStructsH-447">/** Type name for FAT32 FSINFO Sector */</front>
<front id="SdFatStructsH-448">typedef struct fat32_fsinfo fat32_fsinfo_t;</front>
<front id="SdFatStructsH-449">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-450">// End Of Chain values for FAT entries</front>
<front id="SdFatStructsH-451">/** FAT12 end of chain value used by Microsoft. */</front>
<front id="SdFatStructsH-452">uint16_t const FAT12EOC = 0XFFF;</front>
<front id="SdFatStructsH-453">/** Minimum value for FAT12 EOC.  Use to test for EOC. */</front>
<front id="SdFatStructsH-454">uint16_t const FAT12EOC_MIN = 0XFF8;</front>
<front id="SdFatStructsH-455">/** FAT16 end of chain value used by Microsoft. */</front>
<front id="SdFatStructsH-456">uint16_t const FAT16EOC = 0XFFFF;</front>
<front id="SdFatStructsH-457">/** Minimum value for FAT16 EOC.  Use to test for EOC. */</front>
<front id="SdFatStructsH-458">uint16_t const FAT16EOC_MIN = 0XFFF8;</front>
<front id="SdFatStructsH-459">/** FAT32 end of chain value used by Microsoft. */</front>
<front id="SdFatStructsH-460">uint32_t const FAT32EOC = 0X0FFFFFFF;</front>
<front id="SdFatStructsH-461">/** Minimum value for FAT32 EOC.  Use to test for EOC. */</front>
<front id="SdFatStructsH-462">uint32_t const FAT32EOC_MIN = 0X0FFFFFF8;</front>
<front id="SdFatStructsH-463">/** Mask a for FAT32 entry. Entries are 28 bits. */</front>
<front id="SdFatStructsH-464">uint32_t const FAT32MASK = 0X0FFFFFFF;</front>
<front id="SdFatStructsH-465">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-466">/**</front>
<front id="SdFatStructsH-467"> * \struct directoryEntry</front>
<front id="SdFatStructsH-468"> * \brief FAT short directory entry</front>
<front id="SdFatStructsH-469"> *</front>
<front id="SdFatStructsH-470"> * Short means short 8.3 name, not the entry size.</front>
<front id="SdFatStructsH-471"> *  </front>
<front id="SdFatStructsH-472"> * Date Format. A FAT directory entry date stamp is a 16-bit field that is </front>
<front id="SdFatStructsH-473"> * basically a date relative to the MS-DOS epoch of 01/01/1980. Here is the</front>
<front id="SdFatStructsH-474"> * format (bit 0 is the LSB of the 16-bit word, bit 15 is the MSB of the </front>
<front id="SdFatStructsH-475"> * 16-bit word):</front>
<front id="SdFatStructsH-476"> *   </front>
<front id="SdFatStructsH-477"> * Bits 9-15: Count of years from 1980, valid value range 0-127 </front>
<front id="SdFatStructsH-478"> * inclusive (1980-2107).</front>
<front id="SdFatStructsH-479"> *   </front>
<front id="SdFatStructsH-480"> * Bits 5-8: Month of year, 1 = January, valid value range 1-12 inclusive.</front>
<front id="SdFatStructsH-481"> *</front>
<front id="SdFatStructsH-482"> * Bits 0-4: Day of month, valid value range 1-31 inclusive.</front>
<front id="SdFatStructsH-483"> *</front>
<front id="SdFatStructsH-484"> * Time Format. A FAT directory entry time stamp is a 16-bit field that has</front>
<front id="SdFatStructsH-485"> * a granularity of 2 seconds. Here is the format (bit 0 is the LSB of the </front>
<front id="SdFatStructsH-486"> * 16-bit word, bit 15 is the MSB of the 16-bit word).</front>
<front id="SdFatStructsH-487"> *   </front>
<front id="SdFatStructsH-488"> * Bits 11-15: Hours, valid value range 0-23 inclusive.</front>
<front id="SdFatStructsH-489"> * </front>
<front id="SdFatStructsH-490"> * Bits 5-10: Minutes, valid value range 0-59 inclusive.</front>
<front id="SdFatStructsH-491"> *      </front>
<front id="SdFatStructsH-492"> * Bits 0-4: 2-second count, valid value range 0-29 inclusive (0 - 58 seconds).</front>
<front id="SdFatStructsH-493"> *   </front>
<front id="SdFatStructsH-494"> * The valid time range is from Midnight 00:00:00 to 23:59:58.</front>
<front id="SdFatStructsH-495"> */</front>
<front id="SdFatStructsH-496">struct directoryEntry {</front>
<front id="SdFatStructsH-497">           /** Short 8.3 name.</front>
<front id="SdFatStructsH-498">            *</front>
<front id="SdFatStructsH-499">            * The first eight bytes contain the file name with blank fill.</front>
<front id="SdFatStructsH-500">            * The last three bytes contain the file extension with blank fill.</front>
<front id="SdFatStructsH-501">            */</front>
<front id="SdFatStructsH-502">  uint8_t  name[11];</front>
<front id="SdFatStructsH-503">          /** Entry attributes.</front>
<front id="SdFatStructsH-504">           *</front>
<front id="SdFatStructsH-505">           * The upper two bits of the attribute byte are reserved and should</front>
<front id="SdFatStructsH-506">           * always be set to 0 when a file is created and never modified or</front>
<front id="SdFatStructsH-507">           * looked at after that.  See defines that begin with DIR_ATT_.</front>
<front id="SdFatStructsH-508">           */</front>
<front id="SdFatStructsH-509">  uint8_t  attributes;</front>
<front id="SdFatStructsH-510">          /**</front>
<front id="SdFatStructsH-511">           * Reserved for use by Windows NT. Set value to 0 when a file is</front>
<front id="SdFatStructsH-512">           * created and never modify or look at it after that.</front>
<front id="SdFatStructsH-513">           */</front>
<front id="SdFatStructsH-514">  uint8_t  reservedNT;</front>
<front id="SdFatStructsH-515">          /**</front>
<front id="SdFatStructsH-516">           * The granularity of the seconds part of creationTime is 2 seconds</front>
<front id="SdFatStructsH-517">           * so this field is a count of tenths of a second and its valid</front>
<front id="SdFatStructsH-518">           * value range is 0-199 inclusive. (WHG note - seems to be hundredths)</front>
<front id="SdFatStructsH-519">           */</front>
<front id="SdFatStructsH-520">  uint8_t  creationTimeTenths;</front>
<front id="SdFatStructsH-521">           /** Time file was created. */</front>
<front id="SdFatStructsH-522">  uint16_t creationTime;</front>
<front id="SdFatStructsH-523">           /** Date file was created. */</front>
<front id="SdFatStructsH-524">  uint16_t creationDate;</front>
<front id="SdFatStructsH-525">          /**</front>
<front id="SdFatStructsH-526">           * Last access date. Note that there is no last access time, only</front>
<front id="SdFatStructsH-527">           * a date.  This is the date of last read or write. In the case of</front>
<front id="SdFatStructsH-528">           * a write, this should be set to the same date as lastWriteDate.</front>
<front id="SdFatStructsH-529">           */</front>
<front id="SdFatStructsH-530">  uint16_t lastAccessDate;</front>
<front id="SdFatStructsH-531">          /**</front>
<front id="SdFatStructsH-532">           * High word of this entry's first cluster number (always 0 for a</front>
<front id="SdFatStructsH-533">           * FAT12 or FAT16 volume).</front>
<front id="SdFatStructsH-534">           */</front>
<front id="SdFatStructsH-535">  uint16_t firstClusterHigh;</front>
<front id="SdFatStructsH-536">           /** Time of last write. File creation is considered a write. */</front>
<front id="SdFatStructsH-537">  uint16_t lastWriteTime;</front>
<front id="SdFatStructsH-538">           /** Date of last write. File creation is considered a write. */</front>
<front id="SdFatStructsH-539">  uint16_t lastWriteDate;</front>
<front id="SdFatStructsH-540">           /** Low word of this entry's first cluster number. */</front>
<front id="SdFatStructsH-541">  uint16_t firstClusterLow;</front>
<front id="SdFatStructsH-542">           /** 32-bit unsigned holding this file's size in bytes. */</front>
<front id="SdFatStructsH-543">  uint32_t fileSize;</front>
<front id="SdFatStructsH-544">} PACKED;</front>
<front id="SdFatStructsH-545">/**</front>
<front id="SdFatStructsH-546"> * \struct directoryVFATEntry</front>
<front id="SdFatStructsH-547"> * \brief VFAT long filename directory entry</front>
<front id="SdFatStructsH-548"> *</front>
<front id="SdFatStructsH-549"> * directoryVFATEntries are found in the same list as normal directoryEntry.</front>
<front id="SdFatStructsH-550"> * But have the attribute field set to DIR_ATT_LONG_NAME.</front>
<front id="SdFatStructsH-551"> * </front>
<front id="SdFatStructsH-552"> * Long filenames are saved in multiple directoryVFATEntries.</front>
<front id="SdFatStructsH-553"> * Each entry containing 13 UTF-16 characters.</front>
<front id="SdFatStructsH-554"> */</front>
<front id="SdFatStructsH-555">struct directoryVFATEntry {</front>
<front id="SdFatStructsH-556">  /**</front>
<front id="SdFatStructsH-557">   * Sequence number. Consists of 2 parts:</front>
<front id="SdFatStructsH-558">   *  bit 6:   indicates first long filename block for the next file</front>
<front id="SdFatStructsH-559">   *  bit 0-4: the position of this long filename block (first block is 1)</front>
<front id="SdFatStructsH-560">   */</front>
<front id="SdFatStructsH-561">  uint8_t  sequenceNumber;</front>
<front id="SdFatStructsH-562">  /** First set of UTF-16 characters */</front>
<front id="SdFatStructsH-563">  uint16_t name1[5];//UTF-16</front>
<front id="SdFatStructsH-564">  /** attributes (at the same location as in directoryEntry), always 0x0F */</front>
<front id="SdFatStructsH-565">  uint8_t  attributes;</front>
<front id="SdFatStructsH-566">  /** Reserved for use by Windows NT. Always 0. */</front>
<front id="SdFatStructsH-567">  uint8_t  reservedNT;</front>
<front id="SdFatStructsH-568">  /** Checksum of the short 8.3 filename, can be used to checked if the file system as modified by a not-long-filename aware implementation. */</front>
<front id="SdFatStructsH-569">  uint8_t  checksum;</front>
<front id="SdFatStructsH-570">  /** Second set of UTF-16 characters */</front>
<front id="SdFatStructsH-571">  uint16_t name2[6];//UTF-16</front>
<front id="SdFatStructsH-572">  /** firstClusterLow is always zero for longFilenames */</front>
<front id="SdFatStructsH-573">  uint16_t firstClusterLow;</front>
<front id="SdFatStructsH-574">  /** Third set of UTF-16 characters */</front>
<front id="SdFatStructsH-575">  uint16_t name3[2];//UTF-16</front>
<front id="SdFatStructsH-576">} PACKED;</front>
<front id="SdFatStructsH-577">//------------------------------------------------------------------------------</front>
<front id="SdFatStructsH-578">// Definitions for directory entries</front>
<front id="SdFatStructsH-579">//</front>
<front id="SdFatStructsH-580">/** Type name for directoryEntry */</front>
<front id="SdFatStructsH-581">typedef struct directoryEntry dir_t;</front>
<front id="SdFatStructsH-582">/** Type name for directoryVFATEntry */</front>
<front id="SdFatStructsH-583">typedef struct directoryVFATEntry vfat_t;</front>
<front id="SdFatStructsH-584">/** escape for name[0] = 0XE5 */</front>
<front id="SdFatStructsH-585">uint8_t const DIR_NAME_0XE5 = 0X05;</front>
<front id="SdFatStructsH-586">/** name[0] value for entry that is free after being "deleted" */</front>
<front id="SdFatStructsH-587">uint8_t const DIR_NAME_DELETED = 0XE5;</front>
<front id="SdFatStructsH-588">/** name[0] value for entry that is free and no allocated entries follow */</front>
<front id="SdFatStructsH-589">uint8_t const DIR_NAME_FREE = 0X00;</front>
<front id="SdFatStructsH-590">/** file is read-only */</front>
<front id="SdFatStructsH-591">uint8_t const DIR_ATT_READ_ONLY = 0X01;</front>
<front id="SdFatStructsH-592">/** File should hidden in directory listings */</front>
<front id="SdFatStructsH-593">uint8_t const DIR_ATT_HIDDEN = 0X02;</front>
<front id="SdFatStructsH-594">/** Entry is for a system file */</front>
<front id="SdFatStructsH-595">uint8_t const DIR_ATT_SYSTEM = 0X04;</front>
<front id="SdFatStructsH-596">/** Directory entry contains the volume label */</front>
<front id="SdFatStructsH-597">uint8_t const DIR_ATT_VOLUME_ID = 0X08;</front>
<front id="SdFatStructsH-598">/** Entry is for a directory */</front>
<front id="SdFatStructsH-599">uint8_t const DIR_ATT_DIRECTORY = 0X10;</front>
<front id="SdFatStructsH-600">/** Old DOS archive bit for backup support */</front>
<front id="SdFatStructsH-601">uint8_t const DIR_ATT_ARCHIVE = 0X20;</front>
<front id="SdFatStructsH-602">/** Test value for long name entry.  Test is</front>
<front id="SdFatStructsH-603">  (d-&gt;attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME. */</front>
<front id="SdFatStructsH-604">uint8_t const DIR_ATT_LONG_NAME = 0X0F;</front>
<front id="SdFatStructsH-605">/** Test mask for long name entry */</front>
<front id="SdFatStructsH-606">uint8_t const DIR_ATT_LONG_NAME_MASK = 0X3F;</front>
<front id="SdFatStructsH-607">/** defined attribute bits */</front>
<front id="SdFatStructsH-608">uint8_t const DIR_ATT_DEFINED_BITS = 0X3F;</front>
<front id="SdFatStructsH-609">/** Directory entry is part of a long name</front>
<front id="SdFatStructsH-610"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-611"> *</front>
<front id="SdFatStructsH-612"> * \return true if the entry is for part of a long name else false.</front>
<front id="SdFatStructsH-613"> */</front>
<front id="SdFatStructsH-614">static inline uint8_t DIR_IS_LONG_NAME(const dir_t* dir) {</front>
<front id="SdFatStructsH-615">  return (dir-&gt;attributes & DIR_ATT_LONG_NAME_MASK) == DIR_ATT_LONG_NAME;</front>
<front id="SdFatStructsH-616">}</front>
<front id="SdFatStructsH-617">/** Mask for file/subdirectory tests */</front>
<front id="SdFatStructsH-618">uint8_t const DIR_ATT_FILE_TYPE_MASK = (DIR_ATT_VOLUME_ID | DIR_ATT_DIRECTORY);</front>
<front id="SdFatStructsH-619">/** Directory entry is for a file</front>
<front id="SdFatStructsH-620"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-621"> *</front>
<front id="SdFatStructsH-622"> * \return true if the entry is for a normal file else false.</front>
<front id="SdFatStructsH-623"> */</front>
<front id="SdFatStructsH-624">static inline uint8_t DIR_IS_FILE(const dir_t* dir) {</front>
<front id="SdFatStructsH-625">  return (dir-&gt;attributes & DIR_ATT_FILE_TYPE_MASK) == 0;</front>
<front id="SdFatStructsH-626">}</front>
<front id="SdFatStructsH-627">/** Directory entry is for a subdirectory</front>
<front id="SdFatStructsH-628"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-629"> *</front>
<front id="SdFatStructsH-630"> * \return true if the entry is for a subdirectory else false.</front>
<front id="SdFatStructsH-631"> */</front>
<front id="SdFatStructsH-632">static inline uint8_t DIR_IS_SUBDIR(const dir_t* dir) {</front>
<front id="SdFatStructsH-633">  return (dir-&gt;attributes & DIR_ATT_FILE_TYPE_MASK) == DIR_ATT_DIRECTORY;</front>
<front id="SdFatStructsH-634">}</front>
<front id="SdFatStructsH-635">/** Directory entry is for a file or subdirectory</front>
<front id="SdFatStructsH-636"> * \param[in] dir Pointer to a directory entry.</front>
<front id="SdFatStructsH-637"> *</front>
<front id="SdFatStructsH-638"> * \return true if the entry is for a normal file or subdirectory else false.</front>
<front id="SdFatStructsH-639"> */</front>
<front id="SdFatStructsH-640">static inline uint8_t DIR_IS_FILE_OR_SUBDIR(const dir_t* dir) {</front>
<front id="SdFatStructsH-641">  return (dir-&gt;attributes & DIR_ATT_VOLUME_ID) == 0;</front>
<front id="SdFatStructsH-642">}</front>
<front id="SdFatStructsH-643">#endif  // SdFatStructs_h</front>
<front id="SdFatStructsH-644"></front>
<front id="SdFatStructsH-645"></front>
<front id="SdFatStructsH-646">#endif</front>
 </pre>
<h1 id="SdFatUtilCPPtitle" >SdFatUtil.cpp</h1>
<pre id="SdFatUtilCPP"  class="prettyprint linenums"><front id="SdFatUtilCPP-1">/* Arduino SdFat Library</front>
<front id="SdFatUtilCPP-2"> * Copyright (C) 2008 by William Greiman</front>
<front id="SdFatUtilCPP-3"> *</front>
<front id="SdFatUtilCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatUtilCPP-5"> *</front>
<front id="SdFatUtilCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatUtilCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatUtilCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatUtilCPP-9"> * (at your option) any later version.</front>
<front id="SdFatUtilCPP-10"> *</front>
<front id="SdFatUtilCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatUtilCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatUtilCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatUtilCPP-14"> * GNU General Public License for more details.</front>
<front id="SdFatUtilCPP-15"></front>
<front id="SdFatUtilCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatUtilCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatUtilCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatUtilCPP-19"> */</front>
<front id="SdFatUtilCPP-20">#include "Marlin.h"</front>
<front id="SdFatUtilCPP-21"></front>
<front id="SdFatUtilCPP-22">#if ENABLED(SDSUPPORT)</front>
<front id="SdFatUtilCPP-23">#include "SdFatUtil.h"</front>
<front id="SdFatUtilCPP-24"></front>
<front id="SdFatUtilCPP-25">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-26">/** Amount of free RAM</front>
<front id="SdFatUtilCPP-27"> * \return The number of free bytes.</front>
<front id="SdFatUtilCPP-28"> */</front>
<front id="SdFatUtilCPP-29">#ifdef __arm__</front>
<front id="SdFatUtilCPP-30">extern "C" char* sbrk(int incr);</front>
<front id="SdFatUtilCPP-31">int SdFatUtil::FreeRam() {</front>
<front id="SdFatUtilCPP-32">  char top;</front>
<front id="SdFatUtilCPP-33">  return &top - reinterpret_cast&lt;char*&gt;(sbrk(0));</front>
<front id="SdFatUtilCPP-34">}</front>
<front id="SdFatUtilCPP-35">#else  // __arm__</front>
<front id="SdFatUtilCPP-36">extern char *__brkval;</front>
<front id="SdFatUtilCPP-37">extern char __bss_end;</front>
<front id="SdFatUtilCPP-38">/** Amount of free RAM</front>
<front id="SdFatUtilCPP-39"> * \return The number of free bytes.</front>
<front id="SdFatUtilCPP-40"> */</front>
<front id="SdFatUtilCPP-41">int SdFatUtil::FreeRam() {</front>
<front id="SdFatUtilCPP-42">  char top;</front>
<front id="SdFatUtilCPP-43">  return __brkval ? &top - __brkval : &top - &__bss_end;</front>
<front id="SdFatUtilCPP-44">}</front>
<front id="SdFatUtilCPP-45">#endif  // __arm</front>
<front id="SdFatUtilCPP-46"></front>
<front id="SdFatUtilCPP-47">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-48">/** %Print a string in flash memory.</front>
<front id="SdFatUtilCPP-49"> *</front>
<front id="SdFatUtilCPP-50"> * \param[in] pr Print object for output.</front>
<front id="SdFatUtilCPP-51"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-52"> */</front>
<front id="SdFatUtilCPP-53">void SdFatUtil::print_P( PGM_P str) {</front>
<front id="SdFatUtilCPP-54">  for (uint8_t c; (c = pgm_read_byte(str)); str++) MYSERIAL.write(c);</front>
<front id="SdFatUtilCPP-55">}</front>
<front id="SdFatUtilCPP-56">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-57">/** %Print a string in flash memory followed by a CR/LF.</front>
<front id="SdFatUtilCPP-58"> *</front>
<front id="SdFatUtilCPP-59"> * \param[in] pr Print object for output.</front>
<front id="SdFatUtilCPP-60"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-61"> */</front>
<front id="SdFatUtilCPP-62">void SdFatUtil::println_P( PGM_P str) {</front>
<front id="SdFatUtilCPP-63">  print_P( str);</front>
<front id="SdFatUtilCPP-64">  MYSERIAL.println();</front>
<front id="SdFatUtilCPP-65">}</front>
<front id="SdFatUtilCPP-66">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-67">/** %Print a string in flash memory to Serial.</front>
<front id="SdFatUtilCPP-68"> *</front>
<front id="SdFatUtilCPP-69"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-70"> */</front>
<front id="SdFatUtilCPP-71">void SdFatUtil::SerialPrint_P(PGM_P str) {</front>
<front id="SdFatUtilCPP-72">  print_P(str);</front>
<front id="SdFatUtilCPP-73">}</front>
<front id="SdFatUtilCPP-74">//------------------------------------------------------------------------------</front>
<front id="SdFatUtilCPP-75">/** %Print a string in flash memory to Serial followed by a CR/LF.</front>
<front id="SdFatUtilCPP-76"> *</front>
<front id="SdFatUtilCPP-77"> * \param[in] str Pointer to string stored in flash memory.</front>
<front id="SdFatUtilCPP-78"> */</front>
<front id="SdFatUtilCPP-79">void SdFatUtil::SerialPrintln_P(PGM_P str) {</front>
<front id="SdFatUtilCPP-80">  println_P( str);</front>
<front id="SdFatUtilCPP-81">}</front>
<front id="SdFatUtilCPP-82">#endif</front>
 </pre>
<h1 id="SdFatUtilHtitle" >SdFatUtil.h</h1>
<pre id="SdFatUtilH"  class="prettyprint linenums"><front id="SdFatUtilH-1">/* Arduino SdFat Library</front>
<front id="SdFatUtilH-2"> * Copyright (C) 2008 by William Greiman</front>
<front id="SdFatUtilH-3"> *</front>
<front id="SdFatUtilH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFatUtilH-5"> *</front>
<front id="SdFatUtilH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFatUtilH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFatUtilH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFatUtilH-9"> * (at your option) any later version.</front>
<front id="SdFatUtilH-10"> *</front>
<front id="SdFatUtilH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFatUtilH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFatUtilH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFatUtilH-14"> * GNU General Public License for more details.</front>
<front id="SdFatUtilH-15"></front>
<front id="SdFatUtilH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFatUtilH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFatUtilH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFatUtilH-19"> */</front>
<front id="SdFatUtilH-20">#include "Marlin.h"</front>
<front id="SdFatUtilH-21">#if ENABLED(SDSUPPORT)</front>
<front id="SdFatUtilH-22"></front>
<front id="SdFatUtilH-23">#ifndef SdFatUtil_h</front>
<front id="SdFatUtilH-24">#define SdFatUtil_h</front>
<front id="SdFatUtilH-25">/**</front>
<front id="SdFatUtilH-26"> * \file</front>
<front id="SdFatUtilH-27"> * \brief Useful utility functions.</front>
<front id="SdFatUtilH-28"> */</front>
<front id="SdFatUtilH-29">#include "Marlin.h"</front>
<front id="SdFatUtilH-30">#include "MarlinSerial.h"</front>
<front id="SdFatUtilH-31">/** Store and print a string in flash memory.*/</front>
<front id="SdFatUtilH-32">#define PgmPrint(x) SerialPrint_P(PSTR(x))</front>
<front id="SdFatUtilH-33">/** Store and print a string in flash memory followed by a CR/LF.*/</front>
<front id="SdFatUtilH-34">#define PgmPrintln(x) SerialPrintln_P(PSTR(x))</front>
<front id="SdFatUtilH-35"></front>
<front id="SdFatUtilH-36">namespace SdFatUtil {</front>
<front id="SdFatUtilH-37">  int FreeRam();</front>
<front id="SdFatUtilH-38">  void print_P( PGM_P str);</front>
<front id="SdFatUtilH-39">  void println_P( PGM_P str);</front>
<front id="SdFatUtilH-40">  void SerialPrint_P(PGM_P str);</front>
<front id="SdFatUtilH-41">  void SerialPrintln_P(PGM_P str);</front>
<front id="SdFatUtilH-42">}</front>
<front id="SdFatUtilH-43"></front>
<front id="SdFatUtilH-44">using namespace SdFatUtil;  // NOLINT</front>
<front id="SdFatUtilH-45">#endif  // #define SdFatUtil_h</front>
<front id="SdFatUtilH-46"></front>
<front id="SdFatUtilH-47"></front>
<front id="SdFatUtilH-48">#endif</front>
 </pre>
<h1 id="SdFileCPPtitle" >SdFile.cpp</h1>
<pre id="SdFileCPP"  class="prettyprint linenums"><front id="SdFileCPP-1">/* Arduino SdFat Library</front>
<front id="SdFileCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFileCPP-3"> *</front>
<front id="SdFileCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFileCPP-5"> *</front>
<front id="SdFileCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFileCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFileCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFileCPP-9"> * (at your option) any later version.</front>
<front id="SdFileCPP-10"> *</front>
<front id="SdFileCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFileCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFileCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFileCPP-14"> * GNU General Public License for more details.</front>
<front id="SdFileCPP-15"> *</front>
<front id="SdFileCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFileCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFileCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFileCPP-19"> */</front>
<front id="SdFileCPP-20">#include "Marlin.h"</front>
<front id="SdFileCPP-21"></front>
<front id="SdFileCPP-22">#if ENABLED(SDSUPPORT)</front>
<front id="SdFileCPP-23">#include "SdFile.h"</front>
<front id="SdFileCPP-24">/**  Create a file object and open it in the current working directory.</front>
<front id="SdFileCPP-25"> *</front>
<front id="SdFileCPP-26"> * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.</front>
<front id="SdFileCPP-27"> *</front>
<front id="SdFileCPP-28"> * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive</front>
<front id="SdFileCPP-29"> * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).</front>
<front id="SdFileCPP-30"> */</front>
<front id="SdFileCPP-31">SdFile::SdFile(const char* path, uint8_t oflag) : SdBaseFile(path, oflag) {</front>
<front id="SdFileCPP-32">}</front>
<front id="SdFileCPP-33">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-34">/** Write data to an open file.</front>
<front id="SdFileCPP-35"> *</front>
<front id="SdFileCPP-36"> * \note Data is moved to the cache but may not be written to the</front>
<front id="SdFileCPP-37"> * storage device until sync() is called.</front>
<front id="SdFileCPP-38"> *</front>
<front id="SdFileCPP-39"> * \param[in] buf Pointer to the location of the data to be written.</front>
<front id="SdFileCPP-40"> *</front>
<front id="SdFileCPP-41"> * \param[in] nbyte Number of bytes to write.</front>
<front id="SdFileCPP-42"> *</front>
<front id="SdFileCPP-43"> * \return For success write() returns the number of bytes written, always</front>
<front id="SdFileCPP-44"> * \a nbyte.  If an error occurs, write() returns -1.  Possible errors</front>
<front id="SdFileCPP-45"> * include write() is called before a file has been opened, write is called</front>
<front id="SdFileCPP-46"> * for a read-only file, device is full, a corrupt file system or an I/O error.</front>
<front id="SdFileCPP-47"> *</front>
<front id="SdFileCPP-48"> */</front>
<front id="SdFileCPP-49">int16_t SdFile::write(const void* buf, uint16_t nbyte) {</front>
<front id="SdFileCPP-50">  return SdBaseFile::write(buf, nbyte);</front>
<front id="SdFileCPP-51">}</front>
<front id="SdFileCPP-52">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-53">/** Write a byte to a file. Required by the Arduino Print class.</front>
<front id="SdFileCPP-54"> * \param[in] b the byte to be written.</front>
<front id="SdFileCPP-55"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-56"> */</front>
<front id="SdFileCPP-57">#if ARDUINO &gt;= 100</front>
<front id="SdFileCPP-58">size_t SdFile::write(uint8_t b)</front>
<front id="SdFileCPP-59">{</front>
<front id="SdFileCPP-60">    return SdBaseFile::write(&b, 1);</front>
<front id="SdFileCPP-61">}</front>
<front id="SdFileCPP-62">#else</front>
<front id="SdFileCPP-63">void SdFile::write(uint8_t b)</front>
<front id="SdFileCPP-64">{</front>
<front id="SdFileCPP-65">    SdBaseFile::write(&b, 1);</front>
<front id="SdFileCPP-66">}</front>
<front id="SdFileCPP-67">#endif</front>
<front id="SdFileCPP-68">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-69">/** Write a string to a file. Used by the Arduino Print class.</front>
<front id="SdFileCPP-70"> * \param[in] str Pointer to the string.</front>
<front id="SdFileCPP-71"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-72"> */</front>
<front id="SdFileCPP-73">void SdFile::write(const char* str) {</front>
<front id="SdFileCPP-74">  SdBaseFile::write(str, strlen(str));</front>
<front id="SdFileCPP-75">}</front>
<front id="SdFileCPP-76">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-77">/** Write a PROGMEM string to a file.</front>
<front id="SdFileCPP-78"> * \param[in] str Pointer to the PROGMEM string.</front>
<front id="SdFileCPP-79"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-80"> */</front>
<front id="SdFileCPP-81">void SdFile::write_P(PGM_P str) {</front>
<front id="SdFileCPP-82">  for (uint8_t c; (c = pgm_read_byte(str)); str++) write(c);</front>
<front id="SdFileCPP-83">}</front>
<front id="SdFileCPP-84">//------------------------------------------------------------------------------</front>
<front id="SdFileCPP-85">/** Write a PROGMEM string followed by CR/LF to a file.</front>
<front id="SdFileCPP-86"> * \param[in] str Pointer to the PROGMEM string.</front>
<front id="SdFileCPP-87"> * Use writeError to check for errors.</front>
<front id="SdFileCPP-88"> */</front>
<front id="SdFileCPP-89">void SdFile::writeln_P(PGM_P str) {</front>
<front id="SdFileCPP-90">  write_P(str);</front>
<front id="SdFileCPP-91">  write_P(PSTR("\r\n"));</front>
<front id="SdFileCPP-92">}</front>
<front id="SdFileCPP-93"></front>
<front id="SdFileCPP-94"></front>
<front id="SdFileCPP-95">#endif</front>
 </pre>
<h1 id="SdFileHtitle" >SdFile.h</h1>
<pre id="SdFileH"  class="prettyprint linenums"><front id="SdFileH-1">/* Arduino SdFat Library</front>
<front id="SdFileH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdFileH-3"> *</front>
<front id="SdFileH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdFileH-5"> *</front>
<front id="SdFileH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdFileH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdFileH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdFileH-9"> * (at your option) any later version.</front>
<front id="SdFileH-10"> *</front>
<front id="SdFileH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdFileH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdFileH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdFileH-14"> * GNU General Public License for more details.</front>
<front id="SdFileH-15"> *</front>
<front id="SdFileH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdFileH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdFileH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdFileH-19"> */</front>
<front id="SdFileH-20">/**</front>
<front id="SdFileH-21"> * \file</front>
<front id="SdFileH-22"> * \brief SdFile class</front>
<front id="SdFileH-23"> */</front>
<front id="SdFileH-24">#include "Marlin.h"</front>
<front id="SdFileH-25"></front>
<front id="SdFileH-26">#if ENABLED(SDSUPPORT)</front>
<front id="SdFileH-27">#include "SdBaseFile.h"</front>
<front id="SdFileH-28">#include &lt;Print.h&gt;</front>
<front id="SdFileH-29">#ifndef SdFile_h</front>
<front id="SdFileH-30">#define SdFile_h</front>
<front id="SdFileH-31">//------------------------------------------------------------------------------</front>
<front id="SdFileH-32">/**</front>
<front id="SdFileH-33"> * \class SdFile</front>
<front id="SdFileH-34"> * \brief SdBaseFile with Print.</front>
<front id="SdFileH-35"> */</front>
<front id="SdFileH-36">class SdFile : public SdBaseFile, public Print {</front>
<front id="SdFileH-37"> public:</front>
<front id="SdFileH-38">  SdFile() {}</front>
<front id="SdFileH-39">  SdFile(const char* name, uint8_t oflag);</front>
<front id="SdFileH-40">  #if ARDUINO &gt;= 100</front>
<front id="SdFileH-41">      size_t write(uint8_t b);</front>
<front id="SdFileH-42">  #else</front>
<front id="SdFileH-43">   void write(uint8_t b);</front>
<front id="SdFileH-44">  #endif</front>
<front id="SdFileH-45">  </front>
<front id="SdFileH-46">  int16_t write(const void* buf, uint16_t nbyte);</front>
<front id="SdFileH-47">  void write(const char* str);</front>
<front id="SdFileH-48">  void write_P(PGM_P str);</front>
<front id="SdFileH-49">  void writeln_P(PGM_P str);</front>
<front id="SdFileH-50">};</front>
<front id="SdFileH-51">#endif  // SdFile_h</front>
<front id="SdFileH-52"></front>
<front id="SdFileH-53"></front>
<front id="SdFileH-54">#endif</front>
 </pre>
<h1 id="SdInfoHtitle" >SdInfo.h</h1>
<pre id="SdInfoH"  class="prettyprint linenums"><front id="SdInfoH-1">/* Arduino Sd2Card Library</front>
<front id="SdInfoH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdInfoH-3"> *</front>
<front id="SdInfoH-4"> * This file is part of the Arduino Sd2Card Library</front>
<front id="SdInfoH-5"> *</front>
<front id="SdInfoH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdInfoH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdInfoH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdInfoH-9"> * (at your option) any later version.</front>
<front id="SdInfoH-10"> *</front>
<front id="SdInfoH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdInfoH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdInfoH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdInfoH-14"> * GNU General Public License for more details.</front>
<front id="SdInfoH-15"> *</front>
<front id="SdInfoH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdInfoH-17"> * along with the Arduino Sd2Card Library.  If not, see</front>
<front id="SdInfoH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdInfoH-19"> */</front>
<front id="SdInfoH-20">#include "Marlin.h"</front>
<front id="SdInfoH-21">#if ENABLED(SDSUPPORT)</front>
<front id="SdInfoH-22"></front>
<front id="SdInfoH-23">#ifndef SdInfo_h</front>
<front id="SdInfoH-24">#define SdInfo_h</front>
<front id="SdInfoH-25">#include &lt;stdint.h&gt;</front>
<front id="SdInfoH-26">// Based on the document:</front>
<front id="SdInfoH-27">//</front>
<front id="SdInfoH-28">// SD Specifications</front>
<front id="SdInfoH-29">// Part 1</front>
<front id="SdInfoH-30">// Physical Layer</front>
<front id="SdInfoH-31">// Simplified Specification</front>
<front id="SdInfoH-32">// Version 3.01</front>
<front id="SdInfoH-33">// May 18, 2010</front>
<front id="SdInfoH-34">//</front>
<front id="SdInfoH-35">// http://www.sdcard.org/developers/tech/sdcard/pls/simplified_specs</front>
<front id="SdInfoH-36">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-37">// SD card commands</front>
<front id="SdInfoH-38">/** GO_IDLE_STATE - init card in spi mode if CS low */</front>
<front id="SdInfoH-39">uint8_t const CMD0 = 0X00;</front>
<front id="SdInfoH-40">/** SEND_IF_COND - verify SD Memory Card interface operating condition.*/</front>
<front id="SdInfoH-41">uint8_t const CMD8 = 0X08;</front>
<front id="SdInfoH-42">/** SEND_CSD - read the Card Specific Data (CSD register) */</front>
<front id="SdInfoH-43">uint8_t const CMD9 = 0X09;</front>
<front id="SdInfoH-44">/** SEND_CID - read the card identification information (CID register) */</front>
<front id="SdInfoH-45">uint8_t const CMD10 = 0X0A;</front>
<front id="SdInfoH-46">/** STOP_TRANSMISSION - end multiple block read sequence */</front>
<front id="SdInfoH-47">uint8_t const CMD12 = 0X0C;</front>
<front id="SdInfoH-48">/** SEND_STATUS - read the card status register */</front>
<front id="SdInfoH-49">uint8_t const CMD13 = 0X0D;</front>
<front id="SdInfoH-50">/** READ_SINGLE_BLOCK - read a single data block from the card */</front>
<front id="SdInfoH-51">uint8_t const CMD17 = 0X11;</front>
<front id="SdInfoH-52">/** READ_MULTIPLE_BLOCK - read a multiple data blocks from the card */</front>
<front id="SdInfoH-53">uint8_t const CMD18 = 0X12;</front>
<front id="SdInfoH-54">/** WRITE_BLOCK - write a single data block to the card */</front>
<front id="SdInfoH-55">uint8_t const CMD24 = 0X18;</front>
<front id="SdInfoH-56">/** WRITE_MULTIPLE_BLOCK - write blocks of data until a STOP_TRANSMISSION */</front>
<front id="SdInfoH-57">uint8_t const CMD25 = 0X19;</front>
<front id="SdInfoH-58">/** ERASE_WR_BLK_START - sets the address of the first block to be erased */</front>
<front id="SdInfoH-59">uint8_t const CMD32 = 0X20;</front>
<front id="SdInfoH-60">/** ERASE_WR_BLK_END - sets the address of the last block of the continuous</front>
<front id="SdInfoH-61">    range to be erased*/</front>
<front id="SdInfoH-62">uint8_t const CMD33 = 0X21;</front>
<front id="SdInfoH-63">/** ERASE - erase all previously selected blocks */</front>
<front id="SdInfoH-64">uint8_t const CMD38 = 0X26;</front>
<front id="SdInfoH-65">/** APP_CMD - escape for application specific command */</front>
<front id="SdInfoH-66">uint8_t const CMD55 = 0X37;</front>
<front id="SdInfoH-67">/** READ_OCR - read the OCR register of a card */</front>
<front id="SdInfoH-68">uint8_t const CMD58 = 0X3A;</front>
<front id="SdInfoH-69">/** SET_WR_BLK_ERASE_COUNT - Set the number of write blocks to be</front>
<front id="SdInfoH-70">     pre-erased before writing */</front>
<front id="SdInfoH-71">uint8_t const ACMD23 = 0X17;</front>
<front id="SdInfoH-72">/** SD_SEND_OP_COMD - Sends host capacity support information and</front>
<front id="SdInfoH-73">    activates the card's initialization process */</front>
<front id="SdInfoH-74">uint8_t const ACMD41 = 0X29;</front>
<front id="SdInfoH-75">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-76">/** status for card in the ready state */</front>
<front id="SdInfoH-77">uint8_t const R1_READY_STATE = 0X00;</front>
<front id="SdInfoH-78">/** status for card in the idle state */</front>
<front id="SdInfoH-79">uint8_t const R1_IDLE_STATE = 0X01;</front>
<front id="SdInfoH-80">/** status bit for illegal command */</front>
<front id="SdInfoH-81">uint8_t const R1_ILLEGAL_COMMAND = 0X04;</front>
<front id="SdInfoH-82">/** start data token for read or write single block*/</front>
<front id="SdInfoH-83">uint8_t const DATA_START_BLOCK = 0XFE;</front>
<front id="SdInfoH-84">/** stop token for write multiple blocks*/</front>
<front id="SdInfoH-85">uint8_t const STOP_TRAN_TOKEN = 0XFD;</front>
<front id="SdInfoH-86">/** start data token for write multiple blocks*/</front>
<front id="SdInfoH-87">uint8_t const WRITE_MULTIPLE_TOKEN = 0XFC;</front>
<front id="SdInfoH-88">/** mask for data response tokens after a write block operation */</front>
<front id="SdInfoH-89">uint8_t const DATA_RES_MASK = 0X1F;</front>
<front id="SdInfoH-90">/** write data accepted token */</front>
<front id="SdInfoH-91">uint8_t const DATA_RES_ACCEPTED = 0X05;</front>
<front id="SdInfoH-92">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-93">/** Card IDentification (CID) register */</front>
<front id="SdInfoH-94">typedef struct CID {</front>
<front id="SdInfoH-95">  // byte 0</front>
<front id="SdInfoH-96">  /** Manufacturer ID */</front>
<front id="SdInfoH-97">  unsigned char mid;</front>
<front id="SdInfoH-98">  // byte 1-2</front>
<front id="SdInfoH-99">  /** OEM/Application ID */</front>
<front id="SdInfoH-100">  char oid[2];</front>
<front id="SdInfoH-101">  // byte 3-7</front>
<front id="SdInfoH-102">  /** Product name */</front>
<front id="SdInfoH-103">  char pnm[5];</front>
<front id="SdInfoH-104">  // byte 8</front>
<front id="SdInfoH-105">  /** Product revision least significant digit */</front>
<front id="SdInfoH-106">  unsigned char prv_m : 4;</front>
<front id="SdInfoH-107">  /** Product revision most significant digit */</front>
<front id="SdInfoH-108">  unsigned char prv_n : 4;</front>
<front id="SdInfoH-109">  // byte 9-12</front>
<front id="SdInfoH-110">  /** Product serial number */</front>
<front id="SdInfoH-111">  uint32_t psn;</front>
<front id="SdInfoH-112">  // byte 13</front>
<front id="SdInfoH-113">  /** Manufacturing date year low digit */</front>
<front id="SdInfoH-114">  unsigned char mdt_year_high : 4;</front>
<front id="SdInfoH-115">  /** not used */</front>
<front id="SdInfoH-116">  unsigned char reserved : 4;</front>
<front id="SdInfoH-117">  // byte 14</front>
<front id="SdInfoH-118">  /** Manufacturing date month */</front>
<front id="SdInfoH-119">  unsigned char mdt_month : 4;</front>
<front id="SdInfoH-120">  /** Manufacturing date year low digit */</front>
<front id="SdInfoH-121">  unsigned char mdt_year_low :4;</front>
<front id="SdInfoH-122">  // byte 15</front>
<front id="SdInfoH-123">  /** not used always 1 */</front>
<front id="SdInfoH-124">  unsigned char always1 : 1;</front>
<front id="SdInfoH-125">  /** CRC7 checksum */</front>
<front id="SdInfoH-126">  unsigned char crc : 7;</front>
<front id="SdInfoH-127">}cid_t;</front>
<front id="SdInfoH-128">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-129">/** CSD for version 1.00 cards */</front>
<front id="SdInfoH-130">typedef struct CSDV1 {</front>
<front id="SdInfoH-131">  // byte 0</front>
<front id="SdInfoH-132">  unsigned char reserved1 : 6;</front>
<front id="SdInfoH-133">  unsigned char csd_ver : 2;</front>
<front id="SdInfoH-134">  // byte 1</front>
<front id="SdInfoH-135">  unsigned char taac;</front>
<front id="SdInfoH-136">  // byte 2</front>
<front id="SdInfoH-137">  unsigned char nsac;</front>
<front id="SdInfoH-138">  // byte 3</front>
<front id="SdInfoH-139">  unsigned char tran_speed;</front>
<front id="SdInfoH-140">  // byte 4</front>
<front id="SdInfoH-141">  unsigned char ccc_high;</front>
<front id="SdInfoH-142">  // byte 5</front>
<front id="SdInfoH-143">  unsigned char read_bl_len : 4;</front>
<front id="SdInfoH-144">  unsigned char ccc_low : 4;</front>
<front id="SdInfoH-145">  // byte 6</front>
<front id="SdInfoH-146">  unsigned char c_size_high : 2;</front>
<front id="SdInfoH-147">  unsigned char reserved2 : 2;</front>
<front id="SdInfoH-148">  unsigned char dsr_imp : 1;</front>
<front id="SdInfoH-149">  unsigned char read_blk_misalign :1;</front>
<front id="SdInfoH-150">  unsigned char write_blk_misalign : 1;</front>
<front id="SdInfoH-151">  unsigned char read_bl_partial : 1;</front>
<front id="SdInfoH-152">  // byte 7</front>
<front id="SdInfoH-153">  unsigned char c_size_mid;</front>
<front id="SdInfoH-154">  // byte 8</front>
<front id="SdInfoH-155">  unsigned char vdd_r_curr_max : 3;</front>
<front id="SdInfoH-156">  unsigned char vdd_r_curr_min : 3;</front>
<front id="SdInfoH-157">  unsigned char c_size_low :2;</front>
<front id="SdInfoH-158">  // byte 9</front>
<front id="SdInfoH-159">  unsigned char c_size_mult_high : 2;</front>
<front id="SdInfoH-160">  unsigned char vdd_w_cur_max : 3;</front>
<front id="SdInfoH-161">  unsigned char vdd_w_curr_min : 3;</front>
<front id="SdInfoH-162">  // byte 10</front>
<front id="SdInfoH-163">  unsigned char sector_size_high : 6;</front>
<front id="SdInfoH-164">  unsigned char erase_blk_en : 1;</front>
<front id="SdInfoH-165">  unsigned char c_size_mult_low : 1;</front>
<front id="SdInfoH-166">  // byte 11</front>
<front id="SdInfoH-167">  unsigned char wp_grp_size : 7;</front>
<front id="SdInfoH-168">  unsigned char sector_size_low : 1;</front>
<front id="SdInfoH-169">  // byte 12</front>
<front id="SdInfoH-170">  unsigned char write_bl_len_high : 2;</front>
<front id="SdInfoH-171">  unsigned char r2w_factor : 3;</front>
<front id="SdInfoH-172">  unsigned char reserved3 : 2;</front>
<front id="SdInfoH-173">  unsigned char wp_grp_enable : 1;</front>
<front id="SdInfoH-174">  // byte 13</front>
<front id="SdInfoH-175">  unsigned char reserved4 : 5;</front>
<front id="SdInfoH-176">  unsigned char write_partial : 1;</front>
<front id="SdInfoH-177">  unsigned char write_bl_len_low : 2;</front>
<front id="SdInfoH-178">  // byte 14</front>
<front id="SdInfoH-179">  unsigned char reserved5: 2;</front>
<front id="SdInfoH-180">  unsigned char file_format : 2;</front>
<front id="SdInfoH-181">  unsigned char tmp_write_protect : 1;</front>
<front id="SdInfoH-182">  unsigned char perm_write_protect : 1;</front>
<front id="SdInfoH-183">  unsigned char copy : 1;</front>
<front id="SdInfoH-184">  /** Indicates the file format on the card */</front>
<front id="SdInfoH-185">  unsigned char file_format_grp : 1;</front>
<front id="SdInfoH-186">  // byte 15</front>
<front id="SdInfoH-187">  unsigned char always1 : 1;</front>
<front id="SdInfoH-188">  unsigned char crc : 7;</front>
<front id="SdInfoH-189">}csd1_t;</front>
<front id="SdInfoH-190">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-191">/** CSD for version 2.00 cards */</front>
<front id="SdInfoH-192">typedef struct CSDV2 {</front>
<front id="SdInfoH-193">  // byte 0</front>
<front id="SdInfoH-194">  unsigned char reserved1 : 6;</front>
<front id="SdInfoH-195">  unsigned char csd_ver : 2;</front>
<front id="SdInfoH-196">  // byte 1</front>
<front id="SdInfoH-197">  /** fixed to 0X0E */</front>
<front id="SdInfoH-198">  unsigned char taac;</front>
<front id="SdInfoH-199">  // byte 2</front>
<front id="SdInfoH-200">  /** fixed to 0 */</front>
<front id="SdInfoH-201">  unsigned char nsac;</front>
<front id="SdInfoH-202">  // byte 3</front>
<front id="SdInfoH-203">  unsigned char tran_speed;</front>
<front id="SdInfoH-204">  // byte 4</front>
<front id="SdInfoH-205">  unsigned char ccc_high;</front>
<front id="SdInfoH-206">  // byte 5</front>
<front id="SdInfoH-207">  /** This field is fixed to 9h, which indicates READ_BL_LEN=512 Byte */</front>
<front id="SdInfoH-208">  unsigned char read_bl_len : 4;</front>
<front id="SdInfoH-209">  unsigned char ccc_low : 4;</front>
<front id="SdInfoH-210">  // byte 6</front>
<front id="SdInfoH-211">  /** not used */</front>
<front id="SdInfoH-212">  unsigned char reserved2 : 4;</front>
<front id="SdInfoH-213">  unsigned char dsr_imp : 1;</front>
<front id="SdInfoH-214">  /** fixed to 0 */</front>
<front id="SdInfoH-215">  unsigned char read_blk_misalign :1;</front>
<front id="SdInfoH-216">  /** fixed to 0 */</front>
<front id="SdInfoH-217">  unsigned char write_blk_misalign : 1;</front>
<front id="SdInfoH-218">  /** fixed to 0 - no partial read */</front>
<front id="SdInfoH-219">  unsigned char read_bl_partial : 1;</front>
<front id="SdInfoH-220">  // byte 7</front>
<front id="SdInfoH-221">  /** not used */</front>
<front id="SdInfoH-222">  unsigned char reserved3 : 2;</front>
<front id="SdInfoH-223">  /** high part of card size */</front>
<front id="SdInfoH-224">  unsigned char c_size_high : 6;</front>
<front id="SdInfoH-225">  // byte 8</front>
<front id="SdInfoH-226">  /** middle part of card size */</front>
<front id="SdInfoH-227">  unsigned char c_size_mid;</front>
<front id="SdInfoH-228">  // byte 9</front>
<front id="SdInfoH-229">  /** low part of card size */</front>
<front id="SdInfoH-230">  unsigned char c_size_low;</front>
<front id="SdInfoH-231">  // byte 10</front>
<front id="SdInfoH-232">  /** sector size is fixed at 64 KB */</front>
<front id="SdInfoH-233">  unsigned char sector_size_high : 6;</front>
<front id="SdInfoH-234">  /** fixed to 1 - erase single is supported */</front>
<front id="SdInfoH-235">  unsigned char erase_blk_en : 1;</front>
<front id="SdInfoH-236">  /** not used */</front>
<front id="SdInfoH-237">  unsigned char reserved4 : 1;</front>
<front id="SdInfoH-238">  // byte 11</front>
<front id="SdInfoH-239">  unsigned char wp_grp_size : 7;</front>
<front id="SdInfoH-240">  /** sector size is fixed at 64 KB */</front>
<front id="SdInfoH-241">  unsigned char sector_size_low : 1;</front>
<front id="SdInfoH-242">  // byte 12</front>
<front id="SdInfoH-243">  /** write_bl_len fixed for 512 byte blocks */</front>
<front id="SdInfoH-244">  unsigned char write_bl_len_high : 2;</front>
<front id="SdInfoH-245">  /** fixed value of 2 */</front>
<front id="SdInfoH-246">  unsigned char r2w_factor : 3;</front>
<front id="SdInfoH-247">  /** not used */</front>
<front id="SdInfoH-248">  unsigned char reserved5 : 2;</front>
<front id="SdInfoH-249">  /** fixed value of 0 - no write protect groups */</front>
<front id="SdInfoH-250">  unsigned char wp_grp_enable : 1;</front>
<front id="SdInfoH-251">  // byte 13</front>
<front id="SdInfoH-252">  unsigned char reserved6 : 5;</front>
<front id="SdInfoH-253">  /** always zero - no partial block read*/</front>
<front id="SdInfoH-254">  unsigned char write_partial : 1;</front>
<front id="SdInfoH-255">  /** write_bl_len fixed for 512 byte blocks */</front>
<front id="SdInfoH-256">  unsigned char write_bl_len_low : 2;</front>
<front id="SdInfoH-257">  // byte 14</front>
<front id="SdInfoH-258">  unsigned char reserved7: 2;</front>
<front id="SdInfoH-259">  /** Do not use always 0 */</front>
<front id="SdInfoH-260">  unsigned char file_format : 2;</front>
<front id="SdInfoH-261">  unsigned char tmp_write_protect : 1;</front>
<front id="SdInfoH-262">  unsigned char perm_write_protect : 1;</front>
<front id="SdInfoH-263">  unsigned char copy : 1;</front>
<front id="SdInfoH-264">  /** Do not use always 0 */</front>
<front id="SdInfoH-265">  unsigned char file_format_grp : 1;</front>
<front id="SdInfoH-266">  // byte 15</front>
<front id="SdInfoH-267">  /** not used always 1 */</front>
<front id="SdInfoH-268">  unsigned char always1 : 1;</front>
<front id="SdInfoH-269">  /** checksum */</front>
<front id="SdInfoH-270">  unsigned char crc : 7;</front>
<front id="SdInfoH-271">}csd2_t;</front>
<front id="SdInfoH-272">//------------------------------------------------------------------------------</front>
<front id="SdInfoH-273">/** union of old and new style CSD register */</front>
<front id="SdInfoH-274">union csd_t {</front>
<front id="SdInfoH-275">  csd1_t v1;</front>
<front id="SdInfoH-276">  csd2_t v2;</front>
<front id="SdInfoH-277">};</front>
<front id="SdInfoH-278">#endif  // SdInfo_h</front>
<front id="SdInfoH-279"></front>
<front id="SdInfoH-280">#endif</front>
 </pre>
<h1 id="SdVolumeCPPtitle" >SdVolume.cpp</h1>
<pre id="SdVolumeCPP"  class="prettyprint linenums"><front id="SdVolumeCPP-1">/* Arduino SdFat Library</front>
<front id="SdVolumeCPP-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdVolumeCPP-3"> *</front>
<front id="SdVolumeCPP-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdVolumeCPP-5"> *</front>
<front id="SdVolumeCPP-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdVolumeCPP-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdVolumeCPP-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdVolumeCPP-9"> * (at your option) any later version.</front>
<front id="SdVolumeCPP-10"> *</front>
<front id="SdVolumeCPP-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdVolumeCPP-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdVolumeCPP-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdVolumeCPP-14"> * GNU General Public License for more details.</front>
<front id="SdVolumeCPP-15"> *</front>
<front id="SdVolumeCPP-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdVolumeCPP-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdVolumeCPP-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdVolumeCPP-19"> */</front>
<front id="SdVolumeCPP-20">#include "Marlin.h"</front>
<front id="SdVolumeCPP-21">#if ENABLED(SDSUPPORT)</front>
<front id="SdVolumeCPP-22"></front>
<front id="SdVolumeCPP-23">#include "SdVolume.h"</front>
<front id="SdVolumeCPP-24">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-25">#if !USE_MULTIPLE_CARDS</front>
<front id="SdVolumeCPP-26">// raw block cache</front>
<front id="SdVolumeCPP-27">uint32_t SdVolume::cacheBlockNumber_;  // current block number</front>
<front id="SdVolumeCPP-28">cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card</front>
<front id="SdVolumeCPP-29">Sd2Card* SdVolume::sdCard_;            // pointer to SD card object</front>
<front id="SdVolumeCPP-30">bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true</front>
<front id="SdVolumeCPP-31">uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT</front>
<front id="SdVolumeCPP-32">#endif  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeCPP-33">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-34">// find a contiguous group of clusters</front>
<front id="SdVolumeCPP-35">bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {</front>
<front id="SdVolumeCPP-36">  // start of group</front>
<front id="SdVolumeCPP-37">  uint32_t bgnCluster;</front>
<front id="SdVolumeCPP-38">  // end of group</front>
<front id="SdVolumeCPP-39">  uint32_t endCluster;</front>
<front id="SdVolumeCPP-40">  // last cluster of FAT</front>
<front id="SdVolumeCPP-41">  uint32_t fatEnd = clusterCount_ + 1;</front>
<front id="SdVolumeCPP-42"></front>
<front id="SdVolumeCPP-43">  // flag to save place to start next search</front>
<front id="SdVolumeCPP-44">  bool setStart;</front>
<front id="SdVolumeCPP-45"></front>
<front id="SdVolumeCPP-46">  // set search start cluster</front>
<front id="SdVolumeCPP-47">  if (*curCluster) {</front>
<front id="SdVolumeCPP-48">    // try to make file contiguous</front>
<front id="SdVolumeCPP-49">    bgnCluster = *curCluster + 1;</front>
<front id="SdVolumeCPP-50"></front>
<front id="SdVolumeCPP-51">    // don't save new start location</front>
<front id="SdVolumeCPP-52">    setStart = false;</front>
<front id="SdVolumeCPP-53">  } else {</front>
<front id="SdVolumeCPP-54">    // start at likely place for free cluster</front>
<front id="SdVolumeCPP-55">    bgnCluster = allocSearchStart_;</front>
<front id="SdVolumeCPP-56"></front>
<front id="SdVolumeCPP-57">    // save next search start if one cluster</front>
<front id="SdVolumeCPP-58">    setStart = count == 1;</front>
<front id="SdVolumeCPP-59">  }</front>
<front id="SdVolumeCPP-60">  // end of group</front>
<front id="SdVolumeCPP-61">  endCluster = bgnCluster;</front>
<front id="SdVolumeCPP-62"></front>
<front id="SdVolumeCPP-63">  // search the FAT for free clusters</front>
<front id="SdVolumeCPP-64">  for (uint32_t n = 0;; n++, endCluster++) {</front>
<front id="SdVolumeCPP-65">    // can't find space checked all clusters</front>
<front id="SdVolumeCPP-66">    if (n &gt;= clusterCount_) goto fail;</front>
<front id="SdVolumeCPP-67"></front>
<front id="SdVolumeCPP-68">    // past end - start from beginning of FAT</front>
<front id="SdVolumeCPP-69">    if (endCluster &gt; fatEnd) {</front>
<front id="SdVolumeCPP-70">      bgnCluster = endCluster = 2;</front>
<front id="SdVolumeCPP-71">    }</front>
<front id="SdVolumeCPP-72">    uint32_t f;</front>
<front id="SdVolumeCPP-73">    if (!fatGet(endCluster, &f)) goto fail;</front>
<front id="SdVolumeCPP-74"></front>
<front id="SdVolumeCPP-75">    if (f != 0) {</front>
<front id="SdVolumeCPP-76">      // cluster in use try next cluster as bgnCluster</front>
<front id="SdVolumeCPP-77">      bgnCluster = endCluster + 1;</front>
<front id="SdVolumeCPP-78">    } else if ((endCluster - bgnCluster + 1) == count) {</front>
<front id="SdVolumeCPP-79">      // done - found space</front>
<front id="SdVolumeCPP-80">      break;</front>
<front id="SdVolumeCPP-81">    }</front>
<front id="SdVolumeCPP-82">  }</front>
<front id="SdVolumeCPP-83">  // mark end of chain</front>
<front id="SdVolumeCPP-84">  if (!fatPutEOC(endCluster)) goto fail;</front>
<front id="SdVolumeCPP-85"></front>
<front id="SdVolumeCPP-86">  // link clusters</front>
<front id="SdVolumeCPP-87">  while (endCluster &gt; bgnCluster) {</front>
<front id="SdVolumeCPP-88">    if (!fatPut(endCluster - 1, endCluster)) goto fail;</front>
<front id="SdVolumeCPP-89">    endCluster--;</front>
<front id="SdVolumeCPP-90">  }</front>
<front id="SdVolumeCPP-91">  if (*curCluster != 0) {</front>
<front id="SdVolumeCPP-92">    // connect chains</front>
<front id="SdVolumeCPP-93">    if (!fatPut(*curCluster, bgnCluster)) goto fail;</front>
<front id="SdVolumeCPP-94">  }</front>
<front id="SdVolumeCPP-95">  // return first cluster number to caller</front>
<front id="SdVolumeCPP-96">  *curCluster = bgnCluster;</front>
<front id="SdVolumeCPP-97"></front>
<front id="SdVolumeCPP-98">  // remember possible next free cluster</front>
<front id="SdVolumeCPP-99">  if (setStart) allocSearchStart_ = bgnCluster + 1;</front>
<front id="SdVolumeCPP-100"></front>
<front id="SdVolumeCPP-101">  return true;</front>
<front id="SdVolumeCPP-102"></front>
<front id="SdVolumeCPP-103"> fail:</front>
<front id="SdVolumeCPP-104">  return false;</front>
<front id="SdVolumeCPP-105">}</front>
<front id="SdVolumeCPP-106">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-107">bool SdVolume::cacheFlush() {</front>
<front id="SdVolumeCPP-108">  if (cacheDirty_) {</front>
<front id="SdVolumeCPP-109">    if (!sdCard_-&gt;writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {</front>
<front id="SdVolumeCPP-110">      goto fail;</front>
<front id="SdVolumeCPP-111">    }</front>
<front id="SdVolumeCPP-112">    // mirror FAT tables</front>
<front id="SdVolumeCPP-113">    if (cacheMirrorBlock_) {</front>
<front id="SdVolumeCPP-114">      if (!sdCard_-&gt;writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {</front>
<front id="SdVolumeCPP-115">        goto fail;</front>
<front id="SdVolumeCPP-116">      }</front>
<front id="SdVolumeCPP-117">      cacheMirrorBlock_ = 0;</front>
<front id="SdVolumeCPP-118">    }</front>
<front id="SdVolumeCPP-119">    cacheDirty_ = 0;</front>
<front id="SdVolumeCPP-120">  }</front>
<front id="SdVolumeCPP-121">  return true;</front>
<front id="SdVolumeCPP-122"></front>
<front id="SdVolumeCPP-123"> fail:</front>
<front id="SdVolumeCPP-124">  return false;</front>
<front id="SdVolumeCPP-125">}</front>
<front id="SdVolumeCPP-126">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-127">bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {</front>
<front id="SdVolumeCPP-128">  if (cacheBlockNumber_ != blockNumber) {</front>
<front id="SdVolumeCPP-129">    if (!cacheFlush()) goto fail;</front>
<front id="SdVolumeCPP-130">    if (!sdCard_-&gt;readBlock(blockNumber, cacheBuffer_.data)) goto fail;</front>
<front id="SdVolumeCPP-131">    cacheBlockNumber_ = blockNumber;</front>
<front id="SdVolumeCPP-132">  }</front>
<front id="SdVolumeCPP-133">  if (dirty) cacheDirty_ = true;</front>
<front id="SdVolumeCPP-134">  return true;</front>
<front id="SdVolumeCPP-135"></front>
<front id="SdVolumeCPP-136"> fail:</front>
<front id="SdVolumeCPP-137">  return false;</front>
<front id="SdVolumeCPP-138">}</front>
<front id="SdVolumeCPP-139">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-140">// return the size in bytes of a cluster chain</front>
<front id="SdVolumeCPP-141">bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {</front>
<front id="SdVolumeCPP-142">  uint32_t s = 0;</front>
<front id="SdVolumeCPP-143">  do {</front>
<front id="SdVolumeCPP-144">    if (!fatGet(cluster, &cluster)) goto fail;</front>
<front id="SdVolumeCPP-145">    s += 512UL &lt;&lt; clusterSizeShift_;</front>
<front id="SdVolumeCPP-146">  } while (!isEOC(cluster));</front>
<front id="SdVolumeCPP-147">  *size = s;</front>
<front id="SdVolumeCPP-148">  return true;</front>
<front id="SdVolumeCPP-149"></front>
<front id="SdVolumeCPP-150"> fail:</front>
<front id="SdVolumeCPP-151">  return false;</front>
<front id="SdVolumeCPP-152">}</front>
<front id="SdVolumeCPP-153">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-154">// Fetch a FAT entry</front>
<front id="SdVolumeCPP-155">bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {</front>
<front id="SdVolumeCPP-156">  uint32_t lba;</front>
<front id="SdVolumeCPP-157">  if (cluster &gt; (clusterCount_ + 1)) goto fail;</front>
<front id="SdVolumeCPP-158">  if (FAT12_SUPPORT && fatType_ == 12) {</front>
<front id="SdVolumeCPP-159">    uint16_t index = cluster;</front>
<front id="SdVolumeCPP-160">    index += index &gt;&gt; 1;</front>
<front id="SdVolumeCPP-161">    lba = fatStartBlock_ + (index &gt;&gt; 9);</front>
<front id="SdVolumeCPP-162">    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-163">    index &= 0X1FF;</front>
<front id="SdVolumeCPP-164">    uint16_t tmp = cacheBuffer_.data[index];</front>
<front id="SdVolumeCPP-165">    index++;</front>
<front id="SdVolumeCPP-166">    if (index == 512) {</front>
<front id="SdVolumeCPP-167">      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-168">      index = 0;</front>
<front id="SdVolumeCPP-169">    }</front>
<front id="SdVolumeCPP-170">    tmp |= cacheBuffer_.data[index] &lt;&lt; 8;</front>
<front id="SdVolumeCPP-171">    *value = cluster & 1 ? tmp &gt;&gt; 4 : tmp & 0XFFF;</front>
<front id="SdVolumeCPP-172">    return true;</front>
<front id="SdVolumeCPP-173">  }</front>
<front id="SdVolumeCPP-174">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-175">    lba = fatStartBlock_ + (cluster &gt;&gt; 8);</front>
<front id="SdVolumeCPP-176">  } else if (fatType_ == 32) {</front>
<front id="SdVolumeCPP-177">    lba = fatStartBlock_ + (cluster &gt;&gt; 7);</front>
<front id="SdVolumeCPP-178">  } else {</front>
<front id="SdVolumeCPP-179">    goto fail;</front>
<front id="SdVolumeCPP-180">  }</front>
<front id="SdVolumeCPP-181">  if (lba != cacheBlockNumber_) {</front>
<front id="SdVolumeCPP-182">    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-183">  }</front>
<front id="SdVolumeCPP-184">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-185">    *value = cacheBuffer_.fat16[cluster & 0XFF];</front>
<front id="SdVolumeCPP-186">  } else {</front>
<front id="SdVolumeCPP-187">    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;</front>
<front id="SdVolumeCPP-188">  }</front>
<front id="SdVolumeCPP-189">  return true;</front>
<front id="SdVolumeCPP-190"></front>
<front id="SdVolumeCPP-191"> fail:</front>
<front id="SdVolumeCPP-192">  return false;</front>
<front id="SdVolumeCPP-193">}</front>
<front id="SdVolumeCPP-194">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-195">// Store a FAT entry</front>
<front id="SdVolumeCPP-196">bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {</front>
<front id="SdVolumeCPP-197">  uint32_t lba;</front>
<front id="SdVolumeCPP-198">  // error if reserved cluster</front>
<front id="SdVolumeCPP-199">  if (cluster &lt; 2) goto fail;</front>
<front id="SdVolumeCPP-200"></front>
<front id="SdVolumeCPP-201">  // error if not in FAT</front>
<front id="SdVolumeCPP-202">  if (cluster &gt; (clusterCount_ + 1)) goto fail;</front>
<front id="SdVolumeCPP-203"></front>
<front id="SdVolumeCPP-204">  if (FAT12_SUPPORT && fatType_ == 12) {</front>
<front id="SdVolumeCPP-205">    uint16_t index = cluster;</front>
<front id="SdVolumeCPP-206">    index += index &gt;&gt; 1;</front>
<front id="SdVolumeCPP-207">    lba = fatStartBlock_ + (index &gt;&gt; 9);</front>
<front id="SdVolumeCPP-208">    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdVolumeCPP-209">    // mirror second FAT</front>
<front id="SdVolumeCPP-210">    if (fatCount_ &gt; 1) cacheMirrorBlock_ = lba + blocksPerFat_;</front>
<front id="SdVolumeCPP-211">    index &= 0X1FF;</front>
<front id="SdVolumeCPP-212">    uint8_t tmp = value;</front>
<front id="SdVolumeCPP-213">    if (cluster & 1) {</front>
<front id="SdVolumeCPP-214">      tmp = (cacheBuffer_.data[index] & 0XF) | tmp &lt;&lt; 4;</front>
<front id="SdVolumeCPP-215">    }</front>
<front id="SdVolumeCPP-216">    cacheBuffer_.data[index] = tmp;</front>
<front id="SdVolumeCPP-217">    index++;</front>
<front id="SdVolumeCPP-218">    if (index == 512) {</front>
<front id="SdVolumeCPP-219">      lba++;</front>
<front id="SdVolumeCPP-220">      index = 0;</front>
<front id="SdVolumeCPP-221">      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdVolumeCPP-222">      // mirror second FAT</front>
<front id="SdVolumeCPP-223">      if (fatCount_ &gt; 1) cacheMirrorBlock_ = lba + blocksPerFat_;</front>
<front id="SdVolumeCPP-224">    }</front>
<front id="SdVolumeCPP-225">    tmp = value &gt;&gt; 4;</front>
<front id="SdVolumeCPP-226">    if (!(cluster & 1)) {</front>
<front id="SdVolumeCPP-227">      tmp = ((cacheBuffer_.data[index] & 0XF0)) | tmp &gt;&gt; 4;</front>
<front id="SdVolumeCPP-228">    }</front>
<front id="SdVolumeCPP-229">    cacheBuffer_.data[index] = tmp;</front>
<front id="SdVolumeCPP-230">    return true;</front>
<front id="SdVolumeCPP-231">  }</front>
<front id="SdVolumeCPP-232">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-233">    lba = fatStartBlock_ + (cluster &gt;&gt; 8);</front>
<front id="SdVolumeCPP-234">  } else if (fatType_ == 32) {</front>
<front id="SdVolumeCPP-235">    lba = fatStartBlock_ + (cluster &gt;&gt; 7);</front>
<front id="SdVolumeCPP-236">  } else {</front>
<front id="SdVolumeCPP-237">    goto fail;</front>
<front id="SdVolumeCPP-238">  }</front>
<front id="SdVolumeCPP-239">  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto fail;</front>
<front id="SdVolumeCPP-240">  // store entry</front>
<front id="SdVolumeCPP-241">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-242">    cacheBuffer_.fat16[cluster & 0XFF] = value;</front>
<front id="SdVolumeCPP-243">  } else {</front>
<front id="SdVolumeCPP-244">    cacheBuffer_.fat32[cluster & 0X7F] = value;</front>
<front id="SdVolumeCPP-245">  }</front>
<front id="SdVolumeCPP-246">  // mirror second FAT</front>
<front id="SdVolumeCPP-247">  if (fatCount_ &gt; 1) cacheMirrorBlock_ = lba + blocksPerFat_;</front>
<front id="SdVolumeCPP-248">  return true;</front>
<front id="SdVolumeCPP-249"></front>
<front id="SdVolumeCPP-250"> fail:</front>
<front id="SdVolumeCPP-251">  return false;</front>
<front id="SdVolumeCPP-252">}</front>
<front id="SdVolumeCPP-253">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-254">// free a cluster chain</front>
<front id="SdVolumeCPP-255">bool SdVolume::freeChain(uint32_t cluster) {</front>
<front id="SdVolumeCPP-256">  uint32_t next;</front>
<front id="SdVolumeCPP-257"></front>
<front id="SdVolumeCPP-258">  // clear free cluster location</front>
<front id="SdVolumeCPP-259">  allocSearchStart_ = 2;</front>
<front id="SdVolumeCPP-260"></front>
<front id="SdVolumeCPP-261">  do {</front>
<front id="SdVolumeCPP-262">    if (!fatGet(cluster, &next)) goto fail;</front>
<front id="SdVolumeCPP-263"></front>
<front id="SdVolumeCPP-264">    // free cluster</front>
<front id="SdVolumeCPP-265">    if (!fatPut(cluster, 0)) goto fail;</front>
<front id="SdVolumeCPP-266"></front>
<front id="SdVolumeCPP-267">    cluster = next;</front>
<front id="SdVolumeCPP-268">  } while (!isEOC(cluster));</front>
<front id="SdVolumeCPP-269"></front>
<front id="SdVolumeCPP-270">  return true;</front>
<front id="SdVolumeCPP-271"></front>
<front id="SdVolumeCPP-272"> fail:</front>
<front id="SdVolumeCPP-273">  return false;</front>
<front id="SdVolumeCPP-274">}</front>
<front id="SdVolumeCPP-275">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-276">/** Volume free space in clusters.</front>
<front id="SdVolumeCPP-277"> *</front>
<front id="SdVolumeCPP-278"> * \return Count of free clusters for success or -1 if an error occurs.</front>
<front id="SdVolumeCPP-279"> */</front>
<front id="SdVolumeCPP-280">int32_t SdVolume::freeClusterCount() {</front>
<front id="SdVolumeCPP-281">  uint32_t free = 0;</front>
<front id="SdVolumeCPP-282">  uint16_t n;</front>
<front id="SdVolumeCPP-283">  uint32_t todo = clusterCount_ + 2;</front>
<front id="SdVolumeCPP-284"></front>
<front id="SdVolumeCPP-285">  if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-286">    n = 256;</front>
<front id="SdVolumeCPP-287">  } else if (fatType_ == 32) {</front>
<front id="SdVolumeCPP-288">    n = 128;</front>
<front id="SdVolumeCPP-289">  } else {</front>
<front id="SdVolumeCPP-290">    // put FAT12 here</front>
<front id="SdVolumeCPP-291">    return -1;</front>
<front id="SdVolumeCPP-292">  }</front>
<front id="SdVolumeCPP-293"></front>
<front id="SdVolumeCPP-294">  for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {</front>
<front id="SdVolumeCPP-295">    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;</front>
<front id="SdVolumeCPP-296">    if (todo &lt; n) n = todo;</front>
<front id="SdVolumeCPP-297">    if (fatType_ == 16) {</front>
<front id="SdVolumeCPP-298">      for (uint16_t i = 0; i &lt; n; i++) {</front>
<front id="SdVolumeCPP-299">        if (cacheBuffer_.fat16[i] == 0) free++;</front>
<front id="SdVolumeCPP-300">      }</front>
<front id="SdVolumeCPP-301">    } else {</front>
<front id="SdVolumeCPP-302">      for (uint16_t i = 0; i &lt; n; i++) {</front>
<front id="SdVolumeCPP-303">        if (cacheBuffer_.fat32[i] == 0) free++;</front>
<front id="SdVolumeCPP-304">      }</front>
<front id="SdVolumeCPP-305">    }</front>
<front id="SdVolumeCPP-306">  }</front>
<front id="SdVolumeCPP-307">  return free;</front>
<front id="SdVolumeCPP-308">}</front>
<front id="SdVolumeCPP-309">//------------------------------------------------------------------------------</front>
<front id="SdVolumeCPP-310">/** Initialize a FAT volume.</front>
<front id="SdVolumeCPP-311"> *</front>
<front id="SdVolumeCPP-312"> * \param[in] dev The SD card where the volume is located.</front>
<front id="SdVolumeCPP-313"> *</front>
<front id="SdVolumeCPP-314"> * \param[in] part The partition to be used.  Legal values for \a part are</front>
<front id="SdVolumeCPP-315"> * 1-4 to use the corresponding partition on a device formatted with</front>
<front id="SdVolumeCPP-316"> * a MBR, Master Boot Record, or zero if the device is formatted as</front>
<front id="SdVolumeCPP-317"> * a super floppy with the FAT boot sector in block zero.</front>
<front id="SdVolumeCPP-318"> *</front>
<front id="SdVolumeCPP-319"> * \return The value one, true, is returned for success and</front>
<front id="SdVolumeCPP-320"> * the value zero, false, is returned for failure.  Reasons for</front>
<front id="SdVolumeCPP-321"> * failure include not finding a valid partition, not finding a valid</front>
<front id="SdVolumeCPP-322"> * FAT file system in the specified partition or an I/O error.</front>
<front id="SdVolumeCPP-323"> */</front>
<front id="SdVolumeCPP-324">bool SdVolume::init(Sd2Card* dev, uint8_t part) {</front>
<front id="SdVolumeCPP-325">  uint32_t totalBlocks;</front>
<front id="SdVolumeCPP-326">  uint32_t volumeStartBlock = 0;</front>
<front id="SdVolumeCPP-327">  fat32_boot_t* fbs;</front>
<front id="SdVolumeCPP-328"></front>
<front id="SdVolumeCPP-329">  sdCard_ = dev;</front>
<front id="SdVolumeCPP-330">  fatType_ = 0;</front>
<front id="SdVolumeCPP-331">  allocSearchStart_ = 2;</front>
<front id="SdVolumeCPP-332">  cacheDirty_ = 0;  // cacheFlush() will write block if true</front>
<front id="SdVolumeCPP-333">  cacheMirrorBlock_ = 0;</front>
<front id="SdVolumeCPP-334">  cacheBlockNumber_ = 0XFFFFFFFF;</front>
<front id="SdVolumeCPP-335"></front>
<front id="SdVolumeCPP-336">  // if part == 0 assume super floppy with FAT boot sector in block zero</front>
<front id="SdVolumeCPP-337">  // if part &gt; 0 assume mbr volume with partition table</front>
<front id="SdVolumeCPP-338">  if (part) {</front>
<front id="SdVolumeCPP-339">    if (part &gt; 4)goto fail;</front>
<front id="SdVolumeCPP-340">    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-341">    part_t* p = &cacheBuffer_.mbr.part[part-1];</front>
<front id="SdVolumeCPP-342">    if ((p-&gt;boot & 0X7F) !=0  ||</front>
<front id="SdVolumeCPP-343">      p-&gt;totalSectors &lt; 100 ||</front>
<front id="SdVolumeCPP-344">      p-&gt;firstSector == 0) {</front>
<front id="SdVolumeCPP-345">      // not a valid partition</front>
<front id="SdVolumeCPP-346">      goto fail;</front>
<front id="SdVolumeCPP-347">    }</front>
<front id="SdVolumeCPP-348">    volumeStartBlock = p-&gt;firstSector;</front>
<front id="SdVolumeCPP-349">  }</front>
<front id="SdVolumeCPP-350">  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto fail;</front>
<front id="SdVolumeCPP-351">  fbs = &cacheBuffer_.fbs32;</front>
<front id="SdVolumeCPP-352">  if (fbs-&gt;bytesPerSector != 512 ||</front>
<front id="SdVolumeCPP-353">    fbs-&gt;fatCount == 0 ||</front>
<front id="SdVolumeCPP-354">    fbs-&gt;reservedSectorCount == 0 ||</front>
<front id="SdVolumeCPP-355">    fbs-&gt;sectorsPerCluster == 0) {</front>
<front id="SdVolumeCPP-356">       // not valid FAT volume</front>
<front id="SdVolumeCPP-357">      goto fail;</front>
<front id="SdVolumeCPP-358">  }</front>
<front id="SdVolumeCPP-359">  fatCount_ = fbs-&gt;fatCount;</front>
<front id="SdVolumeCPP-360">  blocksPerCluster_ = fbs-&gt;sectorsPerCluster;</front>
<front id="SdVolumeCPP-361">  // determine shift that is same as multiply by blocksPerCluster_</front>
<front id="SdVolumeCPP-362">  clusterSizeShift_ = 0;</front>
<front id="SdVolumeCPP-363">  while (blocksPerCluster_ != BIT(clusterSizeShift_)) {</front>
<front id="SdVolumeCPP-364">    // error if not power of 2</front>
<front id="SdVolumeCPP-365">    if (clusterSizeShift_++ &gt; 7) goto fail;</front>
<front id="SdVolumeCPP-366">  }</front>
<front id="SdVolumeCPP-367">  blocksPerFat_ = fbs-&gt;sectorsPerFat16 ?</front>
<front id="SdVolumeCPP-368">                    fbs-&gt;sectorsPerFat16 : fbs-&gt;sectorsPerFat32;</front>
<front id="SdVolumeCPP-369"></front>
<front id="SdVolumeCPP-370">  fatStartBlock_ = volumeStartBlock + fbs-&gt;reservedSectorCount;</front>
<front id="SdVolumeCPP-371"></front>
<front id="SdVolumeCPP-372">  // count for FAT16 zero for FAT32</front>
<front id="SdVolumeCPP-373">  rootDirEntryCount_ = fbs-&gt;rootDirEntryCount;</front>
<front id="SdVolumeCPP-374"></front>
<front id="SdVolumeCPP-375">  // directory start for FAT16 dataStart for FAT32</front>
<front id="SdVolumeCPP-376">  rootDirStart_ = fatStartBlock_ + fbs-&gt;fatCount * blocksPerFat_;</front>
<front id="SdVolumeCPP-377"></front>
<front id="SdVolumeCPP-378">  // data start for FAT16 and FAT32</front>
<front id="SdVolumeCPP-379">  dataStartBlock_ = rootDirStart_ + ((32 * fbs-&gt;rootDirEntryCount + 511)/512);</front>
<front id="SdVolumeCPP-380"></front>
<front id="SdVolumeCPP-381">  // total blocks for FAT16 or FAT32</front>
<front id="SdVolumeCPP-382">  totalBlocks = fbs-&gt;totalSectors16 ?</front>
<front id="SdVolumeCPP-383">                           fbs-&gt;totalSectors16 : fbs-&gt;totalSectors32;</front>
<front id="SdVolumeCPP-384">  // total data blocks</front>
<front id="SdVolumeCPP-385">  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);</front>
<front id="SdVolumeCPP-386"></front>
<front id="SdVolumeCPP-387">  // divide by cluster size to get cluster count</front>
<front id="SdVolumeCPP-388">  clusterCount_ &gt;&gt;= clusterSizeShift_;</front>
<front id="SdVolumeCPP-389"></front>
<front id="SdVolumeCPP-390">  // FAT type is determined by cluster count</front>
<front id="SdVolumeCPP-391">  if (clusterCount_ &lt; 4085) {</front>
<front id="SdVolumeCPP-392">    fatType_ = 12;</front>
<front id="SdVolumeCPP-393">    if (!FAT12_SUPPORT) goto fail;</front>
<front id="SdVolumeCPP-394">  } else if (clusterCount_ &lt; 65525) {</front>
<front id="SdVolumeCPP-395">    fatType_ = 16;</front>
<front id="SdVolumeCPP-396">  } else {</front>
<front id="SdVolumeCPP-397">    rootDirStart_ = fbs-&gt;fat32RootCluster;</front>
<front id="SdVolumeCPP-398">    fatType_ = 32;</front>
<front id="SdVolumeCPP-399">  }</front>
<front id="SdVolumeCPP-400">  return true;</front>
<front id="SdVolumeCPP-401"></front>
<front id="SdVolumeCPP-402"> fail:</front>
<front id="SdVolumeCPP-403">  return false;</front>
<front id="SdVolumeCPP-404">}</front>
<front id="SdVolumeCPP-405">#endif</front>
 </pre>
<h1 id="SdVolumeHtitle" >SdVolume.h</h1>
<pre id="SdVolumeH"  class="prettyprint linenums"><front id="SdVolumeH-1">/* Arduino SdFat Library</front>
<front id="SdVolumeH-2"> * Copyright (C) 2009 by William Greiman</front>
<front id="SdVolumeH-3"> *</front>
<front id="SdVolumeH-4"> * This file is part of the Arduino SdFat Library</front>
<front id="SdVolumeH-5"> *</front>
<front id="SdVolumeH-6"> * This Library is free software: you can redistribute it and/or modify</front>
<front id="SdVolumeH-7"> * it under the terms of the GNU General Public License as published by</front>
<front id="SdVolumeH-8"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="SdVolumeH-9"> * (at your option) any later version.</front>
<front id="SdVolumeH-10"> *</front>
<front id="SdVolumeH-11"> * This Library is distributed in the hope that it will be useful,</front>
<front id="SdVolumeH-12"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="SdVolumeH-13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="SdVolumeH-14"> * GNU General Public License for more details.</front>
<front id="SdVolumeH-15"> *</front>
<front id="SdVolumeH-16"> * You should have received a copy of the GNU General Public License</front>
<front id="SdVolumeH-17"> * along with the Arduino SdFat Library.  If not, see</front>
<front id="SdVolumeH-18"> * &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="SdVolumeH-19"> */</front>
<front id="SdVolumeH-20">#include "Marlin.h"</front>
<front id="SdVolumeH-21">#if ENABLED(SDSUPPORT)</front>
<front id="SdVolumeH-22">#ifndef SdVolume_h</front>
<front id="SdVolumeH-23">#define SdVolume_h</front>
<front id="SdVolumeH-24">/**</front>
<front id="SdVolumeH-25"> * \file</front>
<front id="SdVolumeH-26"> * \brief SdVolume class</front>
<front id="SdVolumeH-27"> */</front>
<front id="SdVolumeH-28">#include "SdFatConfig.h"</front>
<front id="SdVolumeH-29">#include "Sd2Card.h"</front>
<front id="SdVolumeH-30">#include "SdFatStructs.h"</front>
<front id="SdVolumeH-31"></front>
<front id="SdVolumeH-32">//==============================================================================</front>
<front id="SdVolumeH-33">// SdVolume class</front>
<front id="SdVolumeH-34">/**</front>
<front id="SdVolumeH-35"> * \brief Cache for an SD data block</front>
<front id="SdVolumeH-36"> */</front>
<front id="SdVolumeH-37">union cache_t {</front>
<front id="SdVolumeH-38">           /** Used to access cached file data blocks. */</front>
<front id="SdVolumeH-39">  uint8_t  data[512];</front>
<front id="SdVolumeH-40">           /** Used to access cached FAT16 entries. */</front>
<front id="SdVolumeH-41">  uint16_t fat16[256];</front>
<front id="SdVolumeH-42">           /** Used to access cached FAT32 entries. */</front>
<front id="SdVolumeH-43">  uint32_t fat32[128];</front>
<front id="SdVolumeH-44">           /** Used to access cached directory entries. */</front>
<front id="SdVolumeH-45">  dir_t    dir[16];</front>
<front id="SdVolumeH-46">           /** Used to access a cached Master Boot Record. */</front>
<front id="SdVolumeH-47">  mbr_t    mbr;</front>
<front id="SdVolumeH-48">           /** Used to access to a cached FAT boot sector. */</front>
<front id="SdVolumeH-49">  fat_boot_t fbs;</front>
<front id="SdVolumeH-50">           /** Used to access to a cached FAT32 boot sector. */</front>
<front id="SdVolumeH-51">  fat32_boot_t fbs32;</front>
<front id="SdVolumeH-52">           /** Used to access to a cached FAT32 FSINFO sector. */</front>
<front id="SdVolumeH-53">  fat32_fsinfo_t fsinfo;</front>
<front id="SdVolumeH-54">};</front>
<front id="SdVolumeH-55">//------------------------------------------------------------------------------</front>
<front id="SdVolumeH-56">/**</front>
<front id="SdVolumeH-57"> * \class SdVolume</front>
<front id="SdVolumeH-58"> * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.</front>
<front id="SdVolumeH-59"> */</front>
<front id="SdVolumeH-60">class SdVolume {</front>
<front id="SdVolumeH-61"> public:</front>
<front id="SdVolumeH-62">  /** Create an instance of SdVolume */</front>
<front id="SdVolumeH-63">  SdVolume() : fatType_(0) {}</front>
<front id="SdVolumeH-64">  /** Clear the cache and returns a pointer to the cache.  Used by the WaveRP</front>
<front id="SdVolumeH-65">   * recorder to do raw write to the SD card.  Not for normal apps.</front>
<front id="SdVolumeH-66">   * \return A pointer to the cache buffer or zero if an error occurs.</front>
<front id="SdVolumeH-67">   */</front>
<front id="SdVolumeH-68">  cache_t* cacheClear() {</front>
<front id="SdVolumeH-69">    if (!cacheFlush()) return 0;</front>
<front id="SdVolumeH-70">    cacheBlockNumber_ = 0XFFFFFFFF;</front>
<front id="SdVolumeH-71">    return &cacheBuffer_;</front>
<front id="SdVolumeH-72">  }</front>
<front id="SdVolumeH-73">  /** Initialize a FAT volume.  Try partition one first then try super</front>
<front id="SdVolumeH-74">   * floppy format.</front>
<front id="SdVolumeH-75">   *</front>
<front id="SdVolumeH-76">   * \param[in] dev The Sd2Card where the volume is located.</front>
<front id="SdVolumeH-77">   *</front>
<front id="SdVolumeH-78">   * \return The value one, true, is returned for success and</front>
<front id="SdVolumeH-79">   * the value zero, false, is returned for failure.  Reasons for</front>
<front id="SdVolumeH-80">   * failure include not finding a valid partition, not finding a valid</front>
<front id="SdVolumeH-81">   * FAT file system or an I/O error.</front>
<front id="SdVolumeH-82">   */</front>
<front id="SdVolumeH-83">  bool init(Sd2Card* dev) { return init(dev, 1) ? true : init(dev, 0);}</front>
<front id="SdVolumeH-84">  bool init(Sd2Card* dev, uint8_t part);</front>
<front id="SdVolumeH-85"></front>
<front id="SdVolumeH-86">  // inline functions that return volume info</front>
<front id="SdVolumeH-87">  /** \return The volume's cluster size in blocks. */</front>
<front id="SdVolumeH-88">  uint8_t blocksPerCluster() const {return blocksPerCluster_;}</front>
<front id="SdVolumeH-89">  /** \return The number of blocks in one FAT. */</front>
<front id="SdVolumeH-90">  uint32_t blocksPerFat()  const {return blocksPerFat_;}</front>
<front id="SdVolumeH-91">  /** \return The total number of clusters in the volume. */</front>
<front id="SdVolumeH-92">  uint32_t clusterCount() const {return clusterCount_;}</front>
<front id="SdVolumeH-93">  /** \return The shift count required to multiply by blocksPerCluster. */</front>
<front id="SdVolumeH-94">  uint8_t clusterSizeShift() const {return clusterSizeShift_;}</front>
<front id="SdVolumeH-95">  /** \return The logical block number for the start of file data. */</front>
<front id="SdVolumeH-96">  uint32_t dataStartBlock() const {return dataStartBlock_;}</front>
<front id="SdVolumeH-97">  /** \return The number of FAT structures on the volume. */</front>
<front id="SdVolumeH-98">  uint8_t fatCount() const {return fatCount_;}</front>
<front id="SdVolumeH-99">  /** \return The logical block number for the start of the first FAT. */</front>
<front id="SdVolumeH-100">  uint32_t fatStartBlock() const {return fatStartBlock_;}</front>
<front id="SdVolumeH-101">  /** \return The FAT type of the volume. Values are 12, 16 or 32. */</front>
<front id="SdVolumeH-102">  uint8_t fatType() const {return fatType_;}</front>
<front id="SdVolumeH-103">  int32_t freeClusterCount();</front>
<front id="SdVolumeH-104">  /** \return The number of entries in the root directory for FAT16 volumes. */</front>
<front id="SdVolumeH-105">  uint32_t rootDirEntryCount() const {return rootDirEntryCount_;}</front>
<front id="SdVolumeH-106">  /** \return The logical block number for the start of the root directory</front>
<front id="SdVolumeH-107">       on FAT16 volumes or the first cluster number on FAT32 volumes. */</front>
<front id="SdVolumeH-108">  uint32_t rootDirStart() const {return rootDirStart_;}</front>
<front id="SdVolumeH-109">  /** Sd2Card object for this volume</front>
<front id="SdVolumeH-110">   * \return pointer to Sd2Card object.</front>
<front id="SdVolumeH-111">   */</front>
<front id="SdVolumeH-112">  Sd2Card* sdCard() {return sdCard_;}</front>
<front id="SdVolumeH-113">  /** Debug access to FAT table</front>
<front id="SdVolumeH-114">   *</front>
<front id="SdVolumeH-115">   * \param[in] n cluster number.</front>
<front id="SdVolumeH-116">   * \param[out] v value of entry</front>
<front id="SdVolumeH-117">   * \return true for success or false for failure</front>
<front id="SdVolumeH-118">   */</front>
<front id="SdVolumeH-119">  bool dbgFat(uint32_t n, uint32_t* v) {return fatGet(n, v);}</front>
<front id="SdVolumeH-120">//------------------------------------------------------------------------------</front>
<front id="SdVolumeH-121"> private:</front>
<front id="SdVolumeH-122">  // Allow SdBaseFile access to SdVolume private data.</front>
<front id="SdVolumeH-123">  friend class SdBaseFile;</front>
<front id="SdVolumeH-124"></front>
<front id="SdVolumeH-125">  // value for dirty argument in cacheRawBlock to indicate read from cache</front>
<front id="SdVolumeH-126">  static bool const CACHE_FOR_READ = false;</front>
<front id="SdVolumeH-127">  // value for dirty argument in cacheRawBlock to indicate write to cache</front>
<front id="SdVolumeH-128">  static bool const CACHE_FOR_WRITE = true;</front>
<front id="SdVolumeH-129"></front>
<front id="SdVolumeH-130">#if USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-131">  cache_t cacheBuffer_;        // 512 byte cache for device blocks</front>
<front id="SdVolumeH-132">  uint32_t cacheBlockNumber_;  // Logical number of block in the cache</front>
<front id="SdVolumeH-133">  Sd2Card* sdCard_;            // Sd2Card object for cache</front>
<front id="SdVolumeH-134">  bool cacheDirty_;            // cacheFlush() will write block if true</front>
<front id="SdVolumeH-135">  uint32_t cacheMirrorBlock_;  // block number for mirror FAT</front>
<front id="SdVolumeH-136">#else  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-137">  static cache_t cacheBuffer_;        // 512 byte cache for device blocks</front>
<front id="SdVolumeH-138">  static uint32_t cacheBlockNumber_;  // Logical number of block in the cache</front>
<front id="SdVolumeH-139">  static Sd2Card* sdCard_;            // Sd2Card object for cache</front>
<front id="SdVolumeH-140">  static bool cacheDirty_;            // cacheFlush() will write block if true</front>
<front id="SdVolumeH-141">  static uint32_t cacheMirrorBlock_;  // block number for mirror FAT</front>
<front id="SdVolumeH-142">#endif  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-143">  uint32_t allocSearchStart_;   // start cluster for alloc search</front>
<front id="SdVolumeH-144">  uint8_t blocksPerCluster_;    // cluster size in blocks</front>
<front id="SdVolumeH-145">  uint32_t blocksPerFat_;       // FAT size in blocks</front>
<front id="SdVolumeH-146">  uint32_t clusterCount_;       // clusters in one FAT</front>
<front id="SdVolumeH-147">  uint8_t clusterSizeShift_;    // shift to convert cluster count to block count</front>
<front id="SdVolumeH-148">  uint32_t dataStartBlock_;     // first data block number</front>
<front id="SdVolumeH-149">  uint8_t fatCount_;            // number of FATs on volume</front>
<front id="SdVolumeH-150">  uint32_t fatStartBlock_;      // start block for first FAT</front>
<front id="SdVolumeH-151">  uint8_t fatType_;             // volume type (12, 16, OR 32)</front>
<front id="SdVolumeH-152">  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir</front>
<front id="SdVolumeH-153">  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32</front>
<front id="SdVolumeH-154">  //----------------------------------------------------------------------------</front>
<front id="SdVolumeH-155">  bool allocContiguous(uint32_t count, uint32_t* curCluster);</front>
<front id="SdVolumeH-156">  uint8_t blockOfCluster(uint32_t position) const {</front>
<front id="SdVolumeH-157">          return (position &gt;&gt; 9) & (blocksPerCluster_ - 1);}</front>
<front id="SdVolumeH-158">  uint32_t clusterStartBlock(uint32_t cluster) const {</front>
<front id="SdVolumeH-159">           return dataStartBlock_ + ((cluster - 2) &lt;&lt; clusterSizeShift_);}</front>
<front id="SdVolumeH-160">  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {</front>
<front id="SdVolumeH-161">           return clusterStartBlock(cluster) + blockOfCluster(position);}</front>
<front id="SdVolumeH-162">  cache_t *cache() {return &cacheBuffer_;}</front>
<front id="SdVolumeH-163">  uint32_t cacheBlockNumber() {return cacheBlockNumber_;}</front>
<front id="SdVolumeH-164">#if USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-165">  bool cacheFlush();</front>
<front id="SdVolumeH-166">  bool cacheRawBlock(uint32_t blockNumber, bool dirty);</front>
<front id="SdVolumeH-167">#else  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-168">  static bool cacheFlush();</front>
<front id="SdVolumeH-169">  static bool cacheRawBlock(uint32_t blockNumber, bool dirty);</front>
<front id="SdVolumeH-170">#endif  // USE_MULTIPLE_CARDS</front>
<front id="SdVolumeH-171">  // used by SdBaseFile write to assign cache to SD location</front>
<front id="SdVolumeH-172">  void cacheSetBlockNumber(uint32_t blockNumber, bool dirty) {</front>
<front id="SdVolumeH-173">    cacheDirty_ = dirty;</front>
<front id="SdVolumeH-174">    cacheBlockNumber_  = blockNumber;</front>
<front id="SdVolumeH-175">  }</front>
<front id="SdVolumeH-176">  void cacheSetDirty() {cacheDirty_ |= CACHE_FOR_WRITE;}</front>
<front id="SdVolumeH-177">  bool chainSize(uint32_t beginCluster, uint32_t* size);</front>
<front id="SdVolumeH-178">  bool fatGet(uint32_t cluster, uint32_t* value);</front>
<front id="SdVolumeH-179">  bool fatPut(uint32_t cluster, uint32_t value);</front>
<front id="SdVolumeH-180">  bool fatPutEOC(uint32_t cluster) {</front>
<front id="SdVolumeH-181">    return fatPut(cluster, 0x0FFFFFFF);</front>
<front id="SdVolumeH-182">  }</front>
<front id="SdVolumeH-183">  bool freeChain(uint32_t cluster);</front>
<front id="SdVolumeH-184">  bool isEOC(uint32_t cluster) const {</front>
<front id="SdVolumeH-185">    if (FAT12_SUPPORT && fatType_ == 12) return  cluster &gt;= FAT12EOC_MIN;</front>
<front id="SdVolumeH-186">    if (fatType_ == 16) return cluster &gt;= FAT16EOC_MIN;</front>
<front id="SdVolumeH-187">    return  cluster &gt;= FAT32EOC_MIN;</front>
<front id="SdVolumeH-188">  }</front>
<front id="SdVolumeH-189">  bool readBlock(uint32_t block, uint8_t* dst) {</front>
<front id="SdVolumeH-190">    return sdCard_-&gt;readBlock(block, dst);}</front>
<front id="SdVolumeH-191">  bool writeBlock(uint32_t block, const uint8_t* dst) {</front>
<front id="SdVolumeH-192">    return sdCard_-&gt;writeBlock(block, dst);</front>
<front id="SdVolumeH-193">  }</front>
<front id="SdVolumeH-194">//------------------------------------------------------------------------------</front>
<front id="SdVolumeH-195">  // Deprecated functions  - suppress cpplint warnings with NOLINT comment</front>
<front id="SdVolumeH-196">#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)</front>
<front id="SdVolumeH-197"> public:</front>
<front id="SdVolumeH-198">  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev);</front>
<front id="SdVolumeH-199">   * \param[in] dev The SD card where the volume is located.</front>
<front id="SdVolumeH-200">   * \return true for success or false for failure.</front>
<front id="SdVolumeH-201">   */</front>
<front id="SdVolumeH-202">  bool init(Sd2Card& dev) {return init(&dev);}  // NOLINT</front>
<front id="SdVolumeH-203">  /** \deprecated Use: bool SdVolume::init(Sd2Card* dev, uint8_t vol);</front>
<front id="SdVolumeH-204">   * \param[in] dev The SD card where the volume is located.</front>
<front id="SdVolumeH-205">   * \param[in] part The partition to be used.</front>
<front id="SdVolumeH-206">   * \return true for success or false for failure.</front>
<front id="SdVolumeH-207">   */</front>
<front id="SdVolumeH-208">  bool init(Sd2Card& dev, uint8_t part) {  // NOLINT</front>
<front id="SdVolumeH-209">    return init(&dev, part);</front>
<front id="SdVolumeH-210">  }</front>
<front id="SdVolumeH-211">#endif  // ALLOW_DEPRECATED_FUNCTIONS</front>
<front id="SdVolumeH-212">};</front>
<front id="SdVolumeH-213">#endif  // SdVolume</front>
<front id="SdVolumeH-214">#endif</front>
 </pre>
<h1 id="servoCPPtitle" >servo.cpp</h1>
<pre id="servoCPP"  class="prettyprint linenums"><front id="servoCPP-1">/*</front>
<front id="servoCPP-2"> servo.cpp - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2</front>
<front id="servoCPP-3"> Copyright (c) 2009 Michael Margolis.  All right reserved.</front>
<front id="servoCPP-4"></front>
<front id="servoCPP-5"> This library is free software; you can redistribute it and/or</front>
<front id="servoCPP-6"> modify it under the terms of the GNU Lesser General Public</front>
<front id="servoCPP-7"> License as published by the Free Software Foundation; either</front>
<front id="servoCPP-8"> version 2.1 of the License, or (at your option) any later version.</front>
<front id="servoCPP-9"></front>
<front id="servoCPP-10"> This library is distributed in the hope that it will be useful,</front>
<front id="servoCPP-11"> but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="servoCPP-12"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="servoCPP-13"> Lesser General Public License for more details.</front>
<front id="servoCPP-14"></front>
<front id="servoCPP-15"> You should have received a copy of the GNU Lesser General Public</front>
<front id="servoCPP-16"> License along with this library; if not, write to the Free Software</front>
<front id="servoCPP-17"> Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="servoCPP-18"> */</front>
<front id="servoCPP-19"></front>
<front id="servoCPP-20">/*</front>
<front id="servoCPP-21"></front>
<front id="servoCPP-22"> A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.</front>
<front id="servoCPP-23"> The servos are pulsed in the background using the value most recently written using the write() method</front>
<front id="servoCPP-24"></front>
<front id="servoCPP-25"> Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.</front>
<front id="servoCPP-26"> Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.</front>
<front id="servoCPP-27"></front>
<front id="servoCPP-28"> The methods are:</front>
<front id="servoCPP-29"></front>
<front id="servoCPP-30"> Servo - Class for manipulating servo motors connected to Arduino pins.</front>
<front id="servoCPP-31"></front>
<front id="servoCPP-32"> attach(pin )  - Attaches a servo motor to an i/o pin.</front>
<front id="servoCPP-33"> attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds</front>
<front id="servoCPP-34"> default min is 544, max is 2400</front>
<front id="servoCPP-35"></front>
<front id="servoCPP-36"> write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)</front>
<front id="servoCPP-37"> writeMicroseconds() - Sets the servo pulse width in microseconds</front>
<front id="servoCPP-38"> move(pin, angle) - Sequence of attach(pin), write(angle).</front>
<front id="servoCPP-39">                    With DEACTIVATE_SERVOS_AFTER_MOVE it waits SERVO_DEACTIVATION_DELAY and detaches.</front>
<front id="servoCPP-40"> read()      - Gets the last written servo pulse width as an angle between 0 and 180.</front>
<front id="servoCPP-41"> readMicroseconds()   - Gets the last written servo pulse width in microseconds. (was read_us() in first release)</front>
<front id="servoCPP-42"> attached()  - Returns true if there is a servo attached.</front>
<front id="servoCPP-43"> detach()    - Stops an attached servos from pulsing its i/o pin.</front>
<front id="servoCPP-44"></front>
<front id="servoCPP-45">*/</front>
<front id="servoCPP-46">#include "Configuration.h" </front>
<front id="servoCPP-47"></front>
<front id="servoCPP-48">#if HAS_SERVOS</front>
<front id="servoCPP-49"></front>
<front id="servoCPP-50">#include &lt;avr/interrupt.h&gt;</front>
<front id="servoCPP-51">#include &lt;Arduino.h&gt;</front>
<front id="servoCPP-52"></front>
<front id="servoCPP-53">#include "servo.h"</front>
<front id="servoCPP-54"></front>
<front id="servoCPP-55">#define usToTicks(_us)    (( clockCyclesPerMicrosecond()* _us) / 8)     // converts microseconds to tick (assumes prescale of 8)  // 12 Aug 2009</front>
<front id="servoCPP-56">#define ticksToUs(_ticks) (( (unsigned)_ticks * 8)/ clockCyclesPerMicrosecond() ) // converts from ticks back to microseconds</front>
<front id="servoCPP-57"></front>
<front id="servoCPP-58">#define TRIM_DURATION       2                               // compensation ticks to trim adjust for digitalWrite delays // 12 August 2009</front>
<front id="servoCPP-59"></front>
<front id="servoCPP-60">//#define NBR_TIMERS        (MAX_SERVOS / SERVOS_PER_TIMER)</front>
<front id="servoCPP-61"></front>
<front id="servoCPP-62">static ServoInfo_t servo_info[MAX_SERVOS];                  // static array of servo info structures</front>
<front id="servoCPP-63">static volatile int8_t Channel[_Nbr_16timers ];             // counter for the servo being pulsed for each timer (or -1 if refresh interval)</front>
<front id="servoCPP-64"></front>
<front id="servoCPP-65">uint8_t ServoCount = 0;                                     // the total number of attached servos</front>
<front id="servoCPP-66"></front>
<front id="servoCPP-67"></front>
<front id="servoCPP-68">// convenience macros</front>
<front id="servoCPP-69">#define SERVO_INDEX_TO_TIMER(_servo_nbr) ((timer16_Sequence_t)(_servo_nbr / SERVOS_PER_TIMER)) // returns the timer controlling this servo</front>
<front id="servoCPP-70">#define SERVO_INDEX_TO_CHANNEL(_servo_nbr) (_servo_nbr % SERVOS_PER_TIMER)       // returns the index of the servo on this timer</front>
<front id="servoCPP-71">#define SERVO_INDEX(_timer,_channel)  ((_timer*SERVOS_PER_TIMER) + _channel)     // macro to access servo index by timer and channel</front>
<front id="servoCPP-72">#define SERVO(_timer,_channel)  (servo_info[SERVO_INDEX(_timer,_channel)])       // macro to access servo class by timer and channel</front>
<front id="servoCPP-73"></front>
<front id="servoCPP-74">#define SERVO_MIN() (MIN_PULSE_WIDTH - this-&gt;min * 4)  // minimum value in uS for this servo</front>
<front id="servoCPP-75">#define SERVO_MAX() (MAX_PULSE_WIDTH - this-&gt;max * 4)  // maximum value in uS for this servo</front>
<front id="servoCPP-76"></front>
<front id="servoCPP-77">/************ static functions common to all instances ***********************/</front>
<front id="servoCPP-78"></front>
<front id="servoCPP-79">static inline void handle_interrupts(timer16_Sequence_t timer, volatile uint16_t *TCNTn, volatile uint16_t* OCRnA) {</front>
<front id="servoCPP-80">  if (Channel[timer] &lt; 0)</front>
<front id="servoCPP-81">    *TCNTn = 0; // channel set to -1 indicated that refresh interval completed so reset the timer</front>
<front id="servoCPP-82">  else {</front>
<front id="servoCPP-83">    if (SERVO_INDEX(timer,Channel[timer]) &lt; ServoCount && SERVO(timer,Channel[timer]).Pin.isActive)</front>
<front id="servoCPP-84">      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,LOW); // pulse this channel low if activated</front>
<front id="servoCPP-85">  }</front>
<front id="servoCPP-86"></front>
<front id="servoCPP-87">  Channel[timer]++;    // increment to the next channel</front>
<front id="servoCPP-88">  if (SERVO_INDEX(timer,Channel[timer]) &lt; ServoCount && Channel[timer] &lt; SERVOS_PER_TIMER) {</front>
<front id="servoCPP-89">    *OCRnA = *TCNTn + SERVO(timer,Channel[timer]).ticks;</front>
<front id="servoCPP-90">    if (SERVO(timer,Channel[timer]).Pin.isActive)     // check if activated</front>
<front id="servoCPP-91">      digitalWrite( SERVO(timer,Channel[timer]).Pin.nbr,HIGH); // its an active channel so pulse it high</front>
<front id="servoCPP-92">  }</front>
<front id="servoCPP-93">  else {</front>
<front id="servoCPP-94">    // finished all channels so wait for the refresh period to expire before starting over</front>
<front id="servoCPP-95">    if ( ((unsigned)*TCNTn) + 4 &lt; usToTicks(REFRESH_INTERVAL) )  // allow a few ticks to ensure the next OCR1A not missed</front>
<front id="servoCPP-96">      *OCRnA = (unsigned int)usToTicks(REFRESH_INTERVAL);</front>
<front id="servoCPP-97">    else</front>
<front id="servoCPP-98">      *OCRnA = *TCNTn + 4;  // at least REFRESH_INTERVAL has elapsed</front>
<front id="servoCPP-99">    Channel[timer] = -1; // this will get incremented at the end of the refresh period to start again at the first channel</front>
<front id="servoCPP-100">  }</front>
<front id="servoCPP-101">}</front>
<front id="servoCPP-102"></front>
<front id="servoCPP-103">#ifndef WIRING // Wiring pre-defines signal handlers so don't define any if compiling for the Wiring platform</front>
<front id="servoCPP-104"></front>
<front id="servoCPP-105">  // Interrupt handlers for Arduino</front>
<front id="servoCPP-106">  #if ENABLED(_useTimer1)</front>
<front id="servoCPP-107">    SIGNAL (TIMER1_COMPA_vect) { handle_interrupts(_timer1, &TCNT1, &OCR1A); }</front>
<front id="servoCPP-108">  #endif</front>
<front id="servoCPP-109"></front>
<front id="servoCPP-110">  #if ENABLED(_useTimer3)</front>
<front id="servoCPP-111">    SIGNAL (TIMER3_COMPA_vect) { handle_interrupts(_timer3, &TCNT3, &OCR3A); }</front>
<front id="servoCPP-112">  #endif</front>
<front id="servoCPP-113"></front>
<front id="servoCPP-114">  #if ENABLED(_useTimer4)</front>
<front id="servoCPP-115">    SIGNAL (TIMER4_COMPA_vect) { handle_interrupts(_timer4, &TCNT4, &OCR4A); }</front>
<front id="servoCPP-116">  #endif</front>
<front id="servoCPP-117"></front>
<front id="servoCPP-118">  #if ENABLED(_useTimer5)</front>
<front id="servoCPP-119">    SIGNAL (TIMER5_COMPA_vect) { handle_interrupts(_timer5, &TCNT5, &OCR5A); }</front>
<front id="servoCPP-120">  #endif</front>
<front id="servoCPP-121"></front>
<front id="servoCPP-122">#else //!WIRING</front>
<front id="servoCPP-123"></front>
<front id="servoCPP-124">  // Interrupt handlers for Wiring</front>
<front id="servoCPP-125">  #if ENABLED(_useTimer1)</front>
<front id="servoCPP-126">    void Timer1Service() { handle_interrupts(_timer1, &TCNT1, &OCR1A); }</front>
<front id="servoCPP-127">  #endif</front>
<front id="servoCPP-128">  #if ENABLED(_useTimer3)</front>
<front id="servoCPP-129">    void Timer3Service() { handle_interrupts(_timer3, &TCNT3, &OCR3A); }</front>
<front id="servoCPP-130">  #endif</front>
<front id="servoCPP-131"></front>
<front id="servoCPP-132">#endif //!WIRING</front>
<front id="servoCPP-133"></front>
<front id="servoCPP-134"></front>
<front id="servoCPP-135">static void initISR(timer16_Sequence_t timer) {</front>
<front id="servoCPP-136">  #if ENABLED(_useTimer1)</front>
<front id="servoCPP-137">    if (timer == _timer1) {</front>
<front id="servoCPP-138">      TCCR1A = 0;             // normal counting mode</front>
<front id="servoCPP-139">      TCCR1B = _BV(CS11);     // set prescaler of 8</front>
<front id="servoCPP-140">      TCNT1 = 0;              // clear the timer count</front>
<front id="servoCPP-141">      #if defined(__AVR_ATmega8__)|| defined(__AVR_ATmega128__)</front>
<front id="servoCPP-142">        TIFR |= _BV(OCF1A);      // clear any pending interrupts;</front>
<front id="servoCPP-143">        TIMSK |= _BV(OCIE1A);    // enable the output compare interrupt</front>
<front id="servoCPP-144">      #else</front>
<front id="servoCPP-145">        // here if not ATmega8 or ATmega128</front>
<front id="servoCPP-146">        TIFR1 |= _BV(OCF1A);     // clear any pending interrupts;</front>
<front id="servoCPP-147">        TIMSK1 |= _BV(OCIE1A);   // enable the output compare interrupt</front>
<front id="servoCPP-148">      #endif</front>
<front id="servoCPP-149">      #ifdef WIRING</front>
<front id="servoCPP-150">        timerAttach(TIMER1OUTCOMPAREA_INT, Timer1Service);</front>
<front id="servoCPP-151">      #endif</front>
<front id="servoCPP-152">    }</front>
<front id="servoCPP-153">  #endif</front>
<front id="servoCPP-154"></front>
<front id="servoCPP-155">  #if ENABLED(_useTimer3)</front>
<front id="servoCPP-156">    if (timer == _timer3) {</front>
<front id="servoCPP-157">      TCCR3A = 0;             // normal counting mode</front>
<front id="servoCPP-158">      TCCR3B = _BV(CS31);     // set prescaler of 8</front>
<front id="servoCPP-159">      TCNT3 = 0;              // clear the timer count</front>
<front id="servoCPP-160">      #ifdef __AVR_ATmega128__</front>
<front id="servoCPP-161">        TIFR |= _BV(OCF3A);     // clear any pending interrupts;</front>
<front id="servoCPP-162">      	ETIMSK |= _BV(OCIE3A);  // enable the output compare interrupt</front>
<front id="servoCPP-163">      #else</front>
<front id="servoCPP-164">        TIFR3 = _BV(OCF3A);     // clear any pending interrupts;</front>
<front id="servoCPP-165">        TIMSK3 =  _BV(OCIE3A) ; // enable the output compare interrupt</front>
<front id="servoCPP-166">      #endif</front>
<front id="servoCPP-167">      #ifdef WIRING</front>
<front id="servoCPP-168">        timerAttach(TIMER3OUTCOMPAREA_INT, Timer3Service);  // for Wiring platform only</front>
<front id="servoCPP-169">      #endif</front>
<front id="servoCPP-170">    }</front>
<front id="servoCPP-171">  #endif</front>
<front id="servoCPP-172"></front>
<front id="servoCPP-173">  #if ENABLED(_useTimer4)</front>
<front id="servoCPP-174">    if (timer == _timer4) {</front>
<front id="servoCPP-175">      TCCR4A = 0;             // normal counting mode</front>
<front id="servoCPP-176">      TCCR4B = _BV(CS41);     // set prescaler of 8</front>
<front id="servoCPP-177">      TCNT4 = 0;              // clear the timer count</front>
<front id="servoCPP-178">      TIFR4 = _BV(OCF4A);     // clear any pending interrupts;</front>
<front id="servoCPP-179">      TIMSK4 =  _BV(OCIE4A) ; // enable the output compare interrupt</front>
<front id="servoCPP-180">    }</front>
<front id="servoCPP-181">  #endif</front>
<front id="servoCPP-182"></front>
<front id="servoCPP-183">  #if ENABLED(_useTimer5)</front>
<front id="servoCPP-184">    if (timer == _timer5) {</front>
<front id="servoCPP-185">      TCCR5A = 0;             // normal counting mode</front>
<front id="servoCPP-186">      TCCR5B = _BV(CS51);     // set prescaler of 8</front>
<front id="servoCPP-187">      TCNT5 = 0;              // clear the timer count</front>
<front id="servoCPP-188">      TIFR5 = _BV(OCF5A);     // clear any pending interrupts;</front>
<front id="servoCPP-189">      TIMSK5 =  _BV(OCIE5A) ; // enable the output compare interrupt</front>
<front id="servoCPP-190">    }</front>
<front id="servoCPP-191">  #endif</front>
<front id="servoCPP-192">}</front>
<front id="servoCPP-193"></front>
<front id="servoCPP-194">static void finISR(timer16_Sequence_t timer) {</front>
<front id="servoCPP-195">  // Disable use of the given timer</front>
<front id="servoCPP-196">  #ifdef WIRING</front>
<front id="servoCPP-197">    if (timer == _timer1) {</front>
<front id="servoCPP-198">      #if defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)</front>
<front id="servoCPP-199">        TIMSK1</front>
<front id="servoCPP-200">      #else</front>
<front id="servoCPP-201">        TIMSK</front>
<front id="servoCPP-202">      #endif</front>
<front id="servoCPP-203">          &= ~_BV(OCIE1A);    // disable timer 1 output compare interrupt</front>
<front id="servoCPP-204">      timerDetach(TIMER1OUTCOMPAREA_INT);</front>
<front id="servoCPP-205">    }</front>
<front id="servoCPP-206">    else if (timer == _timer3) {</front>
<front id="servoCPP-207">      #if defined(__AVR_ATmega1281__) || defined(__AVR_ATmega2561__)</front>
<front id="servoCPP-208">        TIMSK3</front>
<front id="servoCPP-209">      #else</front>
<front id="servoCPP-210">        ETIMSK</front>
<front id="servoCPP-211">      #endif</front>
<front id="servoCPP-212">          &= ~_BV(OCIE3A);    // disable the timer3 output compare A interrupt</front>
<front id="servoCPP-213">      timerDetach(TIMER3OUTCOMPAREA_INT);</front>
<front id="servoCPP-214">    }</front>
<front id="servoCPP-215">  #else //!WIRING</front>
<front id="servoCPP-216">    // For arduino - in future: call here to a currently undefined function to reset the timer</front>
<front id="servoCPP-217">  #endif</front>
<front id="servoCPP-218">}</front>
<front id="servoCPP-219"></front>
<front id="servoCPP-220">static boolean isTimerActive(timer16_Sequence_t timer) {</front>
<front id="servoCPP-221">  // returns true if any servo is active on this timer</front>
<front id="servoCPP-222">  for(uint8_t channel=0; channel &lt; SERVOS_PER_TIMER; channel++) {</front>
<front id="servoCPP-223">    if (SERVO(timer,channel).Pin.isActive)</front>
<front id="servoCPP-224">      return true;</front>
<front id="servoCPP-225">  }</front>
<front id="servoCPP-226">  return false;</front>
<front id="servoCPP-227">}</front>
<front id="servoCPP-228"></front>
<front id="servoCPP-229"></front>
<front id="servoCPP-230">/****************** end of static functions ******************************/</front>
<front id="servoCPP-231"></front>
<front id="servoCPP-232">Servo::Servo() {</front>
<front id="servoCPP-233">  if ( ServoCount &lt; MAX_SERVOS) {</front>
<front id="servoCPP-234">    this-&gt;servoIndex = ServoCount++;                    // assign a servo index to this instance</front>
<front id="servoCPP-235">    servo_info[this-&gt;servoIndex].ticks = usToTicks(DEFAULT_PULSE_WIDTH);   // store default values  - 12 Aug 2009</front>
<front id="servoCPP-236">  }</front>
<front id="servoCPP-237">  else</front>
<front id="servoCPP-238">    this-&gt;servoIndex = INVALID_SERVO;  // too many servos</front>
<front id="servoCPP-239">}</front>
<front id="servoCPP-240"></front>
<front id="servoCPP-241">int8_t Servo::attach(int pin) {</front>
<front id="servoCPP-242">  return this-&gt;attach(pin, MIN_PULSE_WIDTH, MAX_PULSE_WIDTH);</front>
<front id="servoCPP-243">}</front>
<front id="servoCPP-244"></front>
<front id="servoCPP-245">int8_t Servo::attach(int pin, int min, int max) {</front>
<front id="servoCPP-246"></front>
<front id="servoCPP-247">  if (this-&gt;servoIndex &gt;= MAX_SERVOS) return -1;</front>
<front id="servoCPP-248"></front>
<front id="servoCPP-249">  if (pin &gt; 0) servo_info[this-&gt;servoIndex].Pin.nbr = pin;</front>
<front id="servoCPP-250">  pinMode(servo_info[this-&gt;servoIndex].Pin.nbr, OUTPUT); // set servo pin to output</front>
<front id="servoCPP-251"></front>
<front id="servoCPP-252">  // todo min/max check: abs(min - MIN_PULSE_WIDTH) /4 &lt; 128</front>
<front id="servoCPP-253">  this-&gt;min = (MIN_PULSE_WIDTH - min) / 4; //resolution of min/max is 4 uS</front>
<front id="servoCPP-254">  this-&gt;max = (MAX_PULSE_WIDTH - max) / 4;</front>
<front id="servoCPP-255"></front>
<front id="servoCPP-256">  // initialize the timer if it has not already been initialized</front>
<front id="servoCPP-257">  timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);</front>
<front id="servoCPP-258">  if (!isTimerActive(timer)) initISR(timer);</front>
<front id="servoCPP-259">  servo_info[this-&gt;servoIndex].Pin.isActive = true;  // this must be set after the check for isTimerActive</front>
<front id="servoCPP-260"></front>
<front id="servoCPP-261">  return this-&gt;servoIndex;</front>
<front id="servoCPP-262">}</front>
<front id="servoCPP-263"></front>
<front id="servoCPP-264">void Servo::detach() {</front>
<front id="servoCPP-265">  servo_info[this-&gt;servoIndex].Pin.isActive = false;</front>
<front id="servoCPP-266">  timer16_Sequence_t timer = SERVO_INDEX_TO_TIMER(servoIndex);</front>
<front id="servoCPP-267">  if (!isTimerActive(timer)) finISR(timer);</front>
<front id="servoCPP-268">}</front>
<front id="servoCPP-269"></front>
<front id="servoCPP-270">void Servo::write(int value) {</front>
<front id="servoCPP-271">  if (value &lt; MIN_PULSE_WIDTH) { // treat values less than 544 as angles in degrees (valid values in microseconds are handled as microseconds)</front>
<front id="servoCPP-272">    if (value &lt; 0) value = 0;</front>
<front id="servoCPP-273">    if (value &gt; 180) value = 180;</front>
<front id="servoCPP-274">    value = map(value, 0, 180, SERVO_MIN(),  SERVO_MAX());</front>
<front id="servoCPP-275">  }</front>
<front id="servoCPP-276">  this-&gt;writeMicroseconds(value);</front>
<front id="servoCPP-277">}</front>
<front id="servoCPP-278"></front>
<front id="servoCPP-279">void Servo::writeMicroseconds(int value) {</front>
<front id="servoCPP-280">  // calculate and store the values for the given channel</front>
<front id="servoCPP-281">  byte channel = this-&gt;servoIndex;</front>
<front id="servoCPP-282">  if (channel &lt; MAX_SERVOS) {  // ensure channel is valid</front>
<front id="servoCPP-283">    if (value &lt; SERVO_MIN())   // ensure pulse width is valid</front>
<front id="servoCPP-284">      value = SERVO_MIN();</front>
<front id="servoCPP-285">    else if (value &gt; SERVO_MAX())</front>
<front id="servoCPP-286">      value = SERVO_MAX();</front>
<front id="servoCPP-287"></front>
<front id="servoCPP-288">  	value = value - TRIM_DURATION;</front>
<front id="servoCPP-289">    value = usToTicks(value);  // convert to ticks after compensating for interrupt overhead - 12 Aug 2009</front>
<front id="servoCPP-290"></front>
<front id="servoCPP-291">    uint8_t oldSREG = SREG;</front>
<front id="servoCPP-292">    cli();</front>
<front id="servoCPP-293">    servo_info[channel].ticks = value;</front>
<front id="servoCPP-294">    SREG = oldSREG;</front>
<front id="servoCPP-295">  }</front>
<front id="servoCPP-296">}</front>
<front id="servoCPP-297"></front>
<front id="servoCPP-298">// return the value as degrees</front>
<front id="servoCPP-299">int Servo::read() { return map( this-&gt;readMicroseconds()+1, SERVO_MIN(), SERVO_MAX(), 0, 180); }</front>
<front id="servoCPP-300"></front>
<front id="servoCPP-301">int Servo::readMicroseconds() {</front>
<front id="servoCPP-302">  return (this-&gt;servoIndex == INVALID_SERVO) ? 0 : ticksToUs(servo_info[this-&gt;servoIndex].ticks) + TRIM_DURATION;</front>
<front id="servoCPP-303">}</front>
<front id="servoCPP-304"></front>
<front id="servoCPP-305">bool Servo::attached() { return servo_info[this-&gt;servoIndex].Pin.isActive; }</front>
<front id="servoCPP-306"></front>
<front id="servoCPP-307">void Servo::move(int value) {</front>
<front id="servoCPP-308">  if (this-&gt;attach(0) &gt;= 0) {</front>
<front id="servoCPP-309">    this-&gt;write(value);</front>
<front id="servoCPP-310">    #if ENABLED(DEACTIVATE_SERVOS_AFTER_MOVE)</front>
<front id="servoCPP-311">      delay(SERVO_DEACTIVATION_DELAY);</front>
<front id="servoCPP-312">      this-&gt;detach();</front>
<front id="servoCPP-313">    #endif</front>
<front id="servoCPP-314">  }</front>
<front id="servoCPP-315">}</front>
<front id="servoCPP-316"></front>
<front id="servoCPP-317">#endif</front>
 </pre>
<h1 id="servoHtitle" >servo.h</h1>
<pre id="servoH"  class="prettyprint linenums"><front id="servoH-1">/*</front>
<front id="servoH-2">  servo.h - Interrupt driven Servo library for Arduino using 16 bit timers- Version 2</front>
<front id="servoH-3">  Copyright (c) 2009 Michael Margolis.  All right reserved.</front>
<front id="servoH-4"></front>
<front id="servoH-5">  This library is free software; you can redistribute it and/or</front>
<front id="servoH-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="servoH-7">  License as published by the Free Software Foundation; either</front>
<front id="servoH-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="servoH-9"></front>
<front id="servoH-10">  This library is distributed in the hope that it will be useful,</front>
<front id="servoH-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="servoH-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="servoH-13">  Lesser General Public License for more details.</front>
<front id="servoH-14"></front>
<front id="servoH-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="servoH-16">  License along with this library; if not, write to the Free Software</front>
<front id="servoH-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="servoH-18">*/</front>
<front id="servoH-19"></front>
<front id="servoH-20">/*</front>
<front id="servoH-21"></front>
<front id="servoH-22">  A servo is activated by creating an instance of the Servo class passing the desired pin to the attach() method.</front>
<front id="servoH-23">  The servos are pulsed in the background using the value most recently written using the write() method</front>
<front id="servoH-24"></front>
<front id="servoH-25">  Note that analogWrite of PWM on pins associated with the timer are disabled when the first servo is attached.</front>
<front id="servoH-26">  Timers are seized as needed in groups of 12 servos - 24 servos use two timers, 48 servos will use four.</front>
<front id="servoH-27">  The sequence used to seize timers is defined in timers.h</front>
<front id="servoH-28"></front>
<front id="servoH-29">  The methods are:</front>
<front id="servoH-30"></front>
<front id="servoH-31">   Servo - Class for manipulating servo motors connected to Arduino pins.</front>
<front id="servoH-32"></front>
<front id="servoH-33">   attach(pin )  - Attaches a servo motor to an i/o pin.</front>
<front id="servoH-34">   attach(pin, min, max  ) - Attaches to a pin setting min and max values in microseconds</front>
<front id="servoH-35">   default min is 544, max is 2400</front>
<front id="servoH-36"></front>
<front id="servoH-37">   write()     - Sets the servo angle in degrees.  (invalid angle that is valid as pulse in microseconds is treated as microseconds)</front>
<front id="servoH-38">   writeMicroseconds() - Sets the servo pulse width in microseconds</front>
<front id="servoH-39">   read()      - Gets the last written servo pulse width as an angle between 0 and 180.</front>
<front id="servoH-40">   readMicroseconds() - Gets the last written servo pulse width in microseconds. (was read_us() in first release)</front>
<front id="servoH-41">   attached()  - Returns true if there is a servo attached.</front>
<front id="servoH-42">   detach()    - Stops an attached servos from pulsing its i/o pin.</front>
<front id="servoH-43">   move(angle) - Sequence of attach(0), write(angle),</front>
<front id="servoH-44">                   With DEACTIVATE_SERVOS_AFTER_MOVE wait SERVO_DEACTIVATION_DELAY and detach.</front>
<front id="servoH-45"> */</front>
<front id="servoH-46"></front>
<front id="servoH-47">#ifndef servo_h</front>
<front id="servoH-48">#define servo_h</front>
<front id="servoH-49"></front>
<front id="servoH-50">#include &lt;inttypes.h&gt;</front>
<front id="servoH-51"></front>
<front id="servoH-52">/*</front>
<front id="servoH-53"> * Defines for 16 bit timers used with  Servo library</front>
<front id="servoH-54"> *</front>
<front id="servoH-55"> * If _useTimerX is defined then TimerX is a 16 bit timer on the current board</front>
<front id="servoH-56"> * timer16_Sequence_t enumerates the sequence that the timers should be allocated</front>
<front id="servoH-57"> * _Nbr_16timers indicates how many 16 bit timers are available.</front>
<front id="servoH-58"> *</front>
<front id="servoH-59"> */</front>
<front id="servoH-60"></front>
<front id="servoH-61">// Say which 16 bit timers can be used and in what order</front>
<front id="servoH-62">#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)</front>
<front id="servoH-63">  #define _useTimer5</front>
<front id="servoH-64">  //#define _useTimer1</front>
<front id="servoH-65">  #define _useTimer3</front>
<front id="servoH-66">  #define _useTimer4</front>
<front id="servoH-67">  //typedef enum { _timer5, _timer1, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-68">  typedef enum { _timer5, _timer3, _timer4, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-69"></front>
<front id="servoH-70">#elif defined(__AVR_ATmega32U4__)</front>
<front id="servoH-71">  //#define _useTimer1</front>
<front id="servoH-72">  #define _useTimer3</front>
<front id="servoH-73">  //typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-74">  typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-75"></front>
<front id="servoH-76">#elif defined(__AVR_AT90USB646__) || defined(__AVR_AT90USB1286__)</front>
<front id="servoH-77">  #define _useTimer3</front>
<front id="servoH-78">  //#define _useTimer1</front>
<front id="servoH-79">  //typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-80">  typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-81"></front>
<front id="servoH-82">#elif defined(__AVR_ATmega128__) ||defined(__AVR_ATmega1281__) || defined(__AVR_ATmega1284P__) ||defined(__AVR_ATmega2561__)</front>
<front id="servoH-83">  #define _useTimer3</front>
<front id="servoH-84">  //#define _useTimer1</front>
<front id="servoH-85">  //typedef enum { _timer3, _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-86">  typedef enum { _timer3, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-87"></front>
<front id="servoH-88">#else  // everything else</front>
<front id="servoH-89">  //#define _useTimer1</front>
<front id="servoH-90">  //typedef enum { _timer1, _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-91">  typedef enum { _Nbr_16timers } timer16_Sequence_t ;</front>
<front id="servoH-92"></front>
<front id="servoH-93">#endif</front>
<front id="servoH-94"></front>
<front id="servoH-95">#define Servo_VERSION           2     // software version of this library</front>
<front id="servoH-96"></front>
<front id="servoH-97">#define MIN_PULSE_WIDTH       544     // the shortest pulse sent to a servo</front>
<front id="servoH-98">#define MAX_PULSE_WIDTH      2400     // the longest pulse sent to a servo</front>
<front id="servoH-99">#define DEFAULT_PULSE_WIDTH  1500     // default pulse width when servo is attached</front>
<front id="servoH-100">#define REFRESH_INTERVAL    20000     // minimum time to refresh servos in microseconds</front>
<front id="servoH-101"></front>
<front id="servoH-102">#define SERVOS_PER_TIMER       12     // the maximum number of servos controlled by one timer</front>
<front id="servoH-103">#define MAX_SERVOS   (_Nbr_16timers  * SERVOS_PER_TIMER)</front>
<front id="servoH-104"></front>
<front id="servoH-105">#define INVALID_SERVO         255     // flag indicating an invalid servo index</front>
<front id="servoH-106"></front>
<front id="servoH-107">typedef struct {</front>
<front id="servoH-108">  uint8_t nbr        :6 ;             // a pin number from 0 to 63</front>
<front id="servoH-109">  uint8_t isActive   :1 ;             // true if this channel is enabled, pin not pulsed if false</front>
<front id="servoH-110">} ServoPin_t;</front>
<front id="servoH-111"></front>
<front id="servoH-112">typedef struct {</front>
<front id="servoH-113">  ServoPin_t Pin;</front>
<front id="servoH-114">  unsigned int ticks;</front>
<front id="servoH-115">} ServoInfo_t;</front>
<front id="servoH-116"></front>
<front id="servoH-117">class Servo {</front>
<front id="servoH-118">  public:</front>
<front id="servoH-119">    Servo();</front>
<front id="servoH-120">    int8_t attach(int pin);            // attach the given pin to the next free channel, set pinMode, return channel number (-1 on fail)</front>
<front id="servoH-121">    int8_t attach(int pin, int min, int max); // as above but also sets min and max values for writes.</front>
<front id="servoH-122">    void detach();</front>
<front id="servoH-123">    void write(int value);             // if value is &lt; 200 it is treated as an angle, otherwise as pulse width in microseconds</front>
<front id="servoH-124">    void writeMicroseconds(int value); // write pulse width in microseconds</front>
<front id="servoH-125">    void move(int value);              // attach the servo, then move to value</front>
<front id="servoH-126">                                       // if value is &lt; 200 it is treated as an angle, otherwise as pulse width in microseconds</front>
<front id="servoH-127">                                       // if DEACTIVATE_SERVOS_AFTER_MOVE wait SERVO_DEACTIVATION_DELAY, then detach</front>
<front id="servoH-128">    int read();                        // returns current pulse width as an angle between 0 and 180 degrees</front>
<front id="servoH-129">    int readMicroseconds();            // returns current pulse width in microseconds for this servo (was read_us() in first release)</front>
<front id="servoH-130">    bool attached();                   // return true if this servo is attached, otherwise false</front>
<front id="servoH-131"></front>
<front id="servoH-132">  private:</front>
<front id="servoH-133">    uint8_t servoIndex;               // index into the channel data for this servo</front>
<front id="servoH-134">    int8_t min;                       // minimum is this value times 4 added to MIN_PULSE_WIDTH</front>
<front id="servoH-135">    int8_t max;                       // maximum is this value times 4 added to MAX_PULSE_WIDTH</front>
<front id="servoH-136">};</front>
<front id="servoH-137"></front>
<front id="servoH-138">#endif</front>
 </pre>
<h1 id="speed_lookuptableHtitle" >speed_lookuptable.h</h1>
<pre id="speed_lookuptableH"  class="prettyprint linenums"><front id="speed_lookuptableH-1">#ifndef SPEED_LOOKUPTABLE_H</front>
<front id="speed_lookuptableH-2">#define SPEED_LOOKUPTABLE_H</front>
<front id="speed_lookuptableH-3"></front>
<front id="speed_lookuptableH-4">#include "Marlin.h"</front>
<front id="speed_lookuptableH-5"></front>
<front id="speed_lookuptableH-6">#if F_CPU == 16000000</front>
<front id="speed_lookuptableH-7"></front>
<front id="speed_lookuptableH-8">const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {\</front>
<front id="speed_lookuptableH-9">{ 62500, 55556}, { 6944, 3268}, { 3676, 1176}, { 2500, 607}, { 1893, 369}, { 1524, 249}, { 1275, 179}, { 1096, 135}, </front>
<front id="speed_lookuptableH-10">{ 961, 105}, { 856, 85}, { 771, 69}, { 702, 58}, { 644, 49}, { 595, 42}, { 553, 37}, { 516, 32}, </front>
<front id="speed_lookuptableH-11">{ 484, 28}, { 456, 25}, { 431, 23}, { 408, 20}, { 388, 19}, { 369, 16}, { 353, 16}, { 337, 14}, </front>
<front id="speed_lookuptableH-12">{ 323, 13}, { 310, 11}, { 299, 11}, { 288, 11}, { 277, 9}, { 268, 9}, { 259, 8}, { 251, 8}, </front>
<front id="speed_lookuptableH-13">{ 243, 8}, { 235, 7}, { 228, 6}, { 222, 6}, { 216, 6}, { 210, 6}, { 204, 5}, { 199, 5}, </front>
<front id="speed_lookuptableH-14">{ 194, 5}, { 189, 4}, { 185, 4}, { 181, 4}, { 177, 4}, { 173, 4}, { 169, 4}, { 165, 3}, </front>
<front id="speed_lookuptableH-15">{ 162, 3}, { 159, 4}, { 155, 3}, { 152, 3}, { 149, 2}, { 147, 3}, { 144, 3}, { 141, 2}, </front>
<front id="speed_lookuptableH-16">{ 139, 3}, { 136, 2}, { 134, 2}, { 132, 3}, { 129, 2}, { 127, 2}, { 125, 2}, { 123, 2}, </front>
<front id="speed_lookuptableH-17">{ 121, 2}, { 119, 1}, { 118, 2}, { 116, 2}, { 114, 1}, { 113, 2}, { 111, 2}, { 109, 1}, </front>
<front id="speed_lookuptableH-18">{ 108, 2}, { 106, 1}, { 105, 2}, { 103, 1}, { 102, 1}, { 101, 1}, { 100, 2}, { 98, 1}, </front>
<front id="speed_lookuptableH-19">{ 97, 1}, { 96, 1}, { 95, 2}, { 93, 1}, { 92, 1}, { 91, 1}, { 90, 1}, { 89, 1}, </front>
<front id="speed_lookuptableH-20">{ 88, 1}, { 87, 1}, { 86, 1}, { 85, 1}, { 84, 1}, { 83, 0}, { 83, 1}, { 82, 1}, </front>
<front id="speed_lookuptableH-21">{ 81, 1}, { 80, 1}, { 79, 1}, { 78, 0}, { 78, 1}, { 77, 1}, { 76, 1}, { 75, 0}, </front>
<front id="speed_lookuptableH-22">{ 75, 1}, { 74, 1}, { 73, 1}, { 72, 0}, { 72, 1}, { 71, 1}, { 70, 0}, { 70, 1}, </front>
<front id="speed_lookuptableH-23">{ 69, 0}, { 69, 1}, { 68, 1}, { 67, 0}, { 67, 1}, { 66, 0}, { 66, 1}, { 65, 0}, </front>
<front id="speed_lookuptableH-24">{ 65, 1}, { 64, 1}, { 63, 0}, { 63, 1}, { 62, 0}, { 62, 1}, { 61, 0}, { 61, 1}, </front>
<front id="speed_lookuptableH-25">{ 60, 0}, { 60, 0}, { 60, 1}, { 59, 0}, { 59, 1}, { 58, 0}, { 58, 1}, { 57, 0}, </front>
<front id="speed_lookuptableH-26">{ 57, 1}, { 56, 0}, { 56, 0}, { 56, 1}, { 55, 0}, { 55, 1}, { 54, 0}, { 54, 0}, </front>
<front id="speed_lookuptableH-27">{ 54, 1}, { 53, 0}, { 53, 0}, { 53, 1}, { 52, 0}, { 52, 0}, { 52, 1}, { 51, 0}, </front>
<front id="speed_lookuptableH-28">{ 51, 0}, { 51, 1}, { 50, 0}, { 50, 0}, { 50, 1}, { 49, 0}, { 49, 0}, { 49, 1}, </front>
<front id="speed_lookuptableH-29">{ 48, 0}, { 48, 0}, { 48, 1}, { 47, 0}, { 47, 0}, { 47, 0}, { 47, 1}, { 46, 0}, </front>
<front id="speed_lookuptableH-30">{ 46, 0}, { 46, 1}, { 45, 0}, { 45, 0}, { 45, 0}, { 45, 1}, { 44, 0}, { 44, 0}, </front>
<front id="speed_lookuptableH-31">{ 44, 0}, { 44, 1}, { 43, 0}, { 43, 0}, { 43, 0}, { 43, 1}, { 42, 0}, { 42, 0}, </front>
<front id="speed_lookuptableH-32">{ 42, 0}, { 42, 1}, { 41, 0}, { 41, 0}, { 41, 0}, { 41, 0}, { 41, 1}, { 40, 0}, </front>
<front id="speed_lookuptableH-33">{ 40, 0}, { 40, 0}, { 40, 0}, { 40, 1}, { 39, 0}, { 39, 0}, { 39, 0}, { 39, 0}, </front>
<front id="speed_lookuptableH-34">{ 39, 1}, { 38, 0}, { 38, 0}, { 38, 0}, { 38, 0}, { 38, 1}, { 37, 0}, { 37, 0}, </front>
<front id="speed_lookuptableH-35">{ 37, 0}, { 37, 0}, { 37, 0}, { 37, 1}, { 36, 0}, { 36, 0}, { 36, 0}, { 36, 0}, </front>
<front id="speed_lookuptableH-36">{ 36, 1}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 0}, { 35, 1}, </front>
<front id="speed_lookuptableH-37">{ 34, 0}, { 34, 0}, { 34, 0}, { 34, 0}, { 34, 0}, { 34, 1}, { 33, 0}, { 33, 0}, </front>
<front id="speed_lookuptableH-38">{ 33, 0}, { 33, 0}, { 33, 0}, { 33, 0}, { 33, 1}, { 32, 0}, { 32, 0}, { 32, 0}, </front>
<front id="speed_lookuptableH-39">{ 32, 0}, { 32, 0}, { 32, 0}, { 32, 0}, { 32, 1}, { 31, 0}, { 31, 0}, { 31, 0}, </front>
<front id="speed_lookuptableH-40">{ 31, 0}, { 31, 0}, { 31, 0}, { 31, 1}, { 30, 0}, { 30, 0}, { 30, 0}, { 30, 0}</front>
<front id="speed_lookuptableH-41">};</front>
<front id="speed_lookuptableH-42"></front>
<front id="speed_lookuptableH-43">const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {\</front>
<front id="speed_lookuptableH-44">{ 62500, 12500}, { 50000, 8334}, { 41666, 5952}, { 35714, 4464}, { 31250, 3473}, { 27777, 2777}, { 25000, 2273}, { 22727, 1894}, </front>
<front id="speed_lookuptableH-45">{ 20833, 1603}, { 19230, 1373}, { 17857, 1191}, { 16666, 1041}, { 15625, 920}, { 14705, 817}, { 13888, 731}, { 13157, 657}, </front>
<front id="speed_lookuptableH-46">{ 12500, 596}, { 11904, 541}, { 11363, 494}, { 10869, 453}, { 10416, 416}, { 10000, 385}, { 9615, 356}, { 9259, 331}, </front>
<front id="speed_lookuptableH-47">{ 8928, 308}, { 8620, 287}, { 8333, 269}, { 8064, 252}, { 7812, 237}, { 7575, 223}, { 7352, 210}, { 7142, 198}, </front>
<front id="speed_lookuptableH-48">{ 6944, 188}, { 6756, 178}, { 6578, 168}, { 6410, 160}, { 6250, 153}, { 6097, 145}, { 5952, 139}, { 5813, 132}, </front>
<front id="speed_lookuptableH-49">{ 5681, 126}, { 5555, 121}, { 5434, 115}, { 5319, 111}, { 5208, 106}, { 5102, 102}, { 5000, 99}, { 4901, 94}, </front>
<front id="speed_lookuptableH-50">{ 4807, 91}, { 4716, 87}, { 4629, 84}, { 4545, 81}, { 4464, 79}, { 4385, 75}, { 4310, 73}, { 4237, 71}, </front>
<front id="speed_lookuptableH-51">{ 4166, 68}, { 4098, 66}, { 4032, 64}, { 3968, 62}, { 3906, 60}, { 3846, 59}, { 3787, 56}, { 3731, 55}, </front>
<front id="speed_lookuptableH-52">{ 3676, 53}, { 3623, 52}, { 3571, 50}, { 3521, 49}, { 3472, 48}, { 3424, 46}, { 3378, 45}, { 3333, 44}, </front>
<front id="speed_lookuptableH-53">{ 3289, 43}, { 3246, 41}, { 3205, 41}, { 3164, 39}, { 3125, 39}, { 3086, 38}, { 3048, 36}, { 3012, 36}, </front>
<front id="speed_lookuptableH-54">{ 2976, 35}, { 2941, 35}, { 2906, 33}, { 2873, 33}, { 2840, 32}, { 2808, 31}, { 2777, 30}, { 2747, 30}, </front>
<front id="speed_lookuptableH-55">{ 2717, 29}, { 2688, 29}, { 2659, 28}, { 2631, 27}, { 2604, 27}, { 2577, 26}, { 2551, 26}, { 2525, 25}, </front>
<front id="speed_lookuptableH-56">{ 2500, 25}, { 2475, 25}, { 2450, 23}, { 2427, 24}, { 2403, 23}, { 2380, 22}, { 2358, 22}, { 2336, 22}, </front>
<front id="speed_lookuptableH-57">{ 2314, 21}, { 2293, 21}, { 2272, 20}, { 2252, 20}, { 2232, 20}, { 2212, 20}, { 2192, 19}, { 2173, 18}, </front>
<front id="speed_lookuptableH-58">{ 2155, 19}, { 2136, 18}, { 2118, 18}, { 2100, 17}, { 2083, 17}, { 2066, 17}, { 2049, 17}, { 2032, 16}, </front>
<front id="speed_lookuptableH-59">{ 2016, 16}, { 2000, 16}, { 1984, 16}, { 1968, 15}, { 1953, 16}, { 1937, 14}, { 1923, 15}, { 1908, 15}, </front>
<front id="speed_lookuptableH-60">{ 1893, 14}, { 1879, 14}, { 1865, 14}, { 1851, 13}, { 1838, 14}, { 1824, 13}, { 1811, 13}, { 1798, 13}, </front>
<front id="speed_lookuptableH-61">{ 1785, 12}, { 1773, 13}, { 1760, 12}, { 1748, 12}, { 1736, 12}, { 1724, 12}, { 1712, 12}, { 1700, 11}, </front>
<front id="speed_lookuptableH-62">{ 1689, 12}, { 1677, 11}, { 1666, 11}, { 1655, 11}, { 1644, 11}, { 1633, 10}, { 1623, 11}, { 1612, 10}, </front>
<front id="speed_lookuptableH-63">{ 1602, 10}, { 1592, 10}, { 1582, 10}, { 1572, 10}, { 1562, 10}, { 1552, 9}, { 1543, 10}, { 1533, 9}, </front>
<front id="speed_lookuptableH-64">{ 1524, 9}, { 1515, 9}, { 1506, 9}, { 1497, 9}, { 1488, 9}, { 1479, 9}, { 1470, 9}, { 1461, 8}, </front>
<front id="speed_lookuptableH-65">{ 1453, 8}, { 1445, 9}, { 1436, 8}, { 1428, 8}, { 1420, 8}, { 1412, 8}, { 1404, 8}, { 1396, 8}, </front>
<front id="speed_lookuptableH-66">{ 1388, 7}, { 1381, 8}, { 1373, 7}, { 1366, 8}, { 1358, 7}, { 1351, 7}, { 1344, 8}, { 1336, 7}, </front>
<front id="speed_lookuptableH-67">{ 1329, 7}, { 1322, 7}, { 1315, 7}, { 1308, 6}, { 1302, 7}, { 1295, 7}, { 1288, 6}, { 1282, 7}, </front>
<front id="speed_lookuptableH-68">{ 1275, 6}, { 1269, 7}, { 1262, 6}, { 1256, 6}, { 1250, 7}, { 1243, 6}, { 1237, 6}, { 1231, 6}, </front>
<front id="speed_lookuptableH-69">{ 1225, 6}, { 1219, 6}, { 1213, 6}, { 1207, 6}, { 1201, 5}, { 1196, 6}, { 1190, 6}, { 1184, 5}, </front>
<front id="speed_lookuptableH-70">{ 1179, 6}, { 1173, 5}, { 1168, 6}, { 1162, 5}, { 1157, 5}, { 1152, 6}, { 1146, 5}, { 1141, 5}, </front>
<front id="speed_lookuptableH-71">{ 1136, 5}, { 1131, 5}, { 1126, 5}, { 1121, 5}, { 1116, 5}, { 1111, 5}, { 1106, 5}, { 1101, 5}, </front>
<front id="speed_lookuptableH-72">{ 1096, 5}, { 1091, 5}, { 1086, 4}, { 1082, 5}, { 1077, 5}, { 1072, 4}, { 1068, 5}, { 1063, 4}, </front>
<front id="speed_lookuptableH-73">{ 1059, 5}, { 1054, 4}, { 1050, 4}, { 1046, 5}, { 1041, 4}, { 1037, 4}, { 1033, 5}, { 1028, 4}, </front>
<front id="speed_lookuptableH-74">{ 1024, 4}, { 1020, 4}, { 1016, 4}, { 1012, 4}, { 1008, 4}, { 1004, 4}, { 1000, 4}, { 996, 4}, </front>
<front id="speed_lookuptableH-75">{ 992, 4}, { 988, 4}, { 984, 4}, { 980, 4}, { 976, 4}, { 972, 4}, { 968, 3}, { 965, 3}</front>
<front id="speed_lookuptableH-76">};</front>
<front id="speed_lookuptableH-77"></front>
<front id="speed_lookuptableH-78">#elif F_CPU == 20000000</front>
<front id="speed_lookuptableH-79"></front>
<front id="speed_lookuptableH-80">const uint16_t speed_lookuptable_fast[256][2] PROGMEM = {</front>
<front id="speed_lookuptableH-81">   {62500, 54055}, {8445, 3917}, {4528, 1434}, {3094, 745}, {2349, 456}, {1893, 307}, {1586, 222}, {1364, 167},</front>
<front id="speed_lookuptableH-82">   {1197, 131}, {1066, 105}, {961, 86}, {875, 72}, {803, 61}, {742, 53}, {689, 45}, {644, 40},</front>
<front id="speed_lookuptableH-83">   {604, 35}, {569, 32}, {537, 28}, {509, 25}, {484, 23}, {461, 21}, {440, 19}, {421, 17},</front>
<front id="speed_lookuptableH-84">   {404, 16}, {388, 15}, {373, 14}, {359, 13}, {346, 12}, {334, 11}, {323, 10}, {313, 10},</front>
<front id="speed_lookuptableH-85">   {303, 9}, {294, 9}, {285, 8}, {277, 7}, {270, 8}, {262, 7}, {255, 6}, {249, 6},</front>
<front id="speed_lookuptableH-86">   {243, 6}, {237, 6}, {231, 5}, {226, 5}, {221, 5}, {216, 5}, {211, 4}, {207, 5},</front>
<front id="speed_lookuptableH-87">   {202, 4}, {198, 4}, {194, 4}, {190, 3}, {187, 4}, {183, 3}, {180, 3}, {177, 4},</front>
<front id="speed_lookuptableH-88">   {173, 3}, {170, 3}, {167, 2}, {165, 3}, {162, 3}, {159, 2}, {157, 3}, {154, 2},</front>
<front id="speed_lookuptableH-89">   {152, 3}, {149, 2}, {147, 2}, {145, 2}, {143, 2}, {141, 2}, {139, 2}, {137, 2},</front>
<front id="speed_lookuptableH-90">   {135, 2}, {133, 2}, {131, 2}, {129, 1}, {128, 2}, {126, 2}, {124, 1}, {123, 2},</front>
<front id="speed_lookuptableH-91">   {121, 1}, {120, 2}, {118, 1}, {117, 1}, {116, 2}, {114, 1}, {113, 1}, {112, 2},</front>
<front id="speed_lookuptableH-92">   {110, 1}, {109, 1}, {108, 1}, {107, 2}, {105, 1}, {104, 1}, {103, 1}, {102, 1},</front>
<front id="speed_lookuptableH-93">   {101, 1}, {100, 1}, {99, 1}, {98, 1}, {97, 1}, {96, 1}, {95, 1}, {94, 1},</front>
<front id="speed_lookuptableH-94">   {93, 1}, {92, 1}, {91, 0}, {91, 1}, {90, 1}, {89, 1}, {88, 1}, {87, 0},</front>
<front id="speed_lookuptableH-95">   {87, 1}, {86, 1}, {85, 1}, {84, 0}, {84, 1}, {83, 1}, {82, 1}, {81, 0},</front>
<front id="speed_lookuptableH-96">   {81, 1}, {80, 1}, {79, 0}, {79, 1}, {78, 0}, {78, 1}, {77, 1}, {76, 0},</front>
<front id="speed_lookuptableH-97">   {76, 1}, {75, 0}, {75, 1}, {74, 1}, {73, 0}, {73, 1}, {72, 0}, {72, 1},</front>
<front id="speed_lookuptableH-98">   {71, 0}, {71, 1}, {70, 0}, {70, 1}, {69, 0}, {69, 1}, {68, 0}, {68, 1},</front>
<front id="speed_lookuptableH-99">   {67, 0}, {67, 1}, {66, 0}, {66, 1}, {65, 0}, {65, 0}, {65, 1}, {64, 0},</front>
<front id="speed_lookuptableH-100">   {64, 1}, {63, 0}, {63, 1}, {62, 0}, {62, 0}, {62, 1}, {61, 0}, {61, 1},</front>
<front id="speed_lookuptableH-101">   {60, 0}, {60, 0}, {60, 1}, {59, 0}, {59, 0}, {59, 1}, {58, 0}, {58, 0},</front>
<front id="speed_lookuptableH-102">   {58, 1}, {57, 0}, {57, 0}, {57, 1}, {56, 0}, {56, 0}, {56, 1}, {55, 0},</front>
<front id="speed_lookuptableH-103">   {55, 0}, {55, 1}, {54, 0}, {54, 0}, {54, 1}, {53, 0}, {53, 0}, {53, 0},</front>
<front id="speed_lookuptableH-104">   {53, 1}, {52, 0}, {52, 0}, {52, 1}, {51, 0}, {51, 0}, {51, 0}, {51, 1},</front>
<front id="speed_lookuptableH-105">   {50, 0}, {50, 0}, {50, 0}, {50, 1}, {49, 0}, {49, 0}, {49, 0}, {49, 1},</front>
<front id="speed_lookuptableH-106">   {48, 0}, {48, 0}, {48, 0}, {48, 1}, {47, 0}, {47, 0}, {47, 0}, {47, 1},</front>
<front id="speed_lookuptableH-107">   {46, 0}, {46, 0}, {46, 0}, {46, 0}, {46, 1}, {45, 0}, {45, 0}, {45, 0},</front>
<front id="speed_lookuptableH-108">   {45, 1}, {44, 0}, {44, 0}, {44, 0}, {44, 0}, {44, 1}, {43, 0}, {43, 0},</front>
<front id="speed_lookuptableH-109">   {43, 0}, {43, 0}, {43, 1}, {42, 0}, {42, 0}, {42, 0}, {42, 0}, {42, 0},</front>
<front id="speed_lookuptableH-110">   {42, 1}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 0}, {41, 1}, {40, 0},</front>
<front id="speed_lookuptableH-111">   {40, 0}, {40, 0}, {40, 0}, {40, 1}, {39, 0}, {39, 0}, {39, 0}, {39, 0},</front>
<front id="speed_lookuptableH-112">   {39, 0}, {39, 0}, {39, 1}, {38, 0}, {38, 0}, {38, 0}, {38, 0}, {38, 0},</front>
<front id="speed_lookuptableH-113">};</front>
<front id="speed_lookuptableH-114"></front>
<front id="speed_lookuptableH-115">const uint16_t speed_lookuptable_slow[256][2] PROGMEM = {</front>
<front id="speed_lookuptableH-116">   {62500, 10417}, {52083, 7441}, {44642, 5580}, {39062, 4340}, {34722, 3472}, {31250, 2841}, {28409, 2368}, {26041, 2003},</front>
<front id="speed_lookuptableH-117">   {24038, 1717}, {22321, 1488}, {20833, 1302}, {19531, 1149}, {18382, 1021}, {17361, 914}, {16447, 822}, {15625, 745},</front>
<front id="speed_lookuptableH-118">   {14880, 676}, {14204, 618}, {13586, 566}, {13020, 520}, {12500, 481}, {12019, 445}, {11574, 414}, {11160, 385},</front>
<front id="speed_lookuptableH-119">   {10775, 359}, {10416, 336}, {10080, 315}, {9765, 296}, {9469, 278}, {9191, 263}, {8928, 248}, {8680, 235},</front>
<front id="speed_lookuptableH-120">   {8445, 222}, {8223, 211}, {8012, 200}, {7812, 191}, {7621, 181}, {7440, 173}, {7267, 165}, {7102, 158},</front>
<front id="speed_lookuptableH-121">   {6944, 151}, {6793, 145}, {6648, 138}, {6510, 133}, {6377, 127}, {6250, 123}, {6127, 118}, {6009, 113},</front>
<front id="speed_lookuptableH-122">   {5896, 109}, {5787, 106}, {5681, 101}, {5580, 98}, {5482, 95}, {5387, 91}, {5296, 88}, {5208, 86},</front>
<front id="speed_lookuptableH-123">   {5122, 82}, {5040, 80}, {4960, 78}, {4882, 75}, {4807, 73}, {4734, 70}, {4664, 69}, {4595, 67},</front>
<front id="speed_lookuptableH-124">   {4528, 64}, {4464, 63}, {4401, 61}, {4340, 60}, {4280, 58}, {4222, 56}, {4166, 55}, {4111, 53},</front>
<front id="speed_lookuptableH-125">   {4058, 52}, {4006, 51}, {3955, 49}, {3906, 48}, {3858, 48}, {3810, 45}, {3765, 45}, {3720, 44},</front>
<front id="speed_lookuptableH-126">   {3676, 43}, {3633, 42}, {3591, 40}, {3551, 40}, {3511, 39}, {3472, 38}, {3434, 38}, {3396, 36},</front>
<front id="speed_lookuptableH-127">   {3360, 36}, {3324, 35}, {3289, 34}, {3255, 34}, {3221, 33}, {3188, 32}, {3156, 31}, {3125, 31},</front>
<front id="speed_lookuptableH-128">   {3094, 31}, {3063, 30}, {3033, 29}, {3004, 28}, {2976, 28}, {2948, 28}, {2920, 27}, {2893, 27},</front>
<front id="speed_lookuptableH-129">   {2866, 26}, {2840, 25}, {2815, 25}, {2790, 25}, {2765, 24}, {2741, 24}, {2717, 24}, {2693, 23},</front>
<front id="speed_lookuptableH-130">   {2670, 22}, {2648, 22}, {2626, 22}, {2604, 22}, {2582, 21}, {2561, 21}, {2540, 20}, {2520, 20},</front>
<front id="speed_lookuptableH-131">   {2500, 20}, {2480, 20}, {2460, 19}, {2441, 19}, {2422, 19}, {2403, 18}, {2385, 18}, {2367, 18},</front>
<front id="speed_lookuptableH-132">   {2349, 17}, {2332, 18}, {2314, 17}, {2297, 16}, {2281, 17}, {2264, 16}, {2248, 16}, {2232, 16},</front>
<front id="speed_lookuptableH-133">   {2216, 16}, {2200, 15}, {2185, 15}, {2170, 15}, {2155, 15}, {2140, 15}, {2125, 14}, {2111, 14},</front>
<front id="speed_lookuptableH-134">   {2097, 14}, {2083, 14}, {2069, 14}, {2055, 13}, {2042, 13}, {2029, 13}, {2016, 13}, {2003, 13},</front>
<front id="speed_lookuptableH-135">   {1990, 13}, {1977, 12}, {1965, 12}, {1953, 13}, {1940, 11}, {1929, 12}, {1917, 12}, {1905, 12},</front>
<front id="speed_lookuptableH-136">   {1893, 11}, {1882, 11}, {1871, 11}, {1860, 11}, {1849, 11}, {1838, 11}, {1827, 11}, {1816, 10},</front>
<front id="speed_lookuptableH-137">   {1806, 11}, {1795, 10}, {1785, 10}, {1775, 10}, {1765, 10}, {1755, 10}, {1745, 9}, {1736, 10},</front>
<front id="speed_lookuptableH-138">   {1726, 9}, {1717, 10}, {1707, 9}, {1698, 9}, {1689, 9}, {1680, 9}, {1671, 9}, {1662, 9},</front>
<front id="speed_lookuptableH-139">   {1653, 9}, {1644, 8}, {1636, 9}, {1627, 8}, {1619, 9}, {1610, 8}, {1602, 8}, {1594, 8},</front>
<front id="speed_lookuptableH-140">   {1586, 8}, {1578, 8}, {1570, 8}, {1562, 8}, {1554, 7}, {1547, 8}, {1539, 8}, {1531, 7},</front>
<front id="speed_lookuptableH-141">   {1524, 8}, {1516, 7}, {1509, 7}, {1502, 7}, {1495, 7}, {1488, 7}, {1481, 7}, {1474, 7},</front>
<front id="speed_lookuptableH-142">   {1467, 7}, {1460, 7}, {1453, 7}, {1446, 6}, {1440, 7}, {1433, 7}, {1426, 6}, {1420, 6},</front>
<front id="speed_lookuptableH-143">   {1414, 7}, {1407, 6}, {1401, 6}, {1395, 7}, {1388, 6}, {1382, 6}, {1376, 6}, {1370, 6},</front>
<front id="speed_lookuptableH-144">   {1364, 6}, {1358, 6}, {1352, 6}, {1346, 5}, {1341, 6}, {1335, 6}, {1329, 5}, {1324, 6},</front>
<front id="speed_lookuptableH-145">   {1318, 5}, {1313, 6}, {1307, 5}, {1302, 6}, {1296, 5}, {1291, 5}, {1286, 6}, {1280, 5},</front>
<front id="speed_lookuptableH-146">   {1275, 5}, {1270, 5}, {1265, 5}, {1260, 5}, {1255, 5}, {1250, 5}, {1245, 5}, {1240, 5},</front>
<front id="speed_lookuptableH-147">   {1235, 5}, {1230, 5}, {1225, 5}, {1220, 5}, {1215, 4}, {1211, 5}, {1206, 5}, {1201, 5},</front>
<front id="speed_lookuptableH-148">};</front>
<front id="speed_lookuptableH-149"></front>
<front id="speed_lookuptableH-150">#endif</front>
<front id="speed_lookuptableH-151"></front>
<front id="speed_lookuptableH-152">#endif</front>
 </pre>
<h1 id="stepperCPPtitle" >stepper.cpp</h1>
<pre id="stepperCPP"  class="prettyprint linenums"><front id="stepperCPP-1">/**</front>
<front id="stepperCPP-2"> * stepper.cpp - stepper motor driver: executes motion plans using stepper motors</front>
<front id="stepperCPP-3"> * Marlin Firmware</front>
<front id="stepperCPP-4"> *</front>
<front id="stepperCPP-5"> * Derived from Grbl</front>
<front id="stepperCPP-6"> * Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="stepperCPP-7"> *</front>
<front id="stepperCPP-8"> * Grbl is free software: you can redistribute it and/or modify</front>
<front id="stepperCPP-9"> * it under the terms of the GNU General Public License as published by</front>
<front id="stepperCPP-10"> * the Free Software Foundation, either version 3 of the License, or</front>
<front id="stepperCPP-11"> * (at your option) any later version.</front>
<front id="stepperCPP-12"> *</front>
<front id="stepperCPP-13"> * Grbl is distributed in the hope that it will be useful,</front>
<front id="stepperCPP-14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="stepperCPP-15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="stepperCPP-16"> * GNU General Public License for more details.</front>
<front id="stepperCPP-17"> *</front>
<front id="stepperCPP-18"> * You should have received a copy of the GNU General Public License</front>
<front id="stepperCPP-19"> * along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="stepperCPP-20"> */</front>
<front id="stepperCPP-21"></front>
<front id="stepperCPP-22">/* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith</front>
<front id="stepperCPP-23">   and Philipp Tiefenbacher. */</front>
<front id="stepperCPP-24"></front>
<front id="stepperCPP-25">#include "Marlin.h"</front>
<front id="stepperCPP-26">#include "stepper.h"</front>
<front id="stepperCPP-27">#include "planner.h"</front>
<front id="stepperCPP-28">#include "temperature.h"</front>
<front id="stepperCPP-29">#include "ultralcd.h"</front>
<front id="stepperCPP-30">#include "language.h"</front>
<front id="stepperCPP-31">#include "cardreader.h"</front>
<front id="stepperCPP-32">#include "speed_lookuptable.h"</front>
<front id="stepperCPP-33">#if HAS_DIGIPOTSS</front>
<front id="stepperCPP-34">  #include &lt;SPI.h&gt;</front>
<front id="stepperCPP-35">#endif</front>
<front id="stepperCPP-36"></front>
<front id="stepperCPP-37">//===========================================================================</front>
<front id="stepperCPP-38">//============================= public variables ============================</front>
<front id="stepperCPP-39">//===========================================================================</front>
<front id="stepperCPP-40">block_t *current_block;  // A pointer to the block currently being traced</front>
<front id="stepperCPP-41"></front>
<front id="stepperCPP-42"></front>
<front id="stepperCPP-43">//===========================================================================</front>
<front id="stepperCPP-44">//============================= private variables ===========================</front>
<front id="stepperCPP-45">//===========================================================================</front>
<front id="stepperCPP-46">//static makes it impossible to be called from outside of this file by extern.!</front>
<front id="stepperCPP-47"></front>
<front id="stepperCPP-48">// Variables used by The Stepper Driver Interrupt</front>
<front id="stepperCPP-49">static unsigned char out_bits = 0;        // The next stepping-bits to be output</front>
<front id="stepperCPP-50">static unsigned int cleaning_buffer_counter;</front>
<front id="stepperCPP-51"></front>
<front id="stepperCPP-52">#if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-53">  static bool performing_homing = false, </front>
<front id="stepperCPP-54">              locked_z_motor = false, </front>
<front id="stepperCPP-55">              locked_z2_motor = false;</front>
<front id="stepperCPP-56">#endif</front>
<front id="stepperCPP-57"></front>
<front id="stepperCPP-58">// Counter variables for the Bresenham line tracer</front>
<front id="stepperCPP-59">static long counter_x, counter_y, counter_z, counter_e;</front>
<front id="stepperCPP-60">volatile static unsigned long step_events_completed; // The number of step events executed in the current block</front>
<front id="stepperCPP-61"></front>
<front id="stepperCPP-62">#if ENABLED(ADVANCE)</front>
<front id="stepperCPP-63">  static long advance_rate, advance, final_advance = 0;</front>
<front id="stepperCPP-64">  static long old_advance = 0;</front>
<front id="stepperCPP-65">  static long e_steps[4];</front>
<front id="stepperCPP-66">#endif</front>
<front id="stepperCPP-67"></front>
<front id="stepperCPP-68">static long acceleration_time, deceleration_time;</front>
<front id="stepperCPP-69">//static unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;</front>
<front id="stepperCPP-70">static unsigned short acc_step_rate; // needed for deceleration start point</front>
<front id="stepperCPP-71">static char step_loops;</front>
<front id="stepperCPP-72">static unsigned short OCR1A_nominal;</front>
<front id="stepperCPP-73">static unsigned short step_loops_nominal;</front>
<front id="stepperCPP-74"></front>
<front id="stepperCPP-75">volatile long endstops_trigsteps[3] = { 0 };</front>
<front id="stepperCPP-76">volatile long endstops_stepsTotal, endstops_stepsDone;</front>
<front id="stepperCPP-77">static volatile char endstop_hit_bits = 0; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value</front>
<front id="stepperCPP-78"></front>
<front id="stepperCPP-79">#if DISABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-80">  static byte</front>
<front id="stepperCPP-81">#else</front>
<front id="stepperCPP-82">  static uint16_t</front>
<front id="stepperCPP-83">#endif</front>
<front id="stepperCPP-84">  old_endstop_bits = 0; // use X_MIN, X_MAX... Z_MAX, Z_MIN_PROBE, Z2_MIN, Z2_MAX</front>
<front id="stepperCPP-85"></front>
<front id="stepperCPP-86">#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="stepperCPP-87">  bool abort_on_endstop_hit = false;</front>
<front id="stepperCPP-88">#endif</front>
<front id="stepperCPP-89"></front>
<front id="stepperCPP-90">#if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)</front>
<front id="stepperCPP-91">  int motor_current_setting[3] = DEFAULT_PWM_MOTOR_CURRENT;</front>
<front id="stepperCPP-92">#endif</front>
<front id="stepperCPP-93"></front>
<front id="stepperCPP-94">static bool check_endstops = true;</front>
<front id="stepperCPP-95"></front>
<front id="stepperCPP-96">volatile long count_position[NUM_AXIS] = { 0 };</front>
<front id="stepperCPP-97">volatile signed char count_direction[NUM_AXIS] = { 1, 1, 1, 1 };</front>
<front id="stepperCPP-98"></front>
<front id="stepperCPP-99"></front>
<front id="stepperCPP-100">//===========================================================================</front>
<front id="stepperCPP-101">//================================ functions ================================</front>
<front id="stepperCPP-102">//===========================================================================</front>
<front id="stepperCPP-103"></front>
<front id="stepperCPP-104">#if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="stepperCPP-105">  #define X_APPLY_DIR(v,ALWAYS) \</front>
<front id="stepperCPP-106">    if (extruder_duplication_enabled || ALWAYS) { \</front>
<front id="stepperCPP-107">      X_DIR_WRITE(v); \</front>
<front id="stepperCPP-108">      X2_DIR_WRITE(v); \</front>
<front id="stepperCPP-109">    } \</front>
<front id="stepperCPP-110">    else { \</front>
<front id="stepperCPP-111">      if (current_block-&gt;active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \</front>
<front id="stepperCPP-112">    }</front>
<front id="stepperCPP-113">  #define X_APPLY_STEP(v,ALWAYS) \</front>
<front id="stepperCPP-114">    if (extruder_duplication_enabled || ALWAYS) { \</front>
<front id="stepperCPP-115">      X_STEP_WRITE(v); \</front>
<front id="stepperCPP-116">      X2_STEP_WRITE(v); \</front>
<front id="stepperCPP-117">    } \</front>
<front id="stepperCPP-118">    else { \</front>
<front id="stepperCPP-119">      if (current_block-&gt;active_extruder != 0) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \</front>
<front id="stepperCPP-120">    }</front>
<front id="stepperCPP-121">#else</front>
<front id="stepperCPP-122">  #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)</front>
<front id="stepperCPP-123">  #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)</front>
<front id="stepperCPP-124">#endif</front>
<front id="stepperCPP-125"></front>
<front id="stepperCPP-126">#if ENABLED(Y_DUAL_STEPPER_DRIVERS)</front>
<front id="stepperCPP-127">  #define Y_APPLY_DIR(v,Q) { Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }</front>
<front id="stepperCPP-128">  #define Y_APPLY_STEP(v,Q) { Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }</front>
<front id="stepperCPP-129">#else</front>
<front id="stepperCPP-130">  #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)</front>
<front id="stepperCPP-131">  #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)</front>
<front id="stepperCPP-132">#endif</front>
<front id="stepperCPP-133"></front>
<front id="stepperCPP-134">#if ENABLED(Z_DUAL_STEPPER_DRIVERS)</front>
<front id="stepperCPP-135">  #define Z_APPLY_DIR(v,Q) { Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }</front>
<front id="stepperCPP-136">  #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-137">    #define Z_APPLY_STEP(v,Q) \</front>
<front id="stepperCPP-138">    if (performing_homing) { \</front>
<front id="stepperCPP-139">      if (Z_HOME_DIR &gt; 0) {\</front>
<front id="stepperCPP-140">        if (!(TEST(old_endstop_bits, Z_MAX) && (count_direction[Z_AXIS] &gt; 0)) && !locked_z_motor) Z_STEP_WRITE(v); \</front>
<front id="stepperCPP-141">        if (!(TEST(old_endstop_bits, Z2_MAX) && (count_direction[Z_AXIS] &gt; 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \</front>
<front id="stepperCPP-142">      } else {\</front>
<front id="stepperCPP-143">        if (!(TEST(old_endstop_bits, Z_MIN) && (count_direction[Z_AXIS] &lt; 0)) && !locked_z_motor) Z_STEP_WRITE(v); \</front>
<front id="stepperCPP-144">        if (!(TEST(old_endstop_bits, Z2_MIN) && (count_direction[Z_AXIS] &lt; 0)) && !locked_z2_motor) Z2_STEP_WRITE(v); \</front>
<front id="stepperCPP-145">      } \</front>
<front id="stepperCPP-146">    } else { \</front>
<front id="stepperCPP-147">      Z_STEP_WRITE(v); \</front>
<front id="stepperCPP-148">      Z2_STEP_WRITE(v); \</front>
<front id="stepperCPP-149">    }</front>
<front id="stepperCPP-150">  #else</front>
<front id="stepperCPP-151">    #define Z_APPLY_STEP(v,Q) { Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }</front>
<front id="stepperCPP-152">  #endif</front>
<front id="stepperCPP-153">#else</front>
<front id="stepperCPP-154">  #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)</front>
<front id="stepperCPP-155">  #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)</front>
<front id="stepperCPP-156">#endif</front>
<front id="stepperCPP-157"></front>
<front id="stepperCPP-158">#define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)</front>
<front id="stepperCPP-159"></front>
<front id="stepperCPP-160">// intRes = intIn1 * intIn2 &gt;&gt; 16</front>
<front id="stepperCPP-161">// uses:</front>
<front id="stepperCPP-162">// r26 to store 0</front>
<front id="stepperCPP-163">// r27 to store the byte 1 of the 24 bit result</front>
<front id="stepperCPP-164">#define MultiU16X8toH16(intRes, charIn1, intIn2) \</front>
<front id="stepperCPP-165">  asm volatile ( \</front>
<front id="stepperCPP-166">    "clr r26 \n\t" \</front>
<front id="stepperCPP-167">    "mul %A1, %B2 \n\t" \</front>
<front id="stepperCPP-168">    "movw %A0, r0 \n\t" \</front>
<front id="stepperCPP-169">    "mul %A1, %A2 \n\t" \</front>
<front id="stepperCPP-170">    "add %A0, r1 \n\t" \</front>
<front id="stepperCPP-171">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-172">    "lsr r0 \n\t" \</front>
<front id="stepperCPP-173">    "adc %A0, r26 \n\t" \</front>
<front id="stepperCPP-174">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-175">    "clr r1 \n\t" \</front>
<front id="stepperCPP-176">    : \</front>
<front id="stepperCPP-177">    "=&r" (intRes) \</front>
<front id="stepperCPP-178">    : \</front>
<front id="stepperCPP-179">    "d" (charIn1), \</front>
<front id="stepperCPP-180">    "d" (intIn2) \</front>
<front id="stepperCPP-181">    : \</front>
<front id="stepperCPP-182">    "r26" \</front>
<front id="stepperCPP-183">  )</front>
<front id="stepperCPP-184"></front>
<front id="stepperCPP-185">// intRes = longIn1 * longIn2 &gt;&gt; 24</front>
<front id="stepperCPP-186">// uses:</front>
<front id="stepperCPP-187">// r26 to store 0</front>
<front id="stepperCPP-188">// r27 to store bits 16-23 of the 48bit result. The top bit is used to round the two byte result.</front>
<front id="stepperCPP-189">// note that the lower two bytes and the upper byte of the 48bit result are not calculated.</front>
<front id="stepperCPP-190">// this can cause the result to be out by one as the lower bytes may cause carries into the upper ones.</front>
<front id="stepperCPP-191">// B0 A0 are bits 24-39 and are the returned value</front>
<front id="stepperCPP-192">// C1 B1 A1 is longIn1</front>
<front id="stepperCPP-193">// D2 C2 B2 A2 is longIn2</front>
<front id="stepperCPP-194">//</front>
<front id="stepperCPP-195">#define MultiU24X32toH16(intRes, longIn1, longIn2) \</front>
<front id="stepperCPP-196">  asm volatile ( \</front>
<front id="stepperCPP-197">    "clr r26 \n\t" \</front>
<front id="stepperCPP-198">    "mul %A1, %B2 \n\t" \</front>
<front id="stepperCPP-199">    "mov r27, r1 \n\t" \</front>
<front id="stepperCPP-200">    "mul %B1, %C2 \n\t" \</front>
<front id="stepperCPP-201">    "movw %A0, r0 \n\t" \</front>
<front id="stepperCPP-202">    "mul %C1, %C2 \n\t" \</front>
<front id="stepperCPP-203">    "add %B0, r0 \n\t" \</front>
<front id="stepperCPP-204">    "mul %C1, %B2 \n\t" \</front>
<front id="stepperCPP-205">    "add %A0, r0 \n\t" \</front>
<front id="stepperCPP-206">    "adc %B0, r1 \n\t" \</front>
<front id="stepperCPP-207">    "mul %A1, %C2 \n\t" \</front>
<front id="stepperCPP-208">    "add r27, r0 \n\t" \</front>
<front id="stepperCPP-209">    "adc %A0, r1 \n\t" \</front>
<front id="stepperCPP-210">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-211">    "mul %B1, %B2 \n\t" \</front>
<front id="stepperCPP-212">    "add r27, r0 \n\t" \</front>
<front id="stepperCPP-213">    "adc %A0, r1 \n\t" \</front>
<front id="stepperCPP-214">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-215">    "mul %C1, %A2 \n\t" \</front>
<front id="stepperCPP-216">    "add r27, r0 \n\t" \</front>
<front id="stepperCPP-217">    "adc %A0, r1 \n\t" \</front>
<front id="stepperCPP-218">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-219">    "mul %B1, %A2 \n\t" \</front>
<front id="stepperCPP-220">    "add r27, r1 \n\t" \</front>
<front id="stepperCPP-221">    "adc %A0, r26 \n\t" \</front>
<front id="stepperCPP-222">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-223">    "lsr r27 \n\t" \</front>
<front id="stepperCPP-224">    "adc %A0, r26 \n\t" \</front>
<front id="stepperCPP-225">    "adc %B0, r26 \n\t" \</front>
<front id="stepperCPP-226">    "mul %D2, %A1 \n\t" \</front>
<front id="stepperCPP-227">    "add %A0, r0 \n\t" \</front>
<front id="stepperCPP-228">    "adc %B0, r1 \n\t" \</front>
<front id="stepperCPP-229">    "mul %D2, %B1 \n\t" \</front>
<front id="stepperCPP-230">    "add %B0, r0 \n\t" \</front>
<front id="stepperCPP-231">    "clr r1 \n\t" \</front>
<front id="stepperCPP-232">    : \</front>
<front id="stepperCPP-233">    "=&r" (intRes) \</front>
<front id="stepperCPP-234">    : \</front>
<front id="stepperCPP-235">    "d" (longIn1), \</front>
<front id="stepperCPP-236">    "d" (longIn2) \</front>
<front id="stepperCPP-237">    : \</front>
<front id="stepperCPP-238">    "r26" , "r27" \</front>
<front id="stepperCPP-239">  )</front>
<front id="stepperCPP-240"></front>
<front id="stepperCPP-241">// Some useful constants</front>
<front id="stepperCPP-242"></front>
<front id="stepperCPP-243">#define ENABLE_STEPPER_DRIVER_INTERRUPT()  TIMSK1 |= BIT(OCIE1A)</front>
<front id="stepperCPP-244">#define DISABLE_STEPPER_DRIVER_INTERRUPT() TIMSK1 &= ~BIT(OCIE1A)</front>
<front id="stepperCPP-245"></front>
<front id="stepperCPP-246">void endstops_hit_on_purpose() {</front>
<front id="stepperCPP-247">  endstop_hit_bits = 0;</front>
<front id="stepperCPP-248">}</front>
<front id="stepperCPP-249"></front>
<front id="stepperCPP-250">void checkHitEndstops() {</front>
<front id="stepperCPP-251">  if (endstop_hit_bits) {</front>
<front id="stepperCPP-252">    SERIAL_ECHO_START;</front>
<front id="stepperCPP-253">    SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);</front>
<front id="stepperCPP-254">    if (endstop_hit_bits & BIT(X_MIN)) {</front>
<front id="stepperCPP-255">      SERIAL_ECHOPAIR(" X:", (float)endstops_trigsteps[X_AXIS] / axis_steps_per_unit[X_AXIS]);</front>
<front id="stepperCPP-256">      LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "X");</front>
<front id="stepperCPP-257">    }</front>
<front id="stepperCPP-258">    if (endstop_hit_bits & BIT(Y_MIN)) {</front>
<front id="stepperCPP-259">      SERIAL_ECHOPAIR(" Y:", (float)endstops_trigsteps[Y_AXIS] / axis_steps_per_unit[Y_AXIS]);</front>
<front id="stepperCPP-260">      LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Y");</front>
<front id="stepperCPP-261">    }</front>
<front id="stepperCPP-262">    if (endstop_hit_bits & BIT(Z_MIN)) {</front>
<front id="stepperCPP-263">      SERIAL_ECHOPAIR(" Z:", (float)endstops_trigsteps[Z_AXIS] / axis_steps_per_unit[Z_AXIS]);</front>
<front id="stepperCPP-264">      LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "Z");</front>
<front id="stepperCPP-265">    }</front>
<front id="stepperCPP-266">    #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="stepperCPP-267">      if (endstop_hit_bits & BIT(Z_MIN_PROBE)) {</front>
<front id="stepperCPP-268">        SERIAL_ECHOPAIR(" Z_MIN_PROBE:", (float)endstops_trigsteps[Z_AXIS] / axis_steps_per_unit[Z_AXIS]);</front>
<front id="stepperCPP-269">        LCD_MESSAGEPGM(MSG_ENDSTOPS_HIT "ZP");</front>
<front id="stepperCPP-270">      }</front>
<front id="stepperCPP-271">    #endif</front>
<front id="stepperCPP-272">    SERIAL_EOL;</front>
<front id="stepperCPP-273"></front>
<front id="stepperCPP-274">    endstops_hit_on_purpose();</front>
<front id="stepperCPP-275"></front>
<front id="stepperCPP-276">    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)</front>
<front id="stepperCPP-277">      if (abort_on_endstop_hit) {</front>
<front id="stepperCPP-278">        card.sdprinting = false;</front>
<front id="stepperCPP-279">        card.closefile();</front>
<front id="stepperCPP-280">        quickStop();</front>
<front id="stepperCPP-281">        disable_all_heaters(); // switch off all heaters.</front>
<front id="stepperCPP-282">      }</front>
<front id="stepperCPP-283">    #endif</front>
<front id="stepperCPP-284">  }</front>
<front id="stepperCPP-285">}</front>
<front id="stepperCPP-286"></front>
<front id="stepperCPP-287">void enable_endstops(bool check) { check_endstops = check; }</front>
<front id="stepperCPP-288"></front>
<front id="stepperCPP-289">// Check endstops</front>
<front id="stepperCPP-290">inline void update_endstops() {</front>
<front id="stepperCPP-291">  </front>
<front id="stepperCPP-292">  #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-293">    uint16_t</front>
<front id="stepperCPP-294">  #else</front>
<front id="stepperCPP-295">    byte</front>
<front id="stepperCPP-296">  #endif</front>
<front id="stepperCPP-297">      current_endstop_bits = 0;</front>
<front id="stepperCPP-298"></front>
<front id="stepperCPP-299">  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN</front>
<front id="stepperCPP-300">  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING</front>
<front id="stepperCPP-301">  #define _AXIS(AXIS) AXIS ##_AXIS</front>
<front id="stepperCPP-302">  #define _ENDSTOP_HIT(AXIS) endstop_hit_bits |= BIT(_ENDSTOP(AXIS, MIN))</front>
<front id="stepperCPP-303">  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX</front>
<front id="stepperCPP-304"></front>
<front id="stepperCPP-305">  // SET_ENDSTOP_BIT: set the current endstop bits for an endstop to its status</front>
<front id="stepperCPP-306">  #define SET_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))</front>
<front id="stepperCPP-307">  // COPY_BIT: copy the value of COPY_BIT to BIT in bits</front>
<front id="stepperCPP-308">  #define COPY_BIT(bits, COPY_BIT, BIT) SET_BIT(bits, BIT, TEST(bits, COPY_BIT))</front>
<front id="stepperCPP-309">  // TEST_ENDSTOP: test the old and the current status of an endstop</front>
<front id="stepperCPP-310">  #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP) && TEST(old_endstop_bits, ENDSTOP))</front>
<front id="stepperCPP-311"></front>
<front id="stepperCPP-312">  #define UPDATE_ENDSTOP(AXIS,MINMAX) \</front>
<front id="stepperCPP-313">    SET_ENDSTOP_BIT(AXIS, MINMAX); \</front>
<front id="stepperCPP-314">    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))  && (current_block-&gt;steps[_AXIS(AXIS)] &gt; 0)) { \</front>
<front id="stepperCPP-315">      endstops_trigsteps[_AXIS(AXIS)] = count_position[_AXIS(AXIS)]; \</front>
<front id="stepperCPP-316">      _ENDSTOP_HIT(AXIS); \</front>
<front id="stepperCPP-317">      step_events_completed = current_block-&gt;step_event_count; \</front>
<front id="stepperCPP-318">    }</front>
<front id="stepperCPP-319">  </front>
<front id="stepperCPP-320">  #if ENABLED(COREXY)</front>
<front id="stepperCPP-321">    // Head direction in -X axis for CoreXY bots.</front>
<front id="stepperCPP-322">    // If DeltaX == -DeltaY, the movement is only in Y axis</front>
<front id="stepperCPP-323">    if ((current_block-&gt;steps[A_AXIS] != current_block-&gt;steps[B_AXIS]) || (TEST(out_bits, A_AXIS) == TEST(out_bits, B_AXIS))) {</front>
<front id="stepperCPP-324">      if (TEST(out_bits, X_HEAD))</front>
<front id="stepperCPP-325">  #elif ENABLED(COREXZ)</front>
<front id="stepperCPP-326">    // Head direction in -X axis for CoreXZ bots.</front>
<front id="stepperCPP-327">    // If DeltaX == -DeltaZ, the movement is only in Z axis</front>
<front id="stepperCPP-328">    if ((current_block-&gt;steps[A_AXIS] != current_block-&gt;steps[C_AXIS]) || (TEST(out_bits, A_AXIS) == TEST(out_bits, C_AXIS))) {</front>
<front id="stepperCPP-329">      if (TEST(out_bits, X_HEAD))</front>
<front id="stepperCPP-330">  #else</front>
<front id="stepperCPP-331">      if (TEST(out_bits, X_AXIS))   // stepping along -X axis (regular Cartesian bot)</front>
<front id="stepperCPP-332">  #endif</front>
<front id="stepperCPP-333">      { // -direction</front>
<front id="stepperCPP-334">        #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="stepperCPP-335">          // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder</front>
<front id="stepperCPP-336">          if ((current_block-&gt;active_extruder == 0 && X_HOME_DIR == -1) || (current_block-&gt;active_extruder != 0 && X2_HOME_DIR == -1))</front>
<front id="stepperCPP-337">        #endif</front>
<front id="stepperCPP-338">          {</front>
<front id="stepperCPP-339">            #if HAS_X_MIN</front>
<front id="stepperCPP-340">              UPDATE_ENDSTOP(X, MIN);</front>
<front id="stepperCPP-341">            #endif</front>
<front id="stepperCPP-342">          }</front>
<front id="stepperCPP-343">      }</front>
<front id="stepperCPP-344">      else { // +direction</front>
<front id="stepperCPP-345">        #if ENABLED(DUAL_X_CARRIAGE)</front>
<front id="stepperCPP-346">          // with 2 x-carriages, endstops are only checked in the homing direction for the active extruder</front>
<front id="stepperCPP-347">          if ((current_block-&gt;active_extruder == 0 && X_HOME_DIR == 1) || (current_block-&gt;active_extruder != 0 && X2_HOME_DIR == 1))</front>
<front id="stepperCPP-348">        #endif</front>
<front id="stepperCPP-349">          {</front>
<front id="stepperCPP-350">            #if HAS_X_MAX</front>
<front id="stepperCPP-351">              UPDATE_ENDSTOP(X, MAX);</front>
<front id="stepperCPP-352">            #endif</front>
<front id="stepperCPP-353">          }</front>
<front id="stepperCPP-354">      }</front>
<front id="stepperCPP-355">  #if ENABLED(COREXY) || ENABLED(COREXZ)</front>
<front id="stepperCPP-356">    }</front>
<front id="stepperCPP-357">  #endif</front>
<front id="stepperCPP-358"></front>
<front id="stepperCPP-359">  #if ENABLED(COREXY)</front>
<front id="stepperCPP-360">    // Head direction in -Y axis for CoreXY bots.</front>
<front id="stepperCPP-361">    // If DeltaX == DeltaY, the movement is only in X axis</front>
<front id="stepperCPP-362">    if ((current_block-&gt;steps[A_AXIS] != current_block-&gt;steps[B_AXIS]) || (TEST(out_bits, A_AXIS) != TEST(out_bits, B_AXIS))) {</front>
<front id="stepperCPP-363">      if (TEST(out_bits, Y_HEAD))</front>
<front id="stepperCPP-364">  #else</front>
<front id="stepperCPP-365">      if (TEST(out_bits, Y_AXIS))   // -direction</front>
<front id="stepperCPP-366">  #endif</front>
<front id="stepperCPP-367">      { // -direction</front>
<front id="stepperCPP-368">        #if HAS_Y_MIN</front>
<front id="stepperCPP-369">          UPDATE_ENDSTOP(Y, MIN);</front>
<front id="stepperCPP-370">        #endif</front>
<front id="stepperCPP-371">      }</front>
<front id="stepperCPP-372">      else { // +direction</front>
<front id="stepperCPP-373">        #if HAS_Y_MAX</front>
<front id="stepperCPP-374">          UPDATE_ENDSTOP(Y, MAX);</front>
<front id="stepperCPP-375">        #endif</front>
<front id="stepperCPP-376">      }</front>
<front id="stepperCPP-377">  #if ENABLED(COREXY)</front>
<front id="stepperCPP-378">    }</front>
<front id="stepperCPP-379">  #endif</front>
<front id="stepperCPP-380"></front>
<front id="stepperCPP-381">  #if ENABLED(COREXZ)</front>
<front id="stepperCPP-382">    // Head direction in -Z axis for CoreXZ bots.</front>
<front id="stepperCPP-383">    // If DeltaX == DeltaZ, the movement is only in X axis</front>
<front id="stepperCPP-384">    if ((current_block-&gt;steps[A_AXIS] != current_block-&gt;steps[C_AXIS]) || (TEST(out_bits, A_AXIS) != TEST(out_bits, C_AXIS))) {</front>
<front id="stepperCPP-385">      if (TEST(out_bits, Z_HEAD))</front>
<front id="stepperCPP-386">  #else</front>
<front id="stepperCPP-387">      if (TEST(out_bits, Z_AXIS))</front>
<front id="stepperCPP-388">  #endif</front>
<front id="stepperCPP-389">      { // z -direction</front>
<front id="stepperCPP-390">        #if HAS_Z_MIN</front>
<front id="stepperCPP-391"></front>
<front id="stepperCPP-392">          #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-393">            SET_ENDSTOP_BIT(Z, MIN);</front>
<front id="stepperCPP-394">              #if HAS_Z2_MIN</front>
<front id="stepperCPP-395">                SET_ENDSTOP_BIT(Z2, MIN);</front>
<front id="stepperCPP-396">              #else</front>
<front id="stepperCPP-397">                COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);</front>
<front id="stepperCPP-398">              #endif</front>
<front id="stepperCPP-399"></front>
<front id="stepperCPP-400">            byte z_test = TEST_ENDSTOP(Z_MIN) &lt;&lt; 0 + TEST_ENDSTOP(Z2_MIN) &lt;&lt; 1; // bit 0 for Z, bit 1 for Z2</front>
<front id="stepperCPP-401"></front>
<front id="stepperCPP-402">            if (z_test && current_block-&gt;steps[Z_AXIS] &gt; 0) { // z_test = Z_MIN || Z2_MIN</front>
<front id="stepperCPP-403">              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];</front>
<front id="stepperCPP-404">              endstop_hit_bits |= BIT(Z_MIN);</front>
<front id="stepperCPP-405">              if (!performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...</front>
<front id="stepperCPP-406">                step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-407">            }</front>
<front id="stepperCPP-408">          #else // !Z_DUAL_ENDSTOPS</front>
<front id="stepperCPP-409"></front>
<front id="stepperCPP-410">            UPDATE_ENDSTOP(Z, MIN);</front>
<front id="stepperCPP-411">          #endif // !Z_DUAL_ENDSTOPS</front>
<front id="stepperCPP-412">        #endif // Z_MIN_PIN</front>
<front id="stepperCPP-413"></front>
<front id="stepperCPP-414">        #if ENABLED(Z_MIN_PROBE_ENDSTOP)</front>
<front id="stepperCPP-415">          UPDATE_ENDSTOP(Z, MIN_PROBE);</front>
<front id="stepperCPP-416"></front>
<front id="stepperCPP-417">          if (TEST_ENDSTOP(Z_MIN_PROBE))</front>
<front id="stepperCPP-418">          {</front>
<front id="stepperCPP-419">            endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];</front>
<front id="stepperCPP-420">            endstop_hit_bits |= BIT(Z_MIN_PROBE);</front>
<front id="stepperCPP-421">          }</front>
<front id="stepperCPP-422">        #endif</front>
<front id="stepperCPP-423">      }</front>
<front id="stepperCPP-424">      else { // z +direction</front>
<front id="stepperCPP-425">        #if HAS_Z_MAX</front>
<front id="stepperCPP-426"></front>
<front id="stepperCPP-427">          #if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-428"></front>
<front id="stepperCPP-429">            SET_ENDSTOP_BIT(Z, MAX);</front>
<front id="stepperCPP-430">              #if HAS_Z2_MAX</front>
<front id="stepperCPP-431">                SET_ENDSTOP_BIT(Z2, MAX);</front>
<front id="stepperCPP-432">              #else</front>
<front id="stepperCPP-433">                COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);</front>
<front id="stepperCPP-434">              #endif</front>
<front id="stepperCPP-435"></front>
<front id="stepperCPP-436">            byte z_test = TEST_ENDSTOP(Z_MAX) &lt;&lt; 0 + TEST_ENDSTOP(Z2_MAX) &lt;&lt; 1; // bit 0 for Z, bit 1 for Z2</front>
<front id="stepperCPP-437"></front>
<front id="stepperCPP-438">            if (z_test && current_block-&gt;steps[Z_AXIS] &gt; 0) {  // t_test = Z_MAX || Z2_MAX</front>
<front id="stepperCPP-439">              endstops_trigsteps[Z_AXIS] = count_position[Z_AXIS];</front>
<front id="stepperCPP-440">              endstop_hit_bits |= BIT(Z_MIN);</front>
<front id="stepperCPP-441">              if (!performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...</front>
<front id="stepperCPP-442">                step_events_completed = current_block-&gt;step_event_count;</front>
<front id="stepperCPP-443">            }</front>
<front id="stepperCPP-444"></front>
<front id="stepperCPP-445">          #else // !Z_DUAL_ENDSTOPS</front>
<front id="stepperCPP-446"></front>
<front id="stepperCPP-447">            UPDATE_ENDSTOP(Z, MAX);</front>
<front id="stepperCPP-448"></front>
<front id="stepperCPP-449">          #endif // !Z_DUAL_ENDSTOPS</front>
<front id="stepperCPP-450">        #endif // Z_MAX_PIN</front>
<front id="stepperCPP-451">      }</front>
<front id="stepperCPP-452">  #if ENABLED(COREXZ)</front>
<front id="stepperCPP-453">    }</front>
<front id="stepperCPP-454">  #endif  </front>
<front id="stepperCPP-455">  old_endstop_bits = current_endstop_bits;</front>
<front id="stepperCPP-456">}</front>
<front id="stepperCPP-457"></front>
<front id="stepperCPP-458">//         __________________________</front>
<front id="stepperCPP-459">//        /|                        |\     _________________         ^</front>
<front id="stepperCPP-460">//       / |                        | \   /|               |\        |</front>
<front id="stepperCPP-461">//      /  |                        |  \ / |               | \       s</front>
<front id="stepperCPP-462">//     /   |                        |   |  |               |  \      p</front>
<front id="stepperCPP-463">//    /    |                        |   |  |               |   \     e</front>
<front id="stepperCPP-464">//   +-----+------------------------+---+--+---------------+----+    e</front>
<front id="stepperCPP-465">//   |               BLOCK 1            |      BLOCK 2          |    d</front>
<front id="stepperCPP-466">//</front>
<front id="stepperCPP-467">//                           time -----&gt;</front>
<front id="stepperCPP-468">//</front>
<front id="stepperCPP-469">//  The trapezoid is the shape the speed curve over time. It starts at block-&gt;initial_rate, accelerates</front>
<front id="stepperCPP-470">//  first block-&gt;accelerate_until step_events_completed, then keeps going at constant speed until</front>
<front id="stepperCPP-471">//  step_events_completed reaches block-&gt;decelerate_after after which it decelerates until the trapezoid generator is reset.</front>
<front id="stepperCPP-472">//  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.</front>
<front id="stepperCPP-473"></front>
<front id="stepperCPP-474">void st_wake_up() {</front>
<front id="stepperCPP-475">  //  TCNT1 = 0;</front>
<front id="stepperCPP-476">  ENABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-477">}</front>
<front id="stepperCPP-478"></front>
<front id="stepperCPP-479">FORCE_INLINE unsigned short calc_timer(unsigned short step_rate) {</front>
<front id="stepperCPP-480">  unsigned short timer;</front>
<front id="stepperCPP-481">  if (step_rate &gt; MAX_STEP_FREQUENCY) step_rate = MAX_STEP_FREQUENCY;</front>
<front id="stepperCPP-482"></front>
<front id="stepperCPP-483">  if (step_rate &gt; 20000) { // If steprate &gt; 20kHz &gt;&gt; step 4 times</front>
<front id="stepperCPP-484">    step_rate = (step_rate &gt;&gt; 2) & 0x3fff;</front>
<front id="stepperCPP-485">    step_loops = 4;</front>
<front id="stepperCPP-486">  }</front>
<front id="stepperCPP-487">  else if (step_rate &gt; 10000) { // If steprate &gt; 10kHz &gt;&gt; step 2 times</front>
<front id="stepperCPP-488">    step_rate = (step_rate &gt;&gt; 1) & 0x7fff;</front>
<front id="stepperCPP-489">    step_loops = 2;</front>
<front id="stepperCPP-490">  }</front>
<front id="stepperCPP-491">  else {</front>
<front id="stepperCPP-492">    step_loops = 1;</front>
<front id="stepperCPP-493">  }</front>
<front id="stepperCPP-494"></front>
<front id="stepperCPP-495">  if (step_rate &lt; (F_CPU / 500000)) step_rate = (F_CPU / 500000);</front>
<front id="stepperCPP-496">  step_rate -= (F_CPU / 500000); // Correct for minimal speed</front>
<front id="stepperCPP-497">  if (step_rate &gt;= (8 * 256)) { // higher step rate</front>
<front id="stepperCPP-498">    unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate&gt;&gt;8)][0];</front>
<front id="stepperCPP-499">    unsigned char tmp_step_rate = (step_rate & 0x00ff);</front>
<front id="stepperCPP-500">    unsigned short gain = (unsigned short)pgm_read_word_near(table_address+2);</front>
<front id="stepperCPP-501">    MultiU16X8toH16(timer, tmp_step_rate, gain);</front>
<front id="stepperCPP-502">    timer = (unsigned short)pgm_read_word_near(table_address) - timer;</front>
<front id="stepperCPP-503">  }</front>
<front id="stepperCPP-504">  else { // lower step rates</front>
<front id="stepperCPP-505">    unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];</front>
<front id="stepperCPP-506">    table_address += ((step_rate)&gt;&gt;1) & 0xfffc;</front>
<front id="stepperCPP-507">    timer = (unsigned short)pgm_read_word_near(table_address);</front>
<front id="stepperCPP-508">    timer -= (((unsigned short)pgm_read_word_near(table_address+2) * (unsigned char)(step_rate & 0x0007))&gt;&gt;3);</front>
<front id="stepperCPP-509">  }</front>
<front id="stepperCPP-510">  if (timer &lt; 100) { timer = 100; MYSERIAL.print(MSG_STEPPER_TOO_HIGH); MYSERIAL.println(step_rate); }//(20kHz this should never happen)</front>
<front id="stepperCPP-511">  return timer;</front>
<front id="stepperCPP-512">}</front>
<front id="stepperCPP-513"></front>
<front id="stepperCPP-514">/**</front>
<front id="stepperCPP-515"> * Set the stepper direction of each axis</front>
<front id="stepperCPP-516"> *</front>
<front id="stepperCPP-517"> *   X_AXIS=A_AXIS and Y_AXIS=B_AXIS for COREXY</front>
<front id="stepperCPP-518"> *   X_AXIS=A_AXIS and Z_AXIS=C_AXIS for COREXZ</front>
<front id="stepperCPP-519"> */</front>
<front id="stepperCPP-520">void set_stepper_direction() {</front>
<front id="stepperCPP-521"></front>
<front id="stepperCPP-522">  if (TEST(out_bits, X_AXIS)) { // A_AXIS</front>
<front id="stepperCPP-523">    X_APPLY_DIR(INVERT_X_DIR, 0);</front>
<front id="stepperCPP-524">    count_direction[X_AXIS] = -1;</front>
<front id="stepperCPP-525">  }</front>
<front id="stepperCPP-526">  else {</front>
<front id="stepperCPP-527">    X_APPLY_DIR(!INVERT_X_DIR, 0);</front>
<front id="stepperCPP-528">    count_direction[X_AXIS] = 1;</front>
<front id="stepperCPP-529">  }</front>
<front id="stepperCPP-530"></front>
<front id="stepperCPP-531">  if (TEST(out_bits, Y_AXIS)) { // B_AXIS</front>
<front id="stepperCPP-532">    Y_APPLY_DIR(INVERT_Y_DIR, 0);</front>
<front id="stepperCPP-533">    count_direction[Y_AXIS] = -1;</front>
<front id="stepperCPP-534">  }</front>
<front id="stepperCPP-535">  else {</front>
<front id="stepperCPP-536">    Y_APPLY_DIR(!INVERT_Y_DIR, 0);</front>
<front id="stepperCPP-537">    count_direction[Y_AXIS] = 1;</front>
<front id="stepperCPP-538">  }</front>
<front id="stepperCPP-539">  </front>
<front id="stepperCPP-540">  if (TEST(out_bits, Z_AXIS)) { // C_AXIS</front>
<front id="stepperCPP-541">    Z_APPLY_DIR(INVERT_Z_DIR, 0);</front>
<front id="stepperCPP-542">    count_direction[Z_AXIS] = -1;</front>
<front id="stepperCPP-543">  }</front>
<front id="stepperCPP-544">  else {</front>
<front id="stepperCPP-545">    Z_APPLY_DIR(!INVERT_Z_DIR, 0);</front>
<front id="stepperCPP-546">    count_direction[Z_AXIS] = 1;</front>
<front id="stepperCPP-547">  }</front>
<front id="stepperCPP-548">  </front>
<front id="stepperCPP-549">  #if DISABLED(ADVANCE)</front>
<front id="stepperCPP-550">    if (TEST(out_bits, E_AXIS)) {</front>
<front id="stepperCPP-551">      REV_E_DIR();</front>
<front id="stepperCPP-552">      count_direction[E_AXIS] = -1;</front>
<front id="stepperCPP-553">    }</front>
<front id="stepperCPP-554">    else {</front>
<front id="stepperCPP-555">      NORM_E_DIR();</front>
<front id="stepperCPP-556">      count_direction[E_AXIS] = 1;</front>
<front id="stepperCPP-557">    }</front>
<front id="stepperCPP-558">  #endif //!ADVANCE</front>
<front id="stepperCPP-559">}</front>
<front id="stepperCPP-560"></front>
<front id="stepperCPP-561">// Initializes the trapezoid generator from the current block. Called whenever a new</front>
<front id="stepperCPP-562">// block begins.</front>
<front id="stepperCPP-563">FORCE_INLINE void trapezoid_generator_reset() {</front>
<front id="stepperCPP-564"></front>
<front id="stepperCPP-565">  if (current_block-&gt;direction_bits != out_bits) {</front>
<front id="stepperCPP-566">    out_bits = current_block-&gt;direction_bits;</front>
<front id="stepperCPP-567">    set_stepper_direction();</front>
<front id="stepperCPP-568">  }</front>
<front id="stepperCPP-569">  </front>
<front id="stepperCPP-570">  #if ENABLED(ADVANCE)</front>
<front id="stepperCPP-571">    advance = current_block-&gt;initial_advance;</front>
<front id="stepperCPP-572">    final_advance = current_block-&gt;final_advance;</front>
<front id="stepperCPP-573">    // Do E steps + advance steps</front>
<front id="stepperCPP-574">    e_steps[current_block-&gt;active_extruder] += ((advance &gt;&gt;8) - old_advance);</front>
<front id="stepperCPP-575">    old_advance = advance &gt;&gt;8;</front>
<front id="stepperCPP-576">  #endif</front>
<front id="stepperCPP-577">  deceleration_time = 0;</front>
<front id="stepperCPP-578">  // step_rate to timer interval</front>
<front id="stepperCPP-579">  OCR1A_nominal = calc_timer(current_block-&gt;nominal_rate);</front>
<front id="stepperCPP-580">  // make a note of the number of step loops required at nominal speed</front>
<front id="stepperCPP-581">  step_loops_nominal = step_loops;</front>
<front id="stepperCPP-582">  acc_step_rate = current_block-&gt;initial_rate;</front>
<front id="stepperCPP-583">  acceleration_time = calc_timer(acc_step_rate);</front>
<front id="stepperCPP-584">  OCR1A = acceleration_time;</front>
<front id="stepperCPP-585"></front>
<front id="stepperCPP-586">  // SERIAL_ECHO_START;</front>
<front id="stepperCPP-587">  // SERIAL_ECHOPGM("advance :");</front>
<front id="stepperCPP-588">  // SERIAL_ECHO(current_block-&gt;advance/256.0);</front>
<front id="stepperCPP-589">  // SERIAL_ECHOPGM("advance rate :");</front>
<front id="stepperCPP-590">  // SERIAL_ECHO(current_block-&gt;advance_rate/256.0);</front>
<front id="stepperCPP-591">  // SERIAL_ECHOPGM("initial advance :");</front>
<front id="stepperCPP-592">  // SERIAL_ECHO(current_block-&gt;initial_advance/256.0);</front>
<front id="stepperCPP-593">  // SERIAL_ECHOPGM("final advance :");</front>
<front id="stepperCPP-594">  // SERIAL_ECHOLN(current_block-&gt;final_advance/256.0);</front>
<front id="stepperCPP-595">}</front>
<front id="stepperCPP-596"></front>
<front id="stepperCPP-597">// "The Stepper Driver Interrupt" - This timer interrupt is the workhorse.</front>
<front id="stepperCPP-598">// It pops blocks from the block_buffer and executes them by pulsing the stepper pins appropriately.</front>
<front id="stepperCPP-599">ISR(TIMER1_COMPA_vect) {</front>
<front id="stepperCPP-600"></front>
<front id="stepperCPP-601">  if (cleaning_buffer_counter) {</front>
<front id="stepperCPP-602">    current_block = NULL;</front>
<front id="stepperCPP-603">    plan_discard_current_block();</front>
<front id="stepperCPP-604">    #ifdef SD_FINISHED_RELEASECOMMAND</front>
<front id="stepperCPP-605">      if ((cleaning_buffer_counter == 1) && (SD_FINISHED_STEPPERRELEASE)) enqueuecommands_P(PSTR(SD_FINISHED_RELEASECOMMAND));</front>
<front id="stepperCPP-606">    #endif</front>
<front id="stepperCPP-607">    cleaning_buffer_counter--;</front>
<front id="stepperCPP-608">    OCR1A = 200;</front>
<front id="stepperCPP-609">    return;</front>
<front id="stepperCPP-610">  }</front>
<front id="stepperCPP-611"></front>
<front id="stepperCPP-612">  // If there is no current block, attempt to pop one from the buffer</front>
<front id="stepperCPP-613">  if (!current_block) {</front>
<front id="stepperCPP-614">    // Anything in the buffer?</front>
<front id="stepperCPP-615">    current_block = plan_get_current_block();</front>
<front id="stepperCPP-616">    if (current_block) {</front>
<front id="stepperCPP-617">      current_block-&gt;busy = true;</front>
<front id="stepperCPP-618">      trapezoid_generator_reset();</front>
<front id="stepperCPP-619">      counter_x = -(current_block-&gt;step_event_count &gt;&gt; 1);</front>
<front id="stepperCPP-620">      counter_y = counter_z = counter_e = counter_x;</front>
<front id="stepperCPP-621">      step_events_completed = 0;</front>
<front id="stepperCPP-622"></front>
<front id="stepperCPP-623">      #if ENABLED(Z_LATE_ENABLE)</front>
<front id="stepperCPP-624">        if (current_block-&gt;steps[Z_AXIS] &gt; 0) {</front>
<front id="stepperCPP-625">          enable_z();</front>
<front id="stepperCPP-626">          OCR1A = 2000; //1ms wait</front>
<front id="stepperCPP-627">          return;</front>
<front id="stepperCPP-628">        }</front>
<front id="stepperCPP-629">      #endif</front>
<front id="stepperCPP-630"></front>
<front id="stepperCPP-631">      // #if ENABLED(ADVANCE)</front>
<front id="stepperCPP-632">      //   e_steps[current_block-&gt;active_extruder] = 0;</front>
<front id="stepperCPP-633">      // #endif</front>
<front id="stepperCPP-634">    }</front>
<front id="stepperCPP-635">    else {</front>
<front id="stepperCPP-636">      OCR1A = 2000; // 1kHz.</front>
<front id="stepperCPP-637">    }</front>
<front id="stepperCPP-638">  }</front>
<front id="stepperCPP-639"></front>
<front id="stepperCPP-640">  if (current_block != NULL) {</front>
<front id="stepperCPP-641"></front>
<front id="stepperCPP-642">    // Update endstops state, if enabled</front>
<front id="stepperCPP-643">    if (check_endstops) update_endstops();</front>
<front id="stepperCPP-644"></front>
<front id="stepperCPP-645">    // Take multiple steps per interrupt (For high speed moves)</front>
<front id="stepperCPP-646">    for (int8_t i = 0; i &lt; step_loops; i++) {</front>
<front id="stepperCPP-647">      #ifndef USBCON</front>
<front id="stepperCPP-648">        customizedSerial.checkRx(); // Check for serial chars.</front>
<front id="stepperCPP-649">      #endif</front>
<front id="stepperCPP-650"></front>
<front id="stepperCPP-651">      #if ENABLED(ADVANCE)</front>
<front id="stepperCPP-652">        counter_e += current_block-&gt;steps[E_AXIS];</front>
<front id="stepperCPP-653">        if (counter_e &gt; 0) {</front>
<front id="stepperCPP-654">          counter_e -= current_block-&gt;step_event_count;</front>
<front id="stepperCPP-655">          e_steps[current_block-&gt;active_extruder] += TEST(out_bits, E_AXIS) ? -1 : 1;</front>
<front id="stepperCPP-656">        }</front>
<front id="stepperCPP-657">      #endif //ADVANCE</front>
<front id="stepperCPP-658"></front>
<front id="stepperCPP-659">      #define _COUNTER(axis) counter_## axis</front>
<front id="stepperCPP-660">      #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP</front>
<front id="stepperCPP-661">      #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN</front>
<front id="stepperCPP-662"></front>
<front id="stepperCPP-663">      #define STEP_ADD(axis, AXIS) \</front>
<front id="stepperCPP-664">        _COUNTER(axis) += current_block-&gt;steps[_AXIS(AXIS)]; \</front>
<front id="stepperCPP-665">        if (_COUNTER(axis) &gt; 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); }</front>
<front id="stepperCPP-666"></front>
<front id="stepperCPP-667">      STEP_ADD(x,X);</front>
<front id="stepperCPP-668">      STEP_ADD(y,Y);</front>
<front id="stepperCPP-669">      STEP_ADD(z,Z);</front>
<front id="stepperCPP-670">      #if DISABLED(ADVANCE)</front>
<front id="stepperCPP-671">        STEP_ADD(e,E);</front>
<front id="stepperCPP-672">      #endif</front>
<front id="stepperCPP-673"></front>
<front id="stepperCPP-674">      #define STEP_IF_COUNTER(axis, AXIS) \</front>
<front id="stepperCPP-675">        if (_COUNTER(axis) &gt; 0) { \</front>
<front id="stepperCPP-676">          _COUNTER(axis) -= current_block-&gt;step_event_count; \</front>
<front id="stepperCPP-677">          count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \</front>
<front id="stepperCPP-678">          _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0); \</front>
<front id="stepperCPP-679">        }</front>
<front id="stepperCPP-680"></front>
<front id="stepperCPP-681">      STEP_IF_COUNTER(x, X);</front>
<front id="stepperCPP-682">      STEP_IF_COUNTER(y, Y);</front>
<front id="stepperCPP-683">      STEP_IF_COUNTER(z, Z);</front>
<front id="stepperCPP-684">      #if DISABLED(ADVANCE)</front>
<front id="stepperCPP-685">        STEP_IF_COUNTER(e, E);</front>
<front id="stepperCPP-686">      #endif</front>
<front id="stepperCPP-687"></front>
<front id="stepperCPP-688">      step_events_completed++;</front>
<front id="stepperCPP-689">      if (step_events_completed &gt;= current_block-&gt;step_event_count) break;</front>
<front id="stepperCPP-690">    }</front>
<front id="stepperCPP-691">    // Calculate new timer value</front>
<front id="stepperCPP-692">    unsigned short timer;</front>
<front id="stepperCPP-693">    unsigned short step_rate;</front>
<front id="stepperCPP-694">    if (step_events_completed &lt;= (unsigned long)current_block-&gt;accelerate_until) {</front>
<front id="stepperCPP-695"></front>
<front id="stepperCPP-696">      MultiU24X32toH16(acc_step_rate, acceleration_time, current_block-&gt;acceleration_rate);</front>
<front id="stepperCPP-697">      acc_step_rate += current_block-&gt;initial_rate;</front>
<front id="stepperCPP-698"></front>
<front id="stepperCPP-699">      // upper limit</front>
<front id="stepperCPP-700">      if (acc_step_rate &gt; current_block-&gt;nominal_rate)</front>
<front id="stepperCPP-701">        acc_step_rate = current_block-&gt;nominal_rate;</front>
<front id="stepperCPP-702"></front>
<front id="stepperCPP-703">      // step_rate to timer interval</front>
<front id="stepperCPP-704">      timer = calc_timer(acc_step_rate);</front>
<front id="stepperCPP-705">      OCR1A = timer;</front>
<front id="stepperCPP-706">      acceleration_time += timer;</front>
<front id="stepperCPP-707">      #if ENABLED(ADVANCE)</front>
<front id="stepperCPP-708">        for(int8_t i=0; i &lt; step_loops; i++) {</front>
<front id="stepperCPP-709">          advance += advance_rate;</front>
<front id="stepperCPP-710">        }</front>
<front id="stepperCPP-711">        //if (advance &gt; current_block-&gt;advance) advance = current_block-&gt;advance;</front>
<front id="stepperCPP-712">        // Do E steps + advance steps</front>
<front id="stepperCPP-713">        e_steps[current_block-&gt;active_extruder] += ((advance &gt;&gt;8) - old_advance);</front>
<front id="stepperCPP-714">        old_advance = advance &gt;&gt;8;</front>
<front id="stepperCPP-715"></front>
<front id="stepperCPP-716">      #endif</front>
<front id="stepperCPP-717">    }</front>
<front id="stepperCPP-718">    else if (step_events_completed &gt; (unsigned long)current_block-&gt;decelerate_after) {</front>
<front id="stepperCPP-719">      MultiU24X32toH16(step_rate, deceleration_time, current_block-&gt;acceleration_rate);</front>
<front id="stepperCPP-720"></front>
<front id="stepperCPP-721">      if (step_rate &gt; acc_step_rate) { // Check step_rate stays positive</front>
<front id="stepperCPP-722">        step_rate = current_block-&gt;final_rate;</front>
<front id="stepperCPP-723">      }</front>
<front id="stepperCPP-724">      else {</front>
<front id="stepperCPP-725">        step_rate = acc_step_rate - step_rate; // Decelerate from aceleration end point.</front>
<front id="stepperCPP-726">      }</front>
<front id="stepperCPP-727"></front>
<front id="stepperCPP-728">      // lower limit</front>
<front id="stepperCPP-729">      if (step_rate &lt; current_block-&gt;final_rate)</front>
<front id="stepperCPP-730">        step_rate = current_block-&gt;final_rate;</front>
<front id="stepperCPP-731"></front>
<front id="stepperCPP-732">      // step_rate to timer interval</front>
<front id="stepperCPP-733">      timer = calc_timer(step_rate);</front>
<front id="stepperCPP-734">      OCR1A = timer;</front>
<front id="stepperCPP-735">      deceleration_time += timer;</front>
<front id="stepperCPP-736">      #if ENABLED(ADVANCE)</front>
<front id="stepperCPP-737">        for(int8_t i=0; i &lt; step_loops; i++) {</front>
<front id="stepperCPP-738">          advance -= advance_rate;</front>
<front id="stepperCPP-739">        }</front>
<front id="stepperCPP-740">        if (advance &lt; final_advance) advance = final_advance;</front>
<front id="stepperCPP-741">        // Do E steps + advance steps</front>
<front id="stepperCPP-742">        e_steps[current_block-&gt;active_extruder] += ((advance &gt;&gt;8) - old_advance);</front>
<front id="stepperCPP-743">        old_advance = advance &gt;&gt;8;</front>
<front id="stepperCPP-744">      #endif //ADVANCE</front>
<front id="stepperCPP-745">    }</front>
<front id="stepperCPP-746">    else {</front>
<front id="stepperCPP-747">      OCR1A = OCR1A_nominal;</front>
<front id="stepperCPP-748">      // ensure we're running at the correct step rate, even if we just came off an acceleration</front>
<front id="stepperCPP-749">      step_loops = step_loops_nominal;</front>
<front id="stepperCPP-750">    }</front>
<front id="stepperCPP-751"></front>
<front id="stepperCPP-752">    OCR1A = (OCR1A &lt; (TCNT1 +16)) ? (TCNT1 + 16) : OCR1A;</front>
<front id="stepperCPP-753"></front>
<front id="stepperCPP-754">    // If current block is finished, reset pointer</front>
<front id="stepperCPP-755">    if (step_events_completed &gt;= current_block-&gt;step_event_count) {</front>
<front id="stepperCPP-756">      current_block = NULL;</front>
<front id="stepperCPP-757">      plan_discard_current_block();</front>
<front id="stepperCPP-758">    }</front>
<front id="stepperCPP-759">  }</front>
<front id="stepperCPP-760">}</front>
<front id="stepperCPP-761"></front>
<front id="stepperCPP-762">#if ENABLED(ADVANCE)</front>
<front id="stepperCPP-763">  unsigned char old_OCR0A;</front>
<front id="stepperCPP-764">  // Timer interrupt for E. e_steps is set in the main routine;</front>
<front id="stepperCPP-765">  // Timer 0 is shared with millies</front>
<front id="stepperCPP-766">  ISR(TIMER0_COMPA_vect)</front>
<front id="stepperCPP-767">  {</front>
<front id="stepperCPP-768">    old_OCR0A += 52; // ~10kHz interrupt (250000 / 26 = 9615kHz)</front>
<front id="stepperCPP-769">    OCR0A = old_OCR0A;</front>
<front id="stepperCPP-770">    // Set E direction (Depends on E direction + advance)</front>
<front id="stepperCPP-771">    for(unsigned char i=0; i&lt;4;i++) {</front>
<front id="stepperCPP-772">      if (e_steps[0] != 0) {</front>
<front id="stepperCPP-773">        E0_STEP_WRITE(INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-774">        if (e_steps[0] &lt; 0) {</front>
<front id="stepperCPP-775">          E0_DIR_WRITE(INVERT_E0_DIR);</front>
<front id="stepperCPP-776">          e_steps[0]++;</front>
<front id="stepperCPP-777">          E0_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-778">        }</front>
<front id="stepperCPP-779">        else if (e_steps[0] &gt; 0) {</front>
<front id="stepperCPP-780">          E0_DIR_WRITE(!INVERT_E0_DIR);</front>
<front id="stepperCPP-781">          e_steps[0]--;</front>
<front id="stepperCPP-782">          E0_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-783">        }</front>
<front id="stepperCPP-784">      }</front>
<front id="stepperCPP-785"> #if EXTRUDERS &gt; 1</front>
<front id="stepperCPP-786">      if (e_steps[1] != 0) {</front>
<front id="stepperCPP-787">        E1_STEP_WRITE(INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-788">        if (e_steps[1] &lt; 0) {</front>
<front id="stepperCPP-789">          E1_DIR_WRITE(INVERT_E1_DIR);</front>
<front id="stepperCPP-790">          e_steps[1]++;</front>
<front id="stepperCPP-791">          E1_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-792">        }</front>
<front id="stepperCPP-793">        else if (e_steps[1] &gt; 0) {</front>
<front id="stepperCPP-794">          E1_DIR_WRITE(!INVERT_E1_DIR);</front>
<front id="stepperCPP-795">          e_steps[1]--;</front>
<front id="stepperCPP-796">          E1_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-797">        }</front>
<front id="stepperCPP-798">      }</front>
<front id="stepperCPP-799"> #endif</front>
<front id="stepperCPP-800"> #if EXTRUDERS &gt; 2</front>
<front id="stepperCPP-801">      if (e_steps[2] != 0) {</front>
<front id="stepperCPP-802">        E2_STEP_WRITE(INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-803">        if (e_steps[2] &lt; 0) {</front>
<front id="stepperCPP-804">          E2_DIR_WRITE(INVERT_E2_DIR);</front>
<front id="stepperCPP-805">          e_steps[2]++;</front>
<front id="stepperCPP-806">          E2_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-807">        }</front>
<front id="stepperCPP-808">        else if (e_steps[2] &gt; 0) {</front>
<front id="stepperCPP-809">          E2_DIR_WRITE(!INVERT_E2_DIR);</front>
<front id="stepperCPP-810">          e_steps[2]--;</front>
<front id="stepperCPP-811">          E2_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-812">        }</front>
<front id="stepperCPP-813">      }</front>
<front id="stepperCPP-814"> #endif</front>
<front id="stepperCPP-815"> #if EXTRUDERS &gt; 3</front>
<front id="stepperCPP-816">      if (e_steps[3] != 0) {</front>
<front id="stepperCPP-817">        E3_STEP_WRITE(INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-818">        if (e_steps[3] &lt; 0) {</front>
<front id="stepperCPP-819">          E3_DIR_WRITE(INVERT_E3_DIR);</front>
<front id="stepperCPP-820">          e_steps[3]++;</front>
<front id="stepperCPP-821">          E3_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-822">        }</front>
<front id="stepperCPP-823">        else if (e_steps[3] &gt; 0) {</front>
<front id="stepperCPP-824">          E3_DIR_WRITE(!INVERT_E3_DIR);</front>
<front id="stepperCPP-825">          e_steps[3]--;</front>
<front id="stepperCPP-826">          E3_STEP_WRITE(!INVERT_E_STEP_PIN);</front>
<front id="stepperCPP-827">        }</front>
<front id="stepperCPP-828">      }</front>
<front id="stepperCPP-829"> #endif</front>
<front id="stepperCPP-830"></front>
<front id="stepperCPP-831">    }</front>
<front id="stepperCPP-832">  }</front>
<front id="stepperCPP-833">#endif // ADVANCE</front>
<front id="stepperCPP-834"></front>
<front id="stepperCPP-835">void st_init() {</front>
<front id="stepperCPP-836">  digipot_init(); //Initialize Digipot Motor Current</front>
<front id="stepperCPP-837">  microstep_init(); //Initialize Microstepping Pins</front>
<front id="stepperCPP-838"></front>
<front id="stepperCPP-839">  // initialise TMC Steppers</front>
<front id="stepperCPP-840">  #if ENABLED(HAVE_TMCDRIVER)</front>
<front id="stepperCPP-841">    tmc_init();</front>
<front id="stepperCPP-842">  #endif</front>
<front id="stepperCPP-843">    // initialise L6470 Steppers</front>
<front id="stepperCPP-844">  #if ENABLED(HAVE_L6470DRIVER)</front>
<front id="stepperCPP-845">    L6470_init();</front>
<front id="stepperCPP-846">  #endif</front>
<front id="stepperCPP-847"></front>
<front id="stepperCPP-848">  // Initialize Dir Pins</front>
<front id="stepperCPP-849">  #if HAS_X_DIR</front>
<front id="stepperCPP-850">    X_DIR_INIT;</front>
<front id="stepperCPP-851">  #endif</front>
<front id="stepperCPP-852">  #if HAS_X2_DIR</front>
<front id="stepperCPP-853">    X2_DIR_INIT;</front>
<front id="stepperCPP-854">  #endif</front>
<front id="stepperCPP-855">  #if HAS_Y_DIR</front>
<front id="stepperCPP-856">    Y_DIR_INIT;</front>
<front id="stepperCPP-857">    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR</front>
<front id="stepperCPP-858">      Y2_DIR_INIT;</front>
<front id="stepperCPP-859">    #endif</front>
<front id="stepperCPP-860">  #endif</front>
<front id="stepperCPP-861">  #if HAS_Z_DIR</front>
<front id="stepperCPP-862">    Z_DIR_INIT;</front>
<front id="stepperCPP-863">    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR</front>
<front id="stepperCPP-864">      Z2_DIR_INIT;</front>
<front id="stepperCPP-865">    #endif</front>
<front id="stepperCPP-866">  #endif</front>
<front id="stepperCPP-867">  #if HAS_E0_DIR</front>
<front id="stepperCPP-868">    E0_DIR_INIT;</front>
<front id="stepperCPP-869">  #endif</front>
<front id="stepperCPP-870">  #if HAS_E1_DIR</front>
<front id="stepperCPP-871">    E1_DIR_INIT;</front>
<front id="stepperCPP-872">  #endif</front>
<front id="stepperCPP-873">  #if HAS_E2_DIR</front>
<front id="stepperCPP-874">    E2_DIR_INIT;</front>
<front id="stepperCPP-875">  #endif</front>
<front id="stepperCPP-876">  #if HAS_E3_DIR</front>
<front id="stepperCPP-877">    E3_DIR_INIT;</front>
<front id="stepperCPP-878">  #endif</front>
<front id="stepperCPP-879"></front>
<front id="stepperCPP-880">  //Initialize Enable Pins - steppers default to disabled.</front>
<front id="stepperCPP-881"></front>
<front id="stepperCPP-882">  #if HAS_X_ENABLE</front>
<front id="stepperCPP-883">    X_ENABLE_INIT;</front>
<front id="stepperCPP-884">    if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-885">  #endif</front>
<front id="stepperCPP-886">  #if HAS_X2_ENABLE</front>
<front id="stepperCPP-887">    X2_ENABLE_INIT;</front>
<front id="stepperCPP-888">    if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-889">  #endif</front>
<front id="stepperCPP-890">  #if HAS_Y_ENABLE</front>
<front id="stepperCPP-891">    Y_ENABLE_INIT;</front>
<front id="stepperCPP-892">    if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-893"></front>
<front id="stepperCPP-894">  #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE</front>
<front id="stepperCPP-895">    Y2_ENABLE_INIT;</front>
<front id="stepperCPP-896">    if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-897">  #endif</front>
<front id="stepperCPP-898">  #endif</front>
<front id="stepperCPP-899">  #if HAS_Z_ENABLE</front>
<front id="stepperCPP-900">    Z_ENABLE_INIT;</front>
<front id="stepperCPP-901">    if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-902"></front>
<front id="stepperCPP-903">    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE</front>
<front id="stepperCPP-904">      Z2_ENABLE_INIT;</front>
<front id="stepperCPP-905">      if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-906">    #endif</front>
<front id="stepperCPP-907">  #endif</front>
<front id="stepperCPP-908">  #if HAS_E0_ENABLE</front>
<front id="stepperCPP-909">    E0_ENABLE_INIT;</front>
<front id="stepperCPP-910">    if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-911">  #endif</front>
<front id="stepperCPP-912">  #if HAS_E1_ENABLE</front>
<front id="stepperCPP-913">    E1_ENABLE_INIT;</front>
<front id="stepperCPP-914">    if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-915">  #endif</front>
<front id="stepperCPP-916">  #if HAS_E2_ENABLE</front>
<front id="stepperCPP-917">    E2_ENABLE_INIT;</front>
<front id="stepperCPP-918">    if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-919">  #endif</front>
<front id="stepperCPP-920">  #if HAS_E3_ENABLE</front>
<front id="stepperCPP-921">    E3_ENABLE_INIT;</front>
<front id="stepperCPP-922">    if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);</front>
<front id="stepperCPP-923">  #endif</front>
<front id="stepperCPP-924"></front>
<front id="stepperCPP-925">  //endstops and pullups</front>
<front id="stepperCPP-926"></front>
<front id="stepperCPP-927">  #if HAS_X_MIN</front>
<front id="stepperCPP-928">    SET_INPUT(X_MIN_PIN);</front>
<front id="stepperCPP-929">    #if ENABLED(ENDSTOPPULLUP_XMIN)</front>
<front id="stepperCPP-930">      WRITE(X_MIN_PIN,HIGH);</front>
<front id="stepperCPP-931">    #endif</front>
<front id="stepperCPP-932">  #endif</front>
<front id="stepperCPP-933"></front>
<front id="stepperCPP-934">  #if HAS_Y_MIN</front>
<front id="stepperCPP-935">    SET_INPUT(Y_MIN_PIN);</front>
<front id="stepperCPP-936">    #if ENABLED(ENDSTOPPULLUP_YMIN)</front>
<front id="stepperCPP-937">      WRITE(Y_MIN_PIN,HIGH);</front>
<front id="stepperCPP-938">    #endif</front>
<front id="stepperCPP-939">  #endif</front>
<front id="stepperCPP-940"></front>
<front id="stepperCPP-941">  #if HAS_Z_MIN</front>
<front id="stepperCPP-942">    SET_INPUT(Z_MIN_PIN);</front>
<front id="stepperCPP-943">    #if ENABLED(ENDSTOPPULLUP_ZMIN)</front>
<front id="stepperCPP-944">      WRITE(Z_MIN_PIN,HIGH);</front>
<front id="stepperCPP-945">    #endif</front>
<front id="stepperCPP-946">  #endif</front>
<front id="stepperCPP-947"></front>
<front id="stepperCPP-948">  #if HAS_X_MAX</front>
<front id="stepperCPP-949">    SET_INPUT(X_MAX_PIN);</front>
<front id="stepperCPP-950">    #if ENABLED(ENDSTOPPULLUP_XMAX)</front>
<front id="stepperCPP-951">      WRITE(X_MAX_PIN,HIGH);</front>
<front id="stepperCPP-952">    #endif</front>
<front id="stepperCPP-953">  #endif</front>
<front id="stepperCPP-954"></front>
<front id="stepperCPP-955">  #if HAS_Y_MAX</front>
<front id="stepperCPP-956">    SET_INPUT(Y_MAX_PIN);</front>
<front id="stepperCPP-957">    #if ENABLED(ENDSTOPPULLUP_YMAX)</front>
<front id="stepperCPP-958">      WRITE(Y_MAX_PIN,HIGH);</front>
<front id="stepperCPP-959">    #endif</front>
<front id="stepperCPP-960">  #endif</front>
<front id="stepperCPP-961"></front>
<front id="stepperCPP-962">  #if HAS_Z_MAX</front>
<front id="stepperCPP-963">    SET_INPUT(Z_MAX_PIN);</front>
<front id="stepperCPP-964">    #if ENABLED(ENDSTOPPULLUP_ZMAX)</front>
<front id="stepperCPP-965">      WRITE(Z_MAX_PIN,HIGH);</front>
<front id="stepperCPP-966">    #endif</front>
<front id="stepperCPP-967">  #endif</front>
<front id="stepperCPP-968"></front>
<front id="stepperCPP-969">  #if HAS_Z2_MAX</front>
<front id="stepperCPP-970">    SET_INPUT(Z2_MAX_PIN);</front>
<front id="stepperCPP-971">    #if ENABLED(ENDSTOPPULLUP_ZMAX)</front>
<front id="stepperCPP-972">      WRITE(Z2_MAX_PIN,HIGH);</front>
<front id="stepperCPP-973">    #endif</front>
<front id="stepperCPP-974">  #endif</front>
<front id="stepperCPP-975"></front>
<front id="stepperCPP-976">  #if HAS_Z_PROBE && ENABLED(Z_MIN_PROBE_ENDSTOP) // Check for Z_MIN_PROBE_ENDSTOP so we don't pull a pin high unless it's to be used.</front>
<front id="stepperCPP-977">    SET_INPUT(Z_MIN_PROBE_PIN);</front>
<front id="stepperCPP-978">    #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)</front>
<front id="stepperCPP-979">      WRITE(Z_MIN_PROBE_PIN,HIGH);</front>
<front id="stepperCPP-980">    #endif</front>
<front id="stepperCPP-981">  #endif</front>
<front id="stepperCPP-982"></front>
<front id="stepperCPP-983">  #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT</front>
<front id="stepperCPP-984">  #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)</front>
<front id="stepperCPP-985">  #define _DISABLE(axis) disable_## axis()</front>
<front id="stepperCPP-986"></front>
<front id="stepperCPP-987">  #define AXIS_INIT(axis, AXIS, PIN) \</front>
<front id="stepperCPP-988">    _STEP_INIT(AXIS); \</front>
<front id="stepperCPP-989">    _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \</front>
<front id="stepperCPP-990">    _DISABLE(axis)</front>
<front id="stepperCPP-991"></front>
<front id="stepperCPP-992">  #define E_AXIS_INIT(NUM) AXIS_INIT(e## NUM, E## NUM, E)</front>
<front id="stepperCPP-993"></front>
<front id="stepperCPP-994">  // Initialize Step Pins</front>
<front id="stepperCPP-995">  #if HAS_X_STEP</front>
<front id="stepperCPP-996">    AXIS_INIT(x, X, X);</front>
<front id="stepperCPP-997">  #endif</front>
<front id="stepperCPP-998">  #if HAS_X2_STEP</front>
<front id="stepperCPP-999">    AXIS_INIT(x, X2, X);</front>
<front id="stepperCPP-1000">  #endif</front>
<front id="stepperCPP-1001">  #if HAS_Y_STEP</front>
<front id="stepperCPP-1002">    #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_STEP</front>
<front id="stepperCPP-1003">      Y2_STEP_INIT;</front>
<front id="stepperCPP-1004">      Y2_STEP_WRITE(INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-1005">    #endif</front>
<front id="stepperCPP-1006">    AXIS_INIT(y, Y, Y);</front>
<front id="stepperCPP-1007">  #endif</front>
<front id="stepperCPP-1008">  #if HAS_Z_STEP</front>
<front id="stepperCPP-1009">    #if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_STEP</front>
<front id="stepperCPP-1010">      Z2_STEP_INIT;</front>
<front id="stepperCPP-1011">      Z2_STEP_WRITE(INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-1012">    #endif</front>
<front id="stepperCPP-1013">    AXIS_INIT(z, Z, Z);</front>
<front id="stepperCPP-1014">  #endif</front>
<front id="stepperCPP-1015">  #if HAS_E0_STEP</front>
<front id="stepperCPP-1016">    E_AXIS_INIT(0);</front>
<front id="stepperCPP-1017">  #endif</front>
<front id="stepperCPP-1018">  #if HAS_E1_STEP</front>
<front id="stepperCPP-1019">    E_AXIS_INIT(1);</front>
<front id="stepperCPP-1020">  #endif</front>
<front id="stepperCPP-1021">  #if HAS_E2_STEP</front>
<front id="stepperCPP-1022">    E_AXIS_INIT(2);</front>
<front id="stepperCPP-1023">  #endif</front>
<front id="stepperCPP-1024">  #if HAS_E3_STEP</front>
<front id="stepperCPP-1025">    E_AXIS_INIT(3);</front>
<front id="stepperCPP-1026">  #endif</front>
<front id="stepperCPP-1027"></front>
<front id="stepperCPP-1028">  // waveform generation = 0100 = CTC</front>
<front id="stepperCPP-1029">  TCCR1B &= ~BIT(WGM13);</front>
<front id="stepperCPP-1030">  TCCR1B |=  BIT(WGM12);</front>
<front id="stepperCPP-1031">  TCCR1A &= ~BIT(WGM11);</front>
<front id="stepperCPP-1032">  TCCR1A &= ~BIT(WGM10);</front>
<front id="stepperCPP-1033"></front>
<front id="stepperCPP-1034">  // output mode = 00 (disconnected)</front>
<front id="stepperCPP-1035">  TCCR1A &= ~(3&lt;&lt;COM1A0);</front>
<front id="stepperCPP-1036">  TCCR1A &= ~(3&lt;&lt;COM1B0);</front>
<front id="stepperCPP-1037"></front>
<front id="stepperCPP-1038">  // Set the timer pre-scaler</front>
<front id="stepperCPP-1039">  // Generally we use a divider of 8, resulting in a 2MHz timer</front>
<front id="stepperCPP-1040">  // frequency on a 16MHz MCU. If you are going to change this, be</front>
<front id="stepperCPP-1041">  // sure to regenerate speed_lookuptable.h with</front>
<front id="stepperCPP-1042">  // create_speed_lookuptable.py</front>
<front id="stepperCPP-1043">  TCCR1B = (TCCR1B & ~(0x07&lt;&lt;CS10)) | (2&lt;&lt;CS10);</front>
<front id="stepperCPP-1044"></front>
<front id="stepperCPP-1045">  OCR1A = 0x4000;</front>
<front id="stepperCPP-1046">  TCNT1 = 0;</front>
<front id="stepperCPP-1047">  ENABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-1048"></front>
<front id="stepperCPP-1049">  #if ENABLED(ADVANCE)</front>
<front id="stepperCPP-1050">    #if defined(TCCR0A) && defined(WGM01)</front>
<front id="stepperCPP-1051">      TCCR0A &= ~BIT(WGM01);</front>
<front id="stepperCPP-1052">      TCCR0A &= ~BIT(WGM00);</front>
<front id="stepperCPP-1053">    #endif</front>
<front id="stepperCPP-1054">    e_steps[0] = e_steps[1] = e_steps[2] = e_steps[3] = 0;</front>
<front id="stepperCPP-1055">    TIMSK0 |= BIT(OCIE0A);</front>
<front id="stepperCPP-1056">  #endif //ADVANCE</front>
<front id="stepperCPP-1057"></front>
<front id="stepperCPP-1058">  enable_endstops(true); // Start with endstops active. After homing they can be disabled</front>
<front id="stepperCPP-1059">  sei();</front>
<front id="stepperCPP-1060">  </front>
<front id="stepperCPP-1061">  set_stepper_direction(); // Init directions to out_bits = 0</front>
<front id="stepperCPP-1062">}</front>
<front id="stepperCPP-1063"></front>
<front id="stepperCPP-1064"></front>
<front id="stepperCPP-1065">/**</front>
<front id="stepperCPP-1066"> * Block until all buffered steps are executed</front>
<front id="stepperCPP-1067"> */</front>
<front id="stepperCPP-1068">void st_synchronize() { while (blocks_queued()) idle(); }</front>
<front id="stepperCPP-1069"></front>
<front id="stepperCPP-1070">void st_set_position(const long &x, const long &y, const long &z, const long &e) {</front>
<front id="stepperCPP-1071">  CRITICAL_SECTION_START;</front>
<front id="stepperCPP-1072">  count_position[X_AXIS] = x;</front>
<front id="stepperCPP-1073">  count_position[Y_AXIS] = y;</front>
<front id="stepperCPP-1074">  count_position[Z_AXIS] = z;</front>
<front id="stepperCPP-1075">  count_position[E_AXIS] = e;</front>
<front id="stepperCPP-1076">  CRITICAL_SECTION_END;</front>
<front id="stepperCPP-1077">}</front>
<front id="stepperCPP-1078"></front>
<front id="stepperCPP-1079">void st_set_e_position(const long &e) {</front>
<front id="stepperCPP-1080">  CRITICAL_SECTION_START;</front>
<front id="stepperCPP-1081">  count_position[E_AXIS] = e;</front>
<front id="stepperCPP-1082">  CRITICAL_SECTION_END;</front>
<front id="stepperCPP-1083">}</front>
<front id="stepperCPP-1084"></front>
<front id="stepperCPP-1085">long st_get_position(uint8_t axis) {</front>
<front id="stepperCPP-1086">  long count_pos;</front>
<front id="stepperCPP-1087">  CRITICAL_SECTION_START;</front>
<front id="stepperCPP-1088">  count_pos = count_position[axis];</front>
<front id="stepperCPP-1089">  CRITICAL_SECTION_END;</front>
<front id="stepperCPP-1090">  return count_pos;</front>
<front id="stepperCPP-1091">}</front>
<front id="stepperCPP-1092"></front>
<front id="stepperCPP-1093">float st_get_position_mm(AxisEnum axis) { return st_get_position(axis) / axis_steps_per_unit[axis]; }</front>
<front id="stepperCPP-1094"></front>
<front id="stepperCPP-1095">void finishAndDisableSteppers() {</front>
<front id="stepperCPP-1096">  st_synchronize();</front>
<front id="stepperCPP-1097">  disable_all_steppers();</front>
<front id="stepperCPP-1098">}</front>
<front id="stepperCPP-1099"></front>
<front id="stepperCPP-1100">void quickStop() {</front>
<front id="stepperCPP-1101">  cleaning_buffer_counter = 5000;</front>
<front id="stepperCPP-1102">  DISABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-1103">  while (blocks_queued()) plan_discard_current_block();</front>
<front id="stepperCPP-1104">  current_block = NULL;</front>
<front id="stepperCPP-1105">  ENABLE_STEPPER_DRIVER_INTERRUPT();</front>
<front id="stepperCPP-1106">}</front>
<front id="stepperCPP-1107"></front>
<front id="stepperCPP-1108">#if ENABLED(BABYSTEPPING)</front>
<front id="stepperCPP-1109"></front>
<front id="stepperCPP-1110">  // MUST ONLY BE CALLED BY AN ISR,</front>
<front id="stepperCPP-1111">  // No other ISR should ever interrupt this!</front>
<front id="stepperCPP-1112">  void babystep(const uint8_t axis, const bool direction) {</front>
<front id="stepperCPP-1113"></front>
<front id="stepperCPP-1114">    #define _ENABLE(axis) enable_## axis()</front>
<front id="stepperCPP-1115">    #define _READ_DIR(AXIS) AXIS ##_DIR_READ</front>
<front id="stepperCPP-1116">    #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR</front>
<front id="stepperCPP-1117">    #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)</front>
<front id="stepperCPP-1118"></front>
<front id="stepperCPP-1119">    #define BABYSTEP_AXIS(axis, AXIS, INVERT) { \</front>
<front id="stepperCPP-1120">        _ENABLE(axis); \</front>
<front id="stepperCPP-1121">        uint8_t old_pin = _READ_DIR(AXIS); \</front>
<front id="stepperCPP-1122">        _APPLY_DIR(AXIS, _INVERT_DIR(AXIS)^direction^INVERT); \</front>
<front id="stepperCPP-1123">        _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true); \</front>
<front id="stepperCPP-1124">        delayMicroseconds(2); \</front>
<front id="stepperCPP-1125">        _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true); \</front>
<front id="stepperCPP-1126">        _APPLY_DIR(AXIS, old_pin); \</front>
<front id="stepperCPP-1127">      }</front>
<front id="stepperCPP-1128"></front>
<front id="stepperCPP-1129">    switch(axis) {</front>
<front id="stepperCPP-1130"></front>
<front id="stepperCPP-1131">      case X_AXIS:</front>
<front id="stepperCPP-1132">        BABYSTEP_AXIS(x, X, false);</front>
<front id="stepperCPP-1133">        break;</front>
<front id="stepperCPP-1134"></front>
<front id="stepperCPP-1135">      case Y_AXIS:</front>
<front id="stepperCPP-1136">        BABYSTEP_AXIS(y, Y, false);</front>
<front id="stepperCPP-1137">        break;</front>
<front id="stepperCPP-1138"> </front>
<front id="stepperCPP-1139">      case Z_AXIS: {</front>
<front id="stepperCPP-1140"></front>
<front id="stepperCPP-1141">        #if DISABLED(DELTA)</front>
<front id="stepperCPP-1142"></front>
<front id="stepperCPP-1143">          BABYSTEP_AXIS(z, Z, BABYSTEP_INVERT_Z);</front>
<front id="stepperCPP-1144"></front>
<front id="stepperCPP-1145">        #else // DELTA</front>
<front id="stepperCPP-1146"></front>
<front id="stepperCPP-1147">          bool z_direction = direction ^ BABYSTEP_INVERT_Z;</front>
<front id="stepperCPP-1148"></front>
<front id="stepperCPP-1149">          enable_x();</front>
<front id="stepperCPP-1150">          enable_y();</front>
<front id="stepperCPP-1151">          enable_z();</front>
<front id="stepperCPP-1152">          uint8_t old_x_dir_pin = X_DIR_READ,</front>
<front id="stepperCPP-1153">                  old_y_dir_pin = Y_DIR_READ,</front>
<front id="stepperCPP-1154">                  old_z_dir_pin = Z_DIR_READ;</front>
<front id="stepperCPP-1155">          //setup new step</front>
<front id="stepperCPP-1156">          X_DIR_WRITE(INVERT_X_DIR^z_direction);</front>
<front id="stepperCPP-1157">          Y_DIR_WRITE(INVERT_Y_DIR^z_direction);</front>
<front id="stepperCPP-1158">          Z_DIR_WRITE(INVERT_Z_DIR^z_direction);</front>
<front id="stepperCPP-1159">          //perform step </front>
<front id="stepperCPP-1160">          X_STEP_WRITE(!INVERT_X_STEP_PIN);</front>
<front id="stepperCPP-1161">          Y_STEP_WRITE(!INVERT_Y_STEP_PIN);</front>
<front id="stepperCPP-1162">          Z_STEP_WRITE(!INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-1163">          delayMicroseconds(2);</front>
<front id="stepperCPP-1164">          X_STEP_WRITE(INVERT_X_STEP_PIN); </front>
<front id="stepperCPP-1165">          Y_STEP_WRITE(INVERT_Y_STEP_PIN); </front>
<front id="stepperCPP-1166">          Z_STEP_WRITE(INVERT_Z_STEP_PIN);</front>
<front id="stepperCPP-1167">          //get old pin state back.</front>
<front id="stepperCPP-1168">          X_DIR_WRITE(old_x_dir_pin);</front>
<front id="stepperCPP-1169">          Y_DIR_WRITE(old_y_dir_pin);</front>
<front id="stepperCPP-1170">          Z_DIR_WRITE(old_z_dir_pin);</front>
<front id="stepperCPP-1171"></front>
<front id="stepperCPP-1172">        #endif</front>
<front id="stepperCPP-1173"></front>
<front id="stepperCPP-1174">      } break;</front>
<front id="stepperCPP-1175"> </front>
<front id="stepperCPP-1176">      default: break;</front>
<front id="stepperCPP-1177">    }</front>
<front id="stepperCPP-1178">  }</front>
<front id="stepperCPP-1179"></front>
<front id="stepperCPP-1180">#endif //BABYSTEPPING</front>
<front id="stepperCPP-1181"></front>
<front id="stepperCPP-1182">// From Arduino DigitalPotControl example</front>
<front id="stepperCPP-1183">void digitalPotWrite(int address, int value) {</front>
<front id="stepperCPP-1184">  #if HAS_DIGIPOTSS</front>
<front id="stepperCPP-1185">    digitalWrite(DIGIPOTSS_PIN,LOW); // take the SS pin low to select the chip</front>
<front id="stepperCPP-1186">    SPI.transfer(address); //  send in the address and value via SPI:</front>
<front id="stepperCPP-1187">    SPI.transfer(value);</front>
<front id="stepperCPP-1188">    digitalWrite(DIGIPOTSS_PIN,HIGH); // take the SS pin high to de-select the chip:</front>
<front id="stepperCPP-1189">    //delay(10);</front>
<front id="stepperCPP-1190">  #else</front>
<front id="stepperCPP-1191">    UNUSED(address);</front>
<front id="stepperCPP-1192">    UNUSED(value);</front>
<front id="stepperCPP-1193">  #endif</front>
<front id="stepperCPP-1194">}</front>
<front id="stepperCPP-1195"></front>
<front id="stepperCPP-1196">// Initialize Digipot Motor Current</front>
<front id="stepperCPP-1197">void digipot_init() {</front>
<front id="stepperCPP-1198">  #if HAS_DIGIPOTSS</front>
<front id="stepperCPP-1199">    const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;</front>
<front id="stepperCPP-1200"></front>
<front id="stepperCPP-1201">    SPI.begin();</front>
<front id="stepperCPP-1202">    pinMode(DIGIPOTSS_PIN, OUTPUT);</front>
<front id="stepperCPP-1203">    for (int i = 0; i &lt;= 4; i++) {</front>
<front id="stepperCPP-1204">      //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);</front>
<front id="stepperCPP-1205">      digipot_current(i,digipot_motor_current[i]);</front>
<front id="stepperCPP-1206">    }</front>
<front id="stepperCPP-1207">  #endif</front>
<front id="stepperCPP-1208">  #ifdef MOTOR_CURRENT_PWM_XY_PIN</front>
<front id="stepperCPP-1209">    pinMode(MOTOR_CURRENT_PWM_XY_PIN, OUTPUT);</front>
<front id="stepperCPP-1210">    pinMode(MOTOR_CURRENT_PWM_Z_PIN, OUTPUT);</front>
<front id="stepperCPP-1211">    pinMode(MOTOR_CURRENT_PWM_E_PIN, OUTPUT);</front>
<front id="stepperCPP-1212">    digipot_current(0, motor_current_setting[0]);</front>
<front id="stepperCPP-1213">    digipot_current(1, motor_current_setting[1]);</front>
<front id="stepperCPP-1214">    digipot_current(2, motor_current_setting[2]);</front>
<front id="stepperCPP-1215">    //Set timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)</front>
<front id="stepperCPP-1216">    TCCR5B = (TCCR5B & ~(_BV(CS50) | _BV(CS51) | _BV(CS52))) | _BV(CS50);</front>
<front id="stepperCPP-1217">  #endif</front>
<front id="stepperCPP-1218">}</front>
<front id="stepperCPP-1219"></front>
<front id="stepperCPP-1220">void digipot_current(uint8_t driver, int current) {</front>
<front id="stepperCPP-1221">  #if HAS_DIGIPOTSS</front>
<front id="stepperCPP-1222">    const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;</front>
<front id="stepperCPP-1223">    digitalPotWrite(digipot_ch[driver], current);</front>
<front id="stepperCPP-1224">  #elif defined(MOTOR_CURRENT_PWM_XY_PIN)</front>
<front id="stepperCPP-1225">    switch(driver) {</front>
<front id="stepperCPP-1226">      case 0: analogWrite(MOTOR_CURRENT_PWM_XY_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;</front>
<front id="stepperCPP-1227">      case 1: analogWrite(MOTOR_CURRENT_PWM_Z_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;</front>
<front id="stepperCPP-1228">      case 2: analogWrite(MOTOR_CURRENT_PWM_E_PIN, 255L * current / MOTOR_CURRENT_PWM_RANGE); break;</front>
<front id="stepperCPP-1229">    }</front>
<front id="stepperCPP-1230">  #else</front>
<front id="stepperCPP-1231">    UNUSED(driver);</front>
<front id="stepperCPP-1232">    UNUSED(current);</front>
<front id="stepperCPP-1233">#endif</front>
<front id="stepperCPP-1234">}</front>
<front id="stepperCPP-1235"></front>
<front id="stepperCPP-1236">void microstep_init() {</front>
<front id="stepperCPP-1237">  #if HAS_MICROSTEPS_E1</front>
<front id="stepperCPP-1238">    pinMode(E1_MS1_PIN,OUTPUT);</front>
<front id="stepperCPP-1239">    pinMode(E1_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1240">  #endif</front>
<front id="stepperCPP-1241"></front>
<front id="stepperCPP-1242">  #if HAS_MICROSTEPS</front>
<front id="stepperCPP-1243">    pinMode(X_MS1_PIN,OUTPUT);</front>
<front id="stepperCPP-1244">    pinMode(X_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1245">    pinMode(Y_MS1_PIN,OUTPUT);</front>
<front id="stepperCPP-1246">    pinMode(Y_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1247">    pinMode(Z_MS1_PIN,OUTPUT);</front>
<front id="stepperCPP-1248">    pinMode(Z_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1249">    pinMode(E0_MS1_PIN,OUTPUT);</front>
<front id="stepperCPP-1250">    pinMode(E0_MS2_PIN,OUTPUT);</front>
<front id="stepperCPP-1251">    const uint8_t microstep_modes[] = MICROSTEP_MODES;</front>
<front id="stepperCPP-1252">    for (uint16_t i = 0; i &lt; COUNT(microstep_modes); i++)</front>
<front id="stepperCPP-1253">      microstep_mode(i, microstep_modes[i]);</front>
<front id="stepperCPP-1254">  #endif</front>
<front id="stepperCPP-1255">}</front>
<front id="stepperCPP-1256"></front>
<front id="stepperCPP-1257">void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2) {</front>
<front id="stepperCPP-1258">  if (ms1 &gt;= 0) switch(driver) {</front>
<front id="stepperCPP-1259">    case 0: digitalWrite(X_MS1_PIN, ms1); break;</front>
<front id="stepperCPP-1260">    case 1: digitalWrite(Y_MS1_PIN, ms1); break;</front>
<front id="stepperCPP-1261">    case 2: digitalWrite(Z_MS1_PIN, ms1); break;</front>
<front id="stepperCPP-1262">    case 3: digitalWrite(E0_MS1_PIN, ms1); break;</front>
<front id="stepperCPP-1263">    #if HAS_MICROSTEPS_E1</front>
<front id="stepperCPP-1264">      case 4: digitalWrite(E1_MS1_PIN, ms1); break;</front>
<front id="stepperCPP-1265">    #endif</front>
<front id="stepperCPP-1266">  }</front>
<front id="stepperCPP-1267">  if (ms2 &gt;= 0) switch(driver) {</front>
<front id="stepperCPP-1268">    case 0: digitalWrite(X_MS2_PIN, ms2); break;</front>
<front id="stepperCPP-1269">    case 1: digitalWrite(Y_MS2_PIN, ms2); break;</front>
<front id="stepperCPP-1270">    case 2: digitalWrite(Z_MS2_PIN, ms2); break;</front>
<front id="stepperCPP-1271">    case 3: digitalWrite(E0_MS2_PIN, ms2); break;</front>
<front id="stepperCPP-1272">    #if PIN_EXISTS(E1_MS2)</front>
<front id="stepperCPP-1273">      case 4: digitalWrite(E1_MS2_PIN, ms2); break;</front>
<front id="stepperCPP-1274">    #endif</front>
<front id="stepperCPP-1275">  }</front>
<front id="stepperCPP-1276">}</front>
<front id="stepperCPP-1277"></front>
<front id="stepperCPP-1278">void microstep_mode(uint8_t driver, uint8_t stepping_mode) {</front>
<front id="stepperCPP-1279">  switch(stepping_mode) {</front>
<front id="stepperCPP-1280">    case 1: microstep_ms(driver,MICROSTEP1); break;</front>
<front id="stepperCPP-1281">    case 2: microstep_ms(driver,MICROSTEP2); break;</front>
<front id="stepperCPP-1282">    case 4: microstep_ms(driver,MICROSTEP4); break;</front>
<front id="stepperCPP-1283">    case 8: microstep_ms(driver,MICROSTEP8); break;</front>
<front id="stepperCPP-1284">    case 16: microstep_ms(driver,MICROSTEP16); break;</front>
<front id="stepperCPP-1285">  }</front>
<front id="stepperCPP-1286">}</front>
<front id="stepperCPP-1287"></front>
<front id="stepperCPP-1288">void microstep_readings() {</front>
<front id="stepperCPP-1289">  SERIAL_PROTOCOLPGM("MS1,MS2 Pins\n");</front>
<front id="stepperCPP-1290">  SERIAL_PROTOCOLPGM("X: ");</front>
<front id="stepperCPP-1291">  SERIAL_PROTOCOL(digitalRead(X_MS1_PIN));</front>
<front id="stepperCPP-1292">  SERIAL_PROTOCOLLN(digitalRead(X_MS2_PIN));</front>
<front id="stepperCPP-1293">  SERIAL_PROTOCOLPGM("Y: ");</front>
<front id="stepperCPP-1294">  SERIAL_PROTOCOL(digitalRead(Y_MS1_PIN));</front>
<front id="stepperCPP-1295">  SERIAL_PROTOCOLLN(digitalRead(Y_MS2_PIN));</front>
<front id="stepperCPP-1296">  SERIAL_PROTOCOLPGM("Z: ");</front>
<front id="stepperCPP-1297">  SERIAL_PROTOCOL(digitalRead(Z_MS1_PIN));</front>
<front id="stepperCPP-1298">  SERIAL_PROTOCOLLN(digitalRead(Z_MS2_PIN));</front>
<front id="stepperCPP-1299">  SERIAL_PROTOCOLPGM("E0: ");</front>
<front id="stepperCPP-1300">  SERIAL_PROTOCOL(digitalRead(E0_MS1_PIN));</front>
<front id="stepperCPP-1301">  SERIAL_PROTOCOLLN(digitalRead(E0_MS2_PIN));</front>
<front id="stepperCPP-1302">  #if HAS_MICROSTEPS_E1</front>
<front id="stepperCPP-1303">    SERIAL_PROTOCOLPGM("E1: ");</front>
<front id="stepperCPP-1304">    SERIAL_PROTOCOL(digitalRead(E1_MS1_PIN));</front>
<front id="stepperCPP-1305">    SERIAL_PROTOCOLLN(digitalRead(E1_MS2_PIN));</front>
<front id="stepperCPP-1306">  #endif</front>
<front id="stepperCPP-1307">}</front>
<front id="stepperCPP-1308"></front>
<front id="stepperCPP-1309">#if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperCPP-1310">  void In_Homing_Process(bool state) { performing_homing = state; }</front>
<front id="stepperCPP-1311">  void Lock_z_motor(bool state) { locked_z_motor = state; }</front>
<front id="stepperCPP-1312">  void Lock_z2_motor(bool state) { locked_z2_motor = state; }</front>
<front id="stepperCPP-1313">#endif</front>
 </pre>
<h1 id="stepperHtitle" >stepper.h</h1>
<pre id="stepperH"  class="prettyprint linenums"><front id="stepperH-1">/*</front>
<front id="stepperH-2">  stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors</front>
<front id="stepperH-3">  Part of Grbl</front>
<front id="stepperH-4"></front>
<front id="stepperH-5">  Copyright (c) 2009-2011 Simen Svale Skogsrud</front>
<front id="stepperH-6"></front>
<front id="stepperH-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="stepperH-8">  it under the terms of the GNU General Public License as published by</front>
<front id="stepperH-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="stepperH-10">  (at your option) any later version.</front>
<front id="stepperH-11"></front>
<front id="stepperH-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="stepperH-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="stepperH-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="stepperH-15">  GNU General Public License for more details.</front>
<front id="stepperH-16"></front>
<front id="stepperH-17">  You should have received a copy of the GNU General Public License</front>
<front id="stepperH-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="stepperH-19">*/</front>
<front id="stepperH-20"></front>
<front id="stepperH-21">#ifndef stepper_h</front>
<front id="stepperH-22">#define stepper_h </front>
<front id="stepperH-23"></front>
<front id="stepperH-24">#include "planner.h"</front>
<front id="stepperH-25">#include "stepper_indirection.h"</front>
<front id="stepperH-26"></front>
<front id="stepperH-27">#if EXTRUDERS &gt; 3</front>
<front id="stepperH-28">  #define E_STEP_WRITE(v) { if(current_block-&gt;active_extruder == 3) { E3_STEP_WRITE(v); } else { if(current_block-&gt;active_extruder == 2) { E2_STEP_WRITE(v); } else { if(current_block-&gt;active_extruder == 1) { E1_STEP_WRITE(v); } else { E0_STEP_WRITE(v); }}}}</front>
<front id="stepperH-29">  #define NORM_E_DIR() { if(current_block-&gt;active_extruder == 3) { E3_DIR_WRITE( !INVERT_E3_DIR); } else { if(current_block-&gt;active_extruder == 2) { E2_DIR_WRITE(!INVERT_E2_DIR); } else { if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(!INVERT_E1_DIR); } else { E0_DIR_WRITE(!INVERT_E0_DIR); }}}}</front>
<front id="stepperH-30">  #define REV_E_DIR() { if(current_block-&gt;active_extruder == 3) { E3_DIR_WRITE(INVERT_E3_DIR); } else { if(current_block-&gt;active_extruder == 2) { E2_DIR_WRITE(INVERT_E2_DIR); } else { if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(INVERT_E1_DIR); } else { E0_DIR_WRITE(INVERT_E0_DIR); }}}}</front>
<front id="stepperH-31">#elif EXTRUDERS &gt; 2</front>
<front id="stepperH-32">  #define E_STEP_WRITE(v) { if(current_block-&gt;active_extruder == 2) { E2_STEP_WRITE(v); } else { if(current_block-&gt;active_extruder == 1) { E1_STEP_WRITE(v); } else { E0_STEP_WRITE(v); }}}</front>
<front id="stepperH-33">  #define NORM_E_DIR() { if(current_block-&gt;active_extruder == 2) { E2_DIR_WRITE(!INVERT_E2_DIR); } else { if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(!INVERT_E1_DIR); } else { E0_DIR_WRITE(!INVERT_E0_DIR); }}}</front>
<front id="stepperH-34">  #define REV_E_DIR() { if(current_block-&gt;active_extruder == 2) { E2_DIR_WRITE(INVERT_E2_DIR); } else { if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(INVERT_E1_DIR); } else { E0_DIR_WRITE(INVERT_E0_DIR); }}}</front>
<front id="stepperH-35">#elif EXTRUDERS &gt; 1</front>
<front id="stepperH-36">  #if DISABLED(DUAL_X_CARRIAGE)</front>
<front id="stepperH-37">    #define E_STEP_WRITE(v) { if(current_block-&gt;active_extruder == 1) { E1_STEP_WRITE(v); } else { E0_STEP_WRITE(v); }}</front>
<front id="stepperH-38">    #define NORM_E_DIR() { if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(!INVERT_E1_DIR); } else { E0_DIR_WRITE(!INVERT_E0_DIR); }}</front>
<front id="stepperH-39">    #define REV_E_DIR() { if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(INVERT_E1_DIR); } else { E0_DIR_WRITE(INVERT_E0_DIR); }}</front>
<front id="stepperH-40">  #else</front>
<front id="stepperH-41">    extern bool extruder_duplication_enabled;</front>
<front id="stepperH-42">    #define E_STEP_WRITE(v) { if(extruder_duplication_enabled) { E0_STEP_WRITE(v); E1_STEP_WRITE(v); } else if(current_block-&gt;active_extruder == 1) { E1_STEP_WRITE(v); } else { E0_STEP_WRITE(v); }}</front>
<front id="stepperH-43">    #define NORM_E_DIR() { if(extruder_duplication_enabled) { E0_DIR_WRITE(!INVERT_E0_DIR); E1_DIR_WRITE(!INVERT_E1_DIR); } else if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(!INVERT_E1_DIR); } else { E0_DIR_WRITE(!INVERT_E0_DIR); }}</front>
<front id="stepperH-44">    #define REV_E_DIR() { if(extruder_duplication_enabled) { E0_DIR_WRITE(INVERT_E0_DIR); E1_DIR_WRITE(INVERT_E1_DIR); } else if(current_block-&gt;active_extruder == 1) { E1_DIR_WRITE(INVERT_E1_DIR); } else { E0_DIR_WRITE(INVERT_E0_DIR); }}</front>
<front id="stepperH-45">  #endif  </front>
<front id="stepperH-46">#else</front>
<front id="stepperH-47">  #define E_STEP_WRITE(v) E0_STEP_WRITE(v)</front>
<front id="stepperH-48">  #define NORM_E_DIR() E0_DIR_WRITE(!INVERT_E0_DIR)</front>
<front id="stepperH-49">  #define REV_E_DIR() E0_DIR_WRITE(INVERT_E0_DIR)</front>
<front id="stepperH-50">#endif</front>
<front id="stepperH-51"></front>
<front id="stepperH-52">#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="stepperH-53">  extern bool abort_on_endstop_hit;</front>
<front id="stepperH-54">#endif</front>
<front id="stepperH-55"></front>
<front id="stepperH-56">// Initialize and start the stepper motor subsystem</front>
<front id="stepperH-57">void st_init();</front>
<front id="stepperH-58"></front>
<front id="stepperH-59">// Block until all buffered steps are executed</front>
<front id="stepperH-60">void st_synchronize();</front>
<front id="stepperH-61"></front>
<front id="stepperH-62">// Set current position in steps</front>
<front id="stepperH-63">void st_set_position(const long &x, const long &y, const long &z, const long &e);</front>
<front id="stepperH-64">void st_set_e_position(const long &e);</front>
<front id="stepperH-65"></front>
<front id="stepperH-66">// Get current position in steps</front>
<front id="stepperH-67">long st_get_position(uint8_t axis);</front>
<front id="stepperH-68"></front>
<front id="stepperH-69">// Get current position in mm</front>
<front id="stepperH-70">float st_get_position_mm(AxisEnum axis);</front>
<front id="stepperH-71"></front>
<front id="stepperH-72">// The stepper subsystem goes to sleep when it runs out of things to execute. Call this</front>
<front id="stepperH-73">// to notify the subsystem that it is time to go to work.</front>
<front id="stepperH-74">void st_wake_up();</front>
<front id="stepperH-75"></front>
<front id="stepperH-76">  </front>
<front id="stepperH-77">void checkHitEndstops(); //call from somewhere to create an serial error message with the locations the endstops where hit, in case they were triggered</front>
<front id="stepperH-78">void endstops_hit_on_purpose(); //avoid creation of the message, i.e. after homing and before a routine call of checkHitEndstops();</front>
<front id="stepperH-79"></front>
<front id="stepperH-80">void enable_endstops(bool check); // Enable/disable endstop checking</front>
<front id="stepperH-81"></front>
<front id="stepperH-82">void checkStepperErrors(); //Print errors detected by the stepper</front>
<front id="stepperH-83"></front>
<front id="stepperH-84">void finishAndDisableSteppers();</front>
<front id="stepperH-85"></front>
<front id="stepperH-86">extern block_t *current_block;  // A pointer to the block currently being traced</front>
<front id="stepperH-87"></front>
<front id="stepperH-88">void quickStop();</front>
<front id="stepperH-89"></front>
<front id="stepperH-90">void digitalPotWrite(int address, int value);</front>
<front id="stepperH-91">void microstep_ms(uint8_t driver, int8_t ms1, int8_t ms2);</front>
<front id="stepperH-92">void microstep_mode(uint8_t driver, uint8_t stepping);</front>
<front id="stepperH-93">void digipot_init();</front>
<front id="stepperH-94">void digipot_current(uint8_t driver, int current);</front>
<front id="stepperH-95">void microstep_init();</front>
<front id="stepperH-96">void microstep_readings();</front>
<front id="stepperH-97"></front>
<front id="stepperH-98">#if ENABLED(Z_DUAL_ENDSTOPS)</front>
<front id="stepperH-99">  void In_Homing_Process(bool state);</front>
<front id="stepperH-100">  void Lock_z_motor(bool state);</front>
<front id="stepperH-101">  void Lock_z2_motor(bool state);</front>
<front id="stepperH-102">#endif</front>
<front id="stepperH-103"></front>
<front id="stepperH-104">#if ENABLED(BABYSTEPPING)</front>
<front id="stepperH-105">  void babystep(const uint8_t axis,const bool direction); // perform a short step with a single stepper motor, outside of any convention</front>
<front id="stepperH-106">#endif</front>
<front id="stepperH-107">     </front>
<front id="stepperH-108">#endif</front>
 </pre>
<h1 id="stepper_indirectionCPPtitle" >stepper_indirection.cpp</h1>
<pre id="stepper_indirectionCPP"  class="prettyprint linenums"><front id="stepper_indirectionCPP-1">/*</front>
<front id="stepper_indirectionCPP-2">  stepper_indirection.c - stepper motor driver indirection </front>
<front id="stepper_indirectionCPP-3">  to allow some stepper functions to be done via SPI/I2c instead of direct pin manipulation</front>
<front id="stepper_indirectionCPP-4">  Part of Marlin</front>
<front id="stepper_indirectionCPP-5"></front>
<front id="stepper_indirectionCPP-6">  Copyright (c) 2015 Dominik Wenger</front>
<front id="stepper_indirectionCPP-7"></front>
<front id="stepper_indirectionCPP-8">  Marlin is free software: you can redistribute it and/or modify</front>
<front id="stepper_indirectionCPP-9">  it under the terms of the GNU General Public License as published by</front>
<front id="stepper_indirectionCPP-10">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="stepper_indirectionCPP-11">  (at your option) any later version.</front>
<front id="stepper_indirectionCPP-12"></front>
<front id="stepper_indirectionCPP-13">  Marlin is distributed in the hope that it will be useful,</front>
<front id="stepper_indirectionCPP-14">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="stepper_indirectionCPP-15">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="stepper_indirectionCPP-16">  GNU General Public License for more details.</front>
<front id="stepper_indirectionCPP-17"></front>
<front id="stepper_indirectionCPP-18">  You should have received a copy of the GNU General Public License</front>
<front id="stepper_indirectionCPP-19">  along with Marlin.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="stepper_indirectionCPP-20">*/</front>
<front id="stepper_indirectionCPP-21"></front>
<front id="stepper_indirectionCPP-22">#include "stepper_indirection.h"</front>
<front id="stepper_indirectionCPP-23">#include "Configuration.h"</front>
<front id="stepper_indirectionCPP-24"></front>
<front id="stepper_indirectionCPP-25">#if ENABLED(HAVE_TMCDRIVER)</front>
<front id="stepper_indirectionCPP-26">  #include &lt;SPI.h&gt;</front>
<front id="stepper_indirectionCPP-27">  #include &lt;TMC26XStepper.h&gt;</front>
<front id="stepper_indirectionCPP-28">#endif</front>
<front id="stepper_indirectionCPP-29"></front>
<front id="stepper_indirectionCPP-30">// Stepper objects of TMC steppers used</front>
<front id="stepper_indirectionCPP-31">#if ENABLED(X_IS_TMC)</front>
<front id="stepper_indirectionCPP-32">	TMC26XStepper stepperX(200,X_ENABLE_PIN,X_STEP_PIN,X_DIR_PIN,X_MAX_CURRENT,X_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-33">#endif</front>
<front id="stepper_indirectionCPP-34">#if ENABLED(X2_IS_TMC)</front>
<front id="stepper_indirectionCPP-35">	TMC26XStepper stepperX2(200,X2_ENABLE_PIN,X2_STEP_PIN,X2_DIR_PIN,X2_MAX_CURRENT,X2_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-36">#endif</front>
<front id="stepper_indirectionCPP-37">#if ENABLED(Y_IS_TMC)</front>
<front id="stepper_indirectionCPP-38">	TMC26XStepper stepperY(200,Y_ENABLE_PIN,Y_STEP_PIN,Y_DIR_PIN,Y_MAX_CURRENT,Y_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-39">#endif</front>
<front id="stepper_indirectionCPP-40">#if ENABLED(Y2_IS_TMC)</front>
<front id="stepper_indirectionCPP-41">	TMC26XStepper stepperY2(200,Y2_ENABLE_PIN,Y2_STEP_PIN,Y2_DIR_PIN,Y2_MAX_CURRENT,Y2_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-42">#endif</front>
<front id="stepper_indirectionCPP-43">#if ENABLED(Z_IS_TMC)</front>
<front id="stepper_indirectionCPP-44">	TMC26XStepper stepperZ(200,Z_ENABLE_PIN,Z_STEP_PIN,Z_DIR_PIN,Z_MAX_CURRENT,Z_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-45">#endif</front>
<front id="stepper_indirectionCPP-46">#if ENABLED(Z2_IS_TMC)</front>
<front id="stepper_indirectionCPP-47">	TMC26XStepper stepperZ2(200,Z2_ENABLE_PIN,Z2_STEP_PIN,Z2_DIR_PIN,Z2_MAX_CURRENT,Z2_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-48">#endif</front>
<front id="stepper_indirectionCPP-49">#if ENABLED(E0_IS_TMC)</front>
<front id="stepper_indirectionCPP-50">	TMC26XStepper stepperE0(200,E0_ENABLE_PIN,E0_STEP_PIN,E0_DIR_PIN,E0_MAX_CURRENT,E0_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-51">#endif</front>
<front id="stepper_indirectionCPP-52">#if ENABLED(E1_IS_TMC)</front>
<front id="stepper_indirectionCPP-53">	TMC26XStepper stepperE1(200,E1_ENABLE_PIN,E1_STEP_PIN,E1_DIR_PIN,E1_MAX_CURRENT,E1_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-54">#endif</front>
<front id="stepper_indirectionCPP-55">#if ENABLED(E2_IS_TMC)</front>
<front id="stepper_indirectionCPP-56">	TMC26XStepper stepperE2(200,E2_ENABLE_PIN,E2_STEP_PIN,E2_DIR_PIN,E2_MAX_CURRENT,E2_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-57">#endif</front>
<front id="stepper_indirectionCPP-58">#if ENABLED(E3_IS_TMC)</front>
<front id="stepper_indirectionCPP-59">	TMC26XStepper stepperE3(200,E3_ENABLE_PIN,E3_STEP_PIN,E3_DIR_PIN,E3_MAX_CURRENT,E3_SENSE_RESISTOR);</front>
<front id="stepper_indirectionCPP-60">#endif	</front>
<front id="stepper_indirectionCPP-61"></front>
<front id="stepper_indirectionCPP-62">#if ENABLED(HAVE_TMCDRIVER)</front>
<front id="stepper_indirectionCPP-63">void tmc_init()</front>
<front id="stepper_indirectionCPP-64">{</front>
<front id="stepper_indirectionCPP-65">  #if ENABLED(X_IS_TMC)</front>
<front id="stepper_indirectionCPP-66">	stepperX.setMicrosteps(X_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-67">	stepperX.start();</front>
<front id="stepper_indirectionCPP-68">  #endif</front>
<front id="stepper_indirectionCPP-69">  #if ENABLED(X2_IS_TMC)</front>
<front id="stepper_indirectionCPP-70">	stepperX2.setMicrosteps(X2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-71">	stepperX2.start();</front>
<front id="stepper_indirectionCPP-72">  #endif</front>
<front id="stepper_indirectionCPP-73">  #if ENABLED(Y_IS_TMC)</front>
<front id="stepper_indirectionCPP-74">	stepperY.setMicrosteps(Y_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-75">	stepperY.start();</front>
<front id="stepper_indirectionCPP-76">  #endif</front>
<front id="stepper_indirectionCPP-77">  #if ENABLED(Y2_IS_TMC)</front>
<front id="stepper_indirectionCPP-78">	stepperY2.setMicrosteps(Y2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-79">	stepperY2.start();</front>
<front id="stepper_indirectionCPP-80">  #endif</front>
<front id="stepper_indirectionCPP-81">  #if ENABLED(Z_IS_TMC)</front>
<front id="stepper_indirectionCPP-82">	stepperZ.setMicrosteps(Z_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-83">	stepperZ.start();</front>
<front id="stepper_indirectionCPP-84">  #endif</front>
<front id="stepper_indirectionCPP-85">  #if ENABLED(Z2_IS_TMC)</front>
<front id="stepper_indirectionCPP-86">	stepperZ2.setMicrosteps(Z2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-87">	stepperZ2.start();</front>
<front id="stepper_indirectionCPP-88">  #endif</front>
<front id="stepper_indirectionCPP-89">  #if ENABLED(E0_IS_TMC)</front>
<front id="stepper_indirectionCPP-90">	stepperE0.setMicrosteps(E0_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-91">	stepperE0.start();</front>
<front id="stepper_indirectionCPP-92">  #endif</front>
<front id="stepper_indirectionCPP-93">  #if ENABLED(E1_IS_TMC)</front>
<front id="stepper_indirectionCPP-94">	stepperE1.setMicrosteps(E1_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-95">	stepperE1.start();</front>
<front id="stepper_indirectionCPP-96">  #endif</front>
<front id="stepper_indirectionCPP-97">  #if ENABLED(E2_IS_TMC)</front>
<front id="stepper_indirectionCPP-98">	stepperE2.setMicrosteps(E2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-99">	stepperE2.start();</front>
<front id="stepper_indirectionCPP-100">  #endif</front>
<front id="stepper_indirectionCPP-101">  #if ENABLED(E3_IS_TMC)</front>
<front id="stepper_indirectionCPP-102">	stepperE3.setMicrosteps(E3_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-103">	stepperE3.start();</front>
<front id="stepper_indirectionCPP-104">  #endif</front>
<front id="stepper_indirectionCPP-105">}</front>
<front id="stepper_indirectionCPP-106">#endif</front>
<front id="stepper_indirectionCPP-107"></front>
<front id="stepper_indirectionCPP-108">// L6470 Driver objects and inits</front>
<front id="stepper_indirectionCPP-109"></front>
<front id="stepper_indirectionCPP-110">#if ENABLED(HAVE_L6470DRIVER)</front>
<front id="stepper_indirectionCPP-111">#include &lt;SPI.h&gt;</front>
<front id="stepper_indirectionCPP-112">#include &lt;L6470.h&gt;</front>
<front id="stepper_indirectionCPP-113">#endif</front>
<front id="stepper_indirectionCPP-114"></front>
<front id="stepper_indirectionCPP-115">// L6470 Stepper objects</front>
<front id="stepper_indirectionCPP-116">  #if ENABLED(X_IS_L6470)</front>
<front id="stepper_indirectionCPP-117">	L6470 stepperX(X_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-118">  #endif</front>
<front id="stepper_indirectionCPP-119">  #if ENABLED(X2_IS_L6470)</front>
<front id="stepper_indirectionCPP-120">	L6470 stepperX2(X2_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-121">  #endif</front>
<front id="stepper_indirectionCPP-122">  #if ENABLED(Y_IS_L6470)</front>
<front id="stepper_indirectionCPP-123">	L6470 stepperY(Y_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-124">  #endif</front>
<front id="stepper_indirectionCPP-125">  #if ENABLED(Y2_IS_L6470)</front>
<front id="stepper_indirectionCPP-126">	L6470 stepperY2(Y2_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-127">  #endif</front>
<front id="stepper_indirectionCPP-128">  #if ENABLED(Z_IS_L6470)</front>
<front id="stepper_indirectionCPP-129">	L6470 stepperZ(Z_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-130">  #endif</front>
<front id="stepper_indirectionCPP-131">  #if ENABLED(Z2_IS_L6470)</front>
<front id="stepper_indirectionCPP-132">	L6470 stepperZ2(Z2_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-133">  #endif</front>
<front id="stepper_indirectionCPP-134">  #if ENABLED(E0_IS_L6470)</front>
<front id="stepper_indirectionCPP-135">	L6470 stepperE0(E0_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-136">  #endif</front>
<front id="stepper_indirectionCPP-137">  #if ENABLED(E1_IS_L6470)</front>
<front id="stepper_indirectionCPP-138">	L6470 stepperE1(E1_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-139">  #endif</front>
<front id="stepper_indirectionCPP-140">  #if ENABLED(E2_IS_L6470)</front>
<front id="stepper_indirectionCPP-141">	L6470 stepperE2(E2_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-142">  #endif</front>
<front id="stepper_indirectionCPP-143">  #if ENABLED(E3_IS_L6470)</front>
<front id="stepper_indirectionCPP-144">	L6470 stepperE3(E3_ENABLE_PIN);</front>
<front id="stepper_indirectionCPP-145">  #endif	</front>
<front id="stepper_indirectionCPP-146"></front>
<front id="stepper_indirectionCPP-147"></front>
<front id="stepper_indirectionCPP-148">// init routine</front>
<front id="stepper_indirectionCPP-149">#if ENABLED(HAVE_L6470DRIVER)</front>
<front id="stepper_indirectionCPP-150">void L6470_init()</front>
<front id="stepper_indirectionCPP-151">{</front>
<front id="stepper_indirectionCPP-152">  #if ENABLED(X_IS_L6470)</front>
<front id="stepper_indirectionCPP-153">	stepperX.init(X_K_VAL);</front>
<front id="stepper_indirectionCPP-154">	stepperX.softFree();</front>
<front id="stepper_indirectionCPP-155">	stepperX.setMicroSteps(X_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-156">    stepperX.setOverCurrent(X_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-157">    stepperX.setStallCurrent(X_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-158">  #endif</front>
<front id="stepper_indirectionCPP-159">  #if ENABLED(X2_IS_L6470)</front>
<front id="stepper_indirectionCPP-160">	stepperX2.init(X2_K_VAL);</front>
<front id="stepper_indirectionCPP-161">	stepperX2.softFree();</front>
<front id="stepper_indirectionCPP-162">	stepperX2.setMicroSteps(X2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-163">    stepperX2.setOverCurrent(X2_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-164">    stepperX2.setStallCurrent(X2_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-165">  #endif</front>
<front id="stepper_indirectionCPP-166">  #if ENABLED(Y_IS_L6470)</front>
<front id="stepper_indirectionCPP-167">	stepperY.init(Y_K_VAL);</front>
<front id="stepper_indirectionCPP-168">	stepperY.softFree();</front>
<front id="stepper_indirectionCPP-169">	stepperY.setMicroSteps(Y_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-170">    stepperY.setOverCurrent(Y_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-171">    stepperY.setStallCurrent(Y_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-172">  #endif</front>
<front id="stepper_indirectionCPP-173">  #if ENABLED(Y2_IS_L6470)</front>
<front id="stepper_indirectionCPP-174">	stepperY2.init(Y2_K_VAL);</front>
<front id="stepper_indirectionCPP-175">	stepperY2.softFree();</front>
<front id="stepper_indirectionCPP-176">	stepperY2.setMicroSteps(Y2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-177">    stepperY2.setOverCurrent(Y2_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-178">    stepperY2.setStallCurrent(Y2_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-179">  #endif</front>
<front id="stepper_indirectionCPP-180">  #if ENABLED(Z_IS_L6470)</front>
<front id="stepper_indirectionCPP-181">	stepperZ.init(Z_K_VAL);</front>
<front id="stepper_indirectionCPP-182">	stepperZ.softFree();</front>
<front id="stepper_indirectionCPP-183">	stepperZ.setMicroSteps(Z_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-184">    stepperZ.setOverCurrent(Z_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-185">    stepperZ.setStallCurrent(Z_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-186">  #endif</front>
<front id="stepper_indirectionCPP-187">  #if ENABLED(Z2_IS_L6470)</front>
<front id="stepper_indirectionCPP-188">	stepperZ2.init(Z2_K_VAL);</front>
<front id="stepper_indirectionCPP-189">	stepperZ2.softFree();</front>
<front id="stepper_indirectionCPP-190">	stepperZ2.setMicroSteps(Z2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-191">    stepperZ2.setOverCurrent(Z2_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-192">    stepperZ2.setStallCurrent(Z2_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-193">  #endif</front>
<front id="stepper_indirectionCPP-194">  #if ENABLED(E0_IS_L6470)</front>
<front id="stepper_indirectionCPP-195">	stepperE0.init(E0_K_VAL);</front>
<front id="stepper_indirectionCPP-196">	stepperE0.softFree();</front>
<front id="stepper_indirectionCPP-197">	stepperE0.setMicroSteps(E0_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-198">    stepperE0.setOverCurrent(E0_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-199">    stepperE0.setStallCurrent(E0_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-200">  #endif</front>
<front id="stepper_indirectionCPP-201">  #if ENABLED(E1_IS_L6470)</front>
<front id="stepper_indirectionCPP-202">	stepperE1.init(E1_K_VAL);</front>
<front id="stepper_indirectionCPP-203">	stepperE1.softFree();</front>
<front id="stepper_indirectionCPP-204">	stepperE1.setMicroSteps(E1_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-205">    stepperE1.setOverCurrent(E1_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-206">    stepperE1.setStallCurrent(E1_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-207">  #endif</front>
<front id="stepper_indirectionCPP-208">  #if ENABLED(E2_IS_L6470)</front>
<front id="stepper_indirectionCPP-209">	stepperE2.init(E2_K_VAL);</front>
<front id="stepper_indirectionCPP-210">	stepperE2.softFree();</front>
<front id="stepper_indirectionCPP-211">	stepperE2.setMicroSteps(E2_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-212">    stepperE2.setOverCurrent(E2_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-213">    stepperE2.setStallCurrent(E2_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-214">  #endif</front>
<front id="stepper_indirectionCPP-215">  #if ENABLED(E3_IS_L6470)</front>
<front id="stepper_indirectionCPP-216">	stepperE3.init(E3_K_VAL);</front>
<front id="stepper_indirectionCPP-217">	stepperE3.softFree();</front>
<front id="stepper_indirectionCPP-218">	stepperE3.setMicroSteps(E3_MICROSTEPS);</front>
<front id="stepper_indirectionCPP-219">    stepperE3.setOverCurrent(E3_OVERCURRENT); //set overcurrent protection</front>
<front id="stepper_indirectionCPP-220">    stepperE3.setStallCurrent(E3_STALLCURRENT);</front>
<front id="stepper_indirectionCPP-221">  #endif	</front>
<front id="stepper_indirectionCPP-222">}</front>
<front id="stepper_indirectionCPP-223">#endif</front>
<front id="stepper_indirectionCPP-224"></front>
 </pre>
<h1 id="stepper_indirectionHtitle" >stepper_indirection.h</h1>
<pre id="stepper_indirectionH"  class="prettyprint linenums"><front id="stepper_indirectionH-1">/*</front>
<front id="stepper_indirectionH-2">  stepper_indirection.h - stepper motor driver indirection macros</front>
<front id="stepper_indirectionH-3">  to allow some stepper functions to be done via SPI/I2c instead of direct pin manipulation</front>
<front id="stepper_indirectionH-4">  Part of Marlin</front>
<front id="stepper_indirectionH-5"></front>
<front id="stepper_indirectionH-6">  Copyright (c) 2015 Dominik Wenger</front>
<front id="stepper_indirectionH-7"></front>
<front id="stepper_indirectionH-8">  Marlin is free software: you can redistribute it and/or modify</front>
<front id="stepper_indirectionH-9">  it under the terms of the GNU General Public License as published by</front>
<front id="stepper_indirectionH-10">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="stepper_indirectionH-11">  (at your option) any later version.</front>
<front id="stepper_indirectionH-12"></front>
<front id="stepper_indirectionH-13">  Marlin is distributed in the hope that it will be useful,</front>
<front id="stepper_indirectionH-14">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="stepper_indirectionH-15">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="stepper_indirectionH-16">  GNU General Public License for more details.</front>
<front id="stepper_indirectionH-17"></front>
<front id="stepper_indirectionH-18">  You should have received a copy of the GNU General Public License</front>
<front id="stepper_indirectionH-19">  along with Marlin.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="stepper_indirectionH-20">*/</front>
<front id="stepper_indirectionH-21"></front>
<front id="stepper_indirectionH-22">#ifndef STEPPER_INDIRECTION_H</front>
<front id="stepper_indirectionH-23">#define STEPPER_INDIRECTION_H</front>
<front id="stepper_indirectionH-24"></front>
<front id="stepper_indirectionH-25">#include "macros.h"</front>
<front id="stepper_indirectionH-26"></front>
<front id="stepper_indirectionH-27">// X motor</front>
<front id="stepper_indirectionH-28">#define X_STEP_INIT SET_OUTPUT(X_STEP_PIN)</front>
<front id="stepper_indirectionH-29">#define X_STEP_WRITE(STATE) WRITE(X_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-30">#define X_STEP_READ READ(X_STEP_PIN)</front>
<front id="stepper_indirectionH-31"></front>
<front id="stepper_indirectionH-32">#define X_DIR_INIT SET_OUTPUT(X_DIR_PIN)</front>
<front id="stepper_indirectionH-33">#define X_DIR_WRITE(STATE) WRITE(X_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-34">#define X_DIR_READ READ(X_DIR_PIN)</front>
<front id="stepper_indirectionH-35"></front>
<front id="stepper_indirectionH-36">#define X_ENABLE_INIT SET_OUTPUT(X_ENABLE_PIN)</front>
<front id="stepper_indirectionH-37">#define X_ENABLE_WRITE(STATE) WRITE(X_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-38">#define X_ENABLE_READ READ(X_ENABLE_PIN)</front>
<front id="stepper_indirectionH-39"></front>
<front id="stepper_indirectionH-40">// X2 motor</front>
<front id="stepper_indirectionH-41">#define X2_STEP_INIT SET_OUTPUT(X2_STEP_PIN)</front>
<front id="stepper_indirectionH-42">#define X2_STEP_WRITE(STATE) WRITE(X2_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-43">#define X2_STEP_READ READ(X2_STEP_PIN)</front>
<front id="stepper_indirectionH-44"></front>
<front id="stepper_indirectionH-45">#define X2_DIR_INIT SET_OUTPUT(X2_DIR_PIN)</front>
<front id="stepper_indirectionH-46">#define X2_DIR_WRITE(STATE) WRITE(X2_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-47">#define X2_DIR_READ READ(X_DIR_PIN)</front>
<front id="stepper_indirectionH-48"></front>
<front id="stepper_indirectionH-49">#define X2_ENABLE_INIT SET_OUTPUT(X2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-50">#define X2_ENABLE_WRITE(STATE) WRITE(X2_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-51">#define X2_ENABLE_READ READ(X_ENABLE_PIN)</front>
<front id="stepper_indirectionH-52"></front>
<front id="stepper_indirectionH-53">// Y motor</front>
<front id="stepper_indirectionH-54">#define Y_STEP_INIT SET_OUTPUT(Y_STEP_PIN)</front>
<front id="stepper_indirectionH-55">#define Y_STEP_WRITE(STATE) WRITE(Y_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-56">#define Y_STEP_READ READ(Y_STEP_PIN)</front>
<front id="stepper_indirectionH-57"></front>
<front id="stepper_indirectionH-58">#define Y_DIR_INIT SET_OUTPUT(Y_DIR_PIN)</front>
<front id="stepper_indirectionH-59">#define Y_DIR_WRITE(STATE) WRITE(Y_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-60">#define Y_DIR_READ READ(Y_DIR_PIN)</front>
<front id="stepper_indirectionH-61"></front>
<front id="stepper_indirectionH-62">#define Y_ENABLE_INIT SET_OUTPUT(Y_ENABLE_PIN)</front>
<front id="stepper_indirectionH-63">#define Y_ENABLE_WRITE(STATE) WRITE(Y_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-64">#define Y_ENABLE_READ READ(Y_ENABLE_PIN)</front>
<front id="stepper_indirectionH-65"></front>
<front id="stepper_indirectionH-66">// Y2 motor</front>
<front id="stepper_indirectionH-67">#define Y2_STEP_INIT SET_OUTPUT(Y2_STEP_PIN)</front>
<front id="stepper_indirectionH-68">#define Y2_STEP_WRITE(STATE) WRITE(Y2_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-69">#define Y2_STEP_READ READ(Y2_STEP_PIN)</front>
<front id="stepper_indirectionH-70"></front>
<front id="stepper_indirectionH-71">#define Y2_DIR_INIT SET_OUTPUT(Y2_DIR_PIN)</front>
<front id="stepper_indirectionH-72">#define Y2_DIR_WRITE(STATE) WRITE(Y2_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-73">#define Y2_DIR_READ READ(Y2_DIR_PIN)</front>
<front id="stepper_indirectionH-74"></front>
<front id="stepper_indirectionH-75">#define Y2_ENABLE_INIT SET_OUTPUT(Y2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-76">#define Y2_ENABLE_WRITE(STATE) WRITE(Y2_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-77">#define Y2_ENABLE_READ READ(Y2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-78"></front>
<front id="stepper_indirectionH-79">// Z motor</front>
<front id="stepper_indirectionH-80">#define Z_STEP_INIT SET_OUTPUT(Z_STEP_PIN)</front>
<front id="stepper_indirectionH-81">#define Z_STEP_WRITE(STATE) WRITE(Z_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-82">#define Z_STEP_READ READ(Z_STEP_PIN)</front>
<front id="stepper_indirectionH-83"></front>
<front id="stepper_indirectionH-84">#define Z_DIR_INIT SET_OUTPUT(Z_DIR_PIN)</front>
<front id="stepper_indirectionH-85">#define Z_DIR_WRITE(STATE) WRITE(Z_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-86">#define Z_DIR_READ READ(Z_DIR_PIN)</front>
<front id="stepper_indirectionH-87"></front>
<front id="stepper_indirectionH-88">#define Z_ENABLE_INIT SET_OUTPUT(Z_ENABLE_PIN)</front>
<front id="stepper_indirectionH-89">#define Z_ENABLE_WRITE(STATE) WRITE(Z_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-90">#define Z_ENABLE_READ READ(Z_ENABLE_PIN)</front>
<front id="stepper_indirectionH-91"></front>
<front id="stepper_indirectionH-92">// Z2 motor</front>
<front id="stepper_indirectionH-93">#define Z2_STEP_INIT SET_OUTPUT(Z2_STEP_PIN)</front>
<front id="stepper_indirectionH-94">#define Z2_STEP_WRITE(STATE) WRITE(Z2_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-95">#define Z2_STEP_READ READ(Z2_STEP_PIN)</front>
<front id="stepper_indirectionH-96"></front>
<front id="stepper_indirectionH-97">#define Z2_DIR_INIT SET_OUTPUT(Z2_DIR_PIN)</front>
<front id="stepper_indirectionH-98">#define Z2_DIR_WRITE(STATE) WRITE(Z2_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-99">#define Z2_DIR_READ READ(Z2_DIR_PIN)</front>
<front id="stepper_indirectionH-100"></front>
<front id="stepper_indirectionH-101">#define Z2_ENABLE_INIT SET_OUTPUT(Z2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-102">#define Z2_ENABLE_WRITE(STATE) WRITE(Z2_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-103">#define Z2_ENABLE_READ READ(Z2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-104"></front>
<front id="stepper_indirectionH-105">// E0 motor</front>
<front id="stepper_indirectionH-106">#define E0_STEP_INIT SET_OUTPUT(E0_STEP_PIN)</front>
<front id="stepper_indirectionH-107">#define E0_STEP_WRITE(STATE) WRITE(E0_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-108">#define E0_STEP_READ READ(E0_STEP_PIN)</front>
<front id="stepper_indirectionH-109"></front>
<front id="stepper_indirectionH-110">#define E0_DIR_INIT SET_OUTPUT(E0_DIR_PIN)</front>
<front id="stepper_indirectionH-111">#define E0_DIR_WRITE(STATE) WRITE(E0_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-112">#define E0_DIR_READ READ(E0_DIR_PIN)</front>
<front id="stepper_indirectionH-113"></front>
<front id="stepper_indirectionH-114">#define E0_ENABLE_INIT SET_OUTPUT(E0_ENABLE_PIN)</front>
<front id="stepper_indirectionH-115">#define E0_ENABLE_WRITE(STATE) WRITE(E0_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-116">#define E0_ENABLE_READ READ(E0_ENABLE_PIN)</front>
<front id="stepper_indirectionH-117"></front>
<front id="stepper_indirectionH-118">// E1 motor</front>
<front id="stepper_indirectionH-119">#define E1_STEP_INIT SET_OUTPUT(E1_STEP_PIN)</front>
<front id="stepper_indirectionH-120">#define E1_STEP_WRITE(STATE) WRITE(E1_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-121">#define E1_STEP_READ READ(E1_STEP_PIN)</front>
<front id="stepper_indirectionH-122"></front>
<front id="stepper_indirectionH-123">#define E1_DIR_INIT SET_OUTPUT(E1_DIR_PIN)</front>
<front id="stepper_indirectionH-124">#define E1_DIR_WRITE(STATE) WRITE(E1_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-125">#define E1_DIR_READ READ(E1_DIR_PIN)</front>
<front id="stepper_indirectionH-126"></front>
<front id="stepper_indirectionH-127">#define E1_ENABLE_INIT SET_OUTPUT(E1_ENABLE_PIN)</front>
<front id="stepper_indirectionH-128">#define E1_ENABLE_WRITE(STATE) WRITE(E1_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-129">#define E1_ENABLE_READ READ(E1_ENABLE_PIN)</front>
<front id="stepper_indirectionH-130"></front>
<front id="stepper_indirectionH-131">// E2 motor</front>
<front id="stepper_indirectionH-132">#define E2_STEP_INIT SET_OUTPUT(E2_STEP_PIN)</front>
<front id="stepper_indirectionH-133">#define E2_STEP_WRITE(STATE) WRITE(E2_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-134">#define E2_STEP_READ READ(E2_STEP_PIN)</front>
<front id="stepper_indirectionH-135"></front>
<front id="stepper_indirectionH-136">#define E2_DIR_INIT SET_OUTPUT(E2_DIR_PIN)</front>
<front id="stepper_indirectionH-137">#define E2_DIR_WRITE(STATE) WRITE(E2_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-138">#define E2_DIR_READ READ(E2_DIR_PIN)</front>
<front id="stepper_indirectionH-139"></front>
<front id="stepper_indirectionH-140">#define E2_ENABLE_INIT SET_OUTPUT(E2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-141">#define E2_ENABLE_WRITE(STATE) WRITE(E2_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-142">#define E2_ENABLE_READ READ(E2_ENABLE_PIN)</front>
<front id="stepper_indirectionH-143"></front>
<front id="stepper_indirectionH-144">// E3 motor</front>
<front id="stepper_indirectionH-145">#define E3_STEP_INIT SET_OUTPUT(E3_STEP_PIN)</front>
<front id="stepper_indirectionH-146">#define E3_STEP_WRITE(STATE) WRITE(E3_STEP_PIN,STATE)</front>
<front id="stepper_indirectionH-147">#define E3_STEP_READ READ(E3_STEP_PIN)</front>
<front id="stepper_indirectionH-148"></front>
<front id="stepper_indirectionH-149">#define E3_DIR_INIT SET_OUTPUT(E3_DIR_PIN)</front>
<front id="stepper_indirectionH-150">#define E3_DIR_WRITE(STATE) WRITE(E3_DIR_PIN,STATE)</front>
<front id="stepper_indirectionH-151">#define E3_DIR_READ READ(E3_DIR_PIN)</front>
<front id="stepper_indirectionH-152"></front>
<front id="stepper_indirectionH-153">#define E3_ENABLE_INIT SET_OUTPUT(E3_ENABLE_PIN)</front>
<front id="stepper_indirectionH-154">#define E3_ENABLE_WRITE(STATE) WRITE(E3_ENABLE_PIN,STATE)</front>
<front id="stepper_indirectionH-155">#define E3_ENABLE_READ READ(E3_ENABLE_PIN)</front>
<front id="stepper_indirectionH-156"></front>
<front id="stepper_indirectionH-157">//////////////////////////////////</front>
<front id="stepper_indirectionH-158">// Pin redefines for TMC drivers. </front>
<front id="stepper_indirectionH-159">// TMC26X drivers have step and dir on normal pins, but everything else via SPI</front>
<front id="stepper_indirectionH-160">//////////////////////////////////</front>
<front id="stepper_indirectionH-161">#if ENABLED(HAVE_TMCDRIVER)</front>
<front id="stepper_indirectionH-162">#include &lt;SPI.h&gt;</front>
<front id="stepper_indirectionH-163">#include &lt;TMC26XStepper.h&gt;</front>
<front id="stepper_indirectionH-164"></front>
<front id="stepper_indirectionH-165">  void tmc_init();</front>
<front id="stepper_indirectionH-166">#if ENABLED(X_IS_TMC)</front>
<front id="stepper_indirectionH-167">   extern TMC26XStepper stepperX;</front>
<front id="stepper_indirectionH-168">   #undef X_ENABLE_INIT </front>
<front id="stepper_indirectionH-169">   #define X_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-170">   </front>
<front id="stepper_indirectionH-171">   #undef X_ENABLE_WRITE</front>
<front id="stepper_indirectionH-172">   #define X_ENABLE_WRITE(STATE) stepperX.setEnabled(STATE)</front>
<front id="stepper_indirectionH-173">   </front>
<front id="stepper_indirectionH-174">   #undef X_ENABLE_READ</front>
<front id="stepper_indirectionH-175">   #define X_ENABLE_READ stepperX.isEnabled()</front>
<front id="stepper_indirectionH-176">   </front>
<front id="stepper_indirectionH-177">#endif</front>
<front id="stepper_indirectionH-178">#if ENABLED(X2_IS_TMC)</front>
<front id="stepper_indirectionH-179">   extern TMC26XStepper stepperX2;</front>
<front id="stepper_indirectionH-180">   #undef X2_ENABLE_INIT</front>
<front id="stepper_indirectionH-181">   #define X2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-182">   </front>
<front id="stepper_indirectionH-183">   #undef X2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-184">   #define X2_ENABLE_WRITE(STATE) stepperX2.setEnabled(STATE)</front>
<front id="stepper_indirectionH-185">   </front>
<front id="stepper_indirectionH-186">   #undef X2_ENABLE_READ</front>
<front id="stepper_indirectionH-187">   #define X2_ENABLE_READ stepperX2.isEnabled()   </front>
<front id="stepper_indirectionH-188">#endif</front>
<front id="stepper_indirectionH-189">#if ENABLED(Y_IS_TMC)</front>
<front id="stepper_indirectionH-190">   extern TMC26XStepper stepperY;</front>
<front id="stepper_indirectionH-191">   #undef Y_ENABLE_INIT</front>
<front id="stepper_indirectionH-192">   #define Y_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-193">   </front>
<front id="stepper_indirectionH-194">   #undef Y_ENABLE_WRITE</front>
<front id="stepper_indirectionH-195">   #define Y_ENABLE_WRITE(STATE) stepperY.setEnabled(STATE)</front>
<front id="stepper_indirectionH-196">   </front>
<front id="stepper_indirectionH-197">   #undef Y_ENABLE_READ</front>
<front id="stepper_indirectionH-198">   #define Y_ENABLE_READ stepperY.isEnabled()   </front>
<front id="stepper_indirectionH-199">#endif</front>
<front id="stepper_indirectionH-200">#if ENABLED(Y2_IS_TMC)</front>
<front id="stepper_indirectionH-201">   extern TMC26XStepper stepperY2;</front>
<front id="stepper_indirectionH-202">   #undef Y2_ENABLE_INIT</front>
<front id="stepper_indirectionH-203">   #define Y2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-204">   </front>
<front id="stepper_indirectionH-205">   #undef Y2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-206">   #define Y2_ENABLE_WRITE(STATE) stepperY2.setEnabled(STATE)</front>
<front id="stepper_indirectionH-207">   </front>
<front id="stepper_indirectionH-208">   #undef Y2_ENABLE_READ</front>
<front id="stepper_indirectionH-209">   #define Y2_ENABLE_READ stepperY2.isEnabled()     </front>
<front id="stepper_indirectionH-210">#endif</front>
<front id="stepper_indirectionH-211">#if ENABLED(Z_IS_TMC)</front>
<front id="stepper_indirectionH-212">   extern TMC26XStepper stepperZ;</front>
<front id="stepper_indirectionH-213">   #undef Z_ENABLE_INIT</front>
<front id="stepper_indirectionH-214">   #define Z_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-215">   </front>
<front id="stepper_indirectionH-216">   #undef Z_ENABLE_WRITE</front>
<front id="stepper_indirectionH-217">   #define Z_ENABLE_WRITE(STATE) stepperZ.setEnabled(STATE)</front>
<front id="stepper_indirectionH-218">   </front>
<front id="stepper_indirectionH-219">   #undef Z_ENABLE_READ</front>
<front id="stepper_indirectionH-220">   #define Z_ENABLE_READ stepperZ.isEnabled()       </front>
<front id="stepper_indirectionH-221">#endif</front>
<front id="stepper_indirectionH-222">#if ENABLED(Z2_IS_TMC)</front>
<front id="stepper_indirectionH-223">   extern TMC26XStepper stepperZ2;</front>
<front id="stepper_indirectionH-224">   #undef Z2_ENABLE_INIT</front>
<front id="stepper_indirectionH-225">   #define Z2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-226">   </front>
<front id="stepper_indirectionH-227">   #undef Z2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-228">   #define Z2_ENABLE_WRITE(STATE) stepperZ2.setEnabled(STATE)</front>
<front id="stepper_indirectionH-229">   </front>
<front id="stepper_indirectionH-230">   #undef Z2_ENABLE_READ</front>
<front id="stepper_indirectionH-231">   #define Z2_ENABLE_READ stepperZ2.isEnabled()   </front>
<front id="stepper_indirectionH-232">#endif</front>
<front id="stepper_indirectionH-233">#if ENABLED(E0_IS_TMC)</front>
<front id="stepper_indirectionH-234">   extern TMC26XStepper stepperE0;</front>
<front id="stepper_indirectionH-235">   #undef E0_ENABLE_INIT</front>
<front id="stepper_indirectionH-236">   #define E0_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-237">   </front>
<front id="stepper_indirectionH-238">   #undef E0_ENABLE_WRITE</front>
<front id="stepper_indirectionH-239">   #define E0_ENABLE_WRITE(STATE) stepperE0.setEnabled(STATE)</front>
<front id="stepper_indirectionH-240">   </front>
<front id="stepper_indirectionH-241">   #undef E0_ENABLE_READ</front>
<front id="stepper_indirectionH-242">   #define E0_ENABLE_READ stepperE0.isEnabled()   </front>
<front id="stepper_indirectionH-243">#endif</front>
<front id="stepper_indirectionH-244">#if ENABLED(E1_IS_TMC)</front>
<front id="stepper_indirectionH-245">   extern TMC26XStepper stepperE1;</front>
<front id="stepper_indirectionH-246">   #undef E1_ENABLE_INIT</front>
<front id="stepper_indirectionH-247">   #define E1_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-248">   </front>
<front id="stepper_indirectionH-249">   #undef E1_ENABLE_WRITE</front>
<front id="stepper_indirectionH-250">   #define E1_ENABLE_WRITE(STATE) stepperE1.setEnabled(STATE)</front>
<front id="stepper_indirectionH-251">   </front>
<front id="stepper_indirectionH-252">   #undef E1_ENABLE_READ</front>
<front id="stepper_indirectionH-253">   #define E1_ENABLE_READ stepperE1.isEnabled()   </front>
<front id="stepper_indirectionH-254">#endif</front>
<front id="stepper_indirectionH-255">#if ENABLED(E2_IS_TMC)</front>
<front id="stepper_indirectionH-256">   extern TMC26XStepper stepperE2;</front>
<front id="stepper_indirectionH-257">   #undef E2_ENABLE_INIT</front>
<front id="stepper_indirectionH-258">   #define E2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-259">   </front>
<front id="stepper_indirectionH-260">   #undef E2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-261">   #define E2_ENABLE_WRITE(STATE) stepperE2.setEnabled(STATE)</front>
<front id="stepper_indirectionH-262">   </front>
<front id="stepper_indirectionH-263">   #undef E2_ENABLE_READ</front>
<front id="stepper_indirectionH-264">   #define E2_ENABLE_READ stepperE2.isEnabled()   </front>
<front id="stepper_indirectionH-265">#endif</front>
<front id="stepper_indirectionH-266">#if ENABLED(E3_IS_TMC)</front>
<front id="stepper_indirectionH-267">   extern TMC26XStepper stepperE3;</front>
<front id="stepper_indirectionH-268">   #undef E3_ENABLE_INIT</front>
<front id="stepper_indirectionH-269">   #define E3_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-270">   </front>
<front id="stepper_indirectionH-271">   #undef E3_ENABLE_WRITE</front>
<front id="stepper_indirectionH-272">   #define E3_ENABLE_WRITE(STATE) stepperE3.setEnabled(STATE)</front>
<front id="stepper_indirectionH-273">   </front>
<front id="stepper_indirectionH-274">   #undef E3_ENABLE_READ</front>
<front id="stepper_indirectionH-275">   #define E3_ENABLE_READ stepperE3.isEnabled()   </front>
<front id="stepper_indirectionH-276">#endif</front>
<front id="stepper_indirectionH-277"></front>
<front id="stepper_indirectionH-278">#endif  // HAVE_TMCDRIVER</front>
<front id="stepper_indirectionH-279"></front>
<front id="stepper_indirectionH-280">//////////////////////////////////</front>
<front id="stepper_indirectionH-281">// Pin redefines for L6470 drivers. </front>
<front id="stepper_indirectionH-282">// L640 drivers have step on normal pins, but dir and everything else via SPI</front>
<front id="stepper_indirectionH-283">//////////////////////////////////</front>
<front id="stepper_indirectionH-284">#if ENABLED(HAVE_L6470DRIVER)</front>
<front id="stepper_indirectionH-285"></front>
<front id="stepper_indirectionH-286">#include &lt;SPI.h&gt;</front>
<front id="stepper_indirectionH-287">#include &lt;L6470.h&gt;</front>
<front id="stepper_indirectionH-288"></front>
<front id="stepper_indirectionH-289">  void L6470_init();</front>
<front id="stepper_indirectionH-290">#if ENABLED(X_IS_L6470)</front>
<front id="stepper_indirectionH-291">   extern L6470 stepperX;</front>
<front id="stepper_indirectionH-292">   #undef X_ENABLE_INIT </front>
<front id="stepper_indirectionH-293">   #define X_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-294">   </front>
<front id="stepper_indirectionH-295">   #undef X_ENABLE_WRITE</front>
<front id="stepper_indirectionH-296">   #define X_ENABLE_WRITE(STATE) {if(STATE) stepperX.Step_Clock(stepperX.getStatus() & STATUS_HIZ); else stepperX.softFree();}</front>
<front id="stepper_indirectionH-297">   </front>
<front id="stepper_indirectionH-298">   #undef X_ENABLE_READ</front>
<front id="stepper_indirectionH-299">   #define X_ENABLE_READ (stepperX.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-300">   </front>
<front id="stepper_indirectionH-301">   #undef X_DIR_INIT </front>
<front id="stepper_indirectionH-302">   #define X_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-303">   </front>
<front id="stepper_indirectionH-304">   #undef X_DIR_WRITE</front>
<front id="stepper_indirectionH-305">   #define X_DIR_WRITE(STATE) stepperX.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-306">   </front>
<front id="stepper_indirectionH-307">   #undef X_DIR_READ</front>
<front id="stepper_indirectionH-308">   #define X_DIR_READ (stepperX.getStatus() & STATUS_DIR)</front>
<front id="stepper_indirectionH-309">   </front>
<front id="stepper_indirectionH-310">#endif</front>
<front id="stepper_indirectionH-311">#if ENABLED(X2_IS_L6470)</front>
<front id="stepper_indirectionH-312">   extern L6470 stepperX2;</front>
<front id="stepper_indirectionH-313">   #undef X2_ENABLE_INIT</front>
<front id="stepper_indirectionH-314">   #define X2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-315">   </front>
<front id="stepper_indirectionH-316">   #undef X2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-317">   #define X2_ENABLE_WRITE(STATE) (if(STATE) stepperX2.Step_Clock(stepperX2.getStatus() & STATUS_HIZ); else stepperX2.softFree();)</front>
<front id="stepper_indirectionH-318">   </front>
<front id="stepper_indirectionH-319">   #undef X2_ENABLE_READ</front>
<front id="stepper_indirectionH-320">   #define X2_ENABLE_READ (stepperX2.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-321">   </front>
<front id="stepper_indirectionH-322">   #undef X2_DIR_INIT </front>
<front id="stepper_indirectionH-323">   #define X2_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-324">   </front>
<front id="stepper_indirectionH-325">   #undef X2_DIR_WRITE</front>
<front id="stepper_indirectionH-326">   #define X2_DIR_WRITE(STATE) stepperX2.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-327">   </front>
<front id="stepper_indirectionH-328">   #undef X2_DIR_READ</front>
<front id="stepper_indirectionH-329">   #define X2_DIR_READ (stepperX2.getStatus() & STATUS_DIR)</front>
<front id="stepper_indirectionH-330">#endif</front>
<front id="stepper_indirectionH-331">#if ENABLED(Y_IS_L6470)</front>
<front id="stepper_indirectionH-332">   extern L6470 stepperY;</front>
<front id="stepper_indirectionH-333">   #undef Y_ENABLE_INIT</front>
<front id="stepper_indirectionH-334">   #define Y_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-335">   </front>
<front id="stepper_indirectionH-336">   #undef Y_ENABLE_WRITE</front>
<front id="stepper_indirectionH-337">   #define Y_ENABLE_WRITE(STATE) (if(STATE) stepperY.Step_Clock(stepperY.getStatus() & STATUS_HIZ); else stepperY.softFree();)</front>
<front id="stepper_indirectionH-338">   </front>
<front id="stepper_indirectionH-339">   #undef Y_ENABLE_READ</front>
<front id="stepper_indirectionH-340">   #define Y_ENABLE_READ (stepperY.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-341">   </front>
<front id="stepper_indirectionH-342">   #undef Y_DIR_INIT </front>
<front id="stepper_indirectionH-343">   #define Y_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-344">   </front>
<front id="stepper_indirectionH-345">   #undef Y_DIR_WRITE</front>
<front id="stepper_indirectionH-346">   #define Y_DIR_WRITE(STATE) stepperY.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-347">   </front>
<front id="stepper_indirectionH-348">   #undef Y_DIR_READ</front>
<front id="stepper_indirectionH-349">   #define Y_DIR_READ (stepperY.getStatus() & STATUS_DIR)  </front>
<front id="stepper_indirectionH-350">#endif</front>
<front id="stepper_indirectionH-351">#if ENABLED(Y2_IS_L6470)</front>
<front id="stepper_indirectionH-352">   extern L6470 stepperY2;</front>
<front id="stepper_indirectionH-353">   #undef Y2_ENABLE_INIT</front>
<front id="stepper_indirectionH-354">   #define Y2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-355">   </front>
<front id="stepper_indirectionH-356">   #undef Y2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-357">   #define Y2_ENABLE_WRITE(STATE) (if(STATE) stepperY2.Step_Clock(stepperY2.getStatus() & STATUS_HIZ); else stepperY2.softFree();)</front>
<front id="stepper_indirectionH-358">   </front>
<front id="stepper_indirectionH-359">   #undef Y2_ENABLE_READ</front>
<front id="stepper_indirectionH-360">   #define Y2_ENABLE_READ (stepperY2.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-361">   </front>
<front id="stepper_indirectionH-362">   #undef Y2_DIR_INIT </front>
<front id="stepper_indirectionH-363">   #define Y2_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-364">   </front>
<front id="stepper_indirectionH-365">   #undef Y2_DIR_WRITE</front>
<front id="stepper_indirectionH-366">   #define Y2_DIR_WRITE(STATE) stepperY2.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-367">   </front>
<front id="stepper_indirectionH-368">   #undef Y2_DIR_READ</front>
<front id="stepper_indirectionH-369">   #define Y2_DIR_READ (stepperY2.getStatus() & STATUS_DIR)   </front>
<front id="stepper_indirectionH-370">#endif</front>
<front id="stepper_indirectionH-371">#if ENABLED(Z_IS_L6470)</front>
<front id="stepper_indirectionH-372">   extern L6470 stepperZ;</front>
<front id="stepper_indirectionH-373">   #undef Z_ENABLE_INIT</front>
<front id="stepper_indirectionH-374">   #define Z_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-375">   </front>
<front id="stepper_indirectionH-376">   #undef Z_ENABLE_WRITE</front>
<front id="stepper_indirectionH-377">   #define Z_ENABLE_WRITE(STATE) (if(STATE) stepperZ.Step_Clock(stepperZ.getStatus() & STATUS_HIZ); else stepperZ.softFree();)</front>
<front id="stepper_indirectionH-378">   </front>
<front id="stepper_indirectionH-379">   #undef Z_ENABLE_READ</front>
<front id="stepper_indirectionH-380">   #define Z_ENABLE_READ (stepperZ.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-381">   </front>
<front id="stepper_indirectionH-382">   #undef Z_DIR_INIT </front>
<front id="stepper_indirectionH-383">   #define Z_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-384">   </front>
<front id="stepper_indirectionH-385">   #undef Z_DIR_WRITE</front>
<front id="stepper_indirectionH-386">   #define Z_DIR_WRITE(STATE) stepperZ.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-387">   </front>
<front id="stepper_indirectionH-388">   #undef Y_DIR_READ</front>
<front id="stepper_indirectionH-389">   #define Y_DIR_READ (stepperZ.getStatus() & STATUS_DIR)      </front>
<front id="stepper_indirectionH-390">#endif</front>
<front id="stepper_indirectionH-391">#if ENABLED(Z2_IS_L6470)</front>
<front id="stepper_indirectionH-392">   extern L6470 stepperZ2;</front>
<front id="stepper_indirectionH-393">   #undef Z2_ENABLE_INIT</front>
<front id="stepper_indirectionH-394">   #define Z2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-395">   </front>
<front id="stepper_indirectionH-396">   #undef Z2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-397">   #define Z2_ENABLE_WRITE(STATE) (if(STATE) stepperZ2.Step_Clock(stepperZ2.getStatus() & STATUS_HIZ); else stepperZ2.softFree();)</front>
<front id="stepper_indirectionH-398">   </front>
<front id="stepper_indirectionH-399">   #undef Z2_ENABLE_READ</front>
<front id="stepper_indirectionH-400">   #define Z2_ENABLE_READ (stepperZ2.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-401">   </front>
<front id="stepper_indirectionH-402">   #undef Z2_DIR_INIT </front>
<front id="stepper_indirectionH-403">   #define Z2_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-404">   </front>
<front id="stepper_indirectionH-405">   #undef Z2_DIR_WRITE</front>
<front id="stepper_indirectionH-406">   #define Z2_DIR_WRITE(STATE) stepperZ2.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-407">   </front>
<front id="stepper_indirectionH-408">   #undef Y2_DIR_READ</front>
<front id="stepper_indirectionH-409">   #define Y2_DIR_READ (stepperZ2.getStatus() & STATUS_DIR)       </front>
<front id="stepper_indirectionH-410">#endif</front>
<front id="stepper_indirectionH-411">#if ENABLED(E0_IS_L6470)</front>
<front id="stepper_indirectionH-412">   extern L6470 stepperE0;</front>
<front id="stepper_indirectionH-413">   #undef E0_ENABLE_INIT</front>
<front id="stepper_indirectionH-414">   #define E0_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-415">   </front>
<front id="stepper_indirectionH-416">   #undef E0_ENABLE_WRITE</front>
<front id="stepper_indirectionH-417">   #define E0_ENABLE_WRITE(STATE) (if(STATE) stepperE0.Step_Clock(stepperE0.getStatus() & STATUS_HIZ); else stepperE0.softFree();)</front>
<front id="stepper_indirectionH-418">   </front>
<front id="stepper_indirectionH-419">   #undef E0_ENABLE_READ</front>
<front id="stepper_indirectionH-420">   #define E0_ENABLE_READ (stepperE0.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-421">   </front>
<front id="stepper_indirectionH-422">   #undef E0_DIR_INIT </front>
<front id="stepper_indirectionH-423">   #define E0_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-424">   </front>
<front id="stepper_indirectionH-425">   #undef E0_DIR_WRITE</front>
<front id="stepper_indirectionH-426">   #define E0_DIR_WRITE(STATE) stepperE0.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-427">   </front>
<front id="stepper_indirectionH-428">   #undef E0_DIR_READ</front>
<front id="stepper_indirectionH-429">   #define E0_DIR_READ (stepperE0.getStatus() & STATUS_DIR)    </front>
<front id="stepper_indirectionH-430">#endif</front>
<front id="stepper_indirectionH-431">#if ENABLED(E1_IS_L6470)</front>
<front id="stepper_indirectionH-432">   extern L6470 stepperE1;</front>
<front id="stepper_indirectionH-433">   #undef E1_ENABLE_INIT</front>
<front id="stepper_indirectionH-434">   #define E1_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-435">   </front>
<front id="stepper_indirectionH-436">   #undef E1_ENABLE_WRITE</front>
<front id="stepper_indirectionH-437">   #define E1_ENABLE_WRITE(STATE) (if(STATE) stepperE1.Step_Clock(stepperE1.getStatus() & STATUS_HIZ); else stepperE1.softFree();)</front>
<front id="stepper_indirectionH-438">   </front>
<front id="stepper_indirectionH-439">   #undef E1_ENABLE_READ</front>
<front id="stepper_indirectionH-440">   #define E1_ENABLE_READ (stepperE1.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-441">   </front>
<front id="stepper_indirectionH-442">   #undef E1_DIR_INIT </front>
<front id="stepper_indirectionH-443">   #define E1_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-444">   </front>
<front id="stepper_indirectionH-445">   #undef E1_DIR_WRITE</front>
<front id="stepper_indirectionH-446">   #define E1_DIR_WRITE(STATE) stepperE1.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-447">   </front>
<front id="stepper_indirectionH-448">   #undef E1_DIR_READ</front>
<front id="stepper_indirectionH-449">   #define E1_DIR_READ (stepperE1.getStatus() & STATUS_DIR)  </front>
<front id="stepper_indirectionH-450">#endif</front>
<front id="stepper_indirectionH-451">#if ENABLED(E2_IS_L6470)</front>
<front id="stepper_indirectionH-452">   extern L6470 stepperE2;</front>
<front id="stepper_indirectionH-453">   #undef E2_ENABLE_INIT</front>
<front id="stepper_indirectionH-454">   #define E2_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-455">   </front>
<front id="stepper_indirectionH-456">   #undef E2_ENABLE_WRITE</front>
<front id="stepper_indirectionH-457">   #define E2_ENABLE_WRITE(STATE) (if(STATE) stepperE2.Step_Clock(stepperE2.getStatus() & STATUS_HIZ); else stepperE2.softFree();)</front>
<front id="stepper_indirectionH-458">   </front>
<front id="stepper_indirectionH-459">   #undef E2_ENABLE_READ</front>
<front id="stepper_indirectionH-460">   #define E2_ENABLE_READ (stepperE2.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-461">   </front>
<front id="stepper_indirectionH-462">   #undef E2_DIR_INIT </front>
<front id="stepper_indirectionH-463">   #define E2_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-464">   </front>
<front id="stepper_indirectionH-465">   #undef E2_DIR_WRITE</front>
<front id="stepper_indirectionH-466">   #define E2_DIR_WRITE(STATE) stepperE2.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-467">   </front>
<front id="stepper_indirectionH-468">   #undef E2_DIR_READ</front>
<front id="stepper_indirectionH-469">   #define E2_DIR_READ (stepperE2.getStatus() & STATUS_DIR)  </front>
<front id="stepper_indirectionH-470">#endif</front>
<front id="stepper_indirectionH-471">#if ENABLED(E3_IS_L6470)</front>
<front id="stepper_indirectionH-472">   extern L6470 stepperE3;</front>
<front id="stepper_indirectionH-473">   #undef E3_ENABLE_INIT</front>
<front id="stepper_indirectionH-474">   #define E3_ENABLE_INIT ((void)0)</front>
<front id="stepper_indirectionH-475">   </front>
<front id="stepper_indirectionH-476">   #undef E3_ENABLE_WRITE</front>
<front id="stepper_indirectionH-477">   #define E3_ENABLE_WRITE(STATE) (if(STATE) stepperE3.Step_Clock(stepperE3.getStatus() & STATUS_HIZ); else stepperE3.softFree();)</front>
<front id="stepper_indirectionH-478">   </front>
<front id="stepper_indirectionH-479">   #undef E3_ENABLE_READ</front>
<front id="stepper_indirectionH-480">   #define E3_ENABLE_READ (stepperE3.getStatus() & STATUS_HIZ)</front>
<front id="stepper_indirectionH-481">   </front>
<front id="stepper_indirectionH-482">   #undef E3_DIR_INIT </front>
<front id="stepper_indirectionH-483">   #define E3_DIR_INIT ((void)0)</front>
<front id="stepper_indirectionH-484">   </front>
<front id="stepper_indirectionH-485">   #undef E3_DIR_WRITE</front>
<front id="stepper_indirectionH-486">   #define E3_DIR_WRITE(STATE) stepperE3.Step_Clock(STATE)</front>
<front id="stepper_indirectionH-487">   </front>
<front id="stepper_indirectionH-488">   #undef E3_DIR_READ</front>
<front id="stepper_indirectionH-489">   #define E3_DIR_READ (stepperE3.getStatus() & STATUS_DIR)  </front>
<front id="stepper_indirectionH-490">#endif</front>
<front id="stepper_indirectionH-491"></front>
<front id="stepper_indirectionH-492">#endif  //HAVE_L6470DRIVER</front>
<front id="stepper_indirectionH-493"></front>
<front id="stepper_indirectionH-494">#endif // STEPPER_INDIRECTION_H</front>
 </pre>
<h1 id="temperatureCPPtitle" >temperature.cpp</h1>
<pre id="temperatureCPP"  class="prettyprint linenums"><front id="temperatureCPP-1">/*</front>
<front id="temperatureCPP-2">  temperature.cpp - temperature control</front>
<front id="temperatureCPP-3">  Part of Marlin</front>
<front id="temperatureCPP-4">  </front>
<front id="temperatureCPP-5"> Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm</front>
<front id="temperatureCPP-6"> </front>
<front id="temperatureCPP-7"> This program is free software: you can redistribute it and/or modify</front>
<front id="temperatureCPP-8"> it under the terms of the GNU General Public License as published by</front>
<front id="temperatureCPP-9"> the Free Software Foundation, either version 3 of the License, or</front>
<front id="temperatureCPP-10"> (at your option) any later version.</front>
<front id="temperatureCPP-11"> </front>
<front id="temperatureCPP-12"> This program is distributed in the hope that it will be useful,</front>
<front id="temperatureCPP-13"> but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="temperatureCPP-14"> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="temperatureCPP-15"> GNU General Public License for more details.</front>
<front id="temperatureCPP-16"> </front>
<front id="temperatureCPP-17"> You should have received a copy of the GNU General Public License</front>
<front id="temperatureCPP-18"> along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="temperatureCPP-19">*/</front>
<front id="temperatureCPP-20"></front>
<front id="temperatureCPP-21">#include "Marlin.h"</front>
<front id="temperatureCPP-22">#include "ultralcd.h"</front>
<front id="temperatureCPP-23">#include "temperature.h"</front>
<front id="temperatureCPP-24">#include "watchdog.h"</front>
<front id="temperatureCPP-25">#include "language.h"</front>
<front id="temperatureCPP-26"></front>
<front id="temperatureCPP-27">#include "Sd2PinMap.h"</front>
<front id="temperatureCPP-28"></front>
<front id="temperatureCPP-29">//===========================================================================</front>
<front id="temperatureCPP-30">//================================== macros =================================</front>
<front id="temperatureCPP-31">//===========================================================================</front>
<front id="temperatureCPP-32"></front>
<front id="temperatureCPP-33">#ifdef K1 // Defined in Configuration.h in the PID settings</front>
<front id="temperatureCPP-34">  #define K2 (1.0-K1)</front>
<front id="temperatureCPP-35">#endif</front>
<front id="temperatureCPP-36"></front>
<front id="temperatureCPP-37">#if ENABLED(PIDTEMPBED) || ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-38">  #define PID_dT ((OVERSAMPLENR * 12.0)/(F_CPU / 64.0 / 256.0))</front>
<front id="temperatureCPP-39">#endif</front>
<front id="temperatureCPP-40"></front>
<front id="temperatureCPP-41">//===========================================================================</front>
<front id="temperatureCPP-42">//============================= public variables ============================</front>
<front id="temperatureCPP-43">//===========================================================================</front>
<front id="temperatureCPP-44"></front>
<front id="temperatureCPP-45">int target_temperature[4] = { 0 };</front>
<front id="temperatureCPP-46">int target_temperature_bed = 0;</front>
<front id="temperatureCPP-47">int current_temperature_raw[4] = { 0 };</front>
<front id="temperatureCPP-48">float current_temperature[4] = { 0.0 };</front>
<front id="temperatureCPP-49">int current_temperature_bed_raw = 0;</front>
<front id="temperatureCPP-50">float current_temperature_bed = 0.0;</front>
<front id="temperatureCPP-51">#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureCPP-52">  int redundant_temperature_raw = 0;</front>
<front id="temperatureCPP-53">  float redundant_temperature = 0.0;</front>
<front id="temperatureCPP-54">#endif</front>
<front id="temperatureCPP-55"></front>
<front id="temperatureCPP-56">#if ENABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-57">  float bedKp=DEFAULT_bedKp;</front>
<front id="temperatureCPP-58">  float bedKi=(DEFAULT_bedKi*PID_dT);</front>
<front id="temperatureCPP-59">  float bedKd=(DEFAULT_bedKd/PID_dT);</front>
<front id="temperatureCPP-60">#endif //PIDTEMPBED</front>
<front id="temperatureCPP-61">  </front>
<front id="temperatureCPP-62">#if ENABLED(FAN_SOFT_PWM)</front>
<front id="temperatureCPP-63">  unsigned char fanSpeedSoftPwm;</front>
<front id="temperatureCPP-64">#endif</front>
<front id="temperatureCPP-65"></front>
<front id="temperatureCPP-66">unsigned char soft_pwm_bed;</front>
<front id="temperatureCPP-67">  </front>
<front id="temperatureCPP-68">#if ENABLED(BABYSTEPPING)</front>
<front id="temperatureCPP-69">  volatile int babystepsTodo[3] = { 0 };</front>
<front id="temperatureCPP-70">#endif</front>
<front id="temperatureCPP-71"></front>
<front id="temperatureCPP-72">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="temperatureCPP-73">  int current_raw_filwidth = 0;  //Holds measured filament diameter - one extruder only</front>
<front id="temperatureCPP-74">#endif  </front>
<front id="temperatureCPP-75"></front>
<front id="temperatureCPP-76">#if ENABLED(THERMAL_PROTECTION_HOTENDS) || ENABLED(THERMAL_PROTECTION_BED)</front>
<front id="temperatureCPP-77">  enum TRState { TRReset, TRInactive, TRFirstHeating, TRStable, TRRunaway };</front>
<front id="temperatureCPP-78">  void thermal_runaway_protection(TRState *state, millis_t *timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc);</front>
<front id="temperatureCPP-79">  #if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureCPP-80">    static TRState thermal_runaway_state_machine[4] = { TRReset, TRReset, TRReset, TRReset };</front>
<front id="temperatureCPP-81">    static millis_t thermal_runaway_timer[4]; // = {0,0,0,0};</front>
<front id="temperatureCPP-82">  #endif</front>
<front id="temperatureCPP-83">  #if ENABLED(THERMAL_PROTECTION_BED) && TEMP_SENSOR_BED != 0</front>
<front id="temperatureCPP-84">    static TRState thermal_runaway_bed_state_machine = TRReset;</front>
<front id="temperatureCPP-85">    static millis_t thermal_runaway_bed_timer;</front>
<front id="temperatureCPP-86">  #endif</front>
<front id="temperatureCPP-87">#endif</front>
<front id="temperatureCPP-88"></front>
<front id="temperatureCPP-89">//===========================================================================</front>
<front id="temperatureCPP-90">//============================ private variables ============================</front>
<front id="temperatureCPP-91">//===========================================================================</front>
<front id="temperatureCPP-92"></front>
<front id="temperatureCPP-93">static volatile bool temp_meas_ready = false;</front>
<front id="temperatureCPP-94"></front>
<front id="temperatureCPP-95">#if ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-96">  //static cannot be external:</front>
<front id="temperatureCPP-97">  static float temp_iState[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-98">  static float temp_dState[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-99">  static float pTerm[EXTRUDERS];</front>
<front id="temperatureCPP-100">  static float iTerm[EXTRUDERS];</front>
<front id="temperatureCPP-101">  static float dTerm[EXTRUDERS];</front>
<front id="temperatureCPP-102">  #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-103">    static float cTerm[EXTRUDERS];</front>
<front id="temperatureCPP-104">    static long last_position[EXTRUDERS];</front>
<front id="temperatureCPP-105">    static long lpq[LPQ_MAX_LEN];</front>
<front id="temperatureCPP-106">    static int lpq_ptr = 0;</front>
<front id="temperatureCPP-107">  #endif</front>
<front id="temperatureCPP-108">  //int output;</front>
<front id="temperatureCPP-109">  static float pid_error[EXTRUDERS];</front>
<front id="temperatureCPP-110">  static float temp_iState_min[EXTRUDERS];</front>
<front id="temperatureCPP-111">  static float temp_iState_max[EXTRUDERS];</front>
<front id="temperatureCPP-112">  static bool pid_reset[EXTRUDERS];</front>
<front id="temperatureCPP-113">#endif //PIDTEMP</front>
<front id="temperatureCPP-114">#if ENABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-115">  //static cannot be external:</front>
<front id="temperatureCPP-116">  static float temp_iState_bed = { 0 };</front>
<front id="temperatureCPP-117">  static float temp_dState_bed = { 0 };</front>
<front id="temperatureCPP-118">  static float pTerm_bed;</front>
<front id="temperatureCPP-119">  static float iTerm_bed;</front>
<front id="temperatureCPP-120">  static float dTerm_bed;</front>
<front id="temperatureCPP-121">  //int output;</front>
<front id="temperatureCPP-122">  static float pid_error_bed;</front>
<front id="temperatureCPP-123">  static float temp_iState_min_bed;</front>
<front id="temperatureCPP-124">  static float temp_iState_max_bed;</front>
<front id="temperatureCPP-125">#else //PIDTEMPBED</front>
<front id="temperatureCPP-126">  static millis_t  next_bed_check_ms;</front>
<front id="temperatureCPP-127">#endif //PIDTEMPBED</front>
<front id="temperatureCPP-128">  static unsigned char soft_pwm[EXTRUDERS];</front>
<front id="temperatureCPP-129"></front>
<front id="temperatureCPP-130">#if ENABLED(FAN_SOFT_PWM)</front>
<front id="temperatureCPP-131">  static unsigned char soft_pwm_fan;</front>
<front id="temperatureCPP-132">#endif</front>
<front id="temperatureCPP-133">#if HAS_AUTO_FAN</front>
<front id="temperatureCPP-134">  static millis_t next_auto_fan_check_ms;</front>
<front id="temperatureCPP-135">#endif  </front>
<front id="temperatureCPP-136"></front>
<front id="temperatureCPP-137">#if ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-138">  #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="temperatureCPP-139">    float Kp[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kp);</front>
<front id="temperatureCPP-140">    float Ki[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Ki*PID_dT);</front>
<front id="temperatureCPP-141">    float Kd[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kd / PID_dT);</front>
<front id="temperatureCPP-142">    #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-143">      float Kc[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_Kc);</front>
<front id="temperatureCPP-144">    #endif // PID_ADD_EXTRUSION_RATE</front>
<front id="temperatureCPP-145">  #else //PID_PARAMS_PER_EXTRUDER</front>
<front id="temperatureCPP-146">    float Kp = DEFAULT_Kp;</front>
<front id="temperatureCPP-147">    float Ki = DEFAULT_Ki * PID_dT;</front>
<front id="temperatureCPP-148">    float Kd = DEFAULT_Kd / PID_dT;</front>
<front id="temperatureCPP-149">    #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-150">      float Kc = DEFAULT_Kc;</front>
<front id="temperatureCPP-151">    #endif // PID_ADD_EXTRUSION_RATE</front>
<front id="temperatureCPP-152">  #endif // PID_PARAMS_PER_EXTRUDER</front>
<front id="temperatureCPP-153">#endif //PIDTEMP</front>
<front id="temperatureCPP-154"></front>
<front id="temperatureCPP-155">// Init min and max temp with extreme values to prevent false errors during startup</front>
<front id="temperatureCPP-156">static int minttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_LO_TEMP , HEATER_1_RAW_LO_TEMP , HEATER_2_RAW_LO_TEMP, HEATER_3_RAW_LO_TEMP);</front>
<front id="temperatureCPP-157">static int maxttemp_raw[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_RAW_HI_TEMP , HEATER_1_RAW_HI_TEMP , HEATER_2_RAW_HI_TEMP, HEATER_3_RAW_HI_TEMP);</front>
<front id="temperatureCPP-158">static int minttemp[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-159">static int maxttemp[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(16383);</front>
<front id="temperatureCPP-160">#ifdef BED_MINTEMP</front>
<front id="temperatureCPP-161">static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP;</front>
<front id="temperatureCPP-162">#endif</front>
<front id="temperatureCPP-163">#ifdef BED_MAXTEMP</front>
<front id="temperatureCPP-164">  static int bed_maxttemp_raw = HEATER_BED_RAW_HI_TEMP;</front>
<front id="temperatureCPP-165">#endif</front>
<front id="temperatureCPP-166"></front>
<front id="temperatureCPP-167">#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureCPP-168">  static void *heater_ttbl_map[2] = {(void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE };</front>
<front id="temperatureCPP-169">  static uint8_t heater_ttbllen_map[2] = { HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN };</front>
<front id="temperatureCPP-170">#else</front>
<front id="temperatureCPP-171">  static void *heater_ttbl_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( (void *)HEATER_0_TEMPTABLE, (void *)HEATER_1_TEMPTABLE, (void *)HEATER_2_TEMPTABLE, (void *)HEATER_3_TEMPTABLE );</front>
<front id="temperatureCPP-172">  static uint8_t heater_ttbllen_map[EXTRUDERS] = ARRAY_BY_EXTRUDERS( HEATER_0_TEMPTABLE_LEN, HEATER_1_TEMPTABLE_LEN, HEATER_2_TEMPTABLE_LEN, HEATER_3_TEMPTABLE_LEN );</front>
<front id="temperatureCPP-173">#endif</front>
<front id="temperatureCPP-174"></front>
<front id="temperatureCPP-175">static float analog2temp(int raw, uint8_t e);</front>
<front id="temperatureCPP-176">static float analog2tempBed(int raw);</front>
<front id="temperatureCPP-177">static void updateTemperaturesFromRawValues();</front>
<front id="temperatureCPP-178"></front>
<front id="temperatureCPP-179">#if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureCPP-180">  int watch_target_temp[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-181">  millis_t watch_heater_next_ms[EXTRUDERS] = { 0 };</front>
<front id="temperatureCPP-182">#endif</front>
<front id="temperatureCPP-183"></front>
<front id="temperatureCPP-184">#ifndef SOFT_PWM_SCALE</front>
<front id="temperatureCPP-185">  #define SOFT_PWM_SCALE 0</front>
<front id="temperatureCPP-186">#endif</front>
<front id="temperatureCPP-187"></front>
<front id="temperatureCPP-188">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="temperatureCPP-189">  static int meas_shift_index;  //used to point to a delayed sample in buffer for filament width sensor</front>
<front id="temperatureCPP-190">#endif</front>
<front id="temperatureCPP-191"></front>
<front id="temperatureCPP-192">#if ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-193">  static int read_max6675();</front>
<front id="temperatureCPP-194">#endif</front>
<front id="temperatureCPP-195"></front>
<front id="temperatureCPP-196">//===========================================================================</front>
<front id="temperatureCPP-197">//================================ Functions ================================</front>
<front id="temperatureCPP-198">//===========================================================================</front>
<front id="temperatureCPP-199"></front>
<front id="temperatureCPP-200">void PID_autotune(float temp, int extruder, int ncycles) {</front>
<front id="temperatureCPP-201">  float input = 0.0;</front>
<front id="temperatureCPP-202">  int cycles = 0;</front>
<front id="temperatureCPP-203">  bool heating = true;</front>
<front id="temperatureCPP-204"></front>
<front id="temperatureCPP-205">  millis_t temp_ms = millis(), t1 = temp_ms, t2 = temp_ms;</front>
<front id="temperatureCPP-206">  long t_high = 0, t_low = 0;</front>
<front id="temperatureCPP-207"></front>
<front id="temperatureCPP-208">  long bias, d;</front>
<front id="temperatureCPP-209">  float Ku, Tu;</front>
<front id="temperatureCPP-210">  float Kp, Ki, Kd;</front>
<front id="temperatureCPP-211">  float max = 0, min = 10000;</front>
<front id="temperatureCPP-212"></front>
<front id="temperatureCPP-213">  #if HAS_AUTO_FAN</front>
<front id="temperatureCPP-214">    millis_t next_auto_fan_check_ms = temp_ms + 2500;</front>
<front id="temperatureCPP-215">  #endif</front>
<front id="temperatureCPP-216"></front>
<front id="temperatureCPP-217">  if (extruder &gt;= EXTRUDERS</front>
<front id="temperatureCPP-218">    #if !HAS_TEMP_BED</front>
<front id="temperatureCPP-219">       || extruder &lt; 0</front>
<front id="temperatureCPP-220">    #endif</front>
<front id="temperatureCPP-221">  ) {</front>
<front id="temperatureCPP-222">    SERIAL_ECHOLN(MSG_PID_BAD_EXTRUDER_NUM);</front>
<front id="temperatureCPP-223">    return;</front>
<front id="temperatureCPP-224">  }</front>
<front id="temperatureCPP-225">  </front>
<front id="temperatureCPP-226">  SERIAL_ECHOLN(MSG_PID_AUTOTUNE_START);</front>
<front id="temperatureCPP-227"></front>
<front id="temperatureCPP-228">  disable_all_heaters(); // switch off all heaters.</front>
<front id="temperatureCPP-229"></front>
<front id="temperatureCPP-230">  if (extruder &lt; 0)</front>
<front id="temperatureCPP-231">    soft_pwm_bed = bias = d = MAX_BED_POWER / 2;</front>
<front id="temperatureCPP-232">  else</front>
<front id="temperatureCPP-233">    soft_pwm[extruder] = bias = d = PID_MAX / 2;</front>
<front id="temperatureCPP-234"></front>
<front id="temperatureCPP-235">  // PID Tuning loop</front>
<front id="temperatureCPP-236">  for (;;) {</front>
<front id="temperatureCPP-237"></front>
<front id="temperatureCPP-238">    millis_t ms = millis();</front>
<front id="temperatureCPP-239"></front>
<front id="temperatureCPP-240">    if (temp_meas_ready) { // temp sample ready</front>
<front id="temperatureCPP-241">      updateTemperaturesFromRawValues();</front>
<front id="temperatureCPP-242"></front>
<front id="temperatureCPP-243">      input = (extruder&lt;0)?current_temperature_bed:current_temperature[extruder];</front>
<front id="temperatureCPP-244"></front>
<front id="temperatureCPP-245">      max = max(max, input);</front>
<front id="temperatureCPP-246">      min = min(min, input);</front>
<front id="temperatureCPP-247"></front>
<front id="temperatureCPP-248">      #if HAS_AUTO_FAN</front>
<front id="temperatureCPP-249">        if (ms &gt; next_auto_fan_check_ms) {</front>
<front id="temperatureCPP-250">          checkExtruderAutoFans();</front>
<front id="temperatureCPP-251">          next_auto_fan_check_ms = ms + 2500;</front>
<front id="temperatureCPP-252">        }</front>
<front id="temperatureCPP-253">      #endif</front>
<front id="temperatureCPP-254"></front>
<front id="temperatureCPP-255">      if (heating && input &gt; temp) {</front>
<front id="temperatureCPP-256">        if (ms &gt; t2 + 5000) {</front>
<front id="temperatureCPP-257">          heating = false;</front>
<front id="temperatureCPP-258">          if (extruder &lt; 0)</front>
<front id="temperatureCPP-259">            soft_pwm_bed = (bias - d) &gt;&gt; 1;</front>
<front id="temperatureCPP-260">          else</front>
<front id="temperatureCPP-261">            soft_pwm[extruder] = (bias - d) &gt;&gt; 1;</front>
<front id="temperatureCPP-262">          t1 = ms;</front>
<front id="temperatureCPP-263">          t_high = t1 - t2;</front>
<front id="temperatureCPP-264">          max = temp;</front>
<front id="temperatureCPP-265">        }</front>
<front id="temperatureCPP-266">      }</front>
<front id="temperatureCPP-267"></front>
<front id="temperatureCPP-268">      if (!heating && input &lt; temp) {</front>
<front id="temperatureCPP-269">        if (ms &gt; t1 + 5000) {</front>
<front id="temperatureCPP-270">          heating = true;</front>
<front id="temperatureCPP-271">          t2 = ms;</front>
<front id="temperatureCPP-272">          t_low = t2 - t1;</front>
<front id="temperatureCPP-273">          if (cycles &gt; 0) {</front>
<front id="temperatureCPP-274">            long max_pow = extruder &lt; 0 ? MAX_BED_POWER : PID_MAX;</front>
<front id="temperatureCPP-275">            bias += (d*(t_high - t_low))/(t_low + t_high);</front>
<front id="temperatureCPP-276">            bias = constrain(bias, 20, max_pow - 20);</front>
<front id="temperatureCPP-277">            d = (bias &gt; max_pow / 2) ? max_pow - 1 - bias : bias;</front>
<front id="temperatureCPP-278"></front>
<front id="temperatureCPP-279">            SERIAL_PROTOCOLPGM(MSG_BIAS); SERIAL_PROTOCOL(bias);</front>
<front id="temperatureCPP-280">            SERIAL_PROTOCOLPGM(MSG_D);    SERIAL_PROTOCOL(d);</front>
<front id="temperatureCPP-281">            SERIAL_PROTOCOLPGM(MSG_T_MIN);  SERIAL_PROTOCOL(min);</front>
<front id="temperatureCPP-282">            SERIAL_PROTOCOLPGM(MSG_T_MAX);  SERIAL_PROTOCOLLN(max);</front>
<front id="temperatureCPP-283">            if (cycles &gt; 2) {</front>
<front id="temperatureCPP-284">              Ku = (4.0 * d) / (3.14159265 * (max - min) / 2.0);</front>
<front id="temperatureCPP-285">              Tu = ((float)(t_low + t_high) / 1000.0);</front>
<front id="temperatureCPP-286">              SERIAL_PROTOCOLPGM(MSG_KU); SERIAL_PROTOCOL(Ku);</front>
<front id="temperatureCPP-287">              SERIAL_PROTOCOLPGM(MSG_TU); SERIAL_PROTOCOLLN(Tu);</front>
<front id="temperatureCPP-288">              Kp = 0.6 * Ku;</front>
<front id="temperatureCPP-289">              Ki = 2 * Kp / Tu;</front>
<front id="temperatureCPP-290">              Kd = Kp * Tu / 8;</front>
<front id="temperatureCPP-291">              SERIAL_PROTOCOLLNPGM(MSG_CLASSIC_PID);</front>
<front id="temperatureCPP-292">              SERIAL_PROTOCOLPGM(MSG_KP); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-293">              SERIAL_PROTOCOLPGM(MSG_KI); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-294">              SERIAL_PROTOCOLPGM(MSG_KD); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-295">              /*</front>
<front id="temperatureCPP-296">              Kp = 0.33*Ku;</front>
<front id="temperatureCPP-297">              Ki = Kp/Tu;</front>
<front id="temperatureCPP-298">              Kd = Kp*Tu/3;</front>
<front id="temperatureCPP-299">              SERIAL_PROTOCOLLNPGM(" Some overshoot ");</front>
<front id="temperatureCPP-300">              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-301">              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-302">              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-303">              Kp = 0.2*Ku;</front>
<front id="temperatureCPP-304">              Ki = 2*Kp/Tu;</front>
<front id="temperatureCPP-305">              Kd = Kp*Tu/3;</front>
<front id="temperatureCPP-306">              SERIAL_PROTOCOLLNPGM(" No overshoot ");</front>
<front id="temperatureCPP-307">              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-308">              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-309">              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-310">              */</front>
<front id="temperatureCPP-311">            }</front>
<front id="temperatureCPP-312">          }</front>
<front id="temperatureCPP-313">          if (extruder &lt; 0)</front>
<front id="temperatureCPP-314">            soft_pwm_bed = (bias + d) &gt;&gt; 1;</front>
<front id="temperatureCPP-315">          else</front>
<front id="temperatureCPP-316">            soft_pwm[extruder] = (bias + d) &gt;&gt; 1;</front>
<front id="temperatureCPP-317">          cycles++;</front>
<front id="temperatureCPP-318">          min = temp;</front>
<front id="temperatureCPP-319">        }</front>
<front id="temperatureCPP-320">      } </front>
<front id="temperatureCPP-321">    }</front>
<front id="temperatureCPP-322">    #define MAX_OVERSHOOT_PID_AUTOTUNE 20</front>
<front id="temperatureCPP-323">    if (input &gt; temp + MAX_OVERSHOOT_PID_AUTOTUNE) {</front>
<front id="temperatureCPP-324">      SERIAL_PROTOCOLLNPGM(MSG_PID_TEMP_TOO_HIGH);</front>
<front id="temperatureCPP-325">      return;</front>
<front id="temperatureCPP-326">    }</front>
<front id="temperatureCPP-327">    // Every 2 seconds...</front>
<front id="temperatureCPP-328">    if (ms &gt; temp_ms + 2000) {</front>
<front id="temperatureCPP-329">      int p;</front>
<front id="temperatureCPP-330">      if (extruder &lt; 0) {</front>
<front id="temperatureCPP-331">        p = soft_pwm_bed;</front>
<front id="temperatureCPP-332">        SERIAL_PROTOCOLPGM(MSG_B);</front>
<front id="temperatureCPP-333">      }</front>
<front id="temperatureCPP-334">      else {</front>
<front id="temperatureCPP-335">        p = soft_pwm[extruder];</front>
<front id="temperatureCPP-336">        SERIAL_PROTOCOLPGM(MSG_T);</front>
<front id="temperatureCPP-337">      }</front>
<front id="temperatureCPP-338"></front>
<front id="temperatureCPP-339">      SERIAL_PROTOCOL(input);</front>
<front id="temperatureCPP-340">      SERIAL_PROTOCOLPGM(MSG_AT);</front>
<front id="temperatureCPP-341">      SERIAL_PROTOCOLLN(p);</front>
<front id="temperatureCPP-342"></front>
<front id="temperatureCPP-343">      temp_ms = ms;</front>
<front id="temperatureCPP-344">    } // every 2 seconds</front>
<front id="temperatureCPP-345">    // Over 2 minutes?</front>
<front id="temperatureCPP-346">    if (((ms - t1) + (ms - t2)) &gt; (10L*60L*1000L*2L)) {</front>
<front id="temperatureCPP-347">      SERIAL_PROTOCOLLNPGM(MSG_PID_TIMEOUT);</front>
<front id="temperatureCPP-348">      return;</front>
<front id="temperatureCPP-349">    }</front>
<front id="temperatureCPP-350">    if (cycles &gt; ncycles) {</front>
<front id="temperatureCPP-351">      SERIAL_PROTOCOLLNPGM(MSG_PID_AUTOTUNE_FINISHED);</front>
<front id="temperatureCPP-352">      const char *estring = extruder &lt; 0 ? "bed" : "";</front>
<front id="temperatureCPP-353">      SERIAL_PROTOCOLPGM("#define  DEFAULT_"); SERIAL_PROTOCOL(estring); SERIAL_PROTOCOLPGM("Kp "); SERIAL_PROTOCOLLN(Kp);</front>
<front id="temperatureCPP-354">      SERIAL_PROTOCOLPGM("#define  DEFAULT_"); SERIAL_PROTOCOL(estring); SERIAL_PROTOCOLPGM("Ki "); SERIAL_PROTOCOLLN(Ki);</front>
<front id="temperatureCPP-355">      SERIAL_PROTOCOLPGM("#define  DEFAULT_"); SERIAL_PROTOCOL(estring); SERIAL_PROTOCOLPGM("Kd "); SERIAL_PROTOCOLLN(Kd);</front>
<front id="temperatureCPP-356">      return;</front>
<front id="temperatureCPP-357">    }</front>
<front id="temperatureCPP-358">    lcd_update();</front>
<front id="temperatureCPP-359">  }</front>
<front id="temperatureCPP-360">}</front>
<front id="temperatureCPP-361"></front>
<front id="temperatureCPP-362">void updatePID() {</front>
<front id="temperatureCPP-363">  #if ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-364">    for (int e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="temperatureCPP-365">      temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / PID_PARAM(Ki,e);</front>
<front id="temperatureCPP-366">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-367">        last_position[e] = 0;</front>
<front id="temperatureCPP-368">      #endif</front>
<front id="temperatureCPP-369">    }</front>
<front id="temperatureCPP-370">  #endif</front>
<front id="temperatureCPP-371">  #if ENABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-372">    temp_iState_max_bed = PID_BED_INTEGRAL_DRIVE_MAX / bedKi;</front>
<front id="temperatureCPP-373">  #endif</front>
<front id="temperatureCPP-374">}</front>
<front id="temperatureCPP-375"></front>
<front id="temperatureCPP-376">int getHeaterPower(int heater) {</front>
<front id="temperatureCPP-377">  return heater &lt; 0 ? soft_pwm_bed : soft_pwm[heater];</front>
<front id="temperatureCPP-378">}</front>
<front id="temperatureCPP-379"></front>
<front id="temperatureCPP-380">#if HAS_AUTO_FAN</front>
<front id="temperatureCPP-381"></front>
<front id="temperatureCPP-382">void setExtruderAutoFanState(int pin, bool state) {</front>
<front id="temperatureCPP-383">  unsigned char newFanSpeed = (state != 0) ? EXTRUDER_AUTO_FAN_SPEED : 0;</front>
<front id="temperatureCPP-384">  // this idiom allows both digital and PWM fan outputs (see M42 handling).</front>
<front id="temperatureCPP-385">  digitalWrite(pin, newFanSpeed);</front>
<front id="temperatureCPP-386">  analogWrite(pin, newFanSpeed);</front>
<front id="temperatureCPP-387">}</front>
<front id="temperatureCPP-388"></front>
<front id="temperatureCPP-389">void checkExtruderAutoFans() {</front>
<front id="temperatureCPP-390">  uint8_t fanState = 0;</front>
<front id="temperatureCPP-391"></front>
<front id="temperatureCPP-392">  // which fan pins need to be turned on?      </front>
<front id="temperatureCPP-393">  #if HAS_AUTO_FAN_0</front>
<front id="temperatureCPP-394">    if (current_temperature[0] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-395">      fanState |= 1;</front>
<front id="temperatureCPP-396">  #endif</front>
<front id="temperatureCPP-397">  #if HAS_AUTO_FAN_1</front>
<front id="temperatureCPP-398">    if (current_temperature[1] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-399">    {</front>
<front id="temperatureCPP-400">      if (EXTRUDER_1_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-401">        fanState |= 1;</front>
<front id="temperatureCPP-402">      else</front>
<front id="temperatureCPP-403">        fanState |= 2;</front>
<front id="temperatureCPP-404">    }</front>
<front id="temperatureCPP-405">  #endif</front>
<front id="temperatureCPP-406">  #if HAS_AUTO_FAN_2</front>
<front id="temperatureCPP-407">    if (current_temperature[2] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-408">    {</front>
<front id="temperatureCPP-409">      if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-410">        fanState |= 1;</front>
<front id="temperatureCPP-411">      else if (EXTRUDER_2_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-412">        fanState |= 2;</front>
<front id="temperatureCPP-413">      else</front>
<front id="temperatureCPP-414">        fanState |= 4;</front>
<front id="temperatureCPP-415">    }</front>
<front id="temperatureCPP-416">  #endif</front>
<front id="temperatureCPP-417">  #if HAS_AUTO_FAN_3</front>
<front id="temperatureCPP-418">    if (current_temperature[3] &gt; EXTRUDER_AUTO_FAN_TEMPERATURE) </front>
<front id="temperatureCPP-419">    {</front>
<front id="temperatureCPP-420">      if (EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_0_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-421">        fanState |= 1;</front>
<front id="temperatureCPP-422">      else if (EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_1_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-423">        fanState |= 2;</front>
<front id="temperatureCPP-424">      else if (EXTRUDER_3_AUTO_FAN_PIN == EXTRUDER_2_AUTO_FAN_PIN) </front>
<front id="temperatureCPP-425">        fanState |= 4;</front>
<front id="temperatureCPP-426">      else</front>
<front id="temperatureCPP-427">        fanState |= 8;</front>
<front id="temperatureCPP-428">    }</front>
<front id="temperatureCPP-429">  #endif</front>
<front id="temperatureCPP-430">  </front>
<front id="temperatureCPP-431">  // update extruder auto fan states</front>
<front id="temperatureCPP-432">  #if HAS_AUTO_FAN_0</front>
<front id="temperatureCPP-433">    setExtruderAutoFanState(EXTRUDER_0_AUTO_FAN_PIN, (fanState & 1) != 0);</front>
<front id="temperatureCPP-434">  #endif</front>
<front id="temperatureCPP-435">  #if HAS_AUTO_FAN_1</front>
<front id="temperatureCPP-436">    if (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-437">      setExtruderAutoFanState(EXTRUDER_1_AUTO_FAN_PIN, (fanState & 2) != 0);</front>
<front id="temperatureCPP-438">  #endif</front>
<front id="temperatureCPP-439">  #if HAS_AUTO_FAN_2</front>
<front id="temperatureCPP-440">    if (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN</front>
<front id="temperatureCPP-441">        && EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-442">      setExtruderAutoFanState(EXTRUDER_2_AUTO_FAN_PIN, (fanState & 4) != 0);</front>
<front id="temperatureCPP-443">  #endif</front>
<front id="temperatureCPP-444">  #if HAS_AUTO_FAN_3</front>
<front id="temperatureCPP-445">    if (EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN</front>
<front id="temperatureCPP-446">        && EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN</front>
<front id="temperatureCPP-447">        && EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_2_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-448">      setExtruderAutoFanState(EXTRUDER_3_AUTO_FAN_PIN, (fanState & 8) != 0);</front>
<front id="temperatureCPP-449">  #endif</front>
<front id="temperatureCPP-450">}</front>
<front id="temperatureCPP-451"></front>
<front id="temperatureCPP-452">#endif // HAS_AUTO_FAN</front>
<front id="temperatureCPP-453"></front>
<front id="temperatureCPP-454">//</front>
<front id="temperatureCPP-455">// Temperature Error Handlers</front>
<front id="temperatureCPP-456">//</front>
<front id="temperatureCPP-457">inline void _temp_error(int e, const char *serial_msg, const char *lcd_msg) {</front>
<front id="temperatureCPP-458">  static bool killed = false;</front>
<front id="temperatureCPP-459">  if (IsRunning()) {</front>
<front id="temperatureCPP-460">    SERIAL_ERROR_START;</front>
<front id="temperatureCPP-461">    serialprintPGM(serial_msg);</front>
<front id="temperatureCPP-462">    SERIAL_ERRORPGM(MSG_STOPPED_HEATER);</front>
<front id="temperatureCPP-463">    if (e &gt;= 0) SERIAL_ERRORLN((int)e); else SERIAL_ERRORLNPGM(MSG_HEATER_BED);</front>
<front id="temperatureCPP-464">  }</front>
<front id="temperatureCPP-465">  #if DISABLED(BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE)</front>
<front id="temperatureCPP-466">    if (!killed) {</front>
<front id="temperatureCPP-467">      Running = false;</front>
<front id="temperatureCPP-468">      killed = true;</front>
<front id="temperatureCPP-469">      kill(lcd_msg);</front>
<front id="temperatureCPP-470">    }</front>
<front id="temperatureCPP-471">    else</front>
<front id="temperatureCPP-472">      disable_all_heaters(); // paranoia</front>
<front id="temperatureCPP-473">  #endif</front>
<front id="temperatureCPP-474">}</front>
<front id="temperatureCPP-475"></front>
<front id="temperatureCPP-476">void max_temp_error(uint8_t e) {</front>
<front id="temperatureCPP-477">  _temp_error(e, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP));</front>
<front id="temperatureCPP-478">}</front>
<front id="temperatureCPP-479">void min_temp_error(uint8_t e) {</front>
<front id="temperatureCPP-480">  _temp_error(e, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP));</front>
<front id="temperatureCPP-481">}</front>
<front id="temperatureCPP-482"></front>
<front id="temperatureCPP-483">float get_pid_output(int e) {</front>
<front id="temperatureCPP-484">  float pid_output;</front>
<front id="temperatureCPP-485">  #if ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-486">    #if DISABLED(PID_OPENLOOP)</front>
<front id="temperatureCPP-487">      pid_error[e] = target_temperature[e] - current_temperature[e];</front>
<front id="temperatureCPP-488">      dTerm[e] = K2 * PID_PARAM(Kd,e) * (current_temperature[e] - temp_dState[e]) + K1 * dTerm[e];</front>
<front id="temperatureCPP-489">      temp_dState[e] = current_temperature[e];</front>
<front id="temperatureCPP-490">      if (pid_error[e] &gt; PID_FUNCTIONAL_RANGE) {</front>
<front id="temperatureCPP-491">        pid_output = BANG_MAX;</front>
<front id="temperatureCPP-492">        pid_reset[e] = true;</front>
<front id="temperatureCPP-493">      }</front>
<front id="temperatureCPP-494">      else if (pid_error[e] &lt; -PID_FUNCTIONAL_RANGE || target_temperature[e] == 0) {</front>
<front id="temperatureCPP-495">        pid_output = 0;</front>
<front id="temperatureCPP-496">        pid_reset[e] = true;</front>
<front id="temperatureCPP-497">      }</front>
<front id="temperatureCPP-498">      else {</front>
<front id="temperatureCPP-499">        if (pid_reset[e]) {</front>
<front id="temperatureCPP-500">          temp_iState[e] = 0.0;</front>
<front id="temperatureCPP-501">          pid_reset[e] = false;</front>
<front id="temperatureCPP-502">        }</front>
<front id="temperatureCPP-503">        pTerm[e] = PID_PARAM(Kp,e) * pid_error[e];</front>
<front id="temperatureCPP-504">        temp_iState[e] += pid_error[e];</front>
<front id="temperatureCPP-505">        temp_iState[e] = constrain(temp_iState[e], temp_iState_min[e], temp_iState_max[e]);</front>
<front id="temperatureCPP-506">        iTerm[e] = PID_PARAM(Ki,e) * temp_iState[e];</front>
<front id="temperatureCPP-507"></front>
<front id="temperatureCPP-508">        pid_output = pTerm[e] + iTerm[e] - dTerm[e];</front>
<front id="temperatureCPP-509"></front>
<front id="temperatureCPP-510">        #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-511">          cTerm[e] = 0;</front>
<front id="temperatureCPP-512">          if (e == active_extruder) {</front>
<front id="temperatureCPP-513">            long e_position = st_get_position(E_AXIS);</front>
<front id="temperatureCPP-514">            if (e_position &gt; last_position[e]) {</front>
<front id="temperatureCPP-515">              lpq[lpq_ptr++] = e_position - last_position[e];</front>
<front id="temperatureCPP-516">              last_position[e] = e_position;</front>
<front id="temperatureCPP-517">            } else {</front>
<front id="temperatureCPP-518">              lpq[lpq_ptr++] = 0;</front>
<front id="temperatureCPP-519">            }</front>
<front id="temperatureCPP-520">            if (lpq_ptr &gt;= lpq_len) lpq_ptr = 0;</front>
<front id="temperatureCPP-521">            cTerm[e] = (lpq[lpq_ptr] / axis_steps_per_unit[E_AXIS]) * Kc;</front>
<front id="temperatureCPP-522">            pid_output += cTerm[e];</front>
<front id="temperatureCPP-523">          }</front>
<front id="temperatureCPP-524">        #endif //PID_ADD_EXTRUSION_RATE</front>
<front id="temperatureCPP-525"></front>
<front id="temperatureCPP-526">        if (pid_output &gt; PID_MAX) {</front>
<front id="temperatureCPP-527">          if (pid_error[e] &gt; 0) temp_iState[e] -= pid_error[e]; // conditional un-integration</front>
<front id="temperatureCPP-528">          pid_output = PID_MAX;</front>
<front id="temperatureCPP-529">        }</front>
<front id="temperatureCPP-530">        else if (pid_output &lt; 0) {</front>
<front id="temperatureCPP-531">          if (pid_error[e] &lt; 0) temp_iState[e] -= pid_error[e]; // conditional un-integration</front>
<front id="temperatureCPP-532">          pid_output = 0;</front>
<front id="temperatureCPP-533">        }</front>
<front id="temperatureCPP-534">      }</front>
<front id="temperatureCPP-535">    #else</front>
<front id="temperatureCPP-536">      pid_output = constrain(target_temperature[e], 0, PID_MAX);</front>
<front id="temperatureCPP-537">    #endif //PID_OPENLOOP</front>
<front id="temperatureCPP-538"></front>
<front id="temperatureCPP-539">    #if ENABLED(PID_DEBUG)</front>
<front id="temperatureCPP-540">      SERIAL_ECHO_START;</front>
<front id="temperatureCPP-541">      SERIAL_ECHOPAIR(MSG_PID_DEBUG, e);</front>
<front id="temperatureCPP-542">      SERIAL_ECHOPAIR(MSG_PID_DEBUG_INPUT, current_temperature[e]);</front>
<front id="temperatureCPP-543">      SERIAL_ECHOPAIR(MSG_PID_DEBUG_OUTPUT, pid_output);</front>
<front id="temperatureCPP-544">      SERIAL_ECHOPAIR(MSG_PID_DEBUG_PTERM, pTerm[e]);</front>
<front id="temperatureCPP-545">      SERIAL_ECHOPAIR(MSG_PID_DEBUG_ITERM, iTerm[e]);</front>
<front id="temperatureCPP-546">      SERIAL_ECHOPAIR(MSG_PID_DEBUG_DTERM, dTerm[e]);</front>
<front id="temperatureCPP-547">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-548">        SERIAL_ECHOPAIR(MSG_PID_DEBUG_CTERM, cTerm[e]);</front>
<front id="temperatureCPP-549">      #endif</front>
<front id="temperatureCPP-550">      SERIAL_EOL;</front>
<front id="temperatureCPP-551">    #endif //PID_DEBUG</front>
<front id="temperatureCPP-552"></front>
<front id="temperatureCPP-553">  #else /* PID off */</front>
<front id="temperatureCPP-554">    pid_output = (current_temperature[e] &lt; target_temperature[e]) ? PID_MAX : 0;</front>
<front id="temperatureCPP-555">  #endif</front>
<front id="temperatureCPP-556"></front>
<front id="temperatureCPP-557">  return pid_output;</front>
<front id="temperatureCPP-558">}</front>
<front id="temperatureCPP-559"></front>
<front id="temperatureCPP-560">#if ENABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-561">  float get_pid_output_bed() {</front>
<front id="temperatureCPP-562">    float pid_output;</front>
<front id="temperatureCPP-563">    #if DISABLED(PID_OPENLOOP)</front>
<front id="temperatureCPP-564">      pid_error_bed = target_temperature_bed - current_temperature_bed;</front>
<front id="temperatureCPP-565">      pTerm_bed = bedKp * pid_error_bed;</front>
<front id="temperatureCPP-566">      temp_iState_bed += pid_error_bed;</front>
<front id="temperatureCPP-567">      temp_iState_bed = constrain(temp_iState_bed, temp_iState_min_bed, temp_iState_max_bed);</front>
<front id="temperatureCPP-568">      iTerm_bed = bedKi * temp_iState_bed;</front>
<front id="temperatureCPP-569"></front>
<front id="temperatureCPP-570">      dTerm_bed = K2 * bedKd * (current_temperature_bed - temp_dState_bed) + K1 * dTerm_bed;</front>
<front id="temperatureCPP-571">      temp_dState_bed = current_temperature_bed;</front>
<front id="temperatureCPP-572"></front>
<front id="temperatureCPP-573">      pid_output = pTerm_bed + iTerm_bed - dTerm_bed;</front>
<front id="temperatureCPP-574">      if (pid_output &gt; MAX_BED_POWER) {</front>
<front id="temperatureCPP-575">        if (pid_error_bed &gt; 0) temp_iState_bed -= pid_error_bed; // conditional un-integration</front>
<front id="temperatureCPP-576">        pid_output = MAX_BED_POWER;</front>
<front id="temperatureCPP-577">      }</front>
<front id="temperatureCPP-578">      else if (pid_output &lt; 0) {</front>
<front id="temperatureCPP-579">        if (pid_error_bed &lt; 0) temp_iState_bed -= pid_error_bed; // conditional un-integration</front>
<front id="temperatureCPP-580">        pid_output = 0;</front>
<front id="temperatureCPP-581">      }</front>
<front id="temperatureCPP-582">    #else</front>
<front id="temperatureCPP-583">      pid_output = constrain(target_temperature_bed, 0, MAX_BED_POWER);</front>
<front id="temperatureCPP-584">    #endif // PID_OPENLOOP</front>
<front id="temperatureCPP-585"></front>
<front id="temperatureCPP-586">    #if ENABLED(PID_BED_DEBUG)</front>
<front id="temperatureCPP-587">      SERIAL_ECHO_START;</front>
<front id="temperatureCPP-588">      SERIAL_ECHO(" PID_BED_DEBUG ");</front>
<front id="temperatureCPP-589">      SERIAL_ECHO(": Input ");</front>
<front id="temperatureCPP-590">      SERIAL_ECHO(current_temperature_bed);</front>
<front id="temperatureCPP-591">      SERIAL_ECHO(" Output ");</front>
<front id="temperatureCPP-592">      SERIAL_ECHO(pid_output);</front>
<front id="temperatureCPP-593">      SERIAL_ECHO(" pTerm ");</front>
<front id="temperatureCPP-594">      SERIAL_ECHO(pTerm_bed);</front>
<front id="temperatureCPP-595">      SERIAL_ECHO(" iTerm ");</front>
<front id="temperatureCPP-596">      SERIAL_ECHO(iTerm_bed);</front>
<front id="temperatureCPP-597">      SERIAL_ECHO(" dTerm ");</front>
<front id="temperatureCPP-598">      SERIAL_ECHOLN(dTerm_bed);</front>
<front id="temperatureCPP-599">    #endif //PID_BED_DEBUG</front>
<front id="temperatureCPP-600"></front>
<front id="temperatureCPP-601">    return pid_output;</front>
<front id="temperatureCPP-602">  }</front>
<front id="temperatureCPP-603">#endif</front>
<front id="temperatureCPP-604"></front>
<front id="temperatureCPP-605">/**</front>
<front id="temperatureCPP-606"> * Manage heating activities for extruder hot-ends and a heated bed</front>
<front id="temperatureCPP-607"> *  - Acquire updated temperature readings</front>
<front id="temperatureCPP-608"> *  - Invoke thermal runaway protection</front>
<front id="temperatureCPP-609"> *  - Manage extruder auto-fan</front>
<front id="temperatureCPP-610"> *  - Apply filament width to the extrusion rate (may move)</front>
<front id="temperatureCPP-611"> *  - Update the heated bed PID output value</front>
<front id="temperatureCPP-612"> */</front>
<front id="temperatureCPP-613">void manage_heater() {</front>
<front id="temperatureCPP-614"></front>
<front id="temperatureCPP-615">  if (!temp_meas_ready) return;</front>
<front id="temperatureCPP-616"></front>
<front id="temperatureCPP-617">  updateTemperaturesFromRawValues();</front>
<front id="temperatureCPP-618"></front>
<front id="temperatureCPP-619">  #if ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-620">    float ct = current_temperature[0];</front>
<front id="temperatureCPP-621">    if (ct &gt; min(HEATER_0_MAXTEMP, 1023)) max_temp_error(0);</front>
<front id="temperatureCPP-622">    if (ct &lt; max(HEATER_0_MINTEMP, 0.01)) min_temp_error(0);</front>
<front id="temperatureCPP-623">  #endif</front>
<front id="temperatureCPP-624"></front>
<front id="temperatureCPP-625">  #if ENABLED(THERMAL_PROTECTION_HOTENDS) || DISABLED(PIDTEMPBED) || HAS_AUTO_FAN</front>
<front id="temperatureCPP-626">    millis_t ms = millis();</front>
<front id="temperatureCPP-627">  #endif</front>
<front id="temperatureCPP-628"></front>
<front id="temperatureCPP-629">  // Loop through all extruders</front>
<front id="temperatureCPP-630">  for (int e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="temperatureCPP-631"></front>
<front id="temperatureCPP-632">    #if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureCPP-633">      thermal_runaway_protection(&thermal_runaway_state_machine[e], &thermal_runaway_timer[e], current_temperature[e], target_temperature[e], e, THERMAL_PROTECTION_PERIOD, THERMAL_PROTECTION_HYSTERESIS);</front>
<front id="temperatureCPP-634">    #endif</front>
<front id="temperatureCPP-635"></front>
<front id="temperatureCPP-636">    float pid_output = get_pid_output(e);</front>
<front id="temperatureCPP-637"></front>
<front id="temperatureCPP-638">    // Check if temperature is within the correct range</front>
<front id="temperatureCPP-639">    soft_pwm[e] = current_temperature[e] &gt; minttemp[e] && current_temperature[e] &lt; maxttemp[e] ? (int)pid_output &gt;&gt; 1 : 0;</front>
<front id="temperatureCPP-640"></front>
<front id="temperatureCPP-641">    // Check if the temperature is failing to increase</front>
<front id="temperatureCPP-642">    #if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureCPP-643"></front>
<front id="temperatureCPP-644">      // Is it time to check this extruder's heater?</front>
<front id="temperatureCPP-645">      if (watch_heater_next_ms[e] && ms &gt; watch_heater_next_ms[e]) {</front>
<front id="temperatureCPP-646">        // Has it failed to increase enough?</front>
<front id="temperatureCPP-647">        if (degHotend(e) &lt; watch_target_temp[e]) {</front>
<front id="temperatureCPP-648">          // Stop!</front>
<front id="temperatureCPP-649">          _temp_error(e, PSTR(MSG_T_HEATING_FAILED), PSTR(MSG_HEATING_FAILED_LCD));</front>
<front id="temperatureCPP-650">        }</front>
<front id="temperatureCPP-651">        else {</front>
<front id="temperatureCPP-652">          // Start again if the target is still far off</front>
<front id="temperatureCPP-653">          start_watching_heater(e);</front>
<front id="temperatureCPP-654">        }</front>
<front id="temperatureCPP-655">      }</front>
<front id="temperatureCPP-656"></front>
<front id="temperatureCPP-657">    #endif // THERMAL_PROTECTION_HOTENDS</front>
<front id="temperatureCPP-658"></front>
<front id="temperatureCPP-659">    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureCPP-660">      if (fabs(current_temperature[0] - redundant_temperature) &gt; MAX_REDUNDANT_TEMP_SENSOR_DIFF) {</front>
<front id="temperatureCPP-661">        _temp_error(0, PSTR(MSG_EXTRUDER_SWITCHED_OFF), PSTR(MSG_ERR_REDUNDANT_TEMP));</front>
<front id="temperatureCPP-662">      }</front>
<front id="temperatureCPP-663">    #endif</front>
<front id="temperatureCPP-664"></front>
<front id="temperatureCPP-665">  } // Extruders Loop</front>
<front id="temperatureCPP-666"></front>
<front id="temperatureCPP-667">  #if HAS_AUTO_FAN</front>
<front id="temperatureCPP-668">    if (ms &gt; next_auto_fan_check_ms) { // only need to check fan state very infrequently</front>
<front id="temperatureCPP-669">      checkExtruderAutoFans();</front>
<front id="temperatureCPP-670">      next_auto_fan_check_ms = ms + 2500;</front>
<front id="temperatureCPP-671">    }</front>
<front id="temperatureCPP-672">  #endif       </front>
<front id="temperatureCPP-673"></front>
<front id="temperatureCPP-674">  // Control the extruder rate based on the width sensor</front>
<front id="temperatureCPP-675">  #if ENABLED(FILAMENT_SENSOR)</front>
<front id="temperatureCPP-676">    if (filament_sensor) {</front>
<front id="temperatureCPP-677">      meas_shift_index = delay_index1 - meas_delay_cm;</front>
<front id="temperatureCPP-678">      if (meas_shift_index &lt; 0) meas_shift_index += MAX_MEASUREMENT_DELAY + 1;  //loop around buffer if needed</front>
<front id="temperatureCPP-679">      </front>
<front id="temperatureCPP-680">      // Get the delayed info and add 100 to reconstitute to a percent of</front>
<front id="temperatureCPP-681">      // the nominal filament diameter then square it to get an area</front>
<front id="temperatureCPP-682">      meas_shift_index = constrain(meas_shift_index, 0, MAX_MEASUREMENT_DELAY);</front>
<front id="temperatureCPP-683">      float vm = pow((measurement_delay[meas_shift_index] + 100.0) / 100.0, 2);</front>
<front id="temperatureCPP-684">      if (vm &lt; 0.01) vm = 0.01;</front>
<front id="temperatureCPP-685">      volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM] = vm;</front>
<front id="temperatureCPP-686">    }</front>
<front id="temperatureCPP-687">  #endif //FILAMENT_SENSOR</front>
<front id="temperatureCPP-688"></front>
<front id="temperatureCPP-689">  #if DISABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-690">    if (ms &lt; next_bed_check_ms) return;</front>
<front id="temperatureCPP-691">    next_bed_check_ms = ms + BED_CHECK_INTERVAL;</front>
<front id="temperatureCPP-692">  #endif</front>
<front id="temperatureCPP-693"></front>
<front id="temperatureCPP-694">  #if TEMP_SENSOR_BED != 0</front>
<front id="temperatureCPP-695">  </front>
<front id="temperatureCPP-696">    #if ENABLED(THERMAL_PROTECTION_BED)</front>
<front id="temperatureCPP-697">      thermal_runaway_protection(&thermal_runaway_bed_state_machine, &thermal_runaway_bed_timer, current_temperature_bed, target_temperature_bed, -1, THERMAL_PROTECTION_BED_PERIOD, THERMAL_PROTECTION_BED_HYSTERESIS);</front>
<front id="temperatureCPP-698">    #endif</front>
<front id="temperatureCPP-699"></front>
<front id="temperatureCPP-700">    #if ENABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-701">      float pid_output = get_pid_output_bed();</front>
<front id="temperatureCPP-702"></front>
<front id="temperatureCPP-703">      soft_pwm_bed = current_temperature_bed &gt; BED_MINTEMP && current_temperature_bed &lt; BED_MAXTEMP ? (int)pid_output &gt;&gt; 1 : 0;</front>
<front id="temperatureCPP-704"></front>
<front id="temperatureCPP-705">    #elif ENABLED(BED_LIMIT_SWITCHING)</front>
<front id="temperatureCPP-706">      // Check if temperature is within the correct band</front>
<front id="temperatureCPP-707">      if (current_temperature_bed &gt; BED_MINTEMP && current_temperature_bed &lt; BED_MAXTEMP) {</front>
<front id="temperatureCPP-708">        if (current_temperature_bed &gt;= target_temperature_bed + BED_HYSTERESIS)</front>
<front id="temperatureCPP-709">          soft_pwm_bed = 0;</front>
<front id="temperatureCPP-710">        else if (current_temperature_bed &lt;= target_temperature_bed - BED_HYSTERESIS)</front>
<front id="temperatureCPP-711">          soft_pwm_bed = MAX_BED_POWER &gt;&gt; 1;</front>
<front id="temperatureCPP-712">      }</front>
<front id="temperatureCPP-713">      else {</front>
<front id="temperatureCPP-714">        soft_pwm_bed = 0;</front>
<front id="temperatureCPP-715">        WRITE_HEATER_BED(LOW);</front>
<front id="temperatureCPP-716">      }</front>
<front id="temperatureCPP-717">    #else // BED_LIMIT_SWITCHING</front>
<front id="temperatureCPP-718">      // Check if temperature is within the correct range</front>
<front id="temperatureCPP-719">      if (current_temperature_bed &gt; BED_MINTEMP && current_temperature_bed &lt; BED_MAXTEMP) {</front>
<front id="temperatureCPP-720">        soft_pwm_bed = current_temperature_bed &lt; target_temperature_bed ? MAX_BED_POWER &gt;&gt; 1 : 0;</front>
<front id="temperatureCPP-721">      }</front>
<front id="temperatureCPP-722">      else {</front>
<front id="temperatureCPP-723">        soft_pwm_bed = 0;</front>
<front id="temperatureCPP-724">        WRITE_HEATER_BED(LOW);</front>
<front id="temperatureCPP-725">      }</front>
<front id="temperatureCPP-726">    #endif</front>
<front id="temperatureCPP-727">  #endif //TEMP_SENSOR_BED != 0</front>
<front id="temperatureCPP-728">}</front>
<front id="temperatureCPP-729"></front>
<front id="temperatureCPP-730">#define PGM_RD_W(x)   (short)pgm_read_word(&x)</front>
<front id="temperatureCPP-731">// Derived from RepRap FiveD extruder::getTemperature()</front>
<front id="temperatureCPP-732">// For hot end temperature measurement.</front>
<front id="temperatureCPP-733">static float analog2temp(int raw, uint8_t e) {</front>
<front id="temperatureCPP-734">  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureCPP-735">    if (e &gt; EXTRUDERS)</front>
<front id="temperatureCPP-736">  #else</front>
<front id="temperatureCPP-737">    if (e &gt;= EXTRUDERS)</front>
<front id="temperatureCPP-738">  #endif</front>
<front id="temperatureCPP-739">    {</front>
<front id="temperatureCPP-740">      SERIAL_ERROR_START;</front>
<front id="temperatureCPP-741">      SERIAL_ERROR((int)e);</front>
<front id="temperatureCPP-742">      SERIAL_ERRORLNPGM(MSG_INVALID_EXTRUDER_NUM);</front>
<front id="temperatureCPP-743">      kill(PSTR(MSG_KILLED));</front>
<front id="temperatureCPP-744">      return 0.0;</front>
<front id="temperatureCPP-745">    } </front>
<front id="temperatureCPP-746"></front>
<front id="temperatureCPP-747">  #if ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-748">    if (e == 0) return 0.25 * raw;</front>
<front id="temperatureCPP-749">  #endif</front>
<front id="temperatureCPP-750"></front>
<front id="temperatureCPP-751">  if (heater_ttbl_map[e] != NULL) {</front>
<front id="temperatureCPP-752">    float celsius = 0;</front>
<front id="temperatureCPP-753">    uint8_t i;</front>
<front id="temperatureCPP-754">    short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);</front>
<front id="temperatureCPP-755"></front>
<front id="temperatureCPP-756">    for (i = 1; i &lt; heater_ttbllen_map[e]; i++) {</front>
<front id="temperatureCPP-757">      if (PGM_RD_W((*tt)[i][0]) &gt; raw) {</front>
<front id="temperatureCPP-758">        celsius = PGM_RD_W((*tt)[i-1][1]) + </front>
<front id="temperatureCPP-759">          (raw - PGM_RD_W((*tt)[i-1][0])) * </front>
<front id="temperatureCPP-760">          (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1])) /</front>
<front id="temperatureCPP-761">          (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0]));</front>
<front id="temperatureCPP-762">        break;</front>
<front id="temperatureCPP-763">      }</front>
<front id="temperatureCPP-764">    }</front>
<front id="temperatureCPP-765"></front>
<front id="temperatureCPP-766">    // Overflow: Set to last value in the table</front>
<front id="temperatureCPP-767">    if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i-1][1]);</front>
<front id="temperatureCPP-768"></front>
<front id="temperatureCPP-769">    return celsius;</front>
<front id="temperatureCPP-770">  }</front>
<front id="temperatureCPP-771">  return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;</front>
<front id="temperatureCPP-772">}</front>
<front id="temperatureCPP-773"></front>
<front id="temperatureCPP-774">// Derived from RepRap FiveD extruder::getTemperature()</front>
<front id="temperatureCPP-775">// For bed temperature measurement.</front>
<front id="temperatureCPP-776">static float analog2tempBed(int raw) {</front>
<front id="temperatureCPP-777">  #if ENABLED(BED_USES_THERMISTOR)</front>
<front id="temperatureCPP-778">    float celsius = 0;</front>
<front id="temperatureCPP-779">    byte i;</front>
<front id="temperatureCPP-780"></front>
<front id="temperatureCPP-781">    for (i = 1; i &lt; BEDTEMPTABLE_LEN; i++) {</front>
<front id="temperatureCPP-782">      if (PGM_RD_W(BEDTEMPTABLE[i][0]) &gt; raw) {</front>
<front id="temperatureCPP-783">        celsius  = PGM_RD_W(BEDTEMPTABLE[i-1][1]) + </front>
<front id="temperatureCPP-784">          (raw - PGM_RD_W(BEDTEMPTABLE[i-1][0])) * </front>
<front id="temperatureCPP-785">          (float)(PGM_RD_W(BEDTEMPTABLE[i][1]) - PGM_RD_W(BEDTEMPTABLE[i-1][1])) /</front>
<front id="temperatureCPP-786">          (float)(PGM_RD_W(BEDTEMPTABLE[i][0]) - PGM_RD_W(BEDTEMPTABLE[i-1][0]));</front>
<front id="temperatureCPP-787">        break;</front>
<front id="temperatureCPP-788">      }</front>
<front id="temperatureCPP-789">    }</front>
<front id="temperatureCPP-790"></front>
<front id="temperatureCPP-791">    // Overflow: Set to last value in the table</front>
<front id="temperatureCPP-792">    if (i == BEDTEMPTABLE_LEN) celsius = PGM_RD_W(BEDTEMPTABLE[i-1][1]);</front>
<front id="temperatureCPP-793"></front>
<front id="temperatureCPP-794">    return celsius;</front>
<front id="temperatureCPP-795">  #elif defined BED_USES_AD595</front>
<front id="temperatureCPP-796">    return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;</front>
<front id="temperatureCPP-797">  #else</front>
<front id="temperatureCPP-798">    return 0;</front>
<front id="temperatureCPP-799">  #endif</front>
<front id="temperatureCPP-800">}</front>
<front id="temperatureCPP-801"></front>
<front id="temperatureCPP-802">/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,</front>
<front id="temperatureCPP-803">    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */</front>
<front id="temperatureCPP-804">static void updateTemperaturesFromRawValues() {</front>
<front id="temperatureCPP-805">  #if ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-806">    current_temperature_raw[0] = read_max6675();</front>
<front id="temperatureCPP-807">  #endif</front>
<front id="temperatureCPP-808">  for (uint8_t e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="temperatureCPP-809">    current_temperature[e] = analog2temp(current_temperature_raw[e], e);</front>
<front id="temperatureCPP-810">  }</front>
<front id="temperatureCPP-811">  current_temperature_bed = analog2tempBed(current_temperature_bed_raw);</front>
<front id="temperatureCPP-812">  #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureCPP-813">    redundant_temperature = analog2temp(redundant_temperature_raw, 1);</front>
<front id="temperatureCPP-814">  #endif</front>
<front id="temperatureCPP-815">  #if HAS_FILAMENT_SENSOR</front>
<front id="temperatureCPP-816">    filament_width_meas = analog2widthFil();</front>
<front id="temperatureCPP-817">  #endif</front>
<front id="temperatureCPP-818">  //Reset the watchdog after we know we have a temperature measurement.</front>
<front id="temperatureCPP-819">  watchdog_reset();</front>
<front id="temperatureCPP-820"></front>
<front id="temperatureCPP-821">  CRITICAL_SECTION_START;</front>
<front id="temperatureCPP-822">  temp_meas_ready = false;</front>
<front id="temperatureCPP-823">  CRITICAL_SECTION_END;</front>
<front id="temperatureCPP-824">}</front>
<front id="temperatureCPP-825"></front>
<front id="temperatureCPP-826"></front>
<front id="temperatureCPP-827">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="temperatureCPP-828"></front>
<front id="temperatureCPP-829">  // Convert raw Filament Width to millimeters</front>
<front id="temperatureCPP-830">  float analog2widthFil() {</front>
<front id="temperatureCPP-831">    return current_raw_filwidth / 16383.0 * 5.0;</front>
<front id="temperatureCPP-832">    //return current_raw_filwidth;</front>
<front id="temperatureCPP-833">  }</front>
<front id="temperatureCPP-834"></front>
<front id="temperatureCPP-835">  // Convert raw Filament Width to a ratio</front>
<front id="temperatureCPP-836">  int widthFil_to_size_ratio() {</front>
<front id="temperatureCPP-837">    float temp = filament_width_meas;</front>
<front id="temperatureCPP-838">    if (temp &lt; MEASURED_LOWER_LIMIT) temp = filament_width_nominal;  //assume sensor cut out</front>
<front id="temperatureCPP-839">    else if (temp &gt; MEASURED_UPPER_LIMIT) temp = MEASURED_UPPER_LIMIT;</front>
<front id="temperatureCPP-840">    return filament_width_nominal / temp * 100;</front>
<front id="temperatureCPP-841">  } </front>
<front id="temperatureCPP-842"></front>
<front id="temperatureCPP-843">#endif</front>
<front id="temperatureCPP-844"></front>
<front id="temperatureCPP-845"></front>
<front id="temperatureCPP-846">/**</front>
<front id="temperatureCPP-847"> * Initialize the temperature manager</front>
<front id="temperatureCPP-848"> * The manager is implemented by periodic calls to manage_heater()</front>
<front id="temperatureCPP-849"> */</front>
<front id="temperatureCPP-850">void tp_init() {</front>
<front id="temperatureCPP-851">  #if MB(RUMBA) && ((TEMP_SENSOR_0==-1)||(TEMP_SENSOR_1==-1)||(TEMP_SENSOR_2==-1)||(TEMP_SENSOR_BED==-1))</front>
<front id="temperatureCPP-852">    //disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector</front>
<front id="temperatureCPP-853">    MCUCR=BIT(JTD);</front>
<front id="temperatureCPP-854">    MCUCR=BIT(JTD);</front>
<front id="temperatureCPP-855">  #endif</front>
<front id="temperatureCPP-856">  </front>
<front id="temperatureCPP-857">  // Finish init of mult extruder arrays </front>
<front id="temperatureCPP-858">  for (int e = 0; e &lt; EXTRUDERS; e++) {</front>
<front id="temperatureCPP-859">    // populate with the first value </front>
<front id="temperatureCPP-860">    maxttemp[e] = maxttemp[0];</front>
<front id="temperatureCPP-861">    #if ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-862">      temp_iState_min[e] = 0.0;</front>
<front id="temperatureCPP-863">      temp_iState_max[e] = PID_INTEGRAL_DRIVE_MAX / PID_PARAM(Ki,e);</front>
<front id="temperatureCPP-864">      #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureCPP-865">        last_position[e] = 0;</front>
<front id="temperatureCPP-866">      #endif</front>
<front id="temperatureCPP-867">    #endif //PIDTEMP</front>
<front id="temperatureCPP-868">    #if ENABLED(PIDTEMPBED)</front>
<front id="temperatureCPP-869">      temp_iState_min_bed = 0.0;</front>
<front id="temperatureCPP-870">      temp_iState_max_bed = PID_BED_INTEGRAL_DRIVE_MAX / bedKi;</front>
<front id="temperatureCPP-871">    #endif //PIDTEMPBED</front>
<front id="temperatureCPP-872">  }</front>
<front id="temperatureCPP-873"></front>
<front id="temperatureCPP-874">  #if HAS_HEATER_0</front>
<front id="temperatureCPP-875">    SET_OUTPUT(HEATER_0_PIN);</front>
<front id="temperatureCPP-876">  #endif</front>
<front id="temperatureCPP-877">  #if HAS_HEATER_1</front>
<front id="temperatureCPP-878">    SET_OUTPUT(HEATER_1_PIN);</front>
<front id="temperatureCPP-879">  #endif</front>
<front id="temperatureCPP-880">  #if HAS_HEATER_2</front>
<front id="temperatureCPP-881">    SET_OUTPUT(HEATER_2_PIN);</front>
<front id="temperatureCPP-882">  #endif</front>
<front id="temperatureCPP-883">  #if HAS_HEATER_3</front>
<front id="temperatureCPP-884">    SET_OUTPUT(HEATER_3_PIN);</front>
<front id="temperatureCPP-885">  #endif</front>
<front id="temperatureCPP-886">  #if HAS_HEATER_BED</front>
<front id="temperatureCPP-887">    SET_OUTPUT(HEATER_BED_PIN);</front>
<front id="temperatureCPP-888">  #endif  </front>
<front id="temperatureCPP-889">  #if HAS_FAN</front>
<front id="temperatureCPP-890">    SET_OUTPUT(FAN_PIN);</front>
<front id="temperatureCPP-891">    #if ENABLED(FAST_PWM_FAN)</front>
<front id="temperatureCPP-892">      setPwmFrequency(FAN_PIN, 1); // No prescaling. Pwm frequency = F_CPU/256/8</front>
<front id="temperatureCPP-893">    #endif</front>
<front id="temperatureCPP-894">    #if ENABLED(FAN_SOFT_PWM)</front>
<front id="temperatureCPP-895">      soft_pwm_fan = fanSpeedSoftPwm / 2;</front>
<front id="temperatureCPP-896">    #endif</front>
<front id="temperatureCPP-897">  #endif</front>
<front id="temperatureCPP-898"></front>
<front id="temperatureCPP-899">  #if ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-900"></front>
<front id="temperatureCPP-901">    #if DISABLED(SDSUPPORT)</front>
<front id="temperatureCPP-902">      OUT_WRITE(SCK_PIN, LOW);</front>
<front id="temperatureCPP-903">      OUT_WRITE(MOSI_PIN, HIGH);</front>
<front id="temperatureCPP-904">      OUT_WRITE(MISO_PIN, HIGH);</front>
<front id="temperatureCPP-905">    #else</front>
<front id="temperatureCPP-906">      pinMode(SS_PIN, OUTPUT);</front>
<front id="temperatureCPP-907">      digitalWrite(SS_PIN, HIGH);</front>
<front id="temperatureCPP-908">    #endif</front>
<front id="temperatureCPP-909">    </front>
<front id="temperatureCPP-910">    OUT_WRITE(MAX6675_SS,HIGH);</front>
<front id="temperatureCPP-911"></front>
<front id="temperatureCPP-912">  #endif //HEATER_0_USES_MAX6675</front>
<front id="temperatureCPP-913"></front>
<front id="temperatureCPP-914">  #ifdef DIDR2</front>
<front id="temperatureCPP-915">    #define ANALOG_SELECT(pin) do{ if (pin &lt; 8) DIDR0 |= BIT(pin); else DIDR2 |= BIT(pin - 8); }while(0)</front>
<front id="temperatureCPP-916">  #else</front>
<front id="temperatureCPP-917">    #define ANALOG_SELECT(pin) do{ DIDR0 |= BIT(pin); }while(0)</front>
<front id="temperatureCPP-918">  #endif</front>
<front id="temperatureCPP-919"></front>
<front id="temperatureCPP-920">  // Set analog inputs</front>
<front id="temperatureCPP-921">  ADCSRA = BIT(ADEN) | BIT(ADSC) | BIT(ADIF) | 0x07;</front>
<front id="temperatureCPP-922">  DIDR0 = 0;</front>
<front id="temperatureCPP-923">  #ifdef DIDR2</front>
<front id="temperatureCPP-924">    DIDR2 = 0;</front>
<front id="temperatureCPP-925">  #endif</front>
<front id="temperatureCPP-926">  #if HAS_TEMP_0</front>
<front id="temperatureCPP-927">    ANALOG_SELECT(TEMP_0_PIN);</front>
<front id="temperatureCPP-928">  #endif</front>
<front id="temperatureCPP-929">  #if HAS_TEMP_1</front>
<front id="temperatureCPP-930">    ANALOG_SELECT(TEMP_1_PIN);</front>
<front id="temperatureCPP-931">  #endif</front>
<front id="temperatureCPP-932">  #if HAS_TEMP_2</front>
<front id="temperatureCPP-933">    ANALOG_SELECT(TEMP_2_PIN);</front>
<front id="temperatureCPP-934">  #endif</front>
<front id="temperatureCPP-935">  #if HAS_TEMP_3</front>
<front id="temperatureCPP-936">    ANALOG_SELECT(TEMP_3_PIN);</front>
<front id="temperatureCPP-937">  #endif</front>
<front id="temperatureCPP-938">  #if HAS_TEMP_BED</front>
<front id="temperatureCPP-939">    ANALOG_SELECT(TEMP_BED_PIN);</front>
<front id="temperatureCPP-940">  #endif</front>
<front id="temperatureCPP-941">  #if HAS_FILAMENT_SENSOR</front>
<front id="temperatureCPP-942">    ANALOG_SELECT(FILWIDTH_PIN);</front>
<front id="temperatureCPP-943">  #endif</front>
<front id="temperatureCPP-944"></front>
<front id="temperatureCPP-945">  #if HAS_AUTO_FAN_0</front>
<front id="temperatureCPP-946">    pinMode(EXTRUDER_0_AUTO_FAN_PIN, OUTPUT);</front>
<front id="temperatureCPP-947">  #endif</front>
<front id="temperatureCPP-948">  #if HAS_AUTO_FAN_1 && (EXTRUDER_1_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-949">    pinMode(EXTRUDER_1_AUTO_FAN_PIN, OUTPUT);</front>
<front id="temperatureCPP-950">  #endif</front>
<front id="temperatureCPP-951">  #if HAS_AUTO_FAN_2 && (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) && (EXTRUDER_2_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-952">    pinMode(EXTRUDER_2_AUTO_FAN_PIN, OUTPUT);</front>
<front id="temperatureCPP-953">  #endif</front>
<front id="temperatureCPP-954">  #if HAS_AUTO_FAN_3 && (EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_0_AUTO_FAN_PIN) && (EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_1_AUTO_FAN_PIN) && (EXTRUDER_3_AUTO_FAN_PIN != EXTRUDER_2_AUTO_FAN_PIN)</front>
<front id="temperatureCPP-955">    pinMode(EXTRUDER_3_AUTO_FAN_PIN, OUTPUT);</front>
<front id="temperatureCPP-956">  #endif</front>
<front id="temperatureCPP-957"></front>
<front id="temperatureCPP-958">  // Use timer0 for temperature measurement</front>
<front id="temperatureCPP-959">  // Interleave temperature interrupt with millies interrupt</front>
<front id="temperatureCPP-960">  OCR0B = 128;</front>
<front id="temperatureCPP-961">  TIMSK0 |= BIT(OCIE0B);  </front>
<front id="temperatureCPP-962">  </front>
<front id="temperatureCPP-963">  // Wait for temperature measurement to settle</front>
<front id="temperatureCPP-964">  delay(250);</front>
<front id="temperatureCPP-965"></front>
<front id="temperatureCPP-966">  #define TEMP_MIN_ROUTINE(NR) \</front>
<front id="temperatureCPP-967">    minttemp[NR] = HEATER_ ## NR ## _MINTEMP; \</front>
<front id="temperatureCPP-968">    while(analog2temp(minttemp_raw[NR], NR) &lt; HEATER_ ## NR ## _MINTEMP) { \</front>
<front id="temperatureCPP-969">      if (HEATER_ ## NR ## _RAW_LO_TEMP &lt; HEATER_ ## NR ## _RAW_HI_TEMP) \</front>
<front id="temperatureCPP-970">        minttemp_raw[NR] += OVERSAMPLENR; \</front>
<front id="temperatureCPP-971">      else \</front>
<front id="temperatureCPP-972">        minttemp_raw[NR] -= OVERSAMPLENR; \</front>
<front id="temperatureCPP-973">    }</front>
<front id="temperatureCPP-974">  #define TEMP_MAX_ROUTINE(NR) \</front>
<front id="temperatureCPP-975">    maxttemp[NR] = HEATER_ ## NR ## _MAXTEMP; \</front>
<front id="temperatureCPP-976">    while(analog2temp(maxttemp_raw[NR], NR) &gt; HEATER_ ## NR ## _MAXTEMP) { \</front>
<front id="temperatureCPP-977">      if (HEATER_ ## NR ## _RAW_LO_TEMP &lt; HEATER_ ## NR ## _RAW_HI_TEMP) \</front>
<front id="temperatureCPP-978">        maxttemp_raw[NR] -= OVERSAMPLENR; \</front>
<front id="temperatureCPP-979">      else \</front>
<front id="temperatureCPP-980">        maxttemp_raw[NR] += OVERSAMPLENR; \</front>
<front id="temperatureCPP-981">    }</front>
<front id="temperatureCPP-982"></front>
<front id="temperatureCPP-983">  #ifdef HEATER_0_MINTEMP</front>
<front id="temperatureCPP-984">    TEMP_MIN_ROUTINE(0);</front>
<front id="temperatureCPP-985">  #endif</front>
<front id="temperatureCPP-986">  #ifdef HEATER_0_MAXTEMP</front>
<front id="temperatureCPP-987">    TEMP_MAX_ROUTINE(0);</front>
<front id="temperatureCPP-988">  #endif</front>
<front id="temperatureCPP-989">  #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-990">    #ifdef HEATER_1_MINTEMP</front>
<front id="temperatureCPP-991">      TEMP_MIN_ROUTINE(1);</front>
<front id="temperatureCPP-992">    #endif</front>
<front id="temperatureCPP-993">    #ifdef HEATER_1_MAXTEMP</front>
<front id="temperatureCPP-994">      TEMP_MAX_ROUTINE(1);</front>
<front id="temperatureCPP-995">    #endif</front>
<front id="temperatureCPP-996">    #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-997">      #ifdef HEATER_2_MINTEMP</front>
<front id="temperatureCPP-998">        TEMP_MIN_ROUTINE(2);</front>
<front id="temperatureCPP-999">      #endif</front>
<front id="temperatureCPP-1000">      #ifdef HEATER_2_MAXTEMP</front>
<front id="temperatureCPP-1001">        TEMP_MAX_ROUTINE(2);</front>
<front id="temperatureCPP-1002">      #endif</front>
<front id="temperatureCPP-1003">      #if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1004">        #ifdef HEATER_3_MINTEMP</front>
<front id="temperatureCPP-1005">          TEMP_MIN_ROUTINE(3);</front>
<front id="temperatureCPP-1006">        #endif</front>
<front id="temperatureCPP-1007">        #ifdef HEATER_3_MAXTEMP</front>
<front id="temperatureCPP-1008">          TEMP_MAX_ROUTINE(3);</front>
<front id="temperatureCPP-1009">        #endif</front>
<front id="temperatureCPP-1010">      #endif // EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1011">    #endif // EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1012">  #endif // EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1013"></front>
<front id="temperatureCPP-1014">  #ifdef BED_MINTEMP</front>
<front id="temperatureCPP-1015">    while(analog2tempBed(bed_minttemp_raw) &lt; BED_MINTEMP) {</front>
<front id="temperatureCPP-1016">      #if HEATER_BED_RAW_LO_TEMP &lt; HEATER_BED_RAW_HI_TEMP</front>
<front id="temperatureCPP-1017">        bed_minttemp_raw += OVERSAMPLENR;</front>
<front id="temperatureCPP-1018">      #else</front>
<front id="temperatureCPP-1019">        bed_minttemp_raw -= OVERSAMPLENR;</front>
<front id="temperatureCPP-1020">      #endif</front>
<front id="temperatureCPP-1021">    }</front>
<front id="temperatureCPP-1022">  #endif //BED_MINTEMP</front>
<front id="temperatureCPP-1023">  #ifdef BED_MAXTEMP</front>
<front id="temperatureCPP-1024">    while(analog2tempBed(bed_maxttemp_raw) &gt; BED_MAXTEMP) {</front>
<front id="temperatureCPP-1025">      #if HEATER_BED_RAW_LO_TEMP &lt; HEATER_BED_RAW_HI_TEMP</front>
<front id="temperatureCPP-1026">        bed_maxttemp_raw -= OVERSAMPLENR;</front>
<front id="temperatureCPP-1027">      #else</front>
<front id="temperatureCPP-1028">        bed_maxttemp_raw += OVERSAMPLENR;</front>
<front id="temperatureCPP-1029">      #endif</front>
<front id="temperatureCPP-1030">    }</front>
<front id="temperatureCPP-1031">  #endif //BED_MAXTEMP</front>
<front id="temperatureCPP-1032">}</front>
<front id="temperatureCPP-1033"></front>
<front id="temperatureCPP-1034">#if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureCPP-1035">  /**</front>
<front id="temperatureCPP-1036">   * Start Heating Sanity Check for hotends that are below</front>
<front id="temperatureCPP-1037">   * their target temperature by a configurable margin.</front>
<front id="temperatureCPP-1038">   * This is called when the temperature is set. (M104, M109)</front>
<front id="temperatureCPP-1039">   */</front>
<front id="temperatureCPP-1040">  void start_watching_heater(int e) {</front>
<front id="temperatureCPP-1041">    if (degHotend(e) &lt; degTargetHotend(e) - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1)) {</front>
<front id="temperatureCPP-1042">      watch_target_temp[e] = degHotend(e) + WATCH_TEMP_INCREASE;</front>
<front id="temperatureCPP-1043">      watch_heater_next_ms[e] = millis() + WATCH_TEMP_PERIOD * 1000UL;</front>
<front id="temperatureCPP-1044">    }</front>
<front id="temperatureCPP-1045">    else</front>
<front id="temperatureCPP-1046">      watch_heater_next_ms[e] = 0;</front>
<front id="temperatureCPP-1047">  }</front>
<front id="temperatureCPP-1048">#endif</front>
<front id="temperatureCPP-1049"></front>
<front id="temperatureCPP-1050">#if ENABLED(THERMAL_PROTECTION_HOTENDS) || ENABLED(THERMAL_PROTECTION_BED)</front>
<front id="temperatureCPP-1051"></front>
<front id="temperatureCPP-1052">  void thermal_runaway_protection(TRState *state, millis_t *timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc) {</front>
<front id="temperatureCPP-1053"></front>
<front id="temperatureCPP-1054">    static float tr_target_temperature[EXTRUDERS+1] = { 0.0 };</front>
<front id="temperatureCPP-1055"></front>
<front id="temperatureCPP-1056">    /*</front>
<front id="temperatureCPP-1057">        SERIAL_ECHO_START;</front>
<front id="temperatureCPP-1058">        SERIAL_ECHOPGM("Thermal Thermal Runaway Running. Heater ID: ");</front>
<front id="temperatureCPP-1059">        if (heater_id &lt; 0) SERIAL_ECHOPGM("bed"); else SERIAL_ECHOPGM(heater_id);</front>
<front id="temperatureCPP-1060">        SERIAL_ECHOPGM(" ;  State:");</front>
<front id="temperatureCPP-1061">        SERIAL_ECHOPGM(*state);</front>
<front id="temperatureCPP-1062">        SERIAL_ECHOPGM(" ;  Timer:");</front>
<front id="temperatureCPP-1063">        SERIAL_ECHOPGM(*timer);</front>
<front id="temperatureCPP-1064">        SERIAL_ECHOPGM(" ;  Temperature:");</front>
<front id="temperatureCPP-1065">        SERIAL_ECHOPGM(temperature);</front>
<front id="temperatureCPP-1066">        SERIAL_ECHOPGM(" ;  Target Temp:");</front>
<front id="temperatureCPP-1067">        SERIAL_ECHOPGM(target_temperature);</front>
<front id="temperatureCPP-1068">        SERIAL_EOL;</front>
<front id="temperatureCPP-1069">    */</front>
<front id="temperatureCPP-1070"></front>
<front id="temperatureCPP-1071">    int heater_index = heater_id &gt;= 0 ? heater_id : EXTRUDERS;</front>
<front id="temperatureCPP-1072"></front>
<front id="temperatureCPP-1073">    // If the target temperature changes, restart</front>
<front id="temperatureCPP-1074">    if (tr_target_temperature[heater_index] != target_temperature)</front>
<front id="temperatureCPP-1075">      *state = TRReset;</front>
<front id="temperatureCPP-1076"></front>
<front id="temperatureCPP-1077">    switch (*state) {</front>
<front id="temperatureCPP-1078">      case TRReset:</front>
<front id="temperatureCPP-1079">        *timer = 0;</front>
<front id="temperatureCPP-1080">        *state = TRInactive;</front>
<front id="temperatureCPP-1081">      // Inactive state waits for a target temperature to be set</front>
<front id="temperatureCPP-1082">      case TRInactive:</front>
<front id="temperatureCPP-1083">        if (target_temperature &gt; 0) {</front>
<front id="temperatureCPP-1084">          tr_target_temperature[heater_index] = target_temperature;</front>
<front id="temperatureCPP-1085">          *state = TRFirstHeating;</front>
<front id="temperatureCPP-1086">        }</front>
<front id="temperatureCPP-1087">        break;</front>
<front id="temperatureCPP-1088">      // When first heating, wait for the temperature to be reached then go to Stable state</front>
<front id="temperatureCPP-1089">      case TRFirstHeating:</front>
<front id="temperatureCPP-1090">        if (temperature &gt;= tr_target_temperature[heater_index]) *state = TRStable;</front>
<front id="temperatureCPP-1091">        break;</front>
<front id="temperatureCPP-1092">      // While the temperature is stable watch for a bad temperature</front>
<front id="temperatureCPP-1093">      case TRStable:</front>
<front id="temperatureCPP-1094">        // If the temperature is over the target (-hysteresis) restart the timer</front>
<front id="temperatureCPP-1095">        if (temperature &gt;= tr_target_temperature[heater_index] - hysteresis_degc)</front>
<front id="temperatureCPP-1096">          *timer = millis();</front>
<front id="temperatureCPP-1097">          // If the timer goes too long without a reset, trigger shutdown</front>
<front id="temperatureCPP-1098">        else if (millis() &gt; *timer + period_seconds * 1000UL)</front>
<front id="temperatureCPP-1099">          *state = TRRunaway;</front>
<front id="temperatureCPP-1100">        break;</front>
<front id="temperatureCPP-1101">      case TRRunaway:</front>
<front id="temperatureCPP-1102">        _temp_error(heater_id, PSTR(MSG_T_THERMAL_RUNAWAY), PSTR(MSG_THERMAL_RUNAWAY));</front>
<front id="temperatureCPP-1103">    }</front>
<front id="temperatureCPP-1104">  }</front>
<front id="temperatureCPP-1105"></front>
<front id="temperatureCPP-1106">#endif // THERMAL_PROTECTION_HOTENDS || THERMAL_PROTECTION_BED</front>
<front id="temperatureCPP-1107"></front>
<front id="temperatureCPP-1108">void disable_all_heaters() {</front>
<front id="temperatureCPP-1109">  for (int i=0; i&lt;EXTRUDERS; i++) setTargetHotend(0, i);</front>
<front id="temperatureCPP-1110">  setTargetBed(0);</front>
<front id="temperatureCPP-1111"></front>
<front id="temperatureCPP-1112">  #define DISABLE_HEATER(NR) { \</front>
<front id="temperatureCPP-1113">    target_temperature[NR] = 0; \</front>
<front id="temperatureCPP-1114">    soft_pwm[NR] = 0; \</front>
<front id="temperatureCPP-1115">    WRITE_HEATER_ ## NR (LOW); \</front>
<front id="temperatureCPP-1116">  }</front>
<front id="temperatureCPP-1117"></front>
<front id="temperatureCPP-1118">  #if HAS_TEMP_0</front>
<front id="temperatureCPP-1119">    target_temperature[0] = 0;</front>
<front id="temperatureCPP-1120">    soft_pwm[0] = 0;</front>
<front id="temperatureCPP-1121">    WRITE_HEATER_0P(LOW); // Should HEATERS_PARALLEL apply here? Then change to DISABLE_HEATER(0)</front>
<front id="temperatureCPP-1122">  #endif</front>
<front id="temperatureCPP-1123"></front>
<front id="temperatureCPP-1124">  #if EXTRUDERS &gt; 1 && HAS_TEMP_1</front>
<front id="temperatureCPP-1125">    DISABLE_HEATER(1);</front>
<front id="temperatureCPP-1126">  #endif</front>
<front id="temperatureCPP-1127"></front>
<front id="temperatureCPP-1128">  #if EXTRUDERS &gt; 2 && HAS_TEMP_2</front>
<front id="temperatureCPP-1129">    DISABLE_HEATER(2);</front>
<front id="temperatureCPP-1130">  #endif</front>
<front id="temperatureCPP-1131"></front>
<front id="temperatureCPP-1132">  #if EXTRUDERS &gt; 3 && HAS_TEMP_3</front>
<front id="temperatureCPP-1133">    DISABLE_HEATER(3);</front>
<front id="temperatureCPP-1134">  #endif</front>
<front id="temperatureCPP-1135"></front>
<front id="temperatureCPP-1136">  #if HAS_TEMP_BED</front>
<front id="temperatureCPP-1137">    target_temperature_bed = 0;</front>
<front id="temperatureCPP-1138">    soft_pwm_bed = 0;</front>
<front id="temperatureCPP-1139">    #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1140">      WRITE_HEATER_BED(LOW);</front>
<front id="temperatureCPP-1141">    #endif</front>
<front id="temperatureCPP-1142">  #endif</front>
<front id="temperatureCPP-1143">}</front>
<front id="temperatureCPP-1144"></front>
<front id="temperatureCPP-1145">#if ENABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-1146">  #define MAX6675_HEAT_INTERVAL 250u</front>
<front id="temperatureCPP-1147">  static millis_t next_max6675_ms = 0;</front>
<front id="temperatureCPP-1148">  int max6675_temp = 2000;</front>
<front id="temperatureCPP-1149"></front>
<front id="temperatureCPP-1150">  static int read_max6675() {</front>
<front id="temperatureCPP-1151"></front>
<front id="temperatureCPP-1152">    millis_t ms = millis();</front>
<front id="temperatureCPP-1153"></front>
<front id="temperatureCPP-1154">    if (ms &lt; next_max6675_ms)</front>
<front id="temperatureCPP-1155">      return max6675_temp;</front>
<front id="temperatureCPP-1156">    </front>
<front id="temperatureCPP-1157">    next_max6675_ms = ms + MAX6675_HEAT_INTERVAL;</front>
<front id="temperatureCPP-1158"></front>
<front id="temperatureCPP-1159">    max6675_temp = 0;</front>
<front id="temperatureCPP-1160"></front>
<front id="temperatureCPP-1161">    #ifdef PRR</front>
<front id="temperatureCPP-1162">      PRR &= ~BIT(PRSPI);</front>
<front id="temperatureCPP-1163">    #elif defined(PRR0)</front>
<front id="temperatureCPP-1164">      PRR0 &= ~BIT(PRSPI);</front>
<front id="temperatureCPP-1165">    #endif</front>
<front id="temperatureCPP-1166"></front>
<front id="temperatureCPP-1167">    SPCR = BIT(MSTR) | BIT(SPE) | BIT(SPR0);</front>
<front id="temperatureCPP-1168"></front>
<front id="temperatureCPP-1169">    // enable TT_MAX6675</front>
<front id="temperatureCPP-1170">    WRITE(MAX6675_SS, 0);</front>
<front id="temperatureCPP-1171"></front>
<front id="temperatureCPP-1172">    // ensure 100ns delay - a bit extra is fine</front>
<front id="temperatureCPP-1173">    asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz</front>
<front id="temperatureCPP-1174">    asm("nop");//50ns on 20Mhz, 62.5ns on 16Mhz</front>
<front id="temperatureCPP-1175"></front>
<front id="temperatureCPP-1176">    // read MSB</front>
<front id="temperatureCPP-1177">    SPDR = 0;</front>
<front id="temperatureCPP-1178">    for (;(SPSR & BIT(SPIF)) == 0;);</front>
<front id="temperatureCPP-1179">    max6675_temp = SPDR;</front>
<front id="temperatureCPP-1180">    max6675_temp &lt;&lt;= 8;</front>
<front id="temperatureCPP-1181"></front>
<front id="temperatureCPP-1182">    // read LSB</front>
<front id="temperatureCPP-1183">    SPDR = 0;</front>
<front id="temperatureCPP-1184">    for (;(SPSR & BIT(SPIF)) == 0;);</front>
<front id="temperatureCPP-1185">    max6675_temp |= SPDR;</front>
<front id="temperatureCPP-1186"></front>
<front id="temperatureCPP-1187">    // disable TT_MAX6675</front>
<front id="temperatureCPP-1188">    WRITE(MAX6675_SS, 1);</front>
<front id="temperatureCPP-1189"></front>
<front id="temperatureCPP-1190">    if (max6675_temp & 4) {</front>
<front id="temperatureCPP-1191">      // thermocouple open</front>
<front id="temperatureCPP-1192">      max6675_temp = 4000;</front>
<front id="temperatureCPP-1193">    }</front>
<front id="temperatureCPP-1194">    else {</front>
<front id="temperatureCPP-1195">      max6675_temp = max6675_temp &gt;&gt; 3;</front>
<front id="temperatureCPP-1196">    }</front>
<front id="temperatureCPP-1197"></front>
<front id="temperatureCPP-1198">    return max6675_temp;</front>
<front id="temperatureCPP-1199">  }</front>
<front id="temperatureCPP-1200"></front>
<front id="temperatureCPP-1201">#endif //HEATER_0_USES_MAX6675</front>
<front id="temperatureCPP-1202"></front>
<front id="temperatureCPP-1203">/**</front>
<front id="temperatureCPP-1204"> * Stages in the ISR loop</front>
<front id="temperatureCPP-1205"> */</front>
<front id="temperatureCPP-1206">enum TempState {</front>
<front id="temperatureCPP-1207">  PrepareTemp_0,</front>
<front id="temperatureCPP-1208">  MeasureTemp_0,</front>
<front id="temperatureCPP-1209">  PrepareTemp_BED,</front>
<front id="temperatureCPP-1210">  MeasureTemp_BED,</front>
<front id="temperatureCPP-1211">  PrepareTemp_1,</front>
<front id="temperatureCPP-1212">  MeasureTemp_1,</front>
<front id="temperatureCPP-1213">  PrepareTemp_2,</front>
<front id="temperatureCPP-1214">  MeasureTemp_2,</front>
<front id="temperatureCPP-1215">  PrepareTemp_3,</front>
<front id="temperatureCPP-1216">  MeasureTemp_3,</front>
<front id="temperatureCPP-1217">  Prepare_FILWIDTH,</front>
<front id="temperatureCPP-1218">  Measure_FILWIDTH,</front>
<front id="temperatureCPP-1219">  StartupDelay // Startup, delay initial temp reading a tiny bit so the hardware can settle</front>
<front id="temperatureCPP-1220">};</front>
<front id="temperatureCPP-1221"></front>
<front id="temperatureCPP-1222">static unsigned long raw_temp_value[4] = { 0 };</front>
<front id="temperatureCPP-1223">static unsigned long raw_temp_bed_value = 0;</front>
<front id="temperatureCPP-1224"></front>
<front id="temperatureCPP-1225">static void set_current_temp_raw() {</front>
<front id="temperatureCPP-1226">  #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-1227">    current_temperature_raw[0] = raw_temp_value[0];</front>
<front id="temperatureCPP-1228">  #endif</front>
<front id="temperatureCPP-1229">  #if HAS_TEMP_1</front>
<front id="temperatureCPP-1230">    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureCPP-1231">      redundant_temperature_raw = raw_temp_value[1];</front>
<front id="temperatureCPP-1232">    #else</front>
<front id="temperatureCPP-1233">      current_temperature_raw[1] = raw_temp_value[1];</front>
<front id="temperatureCPP-1234">    #endif</front>
<front id="temperatureCPP-1235">    #if HAS_TEMP_2</front>
<front id="temperatureCPP-1236">      current_temperature_raw[2] = raw_temp_value[2];</front>
<front id="temperatureCPP-1237">      #if HAS_TEMP_3</front>
<front id="temperatureCPP-1238">        current_temperature_raw[3] = raw_temp_value[3];</front>
<front id="temperatureCPP-1239">      #endif</front>
<front id="temperatureCPP-1240">    #endif</front>
<front id="temperatureCPP-1241">  #endif</front>
<front id="temperatureCPP-1242">  current_temperature_bed_raw = raw_temp_bed_value;</front>
<front id="temperatureCPP-1243">  temp_meas_ready = true;</front>
<front id="temperatureCPP-1244">}</front>
<front id="temperatureCPP-1245"></front>
<front id="temperatureCPP-1246">/**</front>
<front id="temperatureCPP-1247"> * Timer 0 is shared with millies</front>
<front id="temperatureCPP-1248"> *  - Manage PWM to all the heaters and fan</front>
<front id="temperatureCPP-1249"> *  - Update the raw temperature values</front>
<front id="temperatureCPP-1250"> *  - Check new temperature values for MIN/MAX errors</front>
<front id="temperatureCPP-1251"> *  - Step the babysteps value for each axis towards 0</front>
<front id="temperatureCPP-1252"> */</front>
<front id="temperatureCPP-1253">ISR(TIMER0_COMPB_vect) {</front>
<front id="temperatureCPP-1254"></front>
<front id="temperatureCPP-1255">  static unsigned char temp_count = 0;</front>
<front id="temperatureCPP-1256">  static TempState temp_state = StartupDelay;</front>
<front id="temperatureCPP-1257">  static unsigned char pwm_count = BIT(SOFT_PWM_SCALE);</front>
<front id="temperatureCPP-1258"></front>
<front id="temperatureCPP-1259">  // Static members for each heater</front>
<front id="temperatureCPP-1260">  #if ENABLED(SLOW_PWM_HEATERS)</front>
<front id="temperatureCPP-1261">    static unsigned char slow_pwm_count = 0;</front>
<front id="temperatureCPP-1262">    #define ISR_STATICS(n) \</front>
<front id="temperatureCPP-1263">      static unsigned char soft_pwm_ ## n; \</front>
<front id="temperatureCPP-1264">      static unsigned char state_heater_ ## n = 0; \</front>
<front id="temperatureCPP-1265">      static unsigned char state_timer_heater_ ## n = 0</front>
<front id="temperatureCPP-1266">  #else</front>
<front id="temperatureCPP-1267">    #define ISR_STATICS(n) static unsigned char soft_pwm_ ## n</front>
<front id="temperatureCPP-1268">  #endif</front>
<front id="temperatureCPP-1269"></front>
<front id="temperatureCPP-1270">  // Statics per heater</front>
<front id="temperatureCPP-1271">  ISR_STATICS(0);</front>
<front id="temperatureCPP-1272">  #if (EXTRUDERS &gt; 1) || ENABLED(HEATERS_PARALLEL)</front>
<front id="temperatureCPP-1273">    ISR_STATICS(1);</front>
<front id="temperatureCPP-1274">    #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1275">      ISR_STATICS(2);</front>
<front id="temperatureCPP-1276">      #if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1277">        ISR_STATICS(3);</front>
<front id="temperatureCPP-1278">      #endif</front>
<front id="temperatureCPP-1279">    #endif</front>
<front id="temperatureCPP-1280">  #endif</front>
<front id="temperatureCPP-1281">  #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1282">    ISR_STATICS(BED);</front>
<front id="temperatureCPP-1283">  #endif</front>
<front id="temperatureCPP-1284"></front>
<front id="temperatureCPP-1285">  #if HAS_FILAMENT_SENSOR</front>
<front id="temperatureCPP-1286">    static unsigned long raw_filwidth_value = 0;</front>
<front id="temperatureCPP-1287">  #endif</front>
<front id="temperatureCPP-1288">  </front>
<front id="temperatureCPP-1289">  #if DISABLED(SLOW_PWM_HEATERS)</front>
<front id="temperatureCPP-1290">    /**</front>
<front id="temperatureCPP-1291">     * standard PWM modulation</front>
<front id="temperatureCPP-1292">     */</front>
<front id="temperatureCPP-1293">    if (pwm_count == 0) {</front>
<front id="temperatureCPP-1294">      soft_pwm_0 = soft_pwm[0];</front>
<front id="temperatureCPP-1295">      if (soft_pwm_0 &gt; 0) {</front>
<front id="temperatureCPP-1296">        WRITE_HEATER_0(1);</front>
<front id="temperatureCPP-1297">      }</front>
<front id="temperatureCPP-1298">      else WRITE_HEATER_0P(0); // If HEATERS_PARALLEL should apply, change to WRITE_HEATER_0</front>
<front id="temperatureCPP-1299"></front>
<front id="temperatureCPP-1300">      #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1301">        soft_pwm_1 = soft_pwm[1];</front>
<front id="temperatureCPP-1302">        WRITE_HEATER_1(soft_pwm_1 &gt; 0 ? 1 : 0);</front>
<front id="temperatureCPP-1303">        #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1304">          soft_pwm_2 = soft_pwm[2];</front>
<front id="temperatureCPP-1305">          WRITE_HEATER_2(soft_pwm_2 &gt; 0 ? 1 : 0);</front>
<front id="temperatureCPP-1306">          #if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1307">            soft_pwm_3 = soft_pwm[3];</front>
<front id="temperatureCPP-1308">            WRITE_HEATER_3(soft_pwm_3 &gt; 0 ? 1 : 0);</front>
<front id="temperatureCPP-1309">          #endif</front>
<front id="temperatureCPP-1310">        #endif</front>
<front id="temperatureCPP-1311">      #endif</front>
<front id="temperatureCPP-1312"></front>
<front id="temperatureCPP-1313">      #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1314">        soft_pwm_BED = soft_pwm_bed;</front>
<front id="temperatureCPP-1315">        WRITE_HEATER_BED(soft_pwm_BED &gt; 0 ? 1 : 0);</front>
<front id="temperatureCPP-1316">      #endif</front>
<front id="temperatureCPP-1317">      #if ENABLED(FAN_SOFT_PWM)</front>
<front id="temperatureCPP-1318">        soft_pwm_fan = fanSpeedSoftPwm / 2;</front>
<front id="temperatureCPP-1319">        WRITE_FAN(soft_pwm_fan &gt; 0 ? 1 : 0);</front>
<front id="temperatureCPP-1320">      #endif</front>
<front id="temperatureCPP-1321">    }</front>
<front id="temperatureCPP-1322"></front>
<front id="temperatureCPP-1323">    if (soft_pwm_0 &lt; pwm_count) { WRITE_HEATER_0(0); }</front>
<front id="temperatureCPP-1324">    #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1325">      if (soft_pwm_1 &lt; pwm_count) WRITE_HEATER_1(0);</front>
<front id="temperatureCPP-1326">      #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1327">        if (soft_pwm_2 &lt; pwm_count) WRITE_HEATER_2(0);</front>
<front id="temperatureCPP-1328">        #if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1329">          if (soft_pwm_3 &lt; pwm_count) WRITE_HEATER_3(0);</front>
<front id="temperatureCPP-1330">        #endif</front>
<front id="temperatureCPP-1331">      #endif</front>
<front id="temperatureCPP-1332">    #endif</front>
<front id="temperatureCPP-1333"></front>
<front id="temperatureCPP-1334">    #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1335">      if (soft_pwm_BED &lt; pwm_count) WRITE_HEATER_BED(0);</front>
<front id="temperatureCPP-1336">    #endif</front>
<front id="temperatureCPP-1337"></front>
<front id="temperatureCPP-1338">    #if ENABLED(FAN_SOFT_PWM)</front>
<front id="temperatureCPP-1339">      if (soft_pwm_fan &lt; pwm_count) WRITE_FAN(0);</front>
<front id="temperatureCPP-1340">    #endif</front>
<front id="temperatureCPP-1341">    </front>
<front id="temperatureCPP-1342">    pwm_count += BIT(SOFT_PWM_SCALE);</front>
<front id="temperatureCPP-1343">    pwm_count &= 0x7f;</front>
<front id="temperatureCPP-1344">  </front>
<front id="temperatureCPP-1345">  #else // SLOW_PWM_HEATERS</front>
<front id="temperatureCPP-1346">    /*</front>
<front id="temperatureCPP-1347">     * SLOW PWM HEATERS</front>
<front id="temperatureCPP-1348">     *</front>
<front id="temperatureCPP-1349">     * for heaters drived by relay</front>
<front id="temperatureCPP-1350">     */</front>
<front id="temperatureCPP-1351">    #ifndef MIN_STATE_TIME</front>
<front id="temperatureCPP-1352">      #define MIN_STATE_TIME 16 // MIN_STATE_TIME * 65.5 = time in milliseconds</front>
<front id="temperatureCPP-1353">    #endif</front>
<front id="temperatureCPP-1354"></front>
<front id="temperatureCPP-1355">    // Macros for Slow PWM timer logic - HEATERS_PARALLEL applies</front>
<front id="temperatureCPP-1356">    #define _SLOW_PWM_ROUTINE(NR, src) \</front>
<front id="temperatureCPP-1357">      soft_pwm_ ## NR = src; \</front>
<front id="temperatureCPP-1358">      if (soft_pwm_ ## NR &gt; 0) { \</front>
<front id="temperatureCPP-1359">        if (state_timer_heater_ ## NR == 0) { \</front>
<front id="temperatureCPP-1360">          if (state_heater_ ## NR == 0) state_timer_heater_ ## NR = MIN_STATE_TIME; \</front>
<front id="temperatureCPP-1361">          state_heater_ ## NR = 1; \</front>
<front id="temperatureCPP-1362">          WRITE_HEATER_ ## NR(1); \</front>
<front id="temperatureCPP-1363">        } \</front>
<front id="temperatureCPP-1364">      } \</front>
<front id="temperatureCPP-1365">      else { \</front>
<front id="temperatureCPP-1366">        if (state_timer_heater_ ## NR == 0) { \</front>
<front id="temperatureCPP-1367">          if (state_heater_ ## NR == 1) state_timer_heater_ ## NR = MIN_STATE_TIME; \</front>
<front id="temperatureCPP-1368">          state_heater_ ## NR = 0; \</front>
<front id="temperatureCPP-1369">          WRITE_HEATER_ ## NR(0); \</front>
<front id="temperatureCPP-1370">        } \</front>
<front id="temperatureCPP-1371">      }</front>
<front id="temperatureCPP-1372">    #define SLOW_PWM_ROUTINE(n) _SLOW_PWM_ROUTINE(n, soft_pwm[n])</front>
<front id="temperatureCPP-1373"></front>
<front id="temperatureCPP-1374">    #define PWM_OFF_ROUTINE(NR) \</front>
<front id="temperatureCPP-1375">      if (soft_pwm_ ## NR &lt; slow_pwm_count) { \</front>
<front id="temperatureCPP-1376">        if (state_timer_heater_ ## NR == 0) { \</front>
<front id="temperatureCPP-1377">          if (state_heater_ ## NR == 1) state_timer_heater_ ## NR = MIN_STATE_TIME; \</front>
<front id="temperatureCPP-1378">          state_heater_ ## NR = 0; \</front>
<front id="temperatureCPP-1379">          WRITE_HEATER_ ## NR (0); \</front>
<front id="temperatureCPP-1380">        } \</front>
<front id="temperatureCPP-1381">      }</front>
<front id="temperatureCPP-1382"></front>
<front id="temperatureCPP-1383">    if (slow_pwm_count == 0) {</front>
<front id="temperatureCPP-1384"></front>
<front id="temperatureCPP-1385">      SLOW_PWM_ROUTINE(0); // EXTRUDER 0</front>
<front id="temperatureCPP-1386">      #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1387">        SLOW_PWM_ROUTINE(1); // EXTRUDER 1</front>
<front id="temperatureCPP-1388">        #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1389">          SLOW_PWM_ROUTINE(2); // EXTRUDER 2</front>
<front id="temperatureCPP-1390">          #if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1391">            SLOW_PWM_ROUTINE(3); // EXTRUDER 3</front>
<front id="temperatureCPP-1392">          #endif</front>
<front id="temperatureCPP-1393">        #endif</front>
<front id="temperatureCPP-1394">      #endif</front>
<front id="temperatureCPP-1395">      #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1396">        _SLOW_PWM_ROUTINE(BED, soft_pwm_bed); // BED</front>
<front id="temperatureCPP-1397">      #endif</front>
<front id="temperatureCPP-1398"></front>
<front id="temperatureCPP-1399">    } // slow_pwm_count == 0</front>
<front id="temperatureCPP-1400"></front>
<front id="temperatureCPP-1401">    PWM_OFF_ROUTINE(0); // EXTRUDER 0</front>
<front id="temperatureCPP-1402">    #if EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1403">      PWM_OFF_ROUTINE(1); // EXTRUDER 1</front>
<front id="temperatureCPP-1404">      #if EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1405">        PWM_OFF_ROUTINE(2); // EXTRUDER 2</front>
<front id="temperatureCPP-1406">        #if EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1407">          PWM_OFF_ROUTINE(3); // EXTRUDER 3</front>
<front id="temperatureCPP-1408">        #endif</front>
<front id="temperatureCPP-1409">      #endif</front>
<front id="temperatureCPP-1410">    #endif</front>
<front id="temperatureCPP-1411">    #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1412">      PWM_OFF_ROUTINE(BED); // BED</front>
<front id="temperatureCPP-1413">    #endif</front>
<front id="temperatureCPP-1414"></front>
<front id="temperatureCPP-1415">    #if ENABLED(FAN_SOFT_PWM)</front>
<front id="temperatureCPP-1416">      if (pwm_count == 0) {</front>
<front id="temperatureCPP-1417">        soft_pwm_fan = fanSpeedSoftPwm / 2;</front>
<front id="temperatureCPP-1418">        WRITE_FAN(soft_pwm_fan &gt; 0 ? 1 : 0);</front>
<front id="temperatureCPP-1419">      }</front>
<front id="temperatureCPP-1420">      if (soft_pwm_fan &lt; pwm_count) WRITE_FAN(0);</front>
<front id="temperatureCPP-1421">    #endif //FAN_SOFT_PWM</front>
<front id="temperatureCPP-1422"></front>
<front id="temperatureCPP-1423">    pwm_count += BIT(SOFT_PWM_SCALE);</front>
<front id="temperatureCPP-1424">    pwm_count &= 0x7f;</front>
<front id="temperatureCPP-1425"></front>
<front id="temperatureCPP-1426">    // increment slow_pwm_count only every 64 pwm_count circa 65.5ms</front>
<front id="temperatureCPP-1427">    if ((pwm_count % 64) == 0) {</front>
<front id="temperatureCPP-1428">      slow_pwm_count++;</front>
<front id="temperatureCPP-1429">      slow_pwm_count &= 0x7f;</front>
<front id="temperatureCPP-1430">    </front>
<front id="temperatureCPP-1431">      // EXTRUDER 0</front>
<front id="temperatureCPP-1432">      if (state_timer_heater_0 &gt; 0) state_timer_heater_0--; </front>
<front id="temperatureCPP-1433">      #if EXTRUDERS &gt; 1    // EXTRUDER 1</front>
<front id="temperatureCPP-1434">        if (state_timer_heater_1 &gt; 0) state_timer_heater_1--;</front>
<front id="temperatureCPP-1435">        #if EXTRUDERS &gt; 2    // EXTRUDER 2</front>
<front id="temperatureCPP-1436">          if (state_timer_heater_2 &gt; 0) state_timer_heater_2--;</front>
<front id="temperatureCPP-1437">          #if EXTRUDERS &gt; 3    // EXTRUDER 3</front>
<front id="temperatureCPP-1438">            if (state_timer_heater_3 &gt; 0) state_timer_heater_3--;</front>
<front id="temperatureCPP-1439">          #endif</front>
<front id="temperatureCPP-1440">        #endif</front>
<front id="temperatureCPP-1441">      #endif</front>
<front id="temperatureCPP-1442">      #if HAS_HEATER_BED</front>
<front id="temperatureCPP-1443">        if (state_timer_heater_BED &gt; 0) state_timer_heater_BED--;</front>
<front id="temperatureCPP-1444">      #endif</front>
<front id="temperatureCPP-1445">    } // (pwm_count % 64) == 0</front>
<front id="temperatureCPP-1446">  </front>
<front id="temperatureCPP-1447">  #endif // SLOW_PWM_HEATERS</front>
<front id="temperatureCPP-1448"></front>
<front id="temperatureCPP-1449">  #define SET_ADMUX_ADCSRA(pin) ADMUX = BIT(REFS0) | (pin & 0x07); ADCSRA |= BIT(ADSC)</front>
<front id="temperatureCPP-1450">  #ifdef MUX5</front>
<front id="temperatureCPP-1451">    #define START_ADC(pin) if (pin &gt; 7) ADCSRB = BIT(MUX5); else ADCSRB = 0; SET_ADMUX_ADCSRA(pin)</front>
<front id="temperatureCPP-1452">  #else</front>
<front id="temperatureCPP-1453">    #define START_ADC(pin) ADCSRB = 0; SET_ADMUX_ADCSRA(pin)</front>
<front id="temperatureCPP-1454">  #endif</front>
<front id="temperatureCPP-1455"></front>
<front id="temperatureCPP-1456">  // Prepare or measure a sensor, each one every 12th frame</front>
<front id="temperatureCPP-1457">  switch(temp_state) {</front>
<front id="temperatureCPP-1458">    case PrepareTemp_0:</front>
<front id="temperatureCPP-1459">      #if HAS_TEMP_0</front>
<front id="temperatureCPP-1460">        START_ADC(TEMP_0_PIN);</front>
<front id="temperatureCPP-1461">      #endif</front>
<front id="temperatureCPP-1462">      lcd_buttons_update();</front>
<front id="temperatureCPP-1463">      temp_state = MeasureTemp_0;</front>
<front id="temperatureCPP-1464">      break;</front>
<front id="temperatureCPP-1465">    case MeasureTemp_0:</front>
<front id="temperatureCPP-1466">      #if HAS_TEMP_0</front>
<front id="temperatureCPP-1467">        raw_temp_value[0] += ADC;</front>
<front id="temperatureCPP-1468">      #endif</front>
<front id="temperatureCPP-1469">      temp_state = PrepareTemp_BED;</front>
<front id="temperatureCPP-1470">      break;</front>
<front id="temperatureCPP-1471"></front>
<front id="temperatureCPP-1472">    case PrepareTemp_BED:</front>
<front id="temperatureCPP-1473">      #if HAS_TEMP_BED</front>
<front id="temperatureCPP-1474">        START_ADC(TEMP_BED_PIN);</front>
<front id="temperatureCPP-1475">      #endif</front>
<front id="temperatureCPP-1476">      lcd_buttons_update();</front>
<front id="temperatureCPP-1477">      temp_state = MeasureTemp_BED;</front>
<front id="temperatureCPP-1478">      break;</front>
<front id="temperatureCPP-1479">    case MeasureTemp_BED:</front>
<front id="temperatureCPP-1480">      #if HAS_TEMP_BED</front>
<front id="temperatureCPP-1481">        raw_temp_bed_value += ADC;</front>
<front id="temperatureCPP-1482">      #endif</front>
<front id="temperatureCPP-1483">      temp_state = PrepareTemp_1;</front>
<front id="temperatureCPP-1484">      break;</front>
<front id="temperatureCPP-1485"></front>
<front id="temperatureCPP-1486">    case PrepareTemp_1:</front>
<front id="temperatureCPP-1487">      #if HAS_TEMP_1</front>
<front id="temperatureCPP-1488">        START_ADC(TEMP_1_PIN);</front>
<front id="temperatureCPP-1489">      #endif</front>
<front id="temperatureCPP-1490">      lcd_buttons_update();</front>
<front id="temperatureCPP-1491">      temp_state = MeasureTemp_1;</front>
<front id="temperatureCPP-1492">      break;</front>
<front id="temperatureCPP-1493">    case MeasureTemp_1:</front>
<front id="temperatureCPP-1494">      #if HAS_TEMP_1</front>
<front id="temperatureCPP-1495">        raw_temp_value[1] += ADC;</front>
<front id="temperatureCPP-1496">      #endif</front>
<front id="temperatureCPP-1497">      temp_state = PrepareTemp_2;</front>
<front id="temperatureCPP-1498">      break;</front>
<front id="temperatureCPP-1499"></front>
<front id="temperatureCPP-1500">    case PrepareTemp_2:</front>
<front id="temperatureCPP-1501">      #if HAS_TEMP_2</front>
<front id="temperatureCPP-1502">        START_ADC(TEMP_2_PIN);</front>
<front id="temperatureCPP-1503">      #endif</front>
<front id="temperatureCPP-1504">      lcd_buttons_update();</front>
<front id="temperatureCPP-1505">      temp_state = MeasureTemp_2;</front>
<front id="temperatureCPP-1506">      break;</front>
<front id="temperatureCPP-1507">    case MeasureTemp_2:</front>
<front id="temperatureCPP-1508">      #if HAS_TEMP_2</front>
<front id="temperatureCPP-1509">        raw_temp_value[2] += ADC;</front>
<front id="temperatureCPP-1510">      #endif</front>
<front id="temperatureCPP-1511">      temp_state = PrepareTemp_3;</front>
<front id="temperatureCPP-1512">      break;</front>
<front id="temperatureCPP-1513"></front>
<front id="temperatureCPP-1514">    case PrepareTemp_3:</front>
<front id="temperatureCPP-1515">      #if HAS_TEMP_3</front>
<front id="temperatureCPP-1516">        START_ADC(TEMP_3_PIN);</front>
<front id="temperatureCPP-1517">      #endif</front>
<front id="temperatureCPP-1518">      lcd_buttons_update();</front>
<front id="temperatureCPP-1519">      temp_state = MeasureTemp_3;</front>
<front id="temperatureCPP-1520">      break;</front>
<front id="temperatureCPP-1521">    case MeasureTemp_3:</front>
<front id="temperatureCPP-1522">      #if HAS_TEMP_3</front>
<front id="temperatureCPP-1523">        raw_temp_value[3] += ADC;</front>
<front id="temperatureCPP-1524">      #endif</front>
<front id="temperatureCPP-1525">      temp_state = Prepare_FILWIDTH;</front>
<front id="temperatureCPP-1526">      break;</front>
<front id="temperatureCPP-1527"></front>
<front id="temperatureCPP-1528">    case Prepare_FILWIDTH:</front>
<front id="temperatureCPP-1529">      #if HAS_FILAMENT_SENSOR</front>
<front id="temperatureCPP-1530">        START_ADC(FILWIDTH_PIN);</front>
<front id="temperatureCPP-1531">      #endif</front>
<front id="temperatureCPP-1532">      lcd_buttons_update();</front>
<front id="temperatureCPP-1533">      temp_state = Measure_FILWIDTH;</front>
<front id="temperatureCPP-1534">      break;</front>
<front id="temperatureCPP-1535">    case Measure_FILWIDTH:</front>
<front id="temperatureCPP-1536">      #if HAS_FILAMENT_SENSOR</front>
<front id="temperatureCPP-1537">        // raw_filwidth_value += ADC;  //remove to use an IIR filter approach</front>
<front id="temperatureCPP-1538">        if (ADC &gt; 102) { //check that ADC is reading a voltage &gt; 0.5 volts, otherwise don't take in the data.</front>
<front id="temperatureCPP-1539">          raw_filwidth_value -= (raw_filwidth_value&gt;&gt;7);  //multiply raw_filwidth_value by 127/128</front>
<front id="temperatureCPP-1540">          raw_filwidth_value += ((unsigned long)ADC&lt;&lt;7);  //add new ADC reading</front>
<front id="temperatureCPP-1541">        }</front>
<front id="temperatureCPP-1542">      #endif</front>
<front id="temperatureCPP-1543">      temp_state = PrepareTemp_0;</front>
<front id="temperatureCPP-1544">      temp_count++;</front>
<front id="temperatureCPP-1545">      break;</front>
<front id="temperatureCPP-1546"></front>
<front id="temperatureCPP-1547">    case StartupDelay:</front>
<front id="temperatureCPP-1548">      temp_state = PrepareTemp_0;</front>
<front id="temperatureCPP-1549">      break;</front>
<front id="temperatureCPP-1550"></front>
<front id="temperatureCPP-1551">    // default:</front>
<front id="temperatureCPP-1552">    //   SERIAL_ERROR_START;</front>
<front id="temperatureCPP-1553">    //   SERIAL_ERRORLNPGM("Temp measurement error!");</front>
<front id="temperatureCPP-1554">    //   break;</front>
<front id="temperatureCPP-1555">  } // switch(temp_state)</front>
<front id="temperatureCPP-1556"></front>
<front id="temperatureCPP-1557">  if (temp_count &gt;= OVERSAMPLENR) { // 10 * 16 * 1/(16000000/64/256)  = 164ms.</front>
<front id="temperatureCPP-1558">    // Update the raw values if they've been read. Else we could be updating them during reading.</front>
<front id="temperatureCPP-1559">    if (!temp_meas_ready) set_current_temp_raw();</front>
<front id="temperatureCPP-1560"></front>
<front id="temperatureCPP-1561">    // Filament Sensor - can be read any time since IIR filtering is used</front>
<front id="temperatureCPP-1562">    #if HAS_FILAMENT_SENSOR</front>
<front id="temperatureCPP-1563">      current_raw_filwidth = raw_filwidth_value &gt;&gt; 10;  // Divide to get to 0-16384 range since we used 1/128 IIR filter approach</front>
<front id="temperatureCPP-1564">    #endif</front>
<front id="temperatureCPP-1565"></front>
<front id="temperatureCPP-1566">    temp_count = 0;</front>
<front id="temperatureCPP-1567">    for (int i = 0; i &lt; 4; i++) raw_temp_value[i] = 0;</front>
<front id="temperatureCPP-1568">    raw_temp_bed_value = 0;</front>
<front id="temperatureCPP-1569"></front>
<front id="temperatureCPP-1570">    #if HAS_TEMP_0 && DISABLED(HEATER_0_USES_MAX6675)</front>
<front id="temperatureCPP-1571">      #if HEATER_0_RAW_LO_TEMP &gt; HEATER_0_RAW_HI_TEMP</front>
<front id="temperatureCPP-1572">        #define GE0 &lt;=</front>
<front id="temperatureCPP-1573">      #else</front>
<front id="temperatureCPP-1574">        #define GE0 &gt;=</front>
<front id="temperatureCPP-1575">      #endif</front>
<front id="temperatureCPP-1576">      if (current_temperature_raw[0] GE0 maxttemp_raw[0]) max_temp_error(0);</front>
<front id="temperatureCPP-1577">      if (minttemp_raw[0] GE0 current_temperature_raw[0]) min_temp_error(0);</front>
<front id="temperatureCPP-1578">    #endif</front>
<front id="temperatureCPP-1579"></front>
<front id="temperatureCPP-1580">    #if HAS_TEMP_1 && EXTRUDERS &gt; 1</front>
<front id="temperatureCPP-1581">      #if HEATER_1_RAW_LO_TEMP &gt; HEATER_1_RAW_HI_TEMP</front>
<front id="temperatureCPP-1582">        #define GE1 &lt;=</front>
<front id="temperatureCPP-1583">      #else</front>
<front id="temperatureCPP-1584">        #define GE1 &gt;=</front>
<front id="temperatureCPP-1585">      #endif</front>
<front id="temperatureCPP-1586">      if (current_temperature_raw[1] GE1 maxttemp_raw[1]) max_temp_error(1);</front>
<front id="temperatureCPP-1587">      if (minttemp_raw[1] GE1 current_temperature_raw[1]) min_temp_error(1);</front>
<front id="temperatureCPP-1588">    #endif // TEMP_SENSOR_1</front>
<front id="temperatureCPP-1589"></front>
<front id="temperatureCPP-1590">    #if HAS_TEMP_2 && EXTRUDERS &gt; 2</front>
<front id="temperatureCPP-1591">      #if HEATER_2_RAW_LO_TEMP &gt; HEATER_2_RAW_HI_TEMP</front>
<front id="temperatureCPP-1592">        #define GE2 &lt;=</front>
<front id="temperatureCPP-1593">      #else</front>
<front id="temperatureCPP-1594">        #define GE2 &gt;=</front>
<front id="temperatureCPP-1595">      #endif</front>
<front id="temperatureCPP-1596">      if (current_temperature_raw[2] GE2 maxttemp_raw[2]) max_temp_error(2);</front>
<front id="temperatureCPP-1597">      if (minttemp_raw[2] GE2 current_temperature_raw[2]) min_temp_error(2);</front>
<front id="temperatureCPP-1598">    #endif // TEMP_SENSOR_2</front>
<front id="temperatureCPP-1599"></front>
<front id="temperatureCPP-1600">    #if HAS_TEMP_3 && EXTRUDERS &gt; 3</front>
<front id="temperatureCPP-1601">      #if HEATER_3_RAW_LO_TEMP &gt; HEATER_3_RAW_HI_TEMP</front>
<front id="temperatureCPP-1602">        #define GE3 &lt;=</front>
<front id="temperatureCPP-1603">      #else</front>
<front id="temperatureCPP-1604">        #define GE3 &gt;=</front>
<front id="temperatureCPP-1605">      #endif</front>
<front id="temperatureCPP-1606">      if (current_temperature_raw[3] GE3 maxttemp_raw[3]) max_temp_error(3);</front>
<front id="temperatureCPP-1607">      if (minttemp_raw[3] GE3 current_temperature_raw[3]) min_temp_error(3);</front>
<front id="temperatureCPP-1608">    #endif // TEMP_SENSOR_3</front>
<front id="temperatureCPP-1609"></front>
<front id="temperatureCPP-1610">    #if HAS_TEMP_BED</front>
<front id="temperatureCPP-1611">      #if HEATER_BED_RAW_LO_TEMP &gt; HEATER_BED_RAW_HI_TEMP</front>
<front id="temperatureCPP-1612">        #define GEBED &lt;=</front>
<front id="temperatureCPP-1613">      #else</front>
<front id="temperatureCPP-1614">        #define GEBED &gt;=</front>
<front id="temperatureCPP-1615">      #endif</front>
<front id="temperatureCPP-1616">      if (current_temperature_bed_raw GEBED bed_maxttemp_raw) _temp_error(-1, PSTR(MSG_T_MAXTEMP), PSTR(MSG_ERR_MAXTEMP_BED));</front>
<front id="temperatureCPP-1617">      if (bed_minttemp_raw GEBED current_temperature_bed_raw) _temp_error(-1, PSTR(MSG_T_MINTEMP), PSTR(MSG_ERR_MINTEMP_BED));</front>
<front id="temperatureCPP-1618">    #endif</front>
<front id="temperatureCPP-1619"></front>
<front id="temperatureCPP-1620">  } // temp_count &gt;= OVERSAMPLENR</front>
<front id="temperatureCPP-1621"></front>
<front id="temperatureCPP-1622">  #if ENABLED(BABYSTEPPING)</front>
<front id="temperatureCPP-1623">    for (uint8_t axis = X_AXIS; axis &lt;= Z_AXIS; axis++) {</front>
<front id="temperatureCPP-1624">      int curTodo = babystepsTodo[axis]; //get rid of volatile for performance</front>
<front id="temperatureCPP-1625">     </front>
<front id="temperatureCPP-1626">      if (curTodo &gt; 0) {</front>
<front id="temperatureCPP-1627">        babystep(axis,/*fwd*/true);</front>
<front id="temperatureCPP-1628">        babystepsTodo[axis]--; //fewer to do next time</front>
<front id="temperatureCPP-1629">      }</front>
<front id="temperatureCPP-1630">      else if (curTodo &lt; 0) {</front>
<front id="temperatureCPP-1631">        babystep(axis,/*fwd*/false);</front>
<front id="temperatureCPP-1632">        babystepsTodo[axis]++; //fewer to do next time</front>
<front id="temperatureCPP-1633">      }</front>
<front id="temperatureCPP-1634">    }</front>
<front id="temperatureCPP-1635">  #endif //BABYSTEPPING</front>
<front id="temperatureCPP-1636">}</front>
<front id="temperatureCPP-1637"></front>
<front id="temperatureCPP-1638">#if ENABLED(PIDTEMP)</front>
<front id="temperatureCPP-1639">  // Apply the scale factors to the PID values</front>
<front id="temperatureCPP-1640">  float scalePID_i(float i)   { return i * PID_dT; }</front>
<front id="temperatureCPP-1641">  float unscalePID_i(float i) { return i / PID_dT; }</front>
<front id="temperatureCPP-1642">  float scalePID_d(float d)   { return d / PID_dT; }</front>
<front id="temperatureCPP-1643">  float unscalePID_d(float d) { return d * PID_dT; }</front>
<front id="temperatureCPP-1644">#endif //PIDTEMP</front>
 </pre>
<h1 id="temperatureHtitle" >temperature.h</h1>
<pre id="temperatureH"  class="prettyprint linenums"><front id="temperatureH-1">/*</front>
<front id="temperatureH-2">  temperature.h - temperature controller</front>
<front id="temperatureH-3">  Part of Marlin</front>
<front id="temperatureH-4"></front>
<front id="temperatureH-5">  Copyright (c) 2011 Erik van der Zalm</front>
<front id="temperatureH-6"></front>
<front id="temperatureH-7">  Grbl is free software: you can redistribute it and/or modify</front>
<front id="temperatureH-8">  it under the terms of the GNU General Public License as published by</front>
<front id="temperatureH-9">  the Free Software Foundation, either version 3 of the License, or</front>
<front id="temperatureH-10">  (at your option) any later version.</front>
<front id="temperatureH-11"></front>
<front id="temperatureH-12">  Grbl is distributed in the hope that it will be useful,</front>
<front id="temperatureH-13">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="temperatureH-14">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</front>
<front id="temperatureH-15">  GNU General Public License for more details.</front>
<front id="temperatureH-16"></front>
<front id="temperatureH-17">  You should have received a copy of the GNU General Public License</front>
<front id="temperatureH-18">  along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</front>
<front id="temperatureH-19">*/</front>
<front id="temperatureH-20"></front>
<front id="temperatureH-21">#ifndef TEMPERATURE_H</front>
<front id="temperatureH-22">#define TEMPERATURE_H </front>
<front id="temperatureH-23"></front>
<front id="temperatureH-24">#include "Marlin.h"</front>
<front id="temperatureH-25">#include "planner.h"</front>
<front id="temperatureH-26">#if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="temperatureH-27">  #include "stepper.h"</front>
<front id="temperatureH-28">#endif</front>
<front id="temperatureH-29"></front>
<front id="temperatureH-30">// public functions</front>
<front id="temperatureH-31">void tp_init();  //initialize the heating</front>
<front id="temperatureH-32">void manage_heater(); //it is critical that this is called periodically.</front>
<front id="temperatureH-33"></front>
<front id="temperatureH-34">#if ENABLED(FILAMENT_SENSOR)</front>
<front id="temperatureH-35">// For converting raw Filament Width to milimeters </front>
<front id="temperatureH-36"> float analog2widthFil(); </front>
<front id="temperatureH-37"> </front>
<front id="temperatureH-38">// For converting raw Filament Width to an extrusion ratio </front>
<front id="temperatureH-39"> int widthFil_to_size_ratio();</front>
<front id="temperatureH-40">#endif</front>
<front id="temperatureH-41"></front>
<front id="temperatureH-42">// low level conversion routines</front>
<front id="temperatureH-43">// do not use these routines and variables outside of temperature.cpp</front>
<front id="temperatureH-44">extern int target_temperature[4];  </front>
<front id="temperatureH-45">extern float current_temperature[4];</front>
<front id="temperatureH-46">#if ENABLED(SHOW_TEMP_ADC_VALUES)</front>
<front id="temperatureH-47">  extern int current_temperature_raw[4];</front>
<front id="temperatureH-48">  extern int current_temperature_bed_raw;</front>
<front id="temperatureH-49">#endif</front>
<front id="temperatureH-50">extern int target_temperature_bed;</front>
<front id="temperatureH-51">extern float current_temperature_bed;</front>
<front id="temperatureH-52">#if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)</front>
<front id="temperatureH-53">  extern float redundant_temperature;</front>
<front id="temperatureH-54">#endif</front>
<front id="temperatureH-55"></front>
<front id="temperatureH-56">#if HAS_CONTROLLERFAN</front>
<front id="temperatureH-57">  extern unsigned char soft_pwm_bed;</front>
<front id="temperatureH-58">#endif</front>
<front id="temperatureH-59"></front>
<front id="temperatureH-60">#if ENABLED(PIDTEMP)</front>
<front id="temperatureH-61"></front>
<front id="temperatureH-62">  #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="temperatureH-63">    extern float Kp[EXTRUDERS], Ki[EXTRUDERS], Kd[EXTRUDERS], Kc[EXTRUDERS]; // one param per extruder</front>
<front id="temperatureH-64">    #define PID_PARAM(param,e) param[e] // use macro to point to array value</front>
<front id="temperatureH-65">  #else</front>
<front id="temperatureH-66">    extern float Kp, Ki, Kd, Kc; // one param per extruder - saves 20 or 36 bytes of ram (inc array pointer)</front>
<front id="temperatureH-67">    #define PID_PARAM(param, e) param // use macro to point directly to value</front>
<front id="temperatureH-68">  #endif // PID_PARAMS_PER_EXTRUDER	</front>
<front id="temperatureH-69">  float scalePID_i(float i);</front>
<front id="temperatureH-70">  float scalePID_d(float d);</front>
<front id="temperatureH-71">  float unscalePID_i(float i);</front>
<front id="temperatureH-72">  float unscalePID_d(float d);</front>
<front id="temperatureH-73"></front>
<front id="temperatureH-74">#endif</front>
<front id="temperatureH-75"></front>
<front id="temperatureH-76">#if ENABLED(PIDTEMPBED)</front>
<front id="temperatureH-77">  extern float bedKp,bedKi,bedKd;</front>
<front id="temperatureH-78">#endif</front>
<front id="temperatureH-79">  </front>
<front id="temperatureH-80">#if ENABLED(BABYSTEPPING)</front>
<front id="temperatureH-81">  extern volatile int babystepsTodo[3];</front>
<front id="temperatureH-82">#endif</front>
<front id="temperatureH-83">  </front>
<front id="temperatureH-84">//high level conversion routines, for use outside of temperature.cpp</front>
<front id="temperatureH-85">//inline so that there is no performance decrease.</front>
<front id="temperatureH-86">//deg=degreeCelsius</front>
<front id="temperatureH-87"></front>
<front id="temperatureH-88">FORCE_INLINE float degHotend(uint8_t extruder) { return current_temperature[extruder]; }</front>
<front id="temperatureH-89">FORCE_INLINE float degBed() { return current_temperature_bed; }</front>
<front id="temperatureH-90"></front>
<front id="temperatureH-91">#if ENABLED(SHOW_TEMP_ADC_VALUES)</front>
<front id="temperatureH-92">  FORCE_INLINE float rawHotendTemp(uint8_t extruder) { return current_temperature_raw[extruder]; }</front>
<front id="temperatureH-93">  FORCE_INLINE float rawBedTemp() { return current_temperature_bed_raw; }</front>
<front id="temperatureH-94">#endif</front>
<front id="temperatureH-95"></front>
<front id="temperatureH-96">FORCE_INLINE float degTargetHotend(uint8_t extruder) { return target_temperature[extruder]; }</front>
<front id="temperatureH-97">FORCE_INLINE float degTargetBed() { return target_temperature_bed; }</front>
<front id="temperatureH-98"></front>
<front id="temperatureH-99">#if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureH-100">  void start_watching_heater(int e=0);</front>
<front id="temperatureH-101">#endif</front>
<front id="temperatureH-102"></front>
<front id="temperatureH-103">FORCE_INLINE void setTargetHotend(const float &celsius, uint8_t extruder) {</front>
<front id="temperatureH-104">  target_temperature[extruder] = celsius;</front>
<front id="temperatureH-105">  #if ENABLED(THERMAL_PROTECTION_HOTENDS)</front>
<front id="temperatureH-106">    start_watching_heater(extruder);</front>
<front id="temperatureH-107">  #endif</front>
<front id="temperatureH-108">}</front>
<front id="temperatureH-109">FORCE_INLINE void setTargetBed(const float &celsius) { target_temperature_bed = celsius; }</front>
<front id="temperatureH-110"></front>
<front id="temperatureH-111">FORCE_INLINE bool isHeatingHotend(uint8_t extruder) { return target_temperature[extruder] &gt; current_temperature[extruder]; }</front>
<front id="temperatureH-112">FORCE_INLINE bool isHeatingBed() { return target_temperature_bed &gt; current_temperature_bed; }</front>
<front id="temperatureH-113"></front>
<front id="temperatureH-114">FORCE_INLINE bool isCoolingHotend(uint8_t extruder) { return target_temperature[extruder] &lt; current_temperature[extruder]; }</front>
<front id="temperatureH-115">FORCE_INLINE bool isCoolingBed() { return target_temperature_bed &lt; current_temperature_bed; }</front>
<front id="temperatureH-116"></front>
<front id="temperatureH-117">#define HOTEND_ROUTINES(NR) \</front>
<front id="temperatureH-118">  FORCE_INLINE float degHotend##NR() { return degHotend(NR); } \</front>
<front id="temperatureH-119">  FORCE_INLINE float degTargetHotend##NR() { return degTargetHotend(NR); } \</front>
<front id="temperatureH-120">  FORCE_INLINE void setTargetHotend##NR(const float c) { setTargetHotend(c, NR); } \</front>
<front id="temperatureH-121">  FORCE_INLINE bool isHeatingHotend##NR() { return isHeatingHotend(NR); } \</front>
<front id="temperatureH-122">  FORCE_INLINE bool isCoolingHotend##NR() { return isCoolingHotend(NR); }</front>
<front id="temperatureH-123">HOTEND_ROUTINES(0);</front>
<front id="temperatureH-124">#if EXTRUDERS &gt; 1</front>
<front id="temperatureH-125">  HOTEND_ROUTINES(1);</front>
<front id="temperatureH-126">#else</front>
<front id="temperatureH-127">  #define setTargetHotend1(c) do{}while(0)</front>
<front id="temperatureH-128">#endif</front>
<front id="temperatureH-129">#if EXTRUDERS &gt; 2</front>
<front id="temperatureH-130">  HOTEND_ROUTINES(2);</front>
<front id="temperatureH-131">#else</front>
<front id="temperatureH-132">  #define setTargetHotend2(c) do{}while(0)</front>
<front id="temperatureH-133">#endif</front>
<front id="temperatureH-134">#if EXTRUDERS &gt; 3</front>
<front id="temperatureH-135">  HOTEND_ROUTINES(3);</front>
<front id="temperatureH-136">#else</front>
<front id="temperatureH-137">  #define setTargetHotend3(c) do{}while(0)</front>
<front id="temperatureH-138">#endif</front>
<front id="temperatureH-139"></front>
<front id="temperatureH-140">int getHeaterPower(int heater);</front>
<front id="temperatureH-141">void disable_all_heaters();</front>
<front id="temperatureH-142">void updatePID();</front>
<front id="temperatureH-143"></front>
<front id="temperatureH-144">void PID_autotune(float temp, int extruder, int ncycles);</front>
<front id="temperatureH-145"></front>
<front id="temperatureH-146">void setExtruderAutoFanState(int pin, bool state);</front>
<front id="temperatureH-147">void checkExtruderAutoFans();</front>
<front id="temperatureH-148"></front>
<front id="temperatureH-149">FORCE_INLINE void autotempShutdown() {</front>
<front id="temperatureH-150">  #if ENABLED(AUTOTEMP)</front>
<front id="temperatureH-151">    if (autotemp_enabled) {</front>
<front id="temperatureH-152">      autotemp_enabled = false;</front>
<front id="temperatureH-153">      if (degTargetHotend(active_extruder) &gt; autotemp_min)</front>
<front id="temperatureH-154">        setTargetHotend(0, active_extruder);</front>
<front id="temperatureH-155">    }</front>
<front id="temperatureH-156">  #endif</front>
<front id="temperatureH-157">}</front>
<front id="temperatureH-158"></front>
<front id="temperatureH-159">#endif // TEMPERATURE_H</front>
 </pre>
<h1 id="thermistortablesHtitle" >thermistortables.h</h1>
<pre id="thermistortablesH"  class="prettyprint linenums"><front id="thermistortablesH-1">#ifndef THERMISTORTABLES_H_</front>
<front id="thermistortablesH-2">#define THERMISTORTABLES_H_</front>
<front id="thermistortablesH-3"></front>
<front id="thermistortablesH-4">#include "Marlin.h"</front>
<front id="thermistortablesH-5">#include "macros.h"</front>
<front id="thermistortablesH-6"></front>
<front id="thermistortablesH-7">#define OVERSAMPLENR 16</front>
<front id="thermistortablesH-8"></front>
<front id="thermistortablesH-9">#if (THERMISTORHEATER_0 == 1) || (THERMISTORHEATER_1 == 1)  || (THERMISTORHEATER_2 == 1) || (THERMISTORHEATER_3 == 1) || (THERMISTORBED == 1) //100k bed thermistor</front>
<front id="thermistortablesH-10"></front>
<front id="thermistortablesH-11">const short temptable_1[][2] PROGMEM = {</front>
<front id="thermistortablesH-12">{       23*OVERSAMPLENR ,       300     },</front>
<front id="thermistortablesH-13">{       25*OVERSAMPLENR ,       295     },</front>
<front id="thermistortablesH-14">{       27*OVERSAMPLENR ,       290     },</front>
<front id="thermistortablesH-15">{       28*OVERSAMPLENR ,       285     },</front>
<front id="thermistortablesH-16">{       31*OVERSAMPLENR ,       280     },</front>
<front id="thermistortablesH-17">{       33*OVERSAMPLENR ,       275     },</front>
<front id="thermistortablesH-18">{       35*OVERSAMPLENR ,       270     },</front>
<front id="thermistortablesH-19">{       38*OVERSAMPLENR ,       265     },</front>
<front id="thermistortablesH-20">{       41*OVERSAMPLENR ,       260     },</front>
<front id="thermistortablesH-21">{       44*OVERSAMPLENR ,       255     },</front>
<front id="thermistortablesH-22">{       48*OVERSAMPLENR ,       250     },</front>
<front id="thermistortablesH-23">{       52*OVERSAMPLENR ,       245     },</front>
<front id="thermistortablesH-24">{       56*OVERSAMPLENR ,       240     },</front>
<front id="thermistortablesH-25">{       61*OVERSAMPLENR ,       235     },</front>
<front id="thermistortablesH-26">{       66*OVERSAMPLENR ,       230     },</front>
<front id="thermistortablesH-27">{       71*OVERSAMPLENR ,       225     },</front>
<front id="thermistortablesH-28">{       78*OVERSAMPLENR ,       220     },</front>
<front id="thermistortablesH-29">{       84*OVERSAMPLENR ,       215     },</front>
<front id="thermistortablesH-30">{       92*OVERSAMPLENR ,       210     },</front>
<front id="thermistortablesH-31">{       100*OVERSAMPLENR        ,       205     },</front>
<front id="thermistortablesH-32">{       109*OVERSAMPLENR        ,       200     },</front>
<front id="thermistortablesH-33">{       120*OVERSAMPLENR        ,       195     },</front>
<front id="thermistortablesH-34">{       131*OVERSAMPLENR        ,       190     },</front>
<front id="thermistortablesH-35">{       143*OVERSAMPLENR        ,       185     },</front>
<front id="thermistortablesH-36">{       156*OVERSAMPLENR        ,       180     },</front>
<front id="thermistortablesH-37">{       171*OVERSAMPLENR        ,       175     },</front>
<front id="thermistortablesH-38">{       187*OVERSAMPLENR        ,       170     },</front>
<front id="thermistortablesH-39">{       205*OVERSAMPLENR        ,       165     },</front>
<front id="thermistortablesH-40">{       224*OVERSAMPLENR        ,       160     },</front>
<front id="thermistortablesH-41">{       245*OVERSAMPLENR        ,       155     },</front>
<front id="thermistortablesH-42">{       268*OVERSAMPLENR        ,       150     },</front>
<front id="thermistortablesH-43">{       293*OVERSAMPLENR        ,       145     },</front>
<front id="thermistortablesH-44">{       320*OVERSAMPLENR        ,       140     },</front>
<front id="thermistortablesH-45">{       348*OVERSAMPLENR        ,       135     },</front>
<front id="thermistortablesH-46">{       379*OVERSAMPLENR        ,       130     },</front>
<front id="thermistortablesH-47">{       411*OVERSAMPLENR        ,       125     },</front>
<front id="thermistortablesH-48">{       445*OVERSAMPLENR        ,       120     },</front>
<front id="thermistortablesH-49">{       480*OVERSAMPLENR        ,       115     },</front>
<front id="thermistortablesH-50">{       516*OVERSAMPLENR        ,       110     },</front>
<front id="thermistortablesH-51">{       553*OVERSAMPLENR        ,       105     },</front>
<front id="thermistortablesH-52">{       591*OVERSAMPLENR        ,       100     },</front>
<front id="thermistortablesH-53">{       628*OVERSAMPLENR        ,       95      },</front>
<front id="thermistortablesH-54">{       665*OVERSAMPLENR        ,       90      },</front>
<front id="thermistortablesH-55">{       702*OVERSAMPLENR        ,       85      },</front>
<front id="thermistortablesH-56">{       737*OVERSAMPLENR        ,       80      },</front>
<front id="thermistortablesH-57">{       770*OVERSAMPLENR        ,       75      },</front>
<front id="thermistortablesH-58">{       801*OVERSAMPLENR        ,       70      },</front>
<front id="thermistortablesH-59">{       830*OVERSAMPLENR        ,       65      },</front>
<front id="thermistortablesH-60">{       857*OVERSAMPLENR        ,       60      },</front>
<front id="thermistortablesH-61">{       881*OVERSAMPLENR        ,       55      },</front>
<front id="thermistortablesH-62">{       903*OVERSAMPLENR        ,       50      },</front>
<front id="thermistortablesH-63">{       922*OVERSAMPLENR        ,       45      },</front>
<front id="thermistortablesH-64">{       939*OVERSAMPLENR        ,       40      },</front>
<front id="thermistortablesH-65">{       954*OVERSAMPLENR        ,       35      },</front>
<front id="thermistortablesH-66">{       966*OVERSAMPLENR        ,       30      },</front>
<front id="thermistortablesH-67">{       977*OVERSAMPLENR        ,       25      },</front>
<front id="thermistortablesH-68">{       985*OVERSAMPLENR        ,       20      },</front>
<front id="thermistortablesH-69">{       993*OVERSAMPLENR        ,       15      },</front>
<front id="thermistortablesH-70">{       999*OVERSAMPLENR        ,       10      },</front>
<front id="thermistortablesH-71">{       1004*OVERSAMPLENR       ,       5       },</front>
<front id="thermistortablesH-72">{       1008*OVERSAMPLENR       ,       0       } //safety</front>
<front id="thermistortablesH-73">};</front>
<front id="thermistortablesH-74">#endif</front>
<front id="thermistortablesH-75">#if (THERMISTORHEATER_0 == 2) || (THERMISTORHEATER_1 == 2) || (THERMISTORHEATER_2 == 2) || (THERMISTORHEATER_3 == 2) || (THERMISTORBED == 2) //200k bed thermistor</front>
<front id="thermistortablesH-76">const short temptable_2[][2] PROGMEM = {</front>
<front id="thermistortablesH-77">//200k ATC Semitec 204GT-2</front>
<front id="thermistortablesH-78">//Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-79">// Calculated using 4.7kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-80">   {1*OVERSAMPLENR, 848},</front>
<front id="thermistortablesH-81">   {30*OVERSAMPLENR, 300}, //top rating 300C</front>
<front id="thermistortablesH-82">   {34*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-83">   {39*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-84">   {46*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-85">   {53*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-86">   {63*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-87">   {74*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-88">   {87*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-89">   {104*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-90">   {124*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-91">   {148*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-92">   {176*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-93">   {211*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-94">   {252*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-95">   {301*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-96">   {357*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-97">   {420*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-98">   {489*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-99">   {562*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-100">   {636*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-101">   {708*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-102">   {775*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-103">   {835*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-104">   {884*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-105">   {924*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-106">   {955*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-107">   {977*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-108">   {993*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-109">   {1004*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-110">   {1012*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-111">   {1016*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-112">};</front>
<front id="thermistortablesH-113"></front>
<front id="thermistortablesH-114">#endif</front>
<front id="thermistortablesH-115">#if (THERMISTORHEATER_0 == 3) || (THERMISTORHEATER_1 == 3) || (THERMISTORHEATER_2 == 3) || (THERMISTORHEATER_3 == 3) || (THERMISTORBED == 3) //mendel-parts</front>
<front id="thermistortablesH-116">const short temptable_3[][2] PROGMEM = {</front>
<front id="thermistortablesH-117">                {1*OVERSAMPLENR,864},</front>
<front id="thermistortablesH-118">                {21*OVERSAMPLENR,300},</front>
<front id="thermistortablesH-119">                {25*OVERSAMPLENR,290},</front>
<front id="thermistortablesH-120">                {29*OVERSAMPLENR,280},</front>
<front id="thermistortablesH-121">                {33*OVERSAMPLENR,270},</front>
<front id="thermistortablesH-122">                {39*OVERSAMPLENR,260},</front>
<front id="thermistortablesH-123">                {46*OVERSAMPLENR,250},</front>
<front id="thermistortablesH-124">                {54*OVERSAMPLENR,240},</front>
<front id="thermistortablesH-125">                {64*OVERSAMPLENR,230},</front>
<front id="thermistortablesH-126">                {75*OVERSAMPLENR,220},</front>
<front id="thermistortablesH-127">                {90*OVERSAMPLENR,210},</front>
<front id="thermistortablesH-128">                {107*OVERSAMPLENR,200},</front>
<front id="thermistortablesH-129">                {128*OVERSAMPLENR,190},</front>
<front id="thermistortablesH-130">                {154*OVERSAMPLENR,180},</front>
<front id="thermistortablesH-131">                {184*OVERSAMPLENR,170},</front>
<front id="thermistortablesH-132">                {221*OVERSAMPLENR,160},</front>
<front id="thermistortablesH-133">                {265*OVERSAMPLENR,150},</front>
<front id="thermistortablesH-134">                {316*OVERSAMPLENR,140},</front>
<front id="thermistortablesH-135">                {375*OVERSAMPLENR,130},</front>
<front id="thermistortablesH-136">                {441*OVERSAMPLENR,120},</front>
<front id="thermistortablesH-137">                {513*OVERSAMPLENR,110},</front>
<front id="thermistortablesH-138">                {588*OVERSAMPLENR,100},</front>
<front id="thermistortablesH-139">                {734*OVERSAMPLENR,80},</front>
<front id="thermistortablesH-140">                {856*OVERSAMPLENR,60},</front>
<front id="thermistortablesH-141">                {938*OVERSAMPLENR,40},</front>
<front id="thermistortablesH-142">                {986*OVERSAMPLENR,20},</front>
<front id="thermistortablesH-143">                {1008*OVERSAMPLENR,0},</front>
<front id="thermistortablesH-144">                {1018*OVERSAMPLENR,-20}</front>
<front id="thermistortablesH-145">        };</front>
<front id="thermistortablesH-146"></front>
<front id="thermistortablesH-147">#endif</front>
<front id="thermistortablesH-148">#if (THERMISTORHEATER_0 == 4) || (THERMISTORHEATER_1 == 4) || (THERMISTORHEATER_2 == 4) || (THERMISTORHEATER_3 == 4) || (THERMISTORBED == 4) //10k thermistor</front>
<front id="thermistortablesH-149">const short temptable_4[][2] PROGMEM = {</front>
<front id="thermistortablesH-150">   {1*OVERSAMPLENR, 430},</front>
<front id="thermistortablesH-151">   {54*OVERSAMPLENR, 137},</front>
<front id="thermistortablesH-152">   {107*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-153">   {160*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-154">   {213*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-155">   {266*OVERSAMPLENR, 71},</front>
<front id="thermistortablesH-156">   {319*OVERSAMPLENR, 64},</front>
<front id="thermistortablesH-157">   {372*OVERSAMPLENR, 57},</front>
<front id="thermistortablesH-158">   {425*OVERSAMPLENR, 51},</front>
<front id="thermistortablesH-159">   {478*OVERSAMPLENR, 46},</front>
<front id="thermistortablesH-160">   {531*OVERSAMPLENR, 41},</front>
<front id="thermistortablesH-161">   {584*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-162">   {637*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-163">   {690*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-164">   {743*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-165">   {796*OVERSAMPLENR, 14},</front>
<front id="thermistortablesH-166">   {849*OVERSAMPLENR, 7},</front>
<front id="thermistortablesH-167">   {902*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-168">   {955*OVERSAMPLENR, -11},</front>
<front id="thermistortablesH-169">   {1008*OVERSAMPLENR, -35}</front>
<front id="thermistortablesH-170">};</front>
<front id="thermistortablesH-171">#endif</front>
<front id="thermistortablesH-172"></front>
<front id="thermistortablesH-173">#if (THERMISTORHEATER_0 == 5) || (THERMISTORHEATER_1 == 5) || (THERMISTORHEATER_2 == 5) || (THERMISTORHEATER_3 == 5) || (THERMISTORBED == 5) //100k ParCan thermistor (104GT-2)</front>
<front id="thermistortablesH-174">const short temptable_5[][2] PROGMEM = {</front>
<front id="thermistortablesH-175">// ATC Semitec 104GT-2 (Used in ParCan)</front>
<front id="thermistortablesH-176">// Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-177">// Calculated using 4.7kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-178">   {1*OVERSAMPLENR, 713},</front>
<front id="thermistortablesH-179">   {17*OVERSAMPLENR, 300}, //top rating 300C</front>
<front id="thermistortablesH-180">   {20*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-181">   {23*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-182">   {27*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-183">   {31*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-184">   {37*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-185">   {43*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-186">   {51*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-187">   {61*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-188">   {73*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-189">   {87*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-190">   {106*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-191">   {128*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-192">   {155*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-193">   {189*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-194">   {230*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-195">   {278*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-196">   {336*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-197">   {402*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-198">   {476*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-199">   {554*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-200">   {635*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-201">   {713*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-202">   {784*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-203">   {846*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-204">   {897*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-205">   {937*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-206">   {966*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-207">   {986*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-208">   {1000*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-209">   {1010*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-210">};</front>
<front id="thermistortablesH-211">#endif</front>
<front id="thermistortablesH-212"></front>
<front id="thermistortablesH-213">#if (THERMISTORHEATER_0 == 6) || (THERMISTORHEATER_1 == 6) || (THERMISTORHEATER_2 == 6) || (THERMISTORHEATER_3 == 6) || (THERMISTORBED == 6) // 100k Epcos thermistor</front>
<front id="thermistortablesH-214">const short temptable_6[][2] PROGMEM = {</front>
<front id="thermistortablesH-215">   {1*OVERSAMPLENR, 350},</front>
<front id="thermistortablesH-216">   {28*OVERSAMPLENR, 250}, //top rating 250C</front>
<front id="thermistortablesH-217">   {31*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-218">   {35*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-219">   {39*OVERSAMPLENR, 235},</front>
<front id="thermistortablesH-220">   {42*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-221">   {44*OVERSAMPLENR, 225},</front>
<front id="thermistortablesH-222">   {49*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-223">   {53*OVERSAMPLENR, 215},</front>
<front id="thermistortablesH-224">   {62*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-225">   {71*OVERSAMPLENR, 205}, //fitted graphically</front>
<front id="thermistortablesH-226">   {78*OVERSAMPLENR, 200}, //fitted graphically</front>
<front id="thermistortablesH-227">   {94*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-228">   {102*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-229">   {116*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-230">   {143*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-231">   {183*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-232">   {223*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-233">   {270*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-234">   {318*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-235">   {383*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-236">   {413*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-237">   {439*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-238">   {484*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-239">   {513*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-240">   {607*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-241">   {664*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-242">   {781*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-243">   {810*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-244">   {849*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-245">   {914*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-246">   {914*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-247">   {935*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-248">   {954*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-249">   {970*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-250">   {978*OVERSAMPLENR, 22},</front>
<front id="thermistortablesH-251">   {1008*OVERSAMPLENR, 3},</front>
<front id="thermistortablesH-252">   {1023*OVERSAMPLENR, 0}  //to allow internal 0 degrees C</front>
<front id="thermistortablesH-253">};</front>
<front id="thermistortablesH-254">#endif</front>
<front id="thermistortablesH-255"></front>
<front id="thermistortablesH-256">#if (THERMISTORHEATER_0 == 7) || (THERMISTORHEATER_1 == 7) || (THERMISTORHEATER_2 == 7) || (THERMISTORHEATER_3 == 7) || (THERMISTORBED == 7) // 100k Honeywell 135-104LAG-J01</front>
<front id="thermistortablesH-257">const short temptable_7[][2] PROGMEM = {</front>
<front id="thermistortablesH-258">   {1*OVERSAMPLENR, 941},</front>
<front id="thermistortablesH-259">   {19*OVERSAMPLENR, 362},</front>
<front id="thermistortablesH-260">   {37*OVERSAMPLENR, 299}, //top rating 300C</front>
<front id="thermistortablesH-261">   {55*OVERSAMPLENR, 266},</front>
<front id="thermistortablesH-262">   {73*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-263">   {91*OVERSAMPLENR, 229},</front>
<front id="thermistortablesH-264">   {109*OVERSAMPLENR, 216},</front>
<front id="thermistortablesH-265">   {127*OVERSAMPLENR, 206},</front>
<front id="thermistortablesH-266">   {145*OVERSAMPLENR, 197},</front>
<front id="thermistortablesH-267">   {163*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-268">   {181*OVERSAMPLENR, 183},</front>
<front id="thermistortablesH-269">   {199*OVERSAMPLENR, 177},</front>
<front id="thermistortablesH-270">   {217*OVERSAMPLENR, 171},</front>
<front id="thermistortablesH-271">   {235*OVERSAMPLENR, 166},</front>
<front id="thermistortablesH-272">   {253*OVERSAMPLENR, 162},</front>
<front id="thermistortablesH-273">   {271*OVERSAMPLENR, 157},</front>
<front id="thermistortablesH-274">   {289*OVERSAMPLENR, 153},</front>
<front id="thermistortablesH-275">   {307*OVERSAMPLENR, 149},</front>
<front id="thermistortablesH-276">   {325*OVERSAMPLENR, 146},</front>
<front id="thermistortablesH-277">   {343*OVERSAMPLENR, 142},</front>
<front id="thermistortablesH-278">   {361*OVERSAMPLENR, 139},</front>
<front id="thermistortablesH-279">   {379*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-280">   {397*OVERSAMPLENR, 132},</front>
<front id="thermistortablesH-281">   {415*OVERSAMPLENR, 129},</front>
<front id="thermistortablesH-282">   {433*OVERSAMPLENR, 126},</front>
<front id="thermistortablesH-283">   {451*OVERSAMPLENR, 123},</front>
<front id="thermistortablesH-284">   {469*OVERSAMPLENR, 121},</front>
<front id="thermistortablesH-285">   {487*OVERSAMPLENR, 118},</front>
<front id="thermistortablesH-286">   {505*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-287">   {523*OVERSAMPLENR, 112},</front>
<front id="thermistortablesH-288">   {541*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-289">   {559*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-290">   {577*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-291">   {595*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-292">   {613*OVERSAMPLENR, 99},</front>
<front id="thermistortablesH-293">   {631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-294">   {649*OVERSAMPLENR, 94},</front>
<front id="thermistortablesH-295">   {667*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-296">   {685*OVERSAMPLENR, 89},</front>
<front id="thermistortablesH-297">   {703*OVERSAMPLENR, 86},</front>
<front id="thermistortablesH-298">   {721*OVERSAMPLENR, 84},</front>
<front id="thermistortablesH-299">   {739*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-300">   {757*OVERSAMPLENR, 78},</front>
<front id="thermistortablesH-301">   {775*OVERSAMPLENR, 75},</front>
<front id="thermistortablesH-302">   {793*OVERSAMPLENR, 72},</front>
<front id="thermistortablesH-303">   {811*OVERSAMPLENR, 69},</front>
<front id="thermistortablesH-304">   {829*OVERSAMPLENR, 66},</front>
<front id="thermistortablesH-305">   {847*OVERSAMPLENR, 62},</front>
<front id="thermistortablesH-306">   {865*OVERSAMPLENR, 59},</front>
<front id="thermistortablesH-307">   {883*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-308">   {901*OVERSAMPLENR, 51},</front>
<front id="thermistortablesH-309">   {919*OVERSAMPLENR, 46},</front>
<front id="thermistortablesH-310">   {937*OVERSAMPLENR, 41},</front>
<front id="thermistortablesH-311">   {955*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-312">   {973*OVERSAMPLENR, 27},</front>
<front id="thermistortablesH-313">   {991*OVERSAMPLENR, 17},</front>
<front id="thermistortablesH-314">   {1009*OVERSAMPLENR, 1},</front>
<front id="thermistortablesH-315">   {1023*OVERSAMPLENR, 0}  //to allow internal 0 degrees C</front>
<front id="thermistortablesH-316">};</front>
<front id="thermistortablesH-317">#endif</front>
<front id="thermistortablesH-318"></front>
<front id="thermistortablesH-319">#if (THERMISTORHEATER_0 == 71) || (THERMISTORHEATER_1 == 71) || (THERMISTORHEATER_2 == 71) || (THERMISTORHEATER_3 == 71) || (THERMISTORBED == 71) // 100k Honeywell 135-104LAF-J01</front>
<front id="thermistortablesH-320">// R0 = 100000 Ohm</front>
<front id="thermistortablesH-321">// T0 = 25 C</front>
<front id="thermistortablesH-322">// Beta = 3974</front>
<front id="thermistortablesH-323">// R1 = 0 Ohm</front>
<front id="thermistortablesH-324">// R2 = 4700 Ohm</front>
<front id="thermistortablesH-325">const short temptable_71[][2] PROGMEM = {</front>
<front id="thermistortablesH-326">   {35*OVERSAMPLENR, 300},</front>
<front id="thermistortablesH-327">   {51*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-328">   {54*OVERSAMPLENR, 265},</front>
<front id="thermistortablesH-329">   {58*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-330">   {59*OVERSAMPLENR, 258},</front>
<front id="thermistortablesH-331">   {61*OVERSAMPLENR, 256},</front>
<front id="thermistortablesH-332">   {63*OVERSAMPLENR, 254},</front>
<front id="thermistortablesH-333">   {64*OVERSAMPLENR, 252},</front>
<front id="thermistortablesH-334">   {66*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-335">   {67*OVERSAMPLENR, 249},</front>
<front id="thermistortablesH-336">   {68*OVERSAMPLENR, 248},</front>
<front id="thermistortablesH-337">   {69*OVERSAMPLENR, 247},</front>
<front id="thermistortablesH-338">   {70*OVERSAMPLENR, 246},</front>
<front id="thermistortablesH-339">   {71*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-340">   {72*OVERSAMPLENR, 244},</front>
<front id="thermistortablesH-341">   {73*OVERSAMPLENR, 243},</front>
<front id="thermistortablesH-342">   {74*OVERSAMPLENR, 242},</front>
<front id="thermistortablesH-343">   {75*OVERSAMPLENR, 241},</front>
<front id="thermistortablesH-344">   {76*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-345">   {77*OVERSAMPLENR, 239},</front>
<front id="thermistortablesH-346">   {78*OVERSAMPLENR, 238},</front>
<front id="thermistortablesH-347">   {79*OVERSAMPLENR, 237},</front>
<front id="thermistortablesH-348">   {80*OVERSAMPLENR, 236},</front>
<front id="thermistortablesH-349">   {81*OVERSAMPLENR, 235},</front>
<front id="thermistortablesH-350">   {82*OVERSAMPLENR, 234},</front>
<front id="thermistortablesH-351">   {84*OVERSAMPLENR, 233},</front>
<front id="thermistortablesH-352">   {85*OVERSAMPLENR, 232},</front>
<front id="thermistortablesH-353">   {86*OVERSAMPLENR, 231},</front>
<front id="thermistortablesH-354">   {87*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-355">   {89*OVERSAMPLENR, 229},</front>
<front id="thermistortablesH-356">   {90*OVERSAMPLENR, 228},</front>
<front id="thermistortablesH-357">   {91*OVERSAMPLENR, 227},</front>
<front id="thermistortablesH-358">   {92*OVERSAMPLENR, 226},</front>
<front id="thermistortablesH-359">   {94*OVERSAMPLENR, 225},</front>
<front id="thermistortablesH-360">   {95*OVERSAMPLENR, 224},</front>
<front id="thermistortablesH-361">   {97*OVERSAMPLENR, 223},</front>
<front id="thermistortablesH-362">   {98*OVERSAMPLENR, 222},</front>
<front id="thermistortablesH-363">   {99*OVERSAMPLENR, 221},</front>
<front id="thermistortablesH-364">   {101*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-365">   {102*OVERSAMPLENR, 219},</front>
<front id="thermistortablesH-366">   {104*OVERSAMPLENR, 218},</front>
<front id="thermistortablesH-367">   {106*OVERSAMPLENR, 217},</front>
<front id="thermistortablesH-368">   {107*OVERSAMPLENR, 216},</front>
<front id="thermistortablesH-369">   {109*OVERSAMPLENR, 215},</front>
<front id="thermistortablesH-370">   {110*OVERSAMPLENR, 214},</front>
<front id="thermistortablesH-371">   {112*OVERSAMPLENR, 213},</front>
<front id="thermistortablesH-372">   {114*OVERSAMPLENR, 212},</front>
<front id="thermistortablesH-373">   {115*OVERSAMPLENR, 211},</front>
<front id="thermistortablesH-374">   {117*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-375">   {119*OVERSAMPLENR, 209},</front>
<front id="thermistortablesH-376">   {121*OVERSAMPLENR, 208},</front>
<front id="thermistortablesH-377">   {123*OVERSAMPLENR, 207},</front>
<front id="thermistortablesH-378">   {125*OVERSAMPLENR, 206},</front>
<front id="thermistortablesH-379">   {126*OVERSAMPLENR, 205},</front>
<front id="thermistortablesH-380">   {128*OVERSAMPLENR, 204},</front>
<front id="thermistortablesH-381">   {130*OVERSAMPLENR, 203},</front>
<front id="thermistortablesH-382">   {132*OVERSAMPLENR, 202},</front>
<front id="thermistortablesH-383">   {134*OVERSAMPLENR, 201},</front>
<front id="thermistortablesH-384">   {136*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-385">   {139*OVERSAMPLENR, 199},</front>
<front id="thermistortablesH-386">   {141*OVERSAMPLENR, 198},</front>
<front id="thermistortablesH-387">   {143*OVERSAMPLENR, 197},</front>
<front id="thermistortablesH-388">   {145*OVERSAMPLENR, 196},</front>
<front id="thermistortablesH-389">   {147*OVERSAMPLENR, 195},</front>
<front id="thermistortablesH-390">   {150*OVERSAMPLENR, 194},</front>
<front id="thermistortablesH-391">   {152*OVERSAMPLENR, 193},</front>
<front id="thermistortablesH-392">   {154*OVERSAMPLENR, 192},</front>
<front id="thermistortablesH-393">   {157*OVERSAMPLENR, 191},</front>
<front id="thermistortablesH-394">   {159*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-395">   {162*OVERSAMPLENR, 189},</front>
<front id="thermistortablesH-396">   {164*OVERSAMPLENR, 188},</front>
<front id="thermistortablesH-397">   {167*OVERSAMPLENR, 187},</front>
<front id="thermistortablesH-398">   {170*OVERSAMPLENR, 186},</front>
<front id="thermistortablesH-399">   {172*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-400">   {175*OVERSAMPLENR, 184},</front>
<front id="thermistortablesH-401">   {178*OVERSAMPLENR, 183},</front>
<front id="thermistortablesH-402">   {181*OVERSAMPLENR, 182},</front>
<front id="thermistortablesH-403">   {184*OVERSAMPLENR, 181},</front>
<front id="thermistortablesH-404">   {187*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-405">   {190*OVERSAMPLENR, 179},</front>
<front id="thermistortablesH-406">   {193*OVERSAMPLENR, 178},</front>
<front id="thermistortablesH-407">   {196*OVERSAMPLENR, 177},</front>
<front id="thermistortablesH-408">   {199*OVERSAMPLENR, 176},</front>
<front id="thermistortablesH-409">   {202*OVERSAMPLENR, 175},</front>
<front id="thermistortablesH-410">   {205*OVERSAMPLENR, 174},</front>
<front id="thermistortablesH-411">   {208*OVERSAMPLENR, 173},</front>
<front id="thermistortablesH-412">   {212*OVERSAMPLENR, 172},</front>
<front id="thermistortablesH-413">   {215*OVERSAMPLENR, 171},</front>
<front id="thermistortablesH-414">   {219*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-415">   {237*OVERSAMPLENR, 165},</front>
<front id="thermistortablesH-416">   {256*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-417">   {300*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-418">   {351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-419">   {470*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-420">   {504*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-421">   {538*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-422">   {552*OVERSAMPLENR, 108},</front>
<front id="thermistortablesH-423">   {566*OVERSAMPLENR, 106},</front>
<front id="thermistortablesH-424">   {580*OVERSAMPLENR, 104},</front>
<front id="thermistortablesH-425">   {594*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-426">   {608*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-427">   {622*OVERSAMPLENR, 98},</front>
<front id="thermistortablesH-428">   {636*OVERSAMPLENR, 96},</front>
<front id="thermistortablesH-429">   {650*OVERSAMPLENR, 94},</front>
<front id="thermistortablesH-430">   {664*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-431">   {678*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-432">   {712*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-433">   {745*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-434">   {758*OVERSAMPLENR, 78},</front>
<front id="thermistortablesH-435">   {770*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-436">   {783*OVERSAMPLENR, 74},</front>
<front id="thermistortablesH-437">   {795*OVERSAMPLENR, 72},</front>
<front id="thermistortablesH-438">   {806*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-439">   {818*OVERSAMPLENR, 68},</front>
<front id="thermistortablesH-440">   {829*OVERSAMPLENR, 66},</front>
<front id="thermistortablesH-441">   {840*OVERSAMPLENR, 64},</front>
<front id="thermistortablesH-442">   {850*OVERSAMPLENR, 62},</front>
<front id="thermistortablesH-443">   {860*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-444">   {870*OVERSAMPLENR, 58},</front>
<front id="thermistortablesH-445">   {879*OVERSAMPLENR, 56},</front>
<front id="thermistortablesH-446">   {888*OVERSAMPLENR, 54},</front>
<front id="thermistortablesH-447">   {897*OVERSAMPLENR, 52},</front>
<front id="thermistortablesH-448">   {905*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-449">   {924*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-450">   {940*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-451">   {955*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-452">   {967*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-453">   {970*OVERSAMPLENR, 29},</front>
<front id="thermistortablesH-454">   {972*OVERSAMPLENR, 28},</front>
<front id="thermistortablesH-455">   {974*OVERSAMPLENR, 27},</front>
<front id="thermistortablesH-456">   {976*OVERSAMPLENR, 26},</front>
<front id="thermistortablesH-457">   {978*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-458">   {980*OVERSAMPLENR, 24},</front>
<front id="thermistortablesH-459">   {982*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-460">   {984*OVERSAMPLENR, 22},</front>
<front id="thermistortablesH-461">   {985*OVERSAMPLENR, 21},</front>
<front id="thermistortablesH-462">   {987*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-463">   {995*OVERSAMPLENR, 15},</front>
<front id="thermistortablesH-464">   {1001*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-465">   {1006*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-466">   {1010*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-467">};</front>
<front id="thermistortablesH-468">#endif</front>
<front id="thermistortablesH-469"></front>
<front id="thermistortablesH-470">#if (THERMISTORHEATER_0 == 8) || (THERMISTORHEATER_1 == 8) || (THERMISTORHEATER_2 == 8) || (THERMISTORHEATER_3 == 8) || (THERMISTORBED == 8)</front>
<front id="thermistortablesH-471">// 100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup)</front>
<front id="thermistortablesH-472">const short temptable_8[][2] PROGMEM = {</front>
<front id="thermistortablesH-473">   {1*OVERSAMPLENR, 704},</front>
<front id="thermistortablesH-474">   {54*OVERSAMPLENR, 216},</front>
<front id="thermistortablesH-475">   {107*OVERSAMPLENR, 175},</front>
<front id="thermistortablesH-476">   {160*OVERSAMPLENR, 152},</front>
<front id="thermistortablesH-477">   {213*OVERSAMPLENR, 137},</front>
<front id="thermistortablesH-478">   {266*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-479">   {319*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-480">   {372*OVERSAMPLENR, 106},</front>
<front id="thermistortablesH-481">   {425*OVERSAMPLENR, 99},</front>
<front id="thermistortablesH-482">   {478*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-483">   {531*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-484">   {584*OVERSAMPLENR, 78},</front>
<front id="thermistortablesH-485">   {637*OVERSAMPLENR, 71},</front>
<front id="thermistortablesH-486">   {690*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-487">   {743*OVERSAMPLENR, 58},</front>
<front id="thermistortablesH-488">   {796*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-489">   {849*OVERSAMPLENR, 42},</front>
<front id="thermistortablesH-490">   {902*OVERSAMPLENR, 31},</front>
<front id="thermistortablesH-491">   {955*OVERSAMPLENR, 17},</front>
<front id="thermistortablesH-492">   {1008*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-493">};</front>
<front id="thermistortablesH-494">#endif</front>
<front id="thermistortablesH-495">#if (THERMISTORHEATER_0 == 9) || (THERMISTORHEATER_1 == 9) || (THERMISTORHEATER_2 == 9) || (THERMISTORHEATER_3 == 9) || (THERMISTORBED == 9)</front>
<front id="thermistortablesH-496">// 100k GE Sensing AL03006-58.2K-97-G1 (4.7k pullup)</front>
<front id="thermistortablesH-497">const short temptable_9[][2] PROGMEM = {</front>
<front id="thermistortablesH-498">	{1*OVERSAMPLENR, 936},</front>
<front id="thermistortablesH-499">	{36*OVERSAMPLENR, 300},</front>
<front id="thermistortablesH-500">	{71*OVERSAMPLENR, 246},</front>
<front id="thermistortablesH-501">	{106*OVERSAMPLENR, 218},</front>
<front id="thermistortablesH-502">	{141*OVERSAMPLENR, 199},</front>
<front id="thermistortablesH-503">	{176*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-504">	{211*OVERSAMPLENR, 173},</front>
<front id="thermistortablesH-505">	{246*OVERSAMPLENR, 163},</front>
<front id="thermistortablesH-506">	{281*OVERSAMPLENR, 155},</front>
<front id="thermistortablesH-507">	{316*OVERSAMPLENR, 147},</front>
<front id="thermistortablesH-508">	{351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-509">	{386*OVERSAMPLENR, 134},</front>
<front id="thermistortablesH-510">	{421*OVERSAMPLENR, 128},</front>
<front id="thermistortablesH-511">	{456*OVERSAMPLENR, 122},</front>
<front id="thermistortablesH-512">	{491*OVERSAMPLENR, 117},</front>
<front id="thermistortablesH-513">	{526*OVERSAMPLENR, 112},</front>
<front id="thermistortablesH-514">	{561*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-515">	{596*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-516">	{631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-517">	{666*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-518">	{701*OVERSAMPLENR, 87},</front>
<front id="thermistortablesH-519">	{736*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-520">	{771*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-521">	{806*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-522">	{841*OVERSAMPLENR, 63},</front>
<front id="thermistortablesH-523">	{876*OVERSAMPLENR, 56},</front>
<front id="thermistortablesH-524">	{911*OVERSAMPLENR, 48},</front>
<front id="thermistortablesH-525">	{946*OVERSAMPLENR, 38},</front>
<front id="thermistortablesH-526">	{981*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-527">	{1005*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-528">	{1016*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-529">};</front>
<front id="thermistortablesH-530">#endif</front>
<front id="thermistortablesH-531">#if (THERMISTORHEATER_0 == 10) || (THERMISTORHEATER_1 == 10) || (THERMISTORHEATER_2 == 10) || (THERMISTORHEATER_3 == 10) || (THERMISTORBED == 10)</front>
<front id="thermistortablesH-532">// 100k RS thermistor 198-961 (4.7k pullup)</front>
<front id="thermistortablesH-533">const short temptable_10[][2] PROGMEM = {</front>
<front id="thermistortablesH-534">   {1*OVERSAMPLENR, 929},</front>
<front id="thermistortablesH-535">   {36*OVERSAMPLENR, 299},</front>
<front id="thermistortablesH-536">   {71*OVERSAMPLENR, 246},</front>
<front id="thermistortablesH-537">   {106*OVERSAMPLENR, 217},</front>
<front id="thermistortablesH-538">   {141*OVERSAMPLENR, 198},</front>
<front id="thermistortablesH-539">   {176*OVERSAMPLENR, 184},</front>
<front id="thermistortablesH-540">   {211*OVERSAMPLENR, 173},</front>
<front id="thermistortablesH-541">   {246*OVERSAMPLENR, 163},</front>
<front id="thermistortablesH-542">   {281*OVERSAMPLENR, 154},</front>
<front id="thermistortablesH-543">   {316*OVERSAMPLENR, 147},</front>
<front id="thermistortablesH-544">   {351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-545">   {386*OVERSAMPLENR, 134},</front>
<front id="thermistortablesH-546">   {421*OVERSAMPLENR, 128},</front>
<front id="thermistortablesH-547">   {456*OVERSAMPLENR, 122},</front>
<front id="thermistortablesH-548">   {491*OVERSAMPLENR, 117},</front>
<front id="thermistortablesH-549">   {526*OVERSAMPLENR, 112},</front>
<front id="thermistortablesH-550">   {561*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-551">   {596*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-552">   {631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-553">   {666*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-554">   {701*OVERSAMPLENR, 86},</front>
<front id="thermistortablesH-555">   {736*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-556">   {771*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-557">   {806*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-558">   {841*OVERSAMPLENR, 63},</front>
<front id="thermistortablesH-559">   {876*OVERSAMPLENR, 56},</front>
<front id="thermistortablesH-560">   {911*OVERSAMPLENR, 48},</front>
<front id="thermistortablesH-561">   {946*OVERSAMPLENR, 38},</front>
<front id="thermistortablesH-562">   {981*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-563">   {1005*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-564">   {1016*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-565">};</front>
<front id="thermistortablesH-566">#endif</front>
<front id="thermistortablesH-567"></front>
<front id="thermistortablesH-568">#if (THERMISTORHEATER_0 == 11) || (THERMISTORHEATER_1 == 11) || (THERMISTORHEATER_2 == 11) || (THERMISTORHEATER_3 == 11) || (THERMISTORBED == 11) </front>
<front id="thermistortablesH-569">// QU-BD silicone bed QWG-104F-3950 thermistor</front>
<front id="thermistortablesH-570"></front>
<front id="thermistortablesH-571">const short temptable_11[][2] PROGMEM = {</front>
<front id="thermistortablesH-572">         {1*OVERSAMPLENR,        938},</front>
<front id="thermistortablesH-573">         {31*OVERSAMPLENR,       314},</front>
<front id="thermistortablesH-574">         {41*OVERSAMPLENR,       290},</front>
<front id="thermistortablesH-575">         {51*OVERSAMPLENR,       272},</front>
<front id="thermistortablesH-576">         {61*OVERSAMPLENR,       258},</front>
<front id="thermistortablesH-577">         {71*OVERSAMPLENR,       247},</front>
<front id="thermistortablesH-578">         {81*OVERSAMPLENR,       237},</front>
<front id="thermistortablesH-579">         {91*OVERSAMPLENR,       229},</front>
<front id="thermistortablesH-580">         {101*OVERSAMPLENR,      221},</front>
<front id="thermistortablesH-581">         {111*OVERSAMPLENR,      215},</front>
<front id="thermistortablesH-582">         {121*OVERSAMPLENR,      209},</front>
<front id="thermistortablesH-583">         {131*OVERSAMPLENR,      204},</front>
<front id="thermistortablesH-584">         {141*OVERSAMPLENR,      199},</front>
<front id="thermistortablesH-585">         {151*OVERSAMPLENR,      195},</front>
<front id="thermistortablesH-586">         {161*OVERSAMPLENR,      190},</front>
<front id="thermistortablesH-587">         {171*OVERSAMPLENR,      187},</front>
<front id="thermistortablesH-588">         {181*OVERSAMPLENR,      183},</front>
<front id="thermistortablesH-589">         {191*OVERSAMPLENR,      179},</front>
<front id="thermistortablesH-590">         {201*OVERSAMPLENR,      176},</front>
<front id="thermistortablesH-591">         {221*OVERSAMPLENR,      170},</front>
<front id="thermistortablesH-592">         {241*OVERSAMPLENR,      165},</front>
<front id="thermistortablesH-593">         {261*OVERSAMPLENR,      160},</front>
<front id="thermistortablesH-594">         {281*OVERSAMPLENR,      155},</front>
<front id="thermistortablesH-595">         {301*OVERSAMPLENR,      150},</front>
<front id="thermistortablesH-596">         {331*OVERSAMPLENR,      144},</front>
<front id="thermistortablesH-597">         {361*OVERSAMPLENR,      139},</front>
<front id="thermistortablesH-598">         {391*OVERSAMPLENR,      133},</front>
<front id="thermistortablesH-599">         {421*OVERSAMPLENR,      128},</front>
<front id="thermistortablesH-600">         {451*OVERSAMPLENR,      123},</front>
<front id="thermistortablesH-601">         {491*OVERSAMPLENR,      117},</front>
<front id="thermistortablesH-602">         {531*OVERSAMPLENR,      111},</front>
<front id="thermistortablesH-603">         {571*OVERSAMPLENR,      105},</front>
<front id="thermistortablesH-604">         {611*OVERSAMPLENR,      100},</front>
<front id="thermistortablesH-605">         {641*OVERSAMPLENR,      95},</front>
<front id="thermistortablesH-606">         {681*OVERSAMPLENR,      90},</front>
<front id="thermistortablesH-607">         {711*OVERSAMPLENR,      85},</front>
<front id="thermistortablesH-608">         {751*OVERSAMPLENR,      79},</front>
<front id="thermistortablesH-609">         {791*OVERSAMPLENR,      72},</front>
<front id="thermistortablesH-610">         {811*OVERSAMPLENR,      69},</front>
<front id="thermistortablesH-611">         {831*OVERSAMPLENR,      65},</front>
<front id="thermistortablesH-612">         {871*OVERSAMPLENR,      57},</front>
<front id="thermistortablesH-613">         {881*OVERSAMPLENR,      55},</front>
<front id="thermistortablesH-614">         {901*OVERSAMPLENR,      51},</front>
<front id="thermistortablesH-615">         {921*OVERSAMPLENR,      45},</front>
<front id="thermistortablesH-616">         {941*OVERSAMPLENR,      39},</front>
<front id="thermistortablesH-617">         {971*OVERSAMPLENR,      28},</front>
<front id="thermistortablesH-618">         {981*OVERSAMPLENR,      23},</front>
<front id="thermistortablesH-619">         {991*OVERSAMPLENR,      17},</front>
<front id="thermistortablesH-620">         {1001*OVERSAMPLENR,     9},</front>
<front id="thermistortablesH-621">         {1021*OVERSAMPLENR,     -27}</front>
<front id="thermistortablesH-622">};</front>
<front id="thermistortablesH-623">#endif</front>
<front id="thermistortablesH-624"></front>
<front id="thermistortablesH-625">#if (THERMISTORHEATER_0 == 13) || (THERMISTORHEATER_1 == 13) || (THERMISTORHEATER_2 == 13) || (THERMISTORHEATER_3 == 13) || (THERMISTORBED == 13)</front>
<front id="thermistortablesH-626">// Hisens thermistor B25/50 =3950 +/-1%</front>
<front id="thermistortablesH-627"></front>
<front id="thermistortablesH-628">const short temptable_13[][2] PROGMEM = {</front>
<front id="thermistortablesH-629"> {	20.04*OVERSAMPLENR,	300	},</front>
<front id="thermistortablesH-630">{	23.19*OVERSAMPLENR,	290	},</front>
<front id="thermistortablesH-631">{	26.71*OVERSAMPLENR,	280	},</front>
<front id="thermistortablesH-632">{	31.23*OVERSAMPLENR,	270	},</front>
<front id="thermistortablesH-633">{	36.52*OVERSAMPLENR,	260	},</front>
<front id="thermistortablesH-634">{	42.75*OVERSAMPLENR,	250	},</front>
<front id="thermistortablesH-635">{	50.68*OVERSAMPLENR,	240	},</front>
<front id="thermistortablesH-636">{	60.22*OVERSAMPLENR,	230	},</front>
<front id="thermistortablesH-637">{	72.03*OVERSAMPLENR,	220	},</front>
<front id="thermistortablesH-638">{	86.84*OVERSAMPLENR,	210	},</front>
<front id="thermistortablesH-639">{	102.79*OVERSAMPLENR, 200 },</front>
<front id="thermistortablesH-640">{	124.46*OVERSAMPLENR, 190 },</front>
<front id="thermistortablesH-641">{	151.02*OVERSAMPLENR, 180 },</front>
<front id="thermistortablesH-642">{	182.86*OVERSAMPLENR, 170 },</front>
<front id="thermistortablesH-643">{	220.72*OVERSAMPLENR, 160 },</front>
<front id="thermistortablesH-644">{	316.96*OVERSAMPLENR, 140 },</front>
<front id="thermistortablesH-645">{	447.17*OVERSAMPLENR, 120 },</front>
<front id="thermistortablesH-646">{	590.61*OVERSAMPLENR, 100 },</front>
<front id="thermistortablesH-647">{	737.31*OVERSAMPLENR, 80	},</front>
<front id="thermistortablesH-648">{	857.77*OVERSAMPLENR, 60	},</front>
<front id="thermistortablesH-649">{	939.52*OVERSAMPLENR, 40	},</front>
<front id="thermistortablesH-650">{	986.03*OVERSAMPLENR, 20	},</front>
<front id="thermistortablesH-651">{	1008.7*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-652"></front>
<front id="thermistortablesH-653">};</front>
<front id="thermistortablesH-654">#endif</front>
<front id="thermistortablesH-655"></front>
<front id="thermistortablesH-656">#if (THERMISTORHEATER_0 == 20) || (THERMISTORHEATER_1 == 20) || (THERMISTORHEATER_2 == 20) || (THERMISTORBED == 20) // PT100 with INA826 amp on Ultimaker v2.0 electronics</front>
<front id="thermistortablesH-657">/* The PT100 in the Ultimaker v2.0 electronics has a high sample value for a high temperature.</front>
<front id="thermistortablesH-658">This does not match the normal thermistor behaviour so we need to set the following defines */</front>
<front id="thermistortablesH-659">#if (THERMISTORHEATER_0 == 20)</front>
<front id="thermistortablesH-660"># define HEATER_0_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-661"># define HEATER_0_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-662">#endif</front>
<front id="thermistortablesH-663">#if (THERMISTORHEATER_1 == 20)</front>
<front id="thermistortablesH-664"># define HEATER_1_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-665"># define HEATER_1_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-666">#endif</front>
<front id="thermistortablesH-667">#if (THERMISTORHEATER_2 == 20)</front>
<front id="thermistortablesH-668"># define HEATER_2_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-669"># define HEATER_2_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-670">#endif</front>
<front id="thermistortablesH-671">#if (THERMISTORHEATER_3 == 20)</front>
<front id="thermistortablesH-672"># define HEATER_3_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-673"># define HEATER_3_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-674">#endif</front>
<front id="thermistortablesH-675">#if (THERMISTORBED == 20)</front>
<front id="thermistortablesH-676"># define HEATER_BED_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-677"># define HEATER_BED_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-678">#endif</front>
<front id="thermistortablesH-679">const short temptable_20[][2] PROGMEM = {</front>
<front id="thermistortablesH-680">{         0*OVERSAMPLENR ,       0     },</front>
<front id="thermistortablesH-681">{       227*OVERSAMPLENR ,       1     },</front>
<front id="thermistortablesH-682">{       236*OVERSAMPLENR ,       10     },</front>
<front id="thermistortablesH-683">{       245*OVERSAMPLENR ,       20     },</front>
<front id="thermistortablesH-684">{       253*OVERSAMPLENR ,       30     },</front>
<front id="thermistortablesH-685">{       262*OVERSAMPLENR ,       40     },</front>
<front id="thermistortablesH-686">{       270*OVERSAMPLENR ,       50     },</front>
<front id="thermistortablesH-687">{       279*OVERSAMPLENR ,       60     },</front>
<front id="thermistortablesH-688">{       287*OVERSAMPLENR ,       70     },</front>
<front id="thermistortablesH-689">{       295*OVERSAMPLENR ,       80     },</front>
<front id="thermistortablesH-690">{       304*OVERSAMPLENR ,       90     },</front>
<front id="thermistortablesH-691">{       312*OVERSAMPLENR ,       100     },</front>
<front id="thermistortablesH-692">{       320*OVERSAMPLENR ,       110     },</front>
<front id="thermistortablesH-693">{       329*OVERSAMPLENR ,       120     },</front>
<front id="thermistortablesH-694">{       337*OVERSAMPLENR ,       130     },</front>
<front id="thermistortablesH-695">{       345*OVERSAMPLENR ,       140     },</front>
<front id="thermistortablesH-696">{       353*OVERSAMPLENR ,       150     },</front>
<front id="thermistortablesH-697">{       361*OVERSAMPLENR ,       160     },</front>
<front id="thermistortablesH-698">{       369*OVERSAMPLENR ,       170     },</front>
<front id="thermistortablesH-699">{       377*OVERSAMPLENR ,       180     },</front>
<front id="thermistortablesH-700">{       385*OVERSAMPLENR ,       190     },</front>
<front id="thermistortablesH-701">{       393*OVERSAMPLENR ,       200     },</front>
<front id="thermistortablesH-702">{       401*OVERSAMPLENR ,       210     },</front>
<front id="thermistortablesH-703">{       409*OVERSAMPLENR ,       220     },</front>
<front id="thermistortablesH-704">{       417*OVERSAMPLENR ,       230     },</front>
<front id="thermistortablesH-705">{       424*OVERSAMPLENR ,       240     },</front>
<front id="thermistortablesH-706">{       432*OVERSAMPLENR ,       250     },</front>
<front id="thermistortablesH-707">{       440*OVERSAMPLENR ,       260     },</front>
<front id="thermistortablesH-708">{       447*OVERSAMPLENR ,       270     },</front>
<front id="thermistortablesH-709">{       455*OVERSAMPLENR ,       280     },</front>
<front id="thermistortablesH-710">{       463*OVERSAMPLENR ,       290     },</front>
<front id="thermistortablesH-711">{       470*OVERSAMPLENR ,       300     },</front>
<front id="thermistortablesH-712">{       478*OVERSAMPLENR ,       310     },</front>
<front id="thermistortablesH-713">{       485*OVERSAMPLENR ,       320     },</front>
<front id="thermistortablesH-714">{       493*OVERSAMPLENR ,       330     },</front>
<front id="thermistortablesH-715">{       500*OVERSAMPLENR ,       340     },</front>
<front id="thermistortablesH-716">{       507*OVERSAMPLENR ,       350     },</front>
<front id="thermistortablesH-717">{       515*OVERSAMPLENR ,       360     },</front>
<front id="thermistortablesH-718">{       522*OVERSAMPLENR ,       370     },</front>
<front id="thermistortablesH-719">{       529*OVERSAMPLENR ,       380     },</front>
<front id="thermistortablesH-720">{       537*OVERSAMPLENR ,       390     },</front>
<front id="thermistortablesH-721">{       544*OVERSAMPLENR ,       400     },</front>
<front id="thermistortablesH-722">{       614*OVERSAMPLENR ,       500     },</front>
<front id="thermistortablesH-723">{       681*OVERSAMPLENR ,       600     },</front>
<front id="thermistortablesH-724">{       744*OVERSAMPLENR ,       700     },</front>
<front id="thermistortablesH-725">{       805*OVERSAMPLENR ,       800     },</front>
<front id="thermistortablesH-726">{       862*OVERSAMPLENR ,       900     },</front>
<front id="thermistortablesH-727">{       917*OVERSAMPLENR ,       1000     },</front>
<front id="thermistortablesH-728">{       968*OVERSAMPLENR ,       1100     }</front>
<front id="thermistortablesH-729">};</front>
<front id="thermistortablesH-730">#endif</front>
<front id="thermistortablesH-731"></front>
<front id="thermistortablesH-732">#if (THERMISTORHEATER_0 == 51) || (THERMISTORHEATER_1 == 51) || (THERMISTORHEATER_2 == 51) || (THERMISTORHEATER_3 == 51) || (THERMISTORBED == 51)</front>
<front id="thermistortablesH-733">// 100k EPCOS (WITH 1kohm RESISTOR FOR PULLUP, R9 ON SANGUINOLOLU! NOT FOR 4.7kohm PULLUP! THIS IS NOT NORMAL!)</front>
<front id="thermistortablesH-734">// Verified by linagee.</front>
<front id="thermistortablesH-735">// Calculated using 1kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-736">// Advantage: Twice the resolution and better linearity from 150C to 200C</front>
<front id="thermistortablesH-737">const short temptable_51[][2] PROGMEM = {</front>
<front id="thermistortablesH-738">   {1*OVERSAMPLENR, 350},</front>
<front id="thermistortablesH-739">   {190*OVERSAMPLENR, 250}, //top rating 250C</front>
<front id="thermistortablesH-740">   {203*OVERSAMPLENR, 245},</front>
<front id="thermistortablesH-741">   {217*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-742">   {232*OVERSAMPLENR, 235},</front>
<front id="thermistortablesH-743">   {248*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-744">   {265*OVERSAMPLENR, 225},</front>
<front id="thermistortablesH-745">   {283*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-746">   {302*OVERSAMPLENR, 215},</front>
<front id="thermistortablesH-747">   {322*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-748">   {344*OVERSAMPLENR, 205},</front>
<front id="thermistortablesH-749">   {366*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-750">   {390*OVERSAMPLENR, 195},</front>
<front id="thermistortablesH-751">   {415*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-752">   {440*OVERSAMPLENR, 185},</front>
<front id="thermistortablesH-753">   {467*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-754">   {494*OVERSAMPLENR, 175},</front>
<front id="thermistortablesH-755">   {522*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-756">   {551*OVERSAMPLENR, 165},</front>
<front id="thermistortablesH-757">   {580*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-758">   {609*OVERSAMPLENR, 155},</front>
<front id="thermistortablesH-759">   {638*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-760">   {666*OVERSAMPLENR, 145},</front>
<front id="thermistortablesH-761">   {695*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-762">   {722*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-763">   {749*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-764">   {775*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-765">   {800*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-766">   {823*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-767">   {845*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-768">   {865*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-769">   {884*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-770">   {901*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-771">   {917*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-772">   {932*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-773">   {944*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-774">   {956*OVERSAMPLENR, 75},</front>
<front id="thermistortablesH-775">   {966*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-776">   {975*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-777">   {982*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-778">   {989*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-779">   {995*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-780">   {1000*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-781">   {1004*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-782">   {1007*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-783">   {1010*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-784">   {1013*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-785">   {1015*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-786">   {1017*OVERSAMPLENR, 15},</front>
<front id="thermistortablesH-787">   {1018*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-788">   {1019*OVERSAMPLENR, 5},</front>
<front id="thermistortablesH-789">   {1020*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-790">   {1021*OVERSAMPLENR, -5}</front>
<front id="thermistortablesH-791">};</front>
<front id="thermistortablesH-792">#endif</front>
<front id="thermistortablesH-793"></front>
<front id="thermistortablesH-794">#if (THERMISTORHEATER_0 == 52) || (THERMISTORHEATER_1 == 52) || (THERMISTORHEATER_2 == 52) || (THERMISTORHEATER_3 == 52) || (THERMISTORBED == 52) </front>
<front id="thermistortablesH-795">// 200k ATC Semitec 204GT-2 (WITH 1kohm RESISTOR FOR PULLUP, R9 ON SANGUINOLOLU! NOT FOR 4.7kohm PULLUP! THIS IS NOT NORMAL!)</front>
<front id="thermistortablesH-796">// Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-797">// Calculated using 1kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-798">// Advantage: More resolution and better linearity from 150C to 200C</front>
<front id="thermistortablesH-799">const short temptable_52[][2] PROGMEM = {</front>
<front id="thermistortablesH-800">   {1*OVERSAMPLENR, 500},</front>
<front id="thermistortablesH-801">   {125*OVERSAMPLENR, 300}, //top rating 300C</front>
<front id="thermistortablesH-802">   {142*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-803">   {162*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-804">   {185*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-805">   {211*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-806">   {240*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-807">   {274*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-808">   {312*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-809">   {355*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-810">   {401*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-811">   {452*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-812">   {506*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-813">   {563*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-814">   {620*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-815">   {677*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-816">   {732*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-817">   {783*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-818">   {830*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-819">   {871*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-820">   {906*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-821">   {935*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-822">   {958*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-823">   {976*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-824">   {990*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-825">   {1000*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-826">   {1008*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-827">   {1013*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-828">   {1017*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-829">   {1019*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-830">   {1021*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-831">   {1022*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-832">};</front>
<front id="thermistortablesH-833">#endif</front>
<front id="thermistortablesH-834"></front>
<front id="thermistortablesH-835">#if (THERMISTORHEATER_0 == 55) || (THERMISTORHEATER_1 == 55) || (THERMISTORHEATER_2 == 55) || (THERMISTORHEATER_3 == 55) || (THERMISTORBED == 55) </front>
<front id="thermistortablesH-836">// 100k ATC Semitec 104GT-2 (Used on ParCan) (WITH 1kohm RESISTOR FOR PULLUP, R9 ON SANGUINOLOLU! NOT FOR 4.7kohm PULLUP! THIS IS NOT NORMAL!)</front>
<front id="thermistortablesH-837">// Verified by linagee. Source: http://shop.arcol.hu/static/datasheets/thermistors.pdf</front>
<front id="thermistortablesH-838">// Calculated using 1kohm pullup, voltage divider math, and manufacturer provided temp/resistance</front>
<front id="thermistortablesH-839">// Advantage: More resolution and better linearity from 150C to 200C</front>
<front id="thermistortablesH-840">const short temptable_55[][2] PROGMEM = {</front>
<front id="thermistortablesH-841">   {1*OVERSAMPLENR, 500},</front>
<front id="thermistortablesH-842">   {76*OVERSAMPLENR, 300},</front>
<front id="thermistortablesH-843">   {87*OVERSAMPLENR, 290},</front>
<front id="thermistortablesH-844">   {100*OVERSAMPLENR, 280},</front>
<front id="thermistortablesH-845">   {114*OVERSAMPLENR, 270},</front>
<front id="thermistortablesH-846">   {131*OVERSAMPLENR, 260},</front>
<front id="thermistortablesH-847">   {152*OVERSAMPLENR, 250},</front>
<front id="thermistortablesH-848">   {175*OVERSAMPLENR, 240},</front>
<front id="thermistortablesH-849">   {202*OVERSAMPLENR, 230},</front>
<front id="thermistortablesH-850">   {234*OVERSAMPLENR, 220},</front>
<front id="thermistortablesH-851">   {271*OVERSAMPLENR, 210},</front>
<front id="thermistortablesH-852">   {312*OVERSAMPLENR, 200},</front>
<front id="thermistortablesH-853">   {359*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-854">   {411*OVERSAMPLENR, 180},</front>
<front id="thermistortablesH-855">   {467*OVERSAMPLENR, 170},</front>
<front id="thermistortablesH-856">   {527*OVERSAMPLENR, 160},</front>
<front id="thermistortablesH-857">   {590*OVERSAMPLENR, 150},</front>
<front id="thermistortablesH-858">   {652*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-859">   {713*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-860">   {770*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-861">   {822*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-862">   {867*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-863">   {905*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-864">   {936*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-865">   {961*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-866">   {979*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-867">   {993*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-868">   {1003*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-869">   {1010*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-870">   {1015*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-871">   {1018*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-872">   {1020*OVERSAMPLENR, 0}</front>
<front id="thermistortablesH-873">};</front>
<front id="thermistortablesH-874">#endif</front>
<front id="thermistortablesH-875"></front>
<front id="thermistortablesH-876">#if (THERMISTORHEATER_0 == 60) || (THERMISTORHEATER_1 == 60) || (THERMISTORHEATER_2 == 60) || (THERMISTORHEATER_3 == 60) || (THERMISTORBED == 60) // Maker's Tool Works Kapton Bed Thermister</front>
<front id="thermistortablesH-877">// ./createTemperatureLookup.py --r0=100000 --t0=25 --r1=0 --r2=4700 --beta=3950 </front>
<front id="thermistortablesH-878">// r0: 100000</front>
<front id="thermistortablesH-879">// t0: 25</front>
<front id="thermistortablesH-880">// r1: 0 (parallel with rTherm)</front>
<front id="thermistortablesH-881">// r2: 4700 (series with rTherm)</front>
<front id="thermistortablesH-882">// beta: 3950</front>
<front id="thermistortablesH-883">// min adc: 1 at 0.0048828125 V</front>
<front id="thermistortablesH-884">// max adc: 1023 at 4.9951171875 V</front>
<front id="thermistortablesH-885">const short temptable_60[][2] PROGMEM = {</front>
<front id="thermistortablesH-886">   {51*OVERSAMPLENR, 272},</front>
<front id="thermistortablesH-887">   {61*OVERSAMPLENR, 258},</front>
<front id="thermistortablesH-888">   {71*OVERSAMPLENR, 247},</front>
<front id="thermistortablesH-889">   {81*OVERSAMPLENR, 237},</front>
<front id="thermistortablesH-890">   {91*OVERSAMPLENR, 229},</front>
<front id="thermistortablesH-891">   {101*OVERSAMPLENR, 221},</front>
<front id="thermistortablesH-892">   {131*OVERSAMPLENR, 204},</front>
<front id="thermistortablesH-893">   {161*OVERSAMPLENR, 190},</front>
<front id="thermistortablesH-894">   {191*OVERSAMPLENR, 179},</front>
<front id="thermistortablesH-895">   {231*OVERSAMPLENR, 167},</front>
<front id="thermistortablesH-896">   {271*OVERSAMPLENR, 157},</front>
<front id="thermistortablesH-897">   {311*OVERSAMPLENR, 148},</front>
<front id="thermistortablesH-898">   {351*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-899">   {381*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-900">   {411*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-901">   {441*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-902">   {451*OVERSAMPLENR, 123},</front>
<front id="thermistortablesH-903">   {461*OVERSAMPLENR, 122},</front>
<front id="thermistortablesH-904">   {471*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-905">   {481*OVERSAMPLENR, 119},</front>
<front id="thermistortablesH-906">   {491*OVERSAMPLENR, 117},</front>
<front id="thermistortablesH-907">   {501*OVERSAMPLENR, 116},</front>
<front id="thermistortablesH-908">   {511*OVERSAMPLENR, 114},</front>
<front id="thermistortablesH-909">   {521*OVERSAMPLENR, 113},</front>
<front id="thermistortablesH-910">   {531*OVERSAMPLENR, 111},</front>
<front id="thermistortablesH-911">   {541*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-912">   {551*OVERSAMPLENR, 108},</front>
<front id="thermistortablesH-913">   {561*OVERSAMPLENR, 107},</front>
<front id="thermistortablesH-914">   {571*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-915">   {581*OVERSAMPLENR, 104},</front>
<front id="thermistortablesH-916">   {591*OVERSAMPLENR, 102},</front>
<front id="thermistortablesH-917">   {601*OVERSAMPLENR, 101},</front>
<front id="thermistortablesH-918">   {611*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-919">   {621*OVERSAMPLENR, 98},</front>
<front id="thermistortablesH-920">   {631*OVERSAMPLENR, 97},</front>
<front id="thermistortablesH-921">   {641*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-922">   {651*OVERSAMPLENR, 94},</front>
<front id="thermistortablesH-923">   {661*OVERSAMPLENR, 92},</front>
<front id="thermistortablesH-924">   {671*OVERSAMPLENR, 91},</front>
<front id="thermistortablesH-925">   {681*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-926">   {691*OVERSAMPLENR, 88},</front>
<front id="thermistortablesH-927">   {701*OVERSAMPLENR, 87},</front>
<front id="thermistortablesH-928">   {711*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-929">   {721*OVERSAMPLENR, 84},</front>
<front id="thermistortablesH-930">   {731*OVERSAMPLENR, 82},</front>
<front id="thermistortablesH-931">   {741*OVERSAMPLENR, 81},</front>
<front id="thermistortablesH-932">   {751*OVERSAMPLENR, 79},</front>
<front id="thermistortablesH-933">   {761*OVERSAMPLENR, 77},</front>
<front id="thermistortablesH-934">   {771*OVERSAMPLENR, 76},</front>
<front id="thermistortablesH-935">   {781*OVERSAMPLENR, 74},</front>
<front id="thermistortablesH-936">   {791*OVERSAMPLENR, 72},</front>
<front id="thermistortablesH-937">   {801*OVERSAMPLENR, 71},</front>
<front id="thermistortablesH-938">   {811*OVERSAMPLENR, 69},</front>
<front id="thermistortablesH-939">   {821*OVERSAMPLENR, 67},</front>
<front id="thermistortablesH-940">   {831*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-941">   {841*OVERSAMPLENR, 63},</front>
<front id="thermistortablesH-942">   {851*OVERSAMPLENR, 62},</front>
<front id="thermistortablesH-943">   {861*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-944">   {871*OVERSAMPLENR, 57},</front>
<front id="thermistortablesH-945">   {881*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-946">   {891*OVERSAMPLENR, 53},</front>
<front id="thermistortablesH-947">   {901*OVERSAMPLENR, 51},</front>
<front id="thermistortablesH-948">   {911*OVERSAMPLENR, 48},</front>
<front id="thermistortablesH-949">   {921*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-950">   {931*OVERSAMPLENR, 42},</front>
<front id="thermistortablesH-951">   {941*OVERSAMPLENR, 39},</front>
<front id="thermistortablesH-952">   {951*OVERSAMPLENR, 36},</front>
<front id="thermistortablesH-953">   {961*OVERSAMPLENR, 32},</front>
<front id="thermistortablesH-954">   {981*OVERSAMPLENR, 23},</front>
<front id="thermistortablesH-955">   {991*OVERSAMPLENR, 17},</front>
<front id="thermistortablesH-956">   {1001*OVERSAMPLENR, 9},</front>
<front id="thermistortablesH-957">   {1008*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-958">};</front>
<front id="thermistortablesH-959">#endif</front>
<front id="thermistortablesH-960">#if (THERMISTORBED == 12) </front>
<front id="thermistortablesH-961">//100k 0603 SMD Vishay NTCS0603E3104FXT (4.7k pullup) (calibrated for Makibox hot bed)</front>
<front id="thermistortablesH-962">const short temptable_12[][2] PROGMEM = {</front>
<front id="thermistortablesH-963">   {35*OVERSAMPLENR, 180}, //top rating 180C</front>
<front id="thermistortablesH-964">   {211*OVERSAMPLENR, 140},</front>
<front id="thermistortablesH-965">   {233*OVERSAMPLENR, 135},</front>
<front id="thermistortablesH-966">   {261*OVERSAMPLENR, 130},</front>
<front id="thermistortablesH-967">   {290*OVERSAMPLENR, 125},</front>
<front id="thermistortablesH-968">   {328*OVERSAMPLENR, 120},</front>
<front id="thermistortablesH-969">   {362*OVERSAMPLENR, 115},</front>
<front id="thermistortablesH-970">   {406*OVERSAMPLENR, 110},</front>
<front id="thermistortablesH-971">   {446*OVERSAMPLENR, 105},</front>
<front id="thermistortablesH-972">   {496*OVERSAMPLENR, 100},</front>
<front id="thermistortablesH-973">   {539*OVERSAMPLENR, 95},</front>
<front id="thermistortablesH-974">   {585*OVERSAMPLENR, 90},</front>
<front id="thermistortablesH-975">   {629*OVERSAMPLENR, 85},</front>
<front id="thermistortablesH-976">   {675*OVERSAMPLENR, 80},</front>
<front id="thermistortablesH-977">   {718*OVERSAMPLENR, 75},</front>
<front id="thermistortablesH-978">   {758*OVERSAMPLENR, 70},</front>
<front id="thermistortablesH-979">   {793*OVERSAMPLENR, 65},</front>
<front id="thermistortablesH-980">   {822*OVERSAMPLENR, 60},</front>
<front id="thermistortablesH-981">   {841*OVERSAMPLENR, 55},</front>
<front id="thermistortablesH-982">   {875*OVERSAMPLENR, 50},</front>
<front id="thermistortablesH-983">   {899*OVERSAMPLENR, 45},</front>
<front id="thermistortablesH-984">   {926*OVERSAMPLENR, 40},</front>
<front id="thermistortablesH-985">   {946*OVERSAMPLENR, 35},</front>
<front id="thermistortablesH-986">   {962*OVERSAMPLENR, 30},</front>
<front id="thermistortablesH-987">   {977*OVERSAMPLENR, 25},</front>
<front id="thermistortablesH-988">   {987*OVERSAMPLENR, 20},</front>
<front id="thermistortablesH-989">   {995*OVERSAMPLENR, 15},</front>
<front id="thermistortablesH-990">   {1001*OVERSAMPLENR, 10},</front>
<front id="thermistortablesH-991">   {1010*OVERSAMPLENR, 0},</front>
<front id="thermistortablesH-992">   {1023*OVERSAMPLENR, -40},</front>
<front id="thermistortablesH-993">};</front>
<front id="thermistortablesH-994">#endif</front>
<front id="thermistortablesH-995"></front>
<front id="thermistortablesH-996">// Pt1000 and Pt100 handling</front>
<front id="thermistortablesH-997">// </front>
<front id="thermistortablesH-998">// Rt=R0*(1+a*T+b*T*T) [for T&gt;0]</front>
<front id="thermistortablesH-999">// a=3.9083E-3, b=-5.775E-7</front>
<front id="thermistortablesH-1000"></front>
<front id="thermistortablesH-1001">#define PtA 3.9083E-3</front>
<front id="thermistortablesH-1002">#define PtB -5.775E-7</front>
<front id="thermistortablesH-1003">#define PtRt(T,R0) ((R0)*(1.0+(PtA)*(T)+(PtB)*(T)*(T)))</front>
<front id="thermistortablesH-1004">#define PtAdVal(T,R0,Rup) (short)(1024/(Rup/PtRt(T,R0)+1))</front>
<front id="thermistortablesH-1005">#define PtLine(T,R0,Rup) { PtAdVal(T,R0,Rup)*OVERSAMPLENR, T },</front>
<front id="thermistortablesH-1006"></front>
<front id="thermistortablesH-1007">#if (THERMISTORHEATER_0 == 110) || (THERMISTORHEATER_1 == 110) || (THERMISTORHEATER_2 == 110) || (THERMISTORHEATER_3 == 110) || (THERMISTORBED == 110) // Pt100 with 1k0 pullup</front>
<front id="thermistortablesH-1008">const short temptable_110[][2] PROGMEM = {</front>
<front id="thermistortablesH-1009">// only few values are needed as the curve is very flat  </front>
<front id="thermistortablesH-1010">  PtLine(0,100,1000)</front>
<front id="thermistortablesH-1011">  PtLine(50,100,1000)</front>
<front id="thermistortablesH-1012">  PtLine(100,100,1000)</front>
<front id="thermistortablesH-1013">  PtLine(150,100,1000)</front>
<front id="thermistortablesH-1014">  PtLine(200,100,1000)</front>
<front id="thermistortablesH-1015">  PtLine(250,100,1000)</front>
<front id="thermistortablesH-1016">  PtLine(300,100,1000)</front>
<front id="thermistortablesH-1017">};</front>
<front id="thermistortablesH-1018">#endif</front>
<front id="thermistortablesH-1019">#if (THERMISTORHEATER_0 == 147) || (THERMISTORHEATER_1 == 147) || (THERMISTORHEATER_2 == 147) || (THERMISTORHEATER_3 == 147) || (THERMISTORBED == 147) // Pt100 with 4k7 pullup</front>
<front id="thermistortablesH-1020">const short temptable_147[][2] PROGMEM = {</front>
<front id="thermistortablesH-1021">// only few values are needed as the curve is very flat  </front>
<front id="thermistortablesH-1022">  PtLine(0,100,4700)</front>
<front id="thermistortablesH-1023">  PtLine(50,100,4700)</front>
<front id="thermistortablesH-1024">  PtLine(100,100,4700)</front>
<front id="thermistortablesH-1025">  PtLine(150,100,4700)</front>
<front id="thermistortablesH-1026">  PtLine(200,100,4700)</front>
<front id="thermistortablesH-1027">  PtLine(250,100,4700)</front>
<front id="thermistortablesH-1028">  PtLine(300,100,4700)</front>
<front id="thermistortablesH-1029">};</front>
<front id="thermistortablesH-1030">#endif</front>
<front id="thermistortablesH-1031">#if (THERMISTORHEATER_0 == 1010) || (THERMISTORHEATER_1 == 1010) || (THERMISTORHEATER_2 == 1010) || (THERMISTORHEATER_3 == 1010) || (THERMISTORBED == 1010) // Pt1000 with 1k0 pullup</front>
<front id="thermistortablesH-1032">const short temptable_1010[][2] PROGMEM = {</front>
<front id="thermistortablesH-1033">  PtLine(0,1000,1000)</front>
<front id="thermistortablesH-1034">  PtLine(25,1000,1000)</front>
<front id="thermistortablesH-1035">  PtLine(50,1000,1000)</front>
<front id="thermistortablesH-1036">  PtLine(75,1000,1000)</front>
<front id="thermistortablesH-1037">  PtLine(100,1000,1000)</front>
<front id="thermistortablesH-1038">  PtLine(125,1000,1000)</front>
<front id="thermistortablesH-1039">  PtLine(150,1000,1000)</front>
<front id="thermistortablesH-1040">  PtLine(175,1000,1000)</front>
<front id="thermistortablesH-1041">  PtLine(200,1000,1000)</front>
<front id="thermistortablesH-1042">  PtLine(225,1000,1000)</front>
<front id="thermistortablesH-1043">  PtLine(250,1000,1000)</front>
<front id="thermistortablesH-1044">  PtLine(275,1000,1000)</front>
<front id="thermistortablesH-1045">  PtLine(300,1000,1000)</front>
<front id="thermistortablesH-1046">};</front>
<front id="thermistortablesH-1047">#endif</front>
<front id="thermistortablesH-1048">#if (THERMISTORHEATER_0 == 1047) || (THERMISTORHEATER_1 == 1047) || (THERMISTORHEATER_2 == 1047) || (THERMISTORHEATER_3 == 1047) || (THERMISTORBED == 1047) // Pt1000 with 4k7 pullup</front>
<front id="thermistortablesH-1049">const short temptable_1047[][2] PROGMEM = {</front>
<front id="thermistortablesH-1050">// only few values are needed as the curve is very flat  </front>
<front id="thermistortablesH-1051">  PtLine(0,1000,4700)</front>
<front id="thermistortablesH-1052">  PtLine(50,1000,4700)</front>
<front id="thermistortablesH-1053">  PtLine(100,1000,4700)</front>
<front id="thermistortablesH-1054">  PtLine(150,1000,4700)</front>
<front id="thermistortablesH-1055">  PtLine(200,1000,4700)</front>
<front id="thermistortablesH-1056">  PtLine(250,1000,4700)</front>
<front id="thermistortablesH-1057">  PtLine(300,1000,4700)</front>
<front id="thermistortablesH-1058">};</front>
<front id="thermistortablesH-1059">#endif</front>
<front id="thermistortablesH-1060"></front>
<front id="thermistortablesH-1061">#if (THERMISTORHEATER_0 == 999) || (THERMISTORHEATER_1 == 999) || (THERMISTORHEATER_2 == 999) || (THERMISTORHEATER_3 == 999) || (THERMISTORBED == 999) //User defined table</front>
<front id="thermistortablesH-1062">  // Dummy Thermistor table.. It will ALWAYS read a fixed value.</front>
<front id="thermistortablesH-1063">  #ifndef DUMMY_THERMISTOR_999_VALUE</front>
<front id="thermistortablesH-1064">    #define DUMMY_THERMISTOR_999_VALUE 25</front>
<front id="thermistortablesH-1065">  #endif</front>
<front id="thermistortablesH-1066">  const short temptable_999[][2] PROGMEM = {</front>
<front id="thermistortablesH-1067">    {1*OVERSAMPLENR, DUMMY_THERMISTOR_999_VALUE},</front>
<front id="thermistortablesH-1068">    {1023*OVERSAMPLENR, DUMMY_THERMISTOR_999_VALUE}</front>
<front id="thermistortablesH-1069">};</front>
<front id="thermistortablesH-1070">#endif</front>
<front id="thermistortablesH-1071"></front>
<front id="thermistortablesH-1072">#if (THERMISTORHEATER_0 == 998) || (THERMISTORHEATER_1 == 998) || (THERMISTORHEATER_2 == 998) || (THERMISTORHEATER_3 == 998) || (THERMISTORBED == 998) //User defined table</front>
<front id="thermistortablesH-1073">  // Dummy Thermistor table.. It will ALWAYS read a fixed value.</front>
<front id="thermistortablesH-1074">  #ifndef DUMMY_THERMISTOR_998_VALUE</front>
<front id="thermistortablesH-1075">    #define DUMMY_THERMISTOR_998_VALUE 25</front>
<front id="thermistortablesH-1076">  #endif</front>
<front id="thermistortablesH-1077">  const short temptable_998[][2] PROGMEM = {</front>
<front id="thermistortablesH-1078">    {1*OVERSAMPLENR, DUMMY_THERMISTOR_998_VALUE},</front>
<front id="thermistortablesH-1079">    {1023*OVERSAMPLENR, DUMMY_THERMISTOR_998_VALUE}</front>
<front id="thermistortablesH-1080">};</front>
<front id="thermistortablesH-1081">#endif</front>
<front id="thermistortablesH-1082"></front>
<front id="thermistortablesH-1083"></front>
<front id="thermistortablesH-1084">#define _TT_NAME(_N) temptable_ ## _N</front>
<front id="thermistortablesH-1085">#define TT_NAME(_N) _TT_NAME(_N)</front>
<front id="thermistortablesH-1086"></front>
<front id="thermistortablesH-1087">#ifdef THERMISTORHEATER_0</front>
<front id="thermistortablesH-1088"># define HEATER_0_TEMPTABLE TT_NAME(THERMISTORHEATER_0)</front>
<front id="thermistortablesH-1089"># define HEATER_0_TEMPTABLE_LEN COUNT(HEATER_0_TEMPTABLE)</front>
<front id="thermistortablesH-1090">#else</front>
<front id="thermistortablesH-1091"># ifdef HEATER_0_USES_THERMISTOR</front>
<front id="thermistortablesH-1092">#  error No heater 0 thermistor table specified</front>
<front id="thermistortablesH-1093"># else  // HEATER_0_USES_THERMISTOR</front>
<front id="thermistortablesH-1094">#  define HEATER_0_TEMPTABLE NULL</front>
<front id="thermistortablesH-1095">#  define HEATER_0_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-1096"># endif // HEATER_0_USES_THERMISTOR</front>
<front id="thermistortablesH-1097">#endif</front>
<front id="thermistortablesH-1098"></front>
<front id="thermistortablesH-1099">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-1100">#ifndef HEATER_0_RAW_HI_TEMP</front>
<front id="thermistortablesH-1101"># ifdef HEATER_0_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-1102">#  define HEATER_0_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-1103">#  define HEATER_0_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-1104"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-1105">#  define HEATER_0_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-1106">#  define HEATER_0_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-1107"># endif</front>
<front id="thermistortablesH-1108">#endif</front>
<front id="thermistortablesH-1109"></front>
<front id="thermistortablesH-1110">#ifdef THERMISTORHEATER_1</front>
<front id="thermistortablesH-1111"># define HEATER_1_TEMPTABLE TT_NAME(THERMISTORHEATER_1)</front>
<front id="thermistortablesH-1112"># define HEATER_1_TEMPTABLE_LEN COUNT(HEATER_1_TEMPTABLE)</front>
<front id="thermistortablesH-1113">#else</front>
<front id="thermistortablesH-1114"># ifdef HEATER_1_USES_THERMISTOR</front>
<front id="thermistortablesH-1115">#  error No heater 1 thermistor table specified</front>
<front id="thermistortablesH-1116"># else  // HEATER_1_USES_THERMISTOR</front>
<front id="thermistortablesH-1117">#  define HEATER_1_TEMPTABLE NULL</front>
<front id="thermistortablesH-1118">#  define HEATER_1_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-1119"># endif // HEATER_1_USES_THERMISTOR</front>
<front id="thermistortablesH-1120">#endif</front>
<front id="thermistortablesH-1121"></front>
<front id="thermistortablesH-1122">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-1123">#ifndef HEATER_1_RAW_HI_TEMP</front>
<front id="thermistortablesH-1124"># ifdef HEATER_1_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-1125">#  define HEATER_1_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-1126">#  define HEATER_1_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-1127"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-1128">#  define HEATER_1_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-1129">#  define HEATER_1_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-1130"># endif</front>
<front id="thermistortablesH-1131">#endif</front>
<front id="thermistortablesH-1132"></front>
<front id="thermistortablesH-1133">#ifdef THERMISTORHEATER_2</front>
<front id="thermistortablesH-1134"># define HEATER_2_TEMPTABLE TT_NAME(THERMISTORHEATER_2)</front>
<front id="thermistortablesH-1135"># define HEATER_2_TEMPTABLE_LEN COUNT(HEATER_2_TEMPTABLE)</front>
<front id="thermistortablesH-1136">#else</front>
<front id="thermistortablesH-1137"># ifdef HEATER_2_USES_THERMISTOR</front>
<front id="thermistortablesH-1138">#  error No heater 2 thermistor table specified</front>
<front id="thermistortablesH-1139"># else  // HEATER_2_USES_THERMISTOR</front>
<front id="thermistortablesH-1140">#  define HEATER_2_TEMPTABLE NULL</front>
<front id="thermistortablesH-1141">#  define HEATER_2_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-1142"># endif // HEATER_2_USES_THERMISTOR</front>
<front id="thermistortablesH-1143">#endif</front>
<front id="thermistortablesH-1144"></front>
<front id="thermistortablesH-1145">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-1146">#ifndef HEATER_2_RAW_HI_TEMP</front>
<front id="thermistortablesH-1147"># ifdef HEATER_2_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-1148">#  define HEATER_2_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-1149">#  define HEATER_2_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-1150"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-1151">#  define HEATER_2_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-1152">#  define HEATER_2_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-1153"># endif</front>
<front id="thermistortablesH-1154">#endif</front>
<front id="thermistortablesH-1155"></front>
<front id="thermistortablesH-1156">#ifdef THERMISTORHEATER_3</front>
<front id="thermistortablesH-1157"># define HEATER_3_TEMPTABLE TT_NAME(THERMISTORHEATER_3)</front>
<front id="thermistortablesH-1158"># define HEATER_3_TEMPTABLE_LEN COUNT(HEATER_3_TEMPTABLE)</front>
<front id="thermistortablesH-1159">#else</front>
<front id="thermistortablesH-1160"># ifdef HEATER_3_USES_THERMISTOR</front>
<front id="thermistortablesH-1161">#  error No heater 3 thermistor table specified</front>
<front id="thermistortablesH-1162"># else  // HEATER_3_USES_THERMISTOR</front>
<front id="thermistortablesH-1163">#  define HEATER_3_TEMPTABLE NULL</front>
<front id="thermistortablesH-1164">#  define HEATER_3_TEMPTABLE_LEN 0</front>
<front id="thermistortablesH-1165"># endif // HEATER_3_USES_THERMISTOR</front>
<front id="thermistortablesH-1166">#endif</front>
<front id="thermistortablesH-1167"></front>
<front id="thermistortablesH-1168">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-1169">#ifndef HEATER_3_RAW_HI_TEMP</front>
<front id="thermistortablesH-1170"># ifdef HEATER_3_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-1171">#  define HEATER_3_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-1172">#  define HEATER_3_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-1173"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-1174">#  define HEATER_3_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-1175">#  define HEATER_3_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-1176"># endif</front>
<front id="thermistortablesH-1177">#endif</front>
<front id="thermistortablesH-1178"></front>
<front id="thermistortablesH-1179">#ifdef THERMISTORBED</front>
<front id="thermistortablesH-1180"># define BEDTEMPTABLE TT_NAME(THERMISTORBED)</front>
<front id="thermistortablesH-1181"># define BEDTEMPTABLE_LEN COUNT(BEDTEMPTABLE)</front>
<front id="thermistortablesH-1182">#else</front>
<front id="thermistortablesH-1183"># ifdef BED_USES_THERMISTOR</front>
<front id="thermistortablesH-1184">#  error No bed thermistor table specified</front>
<front id="thermistortablesH-1185"># endif // BED_USES_THERMISTOR</front>
<front id="thermistortablesH-1186">#endif</front>
<front id="thermistortablesH-1187"></front>
<front id="thermistortablesH-1188">//Set the high and low raw values for the heater, this indicates which raw value is a high or low temperature</front>
<front id="thermistortablesH-1189">#ifndef HEATER_BED_RAW_HI_TEMP</front>
<front id="thermistortablesH-1190"># ifdef BED_USES_THERMISTOR   //In case of a thermistor the highest temperature results in the lowest ADC value</front>
<front id="thermistortablesH-1191">#  define HEATER_BED_RAW_HI_TEMP 0</front>
<front id="thermistortablesH-1192">#  define HEATER_BED_RAW_LO_TEMP 16383</front>
<front id="thermistortablesH-1193"># else                          //In case of an thermocouple the highest temperature results in the highest ADC value</front>
<front id="thermistortablesH-1194">#  define HEATER_BED_RAW_HI_TEMP 16383</front>
<front id="thermistortablesH-1195">#  define HEATER_BED_RAW_LO_TEMP 0</front>
<front id="thermistortablesH-1196"># endif</front>
<front id="thermistortablesH-1197">#endif</front>
<front id="thermistortablesH-1198"></front>
<front id="thermistortablesH-1199">#endif //THERMISTORTABLES_H_</front>
 </pre>
<h1 id="ultralcdCPPtitle" >ultralcd.cpp</h1>
<pre id="ultralcdCPP"  class="prettyprint linenums"><front id="ultralcdCPP-1">#include "ultralcd.h"</front>
<front id="ultralcdCPP-2">#if ENABLED(ULTRA_LCD)</front>
<front id="ultralcdCPP-3">#include "Marlin.h"</front>
<front id="ultralcdCPP-4">#include "language.h"</front>
<front id="ultralcdCPP-5">#include "cardreader.h"</front>
<front id="ultralcdCPP-6">#include "temperature.h"</front>
<front id="ultralcdCPP-7">#include "stepper.h"</front>
<front id="ultralcdCPP-8">#include "configuration_store.h"</front>
<front id="ultralcdCPP-9"></front>
<front id="ultralcdCPP-10">int8_t encoderDiff; // updated from interrupt context and added to encoderPosition every LCD update</front>
<front id="ultralcdCPP-11"></front>
<front id="ultralcdCPP-12">bool encoderRateMultiplierEnabled;</front>
<front id="ultralcdCPP-13">int32_t lastEncoderMovementMillis;</front>
<front id="ultralcdCPP-14"></front>
<front id="ultralcdCPP-15">int plaPreheatHotendTemp;</front>
<front id="ultralcdCPP-16">int plaPreheatHPBTemp;</front>
<front id="ultralcdCPP-17">int plaPreheatFanSpeed;</front>
<front id="ultralcdCPP-18"></front>
<front id="ultralcdCPP-19">int absPreheatHotendTemp;</front>
<front id="ultralcdCPP-20">int absPreheatHPBTemp;</front>
<front id="ultralcdCPP-21">int absPreheatFanSpeed;</front>
<front id="ultralcdCPP-22"></front>
<front id="ultralcdCPP-23">#if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdCPP-24">  millis_t previous_lcd_status_ms = 0;</front>
<front id="ultralcdCPP-25">#endif</front>
<front id="ultralcdCPP-26"></front>
<front id="ultralcdCPP-27">// Function pointer to menu functions.</front>
<front id="ultralcdCPP-28">typedef void (*menuFunc_t)();</front>
<front id="ultralcdCPP-29"></front>
<front id="ultralcdCPP-30">uint8_t lcd_status_message_level;</front>
<front id="ultralcdCPP-31">char lcd_status_message[3*LCD_WIDTH+1] = WELCOME_MSG; // worst case is kana with up to 3*LCD_WIDTH+1</front>
<front id="ultralcdCPP-32"></front>
<front id="ultralcdCPP-33">#if ENABLED(DOGLCD)</front>
<front id="ultralcdCPP-34">  #include "dogm_lcd_implementation.h"</front>
<front id="ultralcdCPP-35">#else</front>
<front id="ultralcdCPP-36">  #include "ultralcd_implementation_hitachi_HD44780.h"</front>
<front id="ultralcdCPP-37">#endif</front>
<front id="ultralcdCPP-38"></front>
<front id="ultralcdCPP-39">// The main status screen</front>
<front id="ultralcdCPP-40">static void lcd_status_screen();</front>
<front id="ultralcdCPP-41"></front>
<front id="ultralcdCPP-42">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-43"></front>
<front id="ultralcdCPP-44">  #if HAS_POWER_SWITCH</front>
<front id="ultralcdCPP-45">    extern bool powersupply;</front>
<front id="ultralcdCPP-46">  #endif</front>
<front id="ultralcdCPP-47">  const float manual_feedrate[] = MANUAL_FEEDRATE;</front>
<front id="ultralcdCPP-48">  static void lcd_main_menu();</front>
<front id="ultralcdCPP-49">  static void lcd_tune_menu();</front>
<front id="ultralcdCPP-50">  static void lcd_prepare_menu();</front>
<front id="ultralcdCPP-51">  static void lcd_move_menu();</front>
<front id="ultralcdCPP-52">  static void lcd_control_menu();</front>
<front id="ultralcdCPP-53">  static void lcd_control_temperature_menu();</front>
<front id="ultralcdCPP-54">  static void lcd_control_temperature_preheat_pla_settings_menu();</front>
<front id="ultralcdCPP-55">  static void lcd_control_temperature_preheat_abs_settings_menu();</front>
<front id="ultralcdCPP-56">  static void lcd_control_motion_menu();</front>
<front id="ultralcdCPP-57">  static void lcd_control_volumetric_menu();</front>
<front id="ultralcdCPP-58"></front>
<front id="ultralcdCPP-59">  #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-60">    static void lcd_set_contrast();</front>
<front id="ultralcdCPP-61">  #endif</front>
<front id="ultralcdCPP-62"></front>
<front id="ultralcdCPP-63">  #if ENABLED(FWRETRACT)</front>
<front id="ultralcdCPP-64">    static void lcd_control_retract_menu();</front>
<front id="ultralcdCPP-65">  #endif</front>
<front id="ultralcdCPP-66"></front>
<front id="ultralcdCPP-67">  #if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-68">    static void lcd_sdcard_resume_menu();</front>
<front id="ultralcdCPP-69">    static void lcd_sdcard_print_menu();</front>
<front id="ultralcdCPP-70">    extern float planner_disabled_below_z;</front>
<front id="ultralcdCPP-71">    extern float last_z;</front>
<front id="ultralcdCPP-72">    extern bool z_reached;</front>
<front id="ultralcdCPP-73">    extern bool layer_reached;</front>
<front id="ultralcdCPP-74">    extern bool hops;</front>
<front id="ultralcdCPP-75">    extern bool gone_up;</front>
<front id="ultralcdCPP-76">  #endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-77"></front>
<front id="ultralcdCPP-78">  #if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="ultralcdCPP-79">    static void lcd_delta_calibrate_menu();</front>
<front id="ultralcdCPP-80">  #endif</front>
<front id="ultralcdCPP-81"></front>
<front id="ultralcdCPP-82">  #if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-83">    #include "mesh_bed_leveling.h"</front>
<front id="ultralcdCPP-84">    static void _lcd_level_bed();</front>
<front id="ultralcdCPP-85">    static void _lcd_level_bed_homing();</front>
<front id="ultralcdCPP-86">    static void lcd_level_bed();</front>
<front id="ultralcdCPP-87">  #endif</front>
<front id="ultralcdCPP-88"></front>
<front id="ultralcdCPP-89">  /* Different types of actions that can be used in menu items. */</front>
<front id="ultralcdCPP-90">  static void menu_action_back(menuFunc_t data);</front>
<front id="ultralcdCPP-91">  static void menu_action_submenu(menuFunc_t data);</front>
<front id="ultralcdCPP-92">  static void menu_action_gcode(const char* pgcode);</front>
<front id="ultralcdCPP-93">  static void menu_action_function(menuFunc_t data);</front>
<front id="ultralcdCPP-94">  static void menu_action_setting_edit_bool(const char* pstr, bool* ptr);</front>
<front id="ultralcdCPP-95">  static void menu_action_setting_edit_int3(const char* pstr, int* ptr, int minValue, int maxValue);</front>
<front id="ultralcdCPP-96">  static void menu_action_setting_edit_float3(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-97">  static void menu_action_setting_edit_float32(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-98">  static void menu_action_setting_edit_float43(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-99">  static void menu_action_setting_edit_float5(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-100">  static void menu_action_setting_edit_float51(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-101">  static void menu_action_setting_edit_float52(const char* pstr, float* ptr, float minValue, float maxValue);</front>
<front id="ultralcdCPP-102">  static void menu_action_setting_edit_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue);</front>
<front id="ultralcdCPP-103">  static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-104">  static void menu_action_setting_edit_callback_int3(const char* pstr, int* ptr, int minValue, int maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-105">  static void menu_action_setting_edit_callback_float3(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-106">  static void menu_action_setting_edit_callback_float32(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-107">  static void menu_action_setting_edit_callback_float43(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-108">  static void menu_action_setting_edit_callback_float5(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-109">  static void menu_action_setting_edit_callback_float51(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-110">  static void menu_action_setting_edit_callback_float52(const char* pstr, float* ptr, float minValue, float maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-111">  static void menu_action_setting_edit_callback_long5(const char* pstr, unsigned long* ptr, unsigned long minValue, unsigned long maxValue, menuFunc_t callbackFunc);</front>
<front id="ultralcdCPP-112"></front>
<front id="ultralcdCPP-113">  #if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-114">    static void lcd_sdcard_menu();</front>
<front id="ultralcdCPP-115">    static void menu_action_sdfile(const char* filename, char* longFilename);</front>
<front id="ultralcdCPP-116">    static void menu_action_sddirectory(const char* filename, char* longFilename);</front>
<front id="ultralcdCPP-117">  #endif</front>
<front id="ultralcdCPP-118"></front>
<front id="ultralcdCPP-119">  #define ENCODER_FEEDRATE_DEADZONE 10</front>
<front id="ultralcdCPP-120"></front>
<front id="ultralcdCPP-121">  #if DISABLED(LCD_I2C_VIKI)</front>
<front id="ultralcdCPP-122">    #ifndef ENCODER_STEPS_PER_MENU_ITEM</front>
<front id="ultralcdCPP-123">      #define ENCODER_STEPS_PER_MENU_ITEM 5</front>
<front id="ultralcdCPP-124">    #endif</front>
<front id="ultralcdCPP-125">    #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ultralcdCPP-126">      #define ENCODER_PULSES_PER_STEP 1</front>
<front id="ultralcdCPP-127">    #endif</front>
<front id="ultralcdCPP-128">  #else</front>
<front id="ultralcdCPP-129">    #ifndef ENCODER_STEPS_PER_MENU_ITEM</front>
<front id="ultralcdCPP-130">      #define ENCODER_STEPS_PER_MENU_ITEM 2 // VIKI LCD rotary encoder uses a different number of steps per rotation</front>
<front id="ultralcdCPP-131">    #endif</front>
<front id="ultralcdCPP-132">    #ifndef ENCODER_PULSES_PER_STEP</front>
<front id="ultralcdCPP-133">      #define ENCODER_PULSES_PER_STEP 1</front>
<front id="ultralcdCPP-134">    #endif</front>
<front id="ultralcdCPP-135">  #endif</front>
<front id="ultralcdCPP-136"></front>
<front id="ultralcdCPP-137"></front>
<front id="ultralcdCPP-138">  /* Helper macros for menus */</front>
<front id="ultralcdCPP-139"></front>
<front id="ultralcdCPP-140">  /**</front>
<front id="ultralcdCPP-141">   * START_MENU generates the init code for a menu function</front>
<front id="ultralcdCPP-142">   */</front>
<front id="ultralcdCPP-143">  #define START_MENU() do { \</front>
<front id="ultralcdCPP-144">    encoderRateMultiplierEnabled = false; \</front>
<front id="ultralcdCPP-145">    if (encoderPosition &gt; 0x8000) encoderPosition = 0; \</front>
<front id="ultralcdCPP-146">    uint8_t encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; \</front>
<front id="ultralcdCPP-147">    if (encoderLine &lt; currentMenuViewOffset) currentMenuViewOffset = encoderLine; \</front>
<front id="ultralcdCPP-148">    uint8_t _lineNr = currentMenuViewOffset, _menuItemNr; \</front>
<front id="ultralcdCPP-149">    bool wasClicked = LCD_CLICKED, itemSelected; \</front>
<front id="ultralcdCPP-150">    for (uint8_t _drawLineNr = 0; _drawLineNr &lt; LCD_HEIGHT; _drawLineNr++, _lineNr++) { \</front>
<front id="ultralcdCPP-151">      _menuItemNr = 0;</front>
<front id="ultralcdCPP-152"></front>
<front id="ultralcdCPP-153">  /**</front>
<front id="ultralcdCPP-154">   * MENU_ITEM generates draw & handler code for a menu item, potentially calling:</front>
<front id="ultralcdCPP-155">   *</front>
<front id="ultralcdCPP-156">   *   lcd_implementation_drawmenu_[type](sel, row, label, arg3...)</front>
<front id="ultralcdCPP-157">   *   menu_action_[type](arg3...)</front>
<front id="ultralcdCPP-158">   *</front>
<front id="ultralcdCPP-159">   * Examples:</front>
<front id="ultralcdCPP-160">   *   MENU_ITEM(back, MSG_WATCH, lcd_status_screen)</front>
<front id="ultralcdCPP-161">   *     lcd_implementation_drawmenu_back(sel, row, PSTR(MSG_WATCH), lcd_status_screen)</front>
<front id="ultralcdCPP-162">   *     menu_action_back(lcd_status_screen)</front>
<front id="ultralcdCPP-163">   *</front>
<front id="ultralcdCPP-164">   *   MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause)</front>
<front id="ultralcdCPP-165">   *     lcd_implementation_drawmenu_function(sel, row, PSTR(MSG_PAUSE_PRINT), lcd_sdcard_pause)</front>
<front id="ultralcdCPP-166">   *     menu_action_function(lcd_sdcard_pause)</front>
<front id="ultralcdCPP-167">   *</front>
<front id="ultralcdCPP-168">   *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-169">   *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-170">   *     lcd_implementation_drawmenu_setting_edit_int3(sel, row, PSTR(MSG_SPEED), PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-171">   *     menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_multiplier, 10, 999)</front>
<front id="ultralcdCPP-172">   *</front>
<front id="ultralcdCPP-173">   */</front>
<front id="ultralcdCPP-174">  #define MENU_ITEM(type, label, args...) do { \</front>
<front id="ultralcdCPP-175">    if (_menuItemNr == _lineNr) { \</front>
<front id="ultralcdCPP-176">      itemSelected = encoderLine == _menuItemNr; \</front>
<front id="ultralcdCPP-177">      if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-178">        lcd_implementation_drawmenu_ ## type(itemSelected, _drawLineNr, PSTR(label), ## args); \</front>
<front id="ultralcdCPP-179">      if (wasClicked && itemSelected) { \</front>
<front id="ultralcdCPP-180">        lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-181">        menu_action_ ## type(args); \</front>
<front id="ultralcdCPP-182">        return; \</front>
<front id="ultralcdCPP-183">      } \</front>
<front id="ultralcdCPP-184">    } \</front>
<front id="ultralcdCPP-185">    _menuItemNr++; \</front>
<front id="ultralcdCPP-186">  } while(0)</front>
<front id="ultralcdCPP-187"></front>
<front id="ultralcdCPP-188">  #if ENABLED(ENCODER_RATE_MULTIPLIER)</front>
<front id="ultralcdCPP-189"></front>
<front id="ultralcdCPP-190">    //#define ENCODER_RATE_MULTIPLIER_DEBUG  // If defined, output the encoder steps per second value</front>
<front id="ultralcdCPP-191"></front>
<front id="ultralcdCPP-192">    /**</front>
<front id="ultralcdCPP-193">     * MENU_MULTIPLIER_ITEM generates drawing and handling code for a multiplier menu item</front>
<front id="ultralcdCPP-194">     */</front>
<front id="ultralcdCPP-195">    #define MENU_MULTIPLIER_ITEM(type, label, args...) do { \</front>
<front id="ultralcdCPP-196">      if (_menuItemNr == _lineNr) { \</front>
<front id="ultralcdCPP-197">        itemSelected = encoderLine == _menuItemNr; \</front>
<front id="ultralcdCPP-198">        if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-199">          lcd_implementation_drawmenu_ ## type(itemSelected, _drawLineNr, PSTR(label), ## args); \</front>
<front id="ultralcdCPP-200">        if (wasClicked && itemSelected) { \</front>
<front id="ultralcdCPP-201">          lcd_quick_feedback(); \</front>
<front id="ultralcdCPP-202">          encoderRateMultiplierEnabled = true; \</front>
<front id="ultralcdCPP-203">          lastEncoderMovementMillis = 0; \</front>
<front id="ultralcdCPP-204">          menu_action_ ## type(args); \</front>
<front id="ultralcdCPP-205">          return; \</front>
<front id="ultralcdCPP-206">        } \</front>
<front id="ultralcdCPP-207">      } \</front>
<front id="ultralcdCPP-208">      _menuItemNr++; \</front>
<front id="ultralcdCPP-209">    } while(0)</front>
<front id="ultralcdCPP-210">  #endif //ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-211"></front>
<front id="ultralcdCPP-212">  #define MENU_ITEM_DUMMY() do { _menuItemNr++; } while(0)</front>
<front id="ultralcdCPP-213">  #define MENU_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-214">  #define MENU_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-215">  #if ENABLED(ENCODER_RATE_MULTIPLIER)</front>
<front id="ultralcdCPP-216">    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-217">    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_MULTIPLIER_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-218">  #else //!ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-219">    #define MENU_MULTIPLIER_ITEM_EDIT(type, label, args...) MENU_ITEM(setting_edit_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-220">    #define MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(type, label, args...) MENU_ITEM(setting_edit_callback_ ## type, label, PSTR(label), ## args)</front>
<front id="ultralcdCPP-221">  #endif //!ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-222">  #define END_MENU() \</front>
<front id="ultralcdCPP-223">      if (encoderLine &gt;= _menuItemNr) { encoderPosition = _menuItemNr * ENCODER_STEPS_PER_MENU_ITEM - 1; encoderLine = encoderPosition / ENCODER_STEPS_PER_MENU_ITEM; }\</front>
<front id="ultralcdCPP-224">      if (encoderLine &gt;= currentMenuViewOffset + LCD_HEIGHT) { currentMenuViewOffset = encoderLine - LCD_HEIGHT + 1; lcdDrawUpdate = 1; _lineNr = currentMenuViewOffset - 1; _drawLineNr = -1; } \</front>
<front id="ultralcdCPP-225">      } } while(0)</front>
<front id="ultralcdCPP-226"></front>
<front id="ultralcdCPP-227">  /** Used variables to keep track of the menu */</front>
<front id="ultralcdCPP-228">  volatile uint8_t buttons;  //the last checked buttons in a bit array.</front>
<front id="ultralcdCPP-229">  #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-230">    volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shift register values</front>
<front id="ultralcdCPP-231">  #endif</front>
<front id="ultralcdCPP-232">    </front>
<front id="ultralcdCPP-233">  #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-234">    volatile uint8_t slow_buttons; // Bits of the pressed buttons.</front>
<front id="ultralcdCPP-235">  #endif</front>
<front id="ultralcdCPP-236">  uint8_t currentMenuViewOffset;              /* scroll offset in the current menu */</front>
<front id="ultralcdCPP-237">  millis_t next_button_update_ms;</front>
<front id="ultralcdCPP-238">  uint8_t lastEncoderBits;</front>
<front id="ultralcdCPP-239">  uint32_t encoderPosition;</front>
<front id="ultralcdCPP-240">  #if PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-241">    uint8_t lcd_sd_status;</front>
<front id="ultralcdCPP-242">  #endif</front>
<front id="ultralcdCPP-243"></front>
<front id="ultralcdCPP-244">#endif // ULTIPANEL</front>
<front id="ultralcdCPP-245"></front>
<front id="ultralcdCPP-246">menuFunc_t currentMenu = lcd_status_screen; /* function pointer to the currently active menu */</front>
<front id="ultralcdCPP-247">millis_t next_lcd_update_ms;</front>
<front id="ultralcdCPP-248">uint8_t lcd_status_update_delay;</front>
<front id="ultralcdCPP-249">bool ignore_click = false;</front>
<front id="ultralcdCPP-250">bool wait_for_unclick;</front>
<front id="ultralcdCPP-251">uint8_t lcdDrawUpdate = 2;                  /* Set to none-zero when the LCD needs to draw, decreased after every draw. Set to 2 in LCD routines so the LCD gets at least 1 full redraw (first redraw is partial) */</front>
<front id="ultralcdCPP-252"></front>
<front id="ultralcdCPP-253">//prevMenu and prevEncoderPosition are used to store the previous menu location when editing settings.</front>
<front id="ultralcdCPP-254">menuFunc_t prevMenu = NULL;</front>
<front id="ultralcdCPP-255">uint16_t prevEncoderPosition;</front>
<front id="ultralcdCPP-256">//Variables used when editing values.</front>
<front id="ultralcdCPP-257">const char* editLabel;</front>
<front id="ultralcdCPP-258">void* editValue;</front>
<front id="ultralcdCPP-259">int32_t minEditValue, maxEditValue;</front>
<front id="ultralcdCPP-260">menuFunc_t callbackFunc;</front>
<front id="ultralcdCPP-261"></front>
<front id="ultralcdCPP-262">// place-holders for Ki and Kd edits</front>
<front id="ultralcdCPP-263">float raw_Ki, raw_Kd;</front>
<front id="ultralcdCPP-264"></front>
<front id="ultralcdCPP-265">/**</front>
<front id="ultralcdCPP-266"> * General function to go directly to a menu</front>
<front id="ultralcdCPP-267"> */</front>
<front id="ultralcdCPP-268">static void lcd_goto_menu(menuFunc_t menu, const bool feedback=false, const uint32_t encoder=0) {</front>
<front id="ultralcdCPP-269">  if (currentMenu != menu) {</front>
<front id="ultralcdCPP-270">    currentMenu = menu;</front>
<front id="ultralcdCPP-271">    #if ENABLED(NEWPANEL)</front>
<front id="ultralcdCPP-272">      encoderPosition = encoder;</front>
<front id="ultralcdCPP-273">      if (feedback) lcd_quick_feedback();</front>
<front id="ultralcdCPP-274">    #endif</front>
<front id="ultralcdCPP-275">    // For LCD_PROGRESS_BAR re-initialize the custom characters</front>
<front id="ultralcdCPP-276">    #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-277">      lcd_set_custom_characters(menu == lcd_status_screen);</front>
<front id="ultralcdCPP-278">    #endif</front>
<front id="ultralcdCPP-279">  }</front>
<front id="ultralcdCPP-280">}</front>
<front id="ultralcdCPP-281"></front>
<front id="ultralcdCPP-282">/**</front>
<front id="ultralcdCPP-283"> *</front>
<front id="ultralcdCPP-284"> * "Info Screen"</front>
<front id="ultralcdCPP-285"> *</front>
<front id="ultralcdCPP-286"> * This is very display-dependent, so the lcd implementation draws this.</front>
<front id="ultralcdCPP-287"> */</front>
<front id="ultralcdCPP-288"></front>
<front id="ultralcdCPP-289">static void lcd_status_screen() {</front>
<front id="ultralcdCPP-290">	encoderRateMultiplierEnabled = false;</front>
<front id="ultralcdCPP-291"></front>
<front id="ultralcdCPP-292">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-293">    millis_t ms = millis();</front>
<front id="ultralcdCPP-294">    #if DISABLED(PROGRESS_MSG_ONCE)</front>
<front id="ultralcdCPP-295">      if (ms &gt; progress_bar_ms + PROGRESS_BAR_MSG_TIME + PROGRESS_BAR_BAR_TIME) {</front>
<front id="ultralcdCPP-296">        progress_bar_ms = ms;</front>
<front id="ultralcdCPP-297">      }</front>
<front id="ultralcdCPP-298">    #endif</front>
<front id="ultralcdCPP-299">    #if PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdCPP-300">      // Handle message expire</front>
<front id="ultralcdCPP-301">      if (expire_status_ms &gt; 0) {</front>
<front id="ultralcdCPP-302">        #if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-303">          if (card.isFileOpen()) {</front>
<front id="ultralcdCPP-304">            // Expire the message when printing is active</front>
<front id="ultralcdCPP-305">            if (IS_SD_PRINTING) {</front>
<front id="ultralcdCPP-306">              if (ms &gt;= expire_status_ms) {</front>
<front id="ultralcdCPP-307">                lcd_status_message[0] = '\0';</front>
<front id="ultralcdCPP-308">                expire_status_ms = 0;</front>
<front id="ultralcdCPP-309">              }</front>
<front id="ultralcdCPP-310">            }</front>
<front id="ultralcdCPP-311">            else {</front>
<front id="ultralcdCPP-312">              expire_status_ms += LCD_UPDATE_INTERVAL;</front>
<front id="ultralcdCPP-313">            }</front>
<front id="ultralcdCPP-314">          }</front>
<front id="ultralcdCPP-315">          else {</front>
<front id="ultralcdCPP-316">            expire_status_ms = 0;</front>
<front id="ultralcdCPP-317">          }</front>
<front id="ultralcdCPP-318">        #else</front>
<front id="ultralcdCPP-319">          expire_status_ms = 0;</front>
<front id="ultralcdCPP-320">        #endif //SDSUPPORT</front>
<front id="ultralcdCPP-321">      }</front>
<front id="ultralcdCPP-322">    #endif</front>
<front id="ultralcdCPP-323">  #endif //LCD_PROGRESS_BAR</front>
<front id="ultralcdCPP-324"></front>
<front id="ultralcdCPP-325">  lcd_implementation_status_screen();</front>
<front id="ultralcdCPP-326"></front>
<front id="ultralcdCPP-327">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-328"></front>
<front id="ultralcdCPP-329">    bool current_click = LCD_CLICKED;</front>
<front id="ultralcdCPP-330"></front>
<front id="ultralcdCPP-331">    if (ignore_click) {</front>
<front id="ultralcdCPP-332">      if (wait_for_unclick) {</front>
<front id="ultralcdCPP-333">        if (!current_click)</front>
<front id="ultralcdCPP-334">          ignore_click = wait_for_unclick = false;</front>
<front id="ultralcdCPP-335">        else</front>
<front id="ultralcdCPP-336">          current_click = false;</front>
<front id="ultralcdCPP-337">      }</front>
<front id="ultralcdCPP-338">      else if (current_click) {</front>
<front id="ultralcdCPP-339">        lcd_quick_feedback();</front>
<front id="ultralcdCPP-340">        wait_for_unclick = true;</front>
<front id="ultralcdCPP-341">        current_click = false;</front>
<front id="ultralcdCPP-342">      }</front>
<front id="ultralcdCPP-343">    }</front>
<front id="ultralcdCPP-344"></front>
<front id="ultralcdCPP-345">    if (current_click) {</front>
<front id="ultralcdCPP-346">      lcd_goto_menu(lcd_main_menu, true);</front>
<front id="ultralcdCPP-347">      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.</front>
<front id="ultralcdCPP-348">        #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-349">          currentMenu == lcd_status_screen</front>
<front id="ultralcdCPP-350">        #endif</front>
<front id="ultralcdCPP-351">      );</front>
<front id="ultralcdCPP-352">      #if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdCPP-353">        previous_lcd_status_ms = millis();  // get status message to show up for a while</front>
<front id="ultralcdCPP-354">      #endif</front>
<front id="ultralcdCPP-355">    }</front>
<front id="ultralcdCPP-356"></front>
<front id="ultralcdCPP-357">    #if ENABLED(ULTIPANEL_FEEDMULTIPLY)</front>
<front id="ultralcdCPP-358">      // Dead zone at 100% feedrate</front>
<front id="ultralcdCPP-359">      if ((feedrate_multiplier &lt; 100 && (feedrate_multiplier + int(encoderPosition)) &gt; 100) ||</front>
<front id="ultralcdCPP-360">              (feedrate_multiplier &gt; 100 && (feedrate_multiplier + int(encoderPosition)) &lt; 100)) {</front>
<front id="ultralcdCPP-361">        encoderPosition = 0;</front>
<front id="ultralcdCPP-362">        feedrate_multiplier = 100;</front>
<front id="ultralcdCPP-363">      }</front>
<front id="ultralcdCPP-364">      if (feedrate_multiplier == 100) {</front>
<front id="ultralcdCPP-365">        if (int(encoderPosition) &gt; ENCODER_FEEDRATE_DEADZONE) {</front>
<front id="ultralcdCPP-366">          feedrate_multiplier += int(encoderPosition) - ENCODER_FEEDRATE_DEADZONE;</front>
<front id="ultralcdCPP-367">          encoderPosition = 0;</front>
<front id="ultralcdCPP-368">        }</front>
<front id="ultralcdCPP-369">        else if (int(encoderPosition) &lt; -ENCODER_FEEDRATE_DEADZONE) {</front>
<front id="ultralcdCPP-370">          feedrate_multiplier += int(encoderPosition) + ENCODER_FEEDRATE_DEADZONE;</front>
<front id="ultralcdCPP-371">          encoderPosition = 0;</front>
<front id="ultralcdCPP-372">        }</front>
<front id="ultralcdCPP-373">      }</front>
<front id="ultralcdCPP-374">      else {</front>
<front id="ultralcdCPP-375">        feedrate_multiplier += int(encoderPosition);</front>
<front id="ultralcdCPP-376">        encoderPosition = 0;</front>
<front id="ultralcdCPP-377">      }</front>
<front id="ultralcdCPP-378">    #endif // ULTIPANEL_FEEDMULTIPLY</front>
<front id="ultralcdCPP-379"></front>
<front id="ultralcdCPP-380">    feedrate_multiplier = constrain(feedrate_multiplier, 10, 999);</front>
<front id="ultralcdCPP-381"></front>
<front id="ultralcdCPP-382">  #endif //ULTIPANEL</front>
<front id="ultralcdCPP-383">}</front>
<front id="ultralcdCPP-384"></front>
<front id="ultralcdCPP-385">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-386"></front>
<front id="ultralcdCPP-387">static void lcd_return_to_status() { lcd_goto_menu(lcd_status_screen); }</front>
<front id="ultralcdCPP-388"></front>
<front id="ultralcdCPP-389">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-390"></front>
<front id="ultralcdCPP-391">  static void lcd_sdcard_pause() { card.pauseSDPrint(); }</front>
<front id="ultralcdCPP-392"></front>
<front id="ultralcdCPP-393">  static void lcd_sdcard_resume() { card.startFileprint(); }</front>
<front id="ultralcdCPP-394"></front>
<front id="ultralcdCPP-395">  static void lcd_sdcard_stop() {</front>
<front id="ultralcdCPP-396">    quickStop();</front>
<front id="ultralcdCPP-397">    card.sdprinting = false;</front>
<front id="ultralcdCPP-398">    card.closefile();</front>
<front id="ultralcdCPP-399">    autotempShutdown();</front>
<front id="ultralcdCPP-400">    cancel_heatup = true;</front>
<front id="ultralcdCPP-401">    lcd_setstatus(MSG_PRINT_ABORTED, true);</front>
<front id="ultralcdCPP-402">    #if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-403">      planner_disabled_below_z = 0;</front>
<front id="ultralcdCPP-404">    #endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-405">  }</front>
<front id="ultralcdCPP-406"></front>
<front id="ultralcdCPP-407">#endif //SDSUPPORT</front>
<front id="ultralcdCPP-408"></front>
<front id="ultralcdCPP-409">/**</front>
<front id="ultralcdCPP-410"> *</front>
<front id="ultralcdCPP-411"> * "Main" menu</front>
<front id="ultralcdCPP-412"> *</front>
<front id="ultralcdCPP-413"> */</front>
<front id="ultralcdCPP-414"></front>
<front id="ultralcdCPP-415">static void lcd_main_menu() {</front>
<front id="ultralcdCPP-416">  START_MENU();</front>
<front id="ultralcdCPP-417">  MENU_ITEM(back, MSG_WATCH, lcd_status_screen);</front>
<front id="ultralcdCPP-418">  if (movesplanned() || IS_SD_PRINTING) {</front>
<front id="ultralcdCPP-419">    MENU_ITEM(submenu, MSG_TUNE, lcd_tune_menu);</front>
<front id="ultralcdCPP-420">  }</front>
<front id="ultralcdCPP-421">  else {</front>
<front id="ultralcdCPP-422">    MENU_ITEM(submenu, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-423">    #if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="ultralcdCPP-424">      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, lcd_delta_calibrate_menu);</front>
<front id="ultralcdCPP-425">    #endif</front>
<front id="ultralcdCPP-426">  }</front>
<front id="ultralcdCPP-427">  MENU_ITEM(submenu, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-428"></front>
<front id="ultralcdCPP-429">  #if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-430">    if (card.cardOK) {</front>
<front id="ultralcdCPP-431">      if (card.isFileOpen()) {</front>
<front id="ultralcdCPP-432">        if (card.sdprinting)</front>
<front id="ultralcdCPP-433">          MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);</front>
<front id="ultralcdCPP-434">        else</front>
<front id="ultralcdCPP-435">          MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);</front>
<front id="ultralcdCPP-436">        MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);</front>
<front id="ultralcdCPP-437">      }</front>
<front id="ultralcdCPP-438">      else {</front>
<front id="ultralcdCPP-439">        #if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-440">          MENU_ITEM(submenu, MSG_CARD_MENU, lcd_sdcard_print_menu);</front>
<front id="ultralcdCPP-441">          if (current_position[Z_AXIS] &gt; 0)</front>
<front id="ultralcdCPP-442">            MENU_ITEM(submenu, MSG_CARD_RESUME_MENU, lcd_sdcard_resume_menu);</front>
<front id="ultralcdCPP-443">        #endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-444">        #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-445">          MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user</front>
<front id="ultralcdCPP-446">        #endif</front>
<front id="ultralcdCPP-447">      }</front>
<front id="ultralcdCPP-448">    }</front>
<front id="ultralcdCPP-449">    else {</front>
<front id="ultralcdCPP-450">      MENU_ITEM(submenu, MSG_NO_CARD, lcd_sdcard_menu);</front>
<front id="ultralcdCPP-451">      #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-452">        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface</front>
<front id="ultralcdCPP-453">      #endif</front>
<front id="ultralcdCPP-454">    }</front>
<front id="ultralcdCPP-455">  #endif //SDSUPPORT</front>
<front id="ultralcdCPP-456"></front>
<front id="ultralcdCPP-457">  END_MENU();</front>
<front id="ultralcdCPP-458">}</front>
<front id="ultralcdCPP-459"></front>
<front id="ultralcdCPP-460">#if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)</front>
<front id="ultralcdCPP-461">  static void lcd_autostart_sd() {</front>
<front id="ultralcdCPP-462">    card.autostart_index = 0;</front>
<front id="ultralcdCPP-463">    card.setroot();</front>
<front id="ultralcdCPP-464">    card.checkautostart(true);</front>
<front id="ultralcdCPP-465">  }</front>
<front id="ultralcdCPP-466">#endif</front>
<front id="ultralcdCPP-467"></front>
<front id="ultralcdCPP-468">/**</front>
<front id="ultralcdCPP-469"> * Set the home offset based on the current_position</front>
<front id="ultralcdCPP-470"> */</front>
<front id="ultralcdCPP-471">void lcd_set_home_offsets() {</front>
<front id="ultralcdCPP-472">  // M428 Command</front>
<front id="ultralcdCPP-473">  enqueuecommands_P(PSTR("M428"));</front>
<front id="ultralcdCPP-474">  lcd_return_to_status();</front>
<front id="ultralcdCPP-475">}</front>
<front id="ultralcdCPP-476"></front>
<front id="ultralcdCPP-477"></front>
<front id="ultralcdCPP-478">#if ENABLED(BABYSTEPPING)</front>
<front id="ultralcdCPP-479"></front>
<front id="ultralcdCPP-480">  static void _lcd_babystep(int axis, const char *msg) {</front>
<front id="ultralcdCPP-481">    if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-482">      babystepsTodo[axis] += (int)encoderPosition;</front>
<front id="ultralcdCPP-483">      encoderPosition = 0;</front>
<front id="ultralcdCPP-484">      lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-485">    }</front>
<front id="ultralcdCPP-486">    if (lcdDrawUpdate) lcd_implementation_drawedit(msg, "");</front>
<front id="ultralcdCPP-487">    if (LCD_CLICKED) lcd_goto_menu(lcd_tune_menu);</front>
<front id="ultralcdCPP-488">  }</front>
<front id="ultralcdCPP-489">  static void lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEPPING_X)); }</front>
<front id="ultralcdCPP-490">  static void lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEPPING_Y)); }</front>
<front id="ultralcdCPP-491">  static void lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEPPING_Z)); }</front>
<front id="ultralcdCPP-492"></front>
<front id="ultralcdCPP-493">#endif //BABYSTEPPING</front>
<front id="ultralcdCPP-494"></front>
<front id="ultralcdCPP-495">/**</front>
<front id="ultralcdCPP-496"> *</front>
<front id="ultralcdCPP-497"> * "Tune" submenu</front>
<front id="ultralcdCPP-498"> *</front>
<front id="ultralcdCPP-499"> */</front>
<front id="ultralcdCPP-500"></front>
<front id="ultralcdCPP-501">static void lcd_tune_menu() {</front>
<front id="ultralcdCPP-502">  START_MENU();</front>
<front id="ultralcdCPP-503"></front>
<front id="ultralcdCPP-504">  //</front>
<front id="ultralcdCPP-505">  // ^ Main</front>
<front id="ultralcdCPP-506">  //</front>
<front id="ultralcdCPP-507">  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-508"></front>
<front id="ultralcdCPP-509">  //</front>
<front id="ultralcdCPP-510">  // Speed:</front>
<front id="ultralcdCPP-511">  //</front>
<front id="ultralcdCPP-512">  MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_multiplier, 10, 999);</front>
<front id="ultralcdCPP-513"></front>
<front id="ultralcdCPP-514">  //</front>
<front id="ultralcdCPP-515">  // Nozzle:</front>
<front id="ultralcdCPP-516">  // Nozzle 1:</front>
<front id="ultralcdCPP-517">  // Nozzle 2:</front>
<front id="ultralcdCPP-518">  // Nozzle 3:</front>
<front id="ultralcdCPP-519">  // Nozzle 4:</front>
<front id="ultralcdCPP-520">  //</front>
<front id="ultralcdCPP-521">  #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-522">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-523">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-524">    #endif</front>
<front id="ultralcdCPP-525">  #else //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-526">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-527">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N1, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-528">    #endif</front>
<front id="ultralcdCPP-529">    #if TEMP_SENSOR_1 != 0</front>
<front id="ultralcdCPP-530">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);</front>
<front id="ultralcdCPP-531">    #endif</front>
<front id="ultralcdCPP-532">    #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-533">      #if TEMP_SENSOR_2 != 0</front>
<front id="ultralcdCPP-534">        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);</front>
<front id="ultralcdCPP-535">      #endif</front>
<front id="ultralcdCPP-536">      #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-537">        #if TEMP_SENSOR_3 != 0</front>
<front id="ultralcdCPP-538">          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);</front>
<front id="ultralcdCPP-539">        #endif</front>
<front id="ultralcdCPP-540">      #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-541">    #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-542">  #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-543"></front>
<front id="ultralcdCPP-544">  //</front>
<front id="ultralcdCPP-545">  // Bed:</front>
<front id="ultralcdCPP-546">  //</front>
<front id="ultralcdCPP-547">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-548">    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-549">  #endif</front>
<front id="ultralcdCPP-550"></front>
<front id="ultralcdCPP-551">  //</front>
<front id="ultralcdCPP-552">  // Fan Speed:</front>
<front id="ultralcdCPP-553">  //</front>
<front id="ultralcdCPP-554">  MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);</front>
<front id="ultralcdCPP-555"></front>
<front id="ultralcdCPP-556">  //</front>
<front id="ultralcdCPP-557">  // Flow:</front>
<front id="ultralcdCPP-558">  //</front>
<front id="ultralcdCPP-559">  MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[active_extruder], 10, 999);</front>
<front id="ultralcdCPP-560"></front>
<front id="ultralcdCPP-561">  //</front>
<front id="ultralcdCPP-562">  // Flow:</front>
<front id="ultralcdCPP-563">  // Flow 1:</front>
<front id="ultralcdCPP-564">  // Flow 2:</front>
<front id="ultralcdCPP-565">  // Flow 3:</front>
<front id="ultralcdCPP-566">  // Flow 4:</front>
<front id="ultralcdCPP-567">  //</front>
<front id="ultralcdCPP-568">  #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-569">    MENU_ITEM_EDIT(int3, MSG_FLOW, &extruder_multiplier[0], 10, 999);</front>
<front id="ultralcdCPP-570">  #else // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-571">    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N1, &extruder_multiplier[0], 10, 999);</front>
<front id="ultralcdCPP-572">    MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N2, &extruder_multiplier[1], 10, 999);</front>
<front id="ultralcdCPP-573">    #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-574">      MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N3, &extruder_multiplier[2], 10, 999);</front>
<front id="ultralcdCPP-575">      #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-576">        MENU_ITEM_EDIT(int3, MSG_FLOW MSG_N4, &extruder_multiplier[3], 10, 999);</front>
<front id="ultralcdCPP-577">      #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-578">    #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-579">  #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-580"></front>
<front id="ultralcdCPP-581">  #if ENABLED(TRACK_LAYER)</front>
<front id="ultralcdCPP-582">    int layer = current_layer;</front>
<front id="ultralcdCPP-583">    MENU_ITEM_EDIT(int3, MSG_LAYER, &layer, layer, layer);</front>
<front id="ultralcdCPP-584">  #endif //TRACK_LAYER</front>
<front id="ultralcdCPP-585"></front>
<front id="ultralcdCPP-586">  //</front>
<front id="ultralcdCPP-587">  // Babystep X:</front>
<front id="ultralcdCPP-588">  // Babystep Y:</front>
<front id="ultralcdCPP-589">  // Babystep Z:</front>
<front id="ultralcdCPP-590">  //</front>
<front id="ultralcdCPP-591">  #if ENABLED(BABYSTEPPING)</front>
<front id="ultralcdCPP-592">    #if ENABLED(BABYSTEP_XY)</front>
<front id="ultralcdCPP-593">      MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);</front>
<front id="ultralcdCPP-594">      MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);</front>
<front id="ultralcdCPP-595">    #endif //BABYSTEP_XY</front>
<front id="ultralcdCPP-596">    MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);</front>
<front id="ultralcdCPP-597">  #endif</front>
<front id="ultralcdCPP-598"></front>
<front id="ultralcdCPP-599">  //</front>
<front id="ultralcdCPP-600">  // Change filament</front>
<front id="ultralcdCPP-601">  //</front>
<front id="ultralcdCPP-602">  #if ENABLED(FILAMENTCHANGEENABLE)</front>
<front id="ultralcdCPP-603">     MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600"));</front>
<front id="ultralcdCPP-604">  #endif</front>
<front id="ultralcdCPP-605"></front>
<front id="ultralcdCPP-606">  END_MENU();</front>
<front id="ultralcdCPP-607">}</front>
<front id="ultralcdCPP-608"></front>
<front id="ultralcdCPP-609">void _lcd_preheat(int endnum, const float temph, const float tempb, const int fan) {</front>
<front id="ultralcdCPP-610">  if (temph &gt; 0) setTargetHotend(temph, endnum);</front>
<front id="ultralcdCPP-611">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-612">    setTargetBed(tempb);</front>
<front id="ultralcdCPP-613">  #endif</front>
<front id="ultralcdCPP-614">  fanSpeed = fan;</front>
<front id="ultralcdCPP-615">  lcd_return_to_status();</front>
<front id="ultralcdCPP-616">}</front>
<front id="ultralcdCPP-617"></front>
<front id="ultralcdCPP-618">#if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-619">  void lcd_preheat_pla0() { _lcd_preheat(0, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-620">  void lcd_preheat_abs0() { _lcd_preheat(0, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-621">#endif</front>
<front id="ultralcdCPP-622"></front>
<front id="ultralcdCPP-623">#if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-624">  void lcd_preheat_pla1() { _lcd_preheat(1, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-625">  void lcd_preheat_abs1() { _lcd_preheat(1, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-626">  #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-627">    void lcd_preheat_pla2() { _lcd_preheat(2, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-628">    void lcd_preheat_abs2() { _lcd_preheat(2, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-629">    #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-630">      void lcd_preheat_pla3() { _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-631">      void lcd_preheat_abs3() { _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-632">    #endif</front>
<front id="ultralcdCPP-633">  #endif</front>
<front id="ultralcdCPP-634"></front>
<front id="ultralcdCPP-635">  void lcd_preheat_pla0123() {</front>
<front id="ultralcdCPP-636">    setTargetHotend0(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-637">    setTargetHotend1(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-638">    setTargetHotend2(plaPreheatHotendTemp);</front>
<front id="ultralcdCPP-639">    _lcd_preheat(3, plaPreheatHotendTemp, plaPreheatHPBTemp, plaPreheatFanSpeed);</front>
<front id="ultralcdCPP-640">  }</front>
<front id="ultralcdCPP-641">  void lcd_preheat_abs0123() {</front>
<front id="ultralcdCPP-642">    setTargetHotend0(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-643">    setTargetHotend1(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-644">    setTargetHotend2(absPreheatHotendTemp);</front>
<front id="ultralcdCPP-645">    _lcd_preheat(3, absPreheatHotendTemp, absPreheatHPBTemp, absPreheatFanSpeed);</front>
<front id="ultralcdCPP-646">  }</front>
<front id="ultralcdCPP-647"></front>
<front id="ultralcdCPP-648">#endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-649"></front>
<front id="ultralcdCPP-650">#if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-651">  void lcd_preheat_pla_bedonly() { _lcd_preheat(0, 0, plaPreheatHPBTemp, plaPreheatFanSpeed); }</front>
<front id="ultralcdCPP-652">  void lcd_preheat_abs_bedonly() { _lcd_preheat(0, 0, absPreheatHPBTemp, absPreheatFanSpeed); }</front>
<front id="ultralcdCPP-653">#endif</front>
<front id="ultralcdCPP-654"></front>
<front id="ultralcdCPP-655">#if TEMP_SENSOR_0 != 0 && (TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0)</front>
<front id="ultralcdCPP-656"></front>
<front id="ultralcdCPP-657">  static void lcd_preheat_pla_menu() {</front>
<front id="ultralcdCPP-658">    START_MENU();</front>
<front id="ultralcdCPP-659">    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-660">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-661">      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);</front>
<front id="ultralcdCPP-662">    #else</front>
<front id="ultralcdCPP-663">      MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H1, lcd_preheat_pla0);</front>
<front id="ultralcdCPP-664">      MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H2, lcd_preheat_pla1);</front>
<front id="ultralcdCPP-665">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-666">        MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H3, lcd_preheat_pla2);</front>
<front id="ultralcdCPP-667">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-668">          MENU_ITEM(function, MSG_PREHEAT_PLA_N MSG_H4, lcd_preheat_pla3);</front>
<front id="ultralcdCPP-669">        #endif</front>
<front id="ultralcdCPP-670">      #endif</front>
<front id="ultralcdCPP-671">      MENU_ITEM(function, MSG_PREHEAT_PLA_ALL, lcd_preheat_pla0123);</front>
<front id="ultralcdCPP-672">    #endif</front>
<front id="ultralcdCPP-673">    #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-674">      MENU_ITEM(function, MSG_PREHEAT_PLA_BEDONLY, lcd_preheat_pla_bedonly);</front>
<front id="ultralcdCPP-675">    #endif</front>
<front id="ultralcdCPP-676">    END_MENU();</front>
<front id="ultralcdCPP-677">  }</front>
<front id="ultralcdCPP-678"></front>
<front id="ultralcdCPP-679">  static void lcd_preheat_abs_menu() {</front>
<front id="ultralcdCPP-680">    START_MENU();</front>
<front id="ultralcdCPP-681">    MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-682">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-683">      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);</front>
<front id="ultralcdCPP-684">    #else</front>
<front id="ultralcdCPP-685">      MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H1, lcd_preheat_abs0);</front>
<front id="ultralcdCPP-686">      MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H2, lcd_preheat_abs1);</front>
<front id="ultralcdCPP-687">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-688">        MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H3, lcd_preheat_abs2);</front>
<front id="ultralcdCPP-689">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-690">          MENU_ITEM(function, MSG_PREHEAT_ABS_N MSG_H4, lcd_preheat_abs3);</front>
<front id="ultralcdCPP-691">        #endif</front>
<front id="ultralcdCPP-692">      #endif</front>
<front id="ultralcdCPP-693">      MENU_ITEM(function, MSG_PREHEAT_ABS_ALL, lcd_preheat_abs0123);</front>
<front id="ultralcdCPP-694">    #endif</front>
<front id="ultralcdCPP-695">    #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-696">      MENU_ITEM(function, MSG_PREHEAT_ABS_BEDONLY, lcd_preheat_abs_bedonly);</front>
<front id="ultralcdCPP-697">    #endif</front>
<front id="ultralcdCPP-698">    END_MENU();</front>
<front id="ultralcdCPP-699">  }</front>
<front id="ultralcdCPP-700"></front>
<front id="ultralcdCPP-701">#endif // TEMP_SENSOR_0 && (TEMP_SENSOR_1 || TEMP_SENSOR_2 || TEMP_SENSOR_3 || TEMP_SENSOR_BED)</front>
<front id="ultralcdCPP-702"></front>
<front id="ultralcdCPP-703">void lcd_cooldown() {</front>
<front id="ultralcdCPP-704">  disable_all_heaters();</front>
<front id="ultralcdCPP-705">  fanSpeed = 0;</front>
<front id="ultralcdCPP-706">  lcd_return_to_status();</front>
<front id="ultralcdCPP-707">}</front>
<front id="ultralcdCPP-708"></front>
<front id="ultralcdCPP-709">/**</front>
<front id="ultralcdCPP-710"> *</front>
<front id="ultralcdCPP-711"> * "Prepare" submenu</front>
<front id="ultralcdCPP-712"> *</front>
<front id="ultralcdCPP-713"> */</front>
<front id="ultralcdCPP-714"></front>
<front id="ultralcdCPP-715">static void lcd_prepare_menu() {</front>
<front id="ultralcdCPP-716">  START_MENU();</front>
<front id="ultralcdCPP-717"></front>
<front id="ultralcdCPP-718">  //</front>
<front id="ultralcdCPP-719">  // ^ Main</front>
<front id="ultralcdCPP-720">  //</front>
<front id="ultralcdCPP-721">  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-722"></front>
<front id="ultralcdCPP-723">  //</front>
<front id="ultralcdCPP-724">  // Auto Home</front>
<front id="ultralcdCPP-725">  //</front>
<front id="ultralcdCPP-726">  MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));</front>
<front id="ultralcdCPP-727"></front>
<front id="ultralcdCPP-728">  //</front>
<front id="ultralcdCPP-729">  // Set Home Offsets</front>
<front id="ultralcdCPP-730">  //</front>
<front id="ultralcdCPP-731">  MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);</front>
<front id="ultralcdCPP-732">  //MENU_ITEM(gcode, MSG_SET_ORIGIN, PSTR("G92 X0 Y0 Z0"));</front>
<front id="ultralcdCPP-733"></front>
<front id="ultralcdCPP-734">  //</front>
<front id="ultralcdCPP-735">  // Level Bed</front>
<front id="ultralcdCPP-736">  //</front>
<front id="ultralcdCPP-737">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ultralcdCPP-738">    if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS])</front>
<front id="ultralcdCPP-739">      MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G29"));</front>
<front id="ultralcdCPP-740">  #elif ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-741">    MENU_ITEM(submenu, MSG_LEVEL_BED, lcd_level_bed);</front>
<front id="ultralcdCPP-742">  #endif</front>
<front id="ultralcdCPP-743"></front>
<front id="ultralcdCPP-744">  //</front>
<front id="ultralcdCPP-745">  // Move Axis</front>
<front id="ultralcdCPP-746">  //</front>
<front id="ultralcdCPP-747">  MENU_ITEM(submenu, MSG_MOVE_AXIS, lcd_move_menu);</front>
<front id="ultralcdCPP-748"></front>
<front id="ultralcdCPP-749">  //</front>
<front id="ultralcdCPP-750">  // Disable Steppers</front>
<front id="ultralcdCPP-751">  //</front>
<front id="ultralcdCPP-752">  MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));</front>
<front id="ultralcdCPP-753"></front>
<front id="ultralcdCPP-754">  //</front>
<front id="ultralcdCPP-755">  // Preheat PLA</front>
<front id="ultralcdCPP-756">  // Preheat ABS</front>
<front id="ultralcdCPP-757">  //</front>
<front id="ultralcdCPP-758">  #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-759">    #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-760">      MENU_ITEM(submenu, MSG_PREHEAT_PLA, lcd_preheat_pla_menu);</front>
<front id="ultralcdCPP-761">      MENU_ITEM(submenu, MSG_PREHEAT_ABS, lcd_preheat_abs_menu);</front>
<front id="ultralcdCPP-762">    #else</front>
<front id="ultralcdCPP-763">      MENU_ITEM(function, MSG_PREHEAT_PLA, lcd_preheat_pla0);</front>
<front id="ultralcdCPP-764">      MENU_ITEM(function, MSG_PREHEAT_ABS, lcd_preheat_abs0);</front>
<front id="ultralcdCPP-765">    #endif</front>
<front id="ultralcdCPP-766">  #endif</front>
<front id="ultralcdCPP-767"></front>
<front id="ultralcdCPP-768">  //</front>
<front id="ultralcdCPP-769">  // Cooldown</front>
<front id="ultralcdCPP-770">  //</front>
<front id="ultralcdCPP-771">  MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);</front>
<front id="ultralcdCPP-772"></front>
<front id="ultralcdCPP-773">  //</front>
<front id="ultralcdCPP-774">  // Switch power on/off</front>
<front id="ultralcdCPP-775">  //</front>
<front id="ultralcdCPP-776">  #if HAS_POWER_SWITCH</front>
<front id="ultralcdCPP-777">    if (powersupply)</front>
<front id="ultralcdCPP-778">      MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));</front>
<front id="ultralcdCPP-779">    else</front>
<front id="ultralcdCPP-780">      MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));</front>
<front id="ultralcdCPP-781">  #endif</front>
<front id="ultralcdCPP-782"></front>
<front id="ultralcdCPP-783">  //</front>
<front id="ultralcdCPP-784">  // Autostart</front>
<front id="ultralcdCPP-785">  //</front>
<front id="ultralcdCPP-786">  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)</front>
<front id="ultralcdCPP-787">    MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);</front>
<front id="ultralcdCPP-788">  #endif</front>
<front id="ultralcdCPP-789"></front>
<front id="ultralcdCPP-790">  END_MENU();</front>
<front id="ultralcdCPP-791">}</front>
<front id="ultralcdCPP-792"></front>
<front id="ultralcdCPP-793">#if ENABLED(DELTA_CALIBRATION_MENU)</front>
<front id="ultralcdCPP-794"></front>
<front id="ultralcdCPP-795">  static void lcd_delta_calibrate_menu() {</front>
<front id="ultralcdCPP-796">    START_MENU();</front>
<front id="ultralcdCPP-797">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-798">    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));</front>
<front id="ultralcdCPP-799">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_X, PSTR("G0 F8000 X-77.94 Y-45 Z0"));</front>
<front id="ultralcdCPP-800">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Y, PSTR("G0 F8000 X77.94 Y-45 Z0"));</front>
<front id="ultralcdCPP-801">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_Z, PSTR("G0 F8000 X0 Y90 Z0"));</front>
<front id="ultralcdCPP-802">    MENU_ITEM(gcode, MSG_DELTA_CALIBRATE_CENTER, PSTR("G0 F8000 X0 Y0 Z0"));</front>
<front id="ultralcdCPP-803">    END_MENU();</front>
<front id="ultralcdCPP-804">  }</front>
<front id="ultralcdCPP-805"></front>
<front id="ultralcdCPP-806">#endif // DELTA_CALIBRATION_MENU</front>
<front id="ultralcdCPP-807"></front>
<front id="ultralcdCPP-808">inline void line_to_current(AxisEnum axis) {</front>
<front id="ultralcdCPP-809">  #if ENABLED(DELTA)</front>
<front id="ultralcdCPP-810">    calculate_delta(current_position);</front>
<front id="ultralcdCPP-811">    plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);</front>
<front id="ultralcdCPP-812">  #else</front>
<front id="ultralcdCPP-813">    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], manual_feedrate[axis]/60, active_extruder);</front>
<front id="ultralcdCPP-814">  #endif</front>
<front id="ultralcdCPP-815">}</front>
<front id="ultralcdCPP-816"></front>
<front id="ultralcdCPP-817">/**</front>
<front id="ultralcdCPP-818"> *</front>
<front id="ultralcdCPP-819"> * "Prepare" &gt; "Move Axis" submenu</front>
<front id="ultralcdCPP-820"> *</front>
<front id="ultralcdCPP-821"> */</front>
<front id="ultralcdCPP-822"></front>
<front id="ultralcdCPP-823">float move_menu_scale;</front>
<front id="ultralcdCPP-824">static void lcd_move_menu_axis();</front>
<front id="ultralcdCPP-825"></front>
<front id="ultralcdCPP-826">static void _lcd_move(const char *name, AxisEnum axis, int min, int max) {</front>
<front id="ultralcdCPP-827">  if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-828">    refresh_cmd_timeout();</front>
<front id="ultralcdCPP-829">    current_position[axis] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-830">    if (min_software_endstops && current_position[axis] &lt; min) current_position[axis] = min;</front>
<front id="ultralcdCPP-831">    if (max_software_endstops && current_position[axis] &gt; max) current_position[axis] = max;</front>
<front id="ultralcdCPP-832">    encoderPosition = 0;</front>
<front id="ultralcdCPP-833">    line_to_current(axis);</front>
<front id="ultralcdCPP-834">    lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-835">  }</front>
<front id="ultralcdCPP-836">  if (lcdDrawUpdate) lcd_implementation_drawedit(name, ftostr31(current_position[axis]));</front>
<front id="ultralcdCPP-837">  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);</front>
<front id="ultralcdCPP-838">}</front>
<front id="ultralcdCPP-839">static void lcd_move_x() { _lcd_move(PSTR(MSG_MOVE_X), X_AXIS, X_MIN_POS, X_MAX_POS); }</front>
<front id="ultralcdCPP-840">static void lcd_move_y() { _lcd_move(PSTR(MSG_MOVE_Y), Y_AXIS, Y_MIN_POS, Y_MAX_POS); }</front>
<front id="ultralcdCPP-841">static void lcd_move_z() { _lcd_move(PSTR(MSG_MOVE_Z), Z_AXIS, Z_MIN_POS, Z_MAX_POS); }</front>
<front id="ultralcdCPP-842">static void lcd_move_e(</front>
<front id="ultralcdCPP-843">  #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-844">    uint8_t e</front>
<front id="ultralcdCPP-845">  #endif</front>
<front id="ultralcdCPP-846">) {</front>
<front id="ultralcdCPP-847">  #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-848">    unsigned short original_active_extruder = active_extruder;</front>
<front id="ultralcdCPP-849">    active_extruder = e;</front>
<front id="ultralcdCPP-850">  #endif</front>
<front id="ultralcdCPP-851">  if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-852">    current_position[E_AXIS] += float((int)encoderPosition) * move_menu_scale;</front>
<front id="ultralcdCPP-853">    encoderPosition = 0;</front>
<front id="ultralcdCPP-854">    line_to_current(E_AXIS);</front>
<front id="ultralcdCPP-855">    lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-856">  }</front>
<front id="ultralcdCPP-857">  if (lcdDrawUpdate) {</front>
<front id="ultralcdCPP-858">    PGM_P pos_label;</front>
<front id="ultralcdCPP-859">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-860">      pos_label = PSTR(MSG_MOVE_E);</front>
<front id="ultralcdCPP-861">    #else</front>
<front id="ultralcdCPP-862">      switch (e) {</front>
<front id="ultralcdCPP-863">        case 0: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;</front>
<front id="ultralcdCPP-864">        case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;</front>
<front id="ultralcdCPP-865">        #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-866">          case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;</front>
<front id="ultralcdCPP-867">          #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-868">            case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;</front>
<front id="ultralcdCPP-869">          #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-870">        #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-871">      }</front>
<front id="ultralcdCPP-872">    #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-873">    lcd_implementation_drawedit(pos_label, ftostr31(current_position[E_AXIS]));</front>
<front id="ultralcdCPP-874">  }</front>
<front id="ultralcdCPP-875">  if (LCD_CLICKED) lcd_goto_menu(lcd_move_menu_axis);</front>
<front id="ultralcdCPP-876">  #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-877">    active_extruder = original_active_extruder;</front>
<front id="ultralcdCPP-878">  #endif</front>
<front id="ultralcdCPP-879">}</front>
<front id="ultralcdCPP-880"></front>
<front id="ultralcdCPP-881">#if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-882">  static void lcd_move_e0() { lcd_move_e(0); }</front>
<front id="ultralcdCPP-883">  static void lcd_move_e1() { lcd_move_e(1); }</front>
<front id="ultralcdCPP-884">  #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-885">    static void lcd_move_e2() { lcd_move_e(2); }</front>
<front id="ultralcdCPP-886">    #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-887">      static void lcd_move_e3() { lcd_move_e(3); }</front>
<front id="ultralcdCPP-888">    #endif</front>
<front id="ultralcdCPP-889">  #endif</front>
<front id="ultralcdCPP-890">#endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-891"></front>
<front id="ultralcdCPP-892">/**</front>
<front id="ultralcdCPP-893"> *</front>
<front id="ultralcdCPP-894"> * "Prepare" &gt; "Move Xmm" &gt; "Move XYZ" submenu</front>
<front id="ultralcdCPP-895"> *</front>
<front id="ultralcdCPP-896"> */</front>
<front id="ultralcdCPP-897"></front>
<front id="ultralcdCPP-898">static void lcd_move_menu_axis() {</front>
<front id="ultralcdCPP-899">  START_MENU();</front>
<front id="ultralcdCPP-900">  MENU_ITEM(back, MSG_MOVE_AXIS, lcd_move_menu);</front>
<front id="ultralcdCPP-901">  MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_x);</front>
<front id="ultralcdCPP-902">  MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_y);</front>
<front id="ultralcdCPP-903">  if (move_menu_scale &lt; 10.0) {</front>
<front id="ultralcdCPP-904">    MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_z);</front>
<front id="ultralcdCPP-905">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-906">      MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_e);</front>
<front id="ultralcdCPP-907">    #else</front>
<front id="ultralcdCPP-908">      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_e0);</front>
<front id="ultralcdCPP-909">      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_e1);</front>
<front id="ultralcdCPP-910">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-911">        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_e2);</front>
<front id="ultralcdCPP-912">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-913">          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_e3);</front>
<front id="ultralcdCPP-914">        #endif</front>
<front id="ultralcdCPP-915">      #endif</front>
<front id="ultralcdCPP-916">    #endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-917">  }</front>
<front id="ultralcdCPP-918">  END_MENU();</front>
<front id="ultralcdCPP-919">}</front>
<front id="ultralcdCPP-920"></front>
<front id="ultralcdCPP-921">static void lcd_move_menu_10mm() {</front>
<front id="ultralcdCPP-922">  move_menu_scale = 10.0;</front>
<front id="ultralcdCPP-923">  lcd_move_menu_axis();</front>
<front id="ultralcdCPP-924">}</front>
<front id="ultralcdCPP-925">static void lcd_move_menu_1mm() {</front>
<front id="ultralcdCPP-926">  move_menu_scale = 1.0;</front>
<front id="ultralcdCPP-927">  lcd_move_menu_axis();</front>
<front id="ultralcdCPP-928">}</front>
<front id="ultralcdCPP-929">static void lcd_move_menu_01mm() {</front>
<front id="ultralcdCPP-930">  move_menu_scale = 0.1;</front>
<front id="ultralcdCPP-931">  lcd_move_menu_axis();</front>
<front id="ultralcdCPP-932">}</front>
<front id="ultralcdCPP-933"></front>
<front id="ultralcdCPP-934">/**</front>
<front id="ultralcdCPP-935"> *</front>
<front id="ultralcdCPP-936"> * "Prepare" &gt; "Move Axis" submenu</front>
<front id="ultralcdCPP-937"> *</front>
<front id="ultralcdCPP-938"> */</front>
<front id="ultralcdCPP-939"></front>
<front id="ultralcdCPP-940">static void lcd_move_menu() {</front>
<front id="ultralcdCPP-941">  START_MENU();</front>
<front id="ultralcdCPP-942">  MENU_ITEM(back, MSG_PREPARE, lcd_prepare_menu);</front>
<front id="ultralcdCPP-943">  MENU_ITEM(submenu, MSG_MOVE_10MM, lcd_move_menu_10mm);</front>
<front id="ultralcdCPP-944">  MENU_ITEM(submenu, MSG_MOVE_1MM, lcd_move_menu_1mm);</front>
<front id="ultralcdCPP-945">  MENU_ITEM(submenu, MSG_MOVE_01MM, lcd_move_menu_01mm);</front>
<front id="ultralcdCPP-946">  //TODO:X,Y,Z,E</front>
<front id="ultralcdCPP-947">  END_MENU();</front>
<front id="ultralcdCPP-948">}</front>
<front id="ultralcdCPP-949"></front>
<front id="ultralcdCPP-950">/**</front>
<front id="ultralcdCPP-951"> *</front>
<front id="ultralcdCPP-952"> * "Control" submenu</front>
<front id="ultralcdCPP-953"> *</front>
<front id="ultralcdCPP-954"> */</front>
<front id="ultralcdCPP-955"></front>
<front id="ultralcdCPP-956">static void lcd_control_menu() {</front>
<front id="ultralcdCPP-957">  START_MENU();</front>
<front id="ultralcdCPP-958">  MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-959">  MENU_ITEM(submenu, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-960">  MENU_ITEM(submenu, MSG_MOTION, lcd_control_motion_menu);</front>
<front id="ultralcdCPP-961">  MENU_ITEM(submenu, MSG_VOLUMETRIC, lcd_control_volumetric_menu);</front>
<front id="ultralcdCPP-962"></front>
<front id="ultralcdCPP-963">  #if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-964">    //MENU_ITEM_EDIT(int3, MSG_CONTRAST, &lcd_contrast, 0, 63);</front>
<front id="ultralcdCPP-965">    MENU_ITEM(submenu, MSG_CONTRAST, lcd_set_contrast);</front>
<front id="ultralcdCPP-966">  #endif</front>
<front id="ultralcdCPP-967">  #if ENABLED(FWRETRACT)</front>
<front id="ultralcdCPP-968">    MENU_ITEM(submenu, MSG_RETRACT, lcd_control_retract_menu);</front>
<front id="ultralcdCPP-969">  #endif</front>
<front id="ultralcdCPP-970">  #if ENABLED(EEPROM_SETTINGS)</front>
<front id="ultralcdCPP-971">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-972">    MENU_ITEM(function, MSG_LOAD_EPROM, Config_RetrieveSettings);</front>
<front id="ultralcdCPP-973">  #endif</front>
<front id="ultralcdCPP-974">  MENU_ITEM(function, MSG_RESTORE_FAILSAFE, Config_ResetDefault);</front>
<front id="ultralcdCPP-975">  END_MENU();</front>
<front id="ultralcdCPP-976">}</front>
<front id="ultralcdCPP-977"></front>
<front id="ultralcdCPP-978">/**</front>
<front id="ultralcdCPP-979"> *</front>
<front id="ultralcdCPP-980"> * "Temperature" submenu</front>
<front id="ultralcdCPP-981"> *</front>
<front id="ultralcdCPP-982"> */</front>
<front id="ultralcdCPP-983"></front>
<front id="ultralcdCPP-984">#if ENABLED(PIDTEMP)</front>
<front id="ultralcdCPP-985"></front>
<front id="ultralcdCPP-986">  // Helpers for editing PID Ki & Kd values</front>
<front id="ultralcdCPP-987">  // grab the PID value out of the temp variable; scale it; then update the PID driver</front>
<front id="ultralcdCPP-988">  void copy_and_scalePID_i(int e) {</front>
<front id="ultralcdCPP-989">    PID_PARAM(Ki, e) = scalePID_i(raw_Ki);</front>
<front id="ultralcdCPP-990">    updatePID();</front>
<front id="ultralcdCPP-991">  }</front>
<front id="ultralcdCPP-992">  void copy_and_scalePID_d(int e) {</front>
<front id="ultralcdCPP-993">    PID_PARAM(Kd, e) = scalePID_d(raw_Kd);</front>
<front id="ultralcdCPP-994">    updatePID();</front>
<front id="ultralcdCPP-995">  }</front>
<front id="ultralcdCPP-996">  #define COPY_AND_SCALE(eindex) \</front>
<front id="ultralcdCPP-997">    void copy_and_scalePID_i_E ## eindex() { copy_and_scalePID_i(eindex); } \</front>
<front id="ultralcdCPP-998">    void copy_and_scalePID_d_E ## eindex() { copy_and_scalePID_d(eindex); }</front>
<front id="ultralcdCPP-999"></front>
<front id="ultralcdCPP-1000">  COPY_AND_SCALE(0);</front>
<front id="ultralcdCPP-1001">  #if ENABLED(PID_PARAMS_PER_EXTRUDER)</front>
<front id="ultralcdCPP-1002">    #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1003">      COPY_AND_SCALE(1);</front>
<front id="ultralcdCPP-1004">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1005">        COPY_AND_SCALE(2);</front>
<front id="ultralcdCPP-1006">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1007">          COPY_AND_SCALE(3);</front>
<front id="ultralcdCPP-1008">        #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1009">      #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1010">    #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1011">  #endif //PID_PARAMS_PER_EXTRUDER</front>
<front id="ultralcdCPP-1012"></front>
<front id="ultralcdCPP-1013">#endif //PIDTEMP</front>
<front id="ultralcdCPP-1014"></front>
<front id="ultralcdCPP-1015">/**</front>
<front id="ultralcdCPP-1016"> *</front>
<front id="ultralcdCPP-1017"> * "Control" &gt; "Temperature" submenu</front>
<front id="ultralcdCPP-1018"> *</front>
<front id="ultralcdCPP-1019"> */</front>
<front id="ultralcdCPP-1020">static void lcd_control_temperature_menu() {</front>
<front id="ultralcdCPP-1021">  START_MENU();</front>
<front id="ultralcdCPP-1022"></front>
<front id="ultralcdCPP-1023">  //</front>
<front id="ultralcdCPP-1024">  // ^ Control</front>
<front id="ultralcdCPP-1025">  //</front>
<front id="ultralcdCPP-1026">  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1027"></front>
<front id="ultralcdCPP-1028">  //</front>
<front id="ultralcdCPP-1029">  // Nozzle</front>
<front id="ultralcdCPP-1030">  // Nozzle 1, Nozzle 2, Nozzle 3, Nozzle 4</front>
<front id="ultralcdCPP-1031">  //</front>
<front id="ultralcdCPP-1032">  #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-1033">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1034">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1035">    #endif</front>
<front id="ultralcdCPP-1036">  #else //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1037">    #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1038">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N1, &target_temperature[0], 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1039">    #endif</front>
<front id="ultralcdCPP-1040">    #if TEMP_SENSOR_1 != 0</front>
<front id="ultralcdCPP-1041">      MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N2, &target_temperature[1], 0, HEATER_1_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1042">    #endif</front>
<front id="ultralcdCPP-1043">    #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1044">      #if TEMP_SENSOR_2 != 0</front>
<front id="ultralcdCPP-1045">        MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N3, &target_temperature[2], 0, HEATER_2_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1046">      #endif</front>
<front id="ultralcdCPP-1047">      #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1048">        #if TEMP_SENSOR_3 != 0</front>
<front id="ultralcdCPP-1049">          MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_NOZZLE MSG_N4, &target_temperature[3], 0, HEATER_3_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1050">        #endif</front>
<front id="ultralcdCPP-1051">      #endif // EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1052">    #endif // EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1053">  #endif // EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1054"></front>
<front id="ultralcdCPP-1055">  //</front>
<front id="ultralcdCPP-1056">  // Bed</front>
<front id="ultralcdCPP-1057">  //</front>
<front id="ultralcdCPP-1058">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-1059">    MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_BED, &target_temperature_bed, 0, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1060">  #endif</front>
<front id="ultralcdCPP-1061"></front>
<front id="ultralcdCPP-1062">  //</front>
<front id="ultralcdCPP-1063">  // Fan Speed</front>
<front id="ultralcdCPP-1064">  //</front>
<front id="ultralcdCPP-1065">  MENU_MULTIPLIER_ITEM_EDIT(int3, MSG_FAN_SPEED, &fanSpeed, 0, 255);</front>
<front id="ultralcdCPP-1066"></front>
<front id="ultralcdCPP-1067">  //</front>
<front id="ultralcdCPP-1068">  // Autotemp, Min, Max, Fact</front>
<front id="ultralcdCPP-1069">  //</front>
<front id="ultralcdCPP-1070">  #if ENABLED(AUTOTEMP) && (TEMP_SENSOR_0 != 0)</front>
<front id="ultralcdCPP-1071">    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &autotemp_enabled);</front>
<front id="ultralcdCPP-1072">    MENU_ITEM_EDIT(float3, MSG_MIN, &autotemp_min, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1073">    MENU_ITEM_EDIT(float3, MSG_MAX, &autotemp_max, 0, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1074">    MENU_ITEM_EDIT(float32, MSG_FACTOR, &autotemp_factor, 0.0, 1.0);</front>
<front id="ultralcdCPP-1075">  #endif</front>
<front id="ultralcdCPP-1076"></front>
<front id="ultralcdCPP-1077">  //</front>
<front id="ultralcdCPP-1078">  // PID-P, PID-I, PID-D, PID-C</front>
<front id="ultralcdCPP-1079">  // PID-P E1, PID-I E1, PID-D E1, PID-C E1</front>
<front id="ultralcdCPP-1080">  // PID-P E2, PID-I E2, PID-D E2, PID-C E2</front>
<front id="ultralcdCPP-1081">  // PID-P E3, PID-I E3, PID-D E3, PID-C E3</front>
<front id="ultralcdCPP-1082">  // PID-P E4, PID-I E4, PID-D E4, PID-C E4</front>
<front id="ultralcdCPP-1083">  //</front>
<front id="ultralcdCPP-1084">  #if ENABLED(PIDTEMP)</front>
<front id="ultralcdCPP-1085"></front>
<front id="ultralcdCPP-1086">    #define _PID_MENU_ITEMS(ELABEL, eindex) \</front>
<front id="ultralcdCPP-1087">      raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \</front>
<front id="ultralcdCPP-1088">      raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \</front>
<front id="ultralcdCPP-1089">      MENU_ITEM_EDIT(float52, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \</front>
<front id="ultralcdCPP-1090">      MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_I ELABEL, &raw_Ki, 0.01, 9990, copy_and_scalePID_i_E ## eindex); \</front>
<front id="ultralcdCPP-1091">      MENU_ITEM_EDIT_CALLBACK(float52, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)</front>
<front id="ultralcdCPP-1092"></front>
<front id="ultralcdCPP-1093">    #if ENABLED(PID_ADD_EXTRUSION_RATE)</front>
<front id="ultralcdCPP-1094">      #define PID_MENU_ITEMS(ELABEL, eindex) \</front>
<front id="ultralcdCPP-1095">        _PID_MENU_ITEMS(ELABEL, eindex); \</front>
<front id="ultralcdCPP-1096">        MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)</front>
<front id="ultralcdCPP-1097">    #else</front>
<front id="ultralcdCPP-1098">      #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)</front>
<front id="ultralcdCPP-1099">    #endif</front>
<front id="ultralcdCPP-1100"></front>
<front id="ultralcdCPP-1101">    #if ENABLED(PID_PARAMS_PER_EXTRUDER) && EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1102">      PID_MENU_ITEMS(MSG_E1, 0);</front>
<front id="ultralcdCPP-1103">      PID_MENU_ITEMS(MSG_E2, 1);</front>
<front id="ultralcdCPP-1104">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1105">        PID_MENU_ITEMS(MSG_E3, 2);</front>
<front id="ultralcdCPP-1106">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1107">          PID_MENU_ITEMS(MSG_E4, 3);</front>
<front id="ultralcdCPP-1108">        #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1109">      #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1110">    #else //!PID_PARAMS_PER_EXTRUDER || EXTRUDERS == 1</front>
<front id="ultralcdCPP-1111">      PID_MENU_ITEMS("", 0);</front>
<front id="ultralcdCPP-1112">    #endif //!PID_PARAMS_PER_EXTRUDER || EXTRUDERS == 1</front>
<front id="ultralcdCPP-1113"></front>
<front id="ultralcdCPP-1114">  #endif //PIDTEMP</front>
<front id="ultralcdCPP-1115"></front>
<front id="ultralcdCPP-1116">  //</front>
<front id="ultralcdCPP-1117">  // Preheat PLA conf</front>
<front id="ultralcdCPP-1118">  //</front>
<front id="ultralcdCPP-1119">  MENU_ITEM(submenu, MSG_PREHEAT_PLA_SETTINGS, lcd_control_temperature_preheat_pla_settings_menu);</front>
<front id="ultralcdCPP-1120"></front>
<front id="ultralcdCPP-1121">  //</front>
<front id="ultralcdCPP-1122">  // Preheat ABS conf</front>
<front id="ultralcdCPP-1123">  //</front>
<front id="ultralcdCPP-1124">  MENU_ITEM(submenu, MSG_PREHEAT_ABS_SETTINGS, lcd_control_temperature_preheat_abs_settings_menu);</front>
<front id="ultralcdCPP-1125">  END_MENU();</front>
<front id="ultralcdCPP-1126">}</front>
<front id="ultralcdCPP-1127"></front>
<front id="ultralcdCPP-1128">/**</front>
<front id="ultralcdCPP-1129"> *</front>
<front id="ultralcdCPP-1130"> * "Temperature" &gt; "Preheat PLA conf" submenu</front>
<front id="ultralcdCPP-1131"> *</front>
<front id="ultralcdCPP-1132"> */</front>
<front id="ultralcdCPP-1133">static void lcd_control_temperature_preheat_pla_settings_menu() {</front>
<front id="ultralcdCPP-1134">  START_MENU();</front>
<front id="ultralcdCPP-1135">  MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-1136">  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &plaPreheatFanSpeed, 0, 255);</front>
<front id="ultralcdCPP-1137">  #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1138">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &plaPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1139">  #endif</front>
<front id="ultralcdCPP-1140">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-1141">    MENU_ITEM_EDIT(int3, MSG_BED, &plaPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1142">  #endif</front>
<front id="ultralcdCPP-1143">  #if ENABLED(EEPROM_SETTINGS)</front>
<front id="ultralcdCPP-1144">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-1145">  #endif</front>
<front id="ultralcdCPP-1146">  END_MENU();</front>
<front id="ultralcdCPP-1147">}</front>
<front id="ultralcdCPP-1148"></front>
<front id="ultralcdCPP-1149">/**</front>
<front id="ultralcdCPP-1150"> *</front>
<front id="ultralcdCPP-1151"> * "Temperature" &gt; "Preheat ABS conf" submenu</front>
<front id="ultralcdCPP-1152"> *</front>
<front id="ultralcdCPP-1153"> */</front>
<front id="ultralcdCPP-1154">static void lcd_control_temperature_preheat_abs_settings_menu() {</front>
<front id="ultralcdCPP-1155">  START_MENU();</front>
<front id="ultralcdCPP-1156">  MENU_ITEM(back, MSG_TEMPERATURE, lcd_control_temperature_menu);</front>
<front id="ultralcdCPP-1157">  MENU_ITEM_EDIT(int3, MSG_FAN_SPEED, &absPreheatFanSpeed, 0, 255);</front>
<front id="ultralcdCPP-1158">  #if TEMP_SENSOR_0 != 0</front>
<front id="ultralcdCPP-1159">    MENU_ITEM_EDIT(int3, MSG_NOZZLE, &absPreheatHotendTemp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1160">  #endif</front>
<front id="ultralcdCPP-1161">  #if TEMP_SENSOR_BED != 0</front>
<front id="ultralcdCPP-1162">    MENU_ITEM_EDIT(int3, MSG_BED, &absPreheatHPBTemp, BED_MINTEMP, BED_MAXTEMP - 15);</front>
<front id="ultralcdCPP-1163">  #endif</front>
<front id="ultralcdCPP-1164">  #if ENABLED(EEPROM_SETTINGS)</front>
<front id="ultralcdCPP-1165">    MENU_ITEM(function, MSG_STORE_EPROM, Config_StoreSettings);</front>
<front id="ultralcdCPP-1166">  #endif</front>
<front id="ultralcdCPP-1167">  END_MENU();</front>
<front id="ultralcdCPP-1168">}</front>
<front id="ultralcdCPP-1169"></front>
<front id="ultralcdCPP-1170">/**</front>
<front id="ultralcdCPP-1171"> *</front>
<front id="ultralcdCPP-1172"> * "Control" &gt; "Motion" submenu</front>
<front id="ultralcdCPP-1173"> *</front>
<front id="ultralcdCPP-1174"> */</front>
<front id="ultralcdCPP-1175">static void lcd_control_motion_menu() {</front>
<front id="ultralcdCPP-1176">  START_MENU();</front>
<front id="ultralcdCPP-1177">  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1178">  #if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="ultralcdCPP-1179">    MENU_ITEM_EDIT(float32, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);</front>
<front id="ultralcdCPP-1180">  #endif</front>
<front id="ultralcdCPP-1181">  MENU_ITEM_EDIT(float5, MSG_ACC, &acceleration, 10, 99000);</front>
<front id="ultralcdCPP-1182">  MENU_ITEM_EDIT(float3, MSG_VXY_JERK, &max_xy_jerk, 1, 990);</front>
<front id="ultralcdCPP-1183">  MENU_ITEM_EDIT(float52, MSG_VZ_JERK, &max_z_jerk, 0.1, 990);</front>
<front id="ultralcdCPP-1184">  MENU_ITEM_EDIT(float3, MSG_VE_JERK, &max_e_jerk, 1, 990);</front>
<front id="ultralcdCPP-1185">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_X, &max_feedrate[X_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1186">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Y, &max_feedrate[Y_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1187">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_Z, &max_feedrate[Z_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1188">  MENU_ITEM_EDIT(float3, MSG_VMAX MSG_E, &max_feedrate[E_AXIS], 1, 999);</front>
<front id="ultralcdCPP-1189">  MENU_ITEM_EDIT(float3, MSG_VMIN, &minimumfeedrate, 0, 999);</front>
<front id="ultralcdCPP-1190">  MENU_ITEM_EDIT(float3, MSG_VTRAV_MIN, &mintravelfeedrate, 0, 999);</front>
<front id="ultralcdCPP-1191">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_X, &max_acceleration_units_per_sq_second[X_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1192">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Y, &max_acceleration_units_per_sq_second[Y_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1193">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_Z, &max_acceleration_units_per_sq_second[Z_AXIS], 10, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1194">  MENU_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &max_acceleration_units_per_sq_second[E_AXIS], 100, 99000, reset_acceleration_rates);</front>
<front id="ultralcdCPP-1195">  MENU_ITEM_EDIT(float5, MSG_A_RETRACT, &retract_acceleration, 100, 99000);</front>
<front id="ultralcdCPP-1196">  MENU_ITEM_EDIT(float5, MSG_A_TRAVEL, &travel_acceleration, 100, 99000);</front>
<front id="ultralcdCPP-1197">  MENU_ITEM_EDIT(float52, MSG_XSTEPS, &axis_steps_per_unit[X_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1198">  MENU_ITEM_EDIT(float52, MSG_YSTEPS, &axis_steps_per_unit[Y_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1199">  MENU_ITEM_EDIT(float51, MSG_ZSTEPS, &axis_steps_per_unit[Z_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1200">  MENU_ITEM_EDIT(float51, MSG_ESTEPS, &axis_steps_per_unit[E_AXIS], 5, 9999);</front>
<front id="ultralcdCPP-1201">  #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</front>
<front id="ultralcdCPP-1202">    MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &abort_on_endstop_hit);</front>
<front id="ultralcdCPP-1203">  #endif</front>
<front id="ultralcdCPP-1204">  #if ENABLED(SCARA)</front>
<front id="ultralcdCPP-1205">    MENU_ITEM_EDIT(float74, MSG_XSCALE, &axis_scaling[X_AXIS],0.5,2);</front>
<front id="ultralcdCPP-1206">    MENU_ITEM_EDIT(float74, MSG_YSCALE, &axis_scaling[Y_AXIS],0.5,2);</front>
<front id="ultralcdCPP-1207">  #endif</front>
<front id="ultralcdCPP-1208">  END_MENU();</front>
<front id="ultralcdCPP-1209">}</front>
<front id="ultralcdCPP-1210"></front>
<front id="ultralcdCPP-1211">/**</front>
<front id="ultralcdCPP-1212"> *</front>
<front id="ultralcdCPP-1213"> * "Control" &gt; "Filament" submenu</front>
<front id="ultralcdCPP-1214"> *</front>
<front id="ultralcdCPP-1215"> */</front>
<front id="ultralcdCPP-1216">static void lcd_control_volumetric_menu() {</front>
<front id="ultralcdCPP-1217">  START_MENU();</front>
<front id="ultralcdCPP-1218">  MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1219"></front>
<front id="ultralcdCPP-1220">  MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &volumetric_enabled, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1221"></front>
<front id="ultralcdCPP-1222">  if (volumetric_enabled) {</front>
<front id="ultralcdCPP-1223">    #if EXTRUDERS == 1</front>
<front id="ultralcdCPP-1224">      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1225">    #else //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1226">      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &filament_size[0], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1227">      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &filament_size[1], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1228">      #if EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1229">        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &filament_size[2], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1230">        #if EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1231">          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &filament_size[3], 1.5, 3.25, calculate_volumetric_multipliers);</front>
<front id="ultralcdCPP-1232">        #endif //EXTRUDERS &gt; 3</front>
<front id="ultralcdCPP-1233">      #endif //EXTRUDERS &gt; 2</front>
<front id="ultralcdCPP-1234">    #endif //EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1235">  }</front>
<front id="ultralcdCPP-1236"></front>
<front id="ultralcdCPP-1237">  END_MENU();</front>
<front id="ultralcdCPP-1238">}</front>
<front id="ultralcdCPP-1239"></front>
<front id="ultralcdCPP-1240">/**</front>
<front id="ultralcdCPP-1241"> *</front>
<front id="ultralcdCPP-1242"> * "Control" &gt; "Contrast" submenu</front>
<front id="ultralcdCPP-1243"> *</front>
<front id="ultralcdCPP-1244"> */</front>
<front id="ultralcdCPP-1245">#if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-1246">  static void lcd_set_contrast() {</front>
<front id="ultralcdCPP-1247">    if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-1248">      #if ENABLED(U8GLIB_LM6059_AF)</front>
<front id="ultralcdCPP-1249">        lcd_contrast += encoderPosition;</front>
<front id="ultralcdCPP-1250">        lcd_contrast &= 0xFF;</front>
<front id="ultralcdCPP-1251">      #else</front>
<front id="ultralcdCPP-1252">        lcd_contrast -= encoderPosition;</front>
<front id="ultralcdCPP-1253">        lcd_contrast &= 0x3F;</front>
<front id="ultralcdCPP-1254">      #endif</front>
<front id="ultralcdCPP-1255">      encoderPosition = 0;</front>
<front id="ultralcdCPP-1256">      lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1257">      u8g.setContrast(lcd_contrast);</front>
<front id="ultralcdCPP-1258">    }</front>
<front id="ultralcdCPP-1259">    if (lcdDrawUpdate) {</front>
<front id="ultralcdCPP-1260">      #if ENABLED(U8GLIB_LM6059_AF)</front>
<front id="ultralcdCPP-1261">        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr3(lcd_contrast));</front>
<front id="ultralcdCPP-1262">      #else</front>
<front id="ultralcdCPP-1263">        lcd_implementation_drawedit(PSTR(MSG_CONTRAST), itostr2(lcd_contrast));</front>
<front id="ultralcdCPP-1264">      #endif</front>
<front id="ultralcdCPP-1265">    }</front>
<front id="ultralcdCPP-1266">    if (LCD_CLICKED) lcd_goto_menu(lcd_control_menu);</front>
<front id="ultralcdCPP-1267">  }</front>
<front id="ultralcdCPP-1268">#endif // HAS_LCD_CONTRAST</front>
<front id="ultralcdCPP-1269"></front>
<front id="ultralcdCPP-1270">/**</front>
<front id="ultralcdCPP-1271"> *</front>
<front id="ultralcdCPP-1272"> * "Control" &gt; "Retract" submenu</front>
<front id="ultralcdCPP-1273"> *</front>
<front id="ultralcdCPP-1274"> */</front>
<front id="ultralcdCPP-1275">#if ENABLED(FWRETRACT)</front>
<front id="ultralcdCPP-1276">  static void lcd_control_retract_menu() {</front>
<front id="ultralcdCPP-1277">    START_MENU();</front>
<front id="ultralcdCPP-1278">    MENU_ITEM(back, MSG_CONTROL, lcd_control_menu);</front>
<front id="ultralcdCPP-1279">    MENU_ITEM_EDIT(bool, MSG_AUTORETRACT, &autoretract_enabled);</front>
<front id="ultralcdCPP-1280">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT, &retract_length, 0, 100);</front>
<front id="ultralcdCPP-1281">    #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1282">      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_SWAP, &retract_length_swap, 0, 100);</front>
<front id="ultralcdCPP-1283">    #endif</front>
<front id="ultralcdCPP-1284">    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &retract_feedrate, 1, 999);</front>
<front id="ultralcdCPP-1285">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_ZLIFT, &retract_zlift, 0, 999);</front>
<front id="ultralcdCPP-1286">    MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER, &retract_recover_length, 0, 100);</front>
<front id="ultralcdCPP-1287">    #if EXTRUDERS &gt; 1</front>
<front id="ultralcdCPP-1288">      MENU_ITEM_EDIT(float52, MSG_CONTROL_RETRACT_RECOVER_SWAP, &retract_recover_length_swap, 0, 100);</front>
<front id="ultralcdCPP-1289">    #endif</front>
<front id="ultralcdCPP-1290">    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &retract_recover_feedrate, 1, 999);</front>
<front id="ultralcdCPP-1291">    END_MENU();</front>
<front id="ultralcdCPP-1292">  }</front>
<front id="ultralcdCPP-1293">#endif // FWRETRACT</front>
<front id="ultralcdCPP-1294"></front>
<front id="ultralcdCPP-1295">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-1296"></front>
<front id="ultralcdCPP-1297">  #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1298">    static void lcd_sd_refresh() {</front>
<front id="ultralcdCPP-1299">      card.initsd();</front>
<front id="ultralcdCPP-1300">      currentMenuViewOffset = 0;</front>
<front id="ultralcdCPP-1301">    }</front>
<front id="ultralcdCPP-1302">  #endif</front>
<front id="ultralcdCPP-1303"></front>
<front id="ultralcdCPP-1304">  static void lcd_sd_updir() {</front>
<front id="ultralcdCPP-1305">    card.updir();</front>
<front id="ultralcdCPP-1306">    currentMenuViewOffset = 0;</front>
<front id="ultralcdCPP-1307">  }</front>
<front id="ultralcdCPP-1308"></front>
<front id="ultralcdCPP-1309">#if ENABLED(RESUME_FEATURE)</front>
<front id="ultralcdCPP-1310">  // Print from SD</front>
<front id="ultralcdCPP-1311">  void lcd_sdcard_print_menu() {</front>
<front id="ultralcdCPP-1312">    planner_disabled_below_z = 0;</front>
<front id="ultralcdCPP-1313">    lcd_sdcard_menu();</front>
<front id="ultralcdCPP-1314">  }</front>
<front id="ultralcdCPP-1315"></front>
<front id="ultralcdCPP-1316">  // Print from SD but set flag to ignore movements below a certain Z</front>
<front id="ultralcdCPP-1317">  void lcd_sdcard_resume_menu() {</front>
<front id="ultralcdCPP-1318">    planner_disabled_below_z = current_position[Z_AXIS];</front>
<front id="ultralcdCPP-1319">    last_z = 0;</front>
<front id="ultralcdCPP-1320">    z_reached = false;</front>
<front id="ultralcdCPP-1321">    layer_reached = false;</front>
<front id="ultralcdCPP-1322">    hops = false;</front>
<front id="ultralcdCPP-1323">    gone_up = false;</front>
<front id="ultralcdCPP-1324">    lcd_sdcard_menu();</front>
<front id="ultralcdCPP-1325">  }</front>
<front id="ultralcdCPP-1326">#endif //RESUME_FEATURE</front>
<front id="ultralcdCPP-1327"></front>
<front id="ultralcdCPP-1328">  /**</front>
<front id="ultralcdCPP-1329">   *</front>
<front id="ultralcdCPP-1330">   * "Print from SD" submenu</front>
<front id="ultralcdCPP-1331">   *</front>
<front id="ultralcdCPP-1332">   */</front>
<front id="ultralcdCPP-1333">  void lcd_sdcard_menu() {</front>
<front id="ultralcdCPP-1334">    if (lcdDrawUpdate == 0 && LCD_CLICKED == 0) return;	// nothing to do (so don't thrash the SD card)</front>
<front id="ultralcdCPP-1335">    uint16_t fileCnt = card.getnrfilenames();</front>
<front id="ultralcdCPP-1336">    START_MENU();</front>
<front id="ultralcdCPP-1337">    MENU_ITEM(back, MSG_MAIN, lcd_main_menu);</front>
<front id="ultralcdCPP-1338">    card.getWorkDirName();</front>
<front id="ultralcdCPP-1339">    if (card.filename[0] == '/') {</front>
<front id="ultralcdCPP-1340">      #if !PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1341">        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);</front>
<front id="ultralcdCPP-1342">      #endif</front>
<front id="ultralcdCPP-1343">    }</front>
<front id="ultralcdCPP-1344">    else {</front>
<front id="ultralcdCPP-1345">      MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);</front>
<front id="ultralcdCPP-1346">    }</front>
<front id="ultralcdCPP-1347"></front>
<front id="ultralcdCPP-1348">    for (uint16_t i = 0; i &lt; fileCnt; i++) {</front>
<front id="ultralcdCPP-1349">      if (_menuItemNr == _lineNr) {</front>
<front id="ultralcdCPP-1350">        card.getfilename(</front>
<front id="ultralcdCPP-1351">          #if ENABLED(SDCARD_RATHERRECENTFIRST)</front>
<front id="ultralcdCPP-1352">            fileCnt-1 -</front>
<front id="ultralcdCPP-1353">          #endif</front>
<front id="ultralcdCPP-1354">          i</front>
<front id="ultralcdCPP-1355">        );</front>
<front id="ultralcdCPP-1356">        if (card.filenameIsDir)</front>
<front id="ultralcdCPP-1357">          MENU_ITEM(sddirectory, MSG_CARD_MENU, card.filename, card.longFilename);</front>
<front id="ultralcdCPP-1358">        else</front>
<front id="ultralcdCPP-1359">          MENU_ITEM(sdfile, MSG_CARD_MENU, card.filename, card.longFilename);</front>
<front id="ultralcdCPP-1360">      }</front>
<front id="ultralcdCPP-1361">      else {</front>
<front id="ultralcdCPP-1362">        MENU_ITEM_DUMMY();</front>
<front id="ultralcdCPP-1363">      }</front>
<front id="ultralcdCPP-1364">    }</front>
<front id="ultralcdCPP-1365">    END_MENU();</front>
<front id="ultralcdCPP-1366">  }</front>
<front id="ultralcdCPP-1367"></front>
<front id="ultralcdCPP-1368"> #endif //SDSUPPORT</front>
<front id="ultralcdCPP-1369"></front>
<front id="ultralcdCPP-1370">/**</front>
<front id="ultralcdCPP-1371"> *</front>
<front id="ultralcdCPP-1372"> * Functions for editing single values</front>
<front id="ultralcdCPP-1373"> *</front>
<front id="ultralcdCPP-1374"> */</front>
<front id="ultralcdCPP-1375">#define menu_edit_type(_type, _name, _strFunc, scale) \</front>
<front id="ultralcdCPP-1376">  bool _menu_edit_ ## _name () { \</front>
<front id="ultralcdCPP-1377">    bool isClicked = LCD_CLICKED; \</front>
<front id="ultralcdCPP-1378">    if ((int32_t)encoderPosition &lt; 0) encoderPosition = 0; \</front>
<front id="ultralcdCPP-1379">    if ((int32_t)encoderPosition &gt; maxEditValue) encoderPosition = maxEditValue; \</front>
<front id="ultralcdCPP-1380">    if (lcdDrawUpdate) \</front>
<front id="ultralcdCPP-1381">        lcd_implementation_drawedit(editLabel, _strFunc(((_type)((int32_t)encoderPosition + minEditValue)) / scale)); \</front>
<front id="ultralcdCPP-1382">    if (isClicked) { \</front>
<front id="ultralcdCPP-1383">      *((_type*)editValue) = ((_type)((int32_t)encoderPosition + minEditValue)) / scale; \</front>
<front id="ultralcdCPP-1384">      lcd_goto_menu(prevMenu, prevEncoderPosition); \</front>
<front id="ultralcdCPP-1385">    } \</front>
<front id="ultralcdCPP-1386">    return isClicked; \</front>
<front id="ultralcdCPP-1387">  } \</front>
<front id="ultralcdCPP-1388">  void menu_edit_ ## _name () { _menu_edit_ ## _name(); } \</front>
<front id="ultralcdCPP-1389">  void menu_edit_callback_ ## _name () { if (_menu_edit_ ## _name ()) (*callbackFunc)(); } \</front>
<front id="ultralcdCPP-1390">  static void _menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \</front>
<front id="ultralcdCPP-1391">    prevMenu = currentMenu; \</front>
<front id="ultralcdCPP-1392">    prevEncoderPosition = encoderPosition; \</front>
<front id="ultralcdCPP-1393">     \</front>
<front id="ultralcdCPP-1394">    lcdDrawUpdate = 2; \</front>
<front id="ultralcdCPP-1395">    currentMenu = menu_edit_ ## _name; \</front>
<front id="ultralcdCPP-1396">     \</front>
<front id="ultralcdCPP-1397">    editLabel = pstr; \</front>
<front id="ultralcdCPP-1398">    editValue = ptr; \</front>
<front id="ultralcdCPP-1399">    minEditValue = minValue * scale; \</front>
<front id="ultralcdCPP-1400">    maxEditValue = maxValue * scale - minEditValue; \</front>
<front id="ultralcdCPP-1401">    encoderPosition = (*ptr) * scale - minEditValue; \</front>
<front id="ultralcdCPP-1402">  } \</front>
<front id="ultralcdCPP-1403">  static void menu_action_setting_edit_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue) { \</front>
<front id="ultralcdCPP-1404">    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \</front>
<front id="ultralcdCPP-1405">    currentMenu = menu_edit_ ## _name; \</front>
<front id="ultralcdCPP-1406">  }\</front>
<front id="ultralcdCPP-1407">  static void menu_action_setting_edit_callback_ ## _name (const char* pstr, _type* ptr, _type minValue, _type maxValue, menuFunc_t callback) { \</front>
<front id="ultralcdCPP-1408">    _menu_action_setting_edit_ ## _name(pstr, ptr, minValue, maxValue); \</front>
<front id="ultralcdCPP-1409">    currentMenu = menu_edit_callback_ ## _name; \</front>
<front id="ultralcdCPP-1410">    callbackFunc = callback; \</front>
<front id="ultralcdCPP-1411">  }</front>
<front id="ultralcdCPP-1412">menu_edit_type(int, int3, itostr3, 1)</front>
<front id="ultralcdCPP-1413">menu_edit_type(float, float3, ftostr3, 1)</front>
<front id="ultralcdCPP-1414">menu_edit_type(float, float32, ftostr32, 100)</front>
<front id="ultralcdCPP-1415">menu_edit_type(float, float43, ftostr43, 1000)</front>
<front id="ultralcdCPP-1416">menu_edit_type(float, float5, ftostr5, 0.01)</front>
<front id="ultralcdCPP-1417">menu_edit_type(float, float51, ftostr51, 10)</front>
<front id="ultralcdCPP-1418">menu_edit_type(float, float52, ftostr52, 100)</front>
<front id="ultralcdCPP-1419">menu_edit_type(unsigned long, long5, ftostr5, 0.01)</front>
<front id="ultralcdCPP-1420"></front>
<front id="ultralcdCPP-1421">/**</front>
<front id="ultralcdCPP-1422"> *</front>
<front id="ultralcdCPP-1423"> * Handlers for RepRap World Keypad input</front>
<front id="ultralcdCPP-1424"> *</front>
<front id="ultralcdCPP-1425"> */</front>
<front id="ultralcdCPP-1426">#if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1427">  static void reprapworld_keypad_move_z_up() {</front>
<front id="ultralcdCPP-1428">    encoderPosition = 1;</front>
<front id="ultralcdCPP-1429">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1430">    lcd_move_z();</front>
<front id="ultralcdCPP-1431">  }</front>
<front id="ultralcdCPP-1432">  static void reprapworld_keypad_move_z_down() {</front>
<front id="ultralcdCPP-1433">    encoderPosition = -1;</front>
<front id="ultralcdCPP-1434">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1435">    lcd_move_z();</front>
<front id="ultralcdCPP-1436">  }</front>
<front id="ultralcdCPP-1437">  static void reprapworld_keypad_move_x_left() {</front>
<front id="ultralcdCPP-1438">    encoderPosition = -1;</front>
<front id="ultralcdCPP-1439">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1440">    lcd_move_x();</front>
<front id="ultralcdCPP-1441">  }</front>
<front id="ultralcdCPP-1442">  static void reprapworld_keypad_move_x_right() {</front>
<front id="ultralcdCPP-1443">    encoderPosition = 1;</front>
<front id="ultralcdCPP-1444">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1445">    lcd_move_x();</front>
<front id="ultralcdCPP-1446">  }</front>
<front id="ultralcdCPP-1447">  static void reprapworld_keypad_move_y_down() {</front>
<front id="ultralcdCPP-1448">    encoderPosition = 1;</front>
<front id="ultralcdCPP-1449">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1450">    lcd_move_y();</front>
<front id="ultralcdCPP-1451">  }</front>
<front id="ultralcdCPP-1452">  static void reprapworld_keypad_move_y_up() {</front>
<front id="ultralcdCPP-1453">    encoderPosition = -1;</front>
<front id="ultralcdCPP-1454">    move_menu_scale = REPRAPWORLD_KEYPAD_MOVE_STEP;</front>
<front id="ultralcdCPP-1455">    lcd_move_y();</front>
<front id="ultralcdCPP-1456">  }</front>
<front id="ultralcdCPP-1457">  static void reprapworld_keypad_move_home() {</front>
<front id="ultralcdCPP-1458">    enqueuecommands_P((PSTR("G28"))); // move all axis home</front>
<front id="ultralcdCPP-1459">  }</front>
<front id="ultralcdCPP-1460">#endif // REPRAPWORLD_KEYPAD</front>
<front id="ultralcdCPP-1461"></front>
<front id="ultralcdCPP-1462"></front>
<front id="ultralcdCPP-1463">/**</front>
<front id="ultralcdCPP-1464"> *</front>
<front id="ultralcdCPP-1465"> * Audio feedback for controller clicks</front>
<front id="ultralcdCPP-1466"> *</front>
<front id="ultralcdCPP-1467"> */</front>
<front id="ultralcdCPP-1468"></front>
<front id="ultralcdCPP-1469">#if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="ultralcdCPP-1470">  void lcd_buzz(long duration, uint16_t freq) { // called from buzz() in Marlin_main.cpp where lcd is unknown</front>
<front id="ultralcdCPP-1471">    lcd.buzz(duration, freq);</front>
<front id="ultralcdCPP-1472">  }</front>
<front id="ultralcdCPP-1473">#endif</front>
<front id="ultralcdCPP-1474"></front>
<front id="ultralcdCPP-1475">void lcd_quick_feedback() {</front>
<front id="ultralcdCPP-1476">  lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1477">  next_button_update_ms = millis() + 500;</front>
<front id="ultralcdCPP-1478">    </front>
<front id="ultralcdCPP-1479">  #if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="ultralcdCPP-1480">    #ifndef LCD_FEEDBACK_FREQUENCY_HZ</front>
<front id="ultralcdCPP-1481">      #define LCD_FEEDBACK_FREQUENCY_HZ 100</front>
<front id="ultralcdCPP-1482">    #endif</front>
<front id="ultralcdCPP-1483">    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS</front>
<front id="ultralcdCPP-1484">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS (1000/6)</front>
<front id="ultralcdCPP-1485">    #endif    </front>
<front id="ultralcdCPP-1486">    lcd.buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);</front>
<front id="ultralcdCPP-1487">  #elif PIN_EXISTS(BEEPER)</front>
<front id="ultralcdCPP-1488">    #ifndef LCD_FEEDBACK_FREQUENCY_HZ</front>
<front id="ultralcdCPP-1489">      #define LCD_FEEDBACK_FREQUENCY_HZ 5000</front>
<front id="ultralcdCPP-1490">    #endif</front>
<front id="ultralcdCPP-1491">    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS</front>
<front id="ultralcdCPP-1492">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2</front>
<front id="ultralcdCPP-1493">    #endif</front>
<front id="ultralcdCPP-1494">    buzz(LCD_FEEDBACK_FREQUENCY_DURATION_MS, LCD_FEEDBACK_FREQUENCY_HZ);</front>
<front id="ultralcdCPP-1495">  #else</front>
<front id="ultralcdCPP-1496">    #ifndef LCD_FEEDBACK_FREQUENCY_DURATION_MS</front>
<front id="ultralcdCPP-1497">      #define LCD_FEEDBACK_FREQUENCY_DURATION_MS 2</front>
<front id="ultralcdCPP-1498">    #endif</front>
<front id="ultralcdCPP-1499">    delay(LCD_FEEDBACK_FREQUENCY_DURATION_MS);</front>
<front id="ultralcdCPP-1500">  #endif</front>
<front id="ultralcdCPP-1501">}</front>
<front id="ultralcdCPP-1502"></front>
<front id="ultralcdCPP-1503">/**</front>
<front id="ultralcdCPP-1504"> *</front>
<front id="ultralcdCPP-1505"> * Menu actions</front>
<front id="ultralcdCPP-1506"> *</front>
<front id="ultralcdCPP-1507"> */</front>
<front id="ultralcdCPP-1508">static void menu_action_back(menuFunc_t func) { lcd_goto_menu(func); }</front>
<front id="ultralcdCPP-1509">static void menu_action_submenu(menuFunc_t func) { lcd_goto_menu(func); }</front>
<front id="ultralcdCPP-1510">static void menu_action_gcode(const char* pgcode) { enqueuecommands_P(pgcode); }</front>
<front id="ultralcdCPP-1511">static void menu_action_function(menuFunc_t func) { (*func)(); }</front>
<front id="ultralcdCPP-1512"></front>
<front id="ultralcdCPP-1513">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcdCPP-1514"></front>
<front id="ultralcdCPP-1515">  static void menu_action_sdfile(const char* filename, char* longFilename) {</front>
<front id="ultralcdCPP-1516">    char cmd[30];</front>
<front id="ultralcdCPP-1517">    char* c;</front>
<front id="ultralcdCPP-1518">    sprintf_P(cmd, PSTR("M23 %s"), filename);</front>
<front id="ultralcdCPP-1519">    for(c = &cmd[4]; *c; c++) *c = tolower(*c);</front>
<front id="ultralcdCPP-1520">    enqueuecommand(cmd);</front>
<front id="ultralcdCPP-1521">    enqueuecommands_P(PSTR("M24"));</front>
<front id="ultralcdCPP-1522">    lcd_return_to_status();</front>
<front id="ultralcdCPP-1523">  }</front>
<front id="ultralcdCPP-1524"></front>
<front id="ultralcdCPP-1525">  static void menu_action_sddirectory(const char* filename, char* longFilename) {</front>
<front id="ultralcdCPP-1526">    card.chdir(filename);</front>
<front id="ultralcdCPP-1527">    encoderPosition = 0;</front>
<front id="ultralcdCPP-1528">  }</front>
<front id="ultralcdCPP-1529"></front>
<front id="ultralcdCPP-1530">#endif //SDSUPPORT</front>
<front id="ultralcdCPP-1531"></front>
<front id="ultralcdCPP-1532">static void menu_action_setting_edit_bool(const char* pstr, bool* ptr) { *ptr = !(*ptr); }</front>
<front id="ultralcdCPP-1533">static void menu_action_setting_edit_callback_bool(const char* pstr, bool* ptr, menuFunc_t callback) {</front>
<front id="ultralcdCPP-1534">  menu_action_setting_edit_bool(pstr, ptr);</front>
<front id="ultralcdCPP-1535">  (*callback)();</front>
<front id="ultralcdCPP-1536">}</front>
<front id="ultralcdCPP-1537"></front>
<front id="ultralcdCPP-1538">#endif //ULTIPANEL</front>
<front id="ultralcdCPP-1539"></front>
<front id="ultralcdCPP-1540">/** LCD API **/</front>
<front id="ultralcdCPP-1541">void lcd_init() {</front>
<front id="ultralcdCPP-1542">  lcd_implementation_init();</front>
<front id="ultralcdCPP-1543"></front>
<front id="ultralcdCPP-1544">  #if ENABLED(NEWPANEL)</front>
<front id="ultralcdCPP-1545"></front>
<front id="ultralcdCPP-1546">    SET_INPUT(BTN_EN1);</front>
<front id="ultralcdCPP-1547">    SET_INPUT(BTN_EN2);</front>
<front id="ultralcdCPP-1548">    WRITE(BTN_EN1,HIGH);</front>
<front id="ultralcdCPP-1549">    WRITE(BTN_EN2,HIGH);</front>
<front id="ultralcdCPP-1550">  #if BTN_ENC &gt; 0</front>
<front id="ultralcdCPP-1551">    SET_INPUT(BTN_ENC);</front>
<front id="ultralcdCPP-1552">    WRITE(BTN_ENC,HIGH);</front>
<front id="ultralcdCPP-1553">  #endif</front>
<front id="ultralcdCPP-1554">  #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1555">    pinMode(SHIFT_CLK,OUTPUT);</front>
<front id="ultralcdCPP-1556">    pinMode(SHIFT_LD,OUTPUT);</front>
<front id="ultralcdCPP-1557">    pinMode(SHIFT_OUT,INPUT);</front>
<front id="ultralcdCPP-1558">    WRITE(SHIFT_OUT,HIGH);</front>
<front id="ultralcdCPP-1559">    WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-1560">  #endif</front>
<front id="ultralcdCPP-1561">#else  // Not NEWPANEL</front>
<front id="ultralcdCPP-1562">  #if ENABLED(SR_LCD_2W_NL) // Non latching 2 wire shift register</front>
<front id="ultralcdCPP-1563">     pinMode (SR_DATA_PIN, OUTPUT);</front>
<front id="ultralcdCPP-1564">     pinMode (SR_CLK_PIN, OUTPUT);</front>
<front id="ultralcdCPP-1565">  #elif defined(SHIFT_CLK)</front>
<front id="ultralcdCPP-1566">     pinMode(SHIFT_CLK,OUTPUT);</front>
<front id="ultralcdCPP-1567">     pinMode(SHIFT_LD,OUTPUT);</front>
<front id="ultralcdCPP-1568">     pinMode(SHIFT_EN,OUTPUT);</front>
<front id="ultralcdCPP-1569">     pinMode(SHIFT_OUT,INPUT);</front>
<front id="ultralcdCPP-1570">     WRITE(SHIFT_OUT,HIGH);</front>
<front id="ultralcdCPP-1571">     WRITE(SHIFT_LD,HIGH);</front>
<front id="ultralcdCPP-1572">     WRITE(SHIFT_EN,LOW);</front>
<front id="ultralcdCPP-1573">  #endif // SR_LCD_2W_NL</front>
<front id="ultralcdCPP-1574">#endif//!NEWPANEL</front>
<front id="ultralcdCPP-1575"></front>
<front id="ultralcdCPP-1576">  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1577">    pinMode(SD_DETECT_PIN, INPUT);</front>
<front id="ultralcdCPP-1578">    WRITE(SD_DETECT_PIN, HIGH);</front>
<front id="ultralcdCPP-1579">    lcd_sd_status = 2; // UNKNOWN</front>
<front id="ultralcdCPP-1580">  #endif</front>
<front id="ultralcdCPP-1581"></front>
<front id="ultralcdCPP-1582">  #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-1583">    slow_buttons = 0;</front>
<front id="ultralcdCPP-1584">  #endif</front>
<front id="ultralcdCPP-1585"></front>
<front id="ultralcdCPP-1586">  lcd_buttons_update();</front>
<front id="ultralcdCPP-1587"></front>
<front id="ultralcdCPP-1588">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1589">    encoderDiff = 0;</front>
<front id="ultralcdCPP-1590">  #endif</front>
<front id="ultralcdCPP-1591">}</front>
<front id="ultralcdCPP-1592"></front>
<front id="ultralcdCPP-1593">int lcd_strlen(char *s) {</front>
<front id="ultralcdCPP-1594">  int i = 0, j = 0;</front>
<front id="ultralcdCPP-1595">  while (s[i]) {</front>
<front id="ultralcdCPP-1596">    if ((s[i] & 0xc0) != 0x80) j++;</front>
<front id="ultralcdCPP-1597">    i++;</front>
<front id="ultralcdCPP-1598">  }</front>
<front id="ultralcdCPP-1599">  return j;</front>
<front id="ultralcdCPP-1600">}</front>
<front id="ultralcdCPP-1601"></front>
<front id="ultralcdCPP-1602">int lcd_strlen_P(const char *s) {</front>
<front id="ultralcdCPP-1603">  int j = 0;</front>
<front id="ultralcdCPP-1604">  while (pgm_read_byte(s)) {</front>
<front id="ultralcdCPP-1605">    if ((pgm_read_byte(s) & 0xc0) != 0x80) j++;</front>
<front id="ultralcdCPP-1606">    s++;</front>
<front id="ultralcdCPP-1607">  }</front>
<front id="ultralcdCPP-1608">  return j;</front>
<front id="ultralcdCPP-1609">}</front>
<front id="ultralcdCPP-1610"></front>
<front id="ultralcdCPP-1611">/**</front>
<front id="ultralcdCPP-1612"> * Update the LCD, read encoder buttons, etc.</front>
<front id="ultralcdCPP-1613"> *   - Read button states</front>
<front id="ultralcdCPP-1614"> *   - Check the SD Card slot state</front>
<front id="ultralcdCPP-1615"> *   - Act on RepRap World keypad input</front>
<front id="ultralcdCPP-1616"> *   - Update the encoder position</front>
<front id="ultralcdCPP-1617"> *   - Apply acceleration to the encoder position</front>
<front id="ultralcdCPP-1618"> *   - Reset the Info Screen timeout if there's any input</front>
<front id="ultralcdCPP-1619"> *   - Update status indicators, if any</front>
<front id="ultralcdCPP-1620"> *   - Clear the LCD if lcdDrawUpdate == 2</front>
<front id="ultralcdCPP-1621"> *</front>
<front id="ultralcdCPP-1622"> * Warning: This function is called from interrupt context!</front>
<front id="ultralcdCPP-1623"> */</front>
<front id="ultralcdCPP-1624">void lcd_update() {</front>
<front id="ultralcdCPP-1625">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1626">    static millis_t return_to_status_ms = 0;</front>
<front id="ultralcdCPP-1627">  #endif</front>
<front id="ultralcdCPP-1628"></front>
<front id="ultralcdCPP-1629">  #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-1630">    slow_buttons = lcd_implementation_read_slow_buttons(); // buttons which take too long to read in interrupt context</front>
<front id="ultralcdCPP-1631">  #endif</front>
<front id="ultralcdCPP-1632"></front>
<front id="ultralcdCPP-1633">  lcd_buttons_update();</front>
<front id="ultralcdCPP-1634"></front>
<front id="ultralcdCPP-1635">  #if ENABLED(SDSUPPORT) && PIN_EXISTS(SD_DETECT)</front>
<front id="ultralcdCPP-1636"></front>
<front id="ultralcdCPP-1637">    bool sd_status = IS_SD_INSERTED;</front>
<front id="ultralcdCPP-1638">    if (sd_status != lcd_sd_status && lcd_detected()) {</front>
<front id="ultralcdCPP-1639">      lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1640">      lcd_implementation_init( // to maybe revive the LCD if static electricity killed it.</front>
<front id="ultralcdCPP-1641">        #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-1642">          currentMenu == lcd_status_screen</front>
<front id="ultralcdCPP-1643">        #endif</front>
<front id="ultralcdCPP-1644">      );</front>
<front id="ultralcdCPP-1645"></front>
<front id="ultralcdCPP-1646">      if (sd_status) {</front>
<front id="ultralcdCPP-1647">        card.initsd();</front>
<front id="ultralcdCPP-1648">        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_INSERTED);</front>
<front id="ultralcdCPP-1649">      }</front>
<front id="ultralcdCPP-1650">      else {</front>
<front id="ultralcdCPP-1651">        card.release();</front>
<front id="ultralcdCPP-1652">        if (lcd_sd_status != 2) LCD_MESSAGEPGM(MSG_SD_REMOVED);</front>
<front id="ultralcdCPP-1653">      }</front>
<front id="ultralcdCPP-1654"></front>
<front id="ultralcdCPP-1655">      lcd_sd_status = sd_status;</front>
<front id="ultralcdCPP-1656">    }</front>
<front id="ultralcdCPP-1657"></front>
<front id="ultralcdCPP-1658">  #endif //SDSUPPORT && SD_DETECT_PIN</front>
<front id="ultralcdCPP-1659">  </front>
<front id="ultralcdCPP-1660">  millis_t ms = millis();</front>
<front id="ultralcdCPP-1661">  if (ms &gt; next_lcd_update_ms) {</front>
<front id="ultralcdCPP-1662"></front>
<front id="ultralcdCPP-1663">    #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1664"></front>
<front id="ultralcdCPP-1665">      #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1666">        if (REPRAPWORLD_KEYPAD_MOVE_Z_UP)     reprapworld_keypad_move_z_up();</front>
<front id="ultralcdCPP-1667">        if (REPRAPWORLD_KEYPAD_MOVE_Z_DOWN)   reprapworld_keypad_move_z_down();</front>
<front id="ultralcdCPP-1668">        if (REPRAPWORLD_KEYPAD_MOVE_X_LEFT)   reprapworld_keypad_move_x_left();</front>
<front id="ultralcdCPP-1669">        if (REPRAPWORLD_KEYPAD_MOVE_X_RIGHT)  reprapworld_keypad_move_x_right();</front>
<front id="ultralcdCPP-1670">        if (REPRAPWORLD_KEYPAD_MOVE_Y_DOWN)   reprapworld_keypad_move_y_down();</front>
<front id="ultralcdCPP-1671">        if (REPRAPWORLD_KEYPAD_MOVE_Y_UP)     reprapworld_keypad_move_y_up();</front>
<front id="ultralcdCPP-1672">        if (REPRAPWORLD_KEYPAD_MOVE_HOME)     reprapworld_keypad_move_home();</front>
<front id="ultralcdCPP-1673">      #endif</front>
<front id="ultralcdCPP-1674"></front>
<front id="ultralcdCPP-1675">      bool encoderPastThreshold = (abs(encoderDiff) &gt;= ENCODER_PULSES_PER_STEP);</front>
<front id="ultralcdCPP-1676">      if (encoderPastThreshold || LCD_CLICKED) {</front>
<front id="ultralcdCPP-1677">        if (encoderPastThreshold) {</front>
<front id="ultralcdCPP-1678">          int32_t encoderMultiplier = 1;</front>
<front id="ultralcdCPP-1679"></front>
<front id="ultralcdCPP-1680">          #if ENABLED(ENCODER_RATE_MULTIPLIER)</front>
<front id="ultralcdCPP-1681"></front>
<front id="ultralcdCPP-1682">            if (encoderRateMultiplierEnabled) {</front>
<front id="ultralcdCPP-1683">              int32_t encoderMovementSteps = abs(encoderDiff) / ENCODER_PULSES_PER_STEP;</front>
<front id="ultralcdCPP-1684"></front>
<front id="ultralcdCPP-1685">              if (lastEncoderMovementMillis != 0) {</front>
<front id="ultralcdCPP-1686">                // Note that the rate is always calculated between to passes through the </front>
<front id="ultralcdCPP-1687">                // loop and that the abs of the encoderDiff value is tracked.</front>
<front id="ultralcdCPP-1688">                float encoderStepRate = (float)(encoderMovementSteps) / ((float)(ms - lastEncoderMovementMillis)) * 1000.0;</front>
<front id="ultralcdCPP-1689"></front>
<front id="ultralcdCPP-1690">                if (encoderStepRate &gt;= ENCODER_100X_STEPS_PER_SEC)     encoderMultiplier = 100;</front>
<front id="ultralcdCPP-1691">                else if (encoderStepRate &gt;= ENCODER_10X_STEPS_PER_SEC) encoderMultiplier = 10;</front>
<front id="ultralcdCPP-1692"></front>
<front id="ultralcdCPP-1693">                #if ENABLED(ENCODER_RATE_MULTIPLIER_DEBUG)</front>
<front id="ultralcdCPP-1694">                  SERIAL_ECHO_START;</front>
<front id="ultralcdCPP-1695">                  SERIAL_ECHO("Enc Step Rate: ");</front>
<front id="ultralcdCPP-1696">                  SERIAL_ECHO(encoderStepRate);</front>
<front id="ultralcdCPP-1697">                  SERIAL_ECHO("  Multiplier: ");</front>
<front id="ultralcdCPP-1698">                  SERIAL_ECHO(encoderMultiplier);</front>
<front id="ultralcdCPP-1699">                  SERIAL_ECHO("  ENCODER_10X_STEPS_PER_SEC: ");</front>
<front id="ultralcdCPP-1700">                  SERIAL_ECHO(ENCODER_10X_STEPS_PER_SEC);</front>
<front id="ultralcdCPP-1701">                  SERIAL_ECHO("  ENCODER_100X_STEPS_PER_SEC: ");</front>
<front id="ultralcdCPP-1702">                  SERIAL_ECHOLN(ENCODER_100X_STEPS_PER_SEC);</front>
<front id="ultralcdCPP-1703">                #endif //ENCODER_RATE_MULTIPLIER_DEBUG</front>
<front id="ultralcdCPP-1704">              }</front>
<front id="ultralcdCPP-1705"></front>
<front id="ultralcdCPP-1706">              lastEncoderMovementMillis = ms;</front>
<front id="ultralcdCPP-1707">            } // encoderRateMultiplierEnabled</front>
<front id="ultralcdCPP-1708">          #endif //ENCODER_RATE_MULTIPLIER</front>
<front id="ultralcdCPP-1709"></front>
<front id="ultralcdCPP-1710">          encoderPosition += (encoderDiff * encoderMultiplier) / ENCODER_PULSES_PER_STEP;</front>
<front id="ultralcdCPP-1711">          encoderDiff = 0;</front>
<front id="ultralcdCPP-1712">        }</front>
<front id="ultralcdCPP-1713">        return_to_status_ms = ms + LCD_TIMEOUT_TO_STATUS;</front>
<front id="ultralcdCPP-1714">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1715">      }</front>
<front id="ultralcdCPP-1716">    #endif //ULTIPANEL</front>
<front id="ultralcdCPP-1717"></front>
<front id="ultralcdCPP-1718">    if (currentMenu == lcd_status_screen) {</front>
<front id="ultralcdCPP-1719">      if (!lcd_status_update_delay) {</front>
<front id="ultralcdCPP-1720">        lcdDrawUpdate = 1;</front>
<front id="ultralcdCPP-1721">        lcd_status_update_delay = 10;   /* redraw the main screen every second. This is easier then trying keep track of all things that change on the screen */</front>
<front id="ultralcdCPP-1722">      }</front>
<front id="ultralcdCPP-1723">      else {</front>
<front id="ultralcdCPP-1724">        lcd_status_update_delay--;</front>
<front id="ultralcdCPP-1725">      }</front>
<front id="ultralcdCPP-1726">    }</front>
<front id="ultralcdCPP-1727">    #if ENABLED(DOGLCD)  // Changes due to different driver architecture of the DOGM display</front>
<front id="ultralcdCPP-1728">      if (lcdDrawUpdate) {</front>
<front id="ultralcdCPP-1729">        blink++;     // Variable for fan animation and alive dot</front>
<front id="ultralcdCPP-1730">        u8g.firstPage();</front>
<front id="ultralcdCPP-1731">        do {</front>
<front id="ultralcdCPP-1732">          lcd_setFont(FONT_MENU);</front>
<front id="ultralcdCPP-1733">          u8g.setPrintPos(125, 0);</front>
<front id="ultralcdCPP-1734">          if (blink % 2) u8g.setColorIndex(1); else u8g.setColorIndex(0); // Set color for the alive dot</front>
<front id="ultralcdCPP-1735">          u8g.drawPixel(127, 63); // draw alive dot</front>
<front id="ultralcdCPP-1736">          u8g.setColorIndex(1); // black on white</front>
<front id="ultralcdCPP-1737">          (*currentMenu)();</front>
<front id="ultralcdCPP-1738">        } while( u8g.nextPage() );</front>
<front id="ultralcdCPP-1739">      }</front>
<front id="ultralcdCPP-1740">    #else</front>
<front id="ultralcdCPP-1741">      (*currentMenu)();</front>
<front id="ultralcdCPP-1742">    #endif</front>
<front id="ultralcdCPP-1743"></front>
<front id="ultralcdCPP-1744">    #if ENABLED(LCD_HAS_STATUS_INDICATORS)</front>
<front id="ultralcdCPP-1745">      lcd_implementation_update_indicators();</front>
<front id="ultralcdCPP-1746">    #endif</front>
<front id="ultralcdCPP-1747"></front>
<front id="ultralcdCPP-1748">    #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1749"></front>
<front id="ultralcdCPP-1750">      // Return to Status Screen after a timeout</front>
<front id="ultralcdCPP-1751">      if (currentMenu != lcd_status_screen &&</front>
<front id="ultralcdCPP-1752">        #if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-1753">          currentMenu != _lcd_level_bed &&</front>
<front id="ultralcdCPP-1754">          currentMenu != _lcd_level_bed_homing &&</front>
<front id="ultralcdCPP-1755">        #endif</front>
<front id="ultralcdCPP-1756">        millis() &gt; return_to_status_ms</front>
<front id="ultralcdCPP-1757">      ) {</front>
<front id="ultralcdCPP-1758">        lcd_return_to_status();</front>
<front id="ultralcdCPP-1759">        lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1760">      }</front>
<front id="ultralcdCPP-1761"></front>
<front id="ultralcdCPP-1762">    #endif // ULTIPANEL</front>
<front id="ultralcdCPP-1763"></front>
<front id="ultralcdCPP-1764">    if (lcdDrawUpdate == 2) lcd_implementation_clear();</front>
<front id="ultralcdCPP-1765">    if (lcdDrawUpdate) lcdDrawUpdate--;</front>
<front id="ultralcdCPP-1766">    next_lcd_update_ms = ms + LCD_UPDATE_INTERVAL;</front>
<front id="ultralcdCPP-1767">  }</front>
<front id="ultralcdCPP-1768">}</front>
<front id="ultralcdCPP-1769"></front>
<front id="ultralcdCPP-1770">void lcd_ignore_click(bool b) {</front>
<front id="ultralcdCPP-1771">  ignore_click = b;</front>
<front id="ultralcdCPP-1772">  wait_for_unclick = false;</front>
<front id="ultralcdCPP-1773">}</front>
<front id="ultralcdCPP-1774"></front>
<front id="ultralcdCPP-1775">void lcd_finishstatus(bool persist=false) {</front>
<front id="ultralcdCPP-1776">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcdCPP-1777">    progress_bar_ms = millis();</front>
<front id="ultralcdCPP-1778">    #if PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdCPP-1779">      expire_status_ms = persist ? 0 : progress_bar_ms + PROGRESS_MSG_EXPIRE;</front>
<front id="ultralcdCPP-1780">    #endif</front>
<front id="ultralcdCPP-1781">  #endif</front>
<front id="ultralcdCPP-1782">  lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-1783"></front>
<front id="ultralcdCPP-1784">  #if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdCPP-1785">    previous_lcd_status_ms = millis();  //get status message to show up for a while</front>
<front id="ultralcdCPP-1786">  #endif</front>
<front id="ultralcdCPP-1787">}</front>
<front id="ultralcdCPP-1788"></front>
<front id="ultralcdCPP-1789">#if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdCPP-1790">  void dontExpireStatus() { expire_status_ms = 0; }</front>
<front id="ultralcdCPP-1791">#endif</front>
<front id="ultralcdCPP-1792"></front>
<front id="ultralcdCPP-1793">void set_utf_strlen(char *s, uint8_t n) {</front>
<front id="ultralcdCPP-1794">  uint8_t i = 0, j = 0;</front>
<front id="ultralcdCPP-1795">  while (s[i] && (j &lt; n)) {</front>
<front id="ultralcdCPP-1796">    if ((s[i] & 0xc0u) != 0x80u) j++;</front>
<front id="ultralcdCPP-1797">    i++;</front>
<front id="ultralcdCPP-1798">  }</front>
<front id="ultralcdCPP-1799">  while (j++ &lt; n) s[i++] = ' ';</front>
<front id="ultralcdCPP-1800">  s[i] = 0;</front>
<front id="ultralcdCPP-1801">}</front>
<front id="ultralcdCPP-1802"></front>
<front id="ultralcdCPP-1803">bool lcd_hasstatus() { return (lcd_status_message[0] != '\0'); }</front>
<front id="ultralcdCPP-1804"></front>
<front id="ultralcdCPP-1805">void lcd_setstatus(const char* message, bool persist) {</front>
<front id="ultralcdCPP-1806">  if (lcd_status_message_level &gt; 0) return;</front>
<front id="ultralcdCPP-1807">  strncpy(lcd_status_message, message, 3*LCD_WIDTH);</front>
<front id="ultralcdCPP-1808">  set_utf_strlen(lcd_status_message, LCD_WIDTH);</front>
<front id="ultralcdCPP-1809">  lcd_finishstatus(persist);</front>
<front id="ultralcdCPP-1810">}</front>
<front id="ultralcdCPP-1811"></front>
<front id="ultralcdCPP-1812">void lcd_setstatuspgm(const char* message, uint8_t level) {</front>
<front id="ultralcdCPP-1813">  if (level &gt;= lcd_status_message_level) {</front>
<front id="ultralcdCPP-1814">    strncpy_P(lcd_status_message, message, 3*LCD_WIDTH);</front>
<front id="ultralcdCPP-1815">    set_utf_strlen(lcd_status_message, LCD_WIDTH);</front>
<front id="ultralcdCPP-1816">    lcd_status_message_level = level;</front>
<front id="ultralcdCPP-1817">    lcd_finishstatus(level &gt; 0);</front>
<front id="ultralcdCPP-1818">  }</front>
<front id="ultralcdCPP-1819">}</front>
<front id="ultralcdCPP-1820"></front>
<front id="ultralcdCPP-1821">void lcd_setalertstatuspgm(const char* message) {</front>
<front id="ultralcdCPP-1822">  lcd_setstatuspgm(message, 1);</front>
<front id="ultralcdCPP-1823">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1824">    lcd_return_to_status();</front>
<front id="ultralcdCPP-1825">  #endif</front>
<front id="ultralcdCPP-1826">}</front>
<front id="ultralcdCPP-1827"></front>
<front id="ultralcdCPP-1828">void lcd_reset_alert_level() { lcd_status_message_level = 0; }</front>
<front id="ultralcdCPP-1829"></front>
<front id="ultralcdCPP-1830">#if ENABLED(HAS_LCD_CONTRAST)</front>
<front id="ultralcdCPP-1831">  void lcd_setcontrast(uint8_t value) {</front>
<front id="ultralcdCPP-1832">    lcd_contrast = value & 0x3F;</front>
<front id="ultralcdCPP-1833">    u8g.setContrast(lcd_contrast);</front>
<front id="ultralcdCPP-1834">  }</front>
<front id="ultralcdCPP-1835">#endif</front>
<front id="ultralcdCPP-1836"></front>
<front id="ultralcdCPP-1837">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcdCPP-1838"></front>
<front id="ultralcdCPP-1839">  /**</front>
<front id="ultralcdCPP-1840">   * Setup Rotary Encoder Bit Values (for two pin encoders to indicate movement)</front>
<front id="ultralcdCPP-1841">   * These values are independent of which pins are used for EN_A and EN_B indications</front>
<front id="ultralcdCPP-1842">   * The rotary encoder part is also independent to the chipset used for the LCD</front>
<front id="ultralcdCPP-1843">   */</front>
<front id="ultralcdCPP-1844">  #if defined(EN_A) && defined(EN_B)</front>
<front id="ultralcdCPP-1845">    #define encrot0 0</front>
<front id="ultralcdCPP-1846">    #define encrot1 2</front>
<front id="ultralcdCPP-1847">    #define encrot2 3</front>
<front id="ultralcdCPP-1848">    #define encrot3 1</front>
<front id="ultralcdCPP-1849">  #endif</front>
<front id="ultralcdCPP-1850"></front>
<front id="ultralcdCPP-1851">  /**</front>
<front id="ultralcdCPP-1852">   * Read encoder buttons from the hardware registers</front>
<front id="ultralcdCPP-1853">   * Warning: This function is called from interrupt context!</front>
<front id="ultralcdCPP-1854">   */</front>
<front id="ultralcdCPP-1855">  void lcd_buttons_update() {</front>
<front id="ultralcdCPP-1856">    #if ENABLED(NEWPANEL)</front>
<front id="ultralcdCPP-1857">      uint8_t newbutton = 0;</front>
<front id="ultralcdCPP-1858">      if (READ(BTN_EN1) == 0) newbutton |= EN_A;</front>
<front id="ultralcdCPP-1859">      if (READ(BTN_EN2) == 0) newbutton |= EN_B;</front>
<front id="ultralcdCPP-1860">      #if BTN_ENC &gt; 0</front>
<front id="ultralcdCPP-1861">        if (millis() &gt; next_button_update_ms && READ(BTN_ENC) == 0) newbutton |= EN_C;</front>
<front id="ultralcdCPP-1862">      #endif</front>
<front id="ultralcdCPP-1863">      buttons = newbutton;</front>
<front id="ultralcdCPP-1864">      #if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcdCPP-1865">        buttons |= slow_buttons;</front>
<front id="ultralcdCPP-1866">      #endif</front>
<front id="ultralcdCPP-1867">      #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdCPP-1868">        // for the reprapworld_keypad</front>
<front id="ultralcdCPP-1869">        uint8_t newbutton_reprapworld_keypad=0;</front>
<front id="ultralcdCPP-1870">        WRITE(SHIFT_LD, LOW);</front>
<front id="ultralcdCPP-1871">        WRITE(SHIFT_LD, HIGH);</front>
<front id="ultralcdCPP-1872">        for(int8_t i = 0; i &lt; 8; i++) {</front>
<front id="ultralcdCPP-1873">          newbutton_reprapworld_keypad &gt;&gt;= 1;</front>
<front id="ultralcdCPP-1874">          if (READ(SHIFT_OUT)) newbutton_reprapworld_keypad |= BIT(7);</front>
<front id="ultralcdCPP-1875">          WRITE(SHIFT_CLK, HIGH);</front>
<front id="ultralcdCPP-1876">          WRITE(SHIFT_CLK, LOW);</front>
<front id="ultralcdCPP-1877">        }</front>
<front id="ultralcdCPP-1878">        buttons_reprapworld_keypad=~newbutton_reprapworld_keypad; //invert it, because a pressed switch produces a logical 0</front>
<front id="ultralcdCPP-1879">      #endif</front>
<front id="ultralcdCPP-1880">    #else   //read it from the shift register</front>
<front id="ultralcdCPP-1881">      uint8_t newbutton = 0;</front>
<front id="ultralcdCPP-1882">      WRITE(SHIFT_LD, LOW);</front>
<front id="ultralcdCPP-1883">      WRITE(SHIFT_LD, HIGH);</front>
<front id="ultralcdCPP-1884">      unsigned char tmp_buttons = 0;</front>
<front id="ultralcdCPP-1885">      for(int8_t i=0; i&lt;8; i++) {</front>
<front id="ultralcdCPP-1886">        newbutton &gt;&gt;= 1;</front>
<front id="ultralcdCPP-1887">        if (READ(SHIFT_OUT)) newbutton |= BIT(7);</front>
<front id="ultralcdCPP-1888">        WRITE(SHIFT_CLK, HIGH);</front>
<front id="ultralcdCPP-1889">        WRITE(SHIFT_CLK, LOW);</front>
<front id="ultralcdCPP-1890">      }</front>
<front id="ultralcdCPP-1891">      buttons = ~newbutton; //invert it, because a pressed switch produces a logical 0</front>
<front id="ultralcdCPP-1892">    #endif //!NEWPANEL</front>
<front id="ultralcdCPP-1893"></front>
<front id="ultralcdCPP-1894">    //manage encoder rotation</front>
<front id="ultralcdCPP-1895">    uint8_t enc=0;</front>
<front id="ultralcdCPP-1896">    if (buttons & EN_A) enc |= B01;</front>
<front id="ultralcdCPP-1897">    if (buttons & EN_B) enc |= B10;</front>
<front id="ultralcdCPP-1898">    if (enc != lastEncoderBits) {</front>
<front id="ultralcdCPP-1899">      switch(enc) {</front>
<front id="ultralcdCPP-1900">        case encrot0:</front>
<front id="ultralcdCPP-1901">          if (lastEncoderBits==encrot3) encoderDiff++;</front>
<front id="ultralcdCPP-1902">          else if (lastEncoderBits==encrot1) encoderDiff--;</front>
<front id="ultralcdCPP-1903">          break;</front>
<front id="ultralcdCPP-1904">        case encrot1:</front>
<front id="ultralcdCPP-1905">          if (lastEncoderBits==encrot0) encoderDiff++;</front>
<front id="ultralcdCPP-1906">          else if (lastEncoderBits==encrot2) encoderDiff--;</front>
<front id="ultralcdCPP-1907">          break;</front>
<front id="ultralcdCPP-1908">        case encrot2:</front>
<front id="ultralcdCPP-1909">          if (lastEncoderBits==encrot1) encoderDiff++;</front>
<front id="ultralcdCPP-1910">          else if (lastEncoderBits==encrot3) encoderDiff--;</front>
<front id="ultralcdCPP-1911">          break;</front>
<front id="ultralcdCPP-1912">        case encrot3:</front>
<front id="ultralcdCPP-1913">          if (lastEncoderBits==encrot2) encoderDiff++;</front>
<front id="ultralcdCPP-1914">          else if (lastEncoderBits==encrot0) encoderDiff--;</front>
<front id="ultralcdCPP-1915">          break;</front>
<front id="ultralcdCPP-1916">      }</front>
<front id="ultralcdCPP-1917">    }</front>
<front id="ultralcdCPP-1918">    lastEncoderBits = enc;</front>
<front id="ultralcdCPP-1919">  }</front>
<front id="ultralcdCPP-1920"></front>
<front id="ultralcdCPP-1921">  bool lcd_detected(void) {</front>
<front id="ultralcdCPP-1922">    #if (ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)) && ENABLED(DETECT_DEVICE)</front>
<front id="ultralcdCPP-1923">      return lcd.LcdDetected() == 1;</front>
<front id="ultralcdCPP-1924">    #else</front>
<front id="ultralcdCPP-1925">      return true;</front>
<front id="ultralcdCPP-1926">    #endif</front>
<front id="ultralcdCPP-1927">  }</front>
<front id="ultralcdCPP-1928"></front>
<front id="ultralcdCPP-1929">  bool lcd_clicked() { return LCD_CLICKED; }</front>
<front id="ultralcdCPP-1930"></front>
<front id="ultralcdCPP-1931">#endif // ULTIPANEL</front>
<front id="ultralcdCPP-1932"></front>
<front id="ultralcdCPP-1933">/*********************************/</front>
<front id="ultralcdCPP-1934">/** Number to string conversion **/</front>
<front id="ultralcdCPP-1935">/*********************************/</front>
<front id="ultralcdCPP-1936"></front>
<front id="ultralcdCPP-1937">char conv[8];</front>
<front id="ultralcdCPP-1938"></front>
<front id="ultralcdCPP-1939">// Convert float to string with +123.4 format</front>
<front id="ultralcdCPP-1940">char *ftostr3(const float &x) {</front>
<front id="ultralcdCPP-1941">  return itostr3((int)x);</front>
<front id="ultralcdCPP-1942">}</front>
<front id="ultralcdCPP-1943"></front>
<front id="ultralcdCPP-1944">// Convert int to string with 12 format</front>
<front id="ultralcdCPP-1945">char *itostr2(const uint8_t &x) {</front>
<front id="ultralcdCPP-1946">  //sprintf(conv,"%5.1f",x);</front>
<front id="ultralcdCPP-1947">  int xx = x;</front>
<front id="ultralcdCPP-1948">  conv[0] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1949">  conv[1] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1950">  conv[2] = 0;</front>
<front id="ultralcdCPP-1951">  return conv;</front>
<front id="ultralcdCPP-1952">}</front>
<front id="ultralcdCPP-1953"></front>
<front id="ultralcdCPP-1954">// Convert float to string with +123.4 format</front>
<front id="ultralcdCPP-1955">char *ftostr31(const float &x) {</front>
<front id="ultralcdCPP-1956">  int xx = abs(x * 10);</front>
<front id="ultralcdCPP-1957">  conv[0] = (x &gt;= 0) ? '+' : '-';</front>
<front id="ultralcdCPP-1958">  conv[1] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1959">  conv[2] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-1960">  conv[3] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1961">  conv[4] = '.';</front>
<front id="ultralcdCPP-1962">  conv[5] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1963">  conv[6] = 0;</front>
<front id="ultralcdCPP-1964">  return conv;</front>
<front id="ultralcdCPP-1965">}</front>
<front id="ultralcdCPP-1966"></front>
<front id="ultralcdCPP-1967">// Convert float to string with 123.4 format, dropping sign</front>
<front id="ultralcdCPP-1968">char *ftostr31ns(const float &x) {</front>
<front id="ultralcdCPP-1969">  int xx = abs(x * 10);</front>
<front id="ultralcdCPP-1970">  conv[0] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1971">  conv[1] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-1972">  conv[2] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1973">  conv[3] = '.';</front>
<front id="ultralcdCPP-1974">  conv[4] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1975">  conv[5] = 0;</front>
<front id="ultralcdCPP-1976">  return conv;</front>
<front id="ultralcdCPP-1977">}</front>
<front id="ultralcdCPP-1978"></front>
<front id="ultralcdCPP-1979">// Convert float to string with 123.4 format</front>
<front id="ultralcdCPP-1980">char *ftostr32(const float &x) {</front>
<front id="ultralcdCPP-1981">  long xx = abs(x * 100);</front>
<front id="ultralcdCPP-1982">  conv[0] = x &gt;= 0 ? (xx / 10000) % 10 + '0' : '-';</front>
<front id="ultralcdCPP-1983">  conv[1] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1984">  conv[2] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-1985">  conv[3] = '.';</front>
<front id="ultralcdCPP-1986">  conv[4] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-1987">  conv[5] = xx % 10 + '0';</front>
<front id="ultralcdCPP-1988">  conv[6] = 0;</front>
<front id="ultralcdCPP-1989">  return conv;</front>
<front id="ultralcdCPP-1990">}</front>
<front id="ultralcdCPP-1991"></front>
<front id="ultralcdCPP-1992">// Convert float to string with 1.234 format</front>
<front id="ultralcdCPP-1993">char *ftostr43(const float &x) {</front>
<front id="ultralcdCPP-1994">	long xx = x * 1000;</front>
<front id="ultralcdCPP-1995">    if (xx &gt;= 0)</front>
<front id="ultralcdCPP-1996">		conv[0] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-1997">	else</front>
<front id="ultralcdCPP-1998">		conv[0] = '-';</front>
<front id="ultralcdCPP-1999">	xx = abs(xx);</front>
<front id="ultralcdCPP-2000">	conv[1] = '.';</front>
<front id="ultralcdCPP-2001">	conv[2] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2002">	conv[3] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2003">	conv[4] = (xx) % 10 + '0';</front>
<front id="ultralcdCPP-2004">	conv[5] = 0;</front>
<front id="ultralcdCPP-2005">	return conv;</front>
<front id="ultralcdCPP-2006">}</front>
<front id="ultralcdCPP-2007"></front>
<front id="ultralcdCPP-2008">// Convert float to string with 1.23 format</front>
<front id="ultralcdCPP-2009">char *ftostr12ns(const float &x) {</front>
<front id="ultralcdCPP-2010">  long xx=x*100;</front>
<front id="ultralcdCPP-2011">  </front>
<front id="ultralcdCPP-2012">  xx=abs(xx);</front>
<front id="ultralcdCPP-2013">  conv[0]=(xx/100)%10+'0';</front>
<front id="ultralcdCPP-2014">  conv[1]='.';</front>
<front id="ultralcdCPP-2015">  conv[2]=(xx/10)%10+'0';</front>
<front id="ultralcdCPP-2016">  conv[3]=(xx)%10+'0';</front>
<front id="ultralcdCPP-2017">  conv[4]=0;</front>
<front id="ultralcdCPP-2018">  return conv;</front>
<front id="ultralcdCPP-2019">}</front>
<front id="ultralcdCPP-2020"></front>
<front id="ultralcdCPP-2021">// Convert float to space-padded string with -_23.4_ format</front>
<front id="ultralcdCPP-2022">char *ftostr32sp(const float &x) {</front>
<front id="ultralcdCPP-2023">  long xx = abs(x * 100);</front>
<front id="ultralcdCPP-2024">  uint8_t dig;</front>
<front id="ultralcdCPP-2025"></front>
<front id="ultralcdCPP-2026">  if (x &lt; 0) { // negative val = -_0</front>
<front id="ultralcdCPP-2027">    conv[0] = '-';</front>
<front id="ultralcdCPP-2028">    dig = (xx / 1000) % 10;</front>
<front id="ultralcdCPP-2029">    conv[1] = dig ? '0' + dig : ' ';</front>
<front id="ultralcdCPP-2030">  }</front>
<front id="ultralcdCPP-2031">  else { // positive val = __0</front>
<front id="ultralcdCPP-2032">    dig = (xx / 10000) % 10;</front>
<front id="ultralcdCPP-2033">    if (dig) {</front>
<front id="ultralcdCPP-2034">      conv[0] = '0' + dig;</front>
<front id="ultralcdCPP-2035">      conv[1] = '0' + (xx / 1000) % 10;</front>
<front id="ultralcdCPP-2036">    }</front>
<front id="ultralcdCPP-2037">    else {</front>
<front id="ultralcdCPP-2038">      conv[0] = ' ';</front>
<front id="ultralcdCPP-2039">      dig = (xx / 1000) % 10;</front>
<front id="ultralcdCPP-2040">      conv[1] = dig ? '0' + dig : ' ';</front>
<front id="ultralcdCPP-2041">    }</front>
<front id="ultralcdCPP-2042">  }</front>
<front id="ultralcdCPP-2043"></front>
<front id="ultralcdCPP-2044">  conv[2] = '0' + (xx / 100) % 10; // lsd always</front>
<front id="ultralcdCPP-2045"></front>
<front id="ultralcdCPP-2046">  dig = xx % 10;</front>
<front id="ultralcdCPP-2047">  if (dig) { // 2 decimal places</front>
<front id="ultralcdCPP-2048">    conv[5] = '0' + dig;</front>
<front id="ultralcdCPP-2049">    conv[4] = '0' + (xx / 10) % 10;</front>
<front id="ultralcdCPP-2050">    conv[3] = '.';</front>
<front id="ultralcdCPP-2051">  }</front>
<front id="ultralcdCPP-2052">  else { // 1 or 0 decimal place</front>
<front id="ultralcdCPP-2053">    dig = (xx / 10) % 10;</front>
<front id="ultralcdCPP-2054">    if (dig) {</front>
<front id="ultralcdCPP-2055">      conv[4] = '0' + dig;</front>
<front id="ultralcdCPP-2056">      conv[3] = '.';</front>
<front id="ultralcdCPP-2057">    }</front>
<front id="ultralcdCPP-2058">    else {</front>
<front id="ultralcdCPP-2059">      conv[3] = conv[4] = ' ';</front>
<front id="ultralcdCPP-2060">    }</front>
<front id="ultralcdCPP-2061">    conv[5] = ' ';</front>
<front id="ultralcdCPP-2062">  }</front>
<front id="ultralcdCPP-2063">  conv[6] = '\0';</front>
<front id="ultralcdCPP-2064">  return conv;</front>
<front id="ultralcdCPP-2065">}</front>
<front id="ultralcdCPP-2066"></front>
<front id="ultralcdCPP-2067">// Convert int to lj string with +123.0 format</front>
<front id="ultralcdCPP-2068">char *itostr31(const int &x) {</front>
<front id="ultralcdCPP-2069">  conv[0] = x &gt;= 0 ? '+' : '-';</front>
<front id="ultralcdCPP-2070">  int xx = abs(x);</front>
<front id="ultralcdCPP-2071">  conv[1] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2072">  conv[2] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2073">  conv[3] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2074">  conv[4] = '.';</front>
<front id="ultralcdCPP-2075">  conv[5] = '0';</front>
<front id="ultralcdCPP-2076">  conv[6] = 0;</front>
<front id="ultralcdCPP-2077">  return conv;</front>
<front id="ultralcdCPP-2078">}</front>
<front id="ultralcdCPP-2079"></front>
<front id="ultralcdCPP-2080">// Convert int to rj string with 123 or -12 format</front>
<front id="ultralcdCPP-2081">char *itostr3(const int &x) {</front>
<front id="ultralcdCPP-2082">  int xx = x;</front>
<front id="ultralcdCPP-2083">  if (xx &lt; 0) {</front>
<front id="ultralcdCPP-2084">     conv[0] = '-';</front>
<front id="ultralcdCPP-2085">     xx = -xx;</front>
<front id="ultralcdCPP-2086">  }</front>
<front id="ultralcdCPP-2087">  else</front>
<front id="ultralcdCPP-2088">    conv[0] = xx &gt;= 100 ? (xx / 100) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2089"></front>
<front id="ultralcdCPP-2090">  conv[1] = xx &gt;= 10 ? (xx / 10) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2091">  conv[2] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2092">  conv[3] = 0;</front>
<front id="ultralcdCPP-2093">  return conv;</front>
<front id="ultralcdCPP-2094">}</front>
<front id="ultralcdCPP-2095"></front>
<front id="ultralcdCPP-2096">// Convert int to lj string with 123 format</front>
<front id="ultralcdCPP-2097">char *itostr3left(const int &xx) {</front>
<front id="ultralcdCPP-2098">  if (xx &gt;= 100) {</front>
<front id="ultralcdCPP-2099">    conv[0] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2100">    conv[1] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2101">    conv[2] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2102">    conv[3] = 0;</front>
<front id="ultralcdCPP-2103">  }</front>
<front id="ultralcdCPP-2104">  else if (xx &gt;= 10) {</front>
<front id="ultralcdCPP-2105">    conv[0] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2106">    conv[1] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2107">    conv[2] = 0;</front>
<front id="ultralcdCPP-2108">  }</front>
<front id="ultralcdCPP-2109">  else {</front>
<front id="ultralcdCPP-2110">    conv[0] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2111">    conv[1] = 0;</front>
<front id="ultralcdCPP-2112">  }</front>
<front id="ultralcdCPP-2113">  return conv;</front>
<front id="ultralcdCPP-2114">}</front>
<front id="ultralcdCPP-2115"></front>
<front id="ultralcdCPP-2116">// Convert int to rj string with 1234 format</front>
<front id="ultralcdCPP-2117">char *itostr4(const int &xx) {</front>
<front id="ultralcdCPP-2118">  conv[0] = xx &gt;= 1000 ? (xx / 1000) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2119">  conv[1] = xx &gt;= 100 ? (xx / 100) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2120">  conv[2] = xx &gt;= 10 ? (xx / 10) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2121">  conv[3] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2122">  conv[4] = 0;</front>
<front id="ultralcdCPP-2123">  return conv;</front>
<front id="ultralcdCPP-2124">}</front>
<front id="ultralcdCPP-2125"></front>
<front id="ultralcdCPP-2126">// Convert float to rj string with 12345 format</front>
<front id="ultralcdCPP-2127">char *ftostr5(const float &x) {</front>
<front id="ultralcdCPP-2128">  long xx = abs(x);</front>
<front id="ultralcdCPP-2129">  conv[0] = xx &gt;= 10000 ? (xx / 10000) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2130">  conv[1] = xx &gt;= 1000 ? (xx / 1000) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2131">  conv[2] = xx &gt;= 100 ? (xx / 100) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2132">  conv[3] = xx &gt;= 10 ? (xx / 10) % 10 + '0' : ' ';</front>
<front id="ultralcdCPP-2133">  conv[4] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2134">  conv[5] = 0;</front>
<front id="ultralcdCPP-2135">  return conv;</front>
<front id="ultralcdCPP-2136">}</front>
<front id="ultralcdCPP-2137"></front>
<front id="ultralcdCPP-2138">// Convert float to string with +1234.5 format</front>
<front id="ultralcdCPP-2139">char *ftostr51(const float &x) {</front>
<front id="ultralcdCPP-2140">  long xx = abs(x * 10);</front>
<front id="ultralcdCPP-2141">  conv[0] = (x &gt;= 0) ? '+' : '-';</front>
<front id="ultralcdCPP-2142">  conv[1] = (xx / 10000) % 10 + '0';</front>
<front id="ultralcdCPP-2143">  conv[2] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-2144">  conv[3] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2145">  conv[4] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2146">  conv[5] = '.';</front>
<front id="ultralcdCPP-2147">  conv[6] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2148">  conv[7] = 0;</front>
<front id="ultralcdCPP-2149">  return conv;</front>
<front id="ultralcdCPP-2150">}</front>
<front id="ultralcdCPP-2151"></front>
<front id="ultralcdCPP-2152">// Convert float to string with +123.45 format</front>
<front id="ultralcdCPP-2153">char *ftostr52(const float &x) {</front>
<front id="ultralcdCPP-2154">  conv[0] = (x &gt;= 0) ? '+' : '-';</front>
<front id="ultralcdCPP-2155">  long xx = abs(x * 100);</front>
<front id="ultralcdCPP-2156">  conv[1] = (xx / 10000) % 10 + '0';</front>
<front id="ultralcdCPP-2157">  conv[2] = (xx / 1000) % 10 + '0';</front>
<front id="ultralcdCPP-2158">  conv[3] = (xx / 100) % 10 + '0';</front>
<front id="ultralcdCPP-2159">  conv[4] = '.';</front>
<front id="ultralcdCPP-2160">  conv[5] = (xx / 10) % 10 + '0';</front>
<front id="ultralcdCPP-2161">  conv[6] = xx % 10 + '0';</front>
<front id="ultralcdCPP-2162">  conv[7] = 0;</front>
<front id="ultralcdCPP-2163">  return conv;</front>
<front id="ultralcdCPP-2164">}</front>
<front id="ultralcdCPP-2165"></front>
<front id="ultralcdCPP-2166">#if ENABLED(MANUAL_BED_LEVELING)</front>
<front id="ultralcdCPP-2167"></front>
<front id="ultralcdCPP-2168">  static int _lcd_level_bed_position;</front>
<front id="ultralcdCPP-2169"></front>
<front id="ultralcdCPP-2170">  /**</front>
<front id="ultralcdCPP-2171">   * MBL Wait for controller movement and clicks:</front>
<front id="ultralcdCPP-2172">   *   - Movement adjusts the Z axis</front>
<front id="ultralcdCPP-2173">   *   - Click saves the Z and goes to the next mesh point</front>
<front id="ultralcdCPP-2174">   */</front>
<front id="ultralcdCPP-2175">  static void _lcd_level_bed() {</front>
<front id="ultralcdCPP-2176">    if (encoderPosition != 0) {</front>
<front id="ultralcdCPP-2177">      refresh_cmd_timeout();</front>
<front id="ultralcdCPP-2178">      current_position[Z_AXIS] += float((int)encoderPosition) * MBL_Z_STEP;</front>
<front id="ultralcdCPP-2179">      if (min_software_endstops && current_position[Z_AXIS] &lt; Z_MIN_POS) current_position[Z_AXIS] = Z_MIN_POS;</front>
<front id="ultralcdCPP-2180">      if (max_software_endstops && current_position[Z_AXIS] &gt; Z_MAX_POS) current_position[Z_AXIS] = Z_MAX_POS;</front>
<front id="ultralcdCPP-2181">      encoderPosition = 0;</front>
<front id="ultralcdCPP-2182">      line_to_current(Z_AXIS);</front>
<front id="ultralcdCPP-2183">      lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2184">    }</front>
<front id="ultralcdCPP-2185">    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("Z"), ftostr43(current_position[Z_AXIS]));</front>
<front id="ultralcdCPP-2186">    static bool debounce_click = false;</front>
<front id="ultralcdCPP-2187">    if (LCD_CLICKED) {</front>
<front id="ultralcdCPP-2188">      if (!debounce_click) {</front>
<front id="ultralcdCPP-2189">        debounce_click = true;</front>
<front id="ultralcdCPP-2190">        int ix = _lcd_level_bed_position % MESH_NUM_X_POINTS,</front>
<front id="ultralcdCPP-2191">            iy = _lcd_level_bed_position / MESH_NUM_X_POINTS;</front>
<front id="ultralcdCPP-2192">        if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // Zig zag</front>
<front id="ultralcdCPP-2193">        mbl.set_z(ix, iy, current_position[Z_AXIS]);</front>
<front id="ultralcdCPP-2194">        _lcd_level_bed_position++;</front>
<front id="ultralcdCPP-2195">        if (_lcd_level_bed_position == MESH_NUM_X_POINTS*MESH_NUM_Y_POINTS) {</front>
<front id="ultralcdCPP-2196">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="ultralcdCPP-2197">          line_to_current(Z_AXIS);</front>
<front id="ultralcdCPP-2198">          mbl.active = 1;</front>
<front id="ultralcdCPP-2199">          enqueuecommands_P(PSTR("G28"));</front>
<front id="ultralcdCPP-2200">          lcd_return_to_status();</front>
<front id="ultralcdCPP-2201">        }</front>
<front id="ultralcdCPP-2202">        else {</front>
<front id="ultralcdCPP-2203">          current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="ultralcdCPP-2204">          line_to_current(Z_AXIS);</front>
<front id="ultralcdCPP-2205">          ix = _lcd_level_bed_position % MESH_NUM_X_POINTS;</front>
<front id="ultralcdCPP-2206">          iy = _lcd_level_bed_position / MESH_NUM_X_POINTS;</front>
<front id="ultralcdCPP-2207">          if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // Zig zag</front>
<front id="ultralcdCPP-2208">          current_position[X_AXIS] = mbl.get_x(ix);</front>
<front id="ultralcdCPP-2209">          current_position[Y_AXIS] = mbl.get_y(iy);</front>
<front id="ultralcdCPP-2210">          line_to_current(manual_feedrate[X_AXIS] &lt;= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);</front>
<front id="ultralcdCPP-2211">          lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2212">        }</front>
<front id="ultralcdCPP-2213">      }</front>
<front id="ultralcdCPP-2214">    }</front>
<front id="ultralcdCPP-2215">    else {</front>
<front id="ultralcdCPP-2216">      debounce_click = false;</front>
<front id="ultralcdCPP-2217">    }</front>
<front id="ultralcdCPP-2218">  }</front>
<front id="ultralcdCPP-2219"></front>
<front id="ultralcdCPP-2220">  /**</front>
<front id="ultralcdCPP-2221">   * MBL Move to mesh starting point</front>
<front id="ultralcdCPP-2222">   */</front>
<front id="ultralcdCPP-2223">  static void _lcd_level_bed_homing() {</front>
<front id="ultralcdCPP-2224">    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR("XYZ"), "Homing");</front>
<front id="ultralcdCPP-2225">    if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && axis_known_position[Z_AXIS]) {</front>
<front id="ultralcdCPP-2226">      current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;</front>
<front id="ultralcdCPP-2227">      plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);</front>
<front id="ultralcdCPP-2228">      current_position[X_AXIS] = MESH_MIN_X;</front>
<front id="ultralcdCPP-2229">      current_position[Y_AXIS] = MESH_MIN_Y;</front>
<front id="ultralcdCPP-2230">      line_to_current(manual_feedrate[X_AXIS] &lt;= manual_feedrate[Y_AXIS] ? X_AXIS : Y_AXIS);</front>
<front id="ultralcdCPP-2231">      _lcd_level_bed_position = 0;</front>
<front id="ultralcdCPP-2232">      lcd_goto_menu(_lcd_level_bed);</front>
<front id="ultralcdCPP-2233">    }</front>
<front id="ultralcdCPP-2234">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2235">  }</front>
<front id="ultralcdCPP-2236"></front>
<front id="ultralcdCPP-2237">  /**</front>
<front id="ultralcdCPP-2238">   * MBL entry-point</front>
<front id="ultralcdCPP-2239">   */</front>
<front id="ultralcdCPP-2240">  static void lcd_level_bed() {</front>
<front id="ultralcdCPP-2241">    axis_known_position[X_AXIS] = axis_known_position[Y_AXIS] = axis_known_position[Z_AXIS] = false;</front>
<front id="ultralcdCPP-2242">    mbl.reset();</front>
<front id="ultralcdCPP-2243">    enqueuecommands_P(PSTR("G28"));</front>
<front id="ultralcdCPP-2244">    lcdDrawUpdate = 2;</front>
<front id="ultralcdCPP-2245">    lcd_goto_menu(_lcd_level_bed_homing);</front>
<front id="ultralcdCPP-2246">  }</front>
<front id="ultralcdCPP-2247"></front>
<front id="ultralcdCPP-2248">#endif  // MANUAL_BED_LEVELING</front>
<front id="ultralcdCPP-2249"></front>
<front id="ultralcdCPP-2250">#endif // ULTRA_LCD</front>
 </pre>
<h1 id="ultralcdHtitle" >ultralcd.h</h1>
<pre id="ultralcdH"  class="prettyprint linenums"><front id="ultralcdH-1">#ifndef ULTRALCD_H</front>
<front id="ultralcdH-2">#define ULTRALCD_H</front>
<front id="ultralcdH-3"></front>
<front id="ultralcdH-4">#include "Marlin.h"</front>
<front id="ultralcdH-5">#if ENABLED(ULTRA_LCD)</front>
<front id="ultralcdH-6">  #include "buzzer.h"</front>
<front id="ultralcdH-7"></front>
<front id="ultralcdH-8">  int lcd_strlen(char *s);</front>
<front id="ultralcdH-9">  int lcd_strlen_P(const char *s);</front>
<front id="ultralcdH-10">  void lcd_update();</front>
<front id="ultralcdH-11">  void lcd_init();</front>
<front id="ultralcdH-12">  bool lcd_hasstatus();</front>
<front id="ultralcdH-13">  void lcd_setstatus(const char* message, const bool persist=false);</front>
<front id="ultralcdH-14">  void lcd_setstatuspgm(const char* message, const uint8_t level=0);</front>
<front id="ultralcdH-15">  void lcd_setalertstatuspgm(const char* message);</front>
<front id="ultralcdH-16">  void lcd_reset_alert_level();</front>
<front id="ultralcdH-17">  bool lcd_detected(void);</front>
<front id="ultralcdH-18"></front>
<front id="ultralcdH-19">  #if ENABLED(LCD_USE_I2C_BUZZER)</front>
<front id="ultralcdH-20">    void lcd_buzz(long duration, uint16_t freq);</front>
<front id="ultralcdH-21">  #endif</front>
<front id="ultralcdH-22"></front>
<front id="ultralcdH-23">  #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcdH-24">    void dontExpireStatus();</front>
<front id="ultralcdH-25">  #endif</front>
<front id="ultralcdH-26"></front>
<front id="ultralcdH-27">  #if ENABLED(DOGLCD)</front>
<front id="ultralcdH-28">    extern int lcd_contrast;</front>
<front id="ultralcdH-29">    void lcd_setcontrast(uint8_t value);</front>
<front id="ultralcdH-30">  #endif</front>
<front id="ultralcdH-31"></front>
<front id="ultralcdH-32">  #define LCD_MESSAGEPGM(x) lcd_setstatuspgm(PSTR(x))</front>
<front id="ultralcdH-33">  #define LCD_ALERTMESSAGEPGM(x) lcd_setalertstatuspgm(PSTR(x))</front>
<front id="ultralcdH-34"></front>
<front id="ultralcdH-35">  #define LCD_UPDATE_INTERVAL 100</front>
<front id="ultralcdH-36">  #define LCD_TIMEOUT_TO_STATUS 15000</front>
<front id="ultralcdH-37"></front>
<front id="ultralcdH-38">  #if ENABLED(ULTIPANEL)</front>
<front id="ultralcdH-39">    void lcd_buttons_update();</front>
<front id="ultralcdH-40">    extern volatile uint8_t buttons;  //the last checked buttons in a bit array.</front>
<front id="ultralcdH-41">    #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdH-42">      extern volatile uint8_t buttons_reprapworld_keypad; // to store the keypad shift register values</front>
<front id="ultralcdH-43">    #endif</front>
<front id="ultralcdH-44">  #else</front>
<front id="ultralcdH-45">    FORCE_INLINE void lcd_buttons_update() {}</front>
<front id="ultralcdH-46">  #endif</front>
<front id="ultralcdH-47"></front>
<front id="ultralcdH-48">  extern int plaPreheatHotendTemp;</front>
<front id="ultralcdH-49">  extern int plaPreheatHPBTemp;</front>
<front id="ultralcdH-50">  extern int plaPreheatFanSpeed;</front>
<front id="ultralcdH-51">  extern int absPreheatHotendTemp;</front>
<front id="ultralcdH-52">  extern int absPreheatHPBTemp;</front>
<front id="ultralcdH-53">  extern int absPreheatFanSpeed;</front>
<front id="ultralcdH-54"></front>
<front id="ultralcdH-55">  extern bool cancel_heatup;</front>
<front id="ultralcdH-56">  </front>
<front id="ultralcdH-57">  #if ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcdH-58">    extern millis_t previous_lcd_status_ms;</front>
<front id="ultralcdH-59">  #endif</front>
<front id="ultralcdH-60">  void lcd_quick_feedback(); // Audible feedback for a button click - could also be visual</front>
<front id="ultralcdH-61">  bool lcd_clicked();</front>
<front id="ultralcdH-62"></front>
<front id="ultralcdH-63">  void lcd_ignore_click(bool b=true);</front>
<front id="ultralcdH-64"></front>
<front id="ultralcdH-65">  #if ENABLED(NEWPANEL)</front>
<front id="ultralcdH-66">    #define EN_C BIT(BLEN_C)</front>
<front id="ultralcdH-67">    #define EN_B BIT(BLEN_B)</front>
<front id="ultralcdH-68">    #define EN_A BIT(BLEN_A)</front>
<front id="ultralcdH-69"></front>
<front id="ultralcdH-70">    #define LCD_CLICKED (buttons&EN_C)</front>
<front id="ultralcdH-71">    #if ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcdH-72">  	  #define EN_REPRAPWORLD_KEYPAD_F3 (BIT(BLEN_REPRAPWORLD_KEYPAD_F3))</front>
<front id="ultralcdH-73">  	  #define EN_REPRAPWORLD_KEYPAD_F2 (BIT(BLEN_REPRAPWORLD_KEYPAD_F2))</front>
<front id="ultralcdH-74">  	  #define EN_REPRAPWORLD_KEYPAD_F1 (BIT(BLEN_REPRAPWORLD_KEYPAD_F1))</front>
<front id="ultralcdH-75">  	  #define EN_REPRAPWORLD_KEYPAD_UP (BIT(BLEN_REPRAPWORLD_KEYPAD_UP))</front>
<front id="ultralcdH-76">  	  #define EN_REPRAPWORLD_KEYPAD_RIGHT (BIT(BLEN_REPRAPWORLD_KEYPAD_RIGHT))</front>
<front id="ultralcdH-77">  	  #define EN_REPRAPWORLD_KEYPAD_MIDDLE (BIT(BLEN_REPRAPWORLD_KEYPAD_MIDDLE))</front>
<front id="ultralcdH-78">  	  #define EN_REPRAPWORLD_KEYPAD_DOWN (BIT(BLEN_REPRAPWORLD_KEYPAD_DOWN))</front>
<front id="ultralcdH-79">  	  #define EN_REPRAPWORLD_KEYPAD_LEFT (BIT(BLEN_REPRAPWORLD_KEYPAD_LEFT))</front>
<front id="ultralcdH-80"></front>
<front id="ultralcdH-81">  	  #define LCD_CLICKED ((buttons&EN_C) || (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F1))</front>
<front id="ultralcdH-82">  	  #define REPRAPWORLD_KEYPAD_MOVE_Z_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F2)</front>
<front id="ultralcdH-83">  	  #define REPRAPWORLD_KEYPAD_MOVE_Z_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_F3)</front>
<front id="ultralcdH-84">  	  #define REPRAPWORLD_KEYPAD_MOVE_X_LEFT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_LEFT)</front>
<front id="ultralcdH-85">  	  #define REPRAPWORLD_KEYPAD_MOVE_X_RIGHT (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_RIGHT)</front>
<front id="ultralcdH-86">  	  #define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_DOWN)</front>
<front id="ultralcdH-87">  	  #define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_UP)</front>
<front id="ultralcdH-88">  	  #define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons_reprapworld_keypad&EN_REPRAPWORLD_KEYPAD_MIDDLE)</front>
<front id="ultralcdH-89">    #endif //REPRAPWORLD_KEYPAD</front>
<front id="ultralcdH-90">  #else</front>
<front id="ultralcdH-91">    //atomic, do not change</front>
<front id="ultralcdH-92">    #define B_LE BIT(BL_LE)</front>
<front id="ultralcdH-93">    #define B_UP BIT(BL_UP)</front>
<front id="ultralcdH-94">    #define B_MI BIT(BL_MI)</front>
<front id="ultralcdH-95">    #define B_DW BIT(BL_DW)</front>
<front id="ultralcdH-96">    #define B_RI BIT(BL_RI)</front>
<front id="ultralcdH-97">    #define B_ST BIT(BL_ST)</front>
<front id="ultralcdH-98">    #define EN_B BIT(BLEN_B)</front>
<front id="ultralcdH-99">    #define EN_A BIT(BLEN_A)</front>
<front id="ultralcdH-100">    </front>
<front id="ultralcdH-101">    #define LCD_CLICKED ((buttons&B_MI)||(buttons&B_ST))</front>
<front id="ultralcdH-102">  #endif//NEWPANEL</front>
<front id="ultralcdH-103"></front>
<front id="ultralcdH-104">#else //no LCD</front>
<front id="ultralcdH-105">  FORCE_INLINE void lcd_update() {}</front>
<front id="ultralcdH-106">  FORCE_INLINE void lcd_init() {}</front>
<front id="ultralcdH-107">  FORCE_INLINE bool lcd_hasstatus() { return false; }</front>
<front id="ultralcdH-108">  FORCE_INLINE void lcd_setstatus(const char* message, const bool persist=false) {UNUSED(message); UNUSED(persist);}</front>
<front id="ultralcdH-109">  FORCE_INLINE void lcd_setstatuspgm(const char* message, const uint8_t level=0) {UNUSED(message); UNUSED(level);}</front>
<front id="ultralcdH-110">  FORCE_INLINE void lcd_buttons_update() {}</front>
<front id="ultralcdH-111">  FORCE_INLINE void lcd_reset_alert_level() {}</front>
<front id="ultralcdH-112">  FORCE_INLINE bool lcd_detected(void) { return true; }</front>
<front id="ultralcdH-113"></front>
<front id="ultralcdH-114">  #define LCD_MESSAGEPGM(x) do{}while(0)</front>
<front id="ultralcdH-115">  #define LCD_ALERTMESSAGEPGM(x) do{}while(0)</front>
<front id="ultralcdH-116"></front>
<front id="ultralcdH-117">#endif //ULTRA_LCD</front>
<front id="ultralcdH-118"></front>
<front id="ultralcdH-119">char *itostr2(const uint8_t &x);</front>
<front id="ultralcdH-120">char *itostr31(const int &xx);</front>
<front id="ultralcdH-121">char *itostr3(const int &xx);</front>
<front id="ultralcdH-122">char *itostr3left(const int &xx);</front>
<front id="ultralcdH-123">char *itostr4(const int &xx);</front>
<front id="ultralcdH-124"></front>
<front id="ultralcdH-125">char *ftostr3(const float &x);</front>
<front id="ultralcdH-126">char *ftostr31ns(const float &x); // float to string without sign character</front>
<front id="ultralcdH-127">char *ftostr31(const float &x);</front>
<front id="ultralcdH-128">char *ftostr32(const float &x);</front>
<front id="ultralcdH-129">char *ftostr43(const float &x);</front>
<front id="ultralcdH-130">char *ftostr12ns(const float &x); </front>
<front id="ultralcdH-131">char *ftostr32sp(const float &x); // remove zero-padding from ftostr32</front>
<front id="ultralcdH-132">char *ftostr5(const float &x);</front>
<front id="ultralcdH-133">char *ftostr51(const float &x);</front>
<front id="ultralcdH-134">char *ftostr52(const float &x);</front>
<front id="ultralcdH-135"></front>
<front id="ultralcdH-136">#endif //ULTRALCD_H</front>
 </pre>
<h1 id="ultralcd_implementation_hitachi_HD44780Htitle" >ultralcd_implementation_hitachi_HD44780.h</h1>
<pre id="ultralcd_implementation_hitachi_HD44780H"  class="prettyprint linenums"><front id="ultralcd_implementation_hitachi_HD44780H-1">#ifndef ULTRALCD_IMPLEMENTATION_HITACHI_HD44780_H</front>
<front id="ultralcd_implementation_hitachi_HD44780H-2">#define ULTRALCD_IMPLEMENTATION_HITACHI_HD44780_H</front>
<front id="ultralcd_implementation_hitachi_HD44780H-3"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-4">/**</front>
<front id="ultralcd_implementation_hitachi_HD44780H-5">* Implementation of the LCD display routines for a Hitachi HD44780 display. These are common LCD character displays.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-6">* When selecting the Russian language, a slightly different LCD implementation is used to handle UTF8 characters.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-7">**/</front>
<front id="ultralcd_implementation_hitachi_HD44780H-8"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-9">//#if DISABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-10">//  extern volatile uint8_t buttons;  //the last checked buttons in a bit array.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-11">//#else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-12">  extern volatile uint8_t buttons;  //an extended version of the last checked buttons in a bit array.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-13">//#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-14"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-15">////////////////////////////////////</front>
<front id="ultralcd_implementation_hitachi_HD44780H-16">// Setup button and encode mappings for each panel (into 'buttons' variable</front>
<front id="ultralcd_implementation_hitachi_HD44780H-17">//</front>
<front id="ultralcd_implementation_hitachi_HD44780H-18">// This is just to map common functions (across different panels) onto the same</front>
<front id="ultralcd_implementation_hitachi_HD44780H-19">// macro name. The mapping is independent of whether the button is directly connected or</front>
<front id="ultralcd_implementation_hitachi_HD44780H-20">// via a shift/i2c register.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-21"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-22">#if ENABLED(ULTIPANEL)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-23">// All UltiPanels might have an encoder - so this is always be mapped onto first two bits</front>
<front id="ultralcd_implementation_hitachi_HD44780H-24">#define BLEN_B 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-25">#define BLEN_A 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-26"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-27">#define EN_B BIT(BLEN_B) // The two encoder pins are connected through BTN_EN1 and BTN_EN2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-28">#define EN_A BIT(BLEN_A)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-29"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-30">#if defined(BTN_ENC) && BTN_ENC &gt; -1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-31">  // encoder click is directly connected</front>
<front id="ultralcd_implementation_hitachi_HD44780H-32">  #define BLEN_C 2 </front>
<front id="ultralcd_implementation_hitachi_HD44780H-33">  #define EN_C BIT(BLEN_C) </front>
<front id="ultralcd_implementation_hitachi_HD44780H-34">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-35">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-36">//</front>
<front id="ultralcd_implementation_hitachi_HD44780H-37">// Setup other button mappings of each panel</front>
<front id="ultralcd_implementation_hitachi_HD44780H-38">//</front>
<front id="ultralcd_implementation_hitachi_HD44780H-39">#if ENABLED(LCD_I2C_VIKI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-40">  #define B_I2C_BTN_OFFSET 3 // (the first three bit positions reserved for EN_A, EN_B, EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-41"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-42">  // button and encoder bit positions within 'buttons'</front>
<front id="ultralcd_implementation_hitachi_HD44780H-43">  #define B_LE (BUTTON_LEFT&lt;&lt;B_I2C_BTN_OFFSET)    // The remaining normalized buttons are all read via I2C</front>
<front id="ultralcd_implementation_hitachi_HD44780H-44">  #define B_UP (BUTTON_UP&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-45">  #define B_MI (BUTTON_SELECT&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-46">  #define B_DW (BUTTON_DOWN&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-47">  #define B_RI (BUTTON_RIGHT&lt;&lt;B_I2C_BTN_OFFSET)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-48"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-49">  #if defined(BTN_ENC) && BTN_ENC &gt; -1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-50">    // the pause/stop/restart button is connected to BTN_ENC when used</front>
<front id="ultralcd_implementation_hitachi_HD44780H-51">    #define B_ST (EN_C)                            // Map the pause/stop/resume button into its normalized functional name</front>
<front id="ultralcd_implementation_hitachi_HD44780H-52">    #define LCD_CLICKED (buttons&(B_MI|B_RI|B_ST)) // pause/stop button also acts as click until we implement proper pause/stop.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-53">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-54">    #define LCD_CLICKED (buttons&(B_MI|B_RI))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-55">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-56"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-57">  // I2C buttons take too long to read inside an interrupt context and so we read them during lcd_update</front>
<front id="ultralcd_implementation_hitachi_HD44780H-58">  #define LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-59"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-60">#elif ENABLED(LCD_I2C_PANELOLU2)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-61">  // encoder click can be read through I2C if not directly connected</front>
<front id="ultralcd_implementation_hitachi_HD44780H-62">  #if BTN_ENC &lt;= 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-63">    #define B_I2C_BTN_OFFSET 3 // (the first three bit positions reserved for EN_A, EN_B, EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-64"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-65">    #define B_MI (PANELOLU2_ENCODER_C&lt;&lt;B_I2C_BTN_OFFSET) // requires LiquidTWI2 library v1.2.3 or later</front>
<front id="ultralcd_implementation_hitachi_HD44780H-66"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-67">    #define LCD_CLICKED (buttons&B_MI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-68"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-69">    // I2C buttons take too long to read inside an interrupt context and so we read them during lcd_update</front>
<front id="ultralcd_implementation_hitachi_HD44780H-70">    #define LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-71">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-72">    #define LCD_CLICKED (buttons&EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-73">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-74"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-75">#elif ENABLED(REPRAPWORLD_KEYPAD)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-76">    // define register bit values, don't change it</front>
<front id="ultralcd_implementation_hitachi_HD44780H-77">    #define BLEN_REPRAPWORLD_KEYPAD_F3 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-78">    #define BLEN_REPRAPWORLD_KEYPAD_F2 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-79">    #define BLEN_REPRAPWORLD_KEYPAD_F1 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-80">    #define BLEN_REPRAPWORLD_KEYPAD_UP 6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-81">    #define BLEN_REPRAPWORLD_KEYPAD_RIGHT 4</front>
<front id="ultralcd_implementation_hitachi_HD44780H-82">    #define BLEN_REPRAPWORLD_KEYPAD_MIDDLE 5</front>
<front id="ultralcd_implementation_hitachi_HD44780H-83">    #define BLEN_REPRAPWORLD_KEYPAD_DOWN 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-84">    #define BLEN_REPRAPWORLD_KEYPAD_LEFT 7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-85">    </front>
<front id="ultralcd_implementation_hitachi_HD44780H-86">    #define REPRAPWORLD_BTN_OFFSET 0 // bit offset into buttons for shift register values</front>
<front id="ultralcd_implementation_hitachi_HD44780H-87"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-88">    #define EN_REPRAPWORLD_KEYPAD_F3 BIT((BLEN_REPRAPWORLD_KEYPAD_F3+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-89">    #define EN_REPRAPWORLD_KEYPAD_F2 BIT((BLEN_REPRAPWORLD_KEYPAD_F2+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-90">    #define EN_REPRAPWORLD_KEYPAD_F1 BIT((BLEN_REPRAPWORLD_KEYPAD_F1+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-91">    #define EN_REPRAPWORLD_KEYPAD_UP BIT((BLEN_REPRAPWORLD_KEYPAD_UP+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-92">    #define EN_REPRAPWORLD_KEYPAD_RIGHT BIT((BLEN_REPRAPWORLD_KEYPAD_RIGHT+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-93">    #define EN_REPRAPWORLD_KEYPAD_MIDDLE BIT((BLEN_REPRAPWORLD_KEYPAD_MIDDLE+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-94">    #define EN_REPRAPWORLD_KEYPAD_DOWN BIT((BLEN_REPRAPWORLD_KEYPAD_DOWN+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-95">    #define EN_REPRAPWORLD_KEYPAD_LEFT BIT((BLEN_REPRAPWORLD_KEYPAD_LEFT+REPRAPWORLD_BTN_OFFSET))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-96"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-97">    //#define LCD_CLICKED ((buttons&EN_C) || (buttons&EN_REPRAPWORLD_KEYPAD_F1))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-98">    //#define REPRAPWORLD_KEYPAD_MOVE_Y_DOWN (buttons&EN_REPRAPWORLD_KEYPAD_DOWN)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-99">    //#define REPRAPWORLD_KEYPAD_MOVE_Y_UP (buttons&EN_REPRAPWORLD_KEYPAD_UP)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-100">    //#define REPRAPWORLD_KEYPAD_MOVE_HOME (buttons&EN_REPRAPWORLD_KEYPAD_MIDDLE)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-101"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-102">#elif ENABLED(NEWPANEL)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-103">  #define LCD_CLICKED (buttons&EN_C)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-104"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-105">#else // old style ULTIPANEL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-106">  //bits in the shift register that carry the buttons for:</front>
<front id="ultralcd_implementation_hitachi_HD44780H-107">  // left up center down right red(stop)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-108">  #define BL_LE 7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-109">  #define BL_UP 6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-110">  #define BL_MI 5</front>
<front id="ultralcd_implementation_hitachi_HD44780H-111">  #define BL_DW 4</front>
<front id="ultralcd_implementation_hitachi_HD44780H-112">  #define BL_RI 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-113">  #define BL_ST 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-114"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-115">  //automatic, do not change</front>
<front id="ultralcd_implementation_hitachi_HD44780H-116">  #define B_LE BIT(BL_LE)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-117">  #define B_UP BIT(BL_UP)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-118">  #define B_MI BIT(BL_MI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-119">  #define B_DW BIT(BL_DW)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-120">  #define B_RI BIT(BL_RI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-121">  #define B_ST BIT(BL_ST)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-122">  </front>
<front id="ultralcd_implementation_hitachi_HD44780H-123">  #define LCD_CLICKED (buttons&(B_MI|B_ST))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-124">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-125"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-126">#endif //ULTIPANEL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-127"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-128">////////////////////////////////////</front>
<front id="ultralcd_implementation_hitachi_HD44780H-129">// Create LCD class instance and chipset-specific information</front>
<front id="ultralcd_implementation_hitachi_HD44780H-130">#if ENABLED(LCD_I2C_TYPE_PCF8575)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-131">  // note: these are register mapped pins on the PCF8575 controller not Arduino pins</front>
<front id="ultralcd_implementation_hitachi_HD44780H-132">  #define LCD_I2C_PIN_BL  3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-133">  #define LCD_I2C_PIN_EN  2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-134">  #define LCD_I2C_PIN_RW  1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-135">  #define LCD_I2C_PIN_RS  0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-136">  #define LCD_I2C_PIN_D4  4</front>
<front id="ultralcd_implementation_hitachi_HD44780H-137">  #define LCD_I2C_PIN_D5  5</front>
<front id="ultralcd_implementation_hitachi_HD44780H-138">  #define LCD_I2C_PIN_D6  6</front>
<front id="ultralcd_implementation_hitachi_HD44780H-139">  #define LCD_I2C_PIN_D7  7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-140"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-141">  #include &lt;Wire.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-142">  #include &lt;LCD.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-143">  #include &lt;LiquidCrystal_I2C.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-144">  #define LCD_CLASS LiquidCrystal_I2C</front>
<front id="ultralcd_implementation_hitachi_HD44780H-145">  LCD_CLASS lcd(LCD_I2C_ADDRESS,LCD_I2C_PIN_EN,LCD_I2C_PIN_RW,LCD_I2C_PIN_RS,LCD_I2C_PIN_D4,LCD_I2C_PIN_D5,LCD_I2C_PIN_D6,LCD_I2C_PIN_D7);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-146"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-147">#elif ENABLED(LCD_I2C_TYPE_MCP23017)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-148">  //for the LED indicators (which maybe mapped to different things in lcd_implementation_update_indicators())</front>
<front id="ultralcd_implementation_hitachi_HD44780H-149">  #define LED_A 0x04 //100</front>
<front id="ultralcd_implementation_hitachi_HD44780H-150">  #define LED_B 0x02 //010</front>
<front id="ultralcd_implementation_hitachi_HD44780H-151">  #define LED_C 0x01 //001</front>
<front id="ultralcd_implementation_hitachi_HD44780H-152"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-153">  #define LCD_HAS_STATUS_INDICATORS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-154"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-155">  #include &lt;Wire.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-156">  #include &lt;LiquidTWI2.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-157">  #define LCD_CLASS LiquidTWI2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-158">  #if ENABLED(DETECT_DEVICE)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-159">    LCD_CLASS lcd(LCD_I2C_ADDRESS, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-160">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-161">    LCD_CLASS lcd(LCD_I2C_ADDRESS);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-162">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-163"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-164">#elif ENABLED(LCD_I2C_TYPE_MCP23008)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-165">  #include &lt;Wire.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-166">  #include &lt;LiquidTWI2.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-167">  #define LCD_CLASS LiquidTWI2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-168">  #if ENABLED(DETECT_DEVICE)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-169">    LCD_CLASS lcd(LCD_I2C_ADDRESS, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-170">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-171">    LCD_CLASS lcd(LCD_I2C_ADDRESS);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-172">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-173"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-174">#elif ENABLED(LCD_I2C_TYPE_PCA8574)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-175">    #include &lt;LiquidCrystal_I2C.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-176">    #define LCD_CLASS LiquidCrystal_I2C</front>
<front id="ultralcd_implementation_hitachi_HD44780H-177">    LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-178"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-179">// 2 wire Non-latching LCD SR from:</front>
<front id="ultralcd_implementation_hitachi_HD44780H-180">// https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection</front>
<front id="ultralcd_implementation_hitachi_HD44780H-181">#elif ENABLED(SR_LCD_2W_NL)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-182">  extern "C" void __cxa_pure_virtual() { while (1); }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-183">  #include &lt;LCD.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-184">  #include &lt;LiquidCrystal_SR.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-185">  #define LCD_CLASS LiquidCrystal_SR</front>
<front id="ultralcd_implementation_hitachi_HD44780H-186">  LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-187">#else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-188">  // Standard directly connected LCD implementations</front>
<front id="ultralcd_implementation_hitachi_HD44780H-189">  #include &lt;LiquidCrystal.h&gt;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-190">  #define LCD_CLASS LiquidCrystal</front>
<front id="ultralcd_implementation_hitachi_HD44780H-191">  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5,LCD_PINS_D6,LCD_PINS_D7);  //RS,Enable,D4,D5,D6,D7</front>
<front id="ultralcd_implementation_hitachi_HD44780H-192">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-193"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-194">#include "utf_mapper.h"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-195"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-196">#if ENABLED(SHOW_BOOTSCREEN)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-197">  static void bootscreen();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-198">  static bool show_bootscreen = true;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-199">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-200"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-201">#if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-202">  static millis_t progress_bar_ms = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-203">  #if PROGRESS_MSG_EXPIRE &gt; 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-204">    static millis_t expire_status_ms = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-205">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-206">  #define LCD_STR_PROGRESS  "\x03\x04\x05"</front>
<front id="ultralcd_implementation_hitachi_HD44780H-207">#endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-208"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-209">static void lcd_set_custom_characters(</front>
<front id="ultralcd_implementation_hitachi_HD44780H-210">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-211">    bool progress_bar_set=true</front>
<front id="ultralcd_implementation_hitachi_HD44780H-212">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-213">) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-214">  byte bedTemp[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-215">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-216">    B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-217">    B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-218">    B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-219">    B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-220">    B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-221">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-222">    B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-223">  }; //thanks Sonny Mounicou</front>
<front id="ultralcd_implementation_hitachi_HD44780H-224">  byte degree[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-225">    B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-226">    B10010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-227">    B10010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-228">    B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-229">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-230">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-231">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-232">    B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-233">  };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-234">  byte thermometer[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-235">    B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-236">    B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-237">    B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-238">    B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-239">    B01010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-240">    B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-241">    B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-242">    B01110</front>
<front id="ultralcd_implementation_hitachi_HD44780H-243">  };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-244">  byte uplevel[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-245">    B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-246">    B01110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-247">    B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-248">    B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-249">    B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-250">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-251">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-252">    B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-253">  }; //thanks joris</front>
<front id="ultralcd_implementation_hitachi_HD44780H-254">  byte refresh[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-255">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-256">    B00110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-257">    B11001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-258">    B11000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-259">    B00011,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-260">    B10011,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-261">    B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-262">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-263">  }; //thanks joris</front>
<front id="ultralcd_implementation_hitachi_HD44780H-264">  byte folder[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-265">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-266">    B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-267">    B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-268">    B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-269">    B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-270">    B11111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-271">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-272">    B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-273">  }; //thanks joris</front>
<front id="ultralcd_implementation_hitachi_HD44780H-274">  byte feedrate[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-275">    B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-276">    B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-277">    B11000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-278">    B10111,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-279">    B00101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-280">    B00110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-281">    B00101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-282">    B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-283">  }; //thanks Sonny Mounicou</front>
<front id="ultralcd_implementation_hitachi_HD44780H-284">  byte clock[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-285">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-286">    B01110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-287">    B10011,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-288">    B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-289">    B10001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-290">    B01110,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-291">    B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-292">    B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-293">  }; //thanks Sonny Mounicou</front>
<front id="ultralcd_implementation_hitachi_HD44780H-294"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-295">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-296">    static bool char_mode = false;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-297">    byte progress[3][8] = { {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-298">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-299">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-300">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-301">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-302">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-303">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-304">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-305">      B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-306">    }, {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-307">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-308">      B10100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-309">      B10100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-310">      B10100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-311">      B10100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-312">      B10100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-313">      B10100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-314">      B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-315">    }, {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-316">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-317">      B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-318">      B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-319">      B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-320">      B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-321">      B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-322">      B10101,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-323">      B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-324">    } };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-325">    if (progress_bar_set != char_mode) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-326">      char_mode = progress_bar_set;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-327">      lcd.createChar(LCD_STR_BEDTEMP[0], bedTemp);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-328">      lcd.createChar(LCD_STR_DEGREE[0], degree);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-329">      lcd.createChar(LCD_STR_THERMOMETER[0], thermometer);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-330">      lcd.createChar(LCD_STR_FEEDRATE[0], feedrate);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-331">      lcd.createChar(LCD_STR_CLOCK[0], clock);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-332">      if (progress_bar_set) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-333">        // Progress bar characters for info screen</front>
<front id="ultralcd_implementation_hitachi_HD44780H-334">        for (int i=3; i--;) lcd.createChar(LCD_STR_PROGRESS[i], progress[i]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-335">      }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-336">      else {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-337">        // Custom characters for submenus</front>
<front id="ultralcd_implementation_hitachi_HD44780H-338">        lcd.createChar(LCD_STR_UPLEVEL[0], uplevel);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-339">        lcd.createChar(LCD_STR_REFRESH[0], refresh);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-340">        lcd.createChar(LCD_STR_FOLDER[0], folder);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-341">      }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-342">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-343">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-344">    lcd.createChar(LCD_STR_BEDTEMP[0], bedTemp);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-345">    lcd.createChar(LCD_STR_DEGREE[0], degree);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-346">    lcd.createChar(LCD_STR_THERMOMETER[0], thermometer);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-347">    lcd.createChar(LCD_STR_UPLEVEL[0], uplevel);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-348">    lcd.createChar(LCD_STR_REFRESH[0], refresh);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-349">    lcd.createChar(LCD_STR_FOLDER[0], folder);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-350">    lcd.createChar(LCD_STR_FEEDRATE[0], feedrate);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-351">    lcd.createChar(LCD_STR_CLOCK[0], clock);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-352">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-353">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-354"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-355">static void lcd_implementation_init(</front>
<front id="ultralcd_implementation_hitachi_HD44780H-356">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-357">    bool progress_bar_set=true</front>
<front id="ultralcd_implementation_hitachi_HD44780H-358">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-359">) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-360"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-361">  #if ENABLED(LCD_I2C_TYPE_PCF8575)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-362">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-363">    #ifdef LCD_I2C_PIN_BL</front>
<front id="ultralcd_implementation_hitachi_HD44780H-364">      lcd.setBacklightPin(LCD_I2C_PIN_BL, POSITIVE);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-365">      lcd.setBacklight(HIGH);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-366">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-367"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-368">  #elif ENABLED(LCD_I2C_TYPE_MCP23017)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-369">    lcd.setMCPType(LTI_TYPE_MCP23017);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-370">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-371">    lcd.setBacklight(0); //set all the LEDs off to begin with</front>
<front id="ultralcd_implementation_hitachi_HD44780H-372"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-373">  #elif ENABLED(LCD_I2C_TYPE_MCP23008)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-374">    lcd.setMCPType(LTI_TYPE_MCP23008);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-375">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-376"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-377">  #elif ENABLED(LCD_I2C_TYPE_PCA8574)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-378">    lcd.init();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-379">    lcd.backlight();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-380"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-381">  #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-382">    lcd.begin(LCD_WIDTH, LCD_HEIGHT);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-383">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-384"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-385">  #if ENABLED(SHOW_BOOTSCREEN)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-386">    if (show_bootscreen) bootscreen();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-387">  #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-388"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-389">  lcd_set_custom_characters(</front>
<front id="ultralcd_implementation_hitachi_HD44780H-390">    #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-391">      progress_bar_set</front>
<front id="ultralcd_implementation_hitachi_HD44780H-392">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-393">  );</front>
<front id="ultralcd_implementation_hitachi_HD44780H-394"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-395">  lcd.clear();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-396">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-397"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-398">static void lcd_implementation_clear() { lcd.clear(); }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-399"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-400">/* Arduino &lt; 1.0.0 is missing a function to print PROGMEM strings, so we need to implement our own */</front>
<front id="ultralcd_implementation_hitachi_HD44780H-401">char lcd_printPGM(const char* str) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-402">  char c, n = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-403">  while ((c = pgm_read_byte(str++))) n += charset_mapper(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-404">  return n;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-405">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-406"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-407">char lcd_print(char* str) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-408">  char c, n = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-409">  unsigned char i = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-410">  while ((c = str[i++])) n += charset_mapper(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-411">  return n;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-412">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-413"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-414">unsigned lcd_print(char c) { return charset_mapper(c); }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-415"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-416">#if ENABLED(SHOW_BOOTSCREEN)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-417">  void lcd_erase_line(int line) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-418">    lcd.setCursor(0, 3);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-419">    for (int i=0; i &lt; LCD_WIDTH; i++)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-420">      lcd_print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-421">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-422"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-423">  // scrol the PSTR'text' in a 'len' wide field for 'time' milliseconds at position col,line</front>
<front id="ultralcd_implementation_hitachi_HD44780H-424">  void lcd_scroll(int col, int line, const char * text, int len, int time) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-425">    char tmp[LCD_WIDTH+1] = {0};</front>
<front id="ultralcd_implementation_hitachi_HD44780H-426">    int n = max(lcd_strlen_P(text) - len, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-427">    for (int i = 0; i &lt;= n; i++) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-428">      strncpy_P(tmp, text+i, min(len, LCD_WIDTH));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-429">      lcd.setCursor(col, line);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-430">      lcd_print(tmp);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-431">      delay(time / max(n, 1));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-432">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-433">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-434"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-435">  static void bootscreen() {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-436">    show_bootscreen = false;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-437">    byte top_left[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-438">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-439">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-440">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-441">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-442">      B00001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-443">      B00010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-444">      B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-445">      B00100</front>
<front id="ultralcd_implementation_hitachi_HD44780H-446">    };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-447">    byte top_right[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-448">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-449">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-450">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-451">      B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-452">      B11100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-453">      B01100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-454">      B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-455">      B00100</front>
<front id="ultralcd_implementation_hitachi_HD44780H-456">    };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-457">    byte botom_left[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-458">      B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-459">      B00010,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-460">      B00001,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-461">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-462">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-463">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-464">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-465">      B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-466">    };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-467">    byte botom_right[8] = {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-468">      B00100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-469">      B01000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-470">      B10000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-471">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-472">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-473">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-474">      B00000,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-475">      B00000</front>
<front id="ultralcd_implementation_hitachi_HD44780H-476">    };</front>
<front id="ultralcd_implementation_hitachi_HD44780H-477">    lcd.createChar(0, top_left);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-478">    lcd.createChar(1, top_right);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-479">    lcd.createChar(2, botom_left);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-480">    lcd.createChar(3, botom_right);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-481"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-482">    lcd.clear();</front>
<front id="ultralcd_implementation_hitachi_HD44780H-483"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-484">    #define TEXT_SCREEN_LOGO_SHIFT ((LCD_WIDTH/2) - 4)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-485">    lcd.setCursor(TEXT_SCREEN_LOGO_SHIFT, 0); lcd.print('\x00'); lcd_printPGM(PSTR( "------" ));  lcd.print('\x01');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-486">    lcd.setCursor(TEXT_SCREEN_LOGO_SHIFT, 1);                    lcd_printPGM(PSTR("|Marlin|"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-487">    lcd.setCursor(TEXT_SCREEN_LOGO_SHIFT, 2); lcd.print('\x02'); lcd_printPGM(PSTR( "------" ));  lcd.print('\x03');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-488"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-489">    lcd_scroll(0, 3, PSTR("marlinfirmware.org"), LCD_WIDTH, 3000);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-490"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-491">    #ifdef STRING_SPLASH_LINE1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-492">      lcd_erase_line(3);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-493">      lcd_scroll(0, 3, PSTR(STRING_SPLASH_LINE1), LCD_WIDTH, 1000);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-494">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-495">    #ifdef STRING_SPLASH_LINE2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-496">      lcd_erase_line(3);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-497">      lcd_scroll(0, 3, PSTR(STRING_SPLASH_LINE2), LCD_WIDTH, 1000);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-498">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-499">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-500">#endif // SHOW_BOOTSCREEN</front>
<front id="ultralcd_implementation_hitachi_HD44780H-501">/*</front>
<front id="ultralcd_implementation_hitachi_HD44780H-502">Possible status screens:</front>
<front id="ultralcd_implementation_hitachi_HD44780H-503">16x2   |000/000 B000/000|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-504">       |0123456789012345|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-505"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-506">16x4   |000/000 B000/000|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-507">       |SD100%  Z000.00 |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-508">       |F100%     T--:--|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-509">       |0123456789012345|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-510"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-511">20x2   |T000/000D B000/000D |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-512">       |01234567890123456789|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-513"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-514">20x4   |T000/000D B000/000D |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-515">       |X000  Y000  Z000.00 |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-516">       |F100%  SD100% T--:--|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-517">       |01234567890123456789|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-518"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-519">20x4   |T000/000D B000/000D |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-520">       |T000/000D   Z000.00 |</front>
<front id="ultralcd_implementation_hitachi_HD44780H-521">       |F100%  SD100% T--:--|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-522">       |01234567890123456789|</front>
<front id="ultralcd_implementation_hitachi_HD44780H-523">*/</front>
<front id="ultralcd_implementation_hitachi_HD44780H-524">static void lcd_implementation_status_screen() {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-525"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-526">  #define LCD_TEMP_ONLY(T1,T2) \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-527">    lcd.print(itostr3(T1 + 0.5)); \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-528">    lcd.print('/'); \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-529">    lcd.print(itostr3left(T2 + 0.5))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-530"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-531">  #define LCD_TEMP(T1,T2,PREFIX) \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-532">    lcd.print(PREFIX); \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-533">    LCD_TEMP_ONLY(T1,T2); \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-534">    lcd_printPGM(PSTR(LCD_STR_DEGREE " ")); \</front>
<front id="ultralcd_implementation_hitachi_HD44780H-535">    if (T2 &lt; 10) lcd.print(' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-536"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-537">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-538">  // Line 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-539">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-540"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-541">  lcd.setCursor(0, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-542"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-543">  #if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-544"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-545">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-546">    // Hotend 0 Temperature</front>
<front id="ultralcd_implementation_hitachi_HD44780H-547">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-548">    LCD_TEMP_ONLY(degHotend(0), degTargetHotend(0));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-549"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-550">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-551">    // Hotend 1 or Bed Temperature</front>
<front id="ultralcd_implementation_hitachi_HD44780H-552">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-553">    #if EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-554"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-555">      lcd.setCursor(8, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-556">      #if EXTRUDERS &gt; 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-557">        lcd.print(LCD_STR_THERMOMETER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-558">        LCD_TEMP_ONLY(degHotend(1), degTargetHotend(1));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-559">      #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-560">        lcd.print(LCD_STR_BEDTEMP[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-561">        LCD_TEMP_ONLY(degBed(), degTargetBed());</front>
<front id="ultralcd_implementation_hitachi_HD44780H-562">      #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-563"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-564">    #endif // EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-565"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-566">  #else // LCD_WIDTH &gt;= 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-567"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-568">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-569">    // Hotend 0 Temperature</front>
<front id="ultralcd_implementation_hitachi_HD44780H-570">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-571">    LCD_TEMP(degHotend(0), degTargetHotend(0), LCD_STR_THERMOMETER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-572"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-573">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-574">    // Hotend 1 or Bed Temperature</front>
<front id="ultralcd_implementation_hitachi_HD44780H-575">    //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-576">    #if EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-577">      lcd.setCursor(10, 0);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-578">      #if EXTRUDERS &gt; 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-579">        LCD_TEMP(degHotend(1), degTargetHotend(1), LCD_STR_THERMOMETER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-580">      #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-581">        LCD_TEMP(degBed(), degTargetBed(), LCD_STR_BEDTEMP[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-582">      #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-583"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-584">    #endif  // EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-585"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-586">  #endif // LCD_WIDTH &gt;= 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-587"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-588">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-589">  // Line 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-590">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-591"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-592">  #if LCD_HEIGHT &gt; 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-593"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-594">    #if LCD_WIDTH &lt; 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-595"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-596">      #if ENABLED(SDSUPPORT)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-597">        lcd.setCursor(0, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-598">        lcd_printPGM(PSTR("SD"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-599">        if (IS_SD_PRINTING)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-600">          lcd.print(itostr3(card.percentDone()));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-601">        else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-602">          lcd_printPGM(PSTR("---"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-603">          lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-604">      #endif // SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-605"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-606">    #else // LCD_WIDTH &gt;= 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-607"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-608">      lcd.setCursor(0, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-609"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-610">      #if EXTRUDERS &gt; 1 && TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-611"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-612">        // If we both have a 2nd extruder and a heated bed,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-613">        // show the heated bed temp on the left,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-614">        // since the first line is filled with extruder temps</front>
<front id="ultralcd_implementation_hitachi_HD44780H-615">        LCD_TEMP(degBed(), degTargetBed(), LCD_STR_BEDTEMP[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-616"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-617">      #else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-618"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-619">        lcd.print('X');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-620">        if (axis_known_position[X_AXIS])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-621">          lcd.print(ftostr3(current_position[X_AXIS]));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-622">        else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-623">          lcd_printPGM(PSTR("---"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-624"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-625">        lcd_printPGM(PSTR("  Y"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-626">        if (axis_known_position[Y_AXIS])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-627">          lcd.print(ftostr3(current_position[Y_AXIS]));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-628">        else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-629">          lcd_printPGM(PSTR("---"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-630"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-631">      #endif // EXTRUDERS &gt; 1 || TEMP_SENSOR_BED != 0</front>
<front id="ultralcd_implementation_hitachi_HD44780H-632"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-633">    #endif // LCD_WIDTH &gt;= 20</front>
<front id="ultralcd_implementation_hitachi_HD44780H-634"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-635">    lcd.setCursor(LCD_WIDTH - 8, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-636">    lcd.print('Z');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-637">    if (axis_known_position[Z_AXIS])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-638">      lcd.print(ftostr32sp(current_position[Z_AXIS] + 0.00001));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-639">    else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-640">      lcd_printPGM(PSTR("---.--"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-641"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-642">  #endif // LCD_HEIGHT &gt; 2</front>
<front id="ultralcd_implementation_hitachi_HD44780H-643"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-644">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-645">  // Line 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-646">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-647"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-648">  #if LCD_HEIGHT &gt; 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-649"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-650">    lcd.setCursor(0, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-651">    lcd.print(LCD_STR_FEEDRATE[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-652">    lcd.print(itostr3(feedrate_multiplier));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-653">    lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-654"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-655">    #if LCD_WIDTH &gt; 19 && ENABLED(SDSUPPORT)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-656"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-657">      lcd.setCursor(7, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-658">      lcd_printPGM(PSTR("SD"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-659">      if (IS_SD_PRINTING)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-660">        lcd.print(itostr3(card.percentDone()));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-661">      else</front>
<front id="ultralcd_implementation_hitachi_HD44780H-662">        lcd_printPGM(PSTR("---"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-663">      lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-664"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-665">    #endif // LCD_WIDTH &gt; 19 && SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-666"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-667">    lcd.setCursor(LCD_WIDTH - 6, 2);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-668">    lcd.print(LCD_STR_CLOCK[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-669">    if (print_job_start_ms != 0) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-670">      uint16_t time = millis()/60000 - print_job_start_ms/60000;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-671">      lcd.print(itostr2(time/60));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-672">      lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-673">      lcd.print(itostr2(time%60));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-674">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-675">    else {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-676">      lcd_printPGM(PSTR("--:--"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-677">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-678"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-679">  #endif // LCD_HEIGHT &gt; 3</front>
<front id="ultralcd_implementation_hitachi_HD44780H-680"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-681">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-682">  // Last Line</front>
<front id="ultralcd_implementation_hitachi_HD44780H-683">  // Status Message (which may be a Progress Bar or Filament display)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-684">  //</front>
<front id="ultralcd_implementation_hitachi_HD44780H-685"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-686">  lcd.setCursor(0, LCD_HEIGHT - 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-687"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-688">  #if ENABLED(LCD_PROGRESS_BAR)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-689"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-690">    if (card.isFileOpen()) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-691">      // Draw the progress bar if the message has shown long enough</front>
<front id="ultralcd_implementation_hitachi_HD44780H-692">      // or if there is no message set.</front>
<front id="ultralcd_implementation_hitachi_HD44780H-693">      if (millis() &gt;= progress_bar_ms + PROGRESS_BAR_MSG_TIME || !lcd_status_message[0]) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-694">        int tix = (int)(card.percentDone() * LCD_WIDTH * 3) / 100,</front>
<front id="ultralcd_implementation_hitachi_HD44780H-695">          cel = tix / 3, rem = tix % 3, i = LCD_WIDTH;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-696">        char msg[LCD_WIDTH+1], b = ' ';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-697">        msg[i] = '\0';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-698">        while (i--) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-699">          if (i == cel - 1)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-700">            b = LCD_STR_PROGRESS[2];</front>
<front id="ultralcd_implementation_hitachi_HD44780H-701">          else if (i == cel && rem != 0)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-702">            b = LCD_STR_PROGRESS[rem-1];</front>
<front id="ultralcd_implementation_hitachi_HD44780H-703">          msg[i] = b;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-704">        }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-705">        lcd.print(msg);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-706">        return;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-707">      }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-708">    } //card.isFileOpen</front>
<front id="ultralcd_implementation_hitachi_HD44780H-709"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-710">  #elif ENABLED(FILAMENT_LCD_DISPLAY)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-711"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-712">    // Show Filament Diameter and Volumetric Multiplier %</front>
<front id="ultralcd_implementation_hitachi_HD44780H-713">    // After allowing lcd_status_message to show for 5 seconds</front>
<front id="ultralcd_implementation_hitachi_HD44780H-714">    if (millis() &gt;= previous_lcd_status_ms + 5000) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-715">      lcd_printPGM(PSTR("Dia "));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-716">      lcd.print(ftostr12ns(filament_width_meas));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-717">      lcd_printPGM(PSTR(" V"));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-718">      lcd.print(itostr3(100.0*volumetric_multiplier[FILAMENT_SENSOR_EXTRUDER_NUM]));</front>
<front id="ultralcd_implementation_hitachi_HD44780H-719">  	  lcd.print('%');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-720">  	  return;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-721">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-722"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-723">  #endif // FILAMENT_LCD_DISPLAY</front>
<front id="ultralcd_implementation_hitachi_HD44780H-724"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-725">  lcd_print(lcd_status_message);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-726">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-727"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-728">static void lcd_implementation_drawmenu_generic(bool sel, uint8_t row, const char* pstr, char pre_char, char post_char) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-729">  char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-730">  uint8_t n = LCD_WIDTH - 2;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-731">  lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-732">  lcd.print(sel ? pre_char : ' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-733">  while ((c = pgm_read_byte(pstr)) && n &gt; 0) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-734">    n -= lcd_print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-735">    pstr++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-736">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-737">  while(n--) lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-738">  lcd.print(post_char);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-739">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-740"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-741">static void lcd_implementation_drawmenu_setting_edit_generic(bool sel, uint8_t row, const char* pstr, char pre_char, char* data) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-742">  char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-743">  uint8_t n = LCD_WIDTH - 2 - lcd_strlen(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-744">  lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-745">  lcd.print(sel ? pre_char : ' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-746">  while ((c = pgm_read_byte(pstr)) && n &gt; 0) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-747">    n -= lcd_print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-748">    pstr++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-749">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-750">  lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-751">  while (n--) lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-752">  lcd_print(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-753">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-754">static void lcd_implementation_drawmenu_setting_edit_generic_P(bool sel, uint8_t row, const char* pstr, char pre_char, const char* data) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-755">  char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-756">  uint8_t n = LCD_WIDTH - 2 - lcd_strlen_P(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-757">  lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-758">  lcd.print(sel ? pre_char : ' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-759">  while ((c = pgm_read_byte(pstr)) && n &gt; 0) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-760">    n -= lcd_print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-761">    pstr++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-762">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-763">  lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-764">  while (n--) lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-765">  lcd_printPGM(data);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-766">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-767"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-768">#define lcd_implementation_drawmenu_setting_edit_int3(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', itostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-769">#define lcd_implementation_drawmenu_setting_edit_float3(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-770">#define lcd_implementation_drawmenu_setting_edit_float32(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr32(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-771">#define lcd_implementation_drawmenu_setting_edit_float43(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr43(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-772">#define lcd_implementation_drawmenu_setting_edit_float5(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-773">#define lcd_implementation_drawmenu_setting_edit_float52(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr52(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-774">#define lcd_implementation_drawmenu_setting_edit_float51(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr51(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-775">#define lcd_implementation_drawmenu_setting_edit_long5(sel, row, pstr, pstr2, data, minValue, maxValue) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-776">#define lcd_implementation_drawmenu_setting_edit_bool(sel, row, pstr, pstr2, data) lcd_implementation_drawmenu_setting_edit_generic_P(sel, row, pstr, '&gt;', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-777"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-778">//Add version for callback functions</front>
<front id="ultralcd_implementation_hitachi_HD44780H-779">#define lcd_implementation_drawmenu_setting_edit_callback_int3(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', itostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-780">#define lcd_implementation_drawmenu_setting_edit_callback_float3(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr3(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-781">#define lcd_implementation_drawmenu_setting_edit_callback_float32(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr32(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-782">#define lcd_implementation_drawmenu_setting_edit_callback_float43(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr43(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-783">#define lcd_implementation_drawmenu_setting_edit_callback_float5(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-784">#define lcd_implementation_drawmenu_setting_edit_callback_float52(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr52(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-785">#define lcd_implementation_drawmenu_setting_edit_callback_float51(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr51(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-786">#define lcd_implementation_drawmenu_setting_edit_callback_long5(sel, row, pstr, pstr2, data, minValue, maxValue, callback) lcd_implementation_drawmenu_setting_edit_generic(sel, row, pstr, '&gt;', ftostr5(*(data)))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-787">#define lcd_implementation_drawmenu_setting_edit_callback_bool(sel, row, pstr, pstr2, data, callback) lcd_implementation_drawmenu_setting_edit_generic_P(sel, row, pstr, '&gt;', (*(data))?PSTR(MSG_ON):PSTR(MSG_OFF))</front>
<front id="ultralcd_implementation_hitachi_HD44780H-788"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-789">void lcd_implementation_drawedit(const char* pstr, char* value) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-790">  lcd.setCursor(1, 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-791">  lcd_printPGM(pstr);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-792">  lcd.print(':');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-793">  lcd.setCursor(LCD_WIDTH - lcd_strlen(value), 1);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-794">  lcd_print(value);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-795">}</front>
<front id="ultralcd_implementation_hitachi_HD44780H-796"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-797">#if ENABLED(SDSUPPORT)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-798"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-799">  static void lcd_implementation_drawmenu_sd(bool sel, uint8_t row, const char* pstr, const char* filename, char* longFilename, uint8_t concat, char post_char) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-800">    char c;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-801">    uint8_t n = LCD_WIDTH - concat;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-802">    lcd.setCursor(0, row);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-803">    lcd.print(sel ? '&gt;' : ' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-804">    if (longFilename[0]) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-805">      filename = longFilename;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-806">      longFilename[n] = '\0';</front>
<front id="ultralcd_implementation_hitachi_HD44780H-807">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-808">    while ((c = *filename) && n &gt; 0) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-809">      n -= lcd_print(c);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-810">      filename++;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-811">    }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-812">    while (n--) lcd.print(' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-813">    lcd.print(post_char);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-814">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-815"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-816">  static void lcd_implementation_drawmenu_sdfile(bool sel, uint8_t row, const char* pstr, const char* filename, char* longFilename) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-817">    lcd_implementation_drawmenu_sd(sel, row, pstr, filename, longFilename, 2, ' ');</front>
<front id="ultralcd_implementation_hitachi_HD44780H-818">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-819"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-820">  static void lcd_implementation_drawmenu_sddirectory(bool sel, uint8_t row, const char* pstr, const char* filename, char* longFilename) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-821">    lcd_implementation_drawmenu_sd(sel, row, pstr, filename, longFilename, 2, LCD_STR_FOLDER[0]);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-822">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-823"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-824">#endif //SDSUPPORT</front>
<front id="ultralcd_implementation_hitachi_HD44780H-825"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-826">#define lcd_implementation_drawmenu_back(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, LCD_STR_UPLEVEL[0], LCD_STR_UPLEVEL[0])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-827">#define lcd_implementation_drawmenu_submenu(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '&gt;', LCD_STR_ARROW_RIGHT[0])</front>
<front id="ultralcd_implementation_hitachi_HD44780H-828">#define lcd_implementation_drawmenu_gcode(sel, row, pstr, gcode) lcd_implementation_drawmenu_generic(sel, row, pstr, '&gt;', ' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-829">#define lcd_implementation_drawmenu_function(sel, row, pstr, data) lcd_implementation_drawmenu_generic(sel, row, pstr, '&gt;', ' ')</front>
<front id="ultralcd_implementation_hitachi_HD44780H-830"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-831">#if ENABLED(LCD_HAS_STATUS_INDICATORS)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-832"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-833">  static void lcd_implementation_update_indicators() {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-834">    #if ENABLED(LCD_I2C_PANELOLU2) || ENABLED(LCD_I2C_VIKI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-835">      // Set the LEDS - referred to as backlights by the LiquidTWI2 library</front>
<front id="ultralcd_implementation_hitachi_HD44780H-836">      static uint8_t ledsprev = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-837">      uint8_t leds = 0;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-838">      if (target_temperature_bed &gt; 0) leds |= LED_A;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-839">      if (target_temperature[0] &gt; 0) leds |= LED_B;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-840">      if (fanSpeed) leds |= LED_C;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-841">      #if EXTRUDERS &gt; 1</front>
<front id="ultralcd_implementation_hitachi_HD44780H-842">        if (target_temperature[1] &gt; 0) leds |= LED_C;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-843">      #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-844">      if (leds != ledsprev) {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-845">        lcd.setBacklight(leds);</front>
<front id="ultralcd_implementation_hitachi_HD44780H-846">        ledsprev = leds;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-847">      }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-848">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-849">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-850"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-851">#endif // LCD_HAS_STATUS_INDICATORS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-852"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-853">#if ENABLED(LCD_HAS_SLOW_BUTTONS)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-854"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-855">  extern millis_t next_button_update_ms;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-856"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-857">  static uint8_t lcd_implementation_read_slow_buttons() {</front>
<front id="ultralcd_implementation_hitachi_HD44780H-858">    #if ENABLED(LCD_I2C_TYPE_MCP23017)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-859">      uint8_t slow_buttons;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-860">      // Reading these buttons this is likely to be too slow to call inside interrupt context</front>
<front id="ultralcd_implementation_hitachi_HD44780H-861">      // so they are called during normal lcd_update</front>
<front id="ultralcd_implementation_hitachi_HD44780H-862">      slow_buttons = lcd.readButtons() &lt;&lt; B_I2C_BTN_OFFSET; </front>
<front id="ultralcd_implementation_hitachi_HD44780H-863">      #if ENABLED(LCD_I2C_VIKI)</front>
<front id="ultralcd_implementation_hitachi_HD44780H-864">        if ((slow_buttons & (B_MI|B_RI)) && millis() &lt; next_button_update_ms) // LCD clicked</front>
<front id="ultralcd_implementation_hitachi_HD44780H-865">          slow_buttons &= ~(B_MI|B_RI); // Disable LCD clicked buttons if screen is updated</front>
<front id="ultralcd_implementation_hitachi_HD44780H-866">      #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-867">      return slow_buttons;</front>
<front id="ultralcd_implementation_hitachi_HD44780H-868">    #endif</front>
<front id="ultralcd_implementation_hitachi_HD44780H-869">  }</front>
<front id="ultralcd_implementation_hitachi_HD44780H-870"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-871">#endif // LCD_HAS_SLOW_BUTTONS</front>
<front id="ultralcd_implementation_hitachi_HD44780H-872"></front>
<front id="ultralcd_implementation_hitachi_HD44780H-873">#endif // ULTRALCD_IMPLEMENTATION_HITACHI_HD44780_H</front>
 </pre>
<h1 id="ultralcd_st7920_u8glib_rrdHtitle" >ultralcd_st7920_u8glib_rrd.h</h1>
<pre id="ultralcd_st7920_u8glib_rrdH"  class="prettyprint linenums"><front id="ultralcd_st7920_u8glib_rrdH-1">#ifndef ULCDST7920_H</front>
<front id="ultralcd_st7920_u8glib_rrdH-2">#define ULCDST7920_H</front>
<front id="ultralcd_st7920_u8glib_rrdH-3"></front>
<front id="ultralcd_st7920_u8glib_rrdH-4">#include "Marlin.h"</front>
<front id="ultralcd_st7920_u8glib_rrdH-5"></front>
<front id="ultralcd_st7920_u8glib_rrdH-6">#if ENABLED(U8GLIB_ST7920)</front>
<front id="ultralcd_st7920_u8glib_rrdH-7"></front>
<front id="ultralcd_st7920_u8glib_rrdH-8">//set optimization so ARDUINO optimizes this file</front>
<front id="ultralcd_st7920_u8glib_rrdH-9">#pragma GCC optimize (3)</front>
<front id="ultralcd_st7920_u8glib_rrdH-10"></front>
<front id="ultralcd_st7920_u8glib_rrdH-11">#define ST7920_CLK_PIN  LCD_PINS_D4</front>
<front id="ultralcd_st7920_u8glib_rrdH-12">#define ST7920_DAT_PIN  LCD_PINS_ENABLE</front>
<front id="ultralcd_st7920_u8glib_rrdH-13">#define ST7920_CS_PIN   LCD_PINS_RS</front>
<front id="ultralcd_st7920_u8glib_rrdH-14"></front>
<front id="ultralcd_st7920_u8glib_rrdH-15">//#define PAGE_HEIGHT 8   //128 byte framebuffer</front>
<front id="ultralcd_st7920_u8glib_rrdH-16">//#define PAGE_HEIGHT 16  //256 byte framebuffer</front>
<front id="ultralcd_st7920_u8glib_rrdH-17">#define PAGE_HEIGHT 32  //512 byte framebuffer</front>
<front id="ultralcd_st7920_u8glib_rrdH-18"></front>
<front id="ultralcd_st7920_u8glib_rrdH-19">#define LCD_PIXEL_WIDTH 128</front>
<front id="ultralcd_st7920_u8glib_rrdH-20">#define LCD_PIXEL_HEIGHT 64</front>
<front id="ultralcd_st7920_u8glib_rrdH-21"></front>
<front id="ultralcd_st7920_u8glib_rrdH-22">#include &lt;U8glib.h&gt;</front>
<front id="ultralcd_st7920_u8glib_rrdH-23"></front>
<front id="ultralcd_st7920_u8glib_rrdH-24">static void ST7920_SWSPI_SND_8BIT(uint8_t val)</front>
<front id="ultralcd_st7920_u8glib_rrdH-25">{</front>
<front id="ultralcd_st7920_u8glib_rrdH-26">  uint8_t i;</front>
<front id="ultralcd_st7920_u8glib_rrdH-27">  for( i=0; i&lt;8; i++ )</front>
<front id="ultralcd_st7920_u8glib_rrdH-28">  {</front>
<front id="ultralcd_st7920_u8glib_rrdH-29">    WRITE(ST7920_CLK_PIN,0);</front>
<front id="ultralcd_st7920_u8glib_rrdH-30">    #if F_CPU == 20000000</front>
<front id="ultralcd_st7920_u8glib_rrdH-31">      __asm__("nop\n\t"); </front>
<front id="ultralcd_st7920_u8glib_rrdH-32">    #endif</front>
<front id="ultralcd_st7920_u8glib_rrdH-33">    WRITE(ST7920_DAT_PIN,val&0x80); </front>
<front id="ultralcd_st7920_u8glib_rrdH-34">    val&lt;&lt;=1;</front>
<front id="ultralcd_st7920_u8glib_rrdH-35">    WRITE(ST7920_CLK_PIN,1);</front>
<front id="ultralcd_st7920_u8glib_rrdH-36">    #if F_CPU == 20000000</front>
<front id="ultralcd_st7920_u8glib_rrdH-37">      __asm__("nop\n\t""nop\n\t"); </front>
<front id="ultralcd_st7920_u8glib_rrdH-38">    #endif</front>
<front id="ultralcd_st7920_u8glib_rrdH-39">  }</front>
<front id="ultralcd_st7920_u8glib_rrdH-40">}</front>
<front id="ultralcd_st7920_u8glib_rrdH-41"></front>
<front id="ultralcd_st7920_u8glib_rrdH-42">#define ST7920_CS()              {WRITE(ST7920_CS_PIN,1);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-43">#define ST7920_NCS()             {WRITE(ST7920_CS_PIN,0);}</front>
<front id="ultralcd_st7920_u8glib_rrdH-44">#define ST7920_SET_CMD()         {ST7920_SWSPI_SND_8BIT(0xf8);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-45">#define ST7920_SET_DAT()         {ST7920_SWSPI_SND_8BIT(0xfa);u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-46">#define ST7920_WRITE_BYTE(a)     {ST7920_SWSPI_SND_8BIT((uint8_t)((a)&0xf0u));ST7920_SWSPI_SND_8BIT((uint8_t)((a)&lt;&lt;4u));u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-47">#define ST7920_WRITE_BYTES(p,l)  {uint8_t i;for(i=0;i&lt;l;i++){ST7920_SWSPI_SND_8BIT(*p&0xf0);ST7920_SWSPI_SND_8BIT(*p&lt;&lt;4);p++;}u8g_10MicroDelay();}</front>
<front id="ultralcd_st7920_u8glib_rrdH-48"></front>
<front id="ultralcd_st7920_u8glib_rrdH-49">uint8_t u8g_dev_rrd_st7920_128x64_fn(u8g_t *u8g, u8g_dev_t *dev, uint8_t msg, void *arg)</front>
<front id="ultralcd_st7920_u8glib_rrdH-50">{</front>
<front id="ultralcd_st7920_u8glib_rrdH-51">  uint8_t i,y;</front>
<front id="ultralcd_st7920_u8glib_rrdH-52">  switch(msg)</front>
<front id="ultralcd_st7920_u8glib_rrdH-53">  {</front>
<front id="ultralcd_st7920_u8glib_rrdH-54">    case U8G_DEV_MSG_INIT:</front>
<front id="ultralcd_st7920_u8glib_rrdH-55">      {</front>
<front id="ultralcd_st7920_u8glib_rrdH-56">        OUT_WRITE(ST7920_CS_PIN,LOW);</front>
<front id="ultralcd_st7920_u8glib_rrdH-57">        OUT_WRITE(ST7920_DAT_PIN,LOW);</front>
<front id="ultralcd_st7920_u8glib_rrdH-58">        OUT_WRITE(ST7920_CLK_PIN,HIGH);</front>
<front id="ultralcd_st7920_u8glib_rrdH-59"></front>
<front id="ultralcd_st7920_u8glib_rrdH-60">        ST7920_CS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-61">        u8g_Delay(120);                 //initial delay for boot up</front>
<front id="ultralcd_st7920_u8glib_rrdH-62">        ST7920_SET_CMD();</front>
<front id="ultralcd_st7920_u8glib_rrdH-63">        ST7920_WRITE_BYTE(0x08);       //display off, cursor+blink off</front>
<front id="ultralcd_st7920_u8glib_rrdH-64">        ST7920_WRITE_BYTE(0x01);       //clear CGRAM ram</front>
<front id="ultralcd_st7920_u8glib_rrdH-65">        u8g_Delay(15);                 //delay for CGRAM clear</front>
<front id="ultralcd_st7920_u8glib_rrdH-66">        ST7920_WRITE_BYTE(0x3E);       //extended mode + GDRAM active</front>
<front id="ultralcd_st7920_u8glib_rrdH-67">        for(y=0;y&lt;LCD_PIXEL_HEIGHT/2;y++)        //clear GDRAM</front>
<front id="ultralcd_st7920_u8glib_rrdH-68">        {</front>
<front id="ultralcd_st7920_u8glib_rrdH-69">          ST7920_WRITE_BYTE(0x80|y);   //set y</front>
<front id="ultralcd_st7920_u8glib_rrdH-70">          ST7920_WRITE_BYTE(0x80);     //set x = 0</front>
<front id="ultralcd_st7920_u8glib_rrdH-71">          ST7920_SET_DAT();</front>
<front id="ultralcd_st7920_u8glib_rrdH-72">          for(i=0;i&lt;2*LCD_PIXEL_WIDTH/8;i++)     //2x width clears both segments</front>
<front id="ultralcd_st7920_u8glib_rrdH-73">            ST7920_WRITE_BYTE(0);</front>
<front id="ultralcd_st7920_u8glib_rrdH-74">          ST7920_SET_CMD();</front>
<front id="ultralcd_st7920_u8glib_rrdH-75">        }</front>
<front id="ultralcd_st7920_u8glib_rrdH-76">        ST7920_WRITE_BYTE(0x0C); //display on, cursor+blink off</front>
<front id="ultralcd_st7920_u8glib_rrdH-77">        ST7920_NCS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-78">      }</front>
<front id="ultralcd_st7920_u8glib_rrdH-79">      break;</front>
<front id="ultralcd_st7920_u8glib_rrdH-80"></front>
<front id="ultralcd_st7920_u8glib_rrdH-81">    case U8G_DEV_MSG_STOP:</front>
<front id="ultralcd_st7920_u8glib_rrdH-82">      break;</front>
<front id="ultralcd_st7920_u8glib_rrdH-83">    case U8G_DEV_MSG_PAGE_NEXT:</front>
<front id="ultralcd_st7920_u8glib_rrdH-84">      {</front>
<front id="ultralcd_st7920_u8glib_rrdH-85">        uint8_t *ptr;</front>
<front id="ultralcd_st7920_u8glib_rrdH-86">        u8g_pb_t *pb = (u8g_pb_t *)(dev-&gt;dev_mem);</front>
<front id="ultralcd_st7920_u8glib_rrdH-87">        y = pb-&gt;p.page_y0;</front>
<front id="ultralcd_st7920_u8glib_rrdH-88">        ptr = (uint8_t*)pb-&gt;buf;</front>
<front id="ultralcd_st7920_u8glib_rrdH-89"></front>
<front id="ultralcd_st7920_u8glib_rrdH-90">        ST7920_CS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-91">        for( i = 0; i &lt; PAGE_HEIGHT; i ++ )</front>
<front id="ultralcd_st7920_u8glib_rrdH-92">        {</front>
<front id="ultralcd_st7920_u8glib_rrdH-93">          ST7920_SET_CMD();</front>
<front id="ultralcd_st7920_u8glib_rrdH-94">          if ( y &lt; 32 )</front>
<front id="ultralcd_st7920_u8glib_rrdH-95">          {</front>
<front id="ultralcd_st7920_u8glib_rrdH-96">            ST7920_WRITE_BYTE(0x80 | y);       //y</front>
<front id="ultralcd_st7920_u8glib_rrdH-97">            ST7920_WRITE_BYTE(0x80);           //x=0</front>
<front id="ultralcd_st7920_u8glib_rrdH-98">          }</front>
<front id="ultralcd_st7920_u8glib_rrdH-99">          else</front>
<front id="ultralcd_st7920_u8glib_rrdH-100">          {</front>
<front id="ultralcd_st7920_u8glib_rrdH-101">            ST7920_WRITE_BYTE(0x80 | (y-32));  //y</front>
<front id="ultralcd_st7920_u8glib_rrdH-102">            ST7920_WRITE_BYTE(0x80 | 8);       //x=64</front>
<front id="ultralcd_st7920_u8glib_rrdH-103">          }</front>
<front id="ultralcd_st7920_u8glib_rrdH-104"></front>
<front id="ultralcd_st7920_u8glib_rrdH-105">          ST7920_SET_DAT();</front>
<front id="ultralcd_st7920_u8glib_rrdH-106">          ST7920_WRITE_BYTES(ptr,LCD_PIXEL_WIDTH/8); //ptr is incremented inside of macro</front>
<front id="ultralcd_st7920_u8glib_rrdH-107">          y++;</front>
<front id="ultralcd_st7920_u8glib_rrdH-108">        }</front>
<front id="ultralcd_st7920_u8glib_rrdH-109">        ST7920_NCS();</front>
<front id="ultralcd_st7920_u8glib_rrdH-110">      }</front>
<front id="ultralcd_st7920_u8glib_rrdH-111">      break;</front>
<front id="ultralcd_st7920_u8glib_rrdH-112">  }</front>
<front id="ultralcd_st7920_u8glib_rrdH-113">#if PAGE_HEIGHT == 8</front>
<front id="ultralcd_st7920_u8glib_rrdH-114">  return u8g_dev_pb8h1_base_fn(u8g, dev, msg, arg);</front>
<front id="ultralcd_st7920_u8glib_rrdH-115">#elif PAGE_HEIGHT == 16</front>
<front id="ultralcd_st7920_u8glib_rrdH-116">  return u8g_dev_pb16h1_base_fn(u8g, dev, msg, arg);</front>
<front id="ultralcd_st7920_u8glib_rrdH-117">#else</front>
<front id="ultralcd_st7920_u8glib_rrdH-118">  return u8g_dev_pb32h1_base_fn(u8g, dev, msg, arg);</front>
<front id="ultralcd_st7920_u8glib_rrdH-119">#endif</front>
<front id="ultralcd_st7920_u8glib_rrdH-120">}</front>
<front id="ultralcd_st7920_u8glib_rrdH-121"></front>
<front id="ultralcd_st7920_u8glib_rrdH-122">uint8_t   u8g_dev_st7920_128x64_rrd_buf[LCD_PIXEL_WIDTH*(PAGE_HEIGHT/8)] U8G_NOCOMMON;</front>
<front id="ultralcd_st7920_u8glib_rrdH-123">u8g_pb_t  u8g_dev_st7920_128x64_rrd_pb = {{PAGE_HEIGHT,LCD_PIXEL_HEIGHT,0,0,0},LCD_PIXEL_WIDTH,u8g_dev_st7920_128x64_rrd_buf};</front>
<front id="ultralcd_st7920_u8glib_rrdH-124">u8g_dev_t u8g_dev_st7920_128x64_rrd_sw_spi = {u8g_dev_rrd_st7920_128x64_fn,&u8g_dev_st7920_128x64_rrd_pb,&u8g_com_null_fn};</front>
<front id="ultralcd_st7920_u8glib_rrdH-125"></front>
<front id="ultralcd_st7920_u8glib_rrdH-126">class U8GLIB_ST7920_128X64_RRD : public U8GLIB</front>
<front id="ultralcd_st7920_u8glib_rrdH-127">{</front>
<front id="ultralcd_st7920_u8glib_rrdH-128">  public:</front>
<front id="ultralcd_st7920_u8glib_rrdH-129">    U8GLIB_ST7920_128X64_RRD(uint8_t dummy) : U8GLIB(&u8g_dev_st7920_128x64_rrd_sw_spi) {}</front>
<front id="ultralcd_st7920_u8glib_rrdH-130">};</front>
<front id="ultralcd_st7920_u8glib_rrdH-131"></front>
<front id="ultralcd_st7920_u8glib_rrdH-132"></front>
<front id="ultralcd_st7920_u8glib_rrdH-133">#endif //U8GLIB_ST7920</front>
<front id="ultralcd_st7920_u8glib_rrdH-134">#endif //ULCDST7920_H</front>
 </pre>
<h1 id="utf_mapperHtitle" >utf_mapper.h</h1>
<pre id="utf_mapperH"  class="prettyprint linenums"><front id="utf_mapperH-1">#ifndef UTF_MAPPER_H</front>
<front id="utf_mapperH-2">#define UTF_MAPPER_H</front>
<front id="utf_mapperH-3"></front>
<front id="utf_mapperH-4">#include  "language.h"</front>
<front id="utf_mapperH-5"></front>
<front id="utf_mapperH-6">#if ENABLED(DOGLCD)</front>
<front id="utf_mapperH-7">  #define HARDWARE_CHAR_OUT u8g.print</front>
<front id="utf_mapperH-8">#else</front>
<front id="utf_mapperH-9">  #define HARDWARE_CHAR_OUT lcd.write</front>
<front id="utf_mapperH-10">#endif</front>
<front id="utf_mapperH-11"></front>
<front id="utf_mapperH-12">#if DISABLED(SIMULATE_ROMFONT) && ENABLED(DOGLCD)</front>
<front id="utf_mapperH-13">  #if ENABLED(DISPLAY_CHARSET_ISO10646_1)</front>
<front id="utf_mapperH-14">    #define MAPPER_ONE_TO_ONE</front>
<front id="utf_mapperH-15">  #elif ENABLED(DISPLAY_CHARSET_ISO10646_5)</front>
<front id="utf_mapperH-16">    #define MAPPER_ONE_TO_ONE</front>
<front id="utf_mapperH-17">  #elif ENABLED(DISPLAY_CHARSET_ISO10646_KANA)</front>
<front id="utf_mapperH-18">    #define MAPPER_ONE_TO_ONE</front>
<front id="utf_mapperH-19">  #endif</front>
<front id="utf_mapperH-20">#else // SIMULATE_ROMFONT</front>
<front id="utf_mapperH-21">  #if ENABLED(DISPLAY_CHARSET_HD44780_JAPAN)</front>
<front id="utf_mapperH-22">    #if ENABLED(MAPPER_C2C3)</front>
<front id="utf_mapperH-23">      const PROGMEM uint8_t utf_recode[] =</front>
<front id="utf_mapperH-24">           { // 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f          This is fair for symbols</front>
<front id="utf_mapperH-25">             0x20,0x3f,0xec,0xed,0x3f,0x5c,0x7c,0x3f,0x22,0x63,0x61,0x7f,0x3f,0x3f,0x52,0xb0,  // c2a</front>
<front id="utf_mapperH-26">  //          ' '                        l         "    c    a                  R</front>
<front id="utf_mapperH-27">             0xdf,0x3f,0x32,0x33,0x27,0xe4,0xf1,0xa5,0x2c,0x31,0xdf,0x7e,0x3f,0x3f,0x3f,0x3f,  // c2b but relatively bad for letters.</front>
<front id="utf_mapperH-28">  //                   2    3    `    N    p    .    ,    1        </front>
<front id="utf_mapperH-29">             0x3f,0x3f,0x3f,0x3f,0xe1,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,  // c38</front>
<front id="utf_mapperH-30">  //                              </front>
<front id="utf_mapperH-31">             0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0xef,0x78,0x3f,0x3f,0x3f,0x3f,0xf5,0x3f,0x3f,0xe2,  // c39 missing characters display as '?'</front>
<front id="utf_mapperH-32">  //                                             x                                     </front>
<front id="utf_mapperH-33">             0x3f,0x3f,0x3f,0x3f,0xe1,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,0x3f,  // c3a</front>
<front id="utf_mapperH-34">  //                              </front>
<front id="utf_mapperH-35">             0x3f,0xee,0x3f,0x3f,0x3f,0x3f,0xef,0xfd,0x3f,0x3f,0x3f,0x3f,0xf5,0x3f,0x3f,0x3f   // c3b</front>
<front id="utf_mapperH-36">  //               n                                                    </front>
<front id="utf_mapperH-37">           };</front>
<front id="utf_mapperH-38">    #elif ENABLED(MAPPER_E382E383)</front>
<front id="utf_mapperH-39">      const PROGMEM uint8_t utf_recode[] =</front>
<front id="utf_mapperH-40">           { // 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f</front>
<front id="utf_mapperH-41">             0x3d,0xb1,0xb1,0xa8,0xb2,0xa9,0xb3,0xaa,0xb4,0xab,0xb5,0xb6,0xb6,0xb7,0xb7,0xb8,  // e382a Please test and correct</front>
<front id="utf_mapperH-42">  //          =                                                          </front>
<front id="utf_mapperH-43">             0xb8,0xb9,0xb9,0xba,0xba,0xbb,0xbb,0xbc,0xbc,0xbd,0xbd,0xbe,0xbe,0xbf,0xbf,0xc0,  // e382b</front>
<front id="utf_mapperH-44">  //                                                                   </front>
<front id="utf_mapperH-45">             0xc0,0xc1,0xc1,0xc2,0xc2,0xc2,0xc3,0xc3,0xc4,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,  // e3838</front>
<front id="utf_mapperH-46">  //                                                                    </front>
<front id="utf_mapperH-47">             0xca,0xca,0xcb,0xcb,0xcb,0xcc,0xcc,0xcc,0xcd,0xcd,0xcd,0xce,0xce,0xce,0xcf,0xd0,  // e3839</front>
<front id="utf_mapperH-48">  //                                                                    </front>
<front id="utf_mapperH-49">             0xd1,0xd2,0xd3,0xd4,0xd4,0xd5,0xd5,0xae,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdc,  // e383a</front>
<front id="utf_mapperH-50">  //                                                                    </front>
<front id="utf_mapperH-51">             0xec,0xa7,0xa6,0xdd,0xcc,0x3f,0x3f,0x3f,0x3f,0x3f,0xa6,0xa5,0xb0,0xa4,0xa4,0x3f   // e383b</front>
<front id="utf_mapperH-52">  //                              ?    ?   ?    ?    ?                       ?</front>
<front id="utf_mapperH-53">           };</front>
<front id="utf_mapperH-54">    #elif ENABLED(MAPPER_D0D1)</front>
<front id="utf_mapperH-55">      #error( "Cyrillic on a japanese dsplay makes no sense. There are no matching symbols.");</front>
<front id="utf_mapperH-56">    #endif</front>
<front id="utf_mapperH-57"></front>
<front id="utf_mapperH-58">  #elif ENABLED(DISPLAY_CHARSET_HD44780_WESTERN)</front>
<front id="utf_mapperH-59">    #if ENABLED(MAPPER_C2C3)</front>
<front id="utf_mapperH-60">      const PROGMEM uint8_t utf_recode[] =</front>
<front id="utf_mapperH-61">           { // 0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f   This is relative complete.</front>
<front id="utf_mapperH-62">             0x20,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0x22,0xa9,0xaa,0xab,0x3f,0x3f,0xae,0x3f,  // c2a</front>
<front id="utf_mapperH-63">  //         ' '                               "                ?    ?        ?</front>
<front id="utf_mapperH-64">             0xb0,0xb1,0xb2,0xb3,0x27,0xb5,0xb6,0xb7,0x2c,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,  // c2b </front>
<front id="utf_mapperH-65">  //                          ?                ,                            </front>
<front id="utf_mapperH-66">             0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,  // c38 </front>
<front id="utf_mapperH-67">  //                                                                      </front>
<front id="utf_mapperH-68">             0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,  // c39 </front>
<front id="utf_mapperH-69">  //                                                                      </front>
<front id="utf_mapperH-70">             0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,  // c3a  </front>
<front id="utf_mapperH-71">  //                                                                      </front>
<front id="utf_mapperH-72">             0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff   // c3b </front>
<front id="utf_mapperH-73">  //                                                                      </front>
<front id="utf_mapperH-74">           };</front>
<front id="utf_mapperH-75">    #elif ENABLED(MAPPER_D0D1)</front>
<front id="utf_mapperH-76">      #define MAPPER_D0D1_MOD</front>
<front id="utf_mapperH-77">      const PROGMEM uint8_t utf_recode[] =</front>
<front id="utf_mapperH-78">           {//0    1    2    3    4    5    6    7    8    9    a    b    c    d    e    f</front>
<front id="utf_mapperH-79">             0x41,0x80,0x42,0x92,0x81,0x45,0x82,0x83,0x84,0x85,0x4b,0x86,0x4d,0x48,0x4f,0x87,  // d0a</front>
<front id="utf_mapperH-80">  //          A        B            E                    K        M    H    O    </front>
<front id="utf_mapperH-81">             0x50,0x43,0x54,0x88,0xd8,0x58,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x62,0x8f,0xac,0xad,  // d0b</front>
<front id="utf_mapperH-82">  //          P    C    T            X                            b            </front>
<front id="utf_mapperH-83">             0x61,0x36,0x42,0x92,0x81,0x65,0x82,0xb3,0x84,0x85,0x6b,0x86,0x4d,0x48,0x6f,0x87,  // d18</front>
<front id="utf_mapperH-84">  //          a    6    B            e                    k        M    H    o    </front>
<front id="utf_mapperH-85">             0x70,0x63,0x54,0x79,0xd8,0x78,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x62,0x8f,0xac,0xad   // d19</front>
<front id="utf_mapperH-86">  //          p    c    T    y        x                            b            </front>
<front id="utf_mapperH-87">            };</front>
<front id="utf_mapperH-88">    #elif ENABLED(MAPPER_E382E383)</front>
<front id="utf_mapperH-89">      #error( "Katakana on a western display makes no sense. There are no matching symbols." );</front>
<front id="utf_mapperH-90">    #endif</front>
<front id="utf_mapperH-91"></front>
<front id="utf_mapperH-92">  #elif ENABLED(DISPLAY_CHARSET_HD44780_CYRILLIC)</front>
<front id="utf_mapperH-93">    #if ENABLED(MAPPER_D0D1)</front>
<front id="utf_mapperH-94">      #define MAPPER_D0D1_MOD</front>
<front id="utf_mapperH-95">      // it is a Russian alphabet translation</front>
<front id="utf_mapperH-96">      // except 0401 --&gt; 0xa2 = , 0451 --&gt; 0xb5 = </front>
<front id="utf_mapperH-97">      const PROGMEM uint8_t utf_recode[] =</front>
<front id="utf_mapperH-98">             { 0x41,0xa0,0x42,0xa1,0xe0,0x45,0xa3,0xa4,   // unicode U+0400 to U+047f</front>
<front id="utf_mapperH-99">  //            A   -&gt;  B            E              // 0         </front>
<front id="utf_mapperH-100">               0xa5,0xa6,0x4b,0xa7,0x4d,0x48,0x4f,0xa8,   //           </front>
<front id="utf_mapperH-101">  //                    K        M    H    O          // 1         </front>
<front id="utf_mapperH-102">               0x50,0x43,0x54,0xa9,0xaa,0x58,0xe1,0xab,   //           </front>
<front id="utf_mapperH-103">  //            P    C    T            X              // 2         </front>
<front id="utf_mapperH-104">               0xac,0xe2,0xad,0xae,0x62,0xaf,0xb0,0xb1,   //           </front>
<front id="utf_mapperH-105">  //                            b                  // 3         </front>
<front id="utf_mapperH-106">               0x61,0xb2,0xb3,0xb4,0xe3,0x65,0xb6,0xb7,   //           </front>
<front id="utf_mapperH-107">  //            a   -&gt;              e              // 4         </front>
<front id="utf_mapperH-108">               0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0x6f,0xbe,   //           </front>
<front id="utf_mapperH-109">  //                                    o          // 5         </front>
<front id="utf_mapperH-110">               0x70,0x63,0xbf,0x79,0xe4,0x78,0xe5,0xc0,   //           </front>
<front id="utf_mapperH-111">  //            p    c        y        x              // 6         </front>
<front id="utf_mapperH-112">               0xc1,0xe6,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7    //           </front>
<front id="utf_mapperH-113">  //                                              // 7         </front>
<front id="utf_mapperH-114">             };                                           //           </front>
<front id="utf_mapperH-115">    #elif ENABLED(MAPPER_C2C3)</front>
<front id="utf_mapperH-116">      #error( "Western languages on a cyrillic display makes no sense. There are no matching symbols." );</front>
<front id="utf_mapperH-117">    #elif ENABLED(MAPPER_E382E383)</front>
<front id="utf_mapperH-118">      #error( "Katakana on a cyrillic display makes no sense. There are no matching symbols." );</front>
<front id="utf_mapperH-119">    #endif</front>
<front id="utf_mapperH-120">  #else</front>
<front id="utf_mapperH-121">    #error("Something went wrong in the selection of DISPLAY_CHARSET_HD44780's");</front>
<front id="utf_mapperH-122">  #endif // DISPLAY_CHARSET_HD44780_CYRILLIC</front>
<front id="utf_mapperH-123">#endif // SIMULATE_ROMFONT</front>
<front id="utf_mapperH-124"></front>
<front id="utf_mapperH-125">#if ENABLED(MAPPER_NON)</front>
<front id="utf_mapperH-126">  char charset_mapper(char c){</front>
<front id="utf_mapperH-127">    HARDWARE_CHAR_OUT( c );</front>
<front id="utf_mapperH-128">    return 1;</front>
<front id="utf_mapperH-129">  }</front>
<front id="utf_mapperH-130">#elif ENABLED(MAPPER_C2C3)</front>
<front id="utf_mapperH-131">  uint8_t utf_hi_char; // UTF-8 high part</front>
<front id="utf_mapperH-132">  bool seen_c2 = false;</front>
<front id="utf_mapperH-133">  char charset_mapper(char c){</front>
<front id="utf_mapperH-134">    uint8_t d = c;</front>
<front id="utf_mapperH-135">    if ( d &gt;= 0x80 ) { // UTF-8 handling</front>
<front id="utf_mapperH-136">      if ( (d &gt;= 0xc0) && (!seen_c2) ) {</front>
<front id="utf_mapperH-137">        utf_hi_char = d - 0xc2;</front>
<front id="utf_mapperH-138">        seen_c2 = true;</front>
<front id="utf_mapperH-139">        return 0;</front>
<front id="utf_mapperH-140">      }</front>
<front id="utf_mapperH-141">      else if (seen_c2){</front>
<front id="utf_mapperH-142">        d &= 0x3f;</front>
<front id="utf_mapperH-143">        #ifndef MAPPER_ONE_TO_ONE</front>
<front id="utf_mapperH-144">          HARDWARE_CHAR_OUT( (char) pgm_read_byte_near( utf_recode + d + ( utf_hi_char &lt;&lt; 6 ) - 0x20 ) );</front>
<front id="utf_mapperH-145">        #else</front>
<front id="utf_mapperH-146">          HARDWARE_CHAR_OUT( (char) (0x80 + ( utf_hi_char &lt;&lt; 6 ) + d) ) ;</front>
<front id="utf_mapperH-147">        #endif</front>
<front id="utf_mapperH-148">      }</front>
<front id="utf_mapperH-149">      else {</front>
<front id="utf_mapperH-150">          HARDWARE_CHAR_OUT('?');</front>
<front id="utf_mapperH-151">      }</front>
<front id="utf_mapperH-152">    }</front>
<front id="utf_mapperH-153">    else {</front>
<front id="utf_mapperH-154">      HARDWARE_CHAR_OUT((char) c );</front>
<front id="utf_mapperH-155">    }</front>
<front id="utf_mapperH-156">    seen_c2 = false;</front>
<front id="utf_mapperH-157">    return 1;</front>
<front id="utf_mapperH-158">  }</front>
<front id="utf_mapperH-159">#elif ENABLED(MAPPER_D0D1_MOD)</front>
<front id="utf_mapperH-160">  uint8_t utf_hi_char; // UTF-8 high part</front>
<front id="utf_mapperH-161">  bool seen_d5 = false;</front>
<front id="utf_mapperH-162">  char charset_mapper(char c){</front>
<front id="utf_mapperH-163">    // it is a Russian alphabet translation</front>
<front id="utf_mapperH-164">    // except 0401 --&gt; 0xa2 = , 0451 --&gt; 0xb5 = </front>
<front id="utf_mapperH-165">    uint8_t d = c;</front>
<front id="utf_mapperH-166">    if ( d &gt;= 0x80 ) { // UTF-8 handling</front>
<front id="utf_mapperH-167">      if ((d &gt;= 0xd0) && (!seen_d5)) {</front>
<front id="utf_mapperH-168">        utf_hi_char = d - 0xd0;</front>
<front id="utf_mapperH-169">        seen_d5 = true;</front>
<front id="utf_mapperH-170">        return 0;</front>
<front id="utf_mapperH-171">      } else if (seen_d5) {</front>
<front id="utf_mapperH-172">          d &= 0x3f;</front>
<front id="utf_mapperH-173">          if ( !utf_hi_char && ( d == 1 )) {</front>
<front id="utf_mapperH-174">            HARDWARE_CHAR_OUT((char) 0xa2 ); // </front>
<front id="utf_mapperH-175">        } else if ((utf_hi_char == 1) && (d == 0x11)) {</front>
<front id="utf_mapperH-176">            HARDWARE_CHAR_OUT((char) 0xb5 ); // </front>
<front id="utf_mapperH-177">          } else {</front>
<front id="utf_mapperH-178">            HARDWARE_CHAR_OUT((char) pgm_read_byte_near( utf_recode + d + ( utf_hi_char &lt;&lt; 6 ) - 0x10 ) );</front>
<front id="utf_mapperH-179">          }</front>
<front id="utf_mapperH-180">        }</front>
<front id="utf_mapperH-181">        else {</front>
<front id="utf_mapperH-182">          HARDWARE_CHAR_OUT('?');</front>
<front id="utf_mapperH-183">        }</front>
<front id="utf_mapperH-184">    } else {</front>
<front id="utf_mapperH-185">      HARDWARE_CHAR_OUT((char) c );</front>
<front id="utf_mapperH-186">    }</front>
<front id="utf_mapperH-187">    seen_d5 = false;</front>
<front id="utf_mapperH-188">    return 1;</front>
<front id="utf_mapperH-189">  }</front>
<front id="utf_mapperH-190">#elif ENABLED(MAPPER_D0D1)</front>
<front id="utf_mapperH-191">  uint8_t utf_hi_char; // UTF-8 high part</front>
<front id="utf_mapperH-192">  bool seen_d5 = false;</front>
<front id="utf_mapperH-193">  char charset_mapper(char c){</front>
<front id="utf_mapperH-194">    uint8_t d = c;</front>
<front id="utf_mapperH-195">    if ( d &gt;= 0x80u ) { // UTF-8 handling</front>
<front id="utf_mapperH-196">      if ((d &gt;= 0xd0u) && (!seen_d5)) {</front>
<front id="utf_mapperH-197">        utf_hi_char = d - 0xd0u;</front>
<front id="utf_mapperH-198">        seen_d5 = true;</front>
<front id="utf_mapperH-199">        return 0;</front>
<front id="utf_mapperH-200">      } else if (seen_d5) {</front>
<front id="utf_mapperH-201">          d &= 0x3fu;</front>
<front id="utf_mapperH-202">        #ifndef MAPPER_ONE_TO_ONE</front>
<front id="utf_mapperH-203">          HARDWARE_CHAR_OUT( (char) pgm_read_byte_near( utf_recode + d + ( utf_hi_char &lt;&lt; 6 ) - 0x20 ) );</front>
<front id="utf_mapperH-204">        #else</front>
<front id="utf_mapperH-205">          HARDWARE_CHAR_OUT( (char) (0xa0u + ( utf_hi_char &lt;&lt; 6 ) + d ) ) ;</front>
<front id="utf_mapperH-206">        #endif</front>
<front id="utf_mapperH-207">      } else {</front>
<front id="utf_mapperH-208">        HARDWARE_CHAR_OUT('?');</front>
<front id="utf_mapperH-209">      }</front>
<front id="utf_mapperH-210">    } else {</front>
<front id="utf_mapperH-211">      HARDWARE_CHAR_OUT((char) c );</front>
<front id="utf_mapperH-212">    }</front>
<front id="utf_mapperH-213">    seen_d5 = false;</front>
<front id="utf_mapperH-214">    return 1;</front>
<front id="utf_mapperH-215">  }</front>
<front id="utf_mapperH-216">#elif ENABLED(MAPPER_E382E383)</front>
<front id="utf_mapperH-217">  uint8_t utf_hi_char; // UTF-8 high part</front>
<front id="utf_mapperH-218">  bool seen_e3 = false;</front>
<front id="utf_mapperH-219">  bool seen_82_83 = false;</front>
<front id="utf_mapperH-220">  char charset_mapper(char c){</front>
<front id="utf_mapperH-221">  uint8_t d = c;</front>
<front id="utf_mapperH-222">    if ( d &gt;= 0x80 ) { // UTF-8 handling</front>
<front id="utf_mapperH-223">      if ( (d == 0xe3) && (seen_e3 == false)) {</front>
<front id="utf_mapperH-224">        seen_e3 = true;</front>
<front id="utf_mapperH-225">        return 0;      // eat 0xe3</front>
<front id="utf_mapperH-226">      } else if ( (d &gt;= 0x82) && (seen_e3 == true) && (seen_82_83 == false)) {</front>
<front id="utf_mapperH-227">        utf_hi_char = d - 0x82;</front>
<front id="utf_mapperH-228">        seen_82_83 = true;</front>
<front id="utf_mapperH-229">        return 0;</front>
<front id="utf_mapperH-230">      } else if ((seen_e3 == true) && (seen_82_83 == true)){</front>
<front id="utf_mapperH-231">        d &= 0x3f;</front>
<front id="utf_mapperH-232">        #ifndef MAPPER_ONE_TO_ONE</front>
<front id="utf_mapperH-233">          HARDWARE_CHAR_OUT( (char) pgm_read_byte_near( utf_recode + d + ( utf_hi_char &lt;&lt; 6 ) - 0x20 ) );</front>
<front id="utf_mapperH-234">        #else</front>
<front id="utf_mapperH-235">          HARDWARE_CHAR_OUT( (char) (0x80 + ( utf_hi_char &lt;&lt; 6 ) + d ) ) ;</front>
<front id="utf_mapperH-236">        #endif</front>
<front id="utf_mapperH-237">      } else {</front>
<front id="utf_mapperH-238">        HARDWARE_CHAR_OUT((char) '?' );</front>
<front id="utf_mapperH-239">      }</front>
<front id="utf_mapperH-240">    } else {</front>
<front id="utf_mapperH-241">      HARDWARE_CHAR_OUT((char) c );</front>
<front id="utf_mapperH-242">    }</front>
<front id="utf_mapperH-243">    seen_e3 = false;</front>
<front id="utf_mapperH-244">    seen_82_83 = false;</front>
<front id="utf_mapperH-245">    return 1;</front>
<front id="utf_mapperH-246">  }</front>
<front id="utf_mapperH-247">#else</front>
<front id="utf_mapperH-248">  #error "You have to define one of the DISPLAY_INPUT_CODE_MAPPERs in your language_xx.h file" // should not occur because (en) will set.</front>
<front id="utf_mapperH-249">#endif // code mappers</front>
<front id="utf_mapperH-250"></front>
<front id="utf_mapperH-251">#endif // UTF_MAPPER_H</front>
 </pre>
<h1 id="vector_3CPPtitle" >vector_3.cpp</h1>
<pre id="vector_3CPP"  class="prettyprint linenums"><front id="vector_3CPP-1">/*</front>
<front id="vector_3CPP-2">  vector_3.cpp - Vector library for bed leveling</front>
<front id="vector_3CPP-3">  Copyright (c) 2012 Lars Brubaker.  All right reserved.</front>
<front id="vector_3CPP-4"></front>
<front id="vector_3CPP-5">  This library is free software; you can redistribute it and/or</front>
<front id="vector_3CPP-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="vector_3CPP-7">  License as published by the Free Software Foundation; either</front>
<front id="vector_3CPP-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="vector_3CPP-9"></front>
<front id="vector_3CPP-10">  This library is distributed in the hope that it will be useful,</front>
<front id="vector_3CPP-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="vector_3CPP-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="vector_3CPP-13">  Lesser General Public License for more details.</front>
<front id="vector_3CPP-14"></front>
<front id="vector_3CPP-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="vector_3CPP-16">  License along with this library; if not, write to the Free Software</front>
<front id="vector_3CPP-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="vector_3CPP-18">*/</front>
<front id="vector_3CPP-19">#include &lt;math.h&gt;</front>
<front id="vector_3CPP-20">#include "Marlin.h"</front>
<front id="vector_3CPP-21"></front>
<front id="vector_3CPP-22">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="vector_3CPP-23">#include "vector_3.h"</front>
<front id="vector_3CPP-24"></front>
<front id="vector_3CPP-25">vector_3::vector_3() : x(0), y(0), z(0) { }</front>
<front id="vector_3CPP-26"></front>
<front id="vector_3CPP-27">vector_3::vector_3(float x_, float y_, float z_) : x(x_), y(y_), z(z_) { }</front>
<front id="vector_3CPP-28"></front>
<front id="vector_3CPP-29">vector_3 vector_3::cross(vector_3 left, vector_3 right) {</front>
<front id="vector_3CPP-30">	return vector_3(left.y * right.z - left.z * right.y,</front>
<front id="vector_3CPP-31">		left.z * right.x - left.x * right.z,</front>
<front id="vector_3CPP-32">		left.x * right.y - left.y * right.x);</front>
<front id="vector_3CPP-33">}</front>
<front id="vector_3CPP-34"></front>
<front id="vector_3CPP-35">vector_3 vector_3::operator+(vector_3 v) { return vector_3((x + v.x), (y + v.y), (z + v.z)); }</front>
<front id="vector_3CPP-36">vector_3 vector_3::operator-(vector_3 v) { return vector_3((x - v.x), (y - v.y), (z - v.z)); }</front>
<front id="vector_3CPP-37"></front>
<front id="vector_3CPP-38">vector_3 vector_3::get_normal() {</front>
<front id="vector_3CPP-39">	vector_3 normalized = vector_3(x, y, z);</front>
<front id="vector_3CPP-40">	normalized.normalize();</front>
<front id="vector_3CPP-41">	return normalized;</front>
<front id="vector_3CPP-42">}</front>
<front id="vector_3CPP-43"></front>
<front id="vector_3CPP-44">float vector_3::get_length() { return sqrt((x * x) + (y * y) + (z * z)); }</front>
<front id="vector_3CPP-45"></front>
<front id="vector_3CPP-46">void vector_3::normalize() {</front>
<front id="vector_3CPP-47">	float length = get_length();</front>
<front id="vector_3CPP-48">	x /= length;</front>
<front id="vector_3CPP-49">	y /= length;</front>
<front id="vector_3CPP-50">	z /= length;</front>
<front id="vector_3CPP-51">}</front>
<front id="vector_3CPP-52"></front>
<front id="vector_3CPP-53">void vector_3::apply_rotation(matrix_3x3 matrix) {</front>
<front id="vector_3CPP-54">	float resultX = x * matrix.matrix[3*0+0] + y * matrix.matrix[3*1+0] + z * matrix.matrix[3*2+0];</front>
<front id="vector_3CPP-55">	float resultY = x * matrix.matrix[3*0+1] + y * matrix.matrix[3*1+1] + z * matrix.matrix[3*2+1];</front>
<front id="vector_3CPP-56">	float resultZ = x * matrix.matrix[3*0+2] + y * matrix.matrix[3*1+2] + z * matrix.matrix[3*2+2];</front>
<front id="vector_3CPP-57">	x = resultX;</front>
<front id="vector_3CPP-58">	y = resultY;</front>
<front id="vector_3CPP-59">	z = resultZ;</front>
<front id="vector_3CPP-60">}</front>
<front id="vector_3CPP-61"></front>
<front id="vector_3CPP-62">void vector_3::debug(const char title[]) {</front>
<front id="vector_3CPP-63">	SERIAL_PROTOCOL(title);</front>
<front id="vector_3CPP-64">	SERIAL_PROTOCOLPGM(" x: ");</front>
<front id="vector_3CPP-65">	SERIAL_PROTOCOL_F(x, 6);</front>
<front id="vector_3CPP-66">	SERIAL_PROTOCOLPGM(" y: ");</front>
<front id="vector_3CPP-67">	SERIAL_PROTOCOL_F(y, 6);</front>
<front id="vector_3CPP-68">	SERIAL_PROTOCOLPGM(" z: ");</front>
<front id="vector_3CPP-69">	SERIAL_PROTOCOL_F(z, 6);</front>
<front id="vector_3CPP-70">	SERIAL_EOL;</front>
<front id="vector_3CPP-71">}</front>
<front id="vector_3CPP-72"></front>
<front id="vector_3CPP-73">void apply_rotation_xyz(matrix_3x3 matrix, float &x, float& y, float& z) {</front>
<front id="vector_3CPP-74">	vector_3 vector = vector_3(x, y, z);</front>
<front id="vector_3CPP-75">	vector.apply_rotation(matrix);</front>
<front id="vector_3CPP-76">	x = vector.x;</front>
<front id="vector_3CPP-77">	y = vector.y;</front>
<front id="vector_3CPP-78">	z = vector.z;</front>
<front id="vector_3CPP-79">}</front>
<front id="vector_3CPP-80"></front>
<front id="vector_3CPP-81">matrix_3x3 matrix_3x3::create_from_rows(vector_3 row_0, vector_3 row_1, vector_3 row_2) {</front>
<front id="vector_3CPP-82">  //row_0.debug("row_0");</front>
<front id="vector_3CPP-83">  //row_1.debug("row_1");</front>
<front id="vector_3CPP-84">  //row_2.debug("row_2");</front>
<front id="vector_3CPP-85">	matrix_3x3 new_matrix;</front>
<front id="vector_3CPP-86">	new_matrix.matrix[0] = row_0.x; new_matrix.matrix[1] = row_0.y; new_matrix.matrix[2] = row_0.z; </front>
<front id="vector_3CPP-87">	new_matrix.matrix[3] = row_1.x; new_matrix.matrix[4] = row_1.y; new_matrix.matrix[5] = row_1.z; </front>
<front id="vector_3CPP-88">	new_matrix.matrix[6] = row_2.x; new_matrix.matrix[7] = row_2.y; new_matrix.matrix[8] = row_2.z; </front>
<front id="vector_3CPP-89">  //new_matrix.debug("new_matrix");</front>
<front id="vector_3CPP-90">	return new_matrix;</front>
<front id="vector_3CPP-91">}</front>
<front id="vector_3CPP-92"></front>
<front id="vector_3CPP-93">void matrix_3x3::set_to_identity() {</front>
<front id="vector_3CPP-94">	matrix[0] = 1; matrix[1] = 0; matrix[2] = 0;</front>
<front id="vector_3CPP-95">	matrix[3] = 0; matrix[4] = 1; matrix[5] = 0;</front>
<front id="vector_3CPP-96">	matrix[6] = 0; matrix[7] = 0; matrix[8] = 1;</front>
<front id="vector_3CPP-97">}</front>
<front id="vector_3CPP-98"></front>
<front id="vector_3CPP-99">matrix_3x3 matrix_3x3::create_look_at(vector_3 target) {</front>
<front id="vector_3CPP-100">  vector_3 z_row = target.get_normal();</front>
<front id="vector_3CPP-101">  vector_3 x_row = vector_3(1, 0, -target.x/target.z).get_normal();</front>
<front id="vector_3CPP-102">  vector_3 y_row = vector_3::cross(z_row, x_row).get_normal();</front>
<front id="vector_3CPP-103"></front>
<front id="vector_3CPP-104">  // x_row.debug("x_row");</front>
<front id="vector_3CPP-105">  // y_row.debug("y_row");</front>
<front id="vector_3CPP-106">  // z_row.debug("z_row");</front>
<front id="vector_3CPP-107"></front>
<front id="vector_3CPP-108">  // create the matrix already correctly transposed</front>
<front id="vector_3CPP-109">  matrix_3x3 rot = matrix_3x3::create_from_rows(x_row, y_row, z_row);</front>
<front id="vector_3CPP-110"></front>
<front id="vector_3CPP-111">  // rot.debug("rot");</front>
<front id="vector_3CPP-112">  return rot;</front>
<front id="vector_3CPP-113">}</front>
<front id="vector_3CPP-114"></front>
<front id="vector_3CPP-115">matrix_3x3 matrix_3x3::transpose(matrix_3x3 original) {</front>
<front id="vector_3CPP-116">  matrix_3x3 new_matrix;</front>
<front id="vector_3CPP-117">  new_matrix.matrix[0] = original.matrix[0]; new_matrix.matrix[1] = original.matrix[3]; new_matrix.matrix[2] = original.matrix[6]; </front>
<front id="vector_3CPP-118">  new_matrix.matrix[3] = original.matrix[1]; new_matrix.matrix[4] = original.matrix[4]; new_matrix.matrix[5] = original.matrix[7]; </front>
<front id="vector_3CPP-119">  new_matrix.matrix[6] = original.matrix[2]; new_matrix.matrix[7] = original.matrix[5]; new_matrix.matrix[8] = original.matrix[8];</front>
<front id="vector_3CPP-120">  return new_matrix;</front>
<front id="vector_3CPP-121">}</front>
<front id="vector_3CPP-122"></front>
<front id="vector_3CPP-123">void matrix_3x3::debug(const char title[]) {</front>
<front id="vector_3CPP-124">  SERIAL_PROTOCOLLN(title);</front>
<front id="vector_3CPP-125">  int count = 0;</front>
<front id="vector_3CPP-126">  for(int i=0; i&lt;3; i++) {</front>
<front id="vector_3CPP-127">    for(int j=0; j&lt;3; j++) {</front>
<front id="vector_3CPP-128">      if (matrix[count] &gt;= 0.0) SERIAL_PROTOCOLCHAR('+');</front>
<front id="vector_3CPP-129">      SERIAL_PROTOCOL_F(matrix[count], 6);</front>
<front id="vector_3CPP-130">      SERIAL_PROTOCOLCHAR(' ');</front>
<front id="vector_3CPP-131">      count++;</front>
<front id="vector_3CPP-132">    }</front>
<front id="vector_3CPP-133">    SERIAL_EOL;</front>
<front id="vector_3CPP-134">  }</front>
<front id="vector_3CPP-135">}</front>
<front id="vector_3CPP-136"></front>
<front id="vector_3CPP-137">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="vector_3CPP-138"></front>
 </pre>
<h1 id="vector_3Htitle" >vector_3.h</h1>
<pre id="vector_3H"  class="prettyprint linenums"><front id="vector_3H-1">/*</front>
<front id="vector_3H-2">  vector_3.cpp - Vector library for bed leveling</front>
<front id="vector_3H-3">  Copyright (c) 2012 Lars Brubaker.  All right reserved.</front>
<front id="vector_3H-4"></front>
<front id="vector_3H-5">  This library is free software; you can redistribute it and/or</front>
<front id="vector_3H-6">  modify it under the terms of the GNU Lesser General Public</front>
<front id="vector_3H-7">  License as published by the Free Software Foundation; either</front>
<front id="vector_3H-8">  version 2.1 of the License, or (at your option) any later version.</front>
<front id="vector_3H-9"></front>
<front id="vector_3H-10">  This library is distributed in the hope that it will be useful,</front>
<front id="vector_3H-11">  but WITHOUT ANY WARRANTY; without even the implied warranty of</front>
<front id="vector_3H-12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</front>
<front id="vector_3H-13">  Lesser General Public License for more details.</front>
<front id="vector_3H-14"></front>
<front id="vector_3H-15">  You should have received a copy of the GNU Lesser General Public</front>
<front id="vector_3H-16">  License along with this library; if not, write to the Free Software</front>
<front id="vector_3H-17">  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</front>
<front id="vector_3H-18">*/</front>
<front id="vector_3H-19">#ifndef VECTOR_3_H</front>
<front id="vector_3H-20">#define VECTOR_3_H</front>
<front id="vector_3H-21"></front>
<front id="vector_3H-22">#if ENABLED(AUTO_BED_LEVELING_FEATURE)</front>
<front id="vector_3H-23">class matrix_3x3;</front>
<front id="vector_3H-24"></front>
<front id="vector_3H-25">struct vector_3</front>
<front id="vector_3H-26">{</front>
<front id="vector_3H-27">	float x, y, z;</front>
<front id="vector_3H-28"></front>
<front id="vector_3H-29">        vector_3();</front>
<front id="vector_3H-30">	vector_3(float x, float y, float z);</front>
<front id="vector_3H-31"></front>
<front id="vector_3H-32">	static vector_3 cross(vector_3 a, vector_3 b);</front>
<front id="vector_3H-33"></front>
<front id="vector_3H-34">	vector_3 operator+(vector_3 v);</front>
<front id="vector_3H-35">	vector_3 operator-(vector_3 v);</front>
<front id="vector_3H-36">	void normalize();</front>
<front id="vector_3H-37">	float get_length();</front>
<front id="vector_3H-38">	vector_3 get_normal();</front>
<front id="vector_3H-39"></front>
<front id="vector_3H-40">	void debug(const char title[]);</front>
<front id="vector_3H-41">	</front>
<front id="vector_3H-42">	void apply_rotation(matrix_3x3 matrix);</front>
<front id="vector_3H-43">};</front>
<front id="vector_3H-44"></front>
<front id="vector_3H-45">struct matrix_3x3</front>
<front id="vector_3H-46">{</front>
<front id="vector_3H-47">	float matrix[9];</front>
<front id="vector_3H-48"></front>
<front id="vector_3H-49">	static matrix_3x3 create_from_rows(vector_3 row_0, vector_3 row_1, vector_3 row_2);</front>
<front id="vector_3H-50">	static matrix_3x3 create_look_at(vector_3 target);</front>
<front id="vector_3H-51">	static matrix_3x3 transpose(matrix_3x3 original);</front>
<front id="vector_3H-52"></front>
<front id="vector_3H-53">	void set_to_identity();</front>
<front id="vector_3H-54"></front>
<front id="vector_3H-55">	void debug(const char title[]);</front>
<front id="vector_3H-56">};</front>
<front id="vector_3H-57"></front>
<front id="vector_3H-58"></front>
<front id="vector_3H-59">void apply_rotation_xyz(matrix_3x3 rotationMatrix, float &x, float& y, float& z);</front>
<front id="vector_3H-60">#endif // AUTO_BED_LEVELING_FEATURE</front>
<front id="vector_3H-61"></front>
<front id="vector_3H-62">#endif // VECTOR_3_H</front>
 </pre>
<h1 id="watchdogCPPtitle" >watchdog.cpp</h1>
<pre id="watchdogCPP"  class="prettyprint linenums"><front id="watchdogCPP-1">#include "Marlin.h"</front>
<front id="watchdogCPP-2"></front>
<front id="watchdogCPP-3">#if ENABLED(USE_WATCHDOG)</front>
<front id="watchdogCPP-4">#include &lt;avr/wdt.h&gt;</front>
<front id="watchdogCPP-5"></front>
<front id="watchdogCPP-6">#include "watchdog.h"</front>
<front id="watchdogCPP-7">#include "ultralcd.h"</front>
<front id="watchdogCPP-8"></front>
<front id="watchdogCPP-9">//===========================================================================</front>
<front id="watchdogCPP-10">//============================ private variables ============================</front>
<front id="watchdogCPP-11">//===========================================================================</front>
<front id="watchdogCPP-12"></front>
<front id="watchdogCPP-13">//===========================================================================</front>
<front id="watchdogCPP-14">//================================ functions ================================</front>
<front id="watchdogCPP-15">//===========================================================================</front>
<front id="watchdogCPP-16"></front>
<front id="watchdogCPP-17"></front>
<front id="watchdogCPP-18">/// intialise watch dog with a 4 sec interrupt time</front>
<front id="watchdogCPP-19">void watchdog_init()</front>
<front id="watchdogCPP-20">{</front>
<front id="watchdogCPP-21">  #if ENABLED(WATCHDOG_RESET_MANUAL)</front>
<front id="watchdogCPP-22">    //We enable the watchdog timer, but only for the interrupt.</front>
<front id="watchdogCPP-23">    //Take care, as this requires the correct order of operation, with interrupts disabled. See the datasheet of any AVR chip for details.</front>
<front id="watchdogCPP-24">    wdt_reset();</front>
<front id="watchdogCPP-25">    _WD_CONTROL_REG = _BV(_WD_CHANGE_BIT) | _BV(WDE);</front>
<front id="watchdogCPP-26">    _WD_CONTROL_REG = _BV(WDIE) | WDTO_4S;</front>
<front id="watchdogCPP-27">  #else</front>
<front id="watchdogCPP-28">    wdt_enable(WDTO_4S);</front>
<front id="watchdogCPP-29">  #endif</front>
<front id="watchdogCPP-30">}</front>
<front id="watchdogCPP-31"></front>
<front id="watchdogCPP-32">/// reset watchdog. MUST be called every 1s after init or avr will reset.</front>
<front id="watchdogCPP-33">void watchdog_reset() </front>
<front id="watchdogCPP-34">{</front>
<front id="watchdogCPP-35">    wdt_reset();</front>
<front id="watchdogCPP-36">}</front>
<front id="watchdogCPP-37"></front>
<front id="watchdogCPP-38">//===========================================================================</front>
<front id="watchdogCPP-39">//=================================== ISR ===================================</front>
<front id="watchdogCPP-40">//===========================================================================</front>
<front id="watchdogCPP-41"></front>
<front id="watchdogCPP-42">//Watchdog timer interrupt, called if main program blocks &gt;1sec and manual reset is enabled.</front>
<front id="watchdogCPP-43">#if ENABLED(WATCHDOG_RESET_MANUAL)</front>
<front id="watchdogCPP-44">ISR(WDT_vect)</front>
<front id="watchdogCPP-45">{ </front>
<front id="watchdogCPP-46">    SERIAL_ERROR_START;</front>
<front id="watchdogCPP-47">    SERIAL_ERRORLNPGM("Something is wrong, please turn off the printer.");</front>
<front id="watchdogCPP-48">    kill(PSTR("ERR:Please Reset")); //kill blocks //16 characters so it fits on a 16x2 display</front>
<front id="watchdogCPP-49">    while(1); //wait for user or serial reset</front>
<front id="watchdogCPP-50">}</front>
<front id="watchdogCPP-51">#endif//RESET_MANUAL</front>
<front id="watchdogCPP-52"></front>
<front id="watchdogCPP-53">#endif//USE_WATCHDOG</front>
 </pre>
<h1 id="watchdogHtitle" >watchdog.h</h1>
<pre id="watchdogH"  class="prettyprint linenums"><front id="watchdogH-1">#ifndef WATCHDOG_H</front>
<front id="watchdogH-2">#define WATCHDOG_H</front>
<front id="watchdogH-3"></front>
<front id="watchdogH-4">#include "Marlin.h"</front>
<front id="watchdogH-5"></front>
<front id="watchdogH-6">#if ENABLED(USE_WATCHDOG)</front>
<front id="watchdogH-7">  // initialize watch dog with a 1 sec interrupt time</front>
<front id="watchdogH-8">  void watchdog_init();</front>
<front id="watchdogH-9">  // pad the dog/reset watchdog. MUST be called at least every second after the first watchdog_init or AVR will go into emergency procedures..</front>
<front id="watchdogH-10">  void watchdog_reset();</front>
<front id="watchdogH-11">#else</front>
<front id="watchdogH-12">  //If we do not have a watchdog, then we can have empty functions which are optimized away.</front>
<front id="watchdogH-13">  FORCE_INLINE void watchdog_init() {};</front>
<front id="watchdogH-14">  FORCE_INLINE void watchdog_reset() {};</front>
<front id="watchdogH-15">#endif</front>
<front id="watchdogH-16"></front>
<front id="watchdogH-17">#endif</front>
 </pre>
<script src="svgDraw.js"></script>
</body>
</html>
