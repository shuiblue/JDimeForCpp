<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="testcpp/Marlin/Marlin_main/2way/1/B.cpp"><comment type="block">/* -*- c++ -*- */</comment>

<comment type="block">/*
    Reprap firmware based on Sprinter and grbl.
 Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/*
 This firmware is a mashup between Sprinter and grbl.
  (https://github.com/kliment/Sprinter)
  (https://github.com/simen/grbl/tree)

 It has preliminary support for Matthew Roberts advance algorithm
    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Marlin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ultralcd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stepper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"temperature.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"motion_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cardreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"watchdog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ConfigurationStore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pins_arduino.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUM_SERVOS</name> &gt; 0</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Servo.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIGIPOTSS_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>DIGIPOTSS_PIN</name> &gt; -1</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;SPI.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_STRING</name></cpp:macro>  <cpp:value>"1.0.0"</cpp:value></cpp:define>

<comment type="line">// look here for descriptions of gcodes: http://linuxcnc.org/handbook/gcode/g-code.html</comment>
<comment type="line">// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes</comment>

<comment type="line">//Implemented Codes</comment>
<comment type="line">//-------------------</comment>
<comment type="line">// G0  -&gt; G1</comment>
<comment type="line">// G1  - Coordinated Movement X Y Z E</comment>
<comment type="line">// G2  - CW ARC</comment>
<comment type="line">// G3  - CCW ARC</comment>
<comment type="line">// G4  - Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</comment>
<comment type="line">// G10 - retract filament according to settings of M207</comment>
<comment type="line">// G11 - retract recover filament according to settings of M208</comment>
<comment type="line">// G28 - Home all Axis</comment>
<comment type="line">// G29 - Calibrate print surface with automatic Z probe</comment>
<comment type="line">// G30 - Bed Probe and Delta geometry Autocalibration</comment>
<comment type="line">// G90 - Use Absolute Coordinates</comment>
<comment type="line">// G91 - Use Relative Coordinates</comment>
<comment type="line">// G92 - Set current position to cordinates given</comment>

<comment type="line">// M Codes</comment>
<comment type="line">// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)</comment>
<comment type="line">// M1   - Same as M0</comment>
<comment type="line">// M17  - Enable/Power all stepper motors</comment>
<comment type="line">// M18  - Disable all stepper motors; same as M84</comment>
<comment type="line">// M20  - List SD card</comment>
<comment type="line">// M21  - Init SD card</comment>
<comment type="line">// M22  - Release SD card</comment>
<comment type="line">// M23  - Select SD file (M23 filename.g)</comment>
<comment type="line">// M24  - Start/resume SD print</comment>
<comment type="line">// M25  - Pause SD print</comment>
<comment type="line">// M26  - Set SD position in bytes (M26 S12345)</comment>
<comment type="line">// M27  - Report SD print status</comment>
<comment type="line">// M28  - Start SD write (M28 filename.g)</comment>
<comment type="line">// M29  - Stop SD write</comment>
<comment type="line">// M30  - Delete file from SD (M30 filename.g)</comment>
<comment type="line">// M31  - Output time since last M109 or SD card start to serial</comment>
<comment type="line">// M32  - Select file and start SD print (Can be used when printing from SD card)</comment>
<comment type="line">// M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.</comment>
<comment type="line">// M80  - Turn on Power Supply</comment>
<comment type="line">// M81  - Turn off Power Supply</comment>
<comment type="line">// M82  - Set E codes absolute (default)</comment>
<comment type="line">// M83  - Set E codes relative while in Absolute Coordinates (G90) mode</comment>
<comment type="line">// M84  - Disable steppers until next move,</comment>
<comment type="line">//        or use S&lt;seconds&gt; to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.</comment>
<comment type="line">// M85  - Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</comment>
<comment type="line">// M92  - Set axis_steps_per_unit - same syntax as G92</comment>
<comment type="line">// M104 - Set extruder target temp</comment>
<comment type="line">// M105 - Read current temp</comment>
<comment type="line">// M106 - Fan on</comment>
<comment type="line">// M107 - Fan off</comment>
<comment type="line">// M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating</comment>
<comment type="line">//        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling</comment>
<comment type="line">// M114 - Output current position to serial port</comment>
<comment type="line">// M115 - Capabilities string</comment>
<comment type="line">// M117 - display message</comment>
<comment type="line">// M119 - Output Endstop status to serial port</comment>
<comment type="line">// M126 - Solenoid Air Valve Open (BariCUDA support by jmil)</comment>
<comment type="line">// M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)</comment>
<comment type="line">// M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)</comment>
<comment type="line">// M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)</comment>
<comment type="line">// M140 - Set bed target temp</comment>
<comment type="line">// M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating</comment>
<comment type="line">//        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</comment>
<comment type="line">// M200 - Set filament diameter</comment>
<comment type="line">// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</comment>
<comment type="line">// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!</comment>
<comment type="line">// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</comment>
<comment type="line">// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) im mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer underruns and M20 minimum feedrate</comment>
<comment type="line">// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk</comment>
<comment type="line">// M206 - set additional homeing offset</comment>
<comment type="line">// M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]</comment>
<comment type="line">// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]</comment>
<comment type="line">// M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</comment>
<comment type="line">// M218 - set hotend offset (in mm): T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</comment>
<comment type="line">// M220 S&lt;factor in percent&gt;- set speed factor override percentage</comment>
<comment type="line">// M221 S&lt;factor in percent&gt;- set extrude factor override percentage</comment>
<comment type="line">// M240 - Trigger a camera to take a photograph</comment>
<comment type="line">// M250 - Set LCD contrast C&lt;contrast value&gt; (value 0..63)</comment>
<comment type="line">// M280 - set servo position absolute. P: servo index, S: angle or microseconds</comment>
<comment type="line">// M300 - Play beepsound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</comment>
<comment type="line">// M301 - Set PID parameters P I and D</comment>
<comment type="line">// M302 - Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</comment>
<comment type="line">// M303 - PID relay autotune S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</comment>
<comment type="line">// M304 - Set bed PID parameters P I and D</comment>
<comment type="line">// M400 - Finish all moves</comment>
<comment type="line">// M500 - stores paramters in EEPROM</comment>
<comment type="line">// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).</comment>
<comment type="line">// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.</comment>
<comment type="line">// M503 - print the current settings (from memory not from eeprom)</comment>
<comment type="line">// M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</comment>
<comment type="line">// M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</comment>
<comment type="line">// M605 - Set dual x-carriage movement mode: S&lt;mode&gt; [ X&lt;duplication x-offset&gt; R&lt;duplication temp offset&gt; ]</comment>
<comment type="line">// M666 - Endstop and delta geometry adjustment</comment>
<comment type="line">// M907 - Set digital trimpot motor current using axis codes.</comment>
<comment type="line">// M908 - Control digital trimpot directly.</comment>
<comment type="line">// M350 - Set microstepping mode.</comment>
<comment type="line">// M351 - Toggle MS1 MS2 pins directly.</comment>
<comment type="line">// M928 - Start SD logging (M928 filename.g) - ended by M29</comment>
<comment type="line">// M999 - Restart after being stopped by error</comment>

<comment type="line">//Stepper Movement Variables</comment>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================imported variables============================</comment>
<comment type="line">//===========================================================================</comment>


<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================public variables=============================</comment>
<comment type="line">//===========================================================================</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
<decl_stmt><decl><type><name>CardReader</name></type> <name>card</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>float</name></type> <name><name>homing_feedrate</name><index>[]</index></name> <init>= <expr><name>HOMING_FEEDRATE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>default_z_probe_offset</name><index>[]</index></name> <init>= <expr><name>Z_PROBE_OFFSET</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>z_probe_offset</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>z_probe_deploy_start_location</name><index>[]</index></name> <init>= <expr><name>Z_PROBE_DEPLOY_START_LOCATION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>z_probe_deploy_end_location</name><index>[]</index></name> <init>= <expr><name>Z_PROBE_DEPLOY_END_LOCATION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>z_probe_retract_start_location</name><index>[]</index></name> <init>= <expr><name>Z_PROBE_RETRACT_START_LOCATION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>z_probe_retract_end_location</name><index>[]</index></name> <init>= <expr><name>Z_PROBE_RETRACT_END_LOCATION</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name><name>axis_relative_modes</name><index>[]</index></name> <init>= <expr><name>AXIS_RELATIVE_MODES</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>feedmultiply</name><init>=<expr>100</expr></init></decl>;</decl_stmt> <comment type="line">//100-&gt;1 200-&gt;2</comment>
<decl_stmt><decl><type><name>int</name></type> <name>saved_feedmultiply</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extrudemultiply</name><init>=<expr>100</expr></init></decl>;</decl_stmt> <comment type="line">//100-&gt;1 200-&gt;2</comment>
<decl_stmt><decl><type><name>float</name></type> <name><name>current_position</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>add_homeing</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name><name>endstop_adj</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>tower_adj</name><index>[<expr>6</expr>]</index></name><init>=<expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_radius</name></decl>;</decl_stmt> <comment type="line">// = DEFAULT_delta_radius;</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_diagonal_rod</name></decl>;</decl_stmt> <comment type="line">// = DEFAULT_DELTA_DIAGONAL_ROD;</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>DELTA_DIAGONAL_ROD_2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>ac_prec</name> <init>= <expr><name>AUTOCALIBRATION_PRECISION</name> / 2</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>bed_radius</name> <init>= <expr><name>BED_DIAMETER</name> / 2</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower1_x</name></decl>, <decl><type ref="prev"/><name>delta_tower1_y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower2_x</name></decl>, <decl><type ref="prev"/><name>delta_tower2_y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower3_x</name></decl>, <decl><type ref="prev"/><name>delta_tower3_y</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>base_max_pos</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr><name>X_MAX_POS</name></expr>, <expr><name>Y_MAX_POS</name></expr>, <expr><name>Z_MAX_POS</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>base_home_pos</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr><name>X_HOME_POS</name></expr>, <expr><name>Y_HOME_POS</name></expr>, <expr><name>Z_HOME_POS</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>max_length</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr><name>X_MAX_LENGTH</name></expr>, <expr><name>Y_MAX_LENGTH</name></expr>, <expr><name>Z_MAX_LENGTH</name></expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>saved_position</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>0.0</expr>,<expr>0.0</expr>,<expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>saved_positions</name><index>[<expr>7</expr>]</index><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
    }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>float</name></type> <name><name>min_pos</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{ <expr><name>X_MIN_POS</name></expr>, <expr><name>Y_MIN_POS</name></expr>, <expr><name>Z_MIN_POS</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>max_pos</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{ <expr><name>X_MAX_POS</name></expr>, <expr><name>Y_MAX_POS</name></expr>, <expr><name>Z_MAX_POS</name></expr> }</block></expr></init></decl>;</decl_stmt>

<comment type="line">// Extruder offset</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifndef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_EXTRUDER_OFFSETS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> <comment type="line">// only in XY plane</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_EXTRUDER_OFFSETS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> <comment type="line">// supports offsets in XYZ plane</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>float</name></type> <name><name>extruder_offset</name><index>[<expr><name>NUM_EXTRUDER_OFFSETS</name></expr>]</index><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_OFFSET_X</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_OFFSET_Y</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><name>EXTRUDER_OFFSET_X</name></expr>, <expr><name>EXTRUDER_OFFSET_Y</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>active_extruder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fanSpeed</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name><name>servo_endstops</name><index>[]</index></name> <init>= <expr><name>SERVO_ENDSTOPS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>servo_endstop_angles</name><index>[]</index></name> <init>= <expr><name>SERVO_ENDSTOP_ANGLES</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>ValvePressure</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>EtoPPressure</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>bool</name></type> <name>autoretract_enabled</name><init>=<expr>true</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>retracted</name><init>=<expr>false</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_length</name><init>=<expr>3</expr></init>, <name>retract_feedrate</name><init>=<expr>17*60</expr></init>, <name>retract_zlift</name><init>=<expr>0.8</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_recover_length</name><init>=<expr>0</expr></init>, <name>retract_recover_feedrate</name><init>=<expr>8*60</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
  <decl_stmt><decl><type><name>bool</name></type> <name>powersupply</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
<decl_stmt><decl><type><name>float</name></type> <name><name>delta</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>delta_tmp</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================private variables=============================</comment>
<comment type="line">//===========================================================================</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>axis_codes</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name> <init>= <expr><block>{<expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>, <expr>'E'</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>SIN_60</name> <init>= <expr>0.8660254037844386</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>COS_60</name> <init>= <expr>0.5</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>destination</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name> <init>= <expr><block>{  <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>offset</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>bed_level</name><index>[<expr>7</expr>]</index><index>[<expr>7</expr>]</index></name> <init>= <expr><block>{
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
  <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>home_all_axis</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>feedrate</name> <init>= <expr>1500.0</expr></init>, <name>next_feedrate</name></decl>, <decl><type ref="prev"/><name>saved_feedrate</name></decl>, <decl><type ref="prev"/><name>z_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>bed_level_x</name></decl>, <decl><type ref="prev"/><name>bed_level_y</name></decl>, <decl><type ref="prev"/><name>bed_level_z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>bed_level_c</name> <init>= <expr>45</expr></init></decl>;</decl_stmt> <comment type="line">//used for inital bed probe safe distance (to avoid crashing into bed)</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>bed_level_ox</name></decl>, <decl><type ref="prev"/><name>bed_level_oy</name></decl>, <decl><type ref="prev"/><name>bed_level_oz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>gcode_N</name></decl>, <decl><type ref="prev"/><name>gcode_LastN</name></decl>, <decl><type ref="prev"/><name>Stopped_gcode_LastN</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>loopcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>relative_mode</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>  <comment type="line">//Determines Absolute or Relative Coordinates</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>cmdbuffer</name><index>[<expr><name>BUFSIZE</name></expr>]</index><index>[<expr><name>MAX_CMD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>fromsd</name><index>[<expr><name>BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufindr</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufindw</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>buflen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<comment type="line">//static int i = 0;</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>serial_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>serial_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>boolean</name></type> <name>comment_mode</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>strchr_pointer</name></decl>;</decl_stmt> <comment type="line">// just a pointer to find chars in the cmd string like X, Y, Z, E, etc</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>sensitive_pins</name><index>[]</index></name> <init>= <expr><name>SENSITIVE_PINS</name></expr></init></decl>;</decl_stmt> <comment type="line">// Sensitive pin list for M42</comment>

<comment type="line">//static float tt = 0;</comment>
<comment type="line">//static float bt = 0;</comment>

<comment type="line">//Inactivity shutdown variables</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>previous_millis_cmd</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>max_inactive_time</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>stepper_inactive_time</name> <init>= <expr><name>DEFAULT_STEPPER_DEACTIVE_TIME</name>*1000l</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>starttime</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>stoptime</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name>tmp_extruder</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>Stopped</name><init>=<expr>false</expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUM_SERVOS</name> &gt; 0</expr></cpp:if>
  <decl_stmt><decl><type><name>Servo</name></type> <name><name>servos</name><index>[<expr><name>NUM_SERVOS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>bool</name></type> <name>CooldownNoWait</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>target_direction</name></decl>;</decl_stmt>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================ROUTINES=============================</comment>
<comment type="line">//===========================================================================</comment>

<function_decl><type><name>void</name></type> <name>get_arc_coordinates</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setTargetedHotend</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>serial_echopair_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_P</name></decl></param>, <param><decl><type><name>float</name></type> <name>v</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>serialprintPGM</name><argument_list>(<argument><expr><name>s_P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<function><type><name>void</name></type> <name>serial_echopair_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_P</name></decl></param>, <param><decl><type><name>double</name></type> <name>v</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>serialprintPGM</name><argument_list>(<argument><expr><name>s_P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<function><type><name>void</name></type> <name>serial_echopair_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_P</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>v</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>serialprintPGM</name><argument_list>(<argument><expr><name>s_P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

<extern>extern "C"<block>{
  <decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name> <name>int</name></type> <name>__bss_end</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name> <name>int</name></type> <name>__heap_start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name> *</type><name>__brkval</name></decl>;</decl_stmt>

  <function><type><name>int</name></type> <name>freeMemory</name><parameter_list>()</parameter_list> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>free_memory</name></decl>;</decl_stmt>

    <if>if<condition>(<expr>(<name>int</name>)<name>__brkval</name> == 0</expr>)</condition><then>
      <expr_stmt><expr><name>free_memory</name> = ((<name>int</name>)&amp;<name>free_memory</name>) - ((<name>int</name>)&amp;<name>__bss_end</name>)</expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>free_memory</name> = ((<name>int</name>)&amp;<name>free_memory</name>) - ((<name>int</name>)<name>__brkval</name>)</expr>;</expr_stmt></else></if>

    <return>return <expr><name>free_memory</name></expr>;</return>
  }</block></function>
}</block></extern>

<comment type="line">//adds an command to the main command buffer</comment>
<comment type="line">//thats really done in a non-safe way.</comment>
<comment type="line">//needs overworking someday</comment>
<function><type><name>void</name></type> <name>enquecommand</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>)</parameter_list>
<block>{
  <if>if<condition>(<expr><name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition><then>
  <block>{
    <comment type="line">//this is dangerous if a mixing of serial and this happsens</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr>&amp;(<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr>0</expr>]</index></name>)</expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr>"enqueing \""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufindw</name>= (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>enquecommand_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>)</parameter_list>
<block>{
  <if>if<condition>(<expr><name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition><then>
  <block>{
    <comment type="line">//this is dangerous if a mixing of serial and this happsens</comment>
    <expr_stmt><expr><call><name>strcpy_P</name><argument_list>(<argument><expr>&amp;(<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr>0</expr>]</index></name>)</expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr>"enqueing \""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufindw</name>= (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>setup_killpin</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>KILL_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>,<argument><expr><name>INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>,<argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>setup_photpin</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PHOTOGRAPH_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>setup_powerhold</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_AWAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>suicide</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>servo_init</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 1) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO0_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>0</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 2) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO1_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>1</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO1_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 3) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO2_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>2</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO2_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 4) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO3_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO3_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>3</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO3_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 5)</expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "TODO: enter initalisation code for more servos"</cpp:error>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Set position of Servo Endstops that are defined</comment>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
  <block>{
    <if>if<condition>(<expr><name><name>servo_endstops</name><index>[<expr><name>i</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>setup</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>setup_killpin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setup_powerhold</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>MYSERIAL</name>.<name>begin</name></name><argument_list>(<argument><expr><name>BAUDRATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>"start"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>

  <comment type="line">// Check startup - does nothing if bootloader sets MCUSR to 0</comment>
  <decl_stmt><decl><type><name>byte</name></type> <name>mcu</name> <init>= <expr><name>MCUSR</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>mcu</name> &amp; 1</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_POWERUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 2</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_EXTERNAL_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 4</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_BROWNOUT_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 8</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_WATCHDOG_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 32</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_SOFTWARE_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>MCUSR</name>=0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_MARLIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>VERSION_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STRING_VERSION_CONFIG_H</name></cpp:ifdef>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STRING_CONFIG_H_AUTHOR</name></cpp:ifdef>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_CONFIGURATION_VER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>STRING_VERSION_CONFIG_H</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_AUTHOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>STRING_CONFIG_H_AUTHOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr>"Compiled: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>__DATE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_FREE_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><call><name>freeMemory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_PLANNER_BUFFER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>(<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>block_t</name></expr></argument>)</argument_list></sizeof>*<name>BLOCK_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>BUFSIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
  <block>{
    <expr_stmt><expr><name><name>fromsd</name><index>[<expr><name>i</name></expr>]</index></name> = false</expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// loads data from EEPROM if available else uses defaults (and resets step acceleration rate)</comment>
  <expr_stmt><expr><call><name>Config_RetrieveSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>tp_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// Initialize temperature loop</comment>
  <expr_stmt><expr><call><name>plan_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Initialize planner;</comment>
  <expr_stmt><expr><call><name>watchdog_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// Initialize stepper, this enables interrupts!</comment>
  <expr_stmt><expr><call><name>setup_photpin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>servo_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>lcd_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// wait 1sec to display the splash screen</comment>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CONTROLLERFAN_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//Set pin used for driver cooling fan</comment>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>void</name></type> <name>loop</name><parameter_list>()</parameter_list>
<block>{
  <if>if<condition>(<expr><name>buflen</name> &lt; (<name>BUFSIZE</name>-1)</expr>)</condition><then>
    <expr_stmt><expr><call><name>get_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>card</name>.<name>checkautostart</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>(<expr><name>buflen</name></expr>)</condition><then>
  <block>{
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
      <if>if<condition>(<expr><name><name>card</name>.<name>saving</name></name></expr>)</condition><then>
      <block>{
        <if>if<condition>(<expr><call><name>strstr_P</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"M29"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name><name>card</name>.<name>write_command</name></name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><name><name>card</name>.<name>logging</name></name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>process_commands</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else
          <block>{
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then>
        <else>else
        <block>{
          <expr_stmt><expr><call><name><name>card</name>.<name>closefile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_FILE_SAVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><call><name>process_commands</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>process_commands</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>
    <expr_stmt><expr><name>buflen</name> = (<name>buflen</name>-1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>bufindr</name> = (<name>bufindr</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">//check heater every n milliseconds</comment>
  <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkHitEndstops</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>get_command</name><parameter_list>()</parameter_list>
<block>{
  <while>while<condition>( <expr><call><name><name>MYSERIAL</name>.<name>available</name></name><argument_list>()</argument_list></call> &gt; 0  &amp;&amp; <name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition> <block>{
    <expr_stmt><expr><name>serial_char</name> = <call><name><name>MYSERIAL</name>.<name>read</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>serial_char</name> == '\n' ||
       <name>serial_char</name> == '\r' ||
       (<name>serial_char</name> == ':' &amp;&amp; <name>comment_mode</name> == false) ||
       <name>serial_count</name> &gt;= (<name>MAX_CMD_SIZE</name> - 1)</expr> )</condition><then>
    <block>{
      <if>if<condition>(<expr>!<name>serial_count</name></expr>)</condition><then> <block>{ <comment type="line">//if empty line</comment>
        <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
        <return>return;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name></expr>]</index></name> = 0</expr>;</expr_stmt> <comment type="line">//terminate string</comment>
      <if>if<condition>(<expr>!<name>comment_mode</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
        <expr_stmt><expr><name><name>fromsd</name><index>[<expr><name>bufindw</name></expr>]</index></name> = false</expr>;</expr_stmt>
        <if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>gcode_N</name> = (<call><name>strtol</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
          <if>if<condition>(<expr><name>gcode_N</name> != <name>gcode_LastN</name>+1 &amp;&amp; (<call><name>strstr_P</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"M110"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NULL</name>)</expr> )</condition><then> <block>{
            <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_LINE_NO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//Serial.println(gcode_N);</comment>
            <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
            <return>return;</return>
          }</block></then></if>

          <if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><name>byte</name></type> <name>checksum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>byte</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>count</name></expr>]</index></name> != '*'</expr>)</condition> <expr_stmt><expr><name>checksum</name> = <name>checksum</name>^<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>count</name>++</expr>]</index></name></expr>;</expr_stmt></while>
            <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if<condition>( <expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name>strtod</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>checksum</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_CHECKSUM_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
              <return>return;</return>
            }</block></then></if>
            <comment type="line">//if no errors, continue parsing</comment>
          }</block></then>
          <else>else
          <block>{
            <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_NO_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
            <return>return;</return>
          }</block></else></if>

          <expr_stmt><expr><name>gcode_LastN</name> = <name>gcode_N</name></expr>;</expr_stmt>
          <comment type="line">//if no errors, continue parsing</comment>
        }</block></then>
        <else>else  <comment type="line">// if we don't receive 'N' but still see '*'</comment>
        <block>{
          <if>if<condition>(<expr>(<call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
            <return>return;</return>
          }</block></then></if>
        }</block></else></if>
        <if>if<condition>(<expr>(<call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>)</condition><then><block>{
          <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><call>(<name>int</name>)<argument_list>(<argument><expr>(<call><name>strtod</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>)</condition><block>{
          <case>case <expr>0</expr>:
          </case><case>case <expr>1</expr>:
          </case><case>case <expr>2</expr>:
          </case><case>case <expr>3</expr>:
            <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{ <comment type="line">// If printer is stopped by an error the G[0-3] codes are ignored.</comment>
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
              <if>if<condition>(<expr><name><name>card</name>.<name>saving</name></name></expr>)</condition><then>
                <break>break;</break></then></if>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
            <else>else <block>{
              <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
            <break>break;</break>
          </case><default>default:
            <break>break;</break>
          </default>}</block></switch>

        }</block></then></if>
        <expr_stmt><expr><name>bufindw</name> = (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt> <comment type="line">//clear buffer</comment>
    }</block></then>
    <else>else
    <block>{
      <if>if<condition>(<expr><name>serial_char</name> == ';'</expr>)</condition><then> <expr_stmt><expr><name>comment_mode</name> = true</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr>!<name>comment_mode</name></expr>)</condition><then> <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name>++</expr>]</index></name> = <name>serial_char</name></expr>;</expr_stmt></then></if>
    }</block></else></if>
  }</block></while>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <if>if<condition>(<expr>!<name><name>card</name>.<name>sdprinting</name></name> || <name>serial_count</name>!=0</expr>)</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <while>while<condition>( <expr>!<call><name><name>card</name>.<name>eof</name></name><argument_list>()</argument_list></call>  &amp;&amp; <name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>int16_t</name></type> <name>n</name><init>=<expr><call><name><name>card</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>serial_char</name> = (<name>char</name>)<name>n</name></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>serial_char</name> == '\n' ||
       <name>serial_char</name> == '\r' ||
       (<name>serial_char</name> == ':' &amp;&amp; <name>comment_mode</name> == false) ||
       <name>serial_count</name> &gt;= (<name>MAX_CMD_SIZE</name> - 1)||<name>n</name>==-1</expr>)</condition><then>
    <block>{
      <if>if<condition>(<expr><call><name><name>card</name>.<name>eof</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_FILE_PRINTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stoptime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>time</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name><init>=<expr>(<name>stoptime</name>-<name>starttime</name>)/1000</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>hours</name></decl>, <decl><type ref="prev"/><name>minutes</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>minutes</name>=(<name>t</name>/60)%60</expr>;</expr_stmt>
        <expr_stmt><expr><name>hours</name>=<name>t</name>/60/60</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf_P</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"%i hours %i minutes"</expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>card</name>.<name>printingHasFinished</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>card</name>.<name>checkautostart</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      }</block></then></if>
      <if>if<condition>(<expr>!<name>serial_count</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
        <return>return;</return> <comment type="line">//if empty line</comment>
      }</block></then></if>
      <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name></expr>]</index></name> = 0</expr>;</expr_stmt> <comment type="line">//terminate string</comment>
<comment type="line">//      if(!comment_mode){</comment>
        <expr_stmt><expr><name><name>fromsd</name><index>[<expr><name>bufindw</name></expr>]</index></name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>bufindw</name> = (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
<comment type="line">//      }</comment>
      <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
      <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt> <comment type="line">//clear buffer</comment>
    }</block></then>
    <else>else
    <block>{
      <if>if<condition>(<expr><name>serial_char</name> == ';'</expr>)</condition><then> <expr_stmt><expr><name>comment_mode</name> = true</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr>!<name>comment_mode</name></expr>)</condition><then> <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name>++</expr>]</index></name> = <name>serial_char</name></expr>;</expr_stmt></then></if>
    }</block></else></if>
  }</block></while>

  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>

}</block></function>


<function><type><name>float</name></type> <name>code_value</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>(<call><name>strtod</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>long</name></type> <name>code_value_long</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>(<call><name>strtol</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name>code_seen</name><parameter_list>(<param><decl><type><name>char</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<name>strchr_pointer</name> != <name>NULL</name>)</expr>;</return>  <comment type="line">//Return True if a character was found</comment>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_PGM_READ_ANY</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>reader</name></type></param>)</parameter_list></cpp:macro>       \
    <cpp:value>static inline type pgm_read_any(const type *p)  \
    { return pgm_read_##reader##_near(p); }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>DEFINE_PGM_READ_ANY</name><argument_list>(<argument><expr><name>float</name></expr></argument>,       <argument><expr><name>float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DEFINE_PGM_READ_ANY</name><argument_list>(<argument>signed char</argument>, <argument>byte</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XYZ_CONSTS_FROM_CONFIG</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>array</name></type></param>, <param><type><name>CONFIG</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static const PROGMEM type array##_P[3] =        \
    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \
static inline type array(int axis)          \
    { return pgm_read_any(&amp;array##_P[axis]); }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>base_min_pos</name></expr></argument>,    <argument><expr><name>MIN_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<comment type="line">//XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,    MAX_POS);</comment>
<comment type="line">//XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,   HOME_POS);</comment>
<comment type="line">//XYZ_CONSTS_FROM_CONFIG(float, max_length,      MAX_LENGTH);</comment>
<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>home_retract_mm</name></expr></argument>, <argument><expr><name>HOME_RETRACT_MM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument>signed char</argument>, <argument>home_dir</argument>,  <argument>HOME_DIR</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> == 1 || <call><name>defined</name><argument_list>(<argument><expr><name>COREXY</name></expr></argument>)</argument_list></call> \
      || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_ENABLE_PIN</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_STEP_PIN</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_DIR_PIN</name></expr></argument>)</argument_list></call> \
      || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_HOME_POS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_MIN_POS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_MAX_POS</name></expr></argument>)</argument_list></call> \
      || !<call><name>defined</name><argument_list>(<argument><expr><name>X_MAX_PIN</name></expr></argument>)</argument_list></call> || <name>X_MAX_PIN</name> &lt; 0</expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "Missing or invalid definitions for DUAL_X_CARRIAGE mode."</cpp:error>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>X_HOME_DIR</name> != -1 || <name>X2_HOME_DIR</name> != 1</expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "Please use canonical x-carriage assignment"</cpp:error> <comment type="line">// the x-carriages are defined by their homing directions</comment>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DXC_FULL_CONTROL_MODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DXC_AUTO_PARK_MODE</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DXC_DUPLICATION_MODE</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dual_x_carriage_mode</name> <init>= <expr><name>DEFAULT_DUAL_X_CARRIAGE_MODE</name></expr></init></decl>;</decl_stmt>
 
<function><type><specifier>static</specifier> <name>float</name></type> <name>x_home_pos</name><parameter_list>(<param><decl><type><name>int</name></type> <name>extruder</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>extruder</name> == 0</expr>)</condition><then>
    <return>return <expr><call><name>base_home_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homeing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</return></then>
  <else>else
    <comment type="line">// In dual carriage mode the extruder offset provides an override of the</comment>
    <comment type="line">// second X-carriage offset when homed - otherwise X2_HOME_POS is used.</comment>
    <comment type="line">// This allow soft recalibration of the second extruder offset position without firmware reflash</comment>
    <comment type="line">// (through the M218 command).</comment>
    <return>return <expr>(<name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name> &gt; 0) ? <name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name> : <name>X2_HOME_POS</name></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>x_home_dir</name><parameter_list>(<param><decl><type><name>int</name></type> <name>extruder</name></decl></param>)</parameter_list> <block>{
  <return>return <expr>(<name>extruder</name> == 0) ? <name>X_HOME_DIR</name> : <name>X2_HOME_DIR</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>inactive_extruder_x_pos</name> <init>= <expr><name>X2_MAX_POS</name></expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 0 &amp; 1</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>active_extruder_parked</name> <init>= <expr>false</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 1 &amp; 2</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>raised_parked_position</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="line">// used in mode 1 </comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>delayed_move_time</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 1 </comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>duplicate_extruder_x_offset</name> <init>= <expr><name>DEFAULT_DUPLICATION_X_OFFSET</name></expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 2</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>duplicate_extruder_temp_offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 2</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>extruder_duplication_enabled</name> <init>= <expr>false</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 2</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//DUAL_X_CARRIAGE    </comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>axis_is_at_home</name><parameter_list>(<param><decl><type><name>int</name></type> <name>axis</name></decl></param>)</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
  <if>if <condition>(<expr><name>axis</name> == <name>X_AXIS</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>active_extruder</name> != 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <name>X2_MIN_POS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <call><name>max</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>X2_MAX_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>active_extruder</name> == 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>base_home_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homeing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <call><name>base_min_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homeing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <call><name>min</name><argument_list>(<argument><expr><name><name>base_max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name><name>add_homeing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, 
                                  <argument><expr><call><name>max</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>X2_MAX_POS</name></expr></argument>)</argument_list></call> - <name>duplicate_extruder_x_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if></else></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = <name><name>base_home_pos</name><index>[<expr><name>axis</name></expr>]</index></name> + <name><name>add_homeing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_min_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homeing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <name><name>base_max_pos</name><index>[<expr><name>axis</name></expr>]</index></name> + <name><name>add_homeing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>homeaxis</name><parameter_list>(<param><decl><type><name>int</name></type> <name>axis</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOMEAXIS_DO</name><parameter_list>(<param><type><name>LETTER</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>((LETTER##_MIN_PIN &gt; -1 &amp;&amp; LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN &gt; -1 &amp;&amp; LETTER##_HOME_DIR==1))</cpp:value></cpp:define>

  <if>if <condition>(<expr><name>axis</name>==<name>X_AXIS</name> ? <call><name>HOMEAXIS_DO</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call> :
      <name>axis</name>==<name>Y_AXIS</name> ? <call><name>HOMEAXIS_DO</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call> :
      <name>axis</name>==<name>Z_AXIS</name> ? <call><name>HOMEAXIS_DO</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call> :
      0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>axis_home_dir</name> <init>= <expr><call><name>home_dir</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>axis</name> == <name>X_AXIS</name></expr>)</condition><then>
      <expr_stmt><expr><name>axis_home_dir</name> = <call><name>x_home_dir</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Engage Servo endstop if enabled</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
      <if>if <condition>(<expr><name><name>SERVO_ENDSTOPS</name><index>[<expr><name>axis</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>axis</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>axis</name> * 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = 1.5 * <name><name>max_length</name><index>[<expr><name>axis</name></expr>]</index></name> * <name>axis_home_dir</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Ignore Z probe while moving away from the top microswitch.</comment>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = -<call><name>home_retract_mm</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> * <name>axis_home_dir</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Stop ignoring Z probe while moving up to the top microswitch again.</comment>

    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = 2*<call><name>home_retract_mm</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> * <name>axis_home_dir</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>axis</name></expr>]</index></name>/10</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>axis</name></expr>]</index></name>/2</expr> ;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
    <comment type="line">// retrace by the amount specified in endstop_adj</comment>
    <if>if <condition>(<expr><name><name>endstop_adj</name><index>[<expr><name>axis</name></expr>]</index></name> * <name>axis_home_dir</name> &lt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Ignore Z probe while moving away from the top microswitch.</comment>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = <name><name>endstop_adj</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Stop ignoring Z probe while moving up to the top microswitch again.</comment>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// Retract Servo endstop if enabled</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
      <if>if <condition>(<expr><name><name>SERVO_ENDSTOPS</name><index>[<expr><name>axis</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>axis</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>axis</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOMEAXIS</name><parameter_list>(<param><type><name>LETTER</name></type></param>)</parameter_list></cpp:macro> <cpp:value>homeaxis(LETTER##_AXIS)</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>set_default_z_probe_offset</name><parameter_list>()</parameter_list>
  <block>{
  <expr_stmt><expr><name><name>z_probe_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>default_z_probe_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z_probe_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>default_z_probe_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>z_probe_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>default_z_probe_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></function>

<function><type><name>void</name></type> <name>set_delta_constants</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> - <name>Z_MIN_POS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>base_max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>  = <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>base_home_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>DELTA_DIAGONAL_ROD_2</name> = <call><name>pow</name><argument_list>(<argument><expr><name>delta_diagonal_rod</name></expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// Effective X/Y positions of the three vertical towers.</comment>
  <comment type="block">/*
  delta_tower1_x = (-SIN_60 * delta_radius) + tower_adj[0]; // front left tower + xa
  delta_tower1_y = (-COS_60 * delta_radius) - tower_adj[0] ;
  delta_tower2_x = -(-SIN_60 * delta_radius) + tower_adj[1]; // front right tower + xb
  delta_tower2_y = (-COS_60 * delta_radius) + tower_adj[1]; // 
  delta_tower3_x = tower_adj[2] ; // back middle tower + xc
  delta_tower3_y = -2 * (-COS_60 * delta_radius);  
  */</comment>
  
  <expr_stmt><expr><name>delta_tower1_x</name> = (<name>delta_radius</name> + <name><name>tower_adj</name><index>[<expr>3</expr>]</index></name>) * <call><name>cos</name><argument_list>(<argument><expr>(210 + <name><name>tower_adj</name><index>[<expr>0</expr>]</index></name>) * <name>PI</name>/180</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// front left tower</comment>
  <expr_stmt><expr><name>delta_tower1_y</name> = (<name>delta_radius</name> + <name><name>tower_adj</name><index>[<expr>3</expr>]</index></name>) * <call><name>sin</name><argument_list>(<argument><expr>(210 + <name><name>tower_adj</name><index>[<expr>0</expr>]</index></name>) * <name>PI</name>/180</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>delta_tower2_x</name> = (<name>delta_radius</name> + <name><name>tower_adj</name><index>[<expr>4</expr>]</index></name>) * <call><name>cos</name><argument_list>(<argument><expr>(330 + <name><name>tower_adj</name><index>[<expr>1</expr>]</index></name>) * <name>PI</name>/180</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// front right tower</comment>
  <expr_stmt><expr><name>delta_tower2_y</name> = (<name>delta_radius</name> + <name><name>tower_adj</name><index>[<expr>4</expr>]</index></name>) * <call><name>sin</name><argument_list>(<argument><expr>(330 + <name><name>tower_adj</name><index>[<expr>1</expr>]</index></name>) * <name>PI</name>/180</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
  <expr_stmt><expr><name>delta_tower3_x</name> = (<name>delta_radius</name> + <name><name>tower_adj</name><index>[<expr>5</expr>]</index></name>) * <call><name>cos</name><argument_list>(<argument><expr>(90 + <name><name>tower_adj</name><index>[<expr>2</expr>]</index></name>) * <name>PI</name>/180</expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// back middle tower</comment>
  <expr_stmt><expr><name>delta_tower3_y</name> = (<name>delta_radius</name> + <name><name>tower_adj</name><index>[<expr>5</expr>]</index></name>) * <call><name>sin</name><argument_list>(<argument><expr>(90 + <name><name>tower_adj</name><index>[<expr>2</expr>]</index></name>) * <name>PI</name>/180</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
}</block></function>

<function><type><name>void</name></type> <name>deploy_z_probe</name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_start_location</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_start_location</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_start_location</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/10</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_end_location</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_end_location</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_end_location</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_start_location</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_start_location</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>z_probe_deploy_start_location</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>retract_z_probe</name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 50</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_start_location</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_start_location</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_start_location</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// Move the nozzle below the print surface to push the probe up.</comment>
  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>/10</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_end_location</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_end_location</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_end_location</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_start_location</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_start_location</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>z_probe_retract_start_location</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>float</name></type> <name>z_probe</name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>start_z</name> <init>= <expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>start_steps</name> <init>= <expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>/10</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = -20</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>stop_steps</name> <init>= <expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  
  <expr_stmt><expr><name><name>saved_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>float</name><argument_list>(<argument><expr>(<call><name>st_get_position</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call>) / <name><name>axis_steps_per_unit</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>saved_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <call><name>float</name><argument_list>(<argument><expr>(<call><name>st_get_position</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call>) / <name><name>axis_steps_per_unit</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>saved_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <call><name>float</name><argument_list>(<argument><expr>(<call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call>) / <name><name>axis_steps_per_unit</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>float</name></type> <name>mm</name> <init>= <expr><name>start_z</name> -
    <call><name>float</name><argument_list>(<argument><expr><name>start_steps</name> - <name>stop_steps</name></expr></argument>)</argument_list></call> / <name><name>axis_steps_per_unit</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>mm</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
        <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>saved_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>float</name><argument_list>(<argument><expr>(<call><name>st_get_position</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call>) / <name><name>axis_steps_per_unit</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>saved_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <call><name>float</name><argument_list>(<argument><expr>(<call><name>st_get_position</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call>) / <name><name>axis_steps_per_unit</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>saved_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <call><name>float</name><argument_list>(<argument><expr>(<call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call>) / <name><name>axis_steps_per_unit</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>mm</name>+2</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move_raw</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>mm</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>calibrate_print_surface</name><parameter_list>(<param><decl><type><name>float</name></type> <name>z_offset</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>float</name></type> <name>probe_bed_z</name></decl>, <decl><type ref="prev"/><name>probe_z</name></decl>, <decl><type ref="prev"/><name>probe_h</name></decl>, <decl><type ref="prev"/><name>probe_l</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>probe_count</name></decl>;</decl_stmt>
      
    <for>for (<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr>3</expr></init></decl>;</init> <condition><expr><name>y</name> &gt;= -3</expr>;</condition> <incr><expr><name>y</name>--</expr></incr>) <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>dir</name> <init>= <expr><name>y</name> % 2 ? -1 : 1</expr></init></decl>;</decl_stmt>
    <for>for (<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr>-3*<name>dir</name></expr></init></decl>;</init> <condition><expr><name>x</name> != 4*<name>dir</name></expr>;</condition> <incr><expr><name>x</name> += <name>dir</name></expr></incr>) <block>{
      <if>if <condition>(<expr><name>x</name>*<name>x</name> + <name>y</name>*<name>y</name> &lt; 11</expr>)</condition><then> <block>{
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>AUTOLEVEL_GRID</name> * <name>x</name> - <name><name>z_probe_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name>AUTOLEVEL_GRID</name> * <name>y</name> - <name><name>z_probe_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>probe_count</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>probe_z</name> = -100</expr>;</expr_stmt>
        <expr_stmt><expr><name>probe_h</name> = -100</expr>;</expr_stmt>
        <expr_stmt><expr><name>probe_l</name> = 100</expr>;</expr_stmt>
        <do>do <block>{
           <expr_stmt><expr><name>probe_bed_z</name> = <name>probe_z</name></expr>;</expr_stmt>
           <expr_stmt><expr><name>probe_z</name> = <call><name>z_probe</name><argument_list>()</argument_list></call> + <name>z_offset</name></expr>;</expr_stmt>
           <if>if <condition>(<expr><name>probe_z</name> &gt; <name>probe_h</name></expr>)</condition><then> <expr_stmt><expr><name>probe_h</name> = <name>probe_z</name></expr>;</expr_stmt></then></if>
           <if>if <condition>(<expr><name>probe_z</name> &lt; <name>probe_l</name></expr>)</condition><then> <expr_stmt><expr><name>probe_l</name> = <name>probe_z</name></expr>;</expr_stmt></then></if>
           <expr_stmt><expr><name>probe_count</name> ++</expr>;</expr_stmt>
           }</block> while <condition>(<expr>(<name>probe_z</name> != <name>probe_bed_z</name>) and (<name>probe_count</name> &lt; 21)</expr>)</condition>;</do>

  <expr_stmt><expr><name><name>bed_level</name><index>[<expr><name>x</name>+3</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name> = <name>probe_bed_z</name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
  <expr_stmt><expr><name><name>bed_level</name><index>[<expr><name>x</name>+3</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name> = 0.0</expr>;</expr_stmt>
      }</block></else></if>
    }</block></for>
    <comment type="line">// For unprobed positions just copy nearest neighbor.</comment>
    <if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> &gt;= 3</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>bed_level</name><index>[<expr>1</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name> = <name><name>bed_level</name><index>[<expr>2</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>bed_level</name><index>[<expr>5</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name> = <name><name>bed_level</name><index>[<expr>4</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> &gt;=2</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>bed_level</name><index>[<expr>0</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name> = <name><name>bed_level</name><index>[<expr>1</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>bed_level</name><index>[<expr>6</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name> = <name><name>bed_level</name><index>[<expr>5</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></then></if>
    <comment type="line">// Print calibration results for manual frame adjustment.</comment>
    <for>for (<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr>-3</expr></init></decl>;</init> <condition><expr><name>x</name> &lt;= 3</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>) <block>{
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name><name>bed_level</name><index>[<expr><name>x</name>+3</expr>]</index><index>[<expr>3-<name>y</name></expr>]</index></name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>float</name></type> <name>probe_bed</name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>)</parameter_list>
  <block>{
  <comment type="line">//Probe bed at specified location and return z height of bed</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>probe_bed_z</name></decl>, <decl><type ref="prev"/><name>probe_z</name></decl>, <decl><type ref="prev"/><name>probe_h</name></decl>, <decl><type ref="prev"/><name>probe_l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>probe_count</name></decl>;</decl_stmt>
<comment type="line">//  feedrate = homing_feedrate[Z_AXIS];</comment>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>x</name> - <name><name>z_probe_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name>y</name> - <name><name>z_probe_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>bed_level_c</name> - <name><name>z_probe_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + 3</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>probe_count</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>probe_z</name> = -100</expr>;</expr_stmt>
  <expr_stmt><expr><name>probe_h</name> = -100</expr>;</expr_stmt>
  <expr_stmt><expr><name>probe_l</name> = 100</expr>;</expr_stmt>
  <do>do <block>{
    <expr_stmt><expr><name>probe_bed_z</name> = <name>probe_z</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>probe_z</name> = <call><name>z_probe</name><argument_list>()</argument_list></call> + <name><name>z_probe_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>probe_z</name> &gt; <name>probe_h</name></expr>)</condition><then> <expr_stmt><expr><name>probe_h</name> = <name>probe_z</name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name>probe_z</name> &lt; <name>probe_l</name></expr>)</condition><then> <expr_stmt><expr><name>probe_l</name> = <name>probe_z</name></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><name>probe_count</name> ++</expr>;</expr_stmt>
    <comment type="line">//SERIAL_PROTOCOL_F(probe_z,3);</comment>
    <comment type="line">//SERIAL_ECHO(" ");</comment>
    }</block> while <condition>(<expr>(<name>probe_z</name> != <name>probe_bed_z</name>) and (<name>probe_count</name> &lt; 21)</expr>)</condition>;</do>
    <comment type="line">//SERIAL_ECHOLN("");</comment>
  <comment type="block">/*
  if (probe_count &gt; 2)
    {
    SERIAL_ECHO("Z-Probe error: ");
    SERIAL_PROTOCOL_F(probe_h - probe_l, 3);
    SERIAL_ECHO("mm in ");
    SERIAL_ECHO(probe_count);
    SERIAL_ECHO(" probes");
    if (probe_count == 20)
      {
      SERIAL_ECHO(" (unable to get 2x consistant probes!)");
      }
    SERIAL_ECHOLN("");
    }
    */</comment>
  <comment type="block">/*
  SERIAL_ECHO("Bed Z-Height at X:");
  SERIAL_ECHO(x);
  SERIAL_ECHO(" Y:");
  SERIAL_ECHO(y);
  SERIAL_ECHO(" = ");
  SERIAL_PROTOCOL_F(probe_bed_z, 4);
  SERIAL_ECHOLN("");      
  */</comment>

  <return>return <expr><name>probe_bed_z</name></expr>;</return>
  }</block></function>

<function><type><name>float</name></type> <name>z_probe_accuracy</name><parameter_list>()</parameter_list>
  <block>{  
  <comment type="line">//Perform z-probe accuracy test</comment>
  <decl_stmt><decl><type><name>float</name></type> <name><name>probe_h</name><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name><name>probe_l</name><index>[<expr>7</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>range_h</name> <init>= <expr>0</expr></init>, <name>range_l</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  
  <for>for(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &lt; 7</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
    <block>{
    <expr_stmt><expr><name><name>probe_h</name><index>[<expr><name>x</name></expr>]</index></name> = -100</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>probe_l</name><index>[<expr><name>x</name></expr>]</index></name> = 100</expr>;</expr_stmt>
    }</block></for>
    
  <comment type="line">// probe test loop  </comment>
  <for>for(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>x</name>&lt;3</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
   <block>{
   <expr_stmt><expr><call><name>bed_probe_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   
   <if>if <condition>(<expr><name>bed_level_c</name> &gt; <name><name>probe_h</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>0</expr>]</index></name> = <name>bed_level_c</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_c</name> &lt; <name><name>probe_l</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>0</expr>]</index></name> = <name>bed_level_c</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_z</name> &gt; <name><name>probe_h</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>1</expr>]</index></name> = <name>bed_level_z</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_z</name> &lt; <name><name>probe_l</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>1</expr>]</index></name> = <name>bed_level_z</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_oy</name> &gt; <name><name>probe_h</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>2</expr>]</index></name> = <name>bed_level_oy</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_oy</name> &lt; <name><name>probe_l</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>2</expr>]</index></name> = <name>bed_level_oy</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_x</name> &gt; <name><name>probe_h</name><index>[<expr>3</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>3</expr>]</index></name> = <name>bed_level_x</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_x</name> &lt; <name><name>probe_l</name><index>[<expr>3</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>3</expr>]</index></name> = <name>bed_level_x</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_oz</name> &gt; <name><name>probe_h</name><index>[<expr>4</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>4</expr>]</index></name> = <name>bed_level_oz</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_oz</name> &lt; <name><name>probe_l</name><index>[<expr>4</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>4</expr>]</index></name> = <name>bed_level_oz</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_y</name> &gt; <name><name>probe_h</name><index>[<expr>5</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>5</expr>]</index></name> = <name>bed_level_y</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_y</name> &lt; <name><name>probe_l</name><index>[<expr>5</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>5</expr>]</index></name> = <name>bed_level_y</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_ox</name> &gt; <name><name>probe_h</name><index>[<expr>6</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_h</name><index>[<expr>6</expr>]</index></name> = <name>bed_level_ox</name></expr>;</expr_stmt></then></if>
   <if>if <condition>(<expr><name>bed_level_ox</name> &lt; <name><name>probe_l</name><index>[<expr>6</expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>probe_l</name><index>[<expr>6</expr>]</index></name> = <name>bed_level_ox</name></expr>;</expr_stmt></then></if>
   }</block></for>
   <for>for(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &lt; 7</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
     <block>{
     <if>if <condition>(<expr><name><name>probe_h</name><index>[<expr><name>x</name></expr>]</index></name> - <name><name>probe_l</name><index>[<expr><name>x</name></expr>]</index></name> &gt; <name>range_h</name></expr>)</condition><then> <expr_stmt><expr><name>range_h</name> = <name><name>probe_h</name><index>[<expr><name>x</name></expr>]</index></name> - <name><name>probe_l</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></then></if>
     <if>if <condition>(<expr><name><name>probe_h</name><index>[<expr><name>x</name></expr>]</index></name> - <name><name>probe_l</name><index>[<expr><name>x</name></expr>]</index></name> &lt; <name>range_l</name></expr>)</condition><then> <expr_stmt><expr><name>range_l</name> = <name><name>probe_h</name><index>[<expr><name>x</name></expr>]</index></name> - <name><name>probe_l</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></then></if>
     }</block></for>
  <return>return <expr><name>range_h</name> - <name>range_l</name></expr>;</return>
  }</block></function>
  
<function><type><name>void</name></type> <name>bed_probe_all</name><parameter_list>()</parameter_list>
  <block>{
  <comment type="line">//Probe all bed positions &amp; store carriage positions</comment>
  <expr_stmt><expr><name>bed_level_c</name> = <call><name>probe_bed</name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>      
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bed_level_z</name> = <call><name>probe_bed</name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr><name>bed_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bed_level_oy</name> = <call><name>probe_bed</name><argument_list>(<argument><expr>-<name>SIN_60</name> * <name>bed_radius</name></expr></argument>, <argument><expr><name>COS_60</name> * <name>bed_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bed_level_x</name> = <call><name>probe_bed</name><argument_list>(<argument><expr>-<name>SIN_60</name> * <name>bed_radius</name></expr></argument>, <argument><expr>-<name>COS_60</name> * <name>bed_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bed_level_oz</name> = <call><name>probe_bed</name><argument_list>(<argument><expr>0.0</expr></argument>, <argument><expr>-<name>bed_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bed_level_y</name> = <call><name>probe_bed</name><argument_list>(<argument><expr><name>SIN_60</name> * <name>bed_radius</name></expr></argument>, <argument><expr>-<name>COS_60</name> * <name>bed_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bed_level_ox</name> = <call><name>probe_bed</name><argument_list>(<argument><expr><name>SIN_60</name> * <name>bed_radius</name></expr></argument>, <argument><expr><name>COS_60</name> * <name>bed_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>save_carriage_positions</name><argument_list>(<argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>    
  }</block></function>
  
<function><type><name>void</name></type> <name>calibration_report</name><parameter_list>()</parameter_list>
  <block>{
  
  <comment type="line">//Display Report</comment>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"\tZ-Tower\t\t\tEndstop Offsets"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_z</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"\t\t\tX:"</expr></argument>,<argument><expr><name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" Y:"</expr></argument>,<argument><expr><name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" Z:"</expr></argument>,<argument><expr><name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_oy</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\t\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_ox</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"\t\tTower Position Adjust"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_c</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"\t\t\tA:"</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" B:"</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" C:"</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_x</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\t\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_y</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"\t\tI:"</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" J:"</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" K:"</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>bed_level_oz</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\t\t\tDelta Radius: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>delta_radius</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"X-Tower\t\tY-Tower\t\tDiag Rod: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>delta_diagonal_rod</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>save_carriage_positions</name><parameter_list>(<param><decl><type><name>int</name></type> <name>position_num</name></decl></param>)</parameter_list> <block>{
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>saved_positions</name><index>[<expr><name>position_num</name></expr>]</index><index>[<expr><name>i</name></expr>]</index></name> = <name><name>saved_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>    
  }</block></for>
}</block></function>

<function><type><name>void</name></type> <name>home_delta_axis</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><name>saved_feedrate</name> = <name>feedrate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saved_feedmultiply</name> = <name>feedmultiply</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedmultiply</name> = 100</expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></for>
    <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>
    <comment type="line">// Move all carriages up together until the first endstop is hit.</comment>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 3 * <name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 3 * <name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 3 * <name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedrate</name> = 1.732 * <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="line">// take care of back off and rehome now we are all at the top</comment>
    <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENDSTOPS_ONLY_FOR_HOMING</name></cpp:ifdef>
       <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
}</block></function>

<function><type><name>void</name></type> <name>process_commands</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>codenum</name></decl>;</decl_stmt> <comment type="line">//throw away variable</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>starpos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'G'</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <switch>switch<condition>(<expr>(<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{
    <case>case <expr>0</expr>: <comment type="line">// G0 -&gt; G1</comment>
    </case><case>case <expr>1</expr>: <comment type="line">// G1</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>get_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// For X Y Z E F</comment>
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
        <return>return;</return>
      }</block></then></if>
      <comment type="line">//break;</comment>
    </case><case>case <expr>2</expr>: <comment type="line">// G2  - CW ARC</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>get_arc_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>prepare_arc_move</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></then></if>
    </case><case>case <expr>3</expr>: <comment type="line">// G3  - CCW ARC</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>get_arc_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>prepare_arc_move</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return;</return>
      }</block></then></if>
    </case><case>case <expr>4</expr>: <comment type="line">// G4 dwell</comment>
      <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_DWELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> = 0</expr>;</expr_stmt>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// milliseconds to wait</comment>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt></then></if> <comment type="line">// seconds to wait</comment>

      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> += <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// keep track of when we started waiting</comment>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call>  &lt; <name>codenum</name></expr> )</condition><block>{
        <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <break>break;</break>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
      </case><case>case <expr>10</expr>: <comment type="line">// G10 retract</comment>
      <if>if<condition>(<expr>!<name>retracted</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+=-<name>retract_zlift</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>-<name>retract_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedrate</name>=<name>retract_feedrate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>retracted</name>=true</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <break>break;</break>
      </case><case>case <expr>11</expr>: <comment type="line">// G10 retract_recover</comment>
      <if>if<condition>(<expr>!<name>retracted</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+=<name>retract_zlift</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=-<name>retract_recover_length</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedrate</name>=<name>retract_recover_feedrate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>retracted</name>=false</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FWRETRACT</comment>
    </case><case>case <expr>28</expr>: <comment type="line">//G28 Home all Axis one at a time</comment>
      <expr_stmt><expr><name>saved_feedrate</name> = <name>feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>saved_feedmultiply</name> = <name>feedmultiply</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedmultiply</name> = 100</expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
          <comment type="line">// A delta can only safely home all axis at the same time</comment>
          <comment type="line">// all axis have to home at the same time</comment>

          <comment type="line">// Move all carriages up together until the first endstop is hit.</comment>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 3 * <name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 3 * <name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 3 * <name><name>max_length</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>feedrate</name> = 1.732 * <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

          <comment type="line">// take care of back off and rehome now we are all at the top</comment>
          <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// NOT DELTA</comment>

      <expr_stmt><expr><name>home_all_axis</name> = !((<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>

      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Z_HOME_DIR</name> &gt; 0</expr></cpp:if>                      <comment type="line">// If homing away from BED do Z first</comment>
      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>QUICK_HOME</name></cpp:ifdef>
      <if>if<condition>(<expr>(<name>home_all_axis</name>)||( <call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr> )</condition><then>  <comment type="line">//first diagonal move</comment>
      <block>{
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt><expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>

       <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifndef>
        <decl_stmt><decl><type><name>int</name></type> <name>x_axis_home_dir</name> <init>= <expr><call><name>home_dir</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>int</name></type> <name>x_axis_home_dir</name> <init>= <expr><call><name>x_home_dir</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
       <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 1.5 * <name><name>max_length</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> * <name>x_axis_home_dir</name></expr>;</expr_stmt><expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 1.5 * <name><name>max_length</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> * <call><name>home_dir</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if<condition>(<expr><name><name>homing_feedrate</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>&lt;<name>feedrate</name></expr>)</condition><then>
          <expr_stmt><expr><name>feedrate</name> =<name><name>homing_feedrate</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
      <block>{
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int</name></type> <name>tmp_extruder</name> <init>= <expr><name>active_extruder</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>active_extruder</name> = !<name>active_extruder</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inactive_extruder_x_pos</name> = <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>active_extruder</name> = <name>tmp_extruder</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// reset state used by the different modes</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>active_extruder_parked</name> = true</expr>;</expr_stmt> 
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>      
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>         
      }</block></then></if>

      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Z_HOME_DIR</name> &lt; 0</expr></cpp:if>                      <comment type="line">// If homing towards BED do Z last</comment>
      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <if>if<condition>(<expr><call><name>code_value_long</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homeing</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>

      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><call><name>code_value_long</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homeing</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>

      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><call><name>code_value_long</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homeing</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// else DELTA</comment>

      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENDSTOPS_ONLY_FOR_HOMING</name></cpp:ifdef>
        <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>29</expr>: <comment type="line">// G29 Calibrate print surface with automatic Z probe.</comment>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
        <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Current bed level array values:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for (<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>y</name> &lt; 7</expr>;</condition> <incr><expr><name>y</name>++</expr></incr>)
          <block>{
          <for>for (<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &lt; 7</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
            <block>{
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name><name>bed_level</name><index>[<expr><name>x</name></expr>]</index><index>[<expr><name>y</name></expr>]</index></name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        <break>break;</break>
        }</block></then></if>
      <expr_stmt><expr><name>saved_feedrate</name> = <name>feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>saved_feedmultiply</name> = <name>feedmultiply</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedmultiply</name> = 100</expr>;</expr_stmt>

      <expr_stmt><expr><call><name>deploy_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>calibrate_print_surface</name><argument_list>(<argument><expr><name><name>z_probe_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> +
  (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call> : 0.0)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>30</expr>: <comment type="line">//G30 Delta AutoCalibration</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>iterations</name></decl>;</decl_stmt>
      
      <comment type="line">//Zero the bed level array</comment>
      <for>for (<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>y</name> &lt; 7</expr>;</condition> <incr><expr><name>y</name>++</expr></incr>)
        <block>{
        <for>for (<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &lt; 7</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
          <block>{
          <expr_stmt><expr><name><name>bed_level</name><index>[<expr><name>x</name></expr>]</index><index>[<expr><name>y</name></expr>]</index></name> = 0.0</expr>;</expr_stmt>
          }</block></for>
      }</block></for>
      
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
        <comment type="line">//Show carriage positions </comment>
        <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Carriage Positions for last scan:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 7</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) 
          <block>{
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"["</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>saved_positions</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>saved_positions</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>saved_positions</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        <break>break;</break>
        }</block></then></if>
       <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call> and <call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then>
          <block>{
          <comment type="line">//Probe specified X,Y point</comment>
          <decl_stmt><decl><type><name>float</name></type> <name>x</name> <init>= <expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call>:0.00</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>float</name></type> <name>y</name> <init>= <expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call>:0.00</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>float</name></type> <name>probe_value</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>deploy_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>probe_value</name> = <call><name>probe_bed</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Bed Z-Height at X:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" Y:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" = "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>probe_value</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Carriage Positions: ["</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>saved_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>saved_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>", "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>saved_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"]"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
          }</block></then></if>
          
       <expr_stmt><expr><name>saved_feedrate</name> = <name>feedrate</name></expr>;</expr_stmt>
       <expr_stmt><expr><name>saved_feedmultiply</name> = <name>feedmultiply</name></expr>;</expr_stmt>
       <expr_stmt><expr><name>feedmultiply</name> = 100</expr>;</expr_stmt>
      
       <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'A'</expr></argument>)</argument_list></call></expr>)</condition><then> 
         <block>{
         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Starting Auto Calibration.."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       
        <comment type="line">//Zero the bedlevel array in case this affects bed probing</comment>
        <for>for (<init><decl><type><name>int</name></type> <name>y</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>y</name> &gt;=6</expr>;</condition> <incr><expr><name>y</name>++</expr></incr>)
          <block>{
          <for>for (<init><decl><type><name>int</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &gt;=6</expr>;</condition> <incr><expr><name>y</name>++</expr></incr>)
            <block>{
            <expr_stmt><expr><name><name>bed_level</name><index>[<expr><name>x</name></expr>]</index><index>[<expr><name>y</name></expr>]</index></name> = 0.0</expr>;</expr_stmt>
            }</block></for>
          }</block></for>
         }</block></then></if>
      
       <expr_stmt><expr><call><name>home_delta_axis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>deploy_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
      
       <comment type="line">//Probe all points</comment>
       <expr_stmt><expr><call><name>bed_probe_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      
       <comment type="line">//Show calibration report      </comment>
       <expr_stmt><expr><call><name>calibration_report</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'A'</expr></argument>)</argument_list></call></expr>)</condition><then> 
         <block>{
         <expr_stmt><expr><name>iterations</name> = 100</expr>;</expr_stmt> <comment type="line">//Maximum number of iterations</comment>
         <decl_stmt><decl><type><name>int</name></type> <name>loopcount</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>adj_r_target</name></decl>, <decl><type ref="prev"/><name>adj_dr_target</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>adj_r_target_delta</name> <init>= <expr>0</expr></init>, <name>adj_dr_target_delta</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>adj_AlphaA</name></decl>, <decl><type ref="prev"/><name>adj_AlphaB</name></decl>, <decl><type ref="prev"/><name>adj_AlphaC</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>adj_RadiusA</name></decl>, <decl><type ref="prev"/><name>adj_RadiusB</name></decl>, <decl><type ref="prev"/><name>adj_RadiusC</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>radiusErrorA</name></decl>, <decl><type ref="prev"/><name>radiusErrorB</name></decl>,<decl><type ref="prev"/><name>radiusErrorC</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>adj_r</name> <init>= <expr>0</expr></init>, <name>adj_dr</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>boolean</name></type> <name>equalAB</name></decl>, <decl><type ref="prev"/><name>equalBC</name></decl>, <decl><type ref="prev"/><name>equalCA</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>boolean</name></type> <name>adj_r_done</name></decl>, <decl><type ref="prev"/><name>adj_dr_done</name></decl>, <decl><type ref="prev"/><name>adj_tower_done</name></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>boolean</name></type> <name>adj_dr_allowed</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>h_endstop</name> <init>= <expr>-100</expr></init>, <name>l_endstop</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>
         <decl_stmt><decl><type><name>float</name></type> <name>probe_error</name></decl>, <decl><type ref="prev"/><name>ftemp</name></decl>;</decl_stmt>
          
         <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> 
           <block>{  
           <expr_stmt><expr><name>delta_diagonal_rod</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><name>adj_dr_allowed</name> = false</expr>;</expr_stmt>
           <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Using diagional rod length: "</expr></argument>, <argument><expr><name>delta_diagonal_rod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"mm (will not be adjusted)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
           }</block></then></if>
         <comment type="line">//Check that endstops are within limits</comment>
         <if>if <condition>(<expr><name>bed_level_x</name> + <name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name> &gt; <name>h_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>h_endstop</name> = <name>bed_level_x</name> + <name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></then></if>
         <if>if <condition>(<expr><name>bed_level_x</name> + <name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name> &lt; <name>l_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>l_endstop</name> = <name>bed_level_x</name> + <name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt></then></if>
         <if>if <condition>(<expr><name>bed_level_y</name> + <name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name> &gt; <name>h_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>h_endstop</name> = <name>bed_level_y</name> + <name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt></then></if>
         <if>if <condition>(<expr><name>bed_level_y</name> + <name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name> &lt; <name>l_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>l_endstop</name> = <name>bed_level_y</name> + <name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt></then></if>
         <if>if <condition>(<expr><name>bed_level_z</name> + <name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name> &gt; <name>h_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>h_endstop</name> = <name>bed_level_z</name> + <name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt></then></if>
         <if>if <condition>(<expr><name>bed_level_z</name> + <name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name> &lt; <name>l_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>l_endstop</name> = <name>bed_level_z</name> + <name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt></then></if>

         <if>if <condition>(<expr><name>h_endstop</name> - <name>l_endstop</name> &gt; 3</expr>)</condition><then>
            <block>{
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"The position of the endstop switches on this printer are not within limits"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Adjust endstop switches so that they are within 3mm Z-height of each other"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Current Endstop Positions - X: "</expr></argument>, <argument><expr><name>bed_level_x</name> + <name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
            <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" Y: "</expr></argument>, <argument><expr><name>bed_level_y</name> + <name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" Z: "</expr></argument>, <argument><expr><name>bed_level_z</name> + <name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Autocalibration aborted"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
            <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
            <comment type="line">//Restore saved variables</comment>
            <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
            <break>break;</break>
            }</block></then></if>
          
         <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
            <comment type="line">//Fix diagonal rod at specified length (do not adjust)</comment>
            <expr_stmt><expr><name>delta_diagonal_rod</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>adj_dr_allowed</name> = false</expr>;</expr_stmt>
            }</block></then></if>
         
         <do>do <block>{
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Iteration: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>loopcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                                 
            <if>if <condition>(<expr>(<name>bed_level_c</name> &gt; 3) or (<name>bed_level_c</name> &lt; -3)</expr>)</condition><then>
              <block>{
              <comment type="line">//Build height is not set correctly .. </comment>
              <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> -= <name>bed_level_c</name> + 2</expr>;</expr_stmt>
              <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Adjusting Z-Height to: "</expr></argument>, <argument><expr><name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" mm.."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then> 
              <else>else
              <block>{
              <if>if <condition>(<expr>(<name>bed_level_x</name> &lt; -<name>ac_prec</name>) or (<name>bed_level_x</name> &gt; <name>ac_prec</name>) or (<name>bed_level_y</name> &lt; -<name>ac_prec</name>) or (<name>bed_level_y</name> &gt; <name>ac_prec</name>) or (<name>bed_level_z</name> &lt; -<name>ac_prec</name>) or (<name>bed_level_z</name> &gt; <name>ac_prec</name>)</expr>)</condition><then>
                <block>{  
                <comment type="line">//Endstops req adjustment</comment>
                <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Adjusting Endstops.."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name> += <name>bed_level_x</name> / 1.05</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name> += <name>bed_level_y</name> / 1.05</expr>;</expr_stmt>
                <expr_stmt><expr><name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name> += <name>bed_level_z</name> / 1.05</expr>;</expr_stmt> 
                
                <comment type="line">//Check that no endstop adj values are &gt; 0 (not allowed).. if they are, reduce the build height to compensate.</comment>
                <expr_stmt><expr><name>h_endstop</name> = 0</expr>;</expr_stmt>
                <for>for(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &lt; 3</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
                  <block>{ 
                  <if>if <condition>(<expr><name><name>endstop_adj</name><index>[<expr><name>x</name></expr>]</index></name> &gt; <name>h_endstop</name></expr>)</condition><then> <expr_stmt><expr><name>h_endstop</name> = <name><name>endstop_adj</name><index>[<expr><name>x</name></expr>]</index></name></expr>;</expr_stmt></then></if> 
                  }</block></for>
                <if>if <condition>(<expr><name>h_endstop</name> &gt; 0</expr>)</condition><then> 
                  <block>{
                  <comment type="line">//Reduce build height and adjust endstops</comment>
                  <for>for(<init><decl><type><name>int</name></type> <name>x</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>x</name> &lt; 3</expr>;</condition> <incr><expr><name>x</name>++</expr></incr>)
                    <block>{
                    <expr_stmt><expr><name><name>endstop_adj</name><index>[<expr><name>x</name></expr>]</index></name> -= <name>h_endstop</name> + 2</expr>;</expr_stmt>
                    }</block></for>
                  <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> -= <name>h_endstop</name> + 2</expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Adjusting Z-Height to: "</expr></argument>, <argument><expr><name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" mm.."</expr></argument>)</argument_list></call></expr>;</expr_stmt>                
                  }</block></then></if>
                }</block></then>
                <else>else 
                <block>{
                <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Endstops: OK"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 
                <expr_stmt><expr><name>adj_r_target</name> = (<name>bed_level_x</name> + <name>bed_level_y</name> + <name>bed_level_z</name>) / 3</expr>;</expr_stmt>
                <expr_stmt><expr><name>adj_dr_target</name> = (<name>bed_level_ox</name> + <name>bed_level_oy</name> + <name>bed_level_oz</name>) / 3</expr>;</expr_stmt>
                
                <comment type="line">//Determine which parameters require adjustment</comment>
                <if>if <condition>(<expr>(<name>bed_level_c</name> &gt;= <name>adj_r_target</name> - <name>ac_prec</name>) and (<name>bed_level_c</name> &lt;= <name>adj_r_target</name> + <name>ac_prec</name>)</expr>)</condition><then> <expr_stmt><expr><name>adj_r_done</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_r_done</name> = false</expr>;</expr_stmt></else></if>
                <if>if <condition>(<expr>(<name>adj_dr_target</name> &gt;= <name>adj_r_target</name> - <name>ac_prec</name>) and (<name>adj_dr_target</name> &lt;= <name>adj_r_target</name> + <name>ac_prec</name>)</expr>)</condition><then> <expr_stmt><expr><name>adj_dr_done</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_dr_done</name> = false</expr>;</expr_stmt></else></if>
                <if>if <condition>(<expr>(<name>bed_level_x</name> != <name>bed_level_ox</name>) or (<name>bed_level_y</name> != <name>bed_level_oy</name>) or (<name>bed_level_z</name> != <name>bed_level_oz</name>)</expr>)</condition><then> <expr_stmt><expr><name>adj_tower_done</name> = false</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_tower_done</name> = true</expr>;</expr_stmt></else></if>
                            
                <if>if <condition>(<expr>(<name>adj_r_done</name> == false) or (<name>adj_dr_done</name> == false) or (<name>adj_tower_done</name> == false)</expr>)</condition><then> 
                  <block>{
                  <comment type="line">//delta geometry adjustment required                     </comment>
                  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Adjusting Delta Geometry.."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       
                  <comment type="line">//set inital direction and magnitude for delta radius &amp; diagonal rod adjustment</comment>
                  <if>if <condition>(<expr><name>adj_r</name> == 0</expr>)</condition><then>
                    <block>{
                    <if>if <condition>(<expr><name>adj_r_target</name> &gt; <name>bed_level_c</name></expr>)</condition><then> <expr_stmt><expr><name>adj_r</name> = 1</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_r</name> = -1</expr>;</expr_stmt></else></if>
                    }</block></then></if>
                  
                  <if>if <condition>(<expr><name>adj_dr</name> == 0</expr>)</condition><then>
                    <block>{
                    <if>if <condition>(<expr><name>adj_r_target</name> &gt; <name>adj_dr_target</name></expr>)</condition><then> <expr_stmt><expr><name>adj_dr</name> = 1</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_dr</name> = -1</expr>;</expr_stmt></else></if>
                    }</block></then></if>
                  
                  <comment type="line">//Don't adjust tower positions on first iteration</comment>
                  <expr_stmt><expr><name>adj_AlphaA</name> = <name>adj_AlphaB</name> = <name>adj_AlphaC</name> = 0</expr>;</expr_stmt> 
                  <expr_stmt><expr><name>adj_RadiusA</name> = <name>adj_RadiusB</name> = <name>adj_RadiusC</name> = 0</expr>;</expr_stmt>
                  
                  <do>do <block>{   
                     <comment type="line">//Apply adjustments </comment>
                     <if>if <condition>(<expr><name>adj_r_done</name> == false</expr>)</condition><then> 
                       <block>{
                       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Adjusting Delta Radius ("</expr></argument>,<argument><expr><name>delta_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" -&gt; "</expr></argument>, <argument><expr><name>delta_radius</name> + <name>adj_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><name>delta_radius</name> += <name>adj_r</name></expr>;</expr_stmt>
                       }</block></then></if>
 
                     <if>if <condition>(<expr><name>adj_dr_allowed</name> == false</expr>)</condition><then> <expr_stmt><expr><name>adj_dr_done</name> = true</expr>;</expr_stmt></then></if>
 
                     <if>if <condition>(<expr><name>adj_dr_done</name> == false</expr>)</condition><then>
                       <block>{
                       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Adjusting Diag Rod Length ("</expr></argument>,<argument><expr><name>delta_diagonal_rod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" -&gt; "</expr></argument>, <argument><expr><name>delta_diagonal_rod</name> + <name>adj_dr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <expr_stmt><expr><name>delta_diagonal_rod</name> += <name>adj_dr</name></expr>;</expr_stmt>
                       }</block></then></if>

                     <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>0</expr>]</index></name> -= <name>adj_AlphaA</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>1</expr>]</index></name> -= <name>adj_AlphaB</name></expr>;</expr_stmt>
               <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>2</expr>]</index></name> -= <name>adj_AlphaC</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>3</expr>]</index></name> += <name>adj_RadiusA</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>4</expr>]</index></name> += <name>adj_RadiusB</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>5</expr>]</index></name> += <name>adj_RadiusC</name></expr>;</expr_stmt>
       
                     <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>              
                          
                     <expr_stmt><expr><call><name>bed_probe_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>calibration_report</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                     
                     <comment type="line">//Check to see if autocal is complete to within limits..</comment>
                     <if>if <condition>(<expr><name>adj_dr_allowed</name> == true</expr>)</condition><then>
                        <block>{
                        <if>if <condition>(<expr>(<name>bed_level_x</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_x</name> &lt;= <name>ac_prec</name>)
                            and (<name>bed_level_y</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_y</name> &lt;= <name>ac_prec</name>)
                            and (<name>bed_level_z</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_z</name> &lt;= <name>ac_prec</name>)
                            and (<name>bed_level_c</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_c</name> &lt;= <name>ac_prec</name>)
                            and (<name>bed_level_ox</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_ox</name> &lt;= <name>ac_prec</name>)
                            and (<name>bed_level_oy</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_oy</name> &lt;= <name>ac_prec</name>)
                            and (<name>bed_level_oz</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_oz</name> &lt;= <name>ac_prec</name>)</expr>)</condition><then> <expr_stmt><expr><name>loopcount</name> = <name>iterations</name></expr>;</expr_stmt></then></if>
                            }</block></then>
                     <else>else
                        <block>{
                        <if>if <condition>(<expr>(<name>bed_level_x</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_x</name> &lt;= <name>ac_prec</name>)
                           and (<name>bed_level_y</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_y</name> &lt;= <name>ac_prec</name>)
                           and (<name>bed_level_z</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_z</name> &lt;= <name>ac_prec</name>)
                           and (<name>bed_level_c</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_c</name> &lt;= <name>ac_prec</name>)</expr>)</condition><then> <expr_stmt><expr><name>loopcount</name> = <name>iterations</name></expr>;</expr_stmt></then></if>
                        }</block></else></if>
                     
                     <comment type="line">//set delta radius and diag rod targets</comment>
                     <expr_stmt><expr><name>adj_r_target</name> = (<name>bed_level_x</name> + <name>bed_level_y</name> + <name>bed_level_z</name>) / 3</expr>;</expr_stmt>
                     <expr_stmt><expr><name>adj_dr_target</name> = (<name>bed_level_ox</name> + <name>bed_level_oy</name> + <name>bed_level_oz</name>) / 3</expr>;</expr_stmt>
        
                     <comment type="line">//set Tower position adjustment values                     </comment>
                     <expr_stmt><expr><name>adj_AlphaA</name> = <name>bed_level_oy</name> - <name>bed_level_oz</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name>adj_AlphaB</name> = <name>bed_level_oz</name> - <name>bed_level_ox</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name>adj_AlphaC</name> = <name>bed_level_ox</name> - <name>bed_level_oy</name></expr>;</expr_stmt>
                     
                     <comment type="line">//set tower radius errors</comment>
                     <expr_stmt><expr><name>radiusErrorA</name> = <name>bed_level_x</name> - <name>bed_level_ox</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name>radiusErrorB</name> = <name>bed_level_y</name> - <name>bed_level_oy</name></expr>;</expr_stmt>
                     <expr_stmt><expr><name>radiusErrorC</name> = <name>bed_level_z</name> - <name>bed_level_oz</name></expr>;</expr_stmt>
                     
                     <if>if <condition>(<expr>(<name>radiusErrorA</name> &gt;= (<name>radiusErrorB</name> - 0.02)) and (<name>radiusErrorA</name> &lt;= (<name>radiusErrorB</name> + 0.02))</expr>)</condition><then> <expr_stmt><expr><name>equalAB</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>equalAB</name> = false</expr>;</expr_stmt></else></if>
                     <if>if <condition>(<expr>(<name>radiusErrorB</name> &gt;= (<name>radiusErrorC</name> - 0.02)) and (<name>radiusErrorB</name> &lt;= (<name>radiusErrorC</name> + 0.02))</expr>)</condition><then> <expr_stmt><expr><name>equalBC</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>equalBC</name> = false</expr>;</expr_stmt></else></if>
                     <if>if <condition>(<expr>(<name>radiusErrorC</name> &gt;= (<name>radiusErrorA</name> - 0.02)) and (<name>radiusErrorC</name> &lt;= (<name>radiusErrorA</name> + 0.02))</expr>)</condition><then> <expr_stmt><expr><name>equalCA</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>equalCA</name> = false</expr>;</expr_stmt></else></if>
              
                 <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MESSAGES</name></cpp:ifdef>
                     <if>if <condition>(<expr><name>equalAB</name> == true</expr>)</condition><then>
                       <block>{
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Tower AB Equal (A="</expr></argument>,<argument><expr><name>radiusErrorA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" B="</expr></argument>,<argument><expr><name>radiusErrorB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       }</block></then> <else>else <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"equalAB=false"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                       
                     <if>if <condition>(<expr><name>equalBC</name> == true</expr>)</condition><then>
                       <block>{ 
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Tower BC Equal (B="</expr></argument>,<argument><expr><name>radiusErrorB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" C="</expr></argument>,<argument><expr><name>radiusErrorC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       }</block></then> <else>else <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"equalBC=false"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                       
                     <if>if <condition>(<expr><name>equalCA</name> == true</expr>)</condition><then>
                      <block>{
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Tower CA Equal (C="</expr></argument>,<argument><expr><name>radiusErrorC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" A="</expr></argument>,<argument><expr><name>radiusErrorA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       }</block></then> <else>else <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"equalCA=false"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>                   
                 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   
                     
                     <if>if <condition>(<expr>(<name>equalAB</name> == true) and (<name>equalBC</name> == true) and (<name>equalCA</name> == true)</expr>)</condition><then>
                       <block>{
                       <comment type="line">// all tower radius out by the same amount (within 0.02) - allow adjustment with delta rod length</comment>
                 <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MESSAGES</name></cpp:ifdef>
                       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"All tower radius errors equal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                       <expr_stmt><expr><name>adj_RadiusA</name> = <name>adj_RadiusB</name> = <name>adj_RadiusC</name> = 0</expr>;</expr_stmt>
                       }</block></then></if>
                     
                     <if>if <condition>(<expr>(<name>equalAB</name> == true) and (<name>equalBC</name> == false) and (<name>equalCA</name> == false)</expr>)</condition><then>
                       <block>{
                       <comment type="line">//Tower C radius error.. adjust it</comment>
                       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"TowerC Radius error - adjusting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <if>if <condition>(<expr><name>adj_RadiusC</name> == 0</expr>)</condition><then>
                         <block>{
                         <if>if <condition>(<expr><name>bed_level_z</name> &lt; <name>bed_level_oz</name></expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusC</name> = 0.5</expr>;</expr_stmt></then></if>
                         <if>if <condition>(<expr><name>bed_level_z</name> &gt; <name>bed_level_oz</name></expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusC</name> = -0.5</expr>;</expr_stmt></then></if>                     
                 <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MESSAGES</name></cpp:ifdef>
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"adj_RadiusC set to "</expr></argument>,<argument><expr><name>adj_RadiusC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                 <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                         }</block></then></if>
                       }</block></then></if>
                     <if>if <condition>(<expr>(<name>equalBC</name> == true) and (<name>equalAB</name> == false) and (<name>equalCA</name> == false)</expr>)</condition><then>
                       <block>{
                       <comment type="line">//Tower A radius error .. adjust it</comment>
                       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"TowerA Radius error - adjusting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <if>if <condition>(<expr><name>adj_RadiusA</name> == 0</expr>)</condition><then>
                         <block>{
                         <if>if <condition>(<expr><name>bed_level_x</name> &lt; <name>bed_level_ox</name></expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusA</name> = 0.5</expr>;</expr_stmt></then></if>
                         <if>if <condition>(<expr><name>bed_level_x</name> &gt; <name>bed_level_ox</name></expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusA</name> = -0.5</expr>;</expr_stmt></then></if>  
                  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MESSAGES</name></cpp:ifdef>                   
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"adj_RadiusA set to "</expr></argument>,<argument><expr><name>adj_RadiusA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
                         }</block></then></if>
                       }</block></then></if> 
                     <if>if <condition>(<expr>(<name>equalCA</name> == true) and (<name>equalAB</name> == false) and (<name>equalBC</name> == false)</expr>)</condition><then>
                       <block>{
                       <comment type="line">//Tower B radius error .. adjust it</comment>
                       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"TowerB Radius error - adjusting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                       <if>if <condition>(<expr><name>adj_RadiusB</name> == 0</expr>)</condition><then>
                         <block>{
                         <if>if <condition>(<expr><name>bed_level_y</name> &lt; <name>bed_level_oy</name></expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusB</name> = 0.5</expr>;</expr_stmt></then></if>
                         <if>if <condition>(<expr><name>bed_level_y</name> &gt; <name>bed_level_oy</name></expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusB</name> = -0.5</expr>;</expr_stmt></then></if>                     
                   <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MESSAGES</name></cpp:ifdef>
                         <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"adj_RadiusB set to "</expr></argument>,<argument><expr><name>adj_RadiusB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                         <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                         }</block></then></if>
                       }</block></then></if>
                                       
                                       
                     <if>if <condition>(<expr>((<name>adj_r</name> &gt; 0) and (<name>bed_level_c</name> &gt; <name>adj_r_target</name>)) or ((<name>adj_r</name> &lt; 0) and (<name>bed_level_c</name> &lt; <name>adj_r_target</name>))</expr>)</condition><then>
                       <block>{
                       <comment type="line">//overshot target .. reverse &amp; scale down</comment>
                       <expr_stmt><expr><name>adj_r</name> = -(<name>adj_r</name> / 2)</expr>;</expr_stmt>
                       }</block></then></if>
                             
                     <if>if <condition>(<expr>((<name>adj_dr</name> &gt; 0) and (<name>adj_dr_target</name> &gt; <name>adj_r_target</name>)) or ((<name>adj_dr</name> &lt; 0) and (<name>adj_dr_target</name> &lt; <name>adj_r_target</name>))</expr>)</condition><then>
                       <block>{
                       <comment type="line">//overshot target .. reverse &amp; scale down</comment>
                       <expr_stmt><expr><name>adj_dr</name> = -(<name>adj_dr</name> / 2)</expr>;</expr_stmt>
                       }</block></then></if>
                     
                     <comment type="line">//Tower radius overshot targets?</comment>
                     <if>if <condition>(<expr>((<name>adj_RadiusA</name> &gt; 0) and (<name>bed_level_x</name> &gt; <name>bed_level_ox</name>)) or ((<name>adj_RadiusA</name> &lt; 0) and (<name>bed_level_x</name> &lt; <name>bed_level_ox</name>))</expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusA</name> = -(<name>adj_RadiusA</name> / 2)</expr>;</expr_stmt></then></if>
                     <if>if <condition>(<expr>((<name>adj_RadiusB</name> &gt; 0) and (<name>bed_level_y</name> &gt; <name>bed_level_oy</name>)) or ((<name>adj_RadiusB</name> &lt; 0) and (<name>bed_level_y</name> &lt; <name>bed_level_oy</name>))</expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusB</name> = -(<name>adj_RadiusB</name> / 2)</expr>;</expr_stmt></then></if>
                     <if>if <condition>(<expr>((<name>adj_RadiusC</name> &gt; 0) and (<name>bed_level_z</name> &gt; <name>bed_level_oz</name>)) or ((<name>adj_RadiusC</name> &lt; 0) and (<name>bed_level_z</name> &lt; <name>bed_level_oz</name>))</expr>)</condition><then> <expr_stmt><expr><name>adj_RadiusC</name> = -(<name>adj_RadiusC</name> / 2)</expr>;</expr_stmt></then></if>
                     
                     <comment type="line">//Delta radius adjustment complete?                       </comment>
                     <if>if <condition>(<expr>(<name>bed_level_c</name> &gt;= (<name>adj_r_target</name> - <name>ac_prec</name>)) and (<name>bed_level_c</name> &lt;= (<name>adj_r_target</name> + <name>ac_prec</name>))</expr>)</condition><then> <expr_stmt><expr><name>adj_r_done</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_r_done</name> = false</expr>;</expr_stmt></else></if>
                     
                     <comment type="line">//Diag Rod adjustment complete?</comment>
                     <if>if <condition>(<expr>(<name>adj_dr_target</name> &gt;= (<name>adj_r_target</name> - <name>ac_prec</name>)) and (<name>adj_dr_target</name> &lt;= (<name>adj_r_target</name> + <name>ac_prec</name>))</expr>)</condition><then> <expr_stmt><expr><name>adj_dr_done</name> = true</expr>;</expr_stmt></then> <else>else <expr_stmt><expr><name>adj_dr_done</name> = false</expr>;</expr_stmt></else></if>
                    
                  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_MESSAGES</name></cpp:ifdef>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"c: "</expr></argument>, <argument><expr><name>bed_level_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" x: "</expr></argument>, <argument><expr><name>bed_level_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" y: "</expr></argument>, <argument><expr><name>bed_level_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" z: "</expr></argument>, <argument><expr><name>bed_level_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" ox: "</expr></argument>, <argument><expr><name>bed_level_ox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" oy: "</expr></argument>, <argument><expr><name>bed_level_oy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" oz: "</expr></argument>, <argument><expr><name>bed_level_oz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"radius:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>delta_radius</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" diagrod:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>delta_diagonal_rod</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Radius Adj Complete: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <if>if <condition>(<expr><name>adj_r_done</name> == true</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Yes"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"No"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                     <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" DiagRod Adj Complete: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <if>if <condition>(<expr><name>adj_dr_done</name> == true</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Yes"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"No"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"RadiusA Error: "</expr></argument>,<argument><expr><name>radiusErrorA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" (adjust: "</expr></argument>,<argument><expr><name>adj_RadiusA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"RadiusB Error: "</expr></argument>,<argument><expr><name>radiusErrorB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" (adjust: "</expr></argument>,<argument><expr><name>adj_RadiusB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"RadiusC Error: "</expr></argument>,<argument><expr><name>radiusErrorC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" (adjust: "</expr></argument>,<argument><expr><name>adj_RadiusC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>")"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"DeltaAlphaA: "</expr></argument>,<argument><expr><name>adj_AlphaA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"DeltaAlphaB: "</expr></argument>,<argument><expr><name>adj_AlphaB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"DeltaAlphaC: "</expr></argument>,<argument><expr><name>adj_AlphaC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                     <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                   
                   }</block> while<condition>(<expr>((<name>adj_r_done</name> == false) or (<name>adj_dr_done</name> = false)) and (<name>loopcount</name> &lt; <name>iterations</name>)</expr>)</condition>;</do> 
                 
                   }</block></then>
                   <else>else
                   <block>{
                   <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Delta Geometry: OK"</expr></argument>)</argument_list></call></expr>;</expr_stmt>  
                   }</block></else></if>
                  }</block></else></if>
                }</block></else></if>
                       
                <if>if <condition>(<expr><name>loopcount</name> &lt; <name>iterations</name></expr>)</condition><then>
                  <block>{
                  <expr_stmt><expr><call><name>home_delta_axis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                
                  <comment type="line">//probe bed and display report</comment>
                  <expr_stmt><expr><call><name>bed_probe_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>calibration_report</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

                  <comment type="line">//Check to see if autocal is complete to within limits..</comment>
                  <if>if <condition>(<expr><name>adj_dr_allowed</name> == true</expr>)</condition><then>
                    <block>{
                    <if>if <condition>(<expr>(<name>bed_level_x</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_x</name> &lt;= <name>ac_prec</name>)
                       and (<name>bed_level_y</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_y</name> &lt;= <name>ac_prec</name>)
                       and (<name>bed_level_z</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_z</name> &lt;= <name>ac_prec</name>)
                       and (<name>bed_level_c</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_c</name> &lt;= <name>ac_prec</name>)
                       and (<name>bed_level_ox</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_ox</name> &lt;= <name>ac_prec</name>)
                       and (<name>bed_level_oy</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_oy</name> &lt;= <name>ac_prec</name>)
                       and (<name>bed_level_oz</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_oz</name> &lt;= <name>ac_prec</name>)</expr>)</condition><then> <expr_stmt><expr><name>loopcount</name> = <name>iterations</name></expr>;</expr_stmt></then></if>
                       }</block></then>
                    <else>else
                       <block>{
                       <if>if <condition>(<expr>(<name>bed_level_x</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_x</name> &lt;= <name>ac_prec</name>)
                          and (<name>bed_level_y</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_y</name> &lt;= <name>ac_prec</name>)
                          and (<name>bed_level_z</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_z</name> &lt;= <name>ac_prec</name>)
                          and (<name>bed_level_c</name> &gt;= -<name>ac_prec</name>) and (<name>bed_level_c</name> &lt;= <name>ac_prec</name>)</expr>)</condition><then> <expr_stmt><expr><name>loopcount</name> = <name>iterations</name></expr>;</expr_stmt></then></if>
                       }</block></else></if>
                  }</block></then></if>
                  
    <expr_stmt><expr><name>loopcount</name> ++</expr>;</expr_stmt>    
    }</block> while<condition>(<expr><name>loopcount</name> &lt; <name>iterations</name></expr>)</condition>;</do>

            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Auto Calibration Complete"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Issue M500 Command to save calibration settings to EPROM (if enabled)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <comment type="block">/*   
            if ((abs(delta_diagonal_rod - saved_delta_diagonal_rod) &gt; 1) and (adj_dr_allowed == true))
              {
              SERIAL_ECHOLN("");
              SERIAL_ECHOPAIR("WARNING: The length of diagonal rods specified (", saved_delta_diagonal_rod);
              SERIAL_ECHOLN(" mm) appears to be incorrect");
              SERIAL_ECHOLN("If you have measured your rods and you believe that this value is correct, this could indicate");
              SERIAL_ECHOLN("excessive twisting movement of carriages and/or loose screws/joints on carriages or end effector");
              }
         */</comment>  
          }</block></then></if> 
         
    <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
 
        <comment type="line">//Restore saved variables</comment>
        <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
        <break>break;</break> 
    </case><case>case <expr>90</expr>: <comment type="line">// G90</comment>
      <expr_stmt><expr><name>relative_mode</name> = false</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>91</expr>: <comment type="line">// G91</comment>
      <expr_stmt><expr><name>relative_mode</name> = true</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>92</expr>: <comment type="line">// G92</comment>
      <if>if<condition>(<expr>!<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
           <if>if<condition>(<expr><name>i</name> == <name>E_AXIS</name></expr>)</condition><then> <block>{
             <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           }</block></then>
           <else>else <block>{
             <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homeing</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           }</block></else></if>
        }</block></then></if>
      }</block></for>
      <break>break;</break>
    </case>}</block></switch>
  }</block></then>

  <else>else <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'M'</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <switch>switch<condition>( <expr>(<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr> )</condition>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
    <case>case <expr>0</expr>: <comment type="line">// M0 - Unconditional stop - Wait for user button press on LCD</comment>
    </case><case>case <expr>1</expr>: <comment type="line">// M1 - Conditional stop - Wait for user button press on LCD</comment>
    <block>{
      <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_USERWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> = 0</expr>;</expr_stmt>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// milliseconds to wait</comment>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt></then></if> <comment type="line">// seconds to wait</comment>

      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>codenum</name> &gt; 0</expr>)</condition><then><block>{
        <expr_stmt><expr><name>codenum</name> += <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// keep track of when we started waiting</comment>
        <while>while<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call>  &lt; <name>codenum</name> &amp;&amp; !<call><name>lcd_clicked</name><argument_list>()</argument_list></call></expr>)</condition><block>{
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
      }</block></then><else>else<block>{
        <while>while<condition>(<expr>!<call><name>lcd_clicked</name><argument_list>()</argument_list></call></expr>)</condition><block>{
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
      }</block></else></if>
      <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_RESUMING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>17</expr>:
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_NO_MOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
    </case><case>case <expr>20</expr>: <comment type="line">// M20 - list SD card</comment>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_BEGIN_FILE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>card</name>.<name>ls</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_END_FILE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>21</expr>: <comment type="line">// M21 - init SD card</comment>

      <expr_stmt><expr><call><name><name>card</name>.<name>initsd</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    </case><case>case <expr>22</expr>: <comment type="line">//M22 - release SD card</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    </case><case>case <expr>23</expr>: <comment type="line">//M23 - Select file</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name>!=<name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*(<name>starpos</name>-1)='\0'</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>24</expr>: <comment type="line">//M24 - Start SD print</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>startFileprint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>starttime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>25</expr>: <comment type="line">//M25 - Pause SD print</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>pauseSDPrint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>26</expr>: <comment type="line">//M26 - Set SD index</comment>
      <if>if<condition>(<expr><name><name>card</name>.<name>cardOK</name></name> &amp;&amp; <call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>card</name>.<name>setIndex</name></name><argument_list>(<argument><expr><call><name>code_value_long</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><case>case <expr>27</expr>: <comment type="line">//M27 - Get SD status</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>getStatus</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>28</expr>: <comment type="line">//M28 - Start SD write</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then><block>{
        <decl_stmt><decl><type><name>char</name>*</type> <name>npos</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>npos</name></expr></argument>,<argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>starpos</name>-1) = '\0'</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name>+4</expr></argument>,<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>29</expr>: <comment type="line">//M29 - Stop SD write</comment>
      <comment type="line">//processed in write to file routine above</comment>
      <comment type="line">//card,saving = false;</comment>
      <break>break;</break>
    </case><case>case <expr>30</expr>: <comment type="line">//M30 &lt;filename&gt; Delete File</comment>
      <if>if <condition>(<expr><name><name>card</name>.<name>cardOK</name></name></expr>)</condition><then><block>{
        <expr_stmt><expr><call><name><name>card</name>.<name>closefile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <if>if<condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then><block>{
          <decl_stmt><decl><type><name>char</name>*</type> <name>npos</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>npos</name></expr></argument>,<argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
          <expr_stmt><expr>*(<name>starpos</name>-1) = '\0'</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>card</name>.<name>removeFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><case>case <expr>32</expr>: <comment type="line">//M32 - Select file and start SD print</comment>
      <if>if<condition>(<expr><name><name>card</name>.<name>sdprinting</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>card</name>.<name>closefile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>card</name>.<name>sdprinting</name></name> = false</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name>!=<name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*(<name>starpos</name>-1)='\0'</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>card</name>.<name>startFileprint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>starttime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>928</expr>: <comment type="line">//M928 - Start SD write</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 5</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then><block>{
        <decl_stmt><decl><type><name>char</name>*</type> <name>npos</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>npos</name></expr></argument>,<argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>starpos</name>-1) = '\0'</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openLogFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name>+5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>

    </case><case>case <expr>31</expr>: <comment type="line">//M31 take time since the start of the SD print or an M109 command</comment>
      <block>{
      <expr_stmt><expr><name>stoptime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>time</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name><init>=<expr>(<name>stoptime</name>-<name>starttime</name>)/1000</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sec</name></decl>,<decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>min</name>=<name>t</name>/60</expr>;</expr_stmt>
      <expr_stmt><expr><name>sec</name>=<name>t</name>%60</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf_P</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"%i min, %i sec"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>autotempShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    </case><case>case <expr>42</expr>: <comment type="line">//M42 -Change pin status via gcode</comment>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>pin_status</name> <init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pin_number</name> <init>= <expr><name>LED_PIN</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call> &amp;&amp; <name>pin_status</name> &gt;= 0 &amp;&amp; <name>pin_status</name> &lt;= 255</expr>)</condition><then>
          <expr_stmt><expr><name>pin_number</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; (<name>int8_t</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>sensitive_pins</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <if>if <condition>(<expr><name><name>sensitive_pins</name><index>[<expr><name>i</name></expr>]</index></name> == <name>pin_number</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name>pin_number</name> = -1</expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></for>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>FAN_PIN</name> &gt; -1</expr></cpp:if>
        <if>if <condition>(<expr><name>pin_number</name> == <name>FAN_PIN</name></expr>)</condition><then>
          <expr_stmt><expr><name>fanSpeed</name> = <name>pin_status</name></expr>;</expr_stmt></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name>pin_number</name> &gt; -1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>pin_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>pin_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
     <break>break;</break>
    </case><case>case <expr>104</expr>: <comment type="line">// M104</comment>
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>104</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
      <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>tmp_extruder</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>setTargetHotend1</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call> == 0.0 ? 0.0 : <call><name>code_value</name><argument_list>()</argument_list></call> + <name>duplicate_extruder_temp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>          
      <expr_stmt><expr><call><name>setWatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>140</expr>: <comment type="line">// M140 set bed temp</comment>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr>105</expr> : <comment type="line">// M105</comment>
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>105</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
        }</block></then></if>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_0_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"ok T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" /"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" B:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" /"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degTargetBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//TEMP_BED_PIN</comment>
        <for>for (<init><decl><type><name>int8_t</name></type> <name>cur_extruder</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>cur_extruder</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr>++<name>cur_extruder</name></expr></incr>) <block>{
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" T"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" /"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degTargetHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_NO_THERMISTORS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" @:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>getHeaterPower</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" B@:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>getHeaterPower</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
      <break>break;</break>
    </case><case>case <expr>109</expr>:
    <block>{<comment type="line">// M109 - Wait for extruder heater to reach target.</comment>
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>109</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_HEATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
        <expr_stmt><expr><name>autotemp_enabled</name>=false</expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>tmp_extruder</name> == 0</expr>)</condition><then>
          <expr_stmt><expr><call><name>setTargetHotend1</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call> == 0.0 ? 0.0 : <call><name>code_value</name><argument_list>()</argument_list></call> + <name>duplicate_extruder_temp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>          
        <expr_stmt><expr><name>CooldownNoWait</name> = true</expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>tmp_extruder</name> == 0</expr>)</condition><then>
          <expr_stmt><expr><call><name>setTargetHotend1</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call> == 0.0 ? 0.0 : <call><name>code_value</name><argument_list>()</argument_list></call> + <name>duplicate_extruder_temp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>          
        <expr_stmt><expr><name>CooldownNoWait</name> = false</expr>;</expr_stmt>
      }</block></then></if></else></if>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>autotemp_min</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>autotemp_max</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>autotemp_factor</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>autotemp_enabled</name>=true</expr>;</expr_stmt>
        }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><call><name>setWatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* See if we are heating up or cooling down */</comment>
      <expr_stmt><expr><name>target_direction</name> = <call><name>isHeatingHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// true if heating, false if cooling</comment>

      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_RESIDENCY_TIME</name></cpp:ifdef>
        <decl_stmt><decl><type><name>long</name></type> <name>residencyStart</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>residencyStart</name> = -1</expr>;</expr_stmt>
        <comment type="block">/* continue to loop until we have reached the target temp
          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */</comment>
        <while>while<condition>(<expr>(<name>residencyStart</name> == -1) ||
              (<name>residencyStart</name> &gt;= 0 &amp;&amp; ((<call>(<name>unsigned</name> <name>int</name>) <argument_list>(<argument><expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>residencyStart</name></expr></argument>)</argument_list></call>) &lt; (<name>TEMP_RESIDENCY_TIME</name> * 1000UL)))</expr> )</condition> <block>{
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <while>while <condition>( <expr><name>target_direction</name> ? (<call><name>isHeatingHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>) : (<call><name>isCoolingHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>&amp;&amp;(<name>CooldownNoWait</name>==false))</expr> )</condition> <block>{
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//TEMP_RESIDENCY_TIME</comment>
          <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>codenum</name>) &gt; 1000UL</expr> )</condition><then>
          <block>{ <comment type="line">//Print Temp Reading and remaining time every 1 second while heating up/cooling down</comment>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" E:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name>int</name>)<name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_RESIDENCY_TIME</name></cpp:ifdef>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" W:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>(<expr><name>residencyStart</name> &gt; -1</expr>)</condition><then>
              <block>{
                 <expr_stmt><expr><name>codenum</name> = ((<name>TEMP_RESIDENCY_TIME</name> * 1000UL) - (<call><name>millis</name><argument_list>()</argument_list></call> - <name>residencyStart</name>)) / 1000UL</expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>( <argument><expr><name>codenum</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              }</block></then>
              <else>else
              <block>{
                 <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>( <argument><expr>"?"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
              }</block></else></if>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_RESIDENCY_TIME</name></cpp:ifdef>
            <comment type="block">/* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
              or when current temp falls outside the hysteresis after target temp was reached */</comment>
          <if>if <condition>(<expr>(<name>residencyStart</name> == -1 &amp;&amp;  <name>target_direction</name> &amp;&amp; (<call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call> &gt;= (<call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>-<name>TEMP_WINDOW</name>))) ||
              (<name>residencyStart</name> == -1 &amp;&amp; !<name>target_direction</name> &amp;&amp; (<call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call> &lt;= (<call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>+<name>TEMP_WINDOW</name>))) ||
              (<name>residencyStart</name> &gt; -1 &amp;&amp; <call><name>labs</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call> - <call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; <name>TEMP_HYSTERESIS</name>)</expr> )</condition><then>
          <block>{
            <expr_stmt><expr><name>residencyStart</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//TEMP_RESIDENCY_TIME</comment>
        }</block></while>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_HEATING_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>starttime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <break>break;</break>
    <case>case <expr>190</expr>: <comment type="line">// M190 - Wait for bed heater to reach target.</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_BED_HEATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>CooldownNoWait</name> = true</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>CooldownNoWait</name> = false</expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>target_direction</name> = <call><name>isHeatingBed</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// true if heating, false if cooling</comment>

        <while>while <condition>( <expr><name>target_direction</name> ? (<call><name>isHeatingBed</name><argument_list>()</argument_list></call>) : (<call><name>isCoolingBed</name><argument_list>()</argument_list></call>&amp;&amp;(<name>CooldownNoWait</name>==false))</expr> )</condition>
        <block>{
          <if>if<condition>(<expr>( <call><name>millis</name><argument_list>()</argument_list></call> - <name>codenum</name>) &gt; 1000</expr> )</condition><then> <comment type="line">//Print Temp Reading every 1 second while heating up.</comment>
          <block>{
            <decl_stmt><decl><type><name>float</name></type> <name>tt</name><init>=<expr><call><name>degHotend</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" E:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name>int</name>)<name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" B:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_BED_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>FAN_PIN</name> &gt; -1</expr></cpp:if>
      </case><case>case <expr>106</expr>: <comment type="line">//M106 Fan On</comment>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
           <expr_stmt><expr><name>fanSpeed</name>=<call><name>constrain</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>fanSpeed</name>=255</expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr>107</expr>: <comment type="line">//M107 Fan Off</comment>
        <expr_stmt><expr><name>fanSpeed</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FAN_PIN</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
      <comment type="line">// PWM for HEATER_1_PIN</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_1_PIN</name> &gt; -1</expr></cpp:if>
        </case><case>case <expr>126</expr>: <comment type="line">//M126 valve open</comment>
          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
             <expr_stmt><expr><name>ValvePressure</name>=<call><name>constrain</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name>ValvePressure</name>=255</expr>;</expr_stmt>
          }</block></else></if>
          <break>break;</break>
        </case><case>case <expr>127</expr>: <comment type="line">//M127 valve closed</comment>
          <expr_stmt><expr><name>ValvePressure</name> = 0</expr>;</expr_stmt>
          <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//HEATER_1_PIN</comment>

      <comment type="line">// PWM for HEATER_2_PIN</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_2_PIN</name> &gt; -1</expr></cpp:if>
        </case><case>case <expr>128</expr>: <comment type="line">//M128 valve open</comment>
          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
             <expr_stmt><expr><name>EtoPPressure</name>=<call><name>constrain</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name>EtoPPressure</name>=255</expr>;</expr_stmt>
          }</block></else></if>
          <break>break;</break>
        </case><case>case <expr>129</expr>: <comment type="line">//M129 valve closed</comment>
          <expr_stmt><expr><name>EtoPPressure</name> = 0</expr>;</expr_stmt>
          <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//HEATER_2_PIN</comment>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:if>
      </case><case>case <expr>80</expr>: <comment type="line">// M80 - Turn on Power Supply</comment>
        <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//GND</comment>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_AWAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
          <expr_stmt><expr><name>powersupply</name> = true</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>WELCOME_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr>81</expr>: <comment type="line">// M81 - Turn off Power Supply</comment>
        <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>finishAndDisableSteppers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fanSpeed</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Wait a little before to switch off</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>suicide</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:elif>
        <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_ASLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
        <expr_stmt><expr><name>powersupply</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MACHINE_NAME</name>" "<name>MSG_OFF</name>"."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <break>break;</break>

    </case><case>case <expr>82</expr>:
      <expr_stmt><expr><name><name>axis_relative_modes</name><index>[<expr>3</expr>]</index></name> = false</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>83</expr>:
      <expr_stmt><expr><name><name>axis_relative_modes</name><index>[<expr>3</expr>]</index></name> = true</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>18</expr>: <comment type="line">//compatibility</comment>
    </case><case>case <expr>84</expr>: <comment type="line">// M84</comment>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <expr_stmt><expr><name>stepper_inactive_time</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt>
      }</block></then>
      <else>else
      <block>{
        <decl_stmt><decl><type><name>bool</name></type> <name>all_axis</name> <init>= <expr>!((<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call>)|| (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call>))</expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><name>all_axis</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>finishAndDisableSteppers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <cpp:if>#<cpp:directive>if</cpp:directive> <expr>((<name>E0_ENABLE_PIN</name> != <name>X_ENABLE_PIN</name>) &amp;&amp; (<name>E1_ENABLE_PIN</name> != <name>Y_ENABLE_PIN</name>))</expr></cpp:if> <comment type="line">// Only enable on boards that have seperate ENABLE_PINS</comment>
            <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
      }</block></else></if>
      <break>break;</break>
    </case><case>case <expr>85</expr>: <comment type="line">// M85</comment>
      <expr_stmt><expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>max_inactive_time</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>92</expr>: <comment type="line">// M92</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if<condition>(<expr><name>i</name> == 3</expr>)</condition><then> <block>{ <comment type="line">// E</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if<condition>(<expr><name>value</name> &lt; 20.0</expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>float</name></type> <name>factor</name> <init>= <expr><name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name> / <name>value</name></expr></init></decl>;</decl_stmt> <comment type="line">// increase e constants if M92 E14 is given for netfab.</comment>
              <expr_stmt><expr><name>max_e_jerk</name> *= <name>factor</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>max_feedrate</name><index>[<expr><name>i</name></expr>]</index></name> *= <name>factor</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>axis_steps_per_sqr_second</name><index>[<expr><name>i</name></expr>]</index></name> *= <name>factor</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then></if>
      }</block></for>
      <break>break;</break>
    </case><case>case <expr>115</expr>: <comment type="line">// M115</comment>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_M115_REPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>117</expr>: <comment type="line">// M117 display message</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 5</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name>!=<name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*(<name>starpos</name>-1)='\0'</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>114</expr>: <comment type="line">// M114</comment>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"X:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Y:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Z:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"E:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_COUNT_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Y:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Z:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>120</expr>: <comment type="line">// M120</comment>
      <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr> ;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>121</expr>: <comment type="line">// M121</comment>
      <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr> ;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>119</expr>: <comment type="line">// M119</comment>
    <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>MSG_M119_REPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MIN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MIN_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_X_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>X_MIN_PIN</name></expr></argument>)</argument_list></call>^<name>X_MIN_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MAX_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MAX_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_X_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>X_MAX_PIN</name></expr></argument>)</argument_list></call>^<name>X_MAX_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Y_MIN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Y_MIN_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Y_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Y_MIN_PIN</name></expr></argument>)</argument_list></call>^<name>Y_MIN_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Y_MAX_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Y_MAX_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Y_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Y_MAX_PIN</name></expr></argument>)</argument_list></call>^<name>Y_MAX_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_MIN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Z_MIN_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Z_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Z_MIN_PIN</name></expr></argument>)</argument_list></call>^<name>Z_MIN_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_MAX_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Z_MAX_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Z_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Z_MAX_PIN</name></expr></argument>)</argument_list></call>^<name>Z_MAX_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
      <comment type="line">//TODO: update for all axis, use for loop</comment>
    </case><case>case <expr>201</expr>: <comment type="line">// M201</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>max_acceleration_units_per_sq_second</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <comment type="line">// steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</comment>
      <expr_stmt><expr><call><name>reset_acceleration_rates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="line">// Not used for Sprinter/grbl gen6</comment>
    case 202: <comment type="line">// M202</comment>
      for(int8_t i=0; i &lt; NUM_AXIS; i++) {
        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
      }
      break;
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>203</expr>: <comment type="line">// M203 max feedrate mm/sec</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>max_feedrate</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></for>
      <break>break;</break>
    </case><case>case <expr>204</expr>: <comment type="line">// M204 acclereration S normal moves T filmanent only moves</comment>
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>acceleration</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>retract_acceleration</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      }</block>
      <break>break;</break>
    </case><case>case <expr>205</expr>: <comment type="line">//M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>minimumfeedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>mintravelfeedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>minsegmenttime</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>max_xy_jerk</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>max_z_jerk</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>max_e_jerk</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
    }</block>
    <break>break;</break>
    </case><case>case <expr>206</expr>: <comment type="line">// M206 additional homeing offset</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>add_homeing</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></for>
      <break>break;</break>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
      </case><case>case <expr>666</expr>: <comment type="line">// M666 set delta endstop and geometry adjustment</comment>
         <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
         <block>{
           <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>endstop_adj</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
         }</block></for>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'A'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>0</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>1</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>2</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
           <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>3</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'J'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>4</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'K'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name><name>tower_adj</name><index>[<expr>5</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
           <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
           <expr_stmt><expr><name>delta_radius</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         }</block></then></if>
           <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
             <expr_stmt><expr><name>delta_diagonal_rod</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         }</block></then></if>
           <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'H'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
             <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>set_delta_constants</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         }</block></then></if>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
             <expr_stmt><expr><name><name>z_probe_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     }</block></then></if>
     <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Current Delta geometry values:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"X (Endstop Adj): "</expr></argument>,<argument><expr><name><name>endstop_adj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Y (Endstop Adj): "</expr></argument>,<argument><expr><name><name>endstop_adj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"Z (Endstop Adj): "</expr></argument>,<argument><expr><name><name>endstop_adj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"P (Z-Probe Offset): X"</expr></argument>, <argument><expr><name><name>z_probe_offset</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" Y"</expr></argument>, <argument><expr><name><name>z_probe_offset</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>" Z"</expr></argument>, <argument><expr><name><name>z_probe_offset</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"A (Tower A Position Correction): "</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"B (Tower B Position Correction): "</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"C (Tower C Position Correction): "</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"I (Tower A Radius Correction): "</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>3</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"J (Tower B Radius Correction): "</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"K (Tower C Radius Correction): "</expr></argument>,<argument><expr><name><name>tower_adj</name><index>[<expr>5</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"R (Delta Radius): "</expr></argument>,<argument><expr><name>delta_radius</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"D (Diagonal Rod Length): "</expr></argument>,<argument><expr><name>delta_diagonal_rod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"H (Z-Height): "</expr></argument>,<argument><expr><name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
             }</block></then></if>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
    </case><case>case <expr>207</expr>: <comment type="line">//M207 - set retract length S[positive mm] F[feedrate mm/sec] Z[additional zlift/hop]</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_length</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_zlift</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
    }</block><break>break;</break>
    </case><case>case <expr>208</expr>: <comment type="line">// M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_recover_length</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_recover_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
    }</block><break>break;</break>
    </case><case>case <expr>209</expr>: <comment type="line">// M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>t</name><init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl> ;</decl_stmt>
        <switch>switch<condition>(<expr><name>t</name></expr>)</condition>
        <block>{
          <case>case <expr>0</expr>: <expr_stmt><expr><name>autoretract_enabled</name>=false</expr>;</expr_stmt><expr_stmt><expr><name>retracted</name>=false</expr>;</expr_stmt><break>break;</break>
          </case><case>case <expr>1</expr>: <expr_stmt><expr><name>autoretract_enabled</name>=true</expr>;</expr_stmt><expr_stmt><expr><name>retracted</name>=false</expr>;</expr_stmt><break>break;</break>
          </case><default>default:
            <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_UNKNOWN_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
      }</block></then></if>

    }</block><break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// FWRETRACT</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    </case><case>case <expr>218</expr>: <comment type="line">// M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</comment>
    <block>{
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>218</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>       
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_HOTEND_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>tmp_extruder</name> = 0</expr>;</init> <condition><expr><name>tmp_extruder</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr><name>tmp_extruder</name>++</expr></incr>)
      <block>{
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></for>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block><break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>220</expr>: <comment type="line">// M220 S&lt;factor in percent&gt;- set speed factor override percentage</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>feedmultiply</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
    }</block>
    <break>break;</break>
    </case><case>case <expr>221</expr>: <comment type="line">// M221 S&lt;factor in percent&gt;- set extrude factor override percentage</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>extrudemultiply</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
    }</block>
    <break>break;</break>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUM_SERVOS</name> &gt; 0</expr></cpp:if>
    </case><case>case <expr>280</expr>: <comment type="line">// M280 - set servo position absolute. P: servo index, S: angle or microseconds</comment>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>servo_index</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>servo_position</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>servo_index</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>servo_position</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name>servo_index</name> &gt;= 0) &amp;&amp; (<name>servo_index</name> &lt; <name>NUM_SERVOS</name>)</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>servos</name><index>[<expr><name>servo_index</name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name>servo_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Servo "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>servo_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>servo_index</name> &gt;= 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" Servo "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>servo_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>servos</name><index>[<expr><name>servo_index</name></expr>]</index></name>.<call><name>read</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// NUM_SERVOS &gt; 0</comment>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>LARGE_FLASH</name> == true &amp;&amp; ( <name>BEEPER</name> &gt; 0 || <call><name>defined</name><argument_list>(<argument><expr><name>ULTRALCD</name></expr></argument>)</argument_list></call> )</expr></cpp:if>
    </case><case>case <expr>300</expr>: <comment type="line">// M300</comment>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>beepS</name> <init>= <expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call> : 110</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>beepP</name> <init>= <expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call> : 1000</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>beepS</name> &gt; 0</expr>)</condition><then>
      <block>{
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BEEPER</name> &gt; 0</expr></cpp:if>
          <expr_stmt><expr><call><name>tone</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>, <argument><expr><name>beepS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>beepP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>noTone</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ULTRALCD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
          <expr_stmt><expr><call><name>lcd_buzz</name><argument_list>(<argument><expr><name>beepS</name></expr></argument>, <argument><expr><name>beepP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>beepP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// M300</comment>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
    </case><case>case <expr>301</expr>: <comment type="line">// M301</comment>
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Kp</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Ki</name> = <call><name>scalePID_i</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Kd</name> = <call><name>scalePID_d</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PID_ADD_EXTRUSION_RATE</name></cpp:ifdef>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Kc</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>updatePID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" p:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>Kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" i:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_i</name><argument_list>(<argument><expr><name>Ki</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" d:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_d</name><argument_list>(<argument><expr><name>Kd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PID_ADD_EXTRUSION_RATE</name></cpp:ifdef>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" c:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//Kc does not have scaling applied above, or in resetting defaults</comment>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>Kc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
    </case><case>case <expr>304</expr>: <comment type="line">// M304</comment>
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bedKp</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bedKi</name> = <call><name>scalePID_i</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bedKd</name> = <call><name>scalePID_d</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>updatePID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" p:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>bedKp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" i:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_i</name><argument_list>(<argument><expr><name>bedKi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" d:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_d</name><argument_list>(<argument><expr><name>bedKd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>
    </case><case>case <expr>240</expr>: <comment type="line">// M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/</comment>
     <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PHOTOGRAPH_PIN</name> &gt; -1</expr></cpp:if>
        <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>NUM_PULSES</name><init>=<expr>16</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>PULSE_LENGTH</name><init>=<expr>0.01524</expr></init></decl>;</decl_stmt>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_PULSES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>7.33</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_PULSES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
          <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
     }</block>
    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOGLCD</name></cpp:ifdef>
    </case><case>case <expr>250</expr>: <comment type="line">// M250  Set LCD contrast value: C&lt;value&gt; (value 0..63)</comment>
     <block>{
    <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
     <expr_stmt><expr><call><name>lcd_setcontrast</name><argument_list>( <argument><expr>((<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call>)&amp;63</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"lcd contrast value: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>lcd_contrast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
     }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PREVENT_DANGEROUS_EXTRUDE</name></cpp:ifdef>
    </case><case>case <expr>302</expr>: <comment type="line">// allow cold extrudes, or set the minimum extrude temperature</comment>
    <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>temp</name> <init>= <expr>.0</expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>temp</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>set_extrude_min_temp</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>303</expr>: <comment type="line">// M303 PID autotune</comment>
    <block>{
      <decl_stmt><decl><type><name>float</name></type> <name>temp</name> <init>= <expr>150.0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr>5</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>e</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>e</name>&lt;0</expr>)</condition><then>
          <expr_stmt><expr><name>temp</name>=70</expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>temp</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>c</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>PID_autotune</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>400</expr>: <comment type="line">// M400 finish all moves</comment>
    <block>{
      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>500</expr>: <comment type="line">// M500 Store settings in EEPROM</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_StoreSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>501</expr>: <comment type="line">// M501 Read settings from EEPROM</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_RetrieveSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>502</expr>: <comment type="line">// M502 Revert to default settings</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_ResetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>503</expr>: <comment type="line">// M503 print settings currently in memory</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_PrintSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</name></cpp:ifdef>
    </case><case>case <expr>540</expr>:
    <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>abort_on_endstop_hit</name> = <call><name>code_value</name><argument_list>()</argument_list></call> &gt; 0</expr>;</expr_stmt></then></if>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGEENABLE</name></cpp:ifdef>
    </case><case>case <expr>600</expr>: <comment type="line">//Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</comment>
    <block>{
        <decl_stmt><decl><type><name>float</name></type> <name><name>target</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name><name>lastpos</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="line">//retract by E</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_FIRSTRETRACT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <name>FILAMENTCHANGE_FIRSTRETRACT</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//lift Z</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_ZADD</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+= <name>FILAMENTCHANGE_ZADD</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//move xy</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_XPOS</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>= <name>FILAMENTCHANGE_XPOS</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_YPOS</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>= <name>FILAMENTCHANGE_YPOS</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>

        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_FINALRETRACT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <name>FILAMENTCHANGE_FINALRETRACT</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>

        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//finish moves</comment>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//disable extruder steppers so filament can be removed</comment>
        <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_FILAMENTCHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>cnt</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr>!<call><name>lcd_clicked</name><argument_list>()</argument_list></call></expr>)</condition><block>{
          <expr_stmt><expr><name>cnt</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><name>cnt</name>==0</expr>)</condition><then>
          <block>{
          <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BEEPER</name> &gt; 0</expr></cpp:if>
            <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>,<argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <expr_stmt><expr><call><name>lcd_buzz</name><argument_list>(<argument><expr>1000/6</expr></argument>,<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          }</block></then></if>
        }</block></while>

        <comment type="line">//return to normal</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= -<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_FINALRETRACT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=(-1)*<name>FILAMENTCHANGE_FINALRETRACT</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">//the long retract of L is compensated by manual filament feeding</comment>
        <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//should do nothing</comment>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//move xy back</comment>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//move z back</comment>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//final untretract</comment>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FILAMENTCHANGEENABLE</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
    </case><case>case <expr>605</expr>: <comment type="line">// Set dual x-carriage movement mode:</comment>
              <comment type="line">//    M605 S0: Full control mode. The slicer has full control over x-carriage movement</comment>
              <comment type="line">//    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement</comment>
              <comment type="line">//    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn</comment>
              <comment type="line">//                         millimeters x-offset and an optional differential hotend temperature of </comment>
              <comment type="line">//                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate</comment>
              <comment type="line">//                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.</comment>
              <comment type="line">//</comment>
              <comment type="line">//    Note: the X axis should be homed after changing dual x-carriage mode.</comment>
    <block>{
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>dual_x_carriage_mode</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>duplicate_extruder_x_offset</name> = <call><name>max</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>X2_MIN_POS</name> - <call><name>x_home_pos</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>duplicate_extruder_temp_offset</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
            
          <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_HOTEND_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>duplicate_extruder_x_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> != <name>DXC_FULL_CONTROL_MODE</name> &amp;&amp; <name>dual_x_carriage_mode</name> != <name>DXC_AUTO_PARK_MODE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>dual_x_carriage_mode</name> = <name>DEFAULT_DUAL_X_CARRIAGE_MODE</name></expr>;</expr_stmt>
        }</block></then></if></else></if>
        
        <expr_stmt><expr><name>active_extruder_parked</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//DUAL_X_CARRIAGE         </comment>

    </case><case>case <expr>907</expr>: <comment type="line">// M907 Set digital trimpot motor current using axis codes.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIGIPOTSS_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>DIGIPOTSS_PIN</name> &gt; -1</expr></cpp:if>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;=4</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>908</expr>: <comment type="line">// M908 Control digital trimpot directly.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIGIPOTSS_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>DIGIPOTSS_PIN</name> &gt; -1</expr></cpp:if>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>channel</name></decl>,<decl><type ref="prev"/><name>current</name></decl>;</decl_stmt>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>channel</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>current</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>digitalPotWrite</name><argument_list>(<argument><expr><name>channel</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>350</expr>: <comment type="line">// M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MS1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MS1_PIN</name> &gt; -1</expr></cpp:if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;=4</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><call><name>microstep_mode</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_mode</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr>(<name>uint8_t</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_mode</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>microstep_readings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>351</expr>: <comment type="line">// M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MS1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MS1_PIN</name> &gt; -1</expr></cpp:if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <switch>switch<condition>(<expr>(<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr>)</condition>
      <block>{
        <case>case <expr>1</expr>:
          <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </case><case>case <expr>2</expr>:
          <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr>-1</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr>-1</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
      </case>}</block></switch></then></if>
      <expr_stmt><expr><call><name>microstep_readings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>999</expr>: <comment type="line">// M999: Restart after being stopped</comment>
      <expr_stmt><expr><name>Stopped</name> = false</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lcd_reset_alert_level</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>gcode_LastN</name> = <name>Stopped_gcode_LastN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </case>}</block>
  </case>}</block></switch>

  <else>else <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>tmp_extruder</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>tmp_extruder</name> &gt;= <name>EXTRUDERS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"T"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>MSG_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <decl_stmt><decl><type><name>boolean</name></type> <name>make_move</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>make_move</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>next_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>next_feedrate</name> &gt; 0.0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>feedrate</name> = <name>next_feedrate</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
      <if>if<condition>(<expr><name>tmp_extruder</name> != <name>active_extruder</name></expr>)</condition><then> <block>{
        <comment type="line">// Save current position to return to after applying extruder offset</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_AUTO_PARK_MODE</name> &amp;&amp; <name>Stopped</name> == false &amp;&amp; 
            (<name>delayed_move_time</name> != 0 || <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> != <call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <comment type="line">// Park old head: 1) raise 2) move to park position 3) lower</comment>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>TOOLCHANGE_PARK_ZLIFT</name></expr></argument>, 
                <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>TOOLCHANGE_PARK_ZLIFT</name></expr></argument>, 
                <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, 
                <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        
        <comment type="line">// apply Y &amp; Z extruder offset (x offset is already used in determining home pos)</comment>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> -
                     <name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>active_extruder</name></expr>]</index></name> +
                     <name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> -
                     <name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>active_extruder</name></expr>]</index></name> +
                     <name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr>;</expr_stmt>
                     
        <expr_stmt><expr><name>active_extruder</name> = <name>tmp_extruder</name></expr>;</expr_stmt>

        <comment type="line">// This function resets the max/min values - the current position may be overwritten below.</comment>
        <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_FULL_CONTROL_MODE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>inactive_extruder_x_pos</name></expr>;</expr_stmt> 
          <expr_stmt><expr><name>inactive_extruder_x_pos</name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>active_extruder_parked</name> = (<name>active_extruder</name> == 0)</expr>;</expr_stmt> <comment type="line">// this triggers the second extruder to move into the duplication position</comment>
          <if>if <condition>(<expr><name>active_extruder</name> == 0 || <name>active_extruder_parked</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>inactive_extruder_x_pos</name></expr>;</expr_stmt></then> 
          <else>else
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name>duplicate_extruder_x_offset</name></expr>;</expr_stmt></else></if> 
          <expr_stmt><expr><name>inactive_extruder_x_pos</name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt> 
        }</block></then>
        <else>else
        <block>{
          <comment type="line">// record raised toolhead position for use by unpark</comment>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> += <name>TOOLCHANGE_UNPARK_ZLIFT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>active_extruder_parked</name> = true</expr>;</expr_stmt>
          <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
        }</block></else></if></else></if>
        
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>    
        <comment type="line">// Offset extruder (only by XY)</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
           <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> -
                                 <name><name>extruder_offset</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>active_extruder</name></expr>]</index></name> +
                                 <name><name>extruder_offset</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <comment type="line">// Set the new active extruder and position</comment>
        <expr_stmt><expr><name>active_extruder</name> = <name>tmp_extruder</name></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//else DUAL_X_CARRIAGE</comment>
        <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// Move to the old position if 'F' was in the parameters</comment>
        <if>if<condition>(<expr><name>make_move</name> &amp;&amp; <name>Stopped</name> == false</expr>)</condition><then> <block>{
           <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_ACTIVE_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>(<name>int</name>)<name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>

  <else>else
  <block>{
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_UNKNOWN_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else>

  <expr_stmt><expr><call><name>ClearToSend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>

<function><type><name>void</name></type> <name>FlushSerialRequestResend</name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">//char cmdbuffer[bufindr][100]="Resend:";</comment>
  <expr_stmt><expr><call><name><name>MYSERIAL</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_RESEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>gcode_LastN</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ClearToSend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>ClearToSend</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <if>if<condition>(<expr><name><name>fromsd</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr>)</condition><then>
    <return>return;</return></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>get_coordinates</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>bool</name></type> <name><name>seen</name><index>[<expr>4</expr>]</index></name><init>=<expr><block>{<expr>false</expr>,<expr>false</expr>,<expr>false</expr>,<expr>false</expr>}</block></expr></init></decl>;</decl_stmt>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>float</name>)<call><name>code_value</name><argument_list>()</argument_list></call> + (<name><name>axis_relative_modes</name><index>[<expr><name>i</name></expr>]</index></name> || <name>relative_mode</name>)*<name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name>=true</expr>;</expr_stmt>
    }</block></then>
    <else>else <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if> <comment type="line">//Are these else lines really needed?</comment>
  }</block></for>
  <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>next_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>next_feedrate</name> &gt; 0.0</expr>)</condition><then> <expr_stmt><expr><name>feedrate</name> = <name>next_feedrate</name></expr>;</expr_stmt></then></if>
  }</block></then></if>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
  <if>if<condition>(<expr><name>autoretract_enabled</name></expr>)</condition><then>
  <if>if<condition>( <expr>!(<name><name>seen</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> || <name><name>seen</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> || <name><name>seen</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>) &amp;&amp; <name><name>seen</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>echange</name><init>=<expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>-<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
    <if>if<condition>(<expr><name>echange</name>&lt;-<name>MIN_RETRACT</name></expr>)</condition><then> <comment type="line">//retract</comment>
    <block>{
      <if>if<condition>(<expr>!<name>retracted</name></expr>)</condition><then>
      <block>{

      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+=<name>retract_zlift</name></expr>;</expr_stmt> <comment type="line">//not sure why chaninging current_position negatively does not work.</comment>
      <comment type="line">//if slicer retracted by echange=-1mm and you want to retract 3mm, corrrectede=-2mm additionally</comment>
      <decl_stmt><decl><type><name>float</name></type> <name>correctede</name><init>=<expr>-<name>echange</name>-<name>retract_length</name></expr></init></decl>;</decl_stmt>
      <comment type="line">//to generate the additional steps, not the destination is changed, but inversely the current position</comment>
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=-<name>correctede</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedrate</name>=<name>retract_feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>retracted</name>=true</expr>;</expr_stmt>
      }</block></then></if>

    }</block></then>
    <else>else
      <if>if<condition>(<expr><name>echange</name>&gt;<name>MIN_RETRACT</name></expr>)</condition><then> <comment type="line">//retract_recover</comment>
    <block>{
      <if>if<condition>(<expr><name>retracted</name></expr>)</condition><then>
      <block>{
      <comment type="line">//current_position[Z_AXIS]+=-retract_zlift;</comment>
      <comment type="line">//if slicer retracted_recovered by echange=+1mm and you want to retract_recover 3mm, corrrectede=2mm additionally</comment>
      <decl_stmt><decl><type><name>float</name></type> <name>correctede</name><init>=<expr>-<name>echange</name>+1*<name>retract_length</name>+<name>retract_recover_length</name></expr></init></decl>;</decl_stmt> <comment type="line">//total unretract=retract_length+retract_recover_length[surplus]</comment>
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=<name>correctede</name></expr>;</expr_stmt> <comment type="line">//to generate the additional steps, not the destination is changed, but inversely the current position</comment>
      <expr_stmt><expr><name>feedrate</name>=<name>retract_recover_feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>retracted</name>=false</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if></else></if>

  }</block></then></if></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FWRETRACT</comment>
}</block></function>

<function><type><name>void</name></type> <name>get_arc_coordinates</name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SF_ARC_FIX</name></cpp:ifdef>
   <decl_stmt><decl><type><name>bool</name></type> <name>relative_mode_backup</name> <init>= <expr><name>relative_mode</name></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>relative_mode</name> = true</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   <expr_stmt><expr><call><name>get_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SF_ARC_FIX</name></cpp:ifdef>
   <expr_stmt><expr><name>relative_mode</name>=<name>relative_mode_backup</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

   <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>0</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   }</block></then>
   <else>else <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>0</expr>]</index></name> = 0.0</expr>;</expr_stmt>
   }</block></else></if>
   <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'J'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>1</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   }</block></then>
   <else>else <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>1</expr>]</index></name> = 0.0</expr>;</expr_stmt>
   }</block></else></if>
}</block></function>

<function><type><name>void</name></type> <name>clamp_to_software_endstops</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>target</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>min_software_endstops</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> &lt; <name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> &lt; <name><name>min_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>min_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &lt; <name><name>min_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>min_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>max_software_endstops</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> &gt; <name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> &gt; <name><name>max_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &gt; <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
<function><type><name>void</name></type> <name>calculate_delta</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>cartesian</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list> 
<block>{
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>sqrt</name><argument_list>(<argument><expr><name>DELTA_DIAGONAL_ROD_2</name>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower1_x</name>-<name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower1_y</name>-<name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                       )</argument_list></call> + <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <call><name>sqrt</name><argument_list>(<argument><expr><name>DELTA_DIAGONAL_ROD_2</name>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower2_x</name>-<name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower2_y</name>-<name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                       )</argument_list></call> + <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <call><name>sqrt</name><argument_list>(<argument><expr><name>DELTA_DIAGONAL_ROD_2</name>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower3_x</name>-<name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower3_y</name>-<name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                       )</argument_list></call> + <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
                       

  <comment type="block">/*
  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);

  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
  */</comment>
  <comment type="block">/*
  if ((delta_tmp[X_AXIS] &gt; 0) and (delta_tmp[Y_AXIS] &gt; 0) and (delta_tmp[Z_AXIS] &gt; 0))
    {
      delta[X_AXIS] = delta_tmp[X_AXIS];
      delta[Y_AXIS] = delta_tmp[Y_AXIS];
      delta[Z_AXIS] = delta_tmp[Z_AXIS];
    } else SERIAL_ECHOLN("ERROR: Invalid delta coordinates!");
*/</comment>
}</block></function>


<comment type="line">// Adjust print surface height by linear interpolation over the bed_level array.</comment>
<function><type><name>void</name></type> <name>adjust_delta</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>cartesian</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>float</name></type> <name>grid_x</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr>-2.999</expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr>2.999</expr></argument>, <argument><expr><name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> / <name>AUTOLEVEL_GRID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>grid_y</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr>-2.999</expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr>2.999</expr></argument>, <argument><expr><name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> / <name>AUTOLEVEL_GRID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>floor_x</name> <init>= <expr><call><name>floor</name><argument_list>(<argument><expr><name>grid_x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>floor_y</name> <init>= <expr><call><name>floor</name><argument_list>(<argument><expr><name>grid_y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>ratio_x</name> <init>= <expr><name>grid_x</name> - <name>floor_x</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>ratio_y</name> <init>= <expr><name>grid_y</name> - <name>floor_y</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>z1</name> <init>= <expr><name><name>bed_level</name><index>[<expr><name>floor_x</name>+3</expr>]</index><index>[<expr><name>floor_y</name>+3</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>z2</name> <init>= <expr><name><name>bed_level</name><index>[<expr><name>floor_x</name>+3</expr>]</index><index>[<expr><name>floor_y</name>+4</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>z3</name> <init>= <expr><name><name>bed_level</name><index>[<expr><name>floor_x</name>+4</expr>]</index><index>[<expr><name>floor_y</name>+3</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>z4</name> <init>= <expr><name><name>bed_level</name><index>[<expr><name>floor_x</name>+4</expr>]</index><index>[<expr><name>floor_y</name>+4</expr>]</index></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>left</name> <init>= <expr>(1-<name>ratio_y</name>)*<name>z1</name> + <name>ratio_y</name>*<name>z2</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>right</name> <init>= <expr>(1-<name>ratio_y</name>)*<name>z3</name> + <name>ratio_y</name>*<name>z4</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>offset</name> <init>= <expr>(1-<name>ratio_x</name>)*<name>left</name> + <name>ratio_x</name>*<name>right</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> += <name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> += <name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> += <name>offset</name></expr>;</expr_stmt>

  <comment type="block">/*
  SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);
  SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);
  SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);
  SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);
  SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);
  SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);
  SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);
  SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);
  SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);
  SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);
  SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);
  SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);
  SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);
  */</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>prepare_move_raw</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
       <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>,
       <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name></type> <name>prepare_move</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>clamp_to_software_endstops</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name><name>difference</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>difference</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <decl_stmt><decl><type><name>float</name></type> <name>cartesian_mm</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> +
                            <call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> +
                            <call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cartesian_mm</name> &lt; 0.000001</expr>)</condition><then> <block>{ <expr_stmt><expr><name>cartesian_mm</name> = <call><name>abs</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
  <if>if <condition>(<expr><name>cartesian_mm</name> &lt; 0.000001</expr>)</condition><then> <block>{ <return>return;</return> }</block></then></if>
  <decl_stmt><decl><type><name>float</name></type> <name>seconds</name> <init>= <expr>6000 * <name>cartesian_mm</name> / <name>feedrate</name> / <name>feedmultiply</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>steps</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>DELTA_SEGMENTS_PER_SECOND</name> * <name>seconds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);</comment>
  <comment type="line">// SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);</comment>
  <comment type="line">// SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);</comment>
  <for>for (<init><decl><type><name>int</name></type> <name>s</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>s</name> &lt;= <name>steps</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>fraction</name> <init>= <expr><call><name>float</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> / <call><name>float</name><argument_list>(<argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>difference</name><index>[<expr><name>i</name></expr>]</index></name> * <name>fraction</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>adjust_delta</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
                     <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>,
                     <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
  <if>if <condition>(<expr><name>active_extruder_parked</name></expr>)</condition><then>
  <block>{
    <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>active_extruder</name> == 0</expr>)</condition><then>
    <block>{
      <comment type="line">// move duplicate extruder into correct duplication position.</comment>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name>inactive_extruder_x_pos</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name>duplicate_extruder_x_offset</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, 
          <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>extruder_duplication_enabled</name> = true</expr>;</expr_stmt>
      <expr_stmt><expr><name>active_extruder_parked</name> = false</expr>;</expr_stmt>
    }</block></then>  
    <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_AUTO_PARK_MODE</name></expr>)</condition><then> <comment type="line">// handle unparking of head</comment>
    <block>{
      <if>if <condition>(<expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name> == <name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>)</condition><then>
      <block>{
        <comment type="line">// this is a travel move - skit it but keep track of current position (so that it can later</comment>
        <comment type="line">// be used as start of first non-travel move)</comment>
        <if>if <condition>(<expr><name>delayed_move_time</name> != 0xFFFFFFFFUL</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
          <if>if <condition>(<expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &gt; <name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>delayed_move_time</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
      <comment type="line">// unpark extruder: 1) raise, 2) move into starting XY position, 3) lower</comment>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>raised_parked_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>raised_parked_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,    <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, 
          <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name><name>max_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>max_feedrate</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, 
          <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>active_extruder_parked</name> = false</expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//DUAL_X_CARRIAGE</comment>

  <comment type="line">// Do not use feedmultiply for E or Z only moves</comment>
  <if>if<condition>( <expr>(<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> == <name><name>destination</name> <index>[<expr><name>X_AXIS</name></expr>]</index></name>) &amp;&amp; (<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> == <name><name>destination</name> <index>[<expr><name>Y_AXIS</name></expr>]</index></name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//else DELTA</comment>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name></type> <name>prepare_arc_move</name><parameter_list>(<param><decl><type><name>char</name></type> <name>isclockwise</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>float</name></type> <name>r</name> <init>= <expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>offset</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Compute arc radius for mc_arc</comment>

  <comment type="line">// Trace the arc</comment>
  <expr_stmt><expr><call><name>mc_arc</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>X_AXIS</name></expr></argument>, <argument><expr><name>Y_AXIS</name></expr></argument>, <argument><expr><name>Z_AXIS</name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>isclockwise</name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// As far as the parser is concerned, the position is now == target. In reality the</comment>
  <comment type="line">// motion control system might still be processing the action and the real tool position</comment>
  <comment type="line">// in any intermediate location.</comment>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CONTROLLERFAN_PIN</name> &gt; -1</expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONTROLLERFAN_PIN</name> == <name>FAN_PIN</name></expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "You cannot set CONTROLLERFAN_PIN equal to FAN_PIN"</cpp:error>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lastMotor</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">//Save the time for when a motor was turned on last</comment>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lastMotorCheck</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>controllerFan</name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>lastMotorCheck</name>) &gt;= 2500</expr>)</condition><then> <comment type="line">//Not a time critical function, so we only check every 2500ms</comment>
  <block>{
    <expr_stmt><expr><name>lastMotorCheck</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr>!<call><name>READ</name><argument_list>(<argument><expr><name>X_ENABLE_PIN</name></expr></argument>)</argument_list></call> || !<call><name>READ</name><argument_list>(<argument><expr><name>Y_ENABLE_PIN</name></expr></argument>)</argument_list></call> || !<call><name>READ</name><argument_list>(<argument><expr><name>Z_ENABLE_PIN</name></expr></argument>)</argument_list></call>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>E2_ENABLE_PIN</name></expr></argument>)</argument_list></call>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDER</name> &gt; 1</expr></cpp:if>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X2_ENABLE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X2_ENABLE_PIN</name> &gt; -1</expr></cpp:if>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>X2_ENABLE_PIN</name></expr></argument>)</argument_list></call>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>E1_ENABLE_PIN</name></expr></argument>)</argument_list></call>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>E0_ENABLE_PIN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">//If any of the drivers are enabled...</comment>
    <block>{
      <expr_stmt><expr><name>lastMotor</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">//... set time to NOW so the fan will turn on</comment>
    }</block></then></if>

    <if>if <condition>(<expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>lastMotor</name>) &gt;= (<name>CONTROLLERFAN_SECS</name>*1000UL) || <name>lastMotor</name> == 0</expr>)</condition><then> <comment type="line">//If the last time any driver was enabled, is longer since than CONTROLLERSEC...</comment>
    <block>{
        <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
        <comment type="line">// allows digital or PWM fan output to be used (see M42 handling)</comment>
        <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr><name>CONTROLLERFAN_SPEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr><name>CONTROLLERFAN_SPEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>manage_inactivity</name><parameter_list>()</parameter_list>
<block>{
  <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_cmd</name>) &gt;  <name>max_inactive_time</name></expr> )</condition><then>
    <if>if<condition>(<expr><name>max_inactive_time</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>kill</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if></then></if>
  <if>if<condition>(<expr><name>stepper_inactive_time</name></expr>)</condition><then>  <block>{
    <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_cmd</name>) &gt;  <name>stepper_inactive_time</name></expr> )</condition><then>
    <block>{
      <if>if<condition>(<expr><call><name>blocks_queued</name><argument_list>()</argument_list></call> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>KILL_PIN</name> &gt; -1</expr></cpp:if>
    <if>if<condition>( <expr>0 == <call><name>READ</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call></expr> )</condition><then>
      <expr_stmt><expr><call><name>kill</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CONTROLLERFAN_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>controllerFan</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">//Check if fan should be turned on to cool stepper drivers down</comment>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXTRUDER_RUNOUT_PREVENT</name></cpp:ifdef>
    <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_cmd</name>) &gt;  <name>EXTRUDER_RUNOUT_SECONDS</name>*1000</expr> )</condition><then>
    <if>if<condition>(<expr><call><name>degHotend</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call>&gt;<name>EXTRUDER_RUNOUT_MINTEMP</name></expr>)</condition><then>
    <block>{
     <decl_stmt><decl><type><name>bool</name></type> <name>oldstatus</name><init>=<expr><call><name>READ</name><argument_list>(<argument><expr><name>E0_ENABLE_PIN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>enable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>float</name></type> <name>oldepos</name><init>=<expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>float</name></type> <name>oldedes</name><init>=<expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+<name>EXTRUDER_RUNOUT_EXTRUDE</name>*<name>EXTRUDER_RUNOUT_ESTEPS</name>/<name><name>axis_steps_per_unit</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name>EXTRUDER_RUNOUT_SPEED</name>/60.*<name>EXTRUDER_RUNOUT_ESTEPS</name>/<name><name>axis_steps_per_unit</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name>oldepos</name></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name>oldedes</name></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name>oldepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>previous_millis_cmd</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>E0_ENABLE_PIN</name></expr></argument>,<argument><expr><name>oldstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DUAL_X_CARRIAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="line">// handle delayed move timeout</comment>
    <if>if <condition>(<expr><name>delayed_move_time</name> != 0 &amp;&amp; (<call><name>millis</name><argument_list>()</argument_list></call> - <name>delayed_move_time</name>) &gt; 1000 &amp;&amp; <name>Stopped</name> == false</expr>)</condition><then>
    <block>{
      <comment type="line">// travel moves have been received so enact them</comment>
      <expr_stmt><expr><name>delayed_move_time</name> = 0xFFFFFFFFUL</expr>;</expr_stmt> <comment type="line">// force moves to be done</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>,<argument><expr><name>current_position</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <expr_stmt><expr><call><name>check_axes_activity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>kill</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>cli</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Stop interrupts</comment>
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:if>
  <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>,<argument><expr><name>INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_KILLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_KILLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>suicide</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>(<expr>1</expr>)</condition> <block>{ <comment type="block">/* Intentionally left empty */</comment> }</block></while> <comment type="line">// Wait for reset</comment>
}</block></function>

<function><type><name>void</name></type> <name>Stop</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>Stopped</name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name>Stopped_gcode_LastN</name> = <name>gcode_LastN</name></expr>;</expr_stmt> <comment type="line">// Save last g_code for restart</comment>
    <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>bool</name></type> <name>IsStopped</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>Stopped</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAST_PWM_FAN</name></cpp:ifdef>
<function><type><name>void</name></type> <name>setPwmFrequency</name><parameter_list>(<param><decl><type><name>uint8_t</name></type> <name>pin</name></decl></param>, <param><decl><type><name>int</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>val</name> &amp;= 0x07</expr>;</expr_stmt>
  <switch>switch<condition>(<expr><call><name>digitalPinToTimer</name><argument_list>(<argument><expr><name>pin</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR0A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <case>case <expr><name>TIMER0A</name></expr>:
    </case><case>case <expr><name>TIMER0B</name></expr>:
<comment type="line">//         TCCR0B &amp;= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));</comment>
<comment type="line">//         TCCR0B |= val;</comment>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR1A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER1A</name></expr>:
    </case><case>case <expr><name>TIMER1B</name></expr>:
<comment type="line">//         TCCR1B &amp;= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</comment>
<comment type="line">//         TCCR1B |= val;</comment>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER2</name></expr>:
    </case><case>case <expr><name>TIMER2</name></expr>:
         <expr_stmt><expr><name>TCCR2</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS10</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS11</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS12</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR2</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR2A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER2A</name></expr>:
    </case><case>case <expr><name>TIMER2B</name></expr>:
         <expr_stmt><expr><name>TCCR2B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS20</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS21</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS22</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR2B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR3A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER3A</name></expr>:
    </case><case>case <expr><name>TIMER3B</name></expr>:
    </case><case>case <expr><name>TIMER3C</name></expr>:
         <expr_stmt><expr><name>TCCR3B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS30</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS31</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS32</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR3B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR4A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER4A</name></expr>:
    </case><case>case <expr><name>TIMER4B</name></expr>:
    </case><case>case <expr><name>TIMER4C</name></expr>:
         <expr_stmt><expr><name>TCCR4B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS40</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS41</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS42</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR4B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR5A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER5A</name></expr>:
    </case><case>case <expr><name>TIMER5B</name></expr>:
    </case><case>case <expr><name>TIMER5C</name></expr>:
         <expr_stmt><expr><name>TCCR5B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS50</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS51</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS52</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR5B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  </case>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FAST_PWM_FAN</comment>

<function><type><name>bool</name></type> <name>setTargetedHotend</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>tmp_extruder</name> = <name>active_extruder</name></expr>;</expr_stmt>
  <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>tmp_extruder</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>tmp_extruder</name> &gt;= <name>EXTRUDERS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <switch>switch<condition>(<expr><name>code</name></expr>)</condition><block>{
        <case>case <expr>104</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M104_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>105</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M105_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>109</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M109_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>218</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M218_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
      </case>}</block></switch>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>true</expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr>false</expr>;</return>
}</block></function></block></function>

</unit>
