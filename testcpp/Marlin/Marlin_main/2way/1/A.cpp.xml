<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="testcpp/Marlin/Marlin_main/2way/1/A.cpp"><comment type="block">/* -*- c++ -*- */</comment>

<comment type="block">/*
    Reprap firmware based on Sprinter and grbl.
 Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/*
 This firmware is a mashup between Sprinter and grbl.
  (https://github.com/kliment/Sprinter)
  (https://github.com/simen/grbl/tree)

 It has preliminary support for Matthew Roberts advance algorithm
    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Marlin.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vector_3.h"</cpp:file></cpp:include>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTO_BED_LEVELING_GRID</name></cpp:ifdef>
    <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"qr_solve.h"</cpp:file></cpp:include>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_AUTO_BED_LEVELING</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ultralcd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stepper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"temperature.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"motion_control.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cardreader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"watchdog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ConfigurationStore.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pins_arduino.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"math.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BLINKM</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"BlinkM.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Wire.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUM_SERVOS</name> &gt; 0</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Servo.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIGIPOTSS_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>DIGIPOTSS_PIN</name> &gt; -1</expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;SPI.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_STRING</name></cpp:macro>  <cpp:value>"1.0.2"</cpp:value></cpp:define>

<comment type="line">// look here for descriptions of G-codes: http://linuxcnc.org/handbook/gcode/g-code.html</comment>
<comment type="line">// http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes</comment>

<comment type="line">//Implemented Codes</comment>
<comment type="line">//-------------------</comment>
<comment type="line">// G0  -&gt; G1</comment>
<comment type="line">// G1  - Coordinated Movement X Y Z E</comment>
<comment type="line">// G2  - CW ARC</comment>
<comment type="line">// G3  - CCW ARC</comment>
<comment type="line">// G4  - Dwell S&lt;seconds&gt; or P&lt;milliseconds&gt;</comment>
<comment type="line">// G10 - retract filament according to settings of M207</comment>
<comment type="line">// G11 - retract recover filament according to settings of M208</comment>
<comment type="line">// G28 - Home all Axis</comment>
<comment type="line">// G29 - Detailed Z-Probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.</comment>
<comment type="line">// G30 - Single Z Probe, probes bed at current XY location.</comment>
<comment type="line">// G31 - Dock sled (Z_PROBE_SLED only)</comment>
<comment type="line">// G32 - Undock sled (Z_PROBE_SLED only)</comment>
<comment type="line">// G90 - Use Absolute Coordinates</comment>
<comment type="line">// G91 - Use Relative Coordinates</comment>
<comment type="line">// G92 - Set current position to coordinates given</comment>

<comment type="line">// M Codes</comment>
<comment type="line">// M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)</comment>
<comment type="line">// M1   - Same as M0</comment>
<comment type="line">// M17  - Enable/Power all stepper motors</comment>
<comment type="line">// M18  - Disable all stepper motors; same as M84</comment>
<comment type="line">// M20  - List SD card</comment>
<comment type="line">// M21  - Init SD card</comment>
<comment type="line">// M22  - Release SD card</comment>
<comment type="line">// M23  - Select SD file (M23 filename.g)</comment>
<comment type="line">// M24  - Start/resume SD print</comment>
<comment type="line">// M25  - Pause SD print</comment>
<comment type="line">// M26  - Set SD position in bytes (M26 S12345)</comment>
<comment type="line">// M27  - Report SD print status</comment>
<comment type="line">// M28  - Start SD write (M28 filename.g)</comment>
<comment type="line">// M29  - Stop SD write</comment>
<comment type="line">// M30  - Delete file from SD (M30 filename.g)</comment>
<comment type="line">// M31  - Output time since last M109 or SD card start to serial</comment>
<comment type="line">// M32  - Select file and start SD print (Can be used _while_ printing from SD card files):</comment>
<comment type="line">//        syntax "M32 /path/filename#", or "M32 S&lt;startpos bytes&gt; !filename#"</comment>
<comment type="line">//        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).</comment>
<comment type="line">//        The '#' is necessary when calling from within sd files, as it stops buffer prereading</comment>
<comment type="line">// M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.</comment>
<comment type="line">// M80  - Turn on Power Supply</comment>
<comment type="line">// M81  - Turn off Power Supply</comment>
<comment type="line">// M82  - Set E codes absolute (default)</comment>
<comment type="line">// M83  - Set E codes relative while in Absolute Coordinates (G90) mode</comment>
<comment type="line">// M84  - Disable steppers until next move,</comment>
<comment type="line">//        or use S&lt;seconds&gt; to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.</comment>
<comment type="line">// M85  - Set inactivity shutdown timer with parameter S&lt;seconds&gt;. To disable set zero (default)</comment>
<comment type="line">// M92  - Set axis_steps_per_unit - same syntax as G92</comment>
<comment type="line">// M104 - Set extruder target temp</comment>
<comment type="line">// M105 - Read current temp</comment>
<comment type="line">// M106 - Fan on</comment>
<comment type="line">// M107 - Fan off</comment>
<comment type="line">// M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating</comment>
<comment type="line">//        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling</comment>
<comment type="line">//        IF AUTOTEMP is enabled, S&lt;mintemp&gt; B&lt;maxtemp&gt; F&lt;factor&gt;. Exit autotemp by any M109 without F</comment>
<comment type="line">// M112 - Emergency stop</comment>
<comment type="line">// M114 - Output current position to serial port</comment>
<comment type="line">// M115 - Capabilities string</comment>
<comment type="line">// M117 - display message</comment>
<comment type="line">// M119 - Output Endstop status to serial port</comment>
<comment type="line">// M126 - Solenoid Air Valve Open (BariCUDA support by jmil)</comment>
<comment type="line">// M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)</comment>
<comment type="line">// M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)</comment>
<comment type="line">// M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)</comment>
<comment type="line">// M140 - Set bed target temp</comment>
<comment type="line">// M150 - Set BlinkM Color Output R: Red&lt;0-255&gt; U(!): Green&lt;0-255&gt; B: Blue&lt;0-255&gt; over i2c, G for green does not work.</comment>
<comment type="line">// M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating</comment>
<comment type="line">//        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling</comment>
<comment type="line">// M200 D&lt;millimeters&gt;- set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).</comment>
<comment type="line">// M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)</comment>
<comment type="line">// M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!</comment>
<comment type="line">// M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec</comment>
<comment type="line">// M204 - Set default acceleration: S normal moves T filament only moves (M204 S3000 T7000) in mm/sec^2  also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate</comment>
<comment type="line">// M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk</comment>
<comment type="line">// M206 - set additional homing offset</comment>
<comment type="line">// M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting</comment>
<comment type="line">// M208 - set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/sec]</comment>
<comment type="line">// M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</comment>
<comment type="line">// M218 - set hotend offset (in mm): T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</comment>
<comment type="line">// M220 S&lt;factor in percent&gt;- set speed factor override percentage</comment>
<comment type="line">// M221 S&lt;factor in percent&gt;- set extrude factor override percentage</comment>
<comment type="line">// M226 P&lt;pin number&gt; S&lt;pin state&gt;- Wait until the specified pin reaches the state required</comment>
<comment type="line">// M240 - Trigger a camera to take a photograph</comment>
<comment type="line">// M250 - Set LCD contrast C&lt;contrast value&gt; (value 0..63)</comment>
<comment type="line">// M280 - set servo position absolute. P: servo index, S: angle or microseconds</comment>
<comment type="line">// M300 - Play beep sound S&lt;frequency Hz&gt; P&lt;duration ms&gt;</comment>
<comment type="line">// M301 - Set PID parameters P I and D</comment>
<comment type="line">// M302 - Allow cold extrudes, or set the minimum extrude S&lt;temperature&gt;.</comment>
<comment type="line">// M303 - PID relay autotune S&lt;temperature&gt; sets the target temperature. (default target temperature = 150C)</comment>
<comment type="line">// M304 - Set bed PID parameters P I and D</comment>
<comment type="line">// M400 - Finish all moves</comment>
<comment type="line">// M401 - Lower z-probe if present</comment>
<comment type="line">// M402 - Raise z-probe if present</comment>
<comment type="line">// M404 - N&lt;dia in mm&gt; Enter the nominal filament width (3mm, 1.75mm ) or will display nominal filament width without parameters</comment>
<comment type="line">// M405 - Turn on Filament Sensor extrusion control.  Optional D&lt;delay in cm&gt; to set delay in centimeters between sensor and extruder </comment>
<comment type="line">// M406 - Turn off Filament Sensor extrusion control </comment>
<comment type="line">// M407 - Displays measured filament diameter </comment>
<comment type="line">// M500 - stores parameters in EEPROM</comment>
<comment type="line">// M501 - reads parameters from EEPROM (if you need reset them after you changed them temporarily).</comment>
<comment type="line">// M502 - reverts to the default "factory settings".  You still need to store them in EEPROM afterwards if you want to.</comment>
<comment type="line">// M503 - print the current settings (from memory not from EEPROM)</comment>
<comment type="line">// M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)</comment>
<comment type="line">// M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</comment>
<comment type="line">// M665 - set delta configurations</comment>
<comment type="line">// M666 - set delta endstop adjustment</comment>
<comment type="line">// M605 - Set dual x-carriage movement mode: S&lt;mode&gt; [ X&lt;duplication x-offset&gt; R&lt;duplication temp offset&gt; ]</comment>
<comment type="line">// M907 - Set digital trimpot motor current using axis codes.</comment>
<comment type="line">// M908 - Control digital trimpot directly.</comment>
<comment type="line">// M350 - Set microstepping mode.</comment>
<comment type="line">// M351 - Toggle MS1 MS2 pins directly.</comment>

<comment type="line">// ************ SCARA Specific - This can change to suit future G-code regulations</comment>
<comment type="line">// M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)</comment>
<comment type="line">// M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)</comment>
<comment type="line">// M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)</comment>
<comment type="line">// M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)</comment>
<comment type="line">// M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)</comment>
<comment type="line">// M365 - SCARA calibration: Scaling factor, X, Y, Z axis</comment>
<comment type="line">//************* SCARA End ***************</comment>

<comment type="line">// M928 - Start SD logging (M928 filename.g) - ended by M29</comment>
<comment type="line">// M999 - Restart after being stopped by error</comment>

<comment type="line">//Stepper Movement Variables</comment>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================imported variables============================</comment>
<comment type="line">//===========================================================================</comment>


<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================public variables=============================</comment>
<comment type="line">//===========================================================================</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
<decl_stmt><decl><type><name>CardReader</name></type> <name>card</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>float</name></type> <name><name>homing_feedrate</name><index>[]</index></name> <init>= <expr><name>HOMING_FEEDRATE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name><name>axis_relative_modes</name><index>[]</index></name> <init>= <expr><name>AXIS_RELATIVE_MODES</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>feedmultiply</name><init>=<expr>100</expr></init></decl>;</decl_stmt> <comment type="line">//100-&gt;1 200-&gt;2</comment>
<decl_stmt><decl><type><name>int</name></type> <name>saved_feedmultiply</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>extrudemultiply</name><init>=<expr>100</expr></init></decl>;</decl_stmt> <comment type="line">//100-&gt;1 200-&gt;2</comment>
<decl_stmt><decl><type><name>int</name></type> <name><name>extruder_multiply</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{<expr>100</expr>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    , <expr>100</expr>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
      , <expr>100</expr>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>volumetric_enabled</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>filament_size</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{ <expr><name>DEFAULT_NOMINAL_FILAMENT_DIA</name></expr>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
      , <expr><name>DEFAULT_NOMINAL_FILAMENT_DIA</name></expr>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
       , <expr><name>DEFAULT_NOMINAL_FILAMENT_DIA</name></expr>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>volumetric_multiplier</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{<expr>1.0</expr>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    , <expr>1.0</expr>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
      , <expr>1.0</expr>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>current_position</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>add_homing</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
<decl_stmt><decl><type><name>float</name></type> <name><name>endstop_adj</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>float</name></type> <name><name>min_pos</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{ <expr><name>X_MIN_POS</name></expr>, <expr><name>Y_MIN_POS</name></expr>, <expr><name>Z_MIN_POS</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>max_pos</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{ <expr><name>X_MAX_POS</name></expr>, <expr><name>Y_MAX_POS</name></expr>, <expr><name>Z_MAX_POS</name></expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name><name>axis_known_position</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>false</expr>, <expr>false</expr>, <expr>false</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>zprobe_zoffset</name></decl>;</decl_stmt>

<comment type="line">// Extruder offset</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifndef>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_EXTRUDER_OFFSETS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> <comment type="line">// only in XY plane</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_EXTRUDER_OFFSETS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> <comment type="line">// supports offsets in XYZ plane</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>float</name></type> <name><name>extruder_offset</name><index>[<expr><name>NUM_EXTRUDER_OFFSETS</name></expr>]</index><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_OFFSET_X</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_OFFSET_Y</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr><name>EXTRUDER_OFFSET_X</name></expr>, <expr><name>EXTRUDER_OFFSET_Y</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>uint8_t</name></type> <name>active_extruder</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fanSpeed</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name><name>servo_endstops</name><index>[]</index></name> <init>= <expr><name>SERVO_ENDSTOPS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name><name>servo_endstop_angles</name><index>[]</index></name> <init>= <expr><name>SERVO_ENDSTOP_ANGLES</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name>ValvePressure</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>EtoPPressure</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>bool</name></type> <name>autoretract_enabled</name><init>=<expr>false</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name><name>retracted</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name><init>=<expr><block>{<expr>false</expr>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    , <expr>false</expr>
     <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
      , <expr>false</expr>
     <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name><name>retracted_swap</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name><init>=<expr><block>{<expr>false</expr>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    , <expr>false</expr>
     <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
      , <expr>false</expr>
     <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>float</name></type> <name>retract_length</name> <init>= <expr><name>RETRACT_LENGTH</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_length_swap</name> <init>= <expr><name>RETRACT_LENGTH_SWAP</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_feedrate</name> <init>= <expr><name>RETRACT_FEEDRATE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_zlift</name> <init>= <expr><name>RETRACT_ZLIFT</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_recover_length</name> <init>= <expr><name>RETRACT_RECOVER_LENGTH</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_recover_length_swap</name> <init>= <expr><name>RETRACT_RECOVER_LENGTH_SWAP</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>retract_recover_feedrate</name> <init>= <expr><name>RETRACT_RECOVER_FEEDRATE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PS_DEFAULT_OFF</name></cpp:ifdef>
    <decl_stmt><decl><type><name>bool</name></type> <name>powersupply</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	  <decl_stmt><decl><type><name>bool</name></type> <name>powersupply</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name><name>delta</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIN_60</name></cpp:macro> <cpp:value>0.8660254037844386</cpp:value></cpp:define>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COS_60</name></cpp:macro> <cpp:value>0.5</cpp:value></cpp:define>
  <comment type="line">// these are the default values, can be overriden with M665</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_radius</name><init>= <expr><name>DELTA_RADIUS</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower1_x</name><init>= <expr>-<name>SIN_60</name>*<name>delta_radius</name></expr></init></decl>;</decl_stmt> <comment type="line">// front left tower</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower1_y</name><init>= <expr>-<name>COS_60</name>*<name>delta_radius</name></expr></init></decl>;</decl_stmt>	   
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower2_x</name><init>=  <expr><name>SIN_60</name>*<name>delta_radius</name></expr></init></decl>;</decl_stmt> <comment type="line">// front right tower</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower2_y</name><init>= <expr>-<name>COS_60</name>*<name>delta_radius</name></expr></init></decl>;</decl_stmt>	   
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower3_x</name><init>= <expr>0.0</expr></init></decl>;</decl_stmt>                  <comment type="line">// back middle tower</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_tower3_y</name><init>= <expr><name>delta_radius</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_diagonal_rod</name><init>= <expr><name>DELTA_DIAGONAL_ROD</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_diagonal_rod_2</name><init>= <expr><call><name>sq</name><argument_list>(<argument><expr><name>delta_diagonal_rod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>delta_segments_per_second</name><init>= <expr><name>DELTA_SEGMENTS_PER_SECOND</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>                              <comment type="line">// Build size scaling</comment>
<decl_stmt><decl><type><name>float</name></type> <name><name>axis_scaling</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>1</expr>,<expr>1</expr>,<expr>1</expr>}</block></expr></init></decl>;</decl_stmt>  <comment type="line">// Build size scaling, default to 1</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>				

<decl_stmt><decl><type><name>bool</name></type> <name>cancel_heatup</name> <init>= <expr>false</expr></init></decl> ;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
  <comment type="line">//Variables for Filament Sensor input </comment>
  <decl_stmt><decl><type><name>float</name></type> <name>filament_width_nominal</name><init>=<expr><name>DEFAULT_NOMINAL_FILAMENT_DIA</name></expr></init></decl>;</decl_stmt>  <comment type="line">//Set nominal filament width, can be changed with M404 </comment>
  <decl_stmt><decl><type><name>bool</name></type> <name>filament_sensor</name><init>=<expr>false</expr></init></decl>;</decl_stmt>  <comment type="line">//M405 turns on filament_sensor control, M406 turns it off </comment>
  <decl_stmt><decl><type><name>float</name></type> <name>filament_width_meas</name><init>=<expr><name>DEFAULT_MEASURED_FILAMENT_DIA</name></expr></init></decl>;</decl_stmt> <comment type="line">//Stores the measured filament diameter </comment>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name><name>measurement_delay</name><index>[<expr><name>MAX_MEASUREMENT_DELAY</name>+1</expr>]</index></name></decl>;</decl_stmt>  <comment type="line">//ring buffer to delay measurement  store extruder factor after subtracting 100 </comment>
  <decl_stmt><decl><type><name>int</name></type> <name>delay_index1</name><init>=<expr>0</expr></init></decl>;</decl_stmt>  <comment type="line">//index into ring buffer</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>delay_index2</name><init>=<expr>-1</expr></init></decl>;</decl_stmt>  <comment type="line">//index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>delay_dist</name><init>=<expr>0</expr></init></decl>;</decl_stmt> <comment type="line">//delay distance counter  </comment>
  <decl_stmt><decl><type><name>int</name></type> <name>meas_delay_cm</name> <init>= <expr><name>MEASUREMENT_DELAY_CM</name></expr></init></decl>;</decl_stmt>  <comment type="line">//distance delay setting</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <name>errormagic</name><index>[]</index></type> <name>PROGMEM</name> <init>= <expr>"Error:"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <name>echomagic</name><index>[]</index></type> <name>PROGMEM</name> <init>= <expr>"echo:"</expr></init></decl>;</decl_stmt>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================Private Variables=============================</comment>
<comment type="line">//===========================================================================</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>axis_codes</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name> <init>= <expr><block>{<expr>'X'</expr>, <expr>'Y'</expr>, <expr>'Z'</expr>, <expr>'E'</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>destination</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name> <init>= <expr><block>{  <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DELTA</name></cpp:ifndef>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>delta</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>offset</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>home_all_axis</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>feedrate</name> <init>= <expr>1500.0</expr></init>, <name>next_feedrate</name></decl>, <decl><type ref="prev"/><name>saved_feedrate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>gcode_N</name></decl>, <decl><type ref="prev"/><name>gcode_LastN</name></decl>, <decl><type ref="prev"/><name>Stopped_gcode_LastN</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>relative_mode</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>  <comment type="line">//Determines Absolute or Relative Coordinates</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>cmdbuffer</name><index>[<expr><name>BUFSIZE</name></expr>]</index><index>[<expr><name>MAX_CMD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>fromsd</name><index>[<expr><name>BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufindr</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bufindw</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>buflen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<comment type="line">//static int i = 0;</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>serial_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>serial_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>boolean</name></type> <name>comment_mode</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>strchr_pointer</name></decl>;</decl_stmt> <comment type="line">// just a pointer to find chars in the command string like X, Y, Z, E, etc</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name><name>sensitive_pins</name><index>[]</index></name> <init>= <expr><name>SENSITIVE_PINS</name></expr></init></decl>;</decl_stmt> <comment type="line">// Sensitive pin list for M42</comment>

<comment type="line">//static float tt = 0;</comment>
<comment type="line">//static float bt = 0;</comment>

<comment type="line">//Inactivity shutdown variables</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>previous_millis_cmd</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>max_inactive_time</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>stepper_inactive_time</name> <init>= <expr><name>DEFAULT_STEPPER_DEACTIVE_TIME</name>*1000l</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>starttime</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>stoptime</name><init>=<expr>0</expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name>tmp_extruder</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>bool</name></type> <name>Stopped</name><init>=<expr>false</expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUM_SERVOS</name> &gt; 0</expr></cpp:if>
  <decl_stmt><decl><type><name>Servo</name></type> <name><name>servos</name><index>[<expr><name>NUM_SERVOS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>bool</name></type> <name>CooldownNoWait</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>target_direction</name></decl>;</decl_stmt>

<comment type="line">//Insert variables if CHDK is defined</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHDK</name></cpp:ifdef>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>chdkHigh</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>boolean</name></type> <name>chdkActive</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================Routines======================================</comment>
<comment type="line">//===========================================================================</comment>

<function_decl><type><name>void</name></type> <name>get_arc_coordinates</name><parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>bool</name></type> <name>setTargetedHotend</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>void</name></type> <name>serial_echopair_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_P</name></decl></param>, <param><decl><type><name>float</name></type> <name>v</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>serialprintPGM</name><argument_list>(<argument><expr><name>s_P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<function><type><name>void</name></type> <name>serial_echopair_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_P</name></decl></param>, <param><decl><type><name>double</name></type> <name>v</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>serialprintPGM</name><argument_list>(<argument><expr><name>s_P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>
<function><type><name>void</name></type> <name>serial_echopair_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_P</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name></type> <name>v</name></decl></param>)</parameter_list>
    <block>{ <expr_stmt><expr><call><name>serialprintPGM</name><argument_list>(<argument><expr><name>s_P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"SdFatUtil.h"</cpp:file></cpp:include>
  <function><type><name>int</name></type> <name>freeMemory</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><call><name><name>SdFatUtil</name>::<name>FreeRam</name></name><argument_list>()</argument_list></call></expr>;</return> }</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <extern>extern "C" <block>{
    <decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name> <name>int</name></type> <name>__bss_end</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name> <name>int</name></type> <name>__heap_start</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>extern</specifier> <name>void</name> *</type><name>__brkval</name></decl>;</decl_stmt>

    <function><type><name>int</name></type> <name>freeMemory</name><parameter_list>()</parameter_list> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>free_memory</name></decl>;</decl_stmt>

      <if>if <condition>(<expr>(<name>int</name>)<name>__brkval</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>free_memory</name> = ((<name>int</name>)&amp;<name>free_memory</name>) - ((<name>int</name>)&amp;<name>__bss_end</name>)</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>free_memory</name> = ((<name>int</name>)&amp;<name>free_memory</name>) - ((<name>int</name>)<name>__brkval</name>)</expr>;</expr_stmt></else></if>

      <return>return <expr><name>free_memory</name></expr>;</return>
    }</block></function>
  }</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line" format="doxygen">//!SDSUPPORT</comment>

<comment type="line">//adds an command to the main command buffer</comment>
<comment type="line">//thats really done in a non-safe way.</comment>
<comment type="line">//needs overworking someday</comment>
<function><type><name>void</name></type> <name>enquecommand</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>)</parameter_list>
<block>{
  <if>if<condition>(<expr><name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition><then>
  <block>{
    <comment type="line">//this is dangerous if a mixing of serial and this happens</comment>
    <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr>&amp;(<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr>0</expr>]</index></name>)</expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_Enqueing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufindw</name>= (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>enquecommand_P</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmd</name></decl></param>)</parameter_list>
<block>{
  <if>if<condition>(<expr><name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition><then>
  <block>{
    <comment type="line">//this is dangerous if a mixing of serial and this happens</comment>
    <expr_stmt><expr><call><name>strcpy_P</name><argument_list>(<argument><expr>&amp;(<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr>0</expr>]</index></name>)</expr></argument>,<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_Enqueing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>bufindw</name>= (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>setup_killpin</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>KILL_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_INPUT</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>,<argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line">// Set home pin</comment>
<function><type><name>void</name></type> <name>setup_homepin</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HOME_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HOME_PIN</name> &gt; -1</expr></cpp:if>
   <expr_stmt><expr><call><name>SET_INPUT</name><argument_list>(<argument><expr><name>HOME_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HOME_PIN</name></expr></argument>,<argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>void</name></type> <name>setup_photpin</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PHOTOGRAPH_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>setup_powerhold</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_DEFAULT_OFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
	  <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_ASLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	  <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_AWAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>suicide</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>servo_init</name><parameter_list>()</parameter_list>
<block>{
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 1) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO0_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>0</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 2) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO1_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>1</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO1_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 3) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO2_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>2</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO2_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 4) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO3_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>SERVO3_PIN</name> &gt; -1)</expr></cpp:if>
    <expr_stmt><expr><name><name>servos</name><index>[<expr>3</expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr><name>SERVO3_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>NUM_SERVOS</name> &gt;= 5)</expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "TODO: enter initalisation code for more servos"</cpp:error>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Set position of Servo Endstops that are defined</comment>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
  <block>{
    <if>if<condition>(<expr><name><name>servo_endstops</name><index>[<expr><name>i</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></for>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
  <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>PROBE_SERVO_DEACTIVATION_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>detach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>


<function><type><name>void</name></type> <name>setup</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>setup_killpin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setup_powerhold</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name><name>MYSERIAL</name>.<name>begin</name></name><argument_list>(<argument><expr><name>BAUDRATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>"start"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>

  <comment type="line">// Check startup - does nothing if bootloader sets MCUSR to 0</comment>
  <decl_stmt><decl><type><name>byte</name></type> <name>mcu</name> <init>= <expr><name>MCUSR</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>mcu</name> &amp; 1</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_POWERUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 2</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_EXTERNAL_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 4</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_BROWNOUT_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 8</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_WATCHDOG_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>mcu</name> &amp; 32</expr>)</condition><then> <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_SOFTWARE_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>MCUSR</name>=0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_MARLIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>VERSION_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STRING_VERSION_CONFIG_H</name></cpp:ifdef>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>STRING_CONFIG_H_AUTHOR</name></cpp:ifdef>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_CONFIGURATION_VER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>STRING_VERSION_CONFIG_H</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_AUTHOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>STRING_CONFIG_H_AUTHOR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr>"Compiled: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>__DATE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_FREE_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><call><name>freeMemory</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_PLANNER_BUFFER_BYTES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>(<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>block_t</name></expr></argument>)</argument_list></sizeof>*<name>BLOCK_BUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>BUFSIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
  <block>{
    <expr_stmt><expr><name><name>fromsd</name><index>[<expr><name>i</name></expr>]</index></name> = false</expr>;</expr_stmt>
  }</block></for>

  <comment type="line">// loads data from EEPROM if available else uses defaults (and resets step acceleration rate)</comment>
  <expr_stmt><expr><call><name>Config_RetrieveSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>tp_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// Initialize temperature loop</comment>
  <expr_stmt><expr><call><name>plan_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// Initialize planner;</comment>
  <expr_stmt><expr><call><name>watchdog_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>st_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// Initialize stepper, this enables interrupts!</comment>
  <expr_stmt><expr><call><name>setup_photpin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>servo_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  

  <expr_stmt><expr><call><name>lcd_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="line">// wait 1sec to display the splash screen</comment>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CONTROLLERFAN_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//Set pin used for driver cooling fan</comment>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIGIPOT_I2C</name></cpp:ifdef>
    <expr_stmt><expr><call><name>digipot_i2c_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifdef>
  <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>, <argument><expr><name>OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// turn it off</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>
  <expr_stmt><expr><call><name>setup_homepin</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type> <name>loop</name><parameter_list>()</parameter_list>
<block>{
  <if>if<condition>(<expr><name>buflen</name> &lt; (<name>BUFSIZE</name>-1)</expr>)</condition><then>
    <expr_stmt><expr><call><name>get_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <expr_stmt><expr><call><name><name>card</name>.<name>checkautostart</name></name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>(<expr><name>buflen</name></expr>)</condition><then>
  <block>{
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
      <if>if<condition>(<expr><name><name>card</name>.<name>saving</name></name></expr>)</condition><then>
      <block>{
        <if>if<condition>(<expr><call><name>strstr_P</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"M29"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name><name>card</name>.<name>write_command</name></name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><name><name>card</name>.<name>logging</name></name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>process_commands</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else
          <block>{
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then>
        <else>else
        <block>{
          <expr_stmt><expr><call><name><name>card</name>.<name>closefile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_FILE_SAVED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><call><name>process_commands</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>process_commands</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>
    <expr_stmt><expr><name>buflen</name> = (<name>buflen</name>-1)</expr>;</expr_stmt>
    <expr_stmt><expr><name>bufindr</name> = (<name>bufindr</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
  }</block></then></if>
  <comment type="line">//check heater every n milliseconds</comment>
  <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>checkHitEndstops</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>get_command</name><parameter_list>()</parameter_list>
<block>{
  <while>while<condition>( <expr><call><name><name>MYSERIAL</name>.<name>available</name></name><argument_list>()</argument_list></call> &gt; 0  &amp;&amp; <name>buflen</name> &lt; <name>BUFSIZE</name></expr>)</condition> <block>{
    <expr_stmt><expr><name>serial_char</name> = <call><name><name>MYSERIAL</name>.<name>read</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>serial_char</name> == '\n' ||
       <name>serial_char</name> == '\r' ||
       (<name>serial_char</name> == ':' &amp;&amp; <name>comment_mode</name> == false) ||
       <name>serial_count</name> &gt;= (<name>MAX_CMD_SIZE</name> - 1)</expr> )</condition><then>
    <block>{
      <if>if<condition>(<expr>!<name>serial_count</name></expr>)</condition><then> <block>{ <comment type="line">//if empty line</comment>
        <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
        <return>return;</return>
      }</block></then></if>
      <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name></expr>]</index></name> = 0</expr>;</expr_stmt> <comment type="line">//terminate string</comment>
      <if>if<condition>(<expr>!<name>comment_mode</name></expr>)</condition><then><block>{
        <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
        <expr_stmt><expr><name><name>fromsd</name><index>[<expr><name>bufindw</name></expr>]</index></name> = false</expr>;</expr_stmt>
        <if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>gcode_N</name> = (<call><name>strtol</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
          <if>if<condition>(<expr><name>gcode_N</name> != <name>gcode_LastN</name>+1 &amp;&amp; (<call><name>strstr_P</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"M110"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == <name>NULL</name>)</expr> )</condition><then> <block>{
            <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_LINE_NO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="line">//Serial.println(gcode_N);</comment>
            <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
            <return>return;</return>
          }</block></then></if>

          <if>if<condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><name>byte</name></type> <name>checksum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>byte</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <while>while<condition>(<expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>count</name></expr>]</index></name> != '*'</expr>)</condition> <expr_stmt><expr><name>checksum</name> = <name>checksum</name>^<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>count</name>++</expr>]</index></name></expr>;</expr_stmt></while>
            <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if>if<condition>( <expr><call>(<name>int</name>)<argument_list>(<argument><expr><call><name>strtod</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>checksum</name></expr>)</condition><then> <block>{
              <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_CHECKSUM_MISMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
              <return>return;</return>
            }</block></then></if>
            <comment type="line">//if no errors, continue parsing</comment>
          }</block></then>
          <else>else
          <block>{
            <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_NO_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
            <return>return;</return>
          }</block></else></if>

          <expr_stmt><expr><name>gcode_LastN</name> = <name>gcode_N</name></expr>;</expr_stmt>
          <comment type="line">//if no errors, continue parsing</comment>
        }</block></then>
        <else>else  <comment type="line">// if we don't receive 'N' but still see '*'</comment>
        <block>{
          <if>if<condition>(<expr>(<call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORPGM</name><argument_list>(<argument><expr><name>MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr><name>gcode_LastN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt>
            <return>return;</return>
          }</block></then></if>
        }</block></else></if>
        <if>if<condition>(<expr>(<call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>)</condition><then><block>{
          <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>'G'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <switch>switch<condition>(<expr><call>(<name>int</name>)<argument_list>(<argument><expr>(<call><name>strtod</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>)</condition><block>{
          <case>case <expr>0</expr>:
          </case><case>case <expr>1</expr>:
          </case><case>case <expr>2</expr>:
          </case><case>case <expr>3</expr>:
            <if>if <condition>(<expr><name>Stopped</name> == true</expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
            <break>break;</break>
          </case><default>default:
            <break>break;</break>
          </default>}</block></switch>

        }</block></then></if>

        <comment type="line">//If command was e-stop process now</comment>
        <if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index></name></expr></argument>, <argument><expr>"M112"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
          <expr_stmt><expr><call><name>kill</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        
        <expr_stmt><expr><name>bufindw</name> = (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt> <comment type="line">//clear buffer</comment>
    }</block></then>
    <else>else
    <block>{
      <if>if<condition>(<expr><name>serial_char</name> == ';'</expr>)</condition><then> <expr_stmt><expr><name>comment_mode</name> = true</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr>!<name>comment_mode</name></expr>)</condition><then> <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name>++</expr>]</index></name> = <name>serial_char</name></expr>;</expr_stmt></then></if>
    }</block></else></if>
  }</block></while>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <if>if<condition>(<expr>!<name><name>card</name>.<name>sdprinting</name></name> || <name>serial_count</name>!=0</expr>)</condition><then><block>{
    <return>return;</return>
  }</block></then></if>

  <comment type="line">//'#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible</comment>
  <comment type="line">// if it occurs, stop_buffering is triggered and the buffer is ran dry.</comment>
  <comment type="line">// this character _can_ occur in serial com, due to checksums. however, no checksums are used in SD printing</comment>

  <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>stop_buffering</name><init>=<expr>false</expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>buflen</name>==0</expr>)</condition><then> <expr_stmt><expr><name>stop_buffering</name>=false</expr>;</expr_stmt></then></if>

  <while>while<condition>( <expr>!<call><name><name>card</name>.<name>eof</name></name><argument_list>()</argument_list></call>  &amp;&amp; <name>buflen</name> &lt; <name>BUFSIZE</name> &amp;&amp; !<name>stop_buffering</name></expr>)</condition> <block>{
    <decl_stmt><decl><type><name>int16_t</name></type> <name>n</name><init>=<expr><call><name><name>card</name>.<name>get</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>serial_char</name> = (<name>char</name>)<name>n</name></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>serial_char</name> == '\n' ||
       <name>serial_char</name> == '\r' ||
       (<name>serial_char</name> == '#' &amp;&amp; <name>comment_mode</name> == false) ||
       (<name>serial_char</name> == ':' &amp;&amp; <name>comment_mode</name> == false) ||
       <name>serial_count</name> &gt;= (<name>MAX_CMD_SIZE</name> - 1)||<name>n</name>==-1</expr>)</condition><then>
    <block>{
      <if>if<condition>(<expr><call><name><name>card</name>.<name>eof</name></name><argument_list>()</argument_list></call></expr>)</condition><then><block>{
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_FILE_PRINTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>stoptime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>char</name></type> <name><name>time</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name><init>=<expr>(<name>stoptime</name>-<name>starttime</name>)/1000</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>hours</name></decl>, <decl><type ref="prev"/><name>minutes</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>minutes</name>=(<name>t</name>/60)%60</expr>;</expr_stmt>
        <expr_stmt><expr><name>hours</name>=<name>t</name>/60/60</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sprintf_P</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"%i hours %i minutes"</expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>hours</name></expr></argument>, <argument><expr><name>minutes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>card</name>.<name>printingHasFinished</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>card</name>.<name>checkautostart</name></name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      }</block></then></if>
      <if>if<condition>(<expr><name>serial_char</name>=='#'</expr>)</condition><then>
        <expr_stmt><expr><name>stop_buffering</name>=true</expr>;</expr_stmt></then></if>

      <if>if<condition>(<expr>!<name>serial_count</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
        <return>return;</return> <comment type="line">//if empty line</comment>
      }</block></then></if>
      <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name></expr>]</index></name> = 0</expr>;</expr_stmt> <comment type="line">//terminate string</comment>
<comment type="line">//      if(!comment_mode){</comment>
        <expr_stmt><expr><name><name>fromsd</name><index>[<expr><name>bufindw</name></expr>]</index></name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>buflen</name> += 1</expr>;</expr_stmt>
        <expr_stmt><expr><name>bufindw</name> = (<name>bufindw</name> + 1)%<name>BUFSIZE</name></expr>;</expr_stmt>
<comment type="line">//      }</comment>
      <expr_stmt><expr><name>comment_mode</name> = false</expr>;</expr_stmt> <comment type="line">//for new command</comment>
      <expr_stmt><expr><name>serial_count</name> = 0</expr>;</expr_stmt> <comment type="line">//clear buffer</comment>
    }</block></then>
    <else>else
    <block>{
      <if>if<condition>(<expr><name>serial_char</name> == ';'</expr>)</condition><then> <expr_stmt><expr><name>comment_mode</name> = true</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr>!<name>comment_mode</name></expr>)</condition><then> <expr_stmt><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindw</name></expr>]</index><index>[<expr><name>serial_count</name>++</expr>]</index></name> = <name>serial_char</name></expr>;</expr_stmt></then></if>
    }</block></else></if>
  }</block></while>

  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>

}</block></function>


<function><type><name>float</name></type> <name>code_value</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>(<call><name>strtod</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>long</name></type> <name>code_value_long</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>(<call><name>strtol</name><argument_list>(<argument><expr>&amp;<name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index><index>[<expr><name>strchr_pointer</name> - <name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name> + 1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>

<function><type><name>bool</name></type> <name>code_seen</name><parameter_list>(<param><decl><type><name>char</name></type> <name>code</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr>(<name>strchr_pointer</name> != <name>NULL</name>)</expr>;</return>  <comment type="line">//Return True if a character was found</comment>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_PGM_READ_ANY</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>reader</name></type></param>)</parameter_list></cpp:macro>       \
    <cpp:value>static inline type pgm_read_any(const type *p)  \
    { return pgm_read_##reader##_near(p); }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>DEFINE_PGM_READ_ANY</name><argument_list>(<argument><expr><name>float</name></expr></argument>,       <argument><expr><name>float</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>DEFINE_PGM_READ_ANY</name><argument_list>(<argument>signed char</argument>, <argument>byte</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XYZ_CONSTS_FROM_CONFIG</name><parameter_list>(<param><type><name>type</name></type></param>, <param><type><name>array</name></type></param>, <param><type><name>CONFIG</name></type></param>)</parameter_list></cpp:macro> \
<cpp:value>static const PROGMEM type array##_P[3] =        \
    { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \
static inline type array(int axis)          \
    { return pgm_read_any(&amp;array##_P[axis]); }</cpp:value></cpp:define>

<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>base_min_pos</name></expr></argument>,    <argument><expr><name>MIN_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>base_max_pos</name></expr></argument>,    <argument><expr><name>MAX_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>base_home_pos</name></expr></argument>,   <argument><expr><name>HOME_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>max_length</name></expr></argument>,      <argument><expr><name>MAX_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument><expr><name>float</name></expr></argument>, <argument><expr><name>home_retract_mm</name></expr></argument>, <argument><expr><name>HOME_RETRACT_MM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>XYZ_CONSTS_FROM_CONFIG</name><argument_list>(<argument>signed char</argument>, <argument>home_dir</argument>,  <argument>HOME_DIR</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> == 1 || <call><name>defined</name><argument_list>(<argument><expr><name>COREXY</name></expr></argument>)</argument_list></call> \
      || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_ENABLE_PIN</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_STEP_PIN</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_DIR_PIN</name></expr></argument>)</argument_list></call> \
      || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_HOME_POS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_MIN_POS</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>X2_MAX_POS</name></expr></argument>)</argument_list></call> \
      || !<call><name>defined</name><argument_list>(<argument><expr><name>X_MAX_PIN</name></expr></argument>)</argument_list></call> || <name>X_MAX_PIN</name> &lt; 0</expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "Missing or invalid definitions for DUAL_X_CARRIAGE mode."</cpp:error>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>X_HOME_DIR</name> != -1 || <name>X2_HOME_DIR</name> != 1</expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "Please use canonical x-carriage assignment"</cpp:error> <comment type="line">// the x-carriages are defined by their homing directions</comment>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DXC_FULL_CONTROL_MODE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DXC_AUTO_PARK_MODE</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DXC_DUPLICATION_MODE</name></cpp:macro>  <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dual_x_carriage_mode</name> <init>= <expr><name>DEFAULT_DUAL_X_CARRIAGE_MODE</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>float</name></type> <name>x_home_pos</name><parameter_list>(<param><decl><type><name>int</name></type> <name>extruder</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>extruder</name> == 0</expr>)</condition><then>
    <return>return <expr><call><name>base_home_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</return></then>
  <else>else
    <comment type="line">// In dual carriage mode the extruder offset provides an override of the</comment>
    <comment type="line">// second X-carriage offset when homed - otherwise X2_HOME_POS is used.</comment>
    <comment type="line">// This allow soft recalibration of the second extruder offset position without firmware reflash</comment>
    <comment type="line">// (through the M218 command).</comment>
    <return>return <expr>(<name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name> &gt; 0) ? <name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name> : <name>X2_HOME_POS</name></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>x_home_dir</name><parameter_list>(<param><decl><type><name>int</name></type> <name>extruder</name></decl></param>)</parameter_list> <block>{
  <return>return <expr>(<name>extruder</name> == 0) ? <name>X_HOME_DIR</name> : <name>X2_HOME_DIR</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>inactive_extruder_x_pos</name> <init>= <expr><name>X2_MAX_POS</name></expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 0 &amp; 1</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>active_extruder_parked</name> <init>= <expr>false</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 1 &amp; 2</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>raised_parked_position</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="line">// used in mode 1</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>delayed_move_time</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 1</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>duplicate_extruder_x_offset</name> <init>= <expr><name>DEFAULT_DUPLICATION_X_OFFSET</name></expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 2</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>duplicate_extruder_temp_offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 2</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>extruder_duplication_enabled</name> <init>= <expr>false</expr></init></decl>;</decl_stmt> <comment type="line">// used in mode 2</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//DUAL_X_CARRIAGE</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>axis_is_at_home</name><parameter_list>(<param><decl><type><name>int</name></type> <name>axis</name></decl></param>)</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
  <if>if <condition>(<expr><name>axis</name> == <name>X_AXIS</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name>active_extruder</name> != 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <name>X2_MIN_POS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <call><name>max</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>X2_MAX_POS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>active_extruder</name> == 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>base_home_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <call><name>base_min_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> =          <call><name>min</name><argument_list>(<argument><expr><call><name>base_max_pos</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>,
                                  <argument><expr><call><name>max</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>X2_MAX_POS</name></expr></argument>)</argument_list></call> - <name>duplicate_extruder_x_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if></else></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
   <decl_stmt><decl><type><name>float</name></type> <name><name>homeposition</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
   <decl_stmt><decl><type><name>char</name></type> <name>i</name></decl>;</decl_stmt>
   
   <if>if <condition>(<expr><name>axis</name> &lt; 2</expr>)</condition><then>
   <block>{
   
     <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
     <block>{
        <expr_stmt><expr><name><name>homeposition</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>base_home_pos</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
     }</block></for>  
	<comment type="line">// SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);</comment>
   <comment type="line">//  SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);</comment>
   <comment type="line">// Works out real Homeposition angles using inverse kinematics, </comment>
   <comment type="line">// and calculates homing offset using forward kinematics</comment>
     <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>homeposition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
    <comment type="line">// SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);</comment>
    <comment type="line">// SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);</comment>
     
     <for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
     <block>{
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>i</name></expr>]</index></name> -= <name><name>add_homing</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
     }</block></for> 
     
    <comment type="line">// SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(add_homing[X_AXIS]);</comment>
	<comment type="line">// SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(add_homing[Y_AXIS]);</comment>
    <comment type="line">// SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);</comment>
    <comment type="line">// SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);</comment>
      
     <expr_stmt><expr><call><name>calculate_SCARA_forward_Transform</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     
    <comment type="line">// SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);</comment>
    <comment type="line">// SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);</comment>
     
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
    
    <comment type="line">// SCARA home positions are based on configuration since the actual limits are determined by the </comment>
    <comment type="line">// inverse kinematic transform.</comment>
    <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_min_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// + (delta[axis] - base_home_pos(axis));</comment>
    <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_max_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// + (delta[axis] - base_home_pos(axis));</comment>
   }</block></then> 
   <else>else
   <block>{
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = <call><name>base_home_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_min_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_max_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
   }</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = <call><name>base_home_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>min_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_min_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>max_pos</name><index>[<expr><name>axis</name></expr>]</index></name> =          <call><name>base_max_pos</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> + <name><name>add_homing</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTO_BED_LEVELING_GRID</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>set_bed_level_equation_lsq</name><parameter_list>(<param><decl><type><name>double</name> *</type><name>plane_equation_coefficients</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>vector_3</name></type> <name>planeNormal</name> <init>= <expr><call><name>vector_3</name><argument_list>(<argument><expr>-<name><name>plane_equation_coefficients</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>-<name><name>plane_equation_coefficients</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name><name>planeNormal</name>.<name>debug</name></name><argument_list>(<argument><expr>"planeNormal"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>plan_bed_level_matrix</name> = <call><name><name>matrix_3x3</name>::<name>create_look_at</name></name><argument_list>(<argument><expr><name>planeNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">//bedLevel.debug("bedLevel");</comment>

    <comment type="line">//plan_bed_level_matrix.debug("bed level before");</comment>
    <comment type="line">//vector_3 uncorrected_position = plan_get_position_mm();</comment>
    <comment type="line">//uncorrected_position.debug("position before");</comment>

    <decl_stmt><decl><type><name>vector_3</name></type> <name>corrected_position</name> <init>= <expr><call><name>plan_get_position</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<comment type="line">//    corrected_position.debug("position after");</comment>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>corrected_position</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>corrected_position</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>corrected_position</name>.<name>z</name></name></expr>;</expr_stmt>

    <comment type="line">// put the bed at 0 so we don't go below it.</comment>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>zprobe_zoffset</name></expr>;</expr_stmt> <comment type="line">// in the lsq we reach here after raising the extruder due to the loop structure</comment>

    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// not AUTO_BED_LEVELING_GRID</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_bed_level_equation_3pts</name><parameter_list>(<param><decl><type><name>float</name></type> <name>z_at_pt_1</name></decl></param>, <param><decl><type><name>float</name></type> <name>z_at_pt_2</name></decl></param>, <param><decl><type><name>float</name></type> <name>z_at_pt_3</name></decl></param>)</parameter_list> <block>{

    <expr_stmt><expr><call><name><name>plan_bed_level_matrix</name>.<name>set_to_identity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>vector_3</name></type> <name>pt1</name> <init>= <expr><call><name>vector_3</name><argument_list>(<argument><expr><name>ABL_PROBE_PT_1_X</name></expr></argument>, <argument><expr><name>ABL_PROBE_PT_1_Y</name></expr></argument>, <argument><expr><name>z_at_pt_1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vector_3</name></type> <name>pt2</name> <init>= <expr><call><name>vector_3</name><argument_list>(<argument><expr><name>ABL_PROBE_PT_2_X</name></expr></argument>, <argument><expr><name>ABL_PROBE_PT_2_Y</name></expr></argument>, <argument><expr><name>z_at_pt_2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vector_3</name></type> <name>pt3</name> <init>= <expr><call><name>vector_3</name><argument_list>(<argument><expr><name>ABL_PROBE_PT_3_X</name></expr></argument>, <argument><expr><name>ABL_PROBE_PT_3_Y</name></expr></argument>, <argument><expr><name>z_at_pt_3</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>vector_3</name></type> <name>from_2_to_1</name> <init>= <expr>(<name>pt1</name> - <name>pt2</name>).<call><name>get_normal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vector_3</name></type> <name>from_2_to_3</name> <init>= <expr>(<name>pt3</name> - <name>pt2</name>).<call><name>get_normal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>vector_3</name></type> <name>planeNormal</name> <init>= <expr><call><name><name>vector_3</name>::<name>cross</name></name><argument_list>(<argument><expr><name>from_2_to_1</name></expr></argument>, <argument><expr><name>from_2_to_3</name></expr></argument>)</argument_list></call>.<call><name>get_normal</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>planeNormal</name> = <call><name>vector_3</name><argument_list>(<argument><expr><name><name>planeNormal</name>.<name>x</name></name></expr></argument>, <argument><expr><name><name>planeNormal</name>.<name>y</name></name></expr></argument>, <argument><expr><call><name>abs</name><argument_list>(<argument><expr><name><name>planeNormal</name>.<name>z</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>plan_bed_level_matrix</name> = <call><name><name>matrix_3x3</name>::<name>create_look_at</name></name><argument_list>(<argument><expr><name>planeNormal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <decl_stmt><decl><type><name>vector_3</name></type> <name>corrected_position</name> <init>= <expr><call><name>plan_get_position</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>corrected_position</name>.<name>x</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>corrected_position</name>.<name>y</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>corrected_position</name>.<name>z</name></name></expr>;</expr_stmt>

    <comment type="line">// put the bed at 0 so we don't go below it.</comment>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>zprobe_zoffset</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// AUTO_BED_LEVELING_GRID</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>run_z_probe</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><call><name><name>plan_bed_level_matrix</name>.<name>set_to_identity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

    <comment type="line">// move down until you find the bed</comment>
    <decl_stmt><decl><type><name>float</name></type> <name>zPosition</name> <init>= <expr>-10</expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>zPosition</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// we have to let the planner know where we are right now as it is not where we said to go.</comment>
    <expr_stmt><expr><name>zPosition</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>zPosition</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// move up the retract distance</comment>
    <expr_stmt><expr><name>zPosition</name> += <call><name>home_retract_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>zPosition</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="line">// move back down slowly to find bed</comment>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>/4</expr>;</expr_stmt>
    <expr_stmt><expr><name>zPosition</name> -= <call><name>home_retract_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call> * 2</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>zPosition</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="line">// make sure the planner knows where we are as it may be a bit different than we last said to move to</comment>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_blocking_move_to</name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>z</name></decl></param>)</parameter_list> <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>oldFeedRate</name> <init>= <expr><name>feedrate</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>z</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>feedrate</name> = <name>XY_TRAVEL_SPEED</name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>x</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name>y</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>feedrate</name> = <name>oldFeedRate</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_blocking_move_relative</name><parameter_list>(<param><decl><type><name>float</name></type> <name>offset_x</name></decl></param>, <param><decl><type><name>float</name></type> <name>offset_y</name></decl></param>, <param><decl><type><name>float</name></type> <name>offset_z</name></decl></param>)</parameter_list> <block>{
    <expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name>offset_x</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> + <name>offset_y</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>offset_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setup_for_endstop_move</name><parameter_list>()</parameter_list> <block>{
    <expr_stmt><expr><name>saved_feedrate</name> = <name>feedrate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>saved_feedmultiply</name> = <name>feedmultiply</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedmultiply</name> = 100</expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_up_after_endstop_move</name><parameter_list>()</parameter_list> <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENDSTOPS_ONLY_FOR_HOMING</name></cpp:ifdef>
    <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>engage_z_probe</name><parameter_list>()</parameter_list> <block>{
    <comment type="line">// Engage Z Servo endstop if enabled</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>Z_AXIS</name> * 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>PROBE_SERVO_DEACTIVATION_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>detach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>retract_z_probe</name><parameter_list>()</parameter_list> <block>{
    <comment type="line">// Retract Z Servo endstop if enabled</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
    <if>if <condition>(<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>Z_AXIS</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>PROBE_SERVO_DEACTIVATION_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>]</index></name>.<call><name>detach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="line" format="doxygen">/// Probe bed height at position (x,y), returns the measured z value</comment>
<function><type><specifier>static</specifier> <name>float</name></type> <name>probe_pt</name><parameter_list>(<param><decl><type><name>float</name></type> <name>x</name></decl></param>, <param><decl><type><name>float</name></type> <name>y</name></decl></param>, <param><decl><type><name>float</name></type> <name>z_before</name></decl></param>)</parameter_list> <block>{
  <comment type="line">// move to right place</comment>
  <expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>z_before</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>(<argument><expr><name>x</name> - <name>X_PROBE_OFFSET_FROM_EXTRUDER</name></expr></argument>, <argument><expr><name>y</name> - <name>Y_PROBE_OFFSET_FROM_EXTRUDER</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifndef>
  <expr_stmt><expr><call><name>engage_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// Engage Z Servo endstop if available</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>
  <expr_stmt><expr><call><name>run_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>measured_z</name> <init>= <expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifndef>
  <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>

  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_BED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" x: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" y: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" z: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>measured_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>measured_z</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #ifdef ENABLE_AUTO_BED_LEVELING</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>homeaxis</name><parameter_list>(<param><decl><type><name>int</name></type> <name>axis</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOMEAXIS_DO</name><parameter_list>(<param><type><name>LETTER</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>((LETTER##_MIN_PIN &gt; -1 &amp;&amp; LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN &gt; -1 &amp;&amp; LETTER##_HOME_DIR==1))</cpp:value></cpp:define>

  <if>if <condition>(<expr><name>axis</name>==<name>X_AXIS</name> ? <call><name>HOMEAXIS_DO</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call> :
      <name>axis</name>==<name>Y_AXIS</name> ? <call><name>HOMEAXIS_DO</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call> :
      <name>axis</name>==<name>Z_AXIS</name> ? <call><name>HOMEAXIS_DO</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call> :
      0</expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>axis_home_dir</name> <init>= <expr><call><name>home_dir</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
    <if>if <condition>(<expr><name>axis</name> == <name>X_AXIS</name></expr>)</condition><then>
      <expr_stmt><expr><name>axis_home_dir</name> = <call><name>x_home_dir</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifndef>
    <comment type="line">// Engage Servo endstop if enabled</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
        <if>if <condition>(<expr><name>axis</name>==<name>Z_AXIS</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>engage_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
	    <else>else
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr><name><name>servo_endstops</name><index>[<expr><name>axis</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>axis</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>axis</name> * 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if></else></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = 1.5 * <call><name>max_length</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> * <name>axis_home_dir</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = -<call><name>home_retract_mm</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> * <name>axis_home_dir</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = 2*<call><name>home_retract_mm</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call> * <name>axis_home_dir</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>axis</name></expr>]</index></name>/10</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>axis</name></expr>]</index></name>/2</expr> ;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
    <comment type="line">// retrace by the amount specified in endstop_adj</comment>
    <if>if <condition>(<expr><name><name>endstop_adj</name><index>[<expr><name>axis</name></expr>]</index></name> * <name>axis_home_dir</name> &lt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = <name><name>endstop_adj</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>axis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>destination</name><index>[<expr><name>axis</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>axis</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>
    <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>axis_known_position</name><index>[<expr><name>axis</name></expr>]</index></name> = true</expr>;</expr_stmt>

    <comment type="line">// Retract Servo endstop if enabled</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SERVO_ENDSTOPS</name></cpp:ifdef>
      <if>if <condition>(<expr><name><name>servo_endstops</name><index>[<expr><name>axis</name></expr>]</index></name> &gt; -1</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>servos</name><index>[<expr><name><name>servo_endstops</name><index>[<expr><name>axis</name></expr>]</index></name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name><name>servo_endstop_angles</name><index>[<expr><name>axis</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifndef>
    <if>if <condition>(<expr><name>axis</name>==<name>Z_AXIS</name></expr>)</condition><then> <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  }</block></then></if>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HOMEAXIS</name><parameter_list>(<param><type><name>LETTER</name></type></param>)</parameter_list></cpp:macro> <cpp:value>homeaxis(LETTER##_AXIS)</cpp:value></cpp:define>

<function><type><name>void</name></type> <name>refresh_cmd_timeout</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
  <function><type><name>void</name></type> <name>retract</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>retracting</name></decl></param>, <param><decl><type><name>bool</name></type> <name>swapretract</name> <init>= <expr>false</expr></init></decl></param>)</parameter_list> <block>{
    <if>if<condition>(<expr><name>retracting</name> &amp;&amp; !<name><name>retracted</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>swapretract</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=<name>retract_length_swap</name>/<name><name>volumetric_multiplier</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=<name>retract_length</name>/<name><name>volumetric_multiplier</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>float</name></type> <name>oldFeedrate</name> <init>= <expr><name>feedrate</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>feedrate</name>=<name>retract_feedrate</name>*60</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>retracted</name><index>[<expr><name>active_extruder</name></expr>]</index></name>=true</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>-=<name>retract_zlift</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
      <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// change cartesian kinematic to  delta kinematic;</comment>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedrate</name> = <name>oldFeedrate</name></expr>;</expr_stmt>
    }</block></then> <else>else <if>if<condition>(<expr>!<name>retracting</name> &amp;&amp; <name><name>retracted</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+=<name>retract_zlift</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
      <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// change cartesian kinematic  to  delta kinematic;</comment>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="line">//prepare_move();</comment>
      <if>if <condition>(<expr><name>swapretract</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>-=(<name>retract_length_swap</name>+<name>retract_recover_length_swap</name>)/<name><name>volumetric_multiplier</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr>;</expr_stmt> 
      }</block></then> <else>else <block>{
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>-=(<name>retract_length</name>+<name>retract_recover_length</name>)/<name><name>volumetric_multiplier</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr>;</expr_stmt> 
      }</block></else></if>
      <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>float</name></type> <name>oldFeedrate</name> <init>= <expr><name>feedrate</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>feedrate</name>=<name>retract_recover_feedrate</name>*60</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>retracted</name><index>[<expr><name>active_extruder</name></expr>]</index></name>=false</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedrate</name> = <name>oldFeedrate</name></expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></function> <comment type="line">//retract</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FWRETRACT</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifdef>
<comment type="line">//</comment>
<comment type="line">// Method to dock/undock a sled designed by Charles Bell.</comment>
<comment type="line">//</comment>
<comment type="line">// dock[in]     If true, move to MAX_X and engage the electromagnet</comment>
<comment type="line">// offset[in]   The additional distance to move to adjust docking location</comment>
<comment type="line">//</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dock_sled</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>dock</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name><init>=<expr>0</expr></init></decl></param>)</parameter_list> <block>{
 <decl_stmt><decl><type><name>int</name></type> <name>z_loc</name></decl>;</decl_stmt>
 
 <if>if <condition>(<expr>!((<name><name>axis_known_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>) &amp;&amp; (<name><name>axis_known_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>))</expr>)</condition><then> <block>{
   <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_POSITION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
   <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_POSITION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <return>return;</return>
 }</block></then></if>

 <if>if <condition>(<expr><name>dock</name></expr>)</condition><then> <block>{
   <expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>(<argument><expr><name>X_MAX_POS</name> + <name>SLED_DOCKING_OFFSET</name> + <name>offset</name></expr></argument>,
                       <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>,
                       <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <comment type="line">// turn off magnet</comment>
   <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 }</block></then> <else>else <block>{
   <if>if <condition>(<expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &lt; (<name>Z_RAISE_BEFORE_PROBING</name> + 5)</expr>)</condition><then>
     <expr_stmt><expr><name>z_loc</name> = <name>Z_RAISE_BEFORE_PROBING</name></expr>;</expr_stmt></then>
   <else>else
     <expr_stmt><expr><name>z_loc</name> = <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></else></if>
   <expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>(<argument><expr><name>X_MAX_POS</name> + <name>SLED_DOCKING_OFFSET</name> + <name>offset</name></expr></argument>,
                       <argument><expr><name>Y_PROBE_OFFSET_FROM_EXTRUDER</name></expr></argument>, <argument><expr><name>z_loc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <comment type="line">// turn on magnet</comment>
   <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>SERVO0_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 }</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>process_commands</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>codenum</name></decl>;</decl_stmt> <comment type="line">//throw away variable</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>starpos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name>x_tmp</name></decl>, <decl><type ref="prev"/><name>y_tmp</name></decl>, <decl><type ref="prev"/><name>z_tmp</name></decl>, <decl><type ref="prev"/><name>real_z</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'G'</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <switch>switch<condition>(<expr>(<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr>)</condition>
    <block>{
    <case>case <expr>0</expr>: <comment type="line">// G0 -&gt; G1</comment>
    </case><case>case <expr>1</expr>: <comment type="line">// G1</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>get_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// For X Y Z E F</comment>
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
            <if>if<condition>(<expr><name>autoretract_enabled</name></expr>)</condition><then>
            <if>if<condition>( <expr>!(<call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call>) &amp;&amp; <call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>float</name></type> <name>echange</name><init>=<expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>-<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
              <if>if<condition>(<expr>(<name>echange</name>&lt;-<name>MIN_RETRACT</name> &amp;&amp; !<name>retracted</name>) || (<name>echange</name>&gt;<name>MIN_RETRACT</name> &amp;&amp; <name>retracted</name>)</expr>)</condition><then> <block>{ <comment type="line">//move appears to be an attempt to retract or recover</comment>
                  <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">//hide the slicer-generated retract/recover from calculations</comment>
                  <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//AND from the planner</comment>
                  <expr_stmt><expr><call><name>retract</name><argument_list>(<argument><expr>!<name>retracted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <return>return;</return>
              }</block></then></if>
            }</block></then></if></then></if>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FWRETRACT</comment>
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
      }</block></then></if>
      <break>break;</break>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SCARA</name></cpp:ifndef> <comment type="line">//disable arc support</comment>
    </case><case>case <expr>2</expr>: <comment type="line">// G2  - CW ARC</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>get_arc_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>prepare_arc_move</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><case>case <expr>3</expr>: <comment type="line">// G3  - CCW ARC</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>get_arc_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>prepare_arc_move</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>4</expr>: <comment type="line">// G4 dwell</comment>
      <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_DWELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> = 0</expr>;</expr_stmt>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// milliseconds to wait</comment>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt></then></if> <comment type="line">// seconds to wait</comment>

      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> += <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// keep track of when we started waiting</comment>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <while>while<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> &lt; <name>codenum</name></expr>)</condition> <block>{
        <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <break>break;</break>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
      </case><case>case <expr>10</expr>: <comment type="line">// G10 retract</comment>
       <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
        <expr_stmt><expr><name><name>retracted_swap</name><index>[<expr><name>active_extruder</name></expr>]</index></name>=(<call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call> &amp;&amp; <call><name>code_value_long</name><argument_list>()</argument_list></call> == 1)</expr>;</expr_stmt> <comment type="line">// checks for swap retract argument</comment>
        <expr_stmt><expr><call><name>retract</name><argument_list>(<argument><expr>true</expr></argument>,<argument><expr><name><name>retracted_swap</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>retract</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
      </case><case>case <expr>11</expr>: <comment type="line">// G11 retract_recover</comment>
       <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
        <expr_stmt><expr><call><name>retract</name><argument_list>(<argument><expr>false</expr></argument>,<argument><expr><name><name>retracted_swap</name><index>[<expr><name>active_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>retract</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
      <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FWRETRACT</comment>
    </case><case>case <expr>28</expr>: <comment type="line">//G28 Home all Axis one at a time</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
      <expr_stmt><expr><call><name><name>plan_bed_level_matrix</name>.<name>set_to_identity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">//Reset the plane ("erase" all leveling data)</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//ENABLE_AUTO_BED_LEVELING</comment>

      <expr_stmt><expr><name>saved_feedrate</name> = <name>feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>saved_feedmultiply</name> = <name>feedmultiply</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedmultiply</name> = 100</expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      }</block></for>
      <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
          <comment type="line">// A delta can only safely home all axis at the same time</comment>
          <comment type="line">// all axis have to home at the same time</comment>

          <comment type="line">// Move all carriages up together until the first endstop is hit.</comment>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 3 * <name>Z_MAX_LENGTH</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 3 * <name>Z_MAX_LENGTH</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 3 * <name>Z_MAX_LENGTH</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>feedrate</name> = 1.732 * <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

          <comment type="line">// take care of back off and rehome now we are all at the top</comment>
          <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// NOT DELTA</comment>

      <expr_stmt><expr><name>home_all_axis</name> = !((<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>))</expr>;</expr_stmt>

      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Z_HOME_DIR</name> &gt; 0</expr></cpp:if>                      <comment type="line">// If homing away from BED do Z first</comment>
      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>QUICK_HOME</name></cpp:ifdef>
      <if>if<condition>(<expr>(<name>home_all_axis</name>)||( <call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr> )</condition><then>  <comment type="line">//first diagonal move</comment>
      <block>{
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt><expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>

       <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifndef>
        <decl_stmt><decl><type><name>int</name></type> <name>x_axis_home_dir</name> <init>= <expr><call><name>home_dir</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
       <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <decl_stmt><decl><type><name>int</name></type> <name>x_axis_home_dir</name> <init>= <expr><call><name>x_home_dir</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
       <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 1.5 * <call><name>max_length</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> * <name>x_axis_home_dir</name></expr>;</expr_stmt><expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 1.5 * <call><name>max_length</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call> * <call><name>home_dir</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <if>if<condition>(<expr><name><name>homing_feedrate</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>&lt;<name>feedrate</name></expr>)</condition><then>
          <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>max_length</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> &gt; <call><name>max_length</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>feedrate</name> *= <call><name>sqrt</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><call><name>max_length</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call> / <call><name>max_length</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then> <else>else <block>{
          <expr_stmt><expr><name>feedrate</name> *= <call><name>sqrt</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><call><name>max_length</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call> / <call><name>max_length</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>feedrate</name> = 0.0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
		<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SCARA</name></cpp:ifndef>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
      <block>{
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <decl_stmt><decl><type><name>int</name></type> <name>tmp_extruder</name> <init>= <expr><name>active_extruder</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>active_extruder</name> = !<name>active_extruder</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>inactive_extruder_x_pos</name> = <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>active_extruder</name> = <name>tmp_extruder</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">// reset state used by the different modes</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name>active_extruder_parked</name> = true</expr>;</expr_stmt>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>

      <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>

      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <if>if<condition>(<expr><call><name>code_value_long</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
		<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
		   <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		   <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if>
      }</block></then></if>

      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><call><name>code_value_long</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
         <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
		   <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		   <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homing</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
		<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></then></if>
      }</block></then></if>

      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Z_HOME_DIR</name> &lt; 0</expr></cpp:if>                      <comment type="line">// If homing towards BED do Z last</comment>
        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_SAFE_HOMING</name></cpp:ifndef>
          <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>Z_RAISE_BEFORE_HOMING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>Z_RAISE_BEFORE_HOMING</name> &gt; 0)</expr></cpp:if>
              <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>Z_RAISE_BEFORE_HOMING</name> * <call><name>home_dir</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call> * (-1)</expr>;</expr_stmt>    <comment type="line">// Set destination away from bed</comment>
              <expr_stmt><expr><name>feedrate</name> = <name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>                      <comment type="line">// Z Safe mode activated.</comment>
          <if>if<condition>(<expr><name>home_all_axis</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>round</name><argument_list>(<argument><expr><name>Z_SAFE_HOMING_X_POINT</name> - <name>X_PROBE_OFFSET_FROM_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <call><name>round</name><argument_list>(<argument><expr><name>Z_SAFE_HOMING_Y_POINT</name> - <name>Y_PROBE_OFFSET_FROM_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>Z_RAISE_BEFORE_HOMING</name> * <call><name>home_dir</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call> * (-1)</expr>;</expr_stmt>    <comment type="line">// Set destination away from bed</comment>
            <expr_stmt><expr><name>feedrate</name> = <name>XY_TRAVEL_SPEED</name>/60</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>

            <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
                                                <comment type="line">// Let's see if X and Y are homed and probe is inside bed area.</comment>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
            <if>if <condition>( <expr>(<name><name>axis_known_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>) &amp;&amp; (<name><name>axis_known_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>) \
              &amp;&amp; (<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>+<name>X_PROBE_OFFSET_FROM_EXTRUDER</name> &gt;= <name>X_MIN_POS</name>) \
              &amp;&amp; (<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>+<name>X_PROBE_OFFSET_FROM_EXTRUDER</name> &lt;= <name>X_MAX_POS</name>) \
              &amp;&amp; (<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>+<name>Y_PROBE_OFFSET_FROM_EXTRUDER</name> &gt;= <name>Y_MIN_POS</name>) \
              &amp;&amp; (<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>+<name>Y_PROBE_OFFSET_FROM_EXTRUDER</name> &lt;= <name>Y_MAX_POS</name>)</expr>)</condition><then> <block>{

              <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
              <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>Z_RAISE_BEFORE_HOMING</name> * <call><name>home_dir</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call> * (-1)</expr>;</expr_stmt>    <comment type="line">// Set destination away from bed</comment>
              <expr_stmt><expr><name>feedrate</name> = <name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>HOMEAXIS</name><argument_list>(<argument><expr><name>Z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <if>if <condition>(<expr>!((<name><name>axis_known_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>) &amp;&amp; (<name><name>axis_known_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>))</expr>)</condition><then> <block>{
                <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_POSITION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_POSITION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then> <else>else <block>{
                <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_ZPROBE_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_ZPROBE_OUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if></else></if>
          }</block></then></if>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><call><name>code_value_long</name><argument_list>()</argument_list></call> != 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homing</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
        <if>if<condition>(<expr>(<name>home_all_axis</name>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> += <name>zprobe_zoffset</name></expr>;</expr_stmt>  <comment type="line">//Add Z_Probe offset (the distance is negative)</comment>
        }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// else DELTA</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
	  <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// SCARA</comment>

      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENDSTOPS_ONLY_FOR_HOMING</name></cpp:ifdef>
        <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>feedrate</name> = <name>saved_feedrate</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>feedmultiply</name> = <name>saved_feedmultiply</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>endstops_hit_on_purpose</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
    </case><case>case <expr>29</expr>: <comment type="line">// G29 Detailed Z-Probe, probes the bed at 3 or more points.</comment>
        <block>{
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Z_MIN_PIN</name> == -1</expr></cpp:if>
            <cpp:error>#<cpp:directive>error</cpp:directive> "You must have a Z_MIN endstop in order to enable Auto Bed Leveling feature!!! Z_MIN_PIN must point to a valid hardware pin."</cpp:error>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

            <comment type="line">// Prevent user from running a G29 without first homing in X and Y</comment>
            <if>if <condition>(<expr>! (<name><name>axis_known_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> &amp;&amp; <name><name>axis_known_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>)</expr> )</condition><then>
            <block>{
                <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_POSITION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_POSITION_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <break>break;</break> <comment type="line">// abort G29, since we don't know where we are</comment>
            }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifdef>
            <expr_stmt><expr><call><name>dock_sled</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>
            <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// make sure the bed_level_rotation_matrix is identity or the planner will get it incorectly</comment>
            <comment type="line">//vector_3 corrected_position = plan_get_position_mm();</comment>
            <comment type="line">//corrected_position.debug("position before G29");</comment>
            <expr_stmt><expr><call><name><name>plan_bed_level_matrix</name>.<name>set_to_identity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <decl_stmt><decl><type><name>vector_3</name></type> <name>uncorrected_position</name> <init>= <expr><call><name>plan_get_position</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <comment type="line">//uncorrected_position.debug("position durring G29");</comment>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>uncorrected_position</name>.<name>x</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>uncorrected_position</name>.<name>y</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>uncorrected_position</name>.<name>z</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>setup_for_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTO_BED_LEVELING_GRID</name></cpp:ifdef>
            <comment type="line">// probe at the points of a lattice grid</comment>

            <decl_stmt><decl><type><name>int</name></type> <name>xGridSpacing</name> <init>= <expr>(<name>RIGHT_PROBE_BED_POSITION</name> - <name>LEFT_PROBE_BED_POSITION</name>) / (<name>AUTO_BED_LEVELING_GRID_POINTS</name>-1)</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>yGridSpacing</name> <init>= <expr>(<name>BACK_PROBE_BED_POSITION</name> - <name>FRONT_PROBE_BED_POSITION</name>) / (<name>AUTO_BED_LEVELING_GRID_POINTS</name>-1)</expr></init></decl>;</decl_stmt>


            <comment type="line">// solve the plane equation ax + by + d = z</comment>
            <comment type="line">// A is the matrix with rows [x y 1] for all the probed points</comment>
            <comment type="line">// B is the vector of the Z positions</comment>
            <comment type="line">// the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0</comment>
            <comment type="line">// so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z</comment>

            <comment type="line">// "A" matrix of the linear system of equations</comment>
            <decl_stmt><decl><type><name>double</name></type> <name><name>eqnAMatrix</name><index>[<expr><name>AUTO_BED_LEVELING_GRID_POINTS</name>*<name>AUTO_BED_LEVELING_GRID_POINTS</name>*3</expr>]</index></name></decl>;</decl_stmt>
            <comment type="line">// "B" vector of Z points</comment>
            <decl_stmt><decl><type><name>double</name></type> <name><name>eqnBVector</name><index>[<expr><name>AUTO_BED_LEVELING_GRID_POINTS</name>*<name>AUTO_BED_LEVELING_GRID_POINTS</name></expr>]</index></name></decl>;</decl_stmt>


            <decl_stmt><decl><type><name>int</name></type> <name>probePointCounter</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>bool</name></type> <name>zig</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>

            <for>for (<init><decl><type><name>int</name></type> <name>yProbe</name><init>=<expr><name>FRONT_PROBE_BED_POSITION</name></expr></init></decl>;</init> <condition><expr><name>yProbe</name> &lt;= <name>BACK_PROBE_BED_POSITION</name></expr>;</condition> <incr><expr><name>yProbe</name> += <name>yGridSpacing</name></expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>int</name></type> <name>xProbe</name></decl>, <decl><type ref="prev"/><name>xInc</name></decl>;</decl_stmt>
              <if>if <condition>(<expr><name>zig</name></expr>)</condition><then>
              <block>{
                <expr_stmt><expr><name>xProbe</name> = <name>LEFT_PROBE_BED_POSITION</name></expr>;</expr_stmt>
                <comment type="line">//xEnd = RIGHT_PROBE_BED_POSITION;</comment>
                <expr_stmt><expr><name>xInc</name> = <name>xGridSpacing</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>zig</name> = false</expr>;</expr_stmt>
              }</block></then> <else>else <comment type="line">// zag</comment>
              <block>{
                <expr_stmt><expr><name>xProbe</name> = <name>RIGHT_PROBE_BED_POSITION</name></expr>;</expr_stmt>
                <comment type="line">//xEnd = LEFT_PROBE_BED_POSITION;</comment>
                <expr_stmt><expr><name>xInc</name> = -<name>xGridSpacing</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>zig</name> = true</expr>;</expr_stmt>
              }</block></else></if>

              <for>for (<init><decl><type><name>int</name></type> <name>xCount</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>xCount</name> &lt; <name>AUTO_BED_LEVELING_GRID_POINTS</name></expr>;</condition> <incr><expr><name>xCount</name>++</expr></incr>)
              <block>{
                <decl_stmt><decl><type><name>float</name></type> <name>z_before</name></decl>;</decl_stmt>
                <if>if <condition>(<expr><name>probePointCounter</name> == 0</expr>)</condition><then>
                <block>{
                  <comment type="line">// raise before probing</comment>
                  <expr_stmt><expr><name>z_before</name> = <name>Z_RAISE_BEFORE_PROBING</name></expr>;</expr_stmt>
                }</block></then> <else>else
                <block>{
                  <comment type="line">// raise extruder</comment>
                  <expr_stmt><expr><name>z_before</name> = <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>Z_RAISE_BETWEEN_PROBINGS</name></expr>;</expr_stmt>
                }</block></else></if>

                <decl_stmt><decl><type><name>float</name></type> <name>measured_z</name> <init>= <expr><call><name>probe_pt</name><argument_list>(<argument><expr><name>xProbe</name></expr></argument>, <argument><expr><name>yProbe</name></expr></argument>, <argument><expr><name>z_before</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <expr_stmt><expr><name><name>eqnBVector</name><index>[<expr><name>probePointCounter</name></expr>]</index></name> = <name>measured_z</name></expr>;</expr_stmt>

                <expr_stmt><expr><name><name>eqnAMatrix</name><index>[<expr><name>probePointCounter</name> + 0*<name>AUTO_BED_LEVELING_GRID_POINTS</name>*<name>AUTO_BED_LEVELING_GRID_POINTS</name></expr>]</index></name> = <name>xProbe</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>eqnAMatrix</name><index>[<expr><name>probePointCounter</name> + 1*<name>AUTO_BED_LEVELING_GRID_POINTS</name>*<name>AUTO_BED_LEVELING_GRID_POINTS</name></expr>]</index></name> = <name>yProbe</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>eqnAMatrix</name><index>[<expr><name>probePointCounter</name> + 2*<name>AUTO_BED_LEVELING_GRID_POINTS</name>*<name>AUTO_BED_LEVELING_GRID_POINTS</name></expr>]</index></name> = 1</expr>;</expr_stmt>
                <expr_stmt><expr><name>probePointCounter</name>++</expr>;</expr_stmt>
                <expr_stmt><expr><name>xProbe</name> += <name>xInc</name></expr>;</expr_stmt>
              }</block></for>
            }</block></for>
            <expr_stmt><expr><call><name>clean_up_after_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// solve lsq problem</comment>
            <decl_stmt><decl><type><name>double</name> *</type><name>plane_equation_coefficients</name> <init>= <expr><call><name>qr_solve</name><argument_list>(<argument><expr><name>AUTO_BED_LEVELING_GRID_POINTS</name>*<name>AUTO_BED_LEVELING_GRID_POINTS</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><name>eqnAMatrix</name></expr></argument>, <argument><expr><name>eqnBVector</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Eqn coefficients: a: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>plane_equation_coefficients</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" b: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>plane_equation_coefficients</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" d: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name><name>plane_equation_coefficients</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


            <expr_stmt><expr><call><name>set_bed_level_equation_lsq</name><argument_list>(<argument><expr><name>plane_equation_coefficients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>plane_equation_coefficients</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">// AUTO_BED_LEVELING_GRID not defined</comment>

            <comment type="line">// Probe at 3 arbitrary points</comment>
            <comment type="line">// probe 1</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>z_at_pt_1</name> <init>= <expr><call><name>probe_pt</name><argument_list>(<argument><expr><name>ABL_PROBE_PT_1_X</name></expr></argument>, <argument><expr><name>ABL_PROBE_PT_1_Y</name></expr></argument>, <argument><expr><name>Z_RAISE_BEFORE_PROBING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// probe 2</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>z_at_pt_2</name> <init>= <expr><call><name>probe_pt</name><argument_list>(<argument><expr><name>ABL_PROBE_PT_2_X</name></expr></argument>, <argument><expr><name>ABL_PROBE_PT_2_Y</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>Z_RAISE_BETWEEN_PROBINGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <comment type="line">// probe 3</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>z_at_pt_3</name> <init>= <expr><call><name>probe_pt</name><argument_list>(<argument><expr><name>ABL_PROBE_PT_3_X</name></expr></argument>, <argument><expr><name>ABL_PROBE_PT_3_Y</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>Z_RAISE_BETWEEN_PROBINGS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>clean_up_after_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>set_bed_level_equation_3pts</name><argument_list>(<argument><expr><name>z_at_pt_1</name></expr></argument>, <argument><expr><name>z_at_pt_2</name></expr></argument>, <argument><expr><name>z_at_pt_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// AUTO_BED_LEVELING_GRID</comment>
            <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <comment type="line">// The following code correct the Z height difference from z-probe position and hotend tip position.</comment>
            <comment type="line">// The Z height on homing is measured by Z-Probe, but the probe is quite far from the hotend.</comment>
            <comment type="line">// When the bed is uneven, this height must be corrected.</comment>
            <expr_stmt><expr><name>real_z</name> = <call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>  <comment type="line">//get the real Z (since the auto bed leveling is already correcting the plane)</comment>
            <expr_stmt><expr><name>x_tmp</name> = <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name>X_PROBE_OFFSET_FROM_EXTRUDER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>y_tmp</name> = <name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> + <name>Y_PROBE_OFFSET_FROM_EXTRUDER</name></expr>;</expr_stmt>
            <expr_stmt><expr><name>z_tmp</name> = <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>apply_rotation_xyz</name><argument_list>(<argument><expr><name>plan_bed_level_matrix</name></expr></argument>, <argument><expr><name>x_tmp</name></expr></argument>, <argument><expr><name>y_tmp</name></expr></argument>, <argument><expr><name>z_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>         <comment type="line">//Apply the correction sending the probe offset</comment>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>z_tmp</name> - <name>real_z</name> + <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>   <comment type="line">//The difference is added to current position and sent to planner.</comment>
            <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifdef>
            <expr_stmt><expr><call><name>dock_sled</name><argument_list>(<argument><expr>true</expr></argument>, <argument><expr>-<name>SLED_DOCKING_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// correct for over travel.</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>
        }</block>
        <break>break;</break>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>Z_PROBE_SLED</name></cpp:ifndef>
    </case><case>case <expr>30</expr>: <comment type="line">// G30 Single Z Probe</comment>
        <block>{
            <expr_stmt><expr><call><name>engage_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Engage Z Servo endstop if available</comment>
            <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <comment type="line">// TODO: make sure the bed_level_rotation_matrix is identity or the planner will get set incorectly</comment>
            <expr_stmt><expr><call><name>setup_for_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name>feedrate</name> = <name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>run_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_BED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" X: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Y: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Z: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>clean_up_after_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Retract Z Servo endstop if available</comment>
        }</block>
        <break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    </case><case>case <expr>31</expr>: <comment type="line">// dock the sled</comment>
        <expr_stmt><expr><call><name>dock_sled</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
    </case><case>case <expr>32</expr>: <comment type="line">// undock the sled</comment>
        <expr_stmt><expr><call><name>dock_sled</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// Z_PROBE_SLED</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_AUTO_BED_LEVELING</comment>
    </case><case>case <expr>90</expr>: <comment type="line">// G90</comment>
      <expr_stmt><expr><name>relative_mode</name> = false</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>91</expr>: <comment type="line">// G91</comment>
      <expr_stmt><expr><name>relative_mode</name> = true</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>92</expr>: <comment type="line">// G92</comment>
      <if>if<condition>(<expr>!<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
           <if>if<condition>(<expr><name>i</name> == <name>E_AXIS</name></expr>)</condition><then> <block>{
             <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
             <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           }</block></then>
           <else>else <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
		<if>if <condition>(<expr><name>i</name> == <name>X_AXIS</name> || <name>i</name> == <name>Y_AXIS</name></expr>)</condition><then> <block>{
                	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  
		}</block></then>
		<else>else <block>{
                <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homing</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>  
            	}</block></else></if>  
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call>+<name><name>add_homing</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           }</block></else></if>
        }</block></then></if>
      }</block></for>
      <break>break;</break>
    </case>}</block></switch>
  }</block></then>

  <else>else <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'M'</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <switch>switch<condition>( <expr>(<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr> )</condition>
    <block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
    <case>case <expr>0</expr>: <comment type="line">// M0 - Unconditional stop - Wait for user button press on LCD</comment>
    </case><case>case <expr>1</expr>: <comment type="line">// M1 - Conditional stop - Wait for user button press on LCD</comment>
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>src</name> <init>= <expr><name>strchr_pointer</name> + 2</expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>codenum</name> = 0</expr>;</expr_stmt>

      <decl_stmt><decl><type><name>bool</name></type> <name>hasP</name> <init>= <expr>false</expr></init>, <name>hasS</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// milliseconds to wait</comment>
        <expr_stmt><expr><name>hasP</name> = <name>codenum</name> &gt; 0</expr>;</expr_stmt>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>codenum</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt> <comment type="line">// seconds to wait</comment>
        <expr_stmt><expr><name>hasS</name> = <name>codenum</name> &gt; 0</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>starpos</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>'*'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then> <expr_stmt><expr>*(<name>starpos</name>) = '\0'</expr>;</expr_stmt></then></if>
      <while>while <condition>(<expr>*<name>src</name> == ' '</expr>)</condition> <expr_stmt><expr>++<name>src</name></expr>;</expr_stmt></while>
      <if>if <condition>(<expr>!<name>hasP</name> &amp;&amp; !<name>hasS</name> &amp;&amp; *<name>src</name> != '\0'</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> <else>else <block>{
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_USERWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>

      <expr_stmt><expr><call><name>lcd_ignore_click</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>codenum</name> &gt; 0</expr>)</condition><then><block>{
        <expr_stmt><expr><name>codenum</name> += <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>  <comment type="line">// keep track of when we started waiting</comment>
        <while>while<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> &lt; <name>codenum</name> &amp;&amp; !<call><name>lcd_clicked</name><argument_list>()</argument_list></call></expr>)</condition><block>{
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>lcd_ignore_click</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
          <if>if <condition>(<expr>!<call><name>lcd_detected</name><argument_list>()</argument_list></call></expr>)</condition><then>
            <break>break;</break></then></if>
        <while>while<condition>(<expr>!<call><name>lcd_clicked</name><argument_list>()</argument_list></call></expr>)</condition><block>{
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
      }</block></else></if>
      <if>if <condition>(<expr><name>IS_SD_PRINTING</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_RESUMING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>WELCOME_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>17</expr>:
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_NO_MOVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>enable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
    </case><case>case <expr>20</expr>: <comment type="line">// M20 - list SD card</comment>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_BEGIN_FILE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>card</name>.<name>ls</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_END_FILE_LIST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>21</expr>: <comment type="line">// M21 - init SD card</comment>

      <expr_stmt><expr><call><name><name>card</name>.<name>initsd</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    </case><case>case <expr>22</expr>: <comment type="line">//M22 - release SD card</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>release</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    </case><case>case <expr>23</expr>: <comment type="line">//M23 - Select file</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name>!=<name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*(<name>starpos</name>)='\0'</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>24</expr>: <comment type="line">//M24 - Start SD print</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>startFileprint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>starttime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>25</expr>: <comment type="line">//M25 - Pause SD print</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>pauseSDPrint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>26</expr>: <comment type="line">//M26 - Set SD index</comment>
      <if>if<condition>(<expr><name><name>card</name>.<name>cardOK</name></name> &amp;&amp; <call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name><name>card</name>.<name>setIndex</name></name><argument_list>(<argument><expr><call><name>code_value_long</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><case>case <expr>27</expr>: <comment type="line">//M27 - Get SD status</comment>
      <expr_stmt><expr><call><name><name>card</name>.<name>getStatus</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>28</expr>: <comment type="line">//M28 - Start SD write</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then><block>{
        <decl_stmt><decl><type><name>char</name>*</type> <name>npos</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>npos</name></expr></argument>,<argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>starpos</name>) = '\0'</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name>+4</expr></argument>,<argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>29</expr>: <comment type="line">//M29 - Stop SD write</comment>
      <comment type="line">//processed in write to file routine above</comment>
      <comment type="line">//card,saving = false;</comment>
      <break>break;</break>
    </case><case>case <expr>30</expr>: <comment type="line">//M30 &lt;filename&gt; Delete File</comment>
      <if>if <condition>(<expr><name><name>card</name>.<name>cardOK</name></name></expr>)</condition><then><block>{
        <expr_stmt><expr><call><name><name>card</name>.<name>closefile</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        <if>if<condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then><block>{
          <decl_stmt><decl><type><name>char</name>*</type> <name>npos</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>npos</name></expr></argument>,<argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
          <expr_stmt><expr>*(<name>starpos</name>) = '\0'</expr>;</expr_stmt>
        }</block></then></if>
        <expr_stmt><expr><call><name><name>card</name>.<name>removeFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><case>case <expr>32</expr>: <comment type="line">//M32 - Select file and start SD print</comment>
    <block>{
      <if>if<condition>(<expr><name><name>card</name>.<name>sdprinting</name></name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      }</block></then></if>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>

      <decl_stmt><decl><type><name>char</name>*</type> <name>namestartpos</name> <init>= <expr>(<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 4</expr></argument>,<argument><expr>'!'</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>   <comment type="line">//find ! to indicate filename string start.</comment>
      <if>if<condition>(<expr><name>namestartpos</name>==<name>NULL</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>namestartpos</name>=<name>strchr_pointer</name> + 4</expr>;</expr_stmt> <comment type="line">//default name position, 4 letters after the M</comment>
      }</block></then>
      <else>else
        <expr_stmt><expr><name>namestartpos</name>++</expr>;</expr_stmt></else></if> <comment type="line">//to skip the '!'</comment>

      <if>if<condition>(<expr><name>starpos</name>!=<name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*(<name>starpos</name>)='\0'</expr>;</expr_stmt></then></if>

      <decl_stmt><decl><type><name>bool</name></type> <name>call_procedure</name><init>=<expr>(<call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>

      <if>if<condition>(<expr><name>strchr_pointer</name>&gt;<name>namestartpos</name></expr>)</condition><then>
        <expr_stmt><expr><name>call_procedure</name>=false</expr>;</expr_stmt></then></if>  <comment type="line">//false alert, 'P' found within filename</comment>

      <if>if<condition>( <expr><name><name>card</name>.<name>cardOK</name></name></expr> )</condition><then>
      <block>{
        <expr_stmt><expr><call><name><name>card</name>.<name>openFile</name></name><argument_list>(<argument><expr><name>namestartpos</name></expr></argument>,<argument><expr>true</expr></argument>,<argument><expr>!<name>call_procedure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
          <if>if<condition>(<expr><name>strchr_pointer</name>&lt;<name>namestartpos</name></expr>)</condition><then> <comment type="line">//only if "S" is occuring _before_ the filename</comment>
            <expr_stmt><expr><call><name><name>card</name>.<name>setIndex</name></name><argument_list>(<argument><expr><call><name>code_value_long</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></then></if>
        <expr_stmt><expr><call><name><name>card</name>.<name>startFileprint</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr>!<name>call_procedure</name></expr>)</condition><then>
          <expr_stmt><expr><name>starttime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">//procedure calls count as normal print time.</comment>
      }</block></then></if>
    }</block> <break>break;</break>
    </case><case>case <expr>928</expr>: <comment type="line">//M928 - Start SD write</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 5</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name> != <name>NULL</name></expr>)</condition><then><block>{
        <decl_stmt><decl><type><name>char</name>*</type> <name>npos</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>, <argument><expr>'N'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>strchr_pointer</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>npos</name></expr></argument>,<argument><expr>' '</expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
        <expr_stmt><expr>*(<name>starpos</name>) = '\0'</expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><call><name><name>card</name>.<name>openLogFile</name></name><argument_list>(<argument><expr><name>strchr_pointer</name>+5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>

    </case><case>case <expr>31</expr>: <comment type="line">//M31 take time since the start of the SD print or an M109 command</comment>
      <block>{
      <expr_stmt><expr><name>stoptime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>time</name><index>[<expr>30</expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name><init>=<expr>(<name>stoptime</name>-<name>starttime</name>)/1000</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>sec</name></decl>,<decl><type ref="prev"/><name>min</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>min</name>=<name>t</name>/60</expr>;</expr_stmt>
      <expr_stmt><expr><name>sec</name>=<name>t</name>%60</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf_P</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><call><name>PSTR</name><argument_list>(<argument><expr>"%i min, %i sec"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>sec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>autotempShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    </case><case>case <expr>42</expr>: <comment type="line">//M42 -Change pin status via gcode</comment>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>pin_status</name> <init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>pin_number</name> <init>= <expr><name>LED_PIN</name></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call> &amp;&amp; <name>pin_status</name> &gt;= 0 &amp;&amp; <name>pin_status</name> &lt;= 255</expr>)</condition><then>
          <expr_stmt><expr><name>pin_number</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call>(<name>int8_t</name>)<argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sensitive_pins</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <if>if <condition>(<expr><name><name>sensitive_pins</name><index>[<expr><name>i</name></expr>]</index></name> == <name>pin_number</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name>pin_number</name> = -1</expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></for>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>FAN_PIN</name> &gt; -1</expr></cpp:if>
        <if>if <condition>(<expr><name>pin_number</name> == <name>FAN_PIN</name></expr>)</condition><then>
          <expr_stmt><expr><name>fanSpeed</name> = <name>pin_status</name></expr>;</expr_stmt></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <if>if <condition>(<expr><name>pin_number</name> &gt; -1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>pin_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>pin_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
     <break>break;</break>

<comment type="line">// M48 Z-Probe repeatability measurement function.</comment>
<comment type="line">//</comment>
<comment type="line">// Usage:   M48 &lt;n #_samples&gt; &lt;X X_position_for_samples&gt; &lt;Y Y_position_for_samples&gt; &lt;V Verbose_Level&gt; &lt;Engage_probe_for_each_reading&gt; &lt;L legs_of_movement_prior_to_doing_probe&gt;</comment>
<comment type="line">//	</comment>
<comment type="line">// This function assumes the bed has been homed.  Specificaly, that a G28 command</comment>
<comment type="line">// as been issued prior to invoking the M48 Z-Probe repeatability measurement function.</comment>
<comment type="line">// Any information generated by a prior G29 Bed leveling command will be lost and need to be</comment>
<comment type="line">// regenerated.</comment>
<comment type="line">//</comment>
<comment type="line">// The number of samples will default to 10 if not specified.  You can use upper or lower case</comment>
<comment type="line">// letters for any of the options EXCEPT n.  n must be in lower case because Marlin uses a capital</comment>
<comment type="line">// N for its communication protocol and will get horribly confused if you send it a capital N.</comment>
<comment type="line">//</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>Z_PROBE_REPEATABILITY_TEST</name></cpp:ifdef> 

    </case><case>case <expr>48</expr>: <comment type="line">// M48 Z-Probe repeatability</comment>
        <block>{
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>Z_MIN_PIN</name> == -1</expr></cpp:if>
            <cpp:error>#<cpp:directive>error</cpp:directive> "You must have a Z_MIN endstop in order to enable calculation of Z-Probe repeatability."</cpp:error>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>double</name></type> <name>sum</name><init>=<expr>0.0</expr></init></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>double</name></type> <name>mean</name><init>=<expr>0.0</expr></init></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>double</name></type> <name>sigma</name><init>=<expr>0.0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name><name>sample_set</name><index>[<expr>50</expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>verbose_level</name><init>=<expr>1</expr></init>, <name>n</name><init>=<expr>0</expr></init>, <name>j</name></decl>, <decl><type ref="prev"/><name>n_samples</name> <init>= <expr>10</expr></init>, <name>n_legs</name><init>=<expr>0</expr></init>, <name>engage_probe_for_each_reading</name><init>=<expr>0</expr></init></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>X_current</name></decl>, <decl><type ref="prev"/><name>Y_current</name></decl>, <decl><type ref="prev"/><name>Z_current</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>X_probe_location</name></decl>, <decl><type ref="prev"/><name>Y_probe_location</name></decl>, <decl><type ref="prev"/><name>Z_start_location</name></decl>, <decl><type ref="prev"/><name>ext_position</name></decl>;</decl_stmt>
	
	<if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'V'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'v'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        	<expr_stmt><expr><name>verbose_level</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>verbose_level</name><argument_list>&lt;<argument><expr>0 || <name>verbose_level</name></expr></argument>&gt;</argument_list></name>4</expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"?Verbose Level not plausable.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Sigma_Exit</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><name>verbose_level</name> &gt; 0</expr>)</condition><then>   <block>{
		<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"M48 Z-Probe Repeatability test.   Version 2.00\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Full support at: http://3dprintboard.com/forum.php\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'n'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        	<expr_stmt><expr><name>n_samples</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>n_samples</name><argument_list>&lt;<argument><expr>4 || <name>n_samples</name></expr></argument>&gt;</argument_list></name>50</expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"?Specified sample size not plausable.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Sigma_Exit</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<expr_stmt><expr><name>X_current</name> = <name>X_probe_location</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Y_current</name> = <name>Y_probe_location</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Z_current</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Z_start_location</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call> + <name>Z_RAISE_BEFORE_PROBING</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ext_position</name>	 = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>E_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'e'</expr></argument>)</argument_list></call></expr> )</condition><then> 
		<expr_stmt><expr><name>engage_probe_for_each_reading</name>++</expr>;</expr_stmt></then></if>

	<if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'x'</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
        	<expr_stmt><expr><name>X_probe_location</name> = <call><name>code_value</name><argument_list>()</argument_list></call> -  <name>X_PROBE_OFFSET_FROM_EXTRUDER</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>X_probe_location</name><argument_list>&lt;<argument><expr><name>X_MIN_POS</name> || <name>X_probe_location</name></expr></argument>&gt;</argument_list></name><name>X_MAX_POS</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"?Specified X position out of range.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Sigma_Exit</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'y'</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
        	<expr_stmt><expr><name>Y_probe_location</name> = <call><name>code_value</name><argument_list>()</argument_list></call> -  <name>Y_PROBE_OFFSET_FROM_EXTRUDER</name></expr>;</expr_stmt>
		<if>if <condition>(<expr><name><name>Y_probe_location</name><argument_list>&lt;<argument><expr><name>Y_MIN_POS</name> || <name>Y_probe_location</name></expr></argument>&gt;</argument_list></name><name>Y_MAX_POS</name></expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"?Specified Y position out of range.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Sigma_Exit</name>;</goto>
		}</block></then></if>
	}</block></then></if>

	<if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call> || <call><name>code_seen</name><argument_list>(<argument><expr>'l'</expr></argument>)</argument_list></call></expr> )</condition><then> <block>{
        	<expr_stmt><expr><name>n_legs</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if>if <condition>( <expr><name>n_legs</name>==1</expr> )</condition><then> 
			<expr_stmt><expr><name>n_legs</name> = 2</expr>;</expr_stmt></then></if>
		<if>if <condition>( <expr><name><name>n_legs</name><argument_list>&lt;<argument><expr>0 || <name>n_legs</name></expr></argument>&gt;</argument_list></name>15</expr> )</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"?Specified number of legs in movement not plausable.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>Sigma_Exit</name>;</goto>
		}</block></then></if>
	}</block></then></if>

<comment type="line">//</comment>
<comment type="line">// Do all the preliminary setup work.   First raise the probe.</comment>
<comment type="line">//</comment>

        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name><name>plan_bed_level_matrix</name>.<name>set_to_identity</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>( <argument><expr><name>X_current</name></expr></argument>, <argument><expr><name>Y_current</name></expr></argument>, <argument><expr><name>Z_start_location</name></expr></argument>,
			<argument><expr><name>ext_position</name></expr></argument>,
    			<argument><expr><name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>/60</expr></argument>,
			<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<comment type="line">//</comment>
<comment type="line">// Now get everything to the specified probe point So we can safely do a probe to</comment>
<comment type="line">// get us close to the bed.  If the Z-Axis is far from the bed, we don't want to </comment>
<comment type="line">// use that as a starting point for each probe.</comment>
<comment type="line">//</comment>
	<if>if <condition>(<expr><name>verbose_level</name> &gt; 2</expr>)</condition><then> 
		<expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>"Positioning probe for the test.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

	<expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>( <argument><expr><name>X_probe_location</name></expr></argument>, <argument><expr><name>Y_probe_location</name></expr></argument>, <argument><expr><name>Z_start_location</name></expr></argument>,
			<argument><expr><name>ext_position</name></expr></argument>,
    			<argument><expr><name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/60</expr></argument>,
			<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>X_current</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name>Y_current</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>Z_current</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name> = <name>ext_position</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>E_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="line">// </comment>
<comment type="line">// OK, do the inital probe to get us close to the bed.</comment>
<comment type="line">// Then retrace the right amount and use that in subsequent probes</comment>
<comment type="line">//</comment>

        <expr_stmt><expr><call><name>engage_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	

	<expr_stmt><expr><call><name>setup_for_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>run_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>Z_current</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>Z_start_location</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call> + <name>Z_RAISE_BEFORE_PROBING</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>( <argument><expr><name>X_probe_location</name></expr></argument>, <argument><expr><name>Y_probe_location</name></expr></argument>, <argument><expr><name>Z_start_location</name></expr></argument>,
			<argument><expr><name>ext_position</name></expr></argument>,
    			<argument><expr><name><name>homing_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/60</expr></argument>,
			<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name>Z_current</name> = <call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if>if <condition>(<expr><name>engage_probe_for_each_reading</name></expr>)</condition><then>
        	<expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <for>for( <init><expr><name>n</name>=0</expr>;</init> <condition><expr><name>n</name>&lt;<name>n_samples</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>) <block>{

		<expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>( <argument><expr><name>X_probe_location</name></expr></argument>, <argument><expr><name>Y_probe_location</name></expr></argument>, <argument><expr><name>Z_start_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Make sure we are at the probe location</comment>

		<if>if <condition>( <expr><name>n_legs</name></expr>)</condition><then>  <block>{
		<decl_stmt><decl><type><name>double</name></type> <name>radius</name><init>=<expr>0.0</expr></init>, <name>theta</name><init>=<expr>0.0</expr></init>, <name>x_sweep</name></decl>, <decl><type ref="prev"/><name>y_sweep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>rotational_direction</name></decl>, <decl><type ref="prev"/><name>l</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rotational_direction</name> = (<name>unsigned</name> <name>long</name>) <call><name>millis</name><argument_list>()</argument_list></call> &amp; 0x0001</expr>;</expr_stmt>			<comment type="line">// clockwise or counter clockwise</comment>
			<expr_stmt><expr><name>radius</name> = (<name>unsigned</name> <name>long</name>) <call><name>millis</name><argument_list>()</argument_list></call> % <call>(<name>long</name>) <argument_list>(<argument><expr><name>X_MAX_LENGTH</name>/4</expr></argument>)</argument_list></call></expr>;</expr_stmt> 			<comment type="line">// limit how far out to go </comment>
			<expr_stmt><expr><name>theta</name> = <call>(<name>float</name>) <argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>) <call><name>millis</name><argument_list>()</argument_list></call> % (<name>long</name>) 360</expr></argument>)</argument_list></call> / (360./(2*3.1415926))</expr>;</expr_stmt>	<comment type="line">// turn into radians</comment>

<comment type="line">//SERIAL_ECHOPAIR("starting radius: ",radius);</comment>
<comment type="line">//SERIAL_ECHOPAIR("   theta: ",theta);</comment>
<comment type="line">//SERIAL_ECHOPAIR("   direction: ",rotational_direction);</comment>
<comment type="line">//SERIAL_PROTOCOLLNPGM("");</comment>

			<for>for( <init><expr><name>l</name>=0</expr>;</init> <condition><expr><name>l</name>&lt;<name>n_legs</name>-1</expr>;</condition> <incr><expr><name>l</name>++</expr></incr>) <block>{
				<if>if <condition>(<expr><name>rotational_direction</name>==1</expr>)</condition><then>
					<expr_stmt><expr><name>theta</name> += <call>(<name>float</name>) <argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>) <call><name>millis</name><argument_list>()</argument_list></call> % (<name>long</name>) 20</expr></argument>)</argument_list></call> / (360.0/(2*3.1415926))</expr>;</expr_stmt></then> <comment type="line">// turn into radians</comment>
				<else>else
					<expr_stmt><expr><name>theta</name> -= <call>(<name>float</name>) <argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>) <call><name>millis</name><argument_list>()</argument_list></call> % (<name>long</name>) 20</expr></argument>)</argument_list></call> / (360.0/(2*3.1415926))</expr>;</expr_stmt></else></if> <comment type="line">// turn into radians</comment>

				<expr_stmt><expr><name>radius</name> += <call>(<name>float</name>) <argument_list>( <argument><expr>(<call>(<name>long</name>) <argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>) <call><name>millis</name><argument_list>()</argument_list></call> % (<name>long</name>) 10</expr></argument>)</argument_list></call>) - 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if>if <condition>( <expr><name>radius</name>&lt;0.0</expr> )</condition><then>
					<expr_stmt><expr><name>radius</name> = -<name>radius</name></expr>;</expr_stmt></then></if>

				<expr_stmt><expr><name>X_current</name> = <name>X_probe_location</name> + <call><name>cos</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call> * <name>radius</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>Y_current</name> = <name>Y_probe_location</name> + <call><name>sin</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call> * <name>radius</name></expr>;</expr_stmt>

				<if>if <condition>( <expr><name>X_current</name>&lt;<name>X_MIN_POS</name></expr>)</condition><then>		<comment type="line">// Make sure our X &amp; Y are sane</comment>
					 <expr_stmt><expr><name>X_current</name> = <name>X_MIN_POS</name></expr>;</expr_stmt></then></if>
				<if>if <condition>( <expr><name>X_current</name>&gt;<name>X_MAX_POS</name></expr>)</condition><then>
					 <expr_stmt><expr><name>X_current</name> = <name>X_MAX_POS</name></expr>;</expr_stmt></then></if>

				<if>if <condition>( <expr><name>Y_current</name>&lt;<name>Y_MIN_POS</name></expr>)</condition><then>		<comment type="line">// Make sure our X &amp; Y are sane</comment>
					 <expr_stmt><expr><name>Y_current</name> = <name>Y_MIN_POS</name></expr>;</expr_stmt></then></if>
				<if>if <condition>( <expr><name>Y_current</name>&gt;<name>Y_MAX_POS</name></expr>)</condition><then>
					 <expr_stmt><expr><name>Y_current</name> = <name>Y_MAX_POS</name></expr>;</expr_stmt></then></if>

				<if>if <condition>(<expr><name>verbose_level</name>&gt;3</expr> )</condition><then> <block>{
					<expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"x: "</expr></argument>, <argument><expr><name>X_current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SERIAL_ECHOPAIR</name><argument_list>(<argument><expr>"y: "</expr></argument>, <argument><expr><name>Y_current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
				}</block></then></if>

				<expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>( <argument><expr><name>X_current</name></expr></argument>, <argument><expr><name>Y_current</name></expr></argument>, <argument><expr><name>Z_current</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
			}</block></for>
			<expr_stmt><expr><call><name>do_blocking_move_to</name><argument_list>( <argument><expr><name>X_probe_location</name></expr></argument>, <argument><expr><name>Y_probe_location</name></expr></argument>, <argument><expr><name>Z_start_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Go back to the probe location</comment>
		}</block></then></if>

		<if>if <condition>(<expr><name>engage_probe_for_each_reading</name></expr>)</condition><then>  <block>{
        		<expr_stmt><expr><call><name>engage_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	
          		<expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<expr_stmt><expr><call><name>setup_for_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><call><name>run_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sample_set</name><index>[<expr><name>n</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>

<comment type="line">//</comment>
<comment type="line">// Get the current mean for the data points we have so far</comment>
<comment type="line">//</comment>
		<expr_stmt><expr><name>sum</name>=0.0</expr>;</expr_stmt> 
		<for>for( <init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;=<name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>sum</name> = <name>sum</name> + <name><name>sample_set</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>mean</name> = <name>sum</name> / (<call><name>double</name> <argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<comment type="line">//</comment>
<comment type="line">// Now, use that mean to calculate the standard deviation for the</comment>
<comment type="line">// data points we have so far</comment>
<comment type="line">//</comment>

		<expr_stmt><expr><name>sum</name>=0.0</expr>;</expr_stmt> 
		<for>for( <init><expr><name>j</name>=0</expr>;</init> <condition><expr><name>j</name>&lt;=<name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
			<expr_stmt><expr><name>sum</name> = <name>sum</name> + (<name><name>sample_set</name><index>[<expr><name>j</name></expr>]</index></name>-<name>mean</name>) * (<name><name>sample_set</name><index>[<expr><name>j</name></expr>]</index></name>-<name>mean</name>)</expr>;</expr_stmt>
		}</block></for>
		<expr_stmt><expr><name>sigma</name> = <call><name>sqrt</name><argument_list>( <argument><expr><name>sum</name> / (<call><name>double</name> <argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>verbose_level</name> &gt; 1</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" of "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>n_samples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"   z: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>verbose_level</name> &gt; 2</expr>)</condition><then> <block>{
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" mean: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>mean</name></expr></argument>,<argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>"   sigma: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>sigma</name></expr></argument>,<argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>

		<if>if <condition>(<expr><name>verbose_level</name> &gt; 0</expr>)</condition><then> 
			<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

		<expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>( <argument><expr><name>X_probe_location</name></expr></argument>, <argument><expr><name>Y_probe_location</name></expr></argument>, <argument><expr><name>Z_start_location</name></expr></argument>, 
				  <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>homing_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        	<expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if>if <condition>(<expr><name>engage_probe_for_each_reading</name></expr>)</condition><then>  <block>{
        		<expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	
          		<expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
	}</block></for>

        <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>clean_up_after_endstop_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<comment type="line">//      enable_endstops(true);</comment>

	<if>if <condition>(<expr><name>verbose_level</name> &gt; 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Mean: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>mean</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></then></if>

<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Standard Deviation: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><name>sigma</name></expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"\n\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>Sigma_Exit</name>:</label>
        <break>break;</break>
	}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>		<comment type="line">// Z_PROBE_REPEATABILITY_TEST </comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>		<comment type="line">// ENABLE_AUTO_BED_LEVELING</comment>

    </case><case>case <expr>104</expr>: <comment type="line">// M104</comment>
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>104</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
      <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>tmp_extruder</name> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>setTargetHotend1</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call> == 0.0 ? 0.0 : <call><name>code_value</name><argument_list>()</argument_list></call> + <name>duplicate_extruder_temp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>setWatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>112</expr>: <comment type="line">//  M112 -Emergency Stop</comment>
      <expr_stmt><expr><call><name>kill</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>140</expr>: <comment type="line">// M140 set bed temp</comment>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr>105</expr> : <comment type="line">// M105</comment>
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>105</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
        }</block></then></if>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_0_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"ok T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" /"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" B:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" /"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degTargetBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//TEMP_BED_PIN</comment>
        <for>for (<init><decl><type><name>int8_t</name></type> <name>cur_extruder</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>cur_extruder</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr>++<name>cur_extruder</name></expr></incr>) <block>{
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" T"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" /"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degTargetHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_NO_THERMISTORS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" @:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXTRUDER_WATTS</name></cpp:ifdef>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name>EXTRUDER_WATTS</name> * <call><name>getHeaterPower</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>)/127</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"W"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>getHeaterPower</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" B@:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BED_WATTS</name></cpp:ifdef>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name>BED_WATTS</name> * <call><name>getHeaterPower</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call>)/127</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"W"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>getHeaterPower</name><argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SHOW_TEMP_ADC_VALUES</name></cpp:ifdef>
          <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"    ADC B:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"C-&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>rawBedTemp</name><argument_list>()</argument_list></call>/<name>OVERSAMPLENR</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <for>for (<init><decl><type><name>int8_t</name></type> <name>cur_extruder</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>cur_extruder</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr>++<name>cur_extruder</name></expr></incr>) <block>{
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"  T"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"C-&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>rawHotendTemp</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call>/<name>OVERSAMPLENR</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
      <break>break;</break>
    </case><case>case <expr>109</expr>:
    <block>{<comment type="line">// M109 - Wait for extruder heater to reach target.</comment>
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>109</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
      <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_HEATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
        <expr_stmt><expr><name>autotemp_enabled</name>=false</expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>tmp_extruder</name> == 0</expr>)</condition><then>
          <expr_stmt><expr><call><name>setTargetHotend1</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call> == 0.0 ? 0.0 : <call><name>code_value</name><argument_list>()</argument_list></call> + <name>duplicate_extruder_temp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>CooldownNoWait</name> = true</expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>tmp_extruder</name> == 0</expr>)</condition><then>
          <expr_stmt><expr><call><name>setTargetHotend1</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call> == 0.0 ? 0.0 : <call><name>code_value</name><argument_list>()</argument_list></call> + <name>duplicate_extruder_temp_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>CooldownNoWait</name> = false</expr>;</expr_stmt>
      }</block></then></if></else></if>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>autotemp_min</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>autotemp_max</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>autotemp_factor</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>autotemp_enabled</name>=true</expr>;</expr_stmt>
        }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><call><name>setWatch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* See if we are heating up or cooling down */</comment>
      <expr_stmt><expr><name>target_direction</name> = <call><name>isHeatingHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// true if heating, false if cooling</comment>

      <expr_stmt><expr><name>cancel_heatup</name> = false</expr>;</expr_stmt>

      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_RESIDENCY_TIME</name></cpp:ifdef>
        <decl_stmt><decl><type><name>long</name></type> <name>residencyStart</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>residencyStart</name> = -1</expr>;</expr_stmt>
        <comment type="block">/* continue to loop until we have reached the target temp
          _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */</comment>
        <while>while<condition>(<expr>(!<name>cancel_heatup</name>)&amp;&amp;((<name>residencyStart</name> == -1) ||
              (<name>residencyStart</name> &gt;= 0 &amp;&amp; ((<call>(<name>unsigned</name> <name>int</name>) <argument_list>(<argument><expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>residencyStart</name></expr></argument>)</argument_list></call>) &lt; (<name>TEMP_RESIDENCY_TIME</name> * 1000UL))))</expr> )</condition> <block>{
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <while>while <condition>( <expr><name>target_direction</name> ? (<call><name>isHeatingHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>) : (<call><name>isCoolingHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>&amp;&amp;(<name>CooldownNoWait</name>==false))</expr> )</condition> <block>{
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//TEMP_RESIDENCY_TIME</comment>
          <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>codenum</name>) &gt; 1000UL</expr> )</condition><then>
          <block>{ <comment type="line">//Print Temp Reading and remaining time every 1 second while heating up/cooling down</comment>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" E:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name>int</name>)<name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_RESIDENCY_TIME</name></cpp:ifdef>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" W:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if<condition>(<expr><name>residencyStart</name> &gt; -1</expr>)</condition><then>
              <block>{
                 <expr_stmt><expr><name>codenum</name> = ((<name>TEMP_RESIDENCY_TIME</name> * 1000UL) - (<call><name>millis</name><argument_list>()</argument_list></call> - <name>residencyStart</name>)) / 1000UL</expr>;</expr_stmt>
                 <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>( <argument><expr><name>codenum</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
              }</block></then>
              <else>else
              <block>{
                 <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>( <argument><expr>"?"</expr></argument> )</argument_list></call></expr>;</expr_stmt>
              }</block></else></if>
            <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_RESIDENCY_TIME</name></cpp:ifdef>
            <comment type="block">/* start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
              or when current temp falls outside the hysteresis after target temp was reached */</comment>
          <if>if <condition>(<expr>(<name>residencyStart</name> == -1 &amp;&amp;  <name>target_direction</name> &amp;&amp; (<call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call> &gt;= (<call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>-<name>TEMP_WINDOW</name>))) ||
              (<name>residencyStart</name> == -1 &amp;&amp; !<name>target_direction</name> &amp;&amp; (<call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call> &lt;= (<call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call>+<name>TEMP_WINDOW</name>))) ||
              (<name>residencyStart</name> &gt; -1 &amp;&amp; <call><name>labs</name><argument_list>(<argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call> - <call><name>degTargetHotend</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &gt; <name>TEMP_HYSTERESIS</name>)</expr> )</condition><then>
          <block>{
            <expr_stmt><expr><name>residencyStart</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//TEMP_RESIDENCY_TIME</comment>
        }</block></while>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_HEATING_COMPLETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>starttime</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></while>
      <break>break;</break>
    <case>case <expr>190</expr>: <comment type="line">// M190 - Wait for bed heater to reach target.</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_BED_HEATING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>CooldownNoWait</name> = true</expr>;</expr_stmt>
        }</block></then> <else>else <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>CooldownNoWait</name> = false</expr>;</expr_stmt>
        }</block></then></if></else></if>
        <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        
        <expr_stmt><expr><name>cancel_heatup</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>target_direction</name> = <call><name>isHeatingBed</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// true if heating, false if cooling</comment>

        <while>while <condition>( <expr>(<name>target_direction</name>)&amp;&amp;(!<name>cancel_heatup</name>) ? (<call><name>isHeatingBed</name><argument_list>()</argument_list></call>) : (<call><name>isCoolingBed</name><argument_list>()</argument_list></call>&amp;&amp;(<name>CooldownNoWait</name>==false))</expr> )</condition>
        <block>{
          <if>if<condition>(<expr>( <call><name>millis</name><argument_list>()</argument_list></call> - <name>codenum</name>) &gt; 1000</expr> )</condition><then> <comment type="line">//Print Temp Reading every 1 second while heating up.</comment>
          <block>{
            <decl_stmt><decl><type><name>float</name></type> <name>tt</name><init>=<expr><call><name>degHotend</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" E:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name>int</name>)<name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" B:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOL_F</name><argument_list>(<argument><expr><call><name>degBed</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>codenum</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_BED_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>FAN_PIN</name> &gt; -1</expr></cpp:if>
      </case><case>case <expr>106</expr>: <comment type="line">//M106 Fan On</comment>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
           <expr_stmt><expr><name>fanSpeed</name>=<call><name>constrain</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <expr_stmt><expr><name>fanSpeed</name>=255</expr>;</expr_stmt>
        }</block></else></if>
        <break>break;</break>
      </case><case>case <expr>107</expr>: <comment type="line">//M107 Fan Off</comment>
        <expr_stmt><expr><name>fanSpeed</name> = 0</expr>;</expr_stmt>
        <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FAN_PIN</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
      <comment type="line">// PWM for HEATER_1_PIN</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_1_PIN</name> &gt; -1</expr></cpp:if>
        </case><case>case <expr>126</expr>: <comment type="line">//M126 valve open</comment>
          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
             <expr_stmt><expr><name>ValvePressure</name>=<call><name>constrain</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name>ValvePressure</name>=255</expr>;</expr_stmt>
          }</block></else></if>
          <break>break;</break>
        </case><case>case <expr>127</expr>: <comment type="line">//M127 valve closed</comment>
          <expr_stmt><expr><name>ValvePressure</name> = 0</expr>;</expr_stmt>
          <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//HEATER_1_PIN</comment>

      <comment type="line">// PWM for HEATER_2_PIN</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_2_PIN</name> &gt; -1</expr></cpp:if>
        </case><case>case <expr>128</expr>: <comment type="line">//M128 valve open</comment>
          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
             <expr_stmt><expr><name>EtoPPressure</name>=<call><name>constrain</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>255</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name>EtoPPressure</name>=255</expr>;</expr_stmt>
          }</block></else></if>
          <break>break;</break>
        </case><case>case <expr>129</expr>: <comment type="line">//M129 valve closed</comment>
          <expr_stmt><expr><name>EtoPPressure</name> = 0</expr>;</expr_stmt>
          <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//HEATER_2_PIN</comment>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:if>
      </case><case>case <expr>80</expr>: <comment type="line">// M80 - Turn on Power Supply</comment>
        <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//GND</comment>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_AWAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">// If you have a switch on suicide pin, this is useful</comment>
        <comment type="line">// if you want to start another print with suicide feature after</comment>
        <comment type="line">// a print without suicide...</comment>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>SUICIDE_PIN</name> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
            <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
          <expr_stmt><expr><name>powersupply</name> = true</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>WELCOME_MSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <break>break;</break>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      </case><case>case <expr>81</expr>: <comment type="line">// M81 - Turn off Power Supply</comment>
        <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>finishAndDisableSteppers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>fanSpeed</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>1000</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Wait a little before to switch off</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUICIDE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SUICIDE_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>suicide</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:elif>
        <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>, <argument><expr><name>PS_ON_ASLEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ULTIPANEL</name></cpp:ifdef>
        <expr_stmt><expr><name>powersupply</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MACHINE_NAME</name>" "<name>MSG_OFF</name>"."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	  <break>break;</break>

    </case><case>case <expr>82</expr>:
      <expr_stmt><expr><name><name>axis_relative_modes</name><index>[<expr>3</expr>]</index></name> = false</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>83</expr>:
      <expr_stmt><expr><name><name>axis_relative_modes</name><index>[<expr>3</expr>]</index></name> = true</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>18</expr>: <comment type="line">//compatibility</comment>
    </case><case>case <expr>84</expr>: <comment type="line">// M84</comment>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <expr_stmt><expr><name>stepper_inactive_time</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt>
      }</block></then>
      <else>else
      <block>{
        <decl_stmt><decl><type><name>bool</name></type> <name>all_axis</name> <init>= <expr>!((<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>) || (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>)|| (<call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>))</expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><name>all_axis</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>finishAndDisableSteppers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
          <cpp:if>#<cpp:directive>if</cpp:directive> <expr>((<name>E0_ENABLE_PIN</name> != <name>X_ENABLE_PIN</name>) &amp;&amp; (<name>E1_ENABLE_PIN</name> != <name>Y_ENABLE_PIN</name>))</expr></cpp:if> <comment type="line">// Only enable on boards that have seperate ENABLE_PINS</comment>
            <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
              <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
      }</block></else></if>
      <break>break;</break>
    </case><case>case <expr>85</expr>: <comment type="line">// M85</comment>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>max_inactive_time</name> = <call><name>code_value</name><argument_list>()</argument_list></call> * 1000</expr>;</expr_stmt>
      }</block></then></if>
      <break>break;</break>
    </case><case>case <expr>92</expr>: <comment type="line">// M92</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if<condition>(<expr><name>i</name> == 3</expr>)</condition><then> <block>{ <comment type="line">// E</comment>
            <decl_stmt><decl><type><name>float</name></type> <name>value</name> <init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
            <if>if<condition>(<expr><name>value</name> &lt; 20.0</expr>)</condition><then> <block>{
              <decl_stmt><decl><type><name>float</name></type> <name>factor</name> <init>= <expr><name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name> / <name>value</name></expr></init></decl>;</decl_stmt> <comment type="line">// increase e constants if M92 E14 is given for netfab.</comment>
              <expr_stmt><expr><name>max_e_jerk</name> *= <name>factor</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>max_feedrate</name><index>[<expr><name>i</name></expr>]</index></name> *= <name>factor</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>axis_steps_per_sqr_second</name><index>[<expr><name>i</name></expr>]</index></name> *= <name>factor</name></expr>;</expr_stmt>
            }</block></then></if>
            <expr_stmt><expr><name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then></if>
      }</block></for>
      <break>break;</break>
    </case><case>case <expr>115</expr>: <comment type="line">// M115</comment>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_M115_REPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>117</expr>: <comment type="line">// M117 display message</comment>
      <expr_stmt><expr><name>starpos</name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 5</expr></argument>,<argument><expr>'*'</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
      <if>if<condition>(<expr><name>starpos</name>!=<name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr>*(<name>starpos</name>)='\0'</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>lcd_setstatus</name><argument_list>(<argument><expr><name>strchr_pointer</name> + 5</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>114</expr>: <comment type="line">// M114</comment>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"X:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Y:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Z:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" E:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_COUNT_X</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Y:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Z:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>float</name><argument_list>(<argument><expr><call><name>st_get_position</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>/<name><name>axis_steps_per_unit</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
	  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"SCARA Theta:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"   Psi+Theta:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"SCARA Cal - Theta:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>+<name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"   Psi+Theta (90):"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>-<name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>-90+<name><name>add_homing</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"SCARA step Cal - Theta:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/90*<name><name>axis_steps_per_unit</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"   Psi+Theta:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>(<name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>-<name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>)/90*<name><name>axis_steps_per_unit</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    </case><case>case <expr>120</expr>: <comment type="line">// M120</comment>
      <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>false</expr></argument>)</argument_list></call></expr> ;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>121</expr>: <comment type="line">// M121</comment>
      <expr_stmt><expr><call><name>enable_endstops</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr> ;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>119</expr>: <comment type="line">// M119</comment>
    <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>MSG_M119_REPORT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MIN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MIN_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_X_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>X_MIN_PIN</name></expr></argument>)</argument_list></call>^<name>X_MIN_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MAX_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MAX_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_X_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>X_MAX_PIN</name></expr></argument>)</argument_list></call>^<name>X_MAX_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Y_MIN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Y_MIN_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Y_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Y_MIN_PIN</name></expr></argument>)</argument_list></call>^<name>Y_MIN_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Y_MAX_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Y_MAX_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Y_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Y_MAX_PIN</name></expr></argument>)</argument_list></call>^<name>Y_MAX_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_MIN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Z_MIN_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Z_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Z_MIN_PIN</name></expr></argument>)</argument_list></call>^<name>Z_MIN_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_MAX_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>Z_MAX_PIN</name> &gt; -1</expr></cpp:if>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_Z_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>((<call><name>READ</name><argument_list>(<argument><expr><name>Z_MAX_PIN</name></expr></argument>)</argument_list></call>^<name>Z_MAX_ENDSTOP_INVERTING</name>)?<name>MSG_ENDSTOP_HIT</name>:<name>MSG_ENDSTOP_OPEN</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
      <comment type="line">//TODO: update for all axis, use for loop</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BLINKM</name></cpp:ifdef>
    </case><case>case <expr>150</expr>: <comment type="line">// M150</comment>
      <block>{
        <decl_stmt><decl><type><name>byte</name></type> <name>red</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name></type> <name>grn</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>byte</name></type> <name>blu</name></decl>;</decl_stmt>

        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>red</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'U'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>grn</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>blu</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>SendColors</name><argument_list>(<argument><expr><name>red</name></expr></argument>,<argument><expr><name>grn</name></expr></argument>,<argument><expr><name>blu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//BLINKM</comment>
    </case><case>case <expr>200</expr>: <comment type="line">// M200 D&lt;millimeters&gt; set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).</comment>
      <block>{

        <expr_stmt><expr><name>tmp_extruder</name> = <name>active_extruder</name></expr>;</expr_stmt>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>tmp_extruder</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><name>tmp_extruder</name> &gt;= <name>EXTRUDERS</name></expr>)</condition><then> <block>{
            <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M200_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <break>break;</break>
          }</block></then></if>
        }</block></then></if>

        <decl_stmt><decl><type><name>float</name></type> <name>area</name> <init>= <expr>.0</expr></init></decl>;</decl_stmt>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
		  <decl_stmt><decl><type><name>float</name></type> <name>diameter</name> <init>= <expr>(<name>float</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		  <if>if <condition>(<expr><name>diameter</name> == 0.0</expr>)</condition><then> <block>{
			<comment type="line">// setting any extruder filament size disables volumetric on the assumption that</comment>
			<comment type="line">// slicers either generate in extruder values as cubic mm or as as filament feeds</comment>
			<comment type="line">// for all extruders</comment>
		    <expr_stmt><expr><name>volumetric_enabled</name> = false</expr>;</expr_stmt>
		  }</block></then> <else>else <block>{
            <expr_stmt><expr><name><name>filament_size</name><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = (<name>float</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<comment type="line">// make sure all extruders have some sane value for the filament size</comment>
			<expr_stmt><expr><name><name>filament_size</name><index>[<expr>0</expr>]</index></name> = (<name><name>filament_size</name><index>[<expr>0</expr>]</index></name> == 0.0 ? <name>DEFAULT_NOMINAL_FILAMENT_DIA</name> : <name><name>filament_size</name><index>[<expr>0</expr>]</index></name>)</expr>;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
			<expr_stmt><expr><name><name>filament_size</name><index>[<expr>1</expr>]</index></name> = (<name><name>filament_size</name><index>[<expr>1</expr>]</index></name> == 0.0 ? <name>DEFAULT_NOMINAL_FILAMENT_DIA</name> : <name><name>filament_size</name><index>[<expr>1</expr>]</index></name>)</expr>;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
			<expr_stmt><expr><name><name>filament_size</name><index>[<expr>2</expr>]</index></name> = (<name><name>filament_size</name><index>[<expr>2</expr>]</index></name> == 0.0 ? <name>DEFAULT_NOMINAL_FILAMENT_DIA</name> : <name><name>filament_size</name><index>[<expr>2</expr>]</index></name>)</expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>volumetric_enabled</name> = true</expr>;</expr_stmt>
		  }</block></else></if>
        }</block></then> <else>else <block>{
          <comment type="line">//reserved for setting filament diameter via UFID or filament measuring device</comment>
          <break>break;</break>
        }</block></else></if>
		<expr_stmt><expr><call><name>calculate_volumetric_multipliers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    </case><case>case <expr>201</expr>: <comment type="line">// M201</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>max_acceleration_units_per_sq_second</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></for>
      <comment type="line">// steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)</comment>
      <expr_stmt><expr><call><name>reset_acceleration_rates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if> <comment type="line">// Not used for Sprinter/grbl gen6</comment>
    case 202: <comment type="line">// M202</comment>
      for(int8_t i=0; i &lt; NUM_AXIS; i++) {
        if(code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
      }
      break;
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>203</expr>: <comment type="line">// M203 max feedrate mm/sec</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>max_feedrate</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></for>
      <break>break;</break>
    </case><case>case <expr>204</expr>: <comment type="line">// M204 acclereration S normal moves T filmanent only moves</comment>
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>acceleration</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>retract_acceleration</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      }</block>
      <break>break;</break>
    </case><case>case <expr>205</expr>: <comment type="line">//M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>minimumfeedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>mintravelfeedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>minsegmenttime</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>max_xy_jerk</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>max_z_jerk</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>max_e_jerk</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt></then></if>
    }</block>
    <break>break;</break>
    </case><case>case <expr>206</expr>: <comment type="line">// M206 additional homing offset</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>add_homing</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></for>
	  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
	   <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then>       <comment type="line">// Theta</comment>
      <block>{
        <expr_stmt><expr><name><name>add_homing</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then>       <comment type="line">// Psi</comment>
      <block>{
        <expr_stmt><expr><name><name>add_homing</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
	  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <break>break;</break>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
	</case><case>case <expr>665</expr>: <comment type="line">// M665 set delta configurations L&lt;diagonal_rod&gt; R&lt;delta_radius&gt; S&lt;segments_per_sec&gt;</comment>
		<if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>delta_diagonal_rod</name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>delta_radius</name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		<if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
			<expr_stmt><expr><name>delta_segments_per_second</name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		}</block></then></if>
		
		<expr_stmt><expr><call><name>recalc_delta_settings</name><argument_list>(<argument><expr><name>delta_radius</name></expr></argument>, <argument><expr><name>delta_diagonal_rod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
    </case><case>case <expr>666</expr>: <comment type="line">// M666 set delta endstop adjustemnt</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name><name>endstop_adj</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      }</block></for>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FWRETRACT</name></cpp:ifdef>
    </case><case>case <expr>207</expr>: <comment type="line">//M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop]</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_length</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call>/60</expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_zlift</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
    }</block><break>break;</break>
    </case><case>case <expr>208</expr>: <comment type="line">// M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/min]</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_recover_length</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>retract_recover_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call>/60</expr> ;</expr_stmt>
      }</block></then></if>
    }</block><break>break;</break>
    </case><case>case <expr>209</expr>: <comment type="line">// M209 - S&lt;1=true/0=false&gt; enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>t</name><init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl> ;</decl_stmt>
        <switch>switch<condition>(<expr><name>t</name></expr>)</condition>
        <block>{
          <case>case <expr>0</expr>: 
          <block>{
            <expr_stmt><expr><name>autoretract_enabled</name>=false</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>retracted</name><index>[<expr>0</expr>]</index></name>=false</expr>;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
              <expr_stmt><expr><name><name>retracted</name><index>[<expr>1</expr>]</index></name>=false</expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
              <expr_stmt><expr><name><name>retracted</name><index>[<expr>2</expr>]</index></name>=false</expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          }</block><break>break;</break>
          </case><case>case <expr>1</expr>: 
          <block>{
            <expr_stmt><expr><name>autoretract_enabled</name>=true</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>retracted</name><index>[<expr>0</expr>]</index></name>=false</expr>;</expr_stmt>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
              <expr_stmt><expr><name><name>retracted</name><index>[<expr>1</expr>]</index></name>=false</expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
              <expr_stmt><expr><name><name>retracted</name><index>[<expr>2</expr>]</index></name>=false</expr>;</expr_stmt>
            <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          }</block><break>break;</break>
          </case><default>default:
            <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_UNKNOWN_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </default>}</block></switch>
      }</block></then></if>

    }</block><break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// FWRETRACT</comment>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    </case><case>case <expr>218</expr>: <comment type="line">// M218 - set hotend offset (in mm), T&lt;extruder_number&gt; X&lt;offset_on_X&gt; Y&lt;offset_on_Y&gt;</comment>
    <block>{
      <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>218</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <break>break;</break>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_HOTEND_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for(<init><expr><name>tmp_extruder</name> = 0</expr>;</init> <condition><expr><name>tmp_extruder</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr><name>tmp_extruder</name>++</expr></incr>)
      <block>{
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></for>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block><break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>220</expr>: <comment type="line">// M220 S&lt;factor in percent&gt;- set speed factor override percentage</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>feedmultiply</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr> ;</expr_stmt>
      }</block></then></if>
    }</block>
    <break>break;</break>
    </case><case>case <expr>221</expr>: <comment type="line">// M221 S&lt;factor in percent&gt;- set extrude factor override percentage</comment>
    <block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>tmp_code</name> <init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if<condition>(<expr><call><name>setTargetedHotend</name><argument_list>(<argument><expr>221</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
            <break>break;</break>
          }</block></then></if>
          <expr_stmt><expr><name><name>extruder_multiply</name><index>[<expr><name>tmp_extruder</name></expr>]</index></name> = <name>tmp_code</name></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <expr_stmt><expr><name>extrudemultiply</name> = <name>tmp_code</name></expr> ;</expr_stmt>
        }</block></else></if>
      }</block></then></if>
    }</block>
    <break>break;</break>

	</case><case>case <expr>226</expr>: <comment type="line">// M226 P&lt;pin number&gt; S&lt;pin state&gt;- Wait until the specified pin reaches the state required</comment>
	<block>{
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then><block>{
        <decl_stmt><decl><type><name>int</name></type> <name>pin_number</name> <init>= <expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// pin number</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>pin_state</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt> <comment type="line">// required pin state - default is inverted</comment>

        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>pin_state</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if> <comment type="line">// required pin state</comment>

        <if>if<condition>(<expr><name>pin_state</name> &gt;= -1 &amp;&amp; <name>pin_state</name> &lt;= 1</expr>)</condition><then><block>{

          <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <call>(<name>int8_t</name>)<argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sensitive_pins</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
          <block>{
            <if>if <condition>(<expr><name><name>sensitive_pins</name><index>[<expr><name>i</name></expr>]</index></name> == <name>pin_number</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>pin_number</name> = -1</expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
          }</block></for>

          <if>if <condition>(<expr><name>pin_number</name> &gt; -1</expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>target</name> <init>= <expr><name>LOW</name></expr></init></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>, <argument><expr><name>INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <switch>switch<condition>(<expr><name>pin_state</name></expr>)</condition><block>{
            <case>case <expr>1</expr>:
              <expr_stmt><expr><name>target</name> = <name>HIGH</name></expr>;</expr_stmt>
              <break>break;</break>

            </case><case>case <expr>0</expr>:
              <expr_stmt><expr><name>target</name> = <name>LOW</name></expr>;</expr_stmt>
              <break>break;</break>

            </case><case>case <expr>-1</expr>:
              <expr_stmt><expr><name>target</name> = !<call><name>digitalRead</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            </case>}</block></switch>

            <while>while<condition>(<expr><call><name>digitalRead</name><argument_list>(<argument><expr><name>pin_number</name></expr></argument>)</argument_list></call> != <name>target</name></expr>)</condition><block>{
              <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
            }</block></while>
          }</block></then></if>
        }</block></then></if>
      }</block></then></if>
    }</block>
    <break>break;</break>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>NUM_SERVOS</name> &gt; 0</expr></cpp:if>
    </case><case>case <expr>280</expr>: <comment type="line">// M280 - set servo position absolute. P: servo index, S: angle or microseconds</comment>
      <block>{
        <decl_stmt><decl><type><name>int</name></type> <name>servo_index</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>servo_position</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>servo_index</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>servo_position</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(<name>servo_index</name> &gt;= 0) &amp;&amp; (<name>servo_index</name> &lt; <name>NUM_SERVOS</name>)</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
		      <expr_stmt><expr><name><name>servos</name><index>[<expr><name>servo_index</name></expr>]</index></name>.<call><name>attach</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <expr_stmt><expr><name><name>servos</name><index>[<expr><name>servo_index</name></expr>]</index></name>.<call><name>write</name><argument_list>(<argument><expr><name>servo_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>PROBE_SERVO_DEACTIVATION_DELAY</name> &gt; 0)</expr></cpp:if>
              <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>PROBE_SERVO_DEACTIVATION_DELAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>servos</name><index>[<expr><name>servo_index</name></expr>]</index></name>.<call><name>detach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          }</block></then>
          <else>else <block>{
            <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"Servo "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>servo_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></else></if>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>servo_index</name> &gt;= 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" Servo "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>servo_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>": "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name><name>servos</name><index>[<expr><name>servo_index</name></expr>]</index></name>.<call><name>read</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// NUM_SERVOS &gt; 0</comment>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>LARGE_FLASH</name> == true &amp;&amp; ( <name>BEEPER</name> &gt; 0 || <call><name>defined</name><argument_list>(<argument><expr><name>ULTRALCD</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>LCD_USE_I2C_BUZZER</name></expr></argument>)</argument_list></call>))</expr></cpp:if>
    </case><case>case <expr>300</expr>: <comment type="line">// M300</comment>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>beepS</name> <init>= <expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call> : 110</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>beepP</name> <init>= <expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call> ? <call><name>code_value</name><argument_list>()</argument_list></call> : 1000</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>beepS</name> &gt; 0</expr>)</condition><then>
      <block>{
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BEEPER</name> &gt; 0</expr></cpp:if>
          <expr_stmt><expr><call><name>tone</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>, <argument><expr><name>beepS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>beepP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>noTone</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ULTRALCD</name></expr></argument>)</argument_list></call></expr></cpp:elif>
		  <expr_stmt><expr><call><name>lcd_buzz</name><argument_list>(<argument><expr><name>beepS</name></expr></argument>, <argument><expr><name>beepP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LCD_USE_I2C_BUZZER</name></expr></argument>)</argument_list></call></expr></cpp:elif>
		  <expr_stmt><expr><call><name>lcd_buzz</name><argument_list>(<argument><expr><name>beepP</name></expr></argument>, <argument><expr><name>beepS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr><name>beepP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// M300</comment>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
    </case><case>case <expr>301</expr>: <comment type="line">// M301</comment>
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Kp</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Ki</name> = <call><name>scalePID_i</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Kd</name> = <call><name>scalePID_d</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PID_ADD_EXTRUSION_RATE</name></cpp:ifdef>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>Kc</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><call><name>updatePID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" p:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>Kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" i:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_i</name><argument_list>(<argument><expr><name>Ki</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" d:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_d</name><argument_list>(<argument><expr><name>Kd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PID_ADD_EXTRUSION_RATE</name></cpp:ifdef>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" c:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//Kc does not have scaling applied above, or in resetting defaults</comment>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>Kc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
    </case><case>case <expr>304</expr>: <comment type="line">// M304</comment>
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bedKp</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bedKi</name> = <call><name>scalePID_i</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>bedKd</name> = <call><name>scalePID_d</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <expr_stmt><expr><call><name>updatePID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" p:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>bedKp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" i:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_i</name><argument_list>(<argument><expr><name>bedKi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr>" d:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><call><name>unscalePID_d</name><argument_list>(<argument><expr><name>bedKd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>
      <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>
    </case><case>case <expr>240</expr>: <comment type="line">// M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/</comment>
     <block>{
     	<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHDK</name></cpp:ifdef>
       
         <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>CHDK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>CHDK</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>chdkHigh</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
         <expr_stmt><expr><name>chdkActive</name> = true</expr>;</expr_stmt>
       
       <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
     	
      	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PHOTOGRAPH_PIN</name> &gt; -1</expr></cpp:if>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name></type> <name>NUM_PULSES</name><init>=<expr>16</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>float</name></type> <name>PULSE_LENGTH</name><init>=<expr>0.01524</expr></init></decl>;</decl_stmt>
	<for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_PULSES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>7.33</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_PULSES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>PHOTOGRAPH_PIN</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>_delay_ms</name><argument_list>(<argument><expr><name>PULSE_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//chdk end if</comment>
     }</block>
    <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DOGLCD</name></cpp:ifdef>
    </case><case>case <expr>250</expr>: <comment type="line">// M250  Set LCD contrast value: C&lt;value&gt; (value 0..63)</comment>
     <block>{
	  <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
	   <expr_stmt><expr><call><name>lcd_setcontrast</name><argument_list>( <argument><expr>((<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call>)&amp;63</expr></argument> )</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"lcd contrast value: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>lcd_contrast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
     }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PREVENT_DANGEROUS_EXTRUDE</name></cpp:ifdef>
    </case><case>case <expr>302</expr>: <comment type="line">// allow cold extrudes, or set the minimum extrude temperature</comment>
    <block>{
	  <decl_stmt><decl><type><name>float</name></type> <name>temp</name> <init>= <expr>.0</expr></init></decl>;</decl_stmt>
	  <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>temp</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>set_extrude_min_temp</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>303</expr>: <comment type="line">// M303 PID autotune</comment>
    <block>{
      <decl_stmt><decl><type><name>float</name></type> <name>temp</name> <init>= <expr>150.0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>e</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>c</name><init>=<expr>5</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>e</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if <condition>(<expr><name>e</name>&lt;0</expr>)</condition><then>
          <expr_stmt><expr><name>temp</name>=70</expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>temp</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'C'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>c</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>PID_autotune</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
	<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
	</case><case>case <expr>360</expr>:  <comment type="line">// M360 SCARA Theta pos1</comment>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" Cal: Theta 0 "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//SoftEndsEnabled = false;              // Ignore soft endstops during calibration</comment>
      <comment type="line">//SERIAL_ECHOLN(" Soft endstops disabled ");</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <comment type="line">//get_coordinates(); // For X Y Z E F</comment>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 120</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculate_SCARA_forward_Transform</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
        <return>return;</return>
      }</block></then></if>
    <break>break;</break>

    </case><case>case <expr>361</expr>:  <comment type="line">// SCARA Theta pos2</comment>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" Cal: Theta 90 "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//SoftEndsEnabled = false;              // Ignore soft endstops during calibration</comment>
      <comment type="line">//SERIAL_ECHOLN(" Soft endstops disabled ");</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <comment type="line">//get_coordinates(); // For X Y Z E F</comment>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 90</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 130</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculate_SCARA_forward_Transform</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
        <return>return;</return>
      }</block></then></if>
    <break>break;</break>
    </case><case>case <expr>362</expr>:  <comment type="line">// SCARA Psi pos1</comment>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" Cal: Psi 0 "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//SoftEndsEnabled = false;              // Ignore soft endstops during calibration</comment>
      <comment type="line">//SERIAL_ECHOLN(" Soft endstops disabled ");</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <comment type="line">//get_coordinates(); // For X Y Z E F</comment>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 60</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 180</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculate_SCARA_forward_Transform</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
        <return>return;</return>
      }</block></then></if>
    <break>break;</break>
    </case><case>case <expr>363</expr>:  <comment type="line">// SCARA Psi pos2</comment>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" Cal: Psi 90 "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="line">//SoftEndsEnabled = false;              // Ignore soft endstops during calibration</comment>
      <comment type="line">//SERIAL_ECHOLN(" Soft endstops disabled ");</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <comment type="line">//get_coordinates(); // For X Y Z E F</comment>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 50</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 90</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculate_SCARA_forward_Transform</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
        <return>return;</return>
      }</block></then></if>
    <break>break;</break>
    </case><case>case <expr>364</expr>:  <comment type="line">// SCARA Psi pos3 (90 deg to Theta)</comment>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>" Cal: Theta-Psi 90 "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <comment type="line">// SoftEndsEnabled = false;              // Ignore soft endstops during calibration</comment>
      <comment type="line">//SERIAL_ECHOLN(" Soft endstops disabled ");</comment>
      <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
        <comment type="line">//get_coordinates(); // For X Y Z E F</comment>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = 45</expr>;</expr_stmt>
        <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = 135</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>calculate_SCARA_forward_Transform</name><argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name><name>axis_scaling</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt> 
        
        <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//ClearToSend();</comment>
        <return>return;</return>
      }</block></then></if>
    <break>break;</break>
    </case><case>case <expr>365</expr>: <comment type="line">// M364  Set SCARA scaling for X Y Z</comment>
      <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) 
      <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> 
        <block>{
          
            <expr_stmt><expr><name><name>axis_scaling</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          
        }</block></then></if>
      }</block></for>
      <break>break;</break>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </case><case>case <expr>400</expr>: <comment type="line">// M400 finish all moves</comment>
    <block>{
      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_AUTO_BED_LEVELING</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>SERVO_ENDSTOPS</name></expr></argument>)</argument_list></call> &amp;&amp; not <call><name>defined</name><argument_list>(<argument><expr><name>Z_PROBE_SLED</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr>401</expr>:
    <block>{
        <expr_stmt><expr><call><name>engage_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// Engage Z Servo endstop if available</comment>
    }</block>
    <break>break;</break>

    </case><case>case <expr>402</expr>:
    <block>{
        <expr_stmt><expr><call><name>retract_z_probe</name><argument_list>()</argument_list></call></expr>;</expr_stmt>    <comment type="line">// Retract Z Servo endstop if enabled</comment>
    }</block>
    <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
</case><case>case <expr>404</expr>:  <comment type="line">//M404 Enter the nominal filament width (3mm, 1.75mm ) N&lt;3.0&gt; or display nominal filament width </comment>
    <block>{
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>FILWIDTH_PIN</name> &gt; -1)</expr></cpp:if> 
    <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'N'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>filament_width_nominal</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
    <else>else<block>{
    <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Filament dia (nominal mm):"</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>filament_width_nominal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    }</block></else></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break> 
    
    </case><case>case <expr>405</expr>:  <comment type="line">//M405 Turn on filament sensor for control </comment>
    <block>{
    
    
    <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'D'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>meas_delay_cm</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
       
       <if>if<condition>(<expr><name>meas_delay_cm</name>&gt; <name>MAX_MEASUREMENT_DELAY</name></expr>)</condition><then>
       	<expr_stmt><expr><name>meas_delay_cm</name> = <name>MAX_MEASUREMENT_DELAY</name></expr>;</expr_stmt></then></if>
    
       <if>if<condition>(<expr><name>delay_index2</name> == -1</expr>)</condition><then>  <comment type="line">//initialize the ring buffer if it has not been done since startup</comment>
    	   <block>{
    	   <decl_stmt><decl><type><name>int</name></type> <name>temp_ratio</name> <init>= <expr><call><name>widthFil_to_size_ratio</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 
       	    
       	    <for>for (<init><expr><name>delay_index1</name>=0</expr>;</init> <condition><expr><name>delay_index1</name>&lt;(<name>MAX_MEASUREMENT_DELAY</name>+1)</expr>;</condition> <incr><expr>++<name>delay_index1</name></expr></incr> )<block>{
       	              <expr_stmt><expr><name><name>measurement_delay</name><index>[<expr><name>delay_index1</name></expr>]</index></name>=<name>temp_ratio</name>-100</expr>;</expr_stmt>  <comment type="line">//subtract 100 to scale within a signed byte</comment>
       	        }</block></for>
       	    <expr_stmt><expr><name>delay_index1</name>=0</expr>;</expr_stmt>
       	    <expr_stmt><expr><name>delay_index2</name>=0</expr>;</expr_stmt>	
    	   }</block></then></if>
    
    <expr_stmt><expr><name>filament_sensor</name> = true</expr> ;</expr_stmt> 
    
    <comment type="line">//SERIAL_PROTOCOLPGM("Filament dia (measured mm):"); </comment>
    <comment type="line">//SERIAL_PROTOCOL(filament_width_meas); </comment>
    <comment type="line">//SERIAL_PROTOCOLPGM("Extrusion ratio(%):"); </comment>
    <comment type="line">//SERIAL_PROTOCOL(extrudemultiply); </comment>
    }</block> 
    <break>break;</break> 
    
    </case><case>case <expr>406</expr>:  <comment type="line">//M406 Turn off filament sensor for control </comment>
    <block>{      
    <expr_stmt><expr><name>filament_sensor</name> = false</expr> ;</expr_stmt> 
    }</block> 
    <break>break;</break> 
  
    </case><case>case <expr>407</expr>:   <comment type="line">//M407 Display measured filament diameter </comment>
    <block>{ 
     
    
    
    <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"Filament dia (measured mm):"</expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>filament_width_meas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
    }</block> 
    <break>break;</break> 
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    




    </case><case>case <expr>500</expr>: <comment type="line">// M500 Store settings in EEPROM</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_StoreSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>501</expr>: <comment type="line">// M501 Read settings from EEPROM</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_RetrieveSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>502</expr>: <comment type="line">// M502 Revert to default settings</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_ResetDefault</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    </case><case>case <expr>503</expr>: <comment type="line">// M503 print settings currently in memory</comment>
    <block>{
        <expr_stmt><expr><call><name>Config_PrintSettings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED</name></cpp:ifdef>
    </case><case>case <expr>540</expr>:
    <block>{
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>abort_on_endstop_hit</name> = <call><name>code_value</name><argument_list>()</argument_list></call> &gt; 0</expr>;</expr_stmt></then></if>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</name></cpp:ifdef>
    </case><case>case <expr><name>CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</name></expr>:
    <block>{
      <decl_stmt><decl><type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>value</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>Z_PROBE_OFFSET_RANGE_MIN</name> &lt;= <name>value</name>) &amp;&amp; (<name>value</name> &lt;= <name>Z_PROBE_OFFSET_RANGE_MAX</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>zprobe_zoffset</name> = -<name>value</name></expr>;</expr_stmt> <comment type="line">// compare w/ line 278 of ConfigurationStore.cpp</comment>
          <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_ZPROBE_ZOFFSET</name> " " <name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_ZPROBE_ZOFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_Z_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>Z_PROBE_OFFSET_RANGE_MIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_Z_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>Z_PROBE_OFFSET_RANGE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      }</block></then>
      <else>else
      <block>{
          <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr><name>MSG_ZPROBE_ZOFFSET</name> " : "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>-<name>zprobe_zoffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
      <break>break;</break>
    }</block>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// CUSTOM_M_CODE_SET_Z_PROBE_OFFSET</comment>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGEENABLE</name></cpp:ifdef>
    </case><case>case <expr>600</expr>: <comment type="line">//Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]</comment>
    <block>{
        <decl_stmt><decl><type><name>float</name></type> <name><name>target</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>float</name></type> <name><name>lastpos</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>lastpos</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        <comment type="line">//retract by E</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_FIRSTRETRACT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <name>FILAMENTCHANGE_FIRSTRETRACT</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//lift Z</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_ZADD</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+= <name>FILAMENTCHANGE_ZADD</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//move xy</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_XPOS</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>= <name>FILAMENTCHANGE_XPOS</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Y'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_YPOS</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>= <name>FILAMENTCHANGE_YPOS</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>

        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_FINALRETRACT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= <name>FILAMENTCHANGE_FINALRETRACT</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>

        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="line">//finish moves</comment>
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <comment type="line">//disable extruder steppers so filament can be removed</comment>
        <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_FILAMENTCHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>cnt</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
        <while>while<condition>(<expr>!<call><name>lcd_clicked</name><argument_list>()</argument_list></call></expr>)</condition><block>{
          <expr_stmt><expr><name>cnt</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_inactivity</name><argument_list>(<argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <if>if<condition>(<expr><name>cnt</name>==0</expr>)</condition><then>
          <block>{
          <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BEEPER</name> &gt; 0</expr></cpp:if>
            <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>,<argument><expr><name>HIGH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>BEEPER</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>LCD_FEEDBACK_FREQUENCY_HZ</name></expr></argument>)</argument_list></call> || !<call><name>defined</name><argument_list>(<argument><expr><name>LCD_FEEDBACK_FREQUENCY_DURATION_MS</name></expr></argument>)</argument_list></call></expr></cpp:if>
              <expr_stmt><expr><call><name>lcd_buzz</name><argument_list>(<argument><expr>1000/6</expr></argument>,<argument><expr>100</expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			  <expr_stmt><expr><call><name>lcd_buzz</name><argument_list>(<argument><expr><name>LCD_FEEDBACK_FREQUENCY_DURATION_MS</name></expr></argument>,<argument><expr><name>LCD_FEEDBACK_FREQUENCY_HZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          }</block></then></if>
        }</block></while>

        <comment type="line">//return to normal</comment>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'L'</expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+= -<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENTCHANGE_FINALRETRACT</name></cpp:ifdef>
            <expr_stmt><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+=(-1)*<name>FILAMENTCHANGE_FINALRETRACT</name></expr> ;</expr_stmt>
          <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        }</block></else></if>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>;</expr_stmt> <comment type="line">//the long retract of L is compensated by manual filament feeding</comment>
        <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//should do nothing</comment>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//move xy back</comment>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//move z back</comment>
        <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>lastpos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>lastpos</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">//final untretract</comment>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FILAMENTCHANGEENABLE</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
    </case><case>case <expr>605</expr>: <comment type="line">// Set dual x-carriage movement mode:</comment>
              <comment type="line">//    M605 S0: Full control mode. The slicer has full control over x-carriage movement</comment>
              <comment type="line">//    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement</comment>
              <comment type="line">//    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn</comment>
              <comment type="line">//                         millimeters x-offset and an optional differential hotend temperature of</comment>
              <comment type="line">//                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate</comment>
              <comment type="line">//                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.</comment>
              <comment type="line">//</comment>
              <comment type="line">//    Note: the X axis should be homed after changing dual x-carriage mode.</comment>
    <block>{
        <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><name>dual_x_carriage_mode</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>duplicate_extruder_x_offset</name> = <call><name>max</name><argument_list>(<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr><name>X2_MIN_POS</name> - <call><name>x_home_pos</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <if>if <condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'R'</expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>duplicate_extruder_temp_offset</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_HOTEND_OFFSET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>X_AXIS</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>duplicate_extruder_x_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> != <name>DXC_FULL_CONTROL_MODE</name> &amp;&amp; <name>dual_x_carriage_mode</name> != <name>DXC_AUTO_PARK_MODE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>dual_x_carriage_mode</name> = <name>DEFAULT_DUAL_X_CARRIAGE_MODE</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

        <expr_stmt><expr><name>active_extruder_parked</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
        <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
    }</block>
    <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//DUAL_X_CARRIAGE</comment>

    </case><case>case <expr>907</expr>: <comment type="line">// M907 Set digital trimpot motor current using axis codes.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIGIPOTSS_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>DIGIPOTSS_PIN</name> &gt; -1</expr></cpp:if>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;=4</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOTOR_CURRENT_PWM_XY_PIN</name></cpp:ifdef>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'X'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOTOR_CURRENT_PWM_Z_PIN</name></cpp:ifdef>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'Z'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>MOTOR_CURRENT_PWM_E_PIN</name></cpp:ifdef>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'E'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_current</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIGIPOT_I2C</name></cpp:ifdef>
        <comment type="line">// this one uses actual amps in floating point</comment>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_i2c_set_current</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
        <comment type="line">// for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)</comment>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr><name>NUM_AXIS</name></expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>DIGIPOT_I2C_NUM_CHANNELS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'+<name>i</name>-<name>NUM_AXIS</name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>digipot_i2c_set_current</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>908</expr>: <comment type="line">// M908 Control digital trimpot directly.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DIGIPOTSS_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>DIGIPOTSS_PIN</name> &gt; -1</expr></cpp:if>
        <decl_stmt><decl><type><name>uint8_t</name></type> <name>channel</name></decl>,<decl><type ref="prev"/><name>current</name></decl>;</decl_stmt>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'P'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>channel</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><name>current</name>=<call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>digitalPotWrite</name><argument_list>(<argument><expr><name>channel</name></expr></argument>, <argument><expr><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>350</expr>: <comment type="line">// M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MS1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MS1_PIN</name> &gt; -1</expr></cpp:if>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;=4</expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <expr_stmt><expr><call><name>microstep_mode</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for></then></if>
        <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_mode</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr>(<name>uint8_t</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
        <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_mode</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        <expr_stmt><expr><call><name>microstep_readings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>351</expr>: <comment type="line">// M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.</comment>
    <block>{
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X_MS1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X_MS1_PIN</name> &gt; -1</expr></cpp:if>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'S'</expr></argument>)</argument_list></call></expr>)</condition><then> <switch>switch<condition>(<expr>(<name>int</name>)<call><name>code_value</name><argument_list>()</argument_list></call></expr>)</condition>
      <block>{
        <case>case <expr>1</expr>:
          <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>,<argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </case><case>case <expr>2</expr>:
          <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>NUM_AXIS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>) <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr><name>i</name></expr></argument>,<argument><expr>-1</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
          <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'B'</expr></argument>)</argument_list></call></expr>)</condition><then> <expr_stmt><expr><call><name>microstep_ms</name><argument_list>(<argument><expr>4</expr></argument>,<argument><expr>-1</expr></argument>,<argument><expr><call><name>code_value</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <break>break;</break>
      </case>}</block></switch></then></if>
      <expr_stmt><expr><call><name>microstep_readings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block>
    <break>break;</break>
    </case><case>case <expr>999</expr>: <comment type="line">// M999: Restart after being stopped</comment>
      <expr_stmt><expr><name>Stopped</name> = false</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>lcd_reset_alert_level</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>gcode_LastN</name> = <name>Stopped_gcode_LastN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>FlushSerialRequestResend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
    </case>}</block>
  </case>}</block></switch>

  <else>else <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>tmp_extruder</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>tmp_extruder</name> &gt;= <name>EXTRUDERS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>"T"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>MSG_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <decl_stmt><decl><type><name>boolean</name></type> <name>make_move</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
      <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
        <expr_stmt><expr><name>make_move</name> = true</expr>;</expr_stmt>
        <expr_stmt><expr><name>next_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><name>next_feedrate</name> &gt; 0.0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>feedrate</name> = <name>next_feedrate</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
      <if>if<condition>(<expr><name>tmp_extruder</name> != <name>active_extruder</name></expr>)</condition><then> <block>{
        <comment type="line">// Save current position to return to after applying extruder offset</comment>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_AUTO_PARK_MODE</name> &amp;&amp; <name>Stopped</name> == false &amp;&amp;
            (<name>delayed_move_time</name> != 0 || <name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> != <call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <comment type="line">// Park old head: 1) raise 2) move to park position 3) lower</comment>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>TOOLCHANGE_PARK_ZLIFT</name></expr></argument>,
                <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> + <name>TOOLCHANGE_PARK_ZLIFT</name></expr></argument>,
                <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><call><name>x_home_pos</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
                <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

        <comment type="line">// apply Y &amp; Z extruder offset (x offset is already used in determining home pos)</comment>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> -
                     <name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>active_extruder</name></expr>]</index></name> +
                     <name><name>extruder_offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> -
                     <name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>active_extruder</name></expr>]</index></name> +
                     <name><name>extruder_offset</name><index>[<expr><name>Z_AXIS</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr>;</expr_stmt>

        <expr_stmt><expr><name>active_extruder</name> = <name>tmp_extruder</name></expr>;</expr_stmt>

        <comment type="line">// This function resets the max/min values - the current position may be overwritten below.</comment>
        <expr_stmt><expr><call><name>axis_is_at_home</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_FULL_CONTROL_MODE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>inactive_extruder_x_pos</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>inactive_extruder_x_pos</name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>active_extruder_parked</name> = (<name>active_extruder</name> == 0)</expr>;</expr_stmt> <comment type="line">// this triggers the second extruder to move into the duplication position</comment>
          <if>if <condition>(<expr><name>active_extruder</name> == 0 || <name>active_extruder_parked</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>inactive_extruder_x_pos</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name>duplicate_extruder_x_offset</name></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><name>inactive_extruder_x_pos</name> = <name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>extruder_duplication_enabled</name> = false</expr>;</expr_stmt>
        }</block></then>
        <else>else
        <block>{
          <comment type="line">// record raised toolhead position for use by unpark</comment>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>, <argument><expr><name>current_position</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>raised_parked_position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> += <name>TOOLCHANGE_UNPARK_ZLIFT</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>active_extruder_parked</name> = true</expr>;</expr_stmt>
          <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
        }</block></else></if></else></if>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <comment type="line">// Offset extruder (only by XY)</comment>
        <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <for>for(<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 2</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
           <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> -
                                 <name><name>extruder_offset</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>active_extruder</name></expr>]</index></name> +
                                 <name><name>extruder_offset</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>tmp_extruder</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
        <comment type="line">// Set the new active extruder and position</comment>
        <expr_stmt><expr><name>active_extruder</name> = <name>tmp_extruder</name></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//else DUAL_X_CARRIAGE</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef> 

  <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// change cartesian kinematic  to  delta kinematic;</comment>
   <comment type="line">//sent position to plan_set_position();</comment>
  <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <comment type="line">// Move to the old position if 'F' was in the parameters</comment>
        <if>if<condition>(<expr><name>make_move</name> &amp;&amp; <name>Stopped</name> == false</expr>)</condition><then> <block>{
           <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_ACTIVE_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr>(<name>int</name>)<name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then>

  <else>else
  <block>{
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOPGM</name><argument_list>(<argument><expr><name>MSG_UNKNOWN_COMMAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>cmdbuffer</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLNPGM</name><argument_list>(<argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if></else>

  <expr_stmt><expr><call><name>ClearToSend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>

<function><type><name>void</name></type> <name>FlushSerialRequestResend</name><parameter_list>()</parameter_list>
<block>{
  <comment type="line">//char cmdbuffer[bufindr][100]="Resend:";</comment>
  <expr_stmt><expr><call><name><name>MYSERIAL</name>.<name>flush</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr><name>MSG_RESEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>gcode_LastN</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>ClearToSend</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>ClearToSend</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SDSUPPORT</name></cpp:ifdef>
  <if>if<condition>(<expr><name><name>fromsd</name><index>[<expr><name>bufindr</name></expr>]</index></name></expr>)</condition><then>
    <return>return;</return></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//SDSUPPORT</comment>
  <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr><name>MSG_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>get_coordinates</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>bool</name></type> <name><name>seen</name><index>[<expr>4</expr>]</index></name><init>=<expr><block>{<expr>false</expr>,<expr>false</expr>,<expr>false</expr>,<expr>false</expr>}</block></expr></init></decl>;</decl_stmt>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr><name><name>axis_codes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>float</name>)<call><name>code_value</name><argument_list>()</argument_list></call> + (<name><name>axis_relative_modes</name><index>[<expr><name>i</name></expr>]</index></name> || <name>relative_mode</name>)*<name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>seen</name><index>[<expr><name>i</name></expr>]</index></name>=true</expr>;</expr_stmt>
    }</block></then>
    <else>else <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></else></if> <comment type="line">//Are these else lines really needed?</comment>
  }</block></for>
  <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'F'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>next_feedrate</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>next_feedrate</name> &gt; 0.0</expr>)</condition><then> <expr_stmt><expr><name>feedrate</name> = <name>next_feedrate</name></expr>;</expr_stmt></then></if>
  }</block></then></if>
}</block></function>

<function><type><name>void</name></type> <name>get_arc_coordinates</name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SF_ARC_FIX</name></cpp:ifdef>
   <decl_stmt><decl><type><name>bool</name></type> <name>relative_mode_backup</name> <init>= <expr><name>relative_mode</name></expr></init></decl>;</decl_stmt>
   <expr_stmt><expr><name>relative_mode</name> = true</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   <expr_stmt><expr><call><name>get_coordinates</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SF_ARC_FIX</name></cpp:ifdef>
   <expr_stmt><expr><name>relative_mode</name>=<name>relative_mode_backup</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

   <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'I'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>0</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   }</block></then>
   <else>else <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>0</expr>]</index></name> = 0.0</expr>;</expr_stmt>
   }</block></else></if>
   <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'J'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>1</expr>]</index></name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
   }</block></then>
   <else>else <block>{
     <expr_stmt><expr><name><name>offset</name><index>[<expr>1</expr>]</index></name> = 0.0</expr>;</expr_stmt>
   }</block></else></if>
}</block></function>

<function><type><name>void</name></type> <name>clamp_to_software_endstops</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>target</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>min_software_endstops</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> &lt; <name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>min_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> &lt; <name><name>min_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>min_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    
    <decl_stmt><decl><type><name>float</name></type> <name>negative_z_offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
      <if>if <condition>(<expr><name>Z_PROBE_OFFSET_FROM_EXTRUDER</name> &lt; 0</expr>)</condition><then> <expr_stmt><expr><name>negative_z_offset</name> = <name>negative_z_offset</name> + <name>Z_PROBE_OFFSET_FROM_EXTRUDER</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name><name>add_homing</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &lt; 0</expr>)</condition><then> <expr_stmt><expr><name>negative_z_offset</name> = <name>negative_z_offset</name> + <name><name>add_homing</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &lt; <name><name>min_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+<name>negative_z_offset</name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>min_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name>+<name>negative_z_offset</name></expr>;</expr_stmt></then></if>
  }</block></then></if>

  <if>if <condition>(<expr><name>max_software_endstops</name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> &gt; <name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> &gt; <name><name>max_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
    <if>if <condition>(<expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &gt; <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>)</condition><then> <expr_stmt><expr><name><name>target</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>max_pos</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
  }</block></then></if>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
<function><type><name>void</name></type> <name>recalc_delta_settings</name><parameter_list>(<param><decl><type><name>float</name></type> <name>radius</name></decl></param>, <param><decl><type><name>float</name></type> <name>diagonal_rod</name></decl></param>)</parameter_list>
<block>{
	 <expr_stmt><expr><name>delta_tower1_x</name>= -<name>SIN_60</name>*<name>radius</name></expr>;</expr_stmt> <comment type="line">// front left tower</comment>
	 <expr_stmt><expr><name>delta_tower1_y</name>= -<name>COS_60</name>*<name>radius</name></expr>;</expr_stmt>	   
	 <expr_stmt><expr><name>delta_tower2_x</name>=  <name>SIN_60</name>*<name>radius</name></expr>;</expr_stmt> <comment type="line">// front right tower</comment>
	 <expr_stmt><expr><name>delta_tower2_y</name>= -<name>COS_60</name>*<name>radius</name></expr>;</expr_stmt>	   
	 <expr_stmt><expr><name>delta_tower3_x</name>= 0.0</expr>;</expr_stmt>                  <comment type="line">// back middle tower</comment>
	 <expr_stmt><expr><name>delta_tower3_y</name>= <name>radius</name></expr>;</expr_stmt>
	 <expr_stmt><expr><name>delta_diagonal_rod_2</name>= <call><name>sq</name><argument_list>(<argument><expr><name>diagonal_rod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>calculate_delta</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>cartesian</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <call><name>sqrt</name><argument_list>(<argument><expr><name>delta_diagonal_rod_2</name>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower1_x</name>-<name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower1_y</name>-<name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                       )</argument_list></call> + <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <call><name>sqrt</name><argument_list>(<argument><expr><name>delta_diagonal_rod_2</name>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower2_x</name>-<name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower2_y</name>-<name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                       )</argument_list></call> + <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <call><name>sqrt</name><argument_list>(<argument><expr><name>delta_diagonal_rod_2</name>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower3_x</name>-<name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>
                       - <call><name>sq</name><argument_list>(<argument><expr><name>delta_tower3_y</name>-<name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>
                       )</argument_list></call> + <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  <comment type="block">/*
  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);

  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
  */</comment>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>prepare_move</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>clamp_to_software_endstops</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef> <comment type="line">//for now same as delta-code</comment>

<decl_stmt><decl><type><name>float</name></type> <name><name>difference</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name></decl>;</decl_stmt>
<for>for (<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
	<expr_stmt><expr><name><name>difference</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>

<decl_stmt><decl><type><name>float</name></type> <name>cartesian_mm</name> <init>= <expr><call><name>sqrt</name><argument_list>(	<argument><expr><call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> +
							<call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> +
							<call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cartesian_mm</name> &lt; 0.000001</expr>)</condition><then> <block>{ <expr_stmt><expr><name>cartesian_mm</name> = <call><name>abs</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
<if>if <condition>(<expr><name>cartesian_mm</name> &lt; 0.000001</expr>)</condition><then> <block>{ <return>return;</return> }</block></then></if>
<decl_stmt><decl><type><name>float</name></type> <name>seconds</name> <init>= <expr>6000 * <name>cartesian_mm</name> / <name>feedrate</name> / <name>feedmultiply</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>steps</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>scara_segments_per_second</name> * <name>seconds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
 <comment type="line">//SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);</comment>
 <comment type="line">//SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);</comment>
 <comment type="line">//SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);</comment>
<for>for (<init><decl><type><name>int</name></type> <name>s</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>s</name> &lt;= <name>steps</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
	<decl_stmt><decl><type><name>float</name></type> <name>fraction</name> <init>= <expr><call><name>float</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> / <call><name>float</name><argument_list>(<argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
		<expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>difference</name><index>[<expr><name>i</name></expr>]</index></name> * <name>fraction</name></expr>;</expr_stmt>
	}</block></for>

	
	<expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
         <comment type="line">//SERIAL_ECHOPGM("destination[X_AXIS]="); SERIAL_ECHOLN(destination[X_AXIS]);</comment>
         <comment type="line">//SERIAL_ECHOPGM("destination[Y_AXIS]="); SERIAL_ECHOLN(destination[Y_AXIS]);</comment>
         <comment type="line">//SERIAL_ECHOPGM("destination[Z_AXIS]="); SERIAL_ECHOLN(destination[Z_AXIS]);</comment>
         <comment type="line">//SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);</comment>
         <comment type="line">//SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);</comment>
         <comment type="line">//SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);</comment>
         
	<expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
	<argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>,
	<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// SCARA</comment>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DELTA</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name><name>difference</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name></decl>;</decl_stmt>
  <for>for (<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>difference</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <decl_stmt><decl><type><name>float</name></type> <name>cartesian_mm</name> <init>= <expr><call><name>sqrt</name><argument_list>(<argument><expr><call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> +
                            <call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> +
                            <call><name>sq</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>cartesian_mm</name> &lt; 0.000001</expr>)</condition><then> <block>{ <expr_stmt><expr><name>cartesian_mm</name> = <call><name>abs</name><argument_list>(<argument><expr><name><name>difference</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> }</block></then></if>
  <if>if <condition>(<expr><name>cartesian_mm</name> &lt; 0.000001</expr>)</condition><then> <block>{ <return>return;</return> }</block></then></if>
  <decl_stmt><decl><type><name>float</name></type> <name>seconds</name> <init>= <expr>6000 * <name>cartesian_mm</name> / <name>feedrate</name> / <name>feedmultiply</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>steps</name> <init>= <expr><call><name>max</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><call><name>int</name><argument_list>(<argument><expr><name>delta_segments_per_second</name> * <name>seconds</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">// SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);</comment>
  <comment type="line">// SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);</comment>
  <comment type="line">// SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);</comment>
  <for>for (<init><decl><type><name>int</name></type> <name>s</name> <init>= <expr>1</expr></init></decl>;</init> <condition><expr><name>s</name> &lt;= <name>steps</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
    <decl_stmt><decl><type><name>float</name></type> <name>fraction</name> <init>= <expr><call><name>float</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> / <call><name>float</name><argument_list>(<argument><expr><name>steps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
      <expr_stmt><expr><name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>difference</name><index>[<expr><name>i</name></expr>]</index></name> * <name>fraction</name></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><call><name>calculate_delta</name><argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
                     <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>,
                     <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></for>
  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// DELTA</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DUAL_X_CARRIAGE</name></cpp:ifdef>
  <if>if <condition>(<expr><name>active_extruder_parked</name></expr>)</condition><then>
  <block>{
    <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_DUPLICATION_MODE</name> &amp;&amp; <name>active_extruder</name> == 0</expr>)</condition><then>
    <block>{
      <comment type="line">// move duplicate extruder into correct duplication position.</comment>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name>inactive_extruder_x_pos</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> + <name>duplicate_extruder_x_offset</name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
          <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_set_position</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>extruder_duplication_enabled</name> = true</expr>;</expr_stmt>
      <expr_stmt><expr><name>active_extruder_parked</name> = false</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>dual_x_carriage_mode</name> == <name>DXC_AUTO_PARK_MODE</name></expr>)</condition><then> <comment type="line">// handle unparking of head</comment>
    <block>{
      <if>if <condition>(<expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name> == <name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr>)</condition><then>
      <block>{
        <comment type="line">// this is a travel move - skit it but keep track of current position (so that it can later</comment>
        <comment type="line">// be used as start of first non-travel move)</comment>
        <if>if <condition>(<expr><name>delayed_move_time</name> != 0xFFFFFFFFUL</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>current_position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> &gt; <name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>delayed_move_time</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        }</block></then></if>
      }</block></then></if>
      <expr_stmt><expr><name>delayed_move_time</name> = 0</expr>;</expr_stmt>
      <comment type="line">// unpark extruder: 1) raise, 2) move into starting XY position, 3) lower</comment>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>raised_parked_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>raised_parked_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,    <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>raised_parked_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
          <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>min</name><argument_list>(<argument><expr><name><name>max_feedrate</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>max_feedrate</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_position</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
          <argument><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>max_feedrate</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>active_extruder_parked</name> = false</expr>;</expr_stmt>
    }</block></then></if></else></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//DUAL_X_CARRIAGE</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>! (<name>defined</name> <name>DELTA</name> || <name>defined</name> <name>SCARA</name>)</expr></cpp:if>
  <comment type="line">// Do not use feedmultiply for E or Z only moves</comment>
  <if>if<condition>( <expr>(<name><name>current_position</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> == <name><name>destination</name> <index>[<expr><name>X_AXIS</name></expr>]</index></name>) &amp;&amp; (<name><name>current_position</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> == <name><name>destination</name> <index>[<expr><name>Y_AXIS</name></expr>]</index></name>)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>/60</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then>
  <else>else <block>{
    <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// !(DELTA || SCARA)</comment>

  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name></type> <name>prepare_arc_move</name><parameter_list>(<param><decl><type><name>char</name></type> <name>isclockwise</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>float</name></type> <name>r</name> <init>= <expr><call><name>hypot</name><argument_list>(<argument><expr><name><name>offset</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>offset</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// Compute arc radius for mc_arc</comment>

  <comment type="line">// Trace the arc</comment>
  <expr_stmt><expr><call><name>mc_arc</name><argument_list>(<argument><expr><name>current_position</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>X_AXIS</name></expr></argument>, <argument><expr><name>Y_AXIS</name></expr></argument>, <argument><expr><name>Z_AXIS</name></expr></argument>, <argument><expr><name>feedrate</name>*<name>feedmultiply</name>/60/100.0</expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>isclockwise</name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// As far as the parser is concerned, the position is now == target. In reality the</comment>
  <comment type="line">// motion control system might still be processing the action and the real tool position</comment>
  <comment type="line">// in any intermediate location.</comment>
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
    <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>destination</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
  }</block></for>
  <expr_stmt><expr><name>previous_millis_cmd</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CONTROLLERFAN_PIN</name> &gt; -1</expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>CONTROLLERFAN_PIN</name> == <name>FAN_PIN</name></expr></cpp:if>
    <cpp:error>#<cpp:directive>error</cpp:directive> "You cannot set CONTROLLERFAN_PIN equal to FAN_PIN"</cpp:error>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lastMotor</name> <init>= <expr>0</expr></init></decl>;</decl_stmt> <comment type="line">//Save the time for when a motor was turned on last</comment>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>lastMotorCheck</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>controllerFan</name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>lastMotorCheck</name>) &gt;= 2500</expr>)</condition><then> <comment type="line">//Not a time critical function, so we only check every 2500ms</comment>
  <block>{
    <expr_stmt><expr><name>lastMotorCheck</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if>if<condition>(<expr>!<call><name>READ</name><argument_list>(<argument><expr><name>X_ENABLE_PIN</name></expr></argument>)</argument_list></call> || !<call><name>READ</name><argument_list>(<argument><expr><name>Y_ENABLE_PIN</name></expr></argument>)</argument_list></call> || !<call><name>READ</name><argument_list>(<argument><expr><name>Z_ENABLE_PIN</name></expr></argument>)</argument_list></call> || (<name>soft_pwm_bed</name> &gt; 0)
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>E2_ENABLE_PIN</name></expr></argument>)</argument_list></call>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDER</name> &gt; 1</expr></cpp:if>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>X2_ENABLE_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>X2_ENABLE_PIN</name> &gt; -1</expr></cpp:if>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>X2_ENABLE_PIN</name></expr></argument>)</argument_list></call>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>E1_ENABLE_PIN</name></expr></argument>)</argument_list></call>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       || !<call><name>READ</name><argument_list>(<argument><expr><name>E0_ENABLE_PIN</name></expr></argument>)</argument_list></call></expr>)</condition><then> <comment type="line">//If any of the drivers are enabled...</comment>
    <block>{
      <expr_stmt><expr><name>lastMotor</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">//... set time to NOW so the fan will turn on</comment>
    }</block></then></if>

    <if>if <condition>(<expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>lastMotor</name>) &gt;= (<name>CONTROLLERFAN_SECS</name>*1000UL) || <name>lastMotor</name> == 0</expr>)</condition><then> <comment type="line">//If the last time any driver was enabled, is longer since than CONTROLLERSEC...</comment>
    <block>{
        <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
    <else>else
    <block>{
        <comment type="line">// allows digital or PWM fan output to be used (see M42 handling)</comment>
        <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr><name>CONTROLLERFAN_SPEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>, <argument><expr><name>CONTROLLERFAN_SPEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SCARA</name></cpp:ifdef>
<function><type><name>void</name></type> <name>calculate_SCARA_forward_Transform</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>f_scara</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list>
<block>{
  <comment type="line">// Perform forward kinematics, and place results in delta[3]</comment>
  <comment type="line">// The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014</comment>
  
  <decl_stmt><decl><type><name>float</name></type> <name>x_sin</name></decl>, <decl><type ref="prev"/><name>x_cos</name></decl>, <decl><type ref="prev"/><name>y_sin</name></decl>, <decl><type ref="prev"/><name>y_cos</name></decl>;</decl_stmt>
  
    <comment type="line">//SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);</comment>
    <comment type="line">//SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);</comment>
  
    <expr_stmt><expr><name>x_sin</name> = <call><name>sin</name><argument_list>(<argument><expr><name><name>f_scara</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name>SCARA_RAD2DEG</name></expr></argument>)</argument_list></call> * <name>Linkage_1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>x_cos</name> = <call><name>cos</name><argument_list>(<argument><expr><name><name>f_scara</name><index>[<expr><name>X_AXIS</name></expr>]</index></name>/<name>SCARA_RAD2DEG</name></expr></argument>)</argument_list></call> * <name>Linkage_1</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y_sin</name> = <call><name>sin</name><argument_list>(<argument><expr><name><name>f_scara</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name>SCARA_RAD2DEG</name></expr></argument>)</argument_list></call> * <name>Linkage_2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>y_cos</name> = <call><name>cos</name><argument_list>(<argument><expr><name><name>f_scara</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name>/<name>SCARA_RAD2DEG</name></expr></argument>)</argument_list></call> * <name>Linkage_2</name></expr>;</expr_stmt>
   
  <comment type="line">//  SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);</comment>
  <comment type="line">//  SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);</comment>
  <comment type="line">//  SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);</comment>
  <comment type="line">//  SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);</comment>
  
    <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>x_cos</name> + <name>y_cos</name> + <name>SCARA_offset_x</name></expr>;</expr_stmt>  <comment type="line">//theta</comment>
    <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name>x_sin</name> + <name>y_sin</name> + <name>SCARA_offset_y</name></expr>;</expr_stmt>  <comment type="line">//theta+phi</comment>
	
    <comment type="line">//SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);</comment>
    <comment type="line">//SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);</comment>
}</block></function>  

<function><type><name>void</name></type> <name>calculate_delta</name><parameter_list>(<param><decl><type><name>float</name></type> <name><name>cartesian</name><index>[<expr>3</expr>]</index></name></decl></param>)</parameter_list><block>{
  <comment type="line">//reverse kinematics.</comment>
  <comment type="line">// Perform reversed kinematics, and place results in delta[3]</comment>
  <comment type="line">// The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014</comment>
  
  <decl_stmt><decl><type><name>float</name></type> <name><name>SCARA_pos</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>SCARA_C2</name></decl>, <decl><type ref="prev"/><name>SCARA_S2</name></decl>, <decl><type ref="prev"/><name>SCARA_K1</name></decl>, <decl><type ref="prev"/><name>SCARA_K2</name></decl>, <decl><type ref="prev"/><name>SCARA_theta</name></decl>, <decl><type ref="prev"/><name>SCARA_psi</name></decl>;</decl_stmt> 
  
  <expr_stmt><expr><name><name>SCARA_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name><name>cartesian</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> * <name><name>axis_scaling</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> - <name>SCARA_offset_x</name></expr>;</expr_stmt>  <comment type="line">//Translate SCARA to standard X Y</comment>
  <expr_stmt><expr><name><name>SCARA_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = <name><name>cartesian</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> * <name><name>axis_scaling</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> - <name>SCARA_offset_y</name></expr>;</expr_stmt>  <comment type="line">// With scaling factor.</comment>
  
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>Linkage_1</name> == <name>Linkage_2</name>)</expr></cpp:if>
    <expr_stmt><expr><name>SCARA_C2</name> = ( ( <call><name>sq</name><argument_list>(<argument><expr><name><name>SCARA_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> + <call><name>sq</name><argument_list>(<argument><expr><name><name>SCARA_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> ) / (2 * (<name>float</name>)<name>L1_2</name>) ) - 1</expr>;</expr_stmt>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>SCARA_C2</name> =   ( <call><name>sq</name><argument_list>(<argument><expr><name><name>SCARA_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> + <call><name>sq</name><argument_list>(<argument><expr><name><name>SCARA_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call> - (<name>float</name>)<name>L1_2</name> - (<name>float</name>)<name>L2_2</name> ) / 45000</expr>;</expr_stmt> 
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>SCARA_S2</name> = <call><name>sqrt</name><argument_list>( <argument><expr>1 - <call><name>sq</name><argument_list>(<argument><expr><name>SCARA_C2</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>SCARA_K1</name> = <name>Linkage_1</name> + <name>Linkage_2</name> * <name>SCARA_C2</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>SCARA_K2</name> = <name>Linkage_2</name> * <name>SCARA_S2</name></expr>;</expr_stmt>
  
  <expr_stmt><expr><name>SCARA_theta</name> = ( <call><name>atan2</name><argument_list>(<argument><expr><name><name>SCARA_pos</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>SCARA_pos</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call>-<call><name>atan2</name><argument_list>(<argument><expr><name>SCARA_K1</name></expr></argument>, <argument><expr><name>SCARA_K2</name></expr></argument>)</argument_list></call> ) * -1</expr>;</expr_stmt>
  <expr_stmt><expr><name>SCARA_psi</name>   =   <call><name>atan2</name><argument_list>(<argument><expr><name>SCARA_S2</name></expr></argument>,<argument><expr><name>SCARA_C2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>X_AXIS</name></expr>]</index></name> = <name>SCARA_theta</name> * <name>SCARA_RAD2DEG</name></expr>;</expr_stmt>  <comment type="line">// Multiply by 180/Pi  -  theta is support arm angle</comment>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name> = (<name>SCARA_theta</name> + <name>SCARA_psi</name>) * <name>SCARA_RAD2DEG</name></expr>;</expr_stmt>  <comment type="line">//       -  equal to sub arm angle (inverted motor)</comment>
  <expr_stmt><expr><name><name>delta</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name> = <name><name>cartesian</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr>;</expr_stmt>
  
  <comment type="block">/*
  SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);
  
  SERIAL_ECHOPGM("scara x="); SERIAL_ECHO(SCARA_pos[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHOLN(SCARA_pos[Y_AXIS]);
  
  SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
  SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
  SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
  
  SERIAL_ECHOPGM("C2="); SERIAL_ECHO(SCARA_C2);
  SERIAL_ECHOPGM(" S2="); SERIAL_ECHO(SCARA_S2);
  SERIAL_ECHOPGM(" Theta="); SERIAL_ECHO(SCARA_theta);
  SERIAL_ECHOPGM(" Psi="); SERIAL_ECHOLN(SCARA_psi);
  SERIAL_ECHOLN(" ");*/</comment>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_STAT_LEDS</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>blue_led</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>red_led</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32_t</name></type> <name>stat_update</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type> <name>handle_status_leds</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>float</name></type> <name>max_temp</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> &gt; <name>stat_update</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>stat_update</name> += 500</expr>;</expr_stmt> <comment type="line">// Update every 0.5s</comment>
    <for>for (<init><decl><type><name>int8_t</name></type> <name>cur_extruder</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>cur_extruder</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr>++<name>cur_extruder</name></expr></incr>) <block>{
       <expr_stmt><expr><name>max_temp</name> = <call><name>max</name><argument_list>(<argument><expr><name>max_temp</name></expr></argument>, <argument><expr><call><name>degHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       <expr_stmt><expr><name>max_temp</name> = <call><name>max</name><argument_list>(<argument><expr><name>max_temp</name></expr></argument>, <argument><expr><call><name>degTargetHotend</name><argument_list>(<argument><expr><name>cur_extruder</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
      <expr_stmt><expr><name>max_temp</name> = <call><name>max</name><argument_list>(<argument><expr><name>max_temp</name></expr></argument>, <argument><expr><call><name>degTargetBed</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>max_temp</name> = <call><name>max</name><argument_list>(<argument><expr><name>max_temp</name></expr></argument>, <argument><expr><call><name>degBed</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if>if<condition>(<expr>(<name>max_temp</name> &gt; 55.0) &amp;&amp; (<name>red_led</name> == false)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>STAT_LED_RED</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>STAT_LED_BLUE</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>red_led</name> = true</expr>;</expr_stmt>
      <expr_stmt><expr><name>blue_led</name> = false</expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>(<expr>(<name>max_temp</name> &lt; 54.0) &amp;&amp; (<name>blue_led</name> == false)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>STAT_LED_RED</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>STAT_LED_BLUE</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>red_led</name> = false</expr>;</expr_stmt>
      <expr_stmt><expr><name>blue_led</name> = true</expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>manage_inactivity</name><parameter_list>(<param><decl><type><name>bool</name></type> <name>ignore_stepper_queue</name></decl></param><comment type="block">/*=false*/</comment>)</parameter_list> <comment type="line">//default argument set in Marlin.h</comment>
<block>{
	
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>KILL_PIN</name> &gt; -1</expr></cpp:if>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>killCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>   <comment type="line">// make the inactivity button a bit less responsive</comment>
   <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>KILL_DELAY</name> <init>= <expr>10000</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HOME_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HOME_PIN</name> &gt; -1</expr></cpp:if>
   <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>homeDebounceCount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>   <comment type="line">// poor man's debouncing count</comment>
   <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>HOME_DEBOUNCE_DELAY</name> <init>= <expr>10000</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
   
	
  <if>if<condition>(<expr><name>buflen</name> &lt; (<name>BUFSIZE</name>-1)</expr>)</condition><then>
    <expr_stmt><expr><call><name>get_command</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_cmd</name>) &gt;  <name>max_inactive_time</name></expr> )</condition><then>
    <if>if<condition>(<expr><name>max_inactive_time</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>kill</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if></then></if>
  <if>if<condition>(<expr><name>stepper_inactive_time</name></expr>)</condition><then>  <block>{
    <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_cmd</name>) &gt;  <name>stepper_inactive_time</name></expr> )</condition><then>
    <block>{
      <if>if<condition>(<expr><call><name>blocks_queued</name><argument_list>()</argument_list></call> == false &amp;&amp; <name>ignore_stepper_queue</name> == false</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
  
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>CHDK</name></cpp:ifdef> <comment type="line">//Check if pin should be set to LOW after M240 set it to HIGH</comment>
    <if>if <condition>(<expr><name>chdkActive</name> &amp;&amp; (<call><name>millis</name><argument_list>()</argument_list></call> - <name>chdkHigh</name> &gt; <name>CHDK_DELAY</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>chdkActive</name> = false</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>CHDK</name></expr></argument>, <argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>KILL_PIN</name> &gt; -1</expr></cpp:if>
    
    <comment type="line">// Check if the kill button was pressed and wait just in case it was an accidental</comment>
    <comment type="line">// key kill key press</comment>
    <comment type="line">// -------------------------------------------------------------------------------</comment>
    <if>if<condition>( <expr>0 == <call><name>READ</name><argument_list>(<argument><expr><name>KILL_PIN</name></expr></argument>)</argument_list></call></expr> )</condition><then>
    <block>{
       <expr_stmt><expr><name>killCount</name>++</expr>;</expr_stmt>
    }</block></then>
    <else>else <if>if <condition>(<expr><name>killCount</name> &gt; 0</expr>)</condition><then>
    <block>{
       <expr_stmt><expr><name>killCount</name>--</expr>;</expr_stmt>
    }</block></then></if></else></if>
    <comment type="line">// Exceeded threshold and we can confirm that it was not accidental</comment>
    <comment type="line">// KILL the machine</comment>
    <comment type="line">// ----------------------------------------------------------------</comment>
    <if>if <condition>( <expr><name>killCount</name> &gt;= <name>KILL_DELAY</name></expr>)</condition><then>
    <block>{
       <expr_stmt><expr><call><name>kill</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HOME_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HOME_PIN</name> &gt; -1</expr></cpp:if>
    <comment type="line">// Check to see if we have to home, use poor man's debouncer</comment>
    <comment type="line">// ---------------------------------------------------------</comment>
    <if>if <condition>( <expr>0 == <call><name>READ</name><argument_list>(<argument><expr><name>HOME_PIN</name></expr></argument>)</argument_list></call></expr> )</condition><then>
    <block>{
       <if>if <condition>(<expr><name>homeDebounceCount</name> == 0</expr>)</condition><then>
       <block>{
          <expr_stmt><expr><call><name>enquecommand_P</name><argument_list>(<argument><expr>(<call><name>PSTR</name><argument_list>(<argument><expr>"G28"</expr></argument>)</argument_list></call>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>homeDebounceCount</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_AUTO_HOME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
       }</block></then>
       <else>else <if>if <condition>(<expr><name>homeDebounceCount</name> &lt; <name>HOME_DEBOUNCE_DELAY</name></expr>)</condition><then>
       <block>{
          <expr_stmt><expr><name>homeDebounceCount</name>++</expr>;</expr_stmt>
       }</block></then>
       <else>else
       <block>{
          <expr_stmt><expr><name>homeDebounceCount</name> = 0</expr>;</expr_stmt>
       }</block></else></if></else></if>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CONTROLLERFAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>CONTROLLERFAN_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>controllerFan</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">//Check if fan should be turned on to cool stepper drivers down</comment>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXTRUDER_RUNOUT_PREVENT</name></cpp:ifdef>
    <if>if<condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_cmd</name>) &gt;  <name>EXTRUDER_RUNOUT_SECONDS</name>*1000</expr> )</condition><then>
    <if>if<condition>(<expr><call><name>degHotend</name><argument_list>(<argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call>&gt;<name>EXTRUDER_RUNOUT_MINTEMP</name></expr>)</condition><then>
    <block>{
     <decl_stmt><decl><type><name>bool</name></type> <name>oldstatus</name><init>=<expr><call><name>READ</name><argument_list>(<argument><expr><name>E0_ENABLE_PIN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>enable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     <decl_stmt><decl><type><name>float</name></type> <name>oldepos</name><init>=<expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
     <decl_stmt><decl><type><name>float</name></type> <name>oldedes</name><init>=<expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
     <expr_stmt><expr><call><name>plan_buffer_line</name><argument_list>(<argument><expr><name><name>destination</name><index>[<expr><name>X_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Y_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>destination</name><index>[<expr><name>Z_AXIS</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>+<name>EXTRUDER_RUNOUT_EXTRUDE</name>*<name>EXTRUDER_RUNOUT_ESTEPS</name>/<name><name>axis_steps_per_unit</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>,
                      <argument><expr><name>EXTRUDER_RUNOUT_SPEED</name>/60.*<name>EXTRUDER_RUNOUT_ESTEPS</name>/<name><name>axis_steps_per_unit</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>, <argument><expr><name>active_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>current_position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name>oldepos</name></expr>;</expr_stmt>
     <expr_stmt><expr><name><name>destination</name><index>[<expr><name>E_AXIS</name></expr>]</index></name>=<name>oldedes</name></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>plan_set_e_position</name><argument_list>(<argument><expr><name>oldepos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><name>previous_millis_cmd</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>st_synchronize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
     <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>E0_ENABLE_PIN</name></expr></argument>,<argument><expr><name>oldstatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DUAL_X_CARRIAGE</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <comment type="line">// handle delayed move timeout</comment>
    <if>if <condition>(<expr><name>delayed_move_time</name> != 0 &amp;&amp; (<call><name>millis</name><argument_list>()</argument_list></call> - <name>delayed_move_time</name>) &gt; 1000 &amp;&amp; <name>Stopped</name> == false</expr>)</condition><then>
    <block>{
      <comment type="line">// travel moves have been received so enact them</comment>
      <expr_stmt><expr><name>delayed_move_time</name> = 0xFFFFFFFFUL</expr>;</expr_stmt> <comment type="line">// force moves to be done</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>destination</name></expr></argument>,<argument><expr><name>current_position</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>destination</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>prepare_move</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_STAT_LEDS</name></cpp:ifdef>
      <expr_stmt><expr><call><name>handle_status_leds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>check_axes_activity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>kill</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>cli</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// Stop interrupts</comment>
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>PS_ON_PIN</name> &gt; -1</expr></cpp:if>
  <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>PS_ON_PIN</name></expr></argument>,<argument><expr><name>INPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_KILLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_KILLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// FMC small patch to update the LCD before ending</comment>
  <expr_stmt><expr><call><name>sei</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// enable interrupts</comment>
  <for>for ( <init><decl><type><name>int</name></type> <name>i</name><init>=<expr>5</expr></init></decl>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr></incr>)
  <block>{
     <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>200</expr></argument>)</argument_list></call></expr>;</expr_stmt>	
  }</block></for>
  <expr_stmt><expr><call><name>cli</name><argument_list>()</argument_list></call></expr>;</expr_stmt>   <comment type="line">// disable interrupts</comment>
  <expr_stmt><expr><call><name>suicide</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <while>while<condition>(<expr>1</expr>)</condition> <block>{ <comment type="block">/* Intentionally left empty */</comment> }</block></while> <comment type="line">// Wait for reset</comment>
}</block></function>

<function><type><name>void</name></type> <name>Stop</name><parameter_list>()</parameter_list>
<block>{
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(<expr><name>Stopped</name> == false</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>Stopped</name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name>Stopped_gcode_LastN</name> = <name>gcode_LastN</name></expr>;</expr_stmt> <comment type="line">// Save last g_code for restart</comment>
    <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr><name>MSG_ERR_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr><name>MSG_STOPPED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<function><type><name>bool</name></type> <name>IsStopped</name><parameter_list>()</parameter_list> <block>{ <return>return <expr><name>Stopped</name></expr>;</return> }</block></function><empty_stmt>;</empty_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAST_PWM_FAN</name></cpp:ifdef>
<function><type><name>void</name></type> <name>setPwmFrequency</name><parameter_list>(<param><decl><type><name>uint8_t</name></type> <name>pin</name></decl></param>, <param><decl><type><name>int</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>val</name> &amp;= 0x07</expr>;</expr_stmt>
  <switch>switch<condition>(<expr><call><name>digitalPinToTimer</name><argument_list>(<argument><expr><name>pin</name></expr></argument>)</argument_list></call></expr>)</condition>
  <block>{

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR0A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <case>case <expr><name>TIMER0A</name></expr>:
    </case><case>case <expr><name>TIMER0B</name></expr>:
<comment type="line">//         TCCR0B &amp;= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));</comment>
<comment type="line">//         TCCR0B |= val;</comment>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR1A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER1A</name></expr>:
    </case><case>case <expr><name>TIMER1B</name></expr>:
<comment type="line">//         TCCR1B &amp;= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));</comment>
<comment type="line">//         TCCR1B |= val;</comment>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR2</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER2</name></expr>:
    </case><case>case <expr><name>TIMER2</name></expr>:
         <expr_stmt><expr><name>TCCR2</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS10</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS11</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS12</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR2</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR2A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER2A</name></expr>:
    </case><case>case <expr><name>TIMER2B</name></expr>:
         <expr_stmt><expr><name>TCCR2B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS20</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS21</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS22</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR2B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR3A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER3A</name></expr>:
    </case><case>case <expr><name>TIMER3B</name></expr>:
    </case><case>case <expr><name>TIMER3C</name></expr>:
         <expr_stmt><expr><name>TCCR3B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS30</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS31</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS32</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR3B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR4A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER4A</name></expr>:
    </case><case>case <expr><name>TIMER4B</name></expr>:
    </case><case>case <expr><name>TIMER4C</name></expr>:
         <expr_stmt><expr><name>TCCR4B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS40</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS41</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS42</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR4B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TCCR5A</name></expr></argument>)</argument_list></call></expr></cpp:if>
    </case><case>case <expr><name>TIMER5A</name></expr>:
    </case><case>case <expr><name>TIMER5B</name></expr>:
    </case><case>case <expr><name>TIMER5C</name></expr>:
         <expr_stmt><expr><name>TCCR5B</name> &amp;= ~(<call><name>_BV</name><argument_list>(<argument><expr><name>CS50</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS51</name></expr></argument>)</argument_list></call> | <call><name>_BV</name><argument_list>(<argument><expr><name>CS52</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
         <expr_stmt><expr><name>TCCR5B</name> |= <name>val</name></expr>;</expr_stmt>
         <break>break;</break>
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  </case>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//FAST_PWM_FAN</comment>

<function><type><name>bool</name></type> <name>setTargetedHotend</name><parameter_list>(<param><decl><type><name>int</name></type> <name>code</name></decl></param>)</parameter_list><block>{
  <expr_stmt><expr><name>tmp_extruder</name> = <name>active_extruder</name></expr>;</expr_stmt>
  <if>if<condition>(<expr><call><name>code_seen</name><argument_list>(<argument><expr>'T'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
    <expr_stmt><expr><name>tmp_extruder</name> = <call><name>code_value</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>tmp_extruder</name> &gt;= <name>EXTRUDERS</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
      <switch>switch<condition>(<expr><name>code</name></expr>)</condition><block>{
        <case>case <expr>104</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M104_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>105</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M105_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>109</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M109_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>218</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M218_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr>221</expr>:
          <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>MSG_M221_INVALID_EXTRUDER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
      </case>}</block></switch>
      <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name>tmp_extruder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>true</expr>;</return>
    }</block></then></if>
  }</block></then></if>
  <return>return <expr>false</expr>;</return>
}</block></function>


<function><type><name>float</name></type> <name>calculate_volumetric_multiplier</name><parameter_list>(<param><decl><type><name>float</name></type> <name>diameter</name></decl></param>)</parameter_list> <block>{
	<decl_stmt><decl><type><name>float</name></type> <name>area</name> <init>= <expr>.0</expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float</name></type> <name>radius</name> <init>= <expr>.0</expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>radius</name> = <name>diameter</name> * .5</expr>;</expr_stmt>
	<if>if <condition>(<expr>! <name>volumetric_enabled</name> || <name>radius</name> == 0</expr>)</condition><then> <block>{
		<expr_stmt><expr><name>area</name> = 1</expr>;</expr_stmt>
	}</block></then>
	<else>else <block>{
		<expr_stmt><expr><name>area</name> = <name>M_PI</name> * <call><name>pow</name><argument_list>(<argument><expr><name>radius</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
	}</block></else></if>

	<return>return <expr>1.0 / <name>area</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type> <name>calculate_volumetric_multipliers</name><parameter_list>()</parameter_list> <block>{
	<expr_stmt><expr><name><name>volumetric_multiplier</name><index>[<expr>0</expr>]</index></name> = <call><name>calculate_volumetric_multiplier</name><argument_list>(<argument><expr><name><name>filament_size</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
	<expr_stmt><expr><name><name>volumetric_multiplier</name><index>[<expr>1</expr>]</index></name> = <call><name>calculate_volumetric_multiplier</name><argument_list>(<argument><expr><name><name>filament_size</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
	<expr_stmt><expr><name><name>volumetric_multiplier</name><index>[<expr>2</expr>]</index></name> = <call><name>calculate_volumetric_multiplier</name><argument_list>(<argument><expr><name><name>filament_size</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function></block></function>

</unit>
