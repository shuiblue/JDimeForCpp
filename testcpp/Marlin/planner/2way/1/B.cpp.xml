<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="testcpp/Marlin/planner/2way/1/B.cpp"><comment type="block">/*
  planner.c - buffers movement commands and manages the acceleration profile plan
 Part of Grbl
 
 Copyright (c) 2009-2011 Simen Svale Skogsrud
 
 Grbl is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 Grbl is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with Grbl.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/* The ring buffer implementation gleaned from the wiring_serial library by David A. Mellis. */</comment>

<comment type="block">/*  
 Reasoning behind the mathematics in this module (in the key of 'Mathematica'):
 
 s == speed, a == acceleration, t == time, d == distance
 
 Basic definitions:
 
 Speed[s_, a_, t_] := s + (a*t) 
 Travel[s_, a_, t_] := Integrate[Speed[s, a, t], t]
 
 Distance to reach a specific speed with a constant acceleration:
 
 Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, d, t]
 d -&gt; (m^2 - s^2)/(2 a) --&gt; estimate_acceleration_distance()
 
 Speed after a given distance of travel with constant acceleration:
 
 Solve[{Speed[s, a, t] == m, Travel[s, a, t] == d}, m, t]
 m -&gt; Sqrt[2 a d + s^2]    
 
 DestinationSpeed[s_, a_, d_] := Sqrt[2 a d + s^2]
 
 When to start braking (di) to reach a specified destionation speed (s2) after accelerating
 from initial speed s1 without ever stopping at a plateau:
 
 Solve[{DestinationSpeed[s1, a, di] == DestinationSpeed[s2, a, d - di]}, di]
 di -&gt; (2 a d - s1^2 + s2^2)/(4 a) --&gt; intersection_distance()
 
 IntersectionDistance[s1_, s2_, a_, d_] := (2 a d - s1^2 + s2^2)/(4 a)
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Marlin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stepper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"temperature.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ultralcd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"language.h"</cpp:file></cpp:include>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================public variables ============================</comment>
<comment type="line">//===========================================================================</comment>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>minsegmenttime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>max_feedrate</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt> <comment type="line">// set the max speeds</comment>
<decl_stmt><decl><type><name>float</name></type> <name><name>axis_steps_per_unit</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name><name>max_acceleration_units_per_sq_second</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt> <comment type="line">// Use M201 to override by software</comment>
<decl_stmt><decl><type><name>float</name></type> <name>minimumfeedrate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>acceleration</name></decl>;</decl_stmt>         <comment type="line">// Normal acceleration mm/s^2  THIS IS THE DEFAULT ACCELERATION for all moves. M204 SXXXX</comment>
<decl_stmt><decl><type><name>float</name></type> <name>retract_acceleration</name></decl>;</decl_stmt> <comment type="line">//  mm/s^2   filament pull-pack and push-forward  while standing still in the other axis M204 TXXXX</comment>
<decl_stmt><decl><type><name>float</name></type> <name>max_xy_jerk</name></decl>;</decl_stmt> <comment type="line">//speed than can be stopped at once, if i understand correctly.</comment>
<decl_stmt><decl><type><name>float</name></type> <name>max_z_jerk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>max_e_jerk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>mintravelfeedrate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name><name>axis_steps_per_sqr_second</name><index>[<expr><name>NUM_AXIS</name></expr>]</index></name></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
<comment type="line">// this holds the required transform to compensate for bed level</comment>
<decl_stmt><decl><type><name>matrix_3x3</name></type> <name>plan_bed_level_matrix</name> <init>= <expr><block>{
  <expr>1.0</expr>, <expr>0.0</expr>, <expr>0.0</expr>,
  <expr>0.0</expr>, <expr>1.0</expr>, <expr>0.0</expr>,
  <expr>0.0</expr>, <expr>0.0</expr>, <expr>1.0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// #ifdef ENABLE_AUTO_BED_LEVELING</comment>

<comment type="line">// The current position of the tool in absolute steps</comment>
<decl_stmt><decl><type><name>long</name></type> <name><name>position</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>   <comment type="line">//rescaled from extern when axis_steps_per_unit are changed by gcode</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>previous_speed</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt> <comment type="line">// Speed of previous path line segment</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>previous_nominal_speed</name></decl>;</decl_stmt> <comment type="line">// Nominal speed of previous path line segment</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
<decl_stmt><decl><type><name>float</name></type> <name>autotemp_max</name><init>=<expr>250</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>autotemp_min</name><init>=<expr>210</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>autotemp_factor</name><init>=<expr>0.1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>autotemp_enabled</name><init>=<expr>false</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>g_uc_extruder_last_move</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=================semi-private variables, used in inline  functions    =====</comment>
<comment type="line">//===========================================================================</comment>
<decl_stmt><decl><type><name>block_t</name></type> <name><name>block_buffer</name><index>[<expr><name>BLOCK_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>            <comment type="line">// A ring buffer for motion instfructions</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name></type> <name>block_buffer_head</name></decl>;</decl_stmt>           <comment type="line">// Index of the next block to be pushed</comment>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>unsigned</name> <name>char</name></type> <name>block_buffer_tail</name></decl>;</decl_stmt>           <comment type="line">// Index of the block to process now</comment>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================private variables ============================</comment>
<comment type="line">//===========================================================================</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PREVENT_DANGEROUS_EXTRUDE</name></cpp:ifdef>
<decl_stmt><decl><type><name>float</name></type> <name>extrude_min_temp</name><init>=<expr><name>EXTRUDE_MINTEMP</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XY_FREQUENCY_LIMIT</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FREQ_TIME</name></cpp:macro> <cpp:value>(1000000.0/XY_FREQUENCY_LIMIT)</cpp:value></cpp:define>
<comment type="line">// Used for the frequency limit</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>old_direction_bits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>               <comment type="line">// Old direction bits. Used for speed calculations</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name><name>x_segment_time</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr><name>MAX_FREQ_TIME</name> + 1</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>     <comment type="line">// Segment times (in us). Used for speed calculations</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name><name>y_segment_time</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr><name>MAX_FREQ_TIME</name> + 1</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
 <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>meas_sample</name></decl>;</decl_stmt> <comment type="line">//temporary variable to hold filament measurement sample</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="line">// Returns the index of the next block in the ring buffer</comment>
<comment type="line">// NOTE: Removed modulo (%) operator, which uses an expensive divide and multiplication.</comment>
<function><type><specifier>static</specifier> <name>int8_t</name></type> <name>next_block_index</name><parameter_list>(<param><decl><type><name>int8_t</name></type> <name>block_index</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><name>block_index</name>++</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>block_index</name> == <name>BLOCK_BUFFER_SIZE</name></expr>)</condition><then> <block>{ 
    <expr_stmt><expr><name>block_index</name> = 0</expr>;</expr_stmt> 
  }</block></then></if>
  <return>return<expr>(<name>block_index</name>)</expr>;</return>
}</block></function>


<comment type="line">// Returns the index of the previous block in the ring buffer</comment>
<function><type><specifier>static</specifier> <name>int8_t</name></type> <name>prev_block_index</name><parameter_list>(<param><decl><type><name>int8_t</name></type> <name>block_index</name></decl></param>)</parameter_list> <block>{
  <if>if <condition>(<expr><name>block_index</name> == 0</expr>)</condition><then> <block>{ 
    <expr_stmt><expr><name>block_index</name> = <name>BLOCK_BUFFER_SIZE</name></expr>;</expr_stmt> 
  }</block></then></if>
  <expr_stmt><expr><name>block_index</name>--</expr>;</expr_stmt>
  <return>return<expr>(<name>block_index</name>)</expr>;</return>
}</block></function>

<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================functions         ============================</comment>
<comment type="line">//===========================================================================</comment>

<comment type="line">// Calculates the distance (not time) it takes to accelerate from initial_rate to target_rate using the </comment>
<comment type="line">// given acceleration:</comment>
<function><type><name>FORCE_INLINE</name> <name>float</name></type> <name>estimate_acceleration_distance</name><parameter_list>(<param><decl><type><name>float</name></type> <name>initial_rate</name></decl></param>, <param><decl><type><name>float</name></type> <name>target_rate</name></decl></param>, <param><decl><type><name>float</name></type> <name>acceleration</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>acceleration</name>!=0</expr>)</condition><then> <block>{
    <return>return<expr>((<name>target_rate</name>*<name>target_rate</name>-<name>initial_rate</name>*<name>initial_rate</name>)/
      (2.0*<name>acceleration</name>))</expr>;</return>
  }</block></then>
  <else>else <block>{
    <return>return <expr>0.0</expr>;</return>  <comment type="line">// acceleration was 0, set acceleration distance to 0</comment>
  }</block></else></if>
}</block></function>

<comment type="line">// This function gives you the point at which you must start braking (at the rate of -acceleration) if </comment>
<comment type="line">// you started at speed initial_rate and accelerated until this point and want to end at the final_rate after</comment>
<comment type="line">// a total travel of distance. This can be used to compute the intersection point between acceleration and</comment>
<comment type="line">// deceleration in the cases where the trapezoid has no plateau (i.e. never reaches maximum speed)</comment>

<function><type><name>FORCE_INLINE</name> <name>float</name></type> <name>intersection_distance</name><parameter_list>(<param><decl><type><name>float</name></type> <name>initial_rate</name></decl></param>, <param><decl><type><name>float</name></type> <name>final_rate</name></decl></param>, <param><decl><type><name>float</name></type> <name>acceleration</name></decl></param>, <param><decl><type><name>float</name></type> <name>distance</name></decl></param>)</parameter_list> 
<block>{
  <if>if <condition>(<expr><name>acceleration</name>!=0</expr>)</condition><then> <block>{
    <return>return<expr>((2.0*<name>acceleration</name>*<name>distance</name>-<name>initial_rate</name>*<name>initial_rate</name>+<name>final_rate</name>*<name>final_rate</name>)/
      (4.0*<name>acceleration</name>) )</expr>;</return>
  }</block></then>
  <else>else <block>{
    <return>return <expr>0.0</expr>;</return>  <comment type="line">// acceleration was 0, set intersection distance to 0</comment>
  }</block></else></if>
}</block></function>


<comment type="line">// Calculates trapezoid parameters so that the entry- and exit-speed is compensated by the provided factors.</comment>

<function><type><name>void</name></type> <name>calculate_trapezoid_for_block</name><parameter_list>(<param><decl><type><name>block_t</name> *</type><name>block</name></decl></param>, <param><decl><type><name>float</name></type> <name>entry_factor</name></decl></param>, <param><decl><type><name>float</name></type> <name>exit_factor</name></decl></param>)</parameter_list> <block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>initial_rate</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>nominal_rate</name></name>*<name>entry_factor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// (step/min)</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>final_rate</name> <init>= <expr><call><name>ceil</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>nominal_rate</name></name>*<name>exit_factor</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="line">// (step/min)</comment>

  <comment type="line">// Limit minimal step rate (Otherwise the timer will overflow.)</comment>
  <if>if<condition>(<expr><name>initial_rate</name> &lt;120</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>initial_rate</name>=120</expr>;</expr_stmt> 
  }</block></then></if>
  <if>if<condition>(<expr><name>final_rate</name> &lt; 120</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>final_rate</name>=120</expr>;</expr_stmt>  
  }</block></then></if>

  <decl_stmt><decl><type><name>long</name></type> <name>acceleration</name> <init>= <expr><name><name>block</name>-&gt;<name>acceleration_st</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>accelerate_steps</name> <init>=
    <expr><call><name>ceil</name><argument_list>(<argument><expr><call><name>estimate_acceleration_distance</name><argument_list>(<argument><expr><name>initial_rate</name></expr></argument>, <argument><expr><name><name>block</name>-&gt;<name>nominal_rate</name></name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>decelerate_steps</name> <init>=
    <expr><call><name>floor</name><argument_list>(<argument><expr><call><name>estimate_acceleration_distance</name><argument_list>(<argument><expr><name><name>block</name>-&gt;<name>nominal_rate</name></name></expr></argument>, <argument><expr><name>final_rate</name></expr></argument>, <argument><expr>-<name>acceleration</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">// Calculate the size of Plateau of Nominal Rate.</comment>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>plateau_steps</name> <init>= <expr><name><name>block</name>-&gt;<name>step_event_count</name></name>-<name>accelerate_steps</name>-<name>decelerate_steps</name></expr></init></decl>;</decl_stmt>

  <comment type="line">// Is the Plateau of Nominal Rate smaller than nothing? That means no cruising, and we will</comment>
  <comment type="line">// have to use intersection_distance() to calculate when to abort acceleration and start braking</comment>
  <comment type="line">// in order to reach the final_rate exactly at the end of this block.</comment>
  <if>if <condition>(<expr><name>plateau_steps</name> &lt; 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>accelerate_steps</name> = <call><name>ceil</name><argument_list>(<argument><expr><call><name>intersection_distance</name><argument_list>(<argument><expr><name>initial_rate</name></expr></argument>, <argument><expr><name>final_rate</name></expr></argument>, <argument><expr><name>acceleration</name></expr></argument>, <argument><expr><name><name>block</name>-&gt;<name>step_event_count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>accelerate_steps</name> = <call><name>max</name><argument_list>(<argument><expr><name>accelerate_steps</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// Check limits due to numerical round-off</comment>
    <expr_stmt><expr><name>accelerate_steps</name> = <call><name>min</name><argument_list>(<argument><expr>(<name>uint32_t</name>)<name>accelerate_steps</name></expr></argument>,<argument><expr><name><name>block</name>-&gt;<name>step_event_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt><comment type="line">//(We can cast here to unsigned, because the above line ensures that we are above zero)</comment>
    <expr_stmt><expr><name>plateau_steps</name> = 0</expr>;</expr_stmt>
  }</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ADVANCE</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>long</name></type> <name>initial_advance</name> <init>= <expr><name><name>block</name>-&gt;<name>advance</name></name>*<name>entry_factor</name>*<name>entry_factor</name></expr></init></decl>;</decl_stmt> 
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>long</name></type> <name>final_advance</name> <init>= <expr><name><name>block</name>-&gt;<name>advance</name></name>*<name>exit_factor</name>*<name>exit_factor</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ADVANCE</comment>

  <comment type="line">// block-&gt;accelerate_until = accelerate_steps;</comment>
  <comment type="line">// block-&gt;decelerate_after = accelerate_steps+plateau_steps;</comment>
  <expr_stmt><expr><name>CRITICAL_SECTION_START</name></expr>;</expr_stmt>  <comment type="line">// Fill variables used by the stepper in a critical section</comment>
  <if>if<condition>(<expr><name><name>block</name>-&gt;<name>busy</name></name> == false</expr>)</condition><then> <block>{ <comment type="line">// Don't update variables if block is busy.</comment>
    <expr_stmt><expr><name><name>block</name>-&gt;<name>accelerate_until</name></name> = <name>accelerate_steps</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name>-&gt;<name>decelerate_after</name></name> = <name>accelerate_steps</name>+<name>plateau_steps</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name>-&gt;<name>initial_rate</name></name> = <name>initial_rate</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name>-&gt;<name>final_rate</name></name> = <name>final_rate</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ADVANCE</name></cpp:ifdef>
    <expr_stmt><expr><name><name>block</name>-&gt;<name>initial_advance</name></name> = <name>initial_advance</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name>-&gt;<name>final_advance</name></name> = <name>final_advance</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//ADVANCE</comment>
  }</block></then></if>
  <expr_stmt><expr><name>CRITICAL_SECTION_END</name></expr>;</expr_stmt>
}</block></function>                    

<comment type="line">// Calculates the maximum allowable speed at this point when you must be able to reach target_velocity using the </comment>
<comment type="line">// acceleration within the allotted distance.</comment>
<function><type><name>FORCE_INLINE</name> <name>float</name></type> <name>max_allowable_speed</name><parameter_list>(<param><decl><type><name>float</name></type> <name>acceleration</name></decl></param>, <param><decl><type><name>float</name></type> <name>target_velocity</name></decl></param>, <param><decl><type><name>float</name></type> <name>distance</name></decl></param>)</parameter_list> <block>{
  <return>return  <expr><call><name>sqrt</name><argument_list>(<argument><expr><name>target_velocity</name>*<name>target_velocity</name>-2*<name>acceleration</name>*<name>distance</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="line">// "Junction jerk" in this context is the immediate change in speed at the junction of two blocks.</comment>
<comment type="line">// This method will calculate the junction jerk as the euclidean distance between the nominal </comment>
<comment type="line">// velocities of the respective blocks.</comment>
<comment type="line">//inline float junction_jerk(block_t *before, block_t *after) {</comment>
<comment type="line">//  return sqrt(</comment>
<comment type="line">//    pow((before-&gt;speed_x-after-&gt;speed_x), 2)+pow((before-&gt;speed_y-after-&gt;speed_y), 2));</comment>
<comment type="line">//}</comment>
<comment type="line">// The kernel called by planner_recalculate() when scanning the plan from last to first entry.</comment>
<function><type><name>void</name></type> <name>planner_reverse_pass_kernel</name><parameter_list>(<param><decl><type><name>block_t</name> *</type><name>previous</name></decl></param>, <param><decl><type><name>block_t</name> *</type><name>current</name></decl></param>, <param><decl><type><name>block_t</name> *</type><name>next</name></decl></param>)</parameter_list> <block>{
  <if>if<condition>(<expr>!<name>current</name></expr>)</condition><then> <block>{ 
    <return>return;</return> 
  }</block></then></if>

  <if>if <condition>(<expr><name>next</name></expr>)</condition><then> <block>{
    <comment type="line">// If entry speed is already at the maximum entry speed, no need to recheck. Block is cruising.</comment>
    <comment type="line">// If not, block in state of acceleration or deceleration. Reset entry speed to maximum and</comment>
    <comment type="line">// check for maximum allowable speed reductions to ensure maximum possible planned speed.</comment>
    <if>if <condition>(<expr><name><name>current</name>-&gt;<name>entry_speed</name></name> != <name><name>current</name>-&gt;<name>max_entry_speed</name></name></expr>)</condition><then> <block>{

      <comment type="line">// If nominal length true, max junction speed is guaranteed to be reached. Only compute</comment>
      <comment type="line">// for max allowable speed if block is decelerating and nominal length is false.</comment>
      <if>if <condition>(<expr>(!<name><name>current</name>-&gt;<name>nominal_length_flag</name></name>) &amp;&amp; (<name><name>current</name>-&gt;<name>max_entry_speed</name></name> &gt; <name><name>next</name>-&gt;<name>entry_speed</name></name>)</expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>current</name>-&gt;<name>entry_speed</name></name> = <call><name>min</name><argument_list>( <argument><expr><name><name>current</name>-&gt;<name>max_entry_speed</name></name></expr></argument>,
        <argument><expr><call><name>max_allowable_speed</name><argument_list>(<argument><expr>-<name><name>current</name>-&gt;<name>acceleration</name></name></expr></argument>,<argument><expr><name><name>next</name>-&gt;<name>entry_speed</name></name></expr></argument>,<argument><expr><name><name>current</name>-&gt;<name>millimeters</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then> 
      <else>else <block>{
        <expr_stmt><expr><name><name>current</name>-&gt;<name>entry_speed</name></name> = <name><name>current</name>-&gt;<name>max_entry_speed</name></name></expr>;</expr_stmt>
      }</block></else></if>
      <expr_stmt><expr><name><name>current</name>-&gt;<name>recalculate_flag</name></name> = true</expr>;</expr_stmt>

    }</block></then></if>
  }</block></then></if> <comment type="line">// Skip last block. Already initialized and set for recalculation.</comment>
}</block></function>


<comment type="line">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This </comment>
<comment type="line">// implements the reverse pass.</comment>
<function><type><name>void</name></type> <name>planner_reverse_pass</name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>block_index</name> <init>= <expr><name>block_buffer_head</name></expr></init></decl>;</decl_stmt>
  
  <comment type="line">//Make a local copy of block_buffer_tail, because the interrupt can alter it</comment>
  <expr_stmt><expr><name>CRITICAL_SECTION_START</name></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>tail</name> <init>= <expr><name>block_buffer_tail</name></expr></init></decl>;</decl_stmt>
  <macro><name>CRITICAL_SECTION_END</name></macro>
  
  <if>if<condition>(<expr>((<name>block_buffer_head</name>-<name>tail</name> + <name>BLOCK_BUFFER_SIZE</name>) &amp; (<name>BLOCK_BUFFER_SIZE</name> - 1)) &gt; 3</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>block_index</name> = (<name>block_buffer_head</name> - 3) &amp; (<name>BLOCK_BUFFER_SIZE</name> - 1)</expr>;</expr_stmt>
    <decl_stmt><decl><type><name>block_t</name> *</type><name><name>block</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{ 
      <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>         }</block></expr></init></decl>;</decl_stmt>
    <while>while<condition>(<expr><name>block_index</name> != <name>tail</name></expr>)</condition> <block>{ 
      <expr_stmt><expr><name>block_index</name> = <call><name>prev_block_index</name><argument_list>(<argument><expr><name>block_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
      <expr_stmt><expr><name><name>block</name><index>[<expr>2</expr>]</index></name>= <name><name>block</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>block</name><index>[<expr>1</expr>]</index></name>= <name><name>block</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>block</name><index>[<expr>0</expr>]</index></name> = &amp;<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>planner_reverse_pass_kernel</name><argument_list>(<argument><expr><name><name>block</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
}</block></function>

<comment type="line">// The kernel called by planner_recalculate() when scanning the plan from first to last entry.</comment>
<function><type><name>void</name></type> <name>planner_forward_pass_kernel</name><parameter_list>(<param><decl><type><name>block_t</name> *</type><name>previous</name></decl></param>, <param><decl><type><name>block_t</name> *</type><name>current</name></decl></param>, <param><decl><type><name>block_t</name> *</type><name>next</name></decl></param>)</parameter_list> <block>{
  <if>if<condition>(<expr>!<name>previous</name></expr>)</condition><then> <block>{ 
    <return>return;</return> 
  }</block></then></if>

  <comment type="line">// If the previous block is an acceleration block, but it is not long enough to complete the</comment>
  <comment type="line">// full speed change within the block, we need to adjust the entry speed accordingly. Entry</comment>
  <comment type="line">// speeds have already been reset, maximized, and reverse planned by reverse planner.</comment>
  <comment type="line">// If nominal length is true, max junction speed is guaranteed to be reached. No need to recheck.</comment>
  <if>if <condition>(<expr>!<name><name>previous</name>-&gt;<name>nominal_length_flag</name></name></expr>)</condition><then> <block>{
    <if>if <condition>(<expr><name><name>previous</name>-&gt;<name>entry_speed</name></name> &lt; <name><name>current</name>-&gt;<name>entry_speed</name></name></expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>double</name></type> <name>entry_speed</name> <init>= <expr><call><name>min</name><argument_list>( <argument><expr><name><name>current</name>-&gt;<name>entry_speed</name></name></expr></argument>,
      <argument><expr><call><name>max_allowable_speed</name><argument_list>(<argument><expr>-<name><name>previous</name>-&gt;<name>acceleration</name></name></expr></argument>,<argument><expr><name><name>previous</name>-&gt;<name>entry_speed</name></name></expr></argument>,<argument><expr><name><name>previous</name>-&gt;<name>millimeters</name></name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="line">// Check for junction speed change</comment>
      <if>if <condition>(<expr><name><name>current</name>-&gt;<name>entry_speed</name></name> != <name>entry_speed</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><name><name>current</name>-&gt;<name>entry_speed</name></name> = <name>entry_speed</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current</name>-&gt;<name>recalculate_flag</name></name> = true</expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
  }</block></then></if>
}</block></function>

<comment type="line">// planner_recalculate() needs to go over the current plan twice. Once in reverse and once forward. This </comment>
<comment type="line">// implements the forward pass.</comment>
<function><type><name>void</name></type> <name>planner_forward_pass</name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>block_index</name> <init>= <expr><name>block_buffer_tail</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>block_t</name> *</type><name><name>block</name><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{ 
    <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>   }</block></expr></init></decl>;</decl_stmt>

  <while>while<condition>(<expr><name>block_index</name> != <name>block_buffer_head</name></expr>)</condition> <block>{
    <expr_stmt><expr><name><name>block</name><index>[<expr>0</expr>]</index></name> = <name><name>block</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name><index>[<expr>1</expr>]</index></name> = <name><name>block</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>block</name><index>[<expr>2</expr>]</index></name> = &amp;<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>planner_forward_pass_kernel</name><argument_list>(<argument><expr><name><name>block</name><index>[<expr>0</expr>]</index></name></expr></argument>,<argument><expr><name><name>block</name><index>[<expr>1</expr>]</index></name></expr></argument>,<argument><expr><name><name>block</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>block_index</name> = <call><name>next_block_index</name><argument_list>(<argument><expr><name>block_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <expr_stmt><expr><call><name>planner_forward_pass_kernel</name><argument_list>(<argument><expr><name><name>block</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>block</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="line">// Recalculates the trapezoid speed profiles for all blocks in the plan according to the </comment>
<comment type="line">// entry_factor for each junction. Must be called by planner_recalculate() after </comment>
<comment type="line">// updating the blocks.</comment>
<function><type><name>void</name></type> <name>planner_recalculate_trapezoids</name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>int8_t</name></type> <name>block_index</name> <init>= <expr><name>block_buffer_tail</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>block_t</name> *</type><name>current</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>block_t</name> *</type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>(<expr><name>block_index</name> != <name>block_buffer_head</name></expr>)</condition> <block>{
    <expr_stmt><expr><name>current</name> = <name>next</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>next</name> = &amp;<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>current</name></expr>)</condition><then> <block>{
      <comment type="line">// Recalculate if current block entry or exit junction speed has changed.</comment>
      <if>if <condition>(<expr><name><name>current</name>-&gt;<name>recalculate_flag</name></name> || <name><name>next</name>-&gt;<name>recalculate_flag</name></name></expr>)</condition><then> <block>{
        <comment type="line">// NOTE: Entry and exit factors always &gt; 0 by all previous logic operations.</comment>
        <expr_stmt><expr><call><name>calculate_trapezoid_for_block</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name><name>current</name>-&gt;<name>entry_speed</name></name>/<name><name>current</name>-&gt;<name>nominal_speed</name></name></expr></argument>,
        <argument><expr><name><name>next</name>-&gt;<name>entry_speed</name></name>/<name><name>current</name>-&gt;<name>nominal_speed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>current</name>-&gt;<name>recalculate_flag</name></name> = false</expr>;</expr_stmt> <comment type="line">// Reset current only to ensure next trapezoid is computed</comment>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>block_index</name> = <call><name>next_block_index</name><argument_list>( <argument><expr><name>block_index</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
  }</block></while>
  <comment type="line">// Last/newest block in buffer. Exit speed is set with MINIMUM_PLANNER_SPEED. Always recalculated.</comment>
  <if>if<condition>(<expr><name>next</name> != <name>NULL</name></expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>calculate_trapezoid_for_block</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><name><name>next</name>-&gt;<name>entry_speed</name></name>/<name><name>next</name>-&gt;<name>nominal_speed</name></name></expr></argument>,
    <argument><expr><name>MINIMUM_PLANNER_SPEED</name>/<name><name>next</name>-&gt;<name>nominal_speed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>next</name>-&gt;<name>recalculate_flag</name></name> = false</expr>;</expr_stmt>
  }</block></then></if>
}</block></function>

<comment type="line">// Recalculates the motion plan according to the following algorithm:</comment>
<comment type="line">//</comment>
<comment type="line">//   1. Go over every block in reverse order and calculate a junction speed reduction (i.e. block_t.entry_factor) </comment>
<comment type="line">//      so that:</comment>
<comment type="line">//     a. The junction jerk is within the set limit</comment>
<comment type="line">//     b. No speed reduction within one block requires faster deceleration than the one, true constant </comment>
<comment type="line">//        acceleration.</comment>
<comment type="line">//   2. Go over every block in chronological order and dial down junction speed reduction values if </comment>
<comment type="line">//     a. The speed increase within one block would require faster accelleration than the one, true </comment>
<comment type="line">//        constant acceleration.</comment>
<comment type="line">//</comment>
<comment type="line">// When these stages are complete all blocks have an entry_factor that will allow all speed changes to </comment>
<comment type="line">// be performed using only the one, true constant acceleration, and where no junction jerk is jerkier than </comment>
<comment type="line">// the set limit. Finally it will:</comment>
<comment type="line">//</comment>
<comment type="line">//   3. Recalculate trapezoids for all blocks.</comment>

<function><type><name>void</name></type> <name>planner_recalculate</name><parameter_list>()</parameter_list> <block>{   
  <expr_stmt><expr><call><name>planner_reverse_pass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>planner_forward_pass</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>planner_recalculate_trapezoids</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>plan_init</name><parameter_list>()</parameter_list> <block>{
  <expr_stmt><expr><name>block_buffer_head</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>block_buffer_tail</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>position</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// clear position</comment>
  <expr_stmt><expr><name><name>previous_speed</name><index>[<expr>0</expr>]</index></name> = 0.0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>previous_speed</name><index>[<expr>1</expr>]</index></name> = 0.0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>previous_speed</name><index>[<expr>2</expr>]</index></name> = 0.0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>previous_speed</name><index>[<expr>3</expr>]</index></name> = 0.0</expr>;</expr_stmt>
  <expr_stmt><expr><name>previous_nominal_speed</name> = 0.0</expr>;</expr_stmt>
}</block></function>




<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
<function><type><name>void</name></type> <name>getHighESpeed</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>oldt</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr>!<name>autotemp_enabled</name></expr>)</condition><then><block>{
    <return>return;</return>
  }</block></then></if>
  <if>if<condition>(<expr><call><name>degTargetHotend0</name><argument_list>()</argument_list></call>+2&lt;<name>autotemp_min</name></expr>)</condition><then> <block>{  <comment type="line">//probably temperature set to zero.</comment>
    <return>return;</return> <comment type="line">//do nothing</comment>
  }</block></then></if>

  <decl_stmt><decl><type><name>float</name></type> <name>high</name><init>=<expr>0.0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>block_index</name> <init>= <expr><name>block_buffer_tail</name></expr></init></decl>;</decl_stmt>

  <while>while<condition>(<expr><name>block_index</name> != <name>block_buffer_head</name></expr>)</condition> <block>{
    <if>if<condition>(<expr>(<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>steps_x</name> != 0) ||
      (<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>steps_y</name> != 0) ||
      (<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>steps_z</name> != 0)</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>float</name></type> <name>se</name><init>=<expr>(<call><name>float</name><argument_list>(<argument><expr><name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>steps_e</name></expr></argument>)</argument_list></call>/<call><name>float</name><argument_list>(<argument><expr><name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>step_event_count</name></expr></argument>)</argument_list></call>)*<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>nominal_speed</name></expr></init></decl>;</decl_stmt>
      <comment type="line">//se; mm/sec;</comment>
      <if>if<condition>(<expr><name>se</name>&gt;<name>high</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>high</name>=<name>se</name></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then></if>
    <expr_stmt><expr><name>block_index</name> = (<name>block_index</name>+1) &amp; (<name>BLOCK_BUFFER_SIZE</name> - 1)</expr>;</expr_stmt>
  }</block></while>

  <decl_stmt><decl><type><name>float</name></type> <name>g</name><init>=<expr><name>autotemp_min</name>+<name>high</name>*<name>autotemp_factor</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>t</name><init>=<expr><name>g</name></expr></init></decl>;</decl_stmt>
  <if>if<condition>(<expr><name>t</name>&lt;<name>autotemp_min</name></expr>)</condition><then>
    <expr_stmt><expr><name>t</name>=<name>autotemp_min</name></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>t</name>&gt;<name>autotemp_max</name></expr>)</condition><then>
    <expr_stmt><expr><name>t</name>=<name>autotemp_max</name></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr><name>oldt</name>&gt;<name>t</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr><name>t</name>=<name>AUTOTEMP_OLDWEIGHT</name>*<name>oldt</name>+(1-<name>AUTOTEMP_OLDWEIGHT</name>)*<name>t</name></expr>;</expr_stmt>
  }</block></then></if>
  <expr_stmt><expr><name>oldt</name>=<name>t</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>setTargetHotend0</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>check_axes_activity</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>x_active</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>y_active</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>z_active</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>e_active</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>tail_fan_speed</name> <init>= <expr><name>fanSpeed</name></expr></init></decl>;</decl_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>tail_valve_pressure</name> <init>= <expr><name>ValvePressure</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>tail_e_to_p_pressure</name> <init>= <expr><name>EtoPPressure</name></expr></init></decl>;</decl_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>block_t</name> *</type><name>block</name></decl>;</decl_stmt>

  <if>if<condition>(<expr><name>block_buffer_tail</name> != <name>block_buffer_head</name></expr>)</condition><then>
  <block>{
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>block_index</name> <init>= <expr><name>block_buffer_tail</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>tail_fan_speed</name> = <name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>fan_speed</name></expr>;</expr_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
    <expr_stmt><expr><name>tail_valve_pressure</name> = <name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>valve_pressure</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>tail_e_to_p_pressure</name> = <name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name>.<name>e_to_p_pressure</name></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <while>while<condition>(<expr><name>block_index</name> != <name>block_buffer_head</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>block</name> = &amp;<name><name>block_buffer</name><index>[<expr><name>block_index</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if<condition>(<expr><name><name>block</name>-&gt;<name>steps_x</name></name> != 0</expr>)</condition><then> <expr_stmt><expr><name>x_active</name>++</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><name><name>block</name>-&gt;<name>steps_y</name></name> != 0</expr>)</condition><then> <expr_stmt><expr><name>y_active</name>++</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><name><name>block</name>-&gt;<name>steps_z</name></name> != 0</expr>)</condition><then> <expr_stmt><expr><name>z_active</name>++</expr>;</expr_stmt></then></if>
      <if>if<condition>(<expr><name><name>block</name>-&gt;<name>steps_e</name></name> != 0</expr>)</condition><then> <expr_stmt><expr><name>e_active</name>++</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>block_index</name> = (<name>block_index</name>+1) &amp; (<name>BLOCK_BUFFER_SIZE</name> - 1)</expr>;</expr_stmt>
    }</block></while>
  }</block></then></if>
  <if>if<condition>(<expr>(<name>DISABLE_X</name>) &amp;&amp; (<name>x_active</name> == 0)</expr>)</condition><then> <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr>(<name>DISABLE_Y</name>) &amp;&amp; (<name>y_active</name> == 0)</expr>)</condition><then> <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr>(<name>DISABLE_Z</name>) &amp;&amp; (<name>z_active</name> == 0)</expr>)</condition><then> <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if<condition>(<expr>(<name>DISABLE_E</name>) &amp;&amp; (<name>e_active</name> == 0)</expr>)</condition><then>
  <block>{
    <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
  }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>FAN_PIN</name> &gt; -1</expr></cpp:if>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_KICKSTART_TIME</name></cpp:ifdef>
    <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>fan_kick_end</name></decl>;</decl_stmt>
    <if>if <condition>(<expr><name>tail_fan_speed</name></expr>)</condition><then> <block>{
      <if>if <condition>(<expr><name>fan_kick_end</name> == 0</expr>)</condition><then> <block>{
        <comment type="line">// Just starting up fan - run at full power.</comment>
        <expr_stmt><expr><name>fan_kick_end</name> = <call><name>millis</name><argument_list>()</argument_list></call> + <name>FAN_KICKSTART_TIME</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail_fan_speed</name> = 255</expr>;</expr_stmt>
      }</block></then> <else>else <if>if <condition>(<expr><name>fan_kick_end</name> &gt; <call><name>millis</name><argument_list>()</argument_list></call></expr>)</condition><then>
        <comment type="line">// Fan still spinning up.</comment>
        <expr_stmt><expr><name>tail_fan_speed</name> = 255</expr>;</expr_stmt></then></if></else></if>
    }</block></then> <else>else <block>{
      <expr_stmt><expr><name>fan_kick_end</name> = 0</expr>;</expr_stmt>
    }</block></else></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif><comment type="line">//FAN_KICKSTART_TIME</comment>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
  <expr_stmt><expr><name>fanSpeedSoftPwm</name> = <name>tail_fan_speed</name></expr>;</expr_stmt>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr><name>tail_fan_speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif><comment type="line" format="doxygen">//!FAN_SOFT_PWM</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif><comment type="line">//FAN_PIN &gt; -1</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AUTOTEMP</name></cpp:ifdef>
  <expr_stmt><expr><call><name>getHighESpeed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BARICUDA</name></cpp:ifdef>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_1_PIN</name> &gt; -1</expr></cpp:if>
      <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr><name>tail_valve_pressure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_2_PIN</name> &gt; -1</expr></cpp:if>
      <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>,<argument><expr><name>tail_e_to_p_pressure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<decl_stmt><decl><type><name>float</name></type> <name>junction_deviation</name> <init>= <expr>0.1</expr></init></decl>;</decl_stmt>
<comment type="line">// Add a new linear movement to the buffer. steps_x, _y and _z is the absolute position in </comment>
<comment type="line">// mm. Microseconds specify how many microseconds the move should take to perform. To aid acceleration</comment>
<comment type="line">// calculation the caller must also provide the physical length of the line in millimeters.</comment>

<comment type="line">// -----------------Undeciplined Annotation---------------------------</comment>
<comment type="line">// #ifdef ENABLE_AUTO_BED_LEVELING</comment>
<comment type="line">// void plan_buffer_line(float x, float y, float z, const float &amp;e, float feed_rate, const uint8_t &amp;extruder)</comment>
<comment type="line">// #else</comment>
<comment type="line">// void plan_buffer_line(const float &amp;x, const float &amp;y, const float &amp;z, const float &amp;e, float feed_rate, const uint8_t &amp;extruder)</comment>
<comment type="line">// #endif  //ENABLE_AUTO_BED_LEVELING</comment>
<comment type="line">// {</comment>
<comment type="line">// / Calculate the buffer head after we push this byte</comment>
<comment type="line">//   int next_buffer_head = next_block_index(block_buffer_head);</comment>

<comment type="line">//   // If the buffer is full: good! That means we are well ahead of the robot. </comment>
<comment type="line">//   // Rest here until there is room in the buffer.</comment>
<comment type="line">//   while(block_buffer_tail == next_buffer_head)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     manage_heater(); </comment>
<comment type="line">//     manage_inactivity(); </comment>
<comment type="line">//     lcd_update();</comment>
<comment type="line">//   }</comment>



<comment type="line">// #ifdef ENABLE_AUTO_BED_LEVELING</comment>
<comment type="line">//   apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</comment>
<comment type="line">// #endif // ENABLE_AUTO_BED_LEVELING</comment>

<comment type="line">//   // The target position of the tool in absolute steps</comment>
<comment type="line">//   // Calculate target position in absolute steps</comment>
<comment type="line">//   //this should be done after the wait, because otherwise a M92 code within the gcode disrupts this calculation somehow</comment>
<comment type="line">//   long target[4];</comment>
<comment type="line">//   target[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);</comment>
<comment type="line">//   target[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);</comment>
<comment type="line">//   target[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     </comment>
<comment type="line">//   target[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);</comment>

<comment type="line">//   #ifdef PREVENT_DANGEROUS_EXTRUDE</comment>
<comment type="line">//   if(target[E_AXIS]!=position[E_AXIS])</comment>
<comment type="line">//   {</comment>
<comment type="line">//     if(degHotend(active_extruder)&lt;extrude_min_temp)</comment>
<comment type="line">//     {</comment>
<comment type="line">//       position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part</comment>
<comment type="line">//       SERIAL_ECHO_START;</comment>
<comment type="line">//       SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);</comment>
<comment type="line">//     }</comment>
    
<comment type="line">//     #ifdef PREVENT_LENGTHY_EXTRUDE</comment>
<comment type="line">//     if(labs(target[E_AXIS]-position[E_AXIS])&gt;axis_steps_per_unit[E_AXIS]*EXTRUDE_MAXLENGTH)</comment>
<comment type="line">//     {</comment>
<comment type="line">//       position[E_AXIS]=target[E_AXIS]; //behave as if the move really took place, but ignore E part</comment>
<comment type="line">//       SERIAL_ECHO_START;</comment>
<comment type="line">//       SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);</comment>
<comment type="line">//     }</comment>
<comment type="line">//     #endif</comment>
<comment type="line">//   }</comment>
<comment type="line">//   #endif</comment>

<comment type="line">//   // Prepare to set up new block</comment>
<comment type="line">//   block_t *block = &amp;block_buffer[block_buffer_head];</comment>

<comment type="line">//   // Mark block as not busy (Not executed by the stepper interrupt)</comment>
<comment type="line">//   block-&gt;busy = false;</comment>

<comment type="line">//   // Number of steps for each axis</comment>
<comment type="line">// #ifndef COREXY</comment>
<comment type="line">// // default non-h-bot planning</comment>
<comment type="line">// block-&gt;steps_x = labs(target[X_AXIS]-position[X_AXIS]);</comment>
<comment type="line">// block-&gt;steps_y = labs(target[Y_AXIS]-position[Y_AXIS]);</comment>
<comment type="line">// #else</comment>
<comment type="line">// // corexy planning</comment>
<comment type="line">// // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html</comment>
<comment type="line">// block-&gt;steps_x = labs((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]));</comment>
<comment type="line">// block-&gt;steps_y = labs((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]));</comment>
<comment type="line">// #endif</comment>
<comment type="line">//   block-&gt;steps_z = labs(target[Z_AXIS]-position[Z_AXIS]);</comment>
<comment type="line">//   block-&gt;steps_e = labs(target[E_AXIS]-position[E_AXIS]);</comment>
<comment type="line">//   block-&gt;steps_e *= volumetric_multiplier[active_extruder];</comment>
<comment type="line">//   block-&gt;steps_e *= extrudemultiply;</comment>
<comment type="line">//   block-&gt;steps_e /= 100;</comment>
<comment type="line">//   block-&gt;step_event_count = max(block-&gt;steps_x, max(block-&gt;steps_y, max(block-&gt;steps_z, block-&gt;steps_e)));</comment>

<comment type="line">//   // Bail if this is a zero-length block</comment>
<comment type="line">//   if (block-&gt;step_event_count &lt;= dropsegments)</comment>
<comment type="line">//   { </comment>
<comment type="line">//     return; </comment>
<comment type="line">//   }</comment>

<comment type="line">//   block-&gt;fan_speed = fanSpeed;</comment>
<comment type="line">//   #ifdef BARICUDA</comment>
<comment type="line">//   block-&gt;valve_pressure = ValvePressure;</comment>
<comment type="line">//   block-&gt;e_to_p_pressure = EtoPPressure;</comment>
<comment type="line">//   #endif</comment>

<comment type="line">//   // Compute direction bits for this block </comment>
<comment type="line">//   block-&gt;direction_bits = 0;</comment>
<comment type="line">// #ifndef COREXY</comment>
<comment type="line">//   if (target[X_AXIS] &lt; position[X_AXIS])</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;direction_bits |= (1&lt;&lt;X_AXIS); </comment>
<comment type="line">//   }</comment>
<comment type="line">//   if (target[Y_AXIS] &lt; position[Y_AXIS])</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;direction_bits |= (1&lt;&lt;Y_AXIS); </comment>
<comment type="line">//   }</comment>
<comment type="line">// #else</comment>
<comment type="line">//   if ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]) &lt; 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;direction_bits |= (1&lt;&lt;X_AXIS); </comment>
<comment type="line">//   }</comment>
<comment type="line">//   if ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]) &lt; 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;direction_bits |= (1&lt;&lt;Y_AXIS); </comment>
<comment type="line">//   }</comment>
<comment type="line">// #endif</comment>
<comment type="line">//   if (target[Z_AXIS] &lt; position[Z_AXIS])</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;direction_bits |= (1&lt;&lt;Z_AXIS); </comment>
<comment type="line">//   }</comment>
<comment type="line">//   if (target[E_AXIS] &lt; position[E_AXIS])</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;direction_bits |= (1&lt;&lt;E_AXIS); </comment>
<comment type="line">//   }</comment>

<comment type="line">//   block-&gt;active_extruder = extruder;</comment>

<comment type="line">//   //enable active axes</comment>
<comment type="line">//   #ifdef COREXY</comment>
<comment type="line">//   if((block-&gt;steps_x != 0) || (block-&gt;steps_y != 0))</comment>
<comment type="line">//   {</comment>
<comment type="line">//     enable_x();</comment>
<comment type="line">//     enable_y();</comment>
<comment type="line">//   }</comment>
<comment type="line">//   #else</comment>
<comment type="line">//   if(block-&gt;steps_x != 0) enable_x();</comment>
<comment type="line">//   if(block-&gt;steps_y != 0) enable_y();</comment>
<comment type="line">//   #endif</comment>
<comment type="line">// #ifndef Z_LATE_ENABLE</comment>
<comment type="line">//   if(block-&gt;steps_z != 0) enable_z();</comment>
<comment type="line">// #endif</comment>

<comment type="line">//   // Enable extruder(s)</comment>
<comment type="line">//   if(block-&gt;steps_e != 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     if (DISABLE_INACTIVE_EXTRUDER) //enable only selected extruder</comment>
<comment type="line">//     {</comment>

<comment type="line">//       if(g_uc_extruder_last_move[0] &gt; 0) g_uc_extruder_last_move[0]--;</comment>
<comment type="line">//       if(g_uc_extruder_last_move[1] &gt; 0) g_uc_extruder_last_move[1]--;</comment>
<comment type="line">//       if(g_uc_extruder_last_move[2] &gt; 0) g_uc_extruder_last_move[2]--;</comment>
      
<comment type="line">//       switch(extruder)</comment>
<comment type="line">//       {</comment>
<comment type="line">//         case 0: </comment>
<comment type="line">//           enable_e0(); </comment>
<comment type="line">//           g_uc_extruder_last_move[0] = BLOCK_BUFFER_SIZE*2;</comment>
          
<comment type="line">//           if(g_uc_extruder_last_move[1] == 0) disable_e1(); </comment>
<comment type="line">//           if(g_uc_extruder_last_move[2] == 0) disable_e2(); </comment>
<comment type="line">//         break;</comment>
<comment type="line">//         case 1:</comment>
<comment type="line">//           enable_e1(); </comment>
<comment type="line">//           g_uc_extruder_last_move[1] = BLOCK_BUFFER_SIZE*2;</comment>
          
<comment type="line">//           if(g_uc_extruder_last_move[0] == 0) disable_e0(); </comment>
<comment type="line">//           if(g_uc_extruder_last_move[2] == 0) disable_e2(); </comment>
<comment type="line">//         break;</comment>
<comment type="line">//         case 2:</comment>
<comment type="line">//           enable_e2(); </comment>
<comment type="line">//           g_uc_extruder_last_move[2] = BLOCK_BUFFER_SIZE*2;</comment>
          
<comment type="line">//           if(g_uc_extruder_last_move[0] == 0) disable_e0(); </comment>
<comment type="line">//           if(g_uc_extruder_last_move[1] == 0) disable_e1(); </comment>
<comment type="line">//         break;        </comment>
<comment type="line">//       }</comment>
<comment type="line">//     }</comment>
<comment type="line">//     else //enable all</comment>
<comment type="line">//     {</comment>
<comment type="line">//       enable_e0();</comment>
<comment type="line">//       enable_e1();</comment>
<comment type="line">//       enable_e2(); </comment>
<comment type="line">//     }</comment>
<comment type="line">//   }</comment>

<comment type="line">//   if (block-&gt;steps_e == 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     if(feed_rate&lt;mintravelfeedrate) feed_rate=mintravelfeedrate;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   else</comment>
<comment type="line">//   {</comment>
<comment type="line">//     if(feed_rate&lt;minimumfeedrate) feed_rate=minimumfeedrate;</comment>
<comment type="line">//   } </comment>

<comment type="line">//   float delta_mm[4];</comment>
<comment type="line">//   #ifndef COREXY</comment>
<comment type="line">//     delta_mm[X_AXIS] = (target[X_AXIS]-position[X_AXIS])/axis_steps_per_unit[X_AXIS];</comment>
<comment type="line">//     delta_mm[Y_AXIS] = (target[Y_AXIS]-position[Y_AXIS])/axis_steps_per_unit[Y_AXIS];</comment>
<comment type="line">//   #else</comment>
<comment type="line">//     delta_mm[X_AXIS] = ((target[X_AXIS]-position[X_AXIS]) + (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[X_AXIS];</comment>
<comment type="line">//     delta_mm[Y_AXIS] = ((target[X_AXIS]-position[X_AXIS]) - (target[Y_AXIS]-position[Y_AXIS]))/axis_steps_per_unit[Y_AXIS];</comment>
<comment type="line">//   #endif</comment>
<comment type="line">//   delta_mm[Z_AXIS] = (target[Z_AXIS]-position[Z_AXIS])/axis_steps_per_unit[Z_AXIS];</comment>
<comment type="line">//   delta_mm[E_AXIS] = ((target[E_AXIS]-position[E_AXIS])/axis_steps_per_unit[E_AXIS])*volumetric_multiplier[active_extruder]*extrudemultiply/100.0;</comment>
<comment type="line">//   if ( block-&gt;steps_x &lt;=dropsegments &amp;&amp; block-&gt;steps_y &lt;=dropsegments &amp;&amp; block-&gt;steps_z &lt;=dropsegments )</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;millimeters = fabs(delta_mm[E_AXIS]);</comment>
<comment type="line">//   } </comment>
<comment type="line">//   else</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;millimeters = sqrt(square(delta_mm[X_AXIS]) + square(delta_mm[Y_AXIS]) + square(delta_mm[Z_AXIS]));</comment>
<comment type="line">//   }</comment>
<comment type="line">//   float inverse_millimeters = 1.0/block-&gt;millimeters;  // Inverse millimeters to remove multiple divides </comment>

<comment type="line">//     // Calculate speed in mm/second for each axis. No divide by zero due to previous checks.</comment>
<comment type="line">//   float inverse_second = feed_rate * inverse_millimeters;</comment>

<comment type="line">//   int moves_queued=(block_buffer_head-block_buffer_tail + BLOCK_BUFFER_SIZE) &amp; (BLOCK_BUFFER_SIZE - 1);</comment>

<comment type="line">//   // slow down when de buffer starts to empty, rather than wait at the corner for a buffer refill</comment>
<comment type="line">// #ifdef OLD_SLOWDOWN</comment>
<comment type="line">//   if(moves_queued &lt; (BLOCK_BUFFER_SIZE * 0.5) &amp;&amp; moves_queued &gt; 1)</comment>
<comment type="line">//     feed_rate = feed_rate*moves_queued / (BLOCK_BUFFER_SIZE * 0.5); </comment>
<comment type="line">// #endif</comment>

<comment type="line">// #ifdef SLOWDOWN</comment>
<comment type="line">//   //  segment time im micro seconds</comment>
<comment type="line">//   unsigned long segment_time = lround(1000000.0/inverse_second);</comment>
<comment type="line">//   if ((moves_queued &gt; 1) &amp;&amp; (moves_queued &lt; (BLOCK_BUFFER_SIZE * 0.5)))</comment>
<comment type="line">//   {</comment>
<comment type="line">//     if (segment_time &lt; minsegmenttime)</comment>
<comment type="line">//     { // buffer is draining, add extra time.  The amount of time added increases if the buffer is still emptied more.</comment>
<comment type="line">//       inverse_second=1000000.0/(segment_time+lround(2*(minsegmenttime-segment_time)/moves_queued));</comment>
<comment type="line">//       #ifdef XY_FREQUENCY_LIMIT</comment>
<comment type="line">//          segment_time = lround(1000000.0/inverse_second);</comment>
<comment type="line">//       #endif</comment>
<comment type="line">//     }</comment>
<comment type="line">//   }</comment>
<comment type="line">// #endif</comment>
<comment type="line">//   //  END OF SLOW DOWN SECTION    </comment>


<comment type="line">//   block-&gt;nominal_speed = block-&gt;millimeters * inverse_second; // (mm/sec) Always &gt; 0</comment>
<comment type="line">//   block-&gt;nominal_rate = ceil(block-&gt;step_event_count * inverse_second); // (step/sec) Always &gt; 0</comment>

<comment type="line">// #ifdef FILAMENT_SENSOR</comment>
<comment type="line">//   //FMM update ring buffer used for delay with filament measurements</comment>
  
  
<comment type="line">//     if((extruder==FILAMENT_SENSOR_EXTRUDER_NUM) &amp;&amp; (delay_index2 &gt; -1))  //only for extruder with filament sensor and if ring buffer is initialized</comment>
<comment type="line">//       {</comment>
<comment type="line">//     delay_dist = delay_dist + delta_mm[E_AXIS];  //increment counter with next move in e axis</comment>
  
<comment type="line">//     while (delay_dist &gt;= (10*(MAX_MEASUREMENT_DELAY+1)))  //check if counter is over max buffer size in mm</comment>
<comment type="line">//           delay_dist = delay_dist - 10*(MAX_MEASUREMENT_DELAY+1);  //loop around the buffer</comment>
<comment type="line">//     while (delay_dist&lt;0)</comment>
<comment type="line">//         delay_dist = delay_dist + 10*(MAX_MEASUREMENT_DELAY+1); //loop around the buffer</comment>
      
<comment type="line">//     delay_index1=delay_dist/10.0;  //calculate index</comment>
    
<comment type="line">//     //ensure the number is within range of the array after converting from floating point</comment>
<comment type="line">//     if(delay_index1&lt;0)</comment>
<comment type="line">//       delay_index1=0;</comment>
<comment type="line">//     else if (delay_index1&gt;MAX_MEASUREMENT_DELAY)</comment>
<comment type="line">//       delay_index1=MAX_MEASUREMENT_DELAY;</comment>
      
<comment type="line">//     if(delay_index1 != delay_index2)  //moved index</comment>
<comment type="line">//       {</comment>
<comment type="line">//       meas_sample=widthFil_to_size_ratio()-100;  //subtract off 100 to reduce magnitude - to store in a signed char</comment>
<comment type="line">//       }</comment>
<comment type="line">//     while( delay_index1 != delay_index2)</comment>
<comment type="line">//       {</comment>
<comment type="line">//       delay_index2 = delay_index2 + 1;</comment>
<comment type="line">//     if(delay_index2&gt;MAX_MEASUREMENT_DELAY)</comment>
<comment type="line">//           delay_index2=delay_index2-(MAX_MEASUREMENT_DELAY+1);  //loop around buffer when incrementing</comment>
<comment type="line">//       if(delay_index2&lt;0)</comment>
<comment type="line">//       delay_index2=0;</comment>
<comment type="line">//       else if (delay_index2&gt;MAX_MEASUREMENT_DELAY)</comment>
<comment type="line">//       delay_index2=MAX_MEASUREMENT_DELAY;  </comment>
      
<comment type="line">//       measurement_delay[delay_index2]=meas_sample;</comment>
<comment type="line">//       }</comment>
      
    
<comment type="line">//       }</comment>
<comment type="line">// #endif</comment>


<comment type="line">//   // Calculate and limit speed in mm/sec for each axis</comment>
<comment type="line">//   float current_speed[4];</comment>
<comment type="line">//   float speed_factor = 1.0; //factor &lt;=1 do decrease speed</comment>
<comment type="line">//   for(int i=0; i &lt; 4; i++)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     current_speed[i] = delta_mm[i] * inverse_second;</comment>
<comment type="line">//     if(fabs(current_speed[i]) &gt; max_feedrate[i])</comment>
<comment type="line">//       speed_factor = min(speed_factor, max_feedrate[i] / fabs(current_speed[i]));</comment>
<comment type="line">//   }</comment>

<comment type="line">//   // Max segement time in us.</comment>
<comment type="line">// #ifdef XY_FREQUENCY_LIMIT</comment>
<comment type="line">// #define MAX_FREQ_TIME (1000000.0/XY_FREQUENCY_LIMIT)</comment>
<comment type="line">//   // Check and limit the xy direction change frequency</comment>
<comment type="line">//   unsigned char direction_change = block-&gt;direction_bits ^ old_direction_bits;</comment>
<comment type="line">//   old_direction_bits = block-&gt;direction_bits;</comment>
<comment type="line">//   segment_time = lround((float)segment_time / speed_factor);</comment>
  
<comment type="line">//   if((direction_change &amp; (1&lt;&lt;X_AXIS)) == 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     x_segment_time[0] += segment_time;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   else</comment>
<comment type="line">//   {</comment>
<comment type="line">//     x_segment_time[2] = x_segment_time[1];</comment>
<comment type="line">//     x_segment_time[1] = x_segment_time[0];</comment>
<comment type="line">//     x_segment_time[0] = segment_time;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   if((direction_change &amp; (1&lt;&lt;Y_AXIS)) == 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     y_segment_time[0] += segment_time;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   else</comment>
<comment type="line">//   {</comment>
<comment type="line">//     y_segment_time[2] = y_segment_time[1];</comment>
<comment type="line">//     y_segment_time[1] = y_segment_time[0];</comment>
<comment type="line">//     y_segment_time[0] = segment_time;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   long max_x_segment_time = max(x_segment_time[0], max(x_segment_time[1], x_segment_time[2]));</comment>
<comment type="line">//   long max_y_segment_time = max(y_segment_time[0], max(y_segment_time[1], y_segment_time[2]));</comment>
<comment type="line">//   long min_xy_segment_time =min(max_x_segment_time, max_y_segment_time);</comment>
<comment type="line">//   if(min_xy_segment_time &lt; MAX_FREQ_TIME)</comment>
<comment type="line">//     speed_factor = min(speed_factor, speed_factor * (float)min_xy_segment_time / (float)MAX_FREQ_TIME);</comment>
<comment type="line">// #endif</comment>

<comment type="line">//   // Correct the speed  </comment>
<comment type="line">//   if( speed_factor &lt; 1.0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     for(unsigned char i=0; i &lt; 4; i++)</comment>
<comment type="line">//     {</comment>
<comment type="line">//       current_speed[i] *= speed_factor;</comment>
<comment type="line">//     }</comment>
<comment type="line">//     block-&gt;nominal_speed *= speed_factor;</comment>
<comment type="line">//     block-&gt;nominal_rate *= speed_factor;</comment>
<comment type="line">//   }</comment>

<comment type="line">//   // Compute and limit the acceleration rate for the trapezoid generator.  </comment>
<comment type="line">//   float steps_per_mm = block-&gt;step_event_count/block-&gt;millimeters;</comment>
<comment type="line">//   if(block-&gt;steps_x == 0 &amp;&amp; block-&gt;steps_y == 0 &amp;&amp; block-&gt;steps_z == 0)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;acceleration_st = ceil(retract_acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</comment>
<comment type="line">//   }</comment>
<comment type="line">//   else</comment>
<comment type="line">//   {</comment>
<comment type="line">//     block-&gt;acceleration_st = ceil(acceleration * steps_per_mm); // convert to: acceleration steps/sec^2</comment>
<comment type="line">//     // Limit acceleration per axis</comment>
<comment type="line">//     if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_x / (float)block-&gt;step_event_count) &gt; axis_steps_per_sqr_second[X_AXIS])</comment>
<comment type="line">//       block-&gt;acceleration_st = axis_steps_per_sqr_second[X_AXIS];</comment>
<comment type="line">//     if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_y / (float)block-&gt;step_event_count) &gt; axis_steps_per_sqr_second[Y_AXIS])</comment>
<comment type="line">//       block-&gt;acceleration_st = axis_steps_per_sqr_second[Y_AXIS];</comment>
<comment type="line">//     if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_e / (float)block-&gt;step_event_count) &gt; axis_steps_per_sqr_second[E_AXIS])</comment>
<comment type="line">//       block-&gt;acceleration_st = axis_steps_per_sqr_second[E_AXIS];</comment>
<comment type="line">//     if(((float)block-&gt;acceleration_st * (float)block-&gt;steps_z / (float)block-&gt;step_event_count ) &gt; axis_steps_per_sqr_second[Z_AXIS])</comment>
<comment type="line">//       block-&gt;acceleration_st = axis_steps_per_sqr_second[Z_AXIS];</comment>
<comment type="line">//   }</comment>
<comment type="line">//   block-&gt;acceleration = block-&gt;acceleration_st / steps_per_mm;</comment>
<comment type="line">//   block-&gt;acceleration_rate = (long)((float)block-&gt;acceleration_st * (16777216.0 / (F_CPU / 8.0)));</comment>

<comment type="line">// #if 0  // Use old jerk for now</comment>
<comment type="line">//   // Compute path unit vector</comment>
<comment type="line">//   double unit_vec[3];</comment>

<comment type="line">//   unit_vec[X_AXIS] = delta_mm[X_AXIS]*inverse_millimeters;</comment>
<comment type="line">//   unit_vec[Y_AXIS] = delta_mm[Y_AXIS]*inverse_millimeters;</comment>
<comment type="line">//   unit_vec[Z_AXIS] = delta_mm[Z_AXIS]*inverse_millimeters;</comment>

<comment type="line">//   // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.</comment>
<comment type="line">//   // Let a circle be tangent to both previous and current path line segments, where the junction</comment>
<comment type="line">//   // deviation is defined as the distance from the junction to the closest edge of the circle,</comment>
<comment type="line">//   // colinear with the circle center. The circular segment joining the two paths represents the</comment>
<comment type="line">//   // path of centripetal acceleration. Solve for max velocity based on max acceleration about the</comment>
<comment type="line">//   // radius of the circle, defined indirectly by junction deviation. This may be also viewed as</comment>
<comment type="line">//   // path width or max_jerk in the previous grbl version. This approach does not actually deviate</comment>
<comment type="line">//   // from path, but used as a robust way to compute cornering speeds, as it takes into account the</comment>
<comment type="line">//   // nonlinearities of both the junction angle and junction velocity.</comment>
<comment type="line">//   double vmax_junction = MINIMUM_PLANNER_SPEED; // Set default max junction speed</comment>

<comment type="line">//   // Skip first block or when previous_nominal_speed is used as a flag for homing and offset cycles.</comment>
<comment type="line">//   if ((block_buffer_head != block_buffer_tail) &amp;&amp; (previous_nominal_speed &gt; 0.0)) {</comment>
<comment type="line">//     // Compute cosine of angle between previous and current path. (prev_unit_vec is negative)</comment>
<comment type="line">//     // NOTE: Max junction velocity is computed without sin() or acos() by trig half angle identity.</comment>
<comment type="line">//     double cos_theta = - previous_unit_vec[X_AXIS] * unit_vec[X_AXIS]</comment>
<comment type="line">//       - previous_unit_vec[Y_AXIS] * unit_vec[Y_AXIS]</comment>
<comment type="line">//       - previous_unit_vec[Z_AXIS] * unit_vec[Z_AXIS] ;</comment>

<comment type="line">//     // Skip and use default max junction speed for 0 degree acute junction.</comment>
<comment type="line">//     if (cos_theta &lt; 0.95) {</comment>
<comment type="line">//       vmax_junction = min(previous_nominal_speed,block-&gt;nominal_speed);</comment>
<comment type="line">//       // Skip and avoid divide by zero for straight junctions at 180 degrees. Limit to min() of nominal speeds.</comment>
<comment type="line">//       if (cos_theta &gt; -0.95) {</comment>
<comment type="line">//         // Compute maximum junction velocity based on maximum acceleration and junction deviation</comment>
<comment type="line">//         double sin_theta_d2 = sqrt(0.5*(1.0-cos_theta)); // Trig half angle identity. Always positive.</comment>
<comment type="line">//         vmax_junction = min(vmax_junction,</comment>
<comment type="line">//         sqrt(block-&gt;acceleration * junction_deviation * sin_theta_d2/(1.0-sin_theta_d2)) );</comment>
<comment type="line">//       }</comment>
<comment type="line">//     }</comment>
<comment type="line">//   }</comment>
<comment type="line">// #endif</comment>
<comment type="line">//   // Start with a safe speed</comment>
<comment type="line">//   float vmax_junction = max_xy_jerk/2; </comment>
<comment type="line">//   float vmax_junction_factor = 1.0; </comment>
<comment type="line">//   if(fabs(current_speed[Z_AXIS]) &gt; max_z_jerk/2) </comment>
<comment type="line">//     vmax_junction = min(vmax_junction, max_z_jerk/2);</comment>
<comment type="line">//   if(fabs(current_speed[E_AXIS]) &gt; max_e_jerk/2) </comment>
<comment type="line">//     vmax_junction = min(vmax_junction, max_e_jerk/2);</comment>
<comment type="line">//   vmax_junction = min(vmax_junction, block-&gt;nominal_speed);</comment>
<comment type="line">//   float safe_speed = vmax_junction;</comment>

<comment type="line">//   if ((moves_queued &gt; 1) &amp;&amp; (previous_nominal_speed &gt; 0.0001)) {</comment>
<comment type="line">//     float jerk = sqrt(pow((current_speed[X_AXIS]-previous_speed[X_AXIS]), 2)+pow((current_speed[Y_AXIS]-previous_speed[Y_AXIS]), 2));</comment>
<comment type="line">//     //    if((fabs(previous_speed[X_AXIS]) &gt; 0.0001) || (fabs(previous_speed[Y_AXIS]) &gt; 0.0001)) {</comment>
<comment type="line">//     vmax_junction = block-&gt;nominal_speed;</comment>
<comment type="line">//     //    }</comment>
<comment type="line">//     if (jerk &gt; max_xy_jerk) {</comment>
<comment type="line">//       vmax_junction_factor = (max_xy_jerk/jerk);</comment>
<comment type="line">//     } </comment>
<comment type="line">//     if(fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS]) &gt; max_z_jerk) {</comment>
<comment type="line">//       vmax_junction_factor= min(vmax_junction_factor, (max_z_jerk/fabs(current_speed[Z_AXIS] - previous_speed[Z_AXIS])));</comment>
<comment type="line">//     } </comment>
<comment type="line">//     if(fabs(current_speed[E_AXIS] - previous_speed[E_AXIS]) &gt; max_e_jerk) {</comment>
<comment type="line">//       vmax_junction_factor = min(vmax_junction_factor, (max_e_jerk/fabs(current_speed[E_AXIS] - previous_speed[E_AXIS])));</comment>
<comment type="line">//     } </comment>
<comment type="line">//     vmax_junction = min(previous_nominal_speed, vmax_junction * vmax_junction_factor); // Limit speed to max previous speed</comment>
<comment type="line">//   }</comment>
<comment type="line">//   block-&gt;max_entry_speed = vmax_junction;</comment>

<comment type="line">//   // Initialize block entry speed. Compute based on deceleration to user-defined MINIMUM_PLANNER_SPEED.</comment>
<comment type="line">//   double v_allowable = max_allowable_speed(-block-&gt;acceleration,MINIMUM_PLANNER_SPEED,block-&gt;millimeters);</comment>
<comment type="line">//   block-&gt;entry_speed = min(vmax_junction, v_allowable);</comment>

<comment type="line">//   // Initialize planner efficiency flags</comment>
<comment type="line">//   // Set flag if block will always reach maximum junction speed regardless of entry/exit speeds.</comment>
<comment type="line">//   // If a block can de/ac-celerate from nominal speed to zero within the length of the block, then</comment>
<comment type="line">//   // the current block and next block junction speeds are guaranteed to always be at their maximum</comment>
<comment type="line">//   // junction speeds in deceleration and acceleration, respectively. This is due to how the current</comment>
<comment type="line">//   // block nominal speed limits both the current and next maximum junction speeds. Hence, in both</comment>
<comment type="line">//   // the reverse and forward planners, the corresponding block junction speed will always be at the</comment>
<comment type="line">//   // the maximum junction speed and may always be ignored for any speed reduction checks.</comment>
<comment type="line">//   if (block-&gt;nominal_speed &lt;= v_allowable) { </comment>
<comment type="line">//     block-&gt;nominal_length_flag = true; </comment>
<comment type="line">//   }</comment>
<comment type="line">//   else { </comment>
<comment type="line">//     block-&gt;nominal_length_flag = false; </comment>
<comment type="line">//   }</comment>
<comment type="line">//   block-&gt;recalculate_flag = true; // Always calculate trapezoid for new block</comment>

<comment type="line">//   // Update previous path unit_vector and nominal speed</comment>
<comment type="line">//   memcpy(previous_speed, current_speed, sizeof(previous_speed)); // previous_speed[] = current_speed[]</comment>
<comment type="line">//   previous_nominal_speed = block-&gt;nominal_speed;</comment>


<comment type="line">// #ifdef ADVANCE</comment>
<comment type="line">//   // Calculate advance rate</comment>
<comment type="line">//   if((block-&gt;steps_e == 0) || (block-&gt;steps_x == 0 &amp;&amp; block-&gt;steps_y == 0 &amp;&amp; block-&gt;steps_z == 0)) {</comment>
<comment type="line">//     block-&gt;advance_rate = 0;</comment>
<comment type="line">//     block-&gt;advance = 0;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   else {</comment>
<comment type="line">//     long acc_dist = estimate_acceleration_distance(0, block-&gt;nominal_rate, block-&gt;acceleration_st);</comment>
<comment type="line">//     float advance = (STEPS_PER_CUBIC_MM_E * EXTRUDER_ADVANCE_K) * </comment>
<comment type="line">//       (current_speed[E_AXIS] * current_speed[E_AXIS] * EXTRUTION_AREA * EXTRUTION_AREA)*256;</comment>
<comment type="line">//     block-&gt;advance = advance;</comment>
<comment type="line">//     if(acc_dist == 0) {</comment>
<comment type="line">//       block-&gt;advance_rate = 0;</comment>
<comment type="line">//     } </comment>
<comment type="line">//     else {</comment>
<comment type="line">//       block-&gt;advance_rate = advance / (float)acc_dist;</comment>
<comment type="line">//     }</comment>
<comment type="line">//   }</comment>
<comment type="line">//   /*</comment>
<comment type="line">//     SERIAL_ECHO_START;</comment>
<comment type="line">//    SERIAL_ECHOPGM("advance :");</comment>
<comment type="line">//    SERIAL_ECHO(block-&gt;advance/256.0);</comment>
<comment type="line">//    SERIAL_ECHOPGM("advance rate :");</comment>
<comment type="line">//    SERIAL_ECHOLN(block-&gt;advance_rate/256.0);</comment>
<comment type="line">//    */</comment>
<comment type="line">// #endif // ADVANCE</comment>

<comment type="line">//   calculate_trapezoid_for_block(block, block-&gt;entry_speed/block-&gt;nominal_speed,</comment>
<comment type="line">//   safe_speed/block-&gt;nominal_speed);</comment>

<comment type="line">//   // Move buffer head</comment>
<comment type="line">//   block_buffer_head = next_buffer_head;</comment>

<comment type="line">//   // Update position</comment>
<comment type="line">//   memcpy(position, target, sizeof(target)); // position[] = target[]</comment>

<comment type="line">//   planner_recalculate();</comment>

<comment type="line">//   st_wake_up();</comment>
<comment type="line">// }</comment>



<comment type="line">//   </comment>
  <comment type="line">// -----------------Undeciplined Annotation---------------------------</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_AUTO_BED_LEVELING</name></cpp:ifdef>
<function><type><name>vector_3</name></type> <name>plan_get_position</name><parameter_list>()</parameter_list> <block>{
  <decl_stmt><decl><type><name>vector_3</name></type> <name>position</name> <init>= <expr><call><name>vector_3</name><argument_list>(<argument><expr><call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>X_AXIS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Y_AXIS</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>st_get_position_mm</name><argument_list>(<argument><expr><name>Z_AXIS</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="line">//position.debug("in plan_get position");</comment>
  <comment type="line">//plan_bed_level_matrix.debug("in plan_get bed_level");</comment>
  <decl_stmt><decl><type><name>matrix_3x3</name></type> <name>inverse</name> <init>= <expr><call><name><name>matrix_3x3</name>::<name>transpose</name></name><argument_list>(<argument><expr><name>plan_bed_level_matrix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="line">//inverse.debug("in plan_get inverse");</comment>
  <expr_stmt><expr><call><name><name>position</name>.<name>apply_rotation</name></name><argument_list>(<argument><expr><name>inverse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="line">//position.debug("after rotation");</comment>

  <return>return <expr><name>position</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// ENABLE_AUTO_BED_LEVELING</comment>
<comment type="line">// -----------------Undeciplined Annotation---------------------------</comment>
<comment type="line">// #ifdef ENABLE_AUTO_BED_LEVELING</comment>
<comment type="line">// void plan_set_position(float x, float y, float z, const float &amp;e)</comment>
<comment type="line">// {</comment>
<comment type="line">//   apply_rotation_xyz(plan_bed_level_matrix, x, y, z);</comment>
<comment type="line">// #else</comment>
<comment type="line">// void plan_set_position(const float &amp;x, const float &amp;y, const float &amp;z, const float &amp;e)</comment>
<comment type="line">// {</comment>
<comment type="line">// #endif // ENABLE_AUTO_BED_LEVELING</comment>

<comment type="line">//   position[X_AXIS] = lround(x*axis_steps_per_unit[X_AXIS]);</comment>
<comment type="line">//   position[Y_AXIS] = lround(y*axis_steps_per_unit[Y_AXIS]);</comment>
<comment type="line">//   position[Z_AXIS] = lround(z*axis_steps_per_unit[Z_AXIS]);     </comment>
<comment type="line">//   position[E_AXIS] = lround(e*axis_steps_per_unit[E_AXIS]);  </comment>
<comment type="line">//   st_set_position(position[X_AXIS], position[Y_AXIS], position[Z_AXIS], position[E_AXIS]);</comment>
<comment type="line">//   previous_nominal_speed = 0.0; // Resets planner junction speeds. Assumes start from rest.</comment>
<comment type="line">//   previous_speed[0] = 0.0;</comment>
<comment type="line">//   previous_speed[1] = 0.0;</comment>
<comment type="line">//   previous_speed[2] = 0.0;</comment>
<comment type="line">//   previous_speed[3] = 0.0;</comment>
<comment type="line">// }</comment>
<comment type="line">// -----------------Undeciplined Annotation---------------------------</comment>
<function><type><name>void</name></type> <name>plan_set_e_position</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>float</name> &amp;</type><name>e</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name> = <call><name>lround</name><argument_list>(<argument><expr><name>e</name>*<name><name>axis_steps_per_unit</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  
  <expr_stmt><expr><call><name>st_set_e_position</name><argument_list>(<argument><expr><name><name>position</name><index>[<expr><name>E_AXIS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>uint8_t</name></type> <name>movesplanned</name><parameter_list>()</parameter_list>
<block>{
  <return>return <expr>(<name>block_buffer_head</name>-<name>block_buffer_tail</name> + <name>BLOCK_BUFFER_SIZE</name>) &amp; (<name>BLOCK_BUFFER_SIZE</name> - 1)</expr>;</return>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PREVENT_DANGEROUS_EXTRUDE</name></cpp:ifdef>
<function><type><name>void</name></type> <name>set_extrude_min_temp</name><parameter_list>(<param><decl><type><name>float</name></type> <name>temp</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>extrude_min_temp</name>=<name>temp</name></expr>;</expr_stmt>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Calculate the steps/s^2 acceleration rates, based on the mm/s^s</comment>
<function><type><name>void</name></type> <name>reset_acceleration_rates</name><parameter_list>()</parameter_list>
<block>{
  <for>for(<init><decl><type><name>int8_t</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init> <condition><expr><name>i</name> &lt; <name>NUM_AXIS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
        <expr_stmt><expr><name><name>axis_steps_per_sqr_second</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>max_acceleration_units_per_sq_second</name><index>[<expr><name>i</name></expr>]</index></name> * <name><name>axis_steps_per_unit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
        }</block></for>
}</block></function>

</unit>
