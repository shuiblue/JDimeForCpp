<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C++" filename="testcpp/Marlin/temperature/2way/1/A.cpp"><comment type="block">/*
  temperature.c - temperature control
  Part of Marlin
  
 Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>

<comment type="block">/*
 This firmware is a mashup between Sprinter and grbl.
  (https://github.com/kliment/Sprinter)
  (https://github.com/simen/grbl/tree)
 
 It has preliminary support for Matthew Roberts advance algorithm 
    http://reprap.org/pipermail/reprap-dev/2011-May/003323.html

 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Marlin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ultralcd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"temperature.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"watchdog.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Sd2PinMap.h"</cpp:file></cpp:include>


<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================public variables============================</comment>
<comment type="line">//===========================================================================</comment>
<decl_stmt><decl><type><name>int</name></type> <name><name>target_temperature</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>target_temperature_bed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>current_temperature_raw</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name><name>current_temperature</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0.0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>current_temperature_bed_raw</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>current_temperature_bed</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_SENSOR_1_AS_REDUNDANT</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>redundant_temperature_raw</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>redundant_temperature</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name>Kp</name><init>=<expr><name>DEFAULT_Kp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>Ki</name><init>=<expr>(<name>DEFAULT_Ki</name>*<name>PID_dT</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>Kd</name><init>=<expr>(<name>DEFAULT_Kd</name>/<name>PID_dT</name>)</expr></init></decl>;</decl_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PID_ADD_EXTRUSION_RATE</name></cpp:ifdef>
    <decl_stmt><decl><type><name>float</name></type> <name>Kc</name><init>=<expr><name>DEFAULT_Kc</name></expr></init></decl>;</decl_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
  <decl_stmt><decl><type><name>float</name></type> <name>bedKp</name><init>=<expr><name>DEFAULT_bedKp</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>bedKi</name><init>=<expr>(<name>DEFAULT_bedKi</name>*<name>PID_dT</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>bedKd</name><init>=<expr>(<name>DEFAULT_bedKd</name>/<name>PID_dT</name>)</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMPBED</comment>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>fanSpeedSoftPwm</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>soft_pwm_bed</name></decl>;</decl_stmt>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BABYSTEPPING</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name><name>babystepsTodo</name><index>[<expr>3</expr>]</index></name><init>=<expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
  <decl_stmt><decl><type><name>int</name></type> <name>current_raw_filwidth</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="line">//Holds measured filament diameter - one extruder only</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================private variables============================</comment>
<comment type="line">//===========================================================================</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>temp_meas_ready</name> <init>= <expr>false</expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
  <comment type="line">//static cannot be external:</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>temp_iState</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>temp_dState</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>pTerm</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>iTerm</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>dTerm</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
  <comment type="line">//int output;</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>pid_error</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>temp_iState_min</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name><name>temp_iState_max</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
  <comment type="line">// static float pid_input[EXTRUDERS];</comment>
  <comment type="line">// static float pid_output[EXTRUDERS];</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>pid_reset</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
  <comment type="line">//static cannot be external:</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>temp_iState_bed</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>temp_dState_bed</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>pTerm_bed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>iTerm_bed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>dTerm_bed</name></decl>;</decl_stmt>
  <comment type="line">//int output;</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>pid_error_bed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>temp_iState_min_bed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>float</name></type> <name>temp_iState_max_bed</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">//PIDTEMPBED</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type>  <name>previous_millis_bed_heater</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMPBED</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>soft_pwm</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>soft_pwm_fan</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1) || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1) || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1)</expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>extruder_autofan_last_check</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 3</expr></cpp:if>
  <cpp:error># <cpp:directive>error</cpp:directive> Unsupported number of extruders</cpp:error>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:elif>
  <cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_BY_EXTRUDERS</name><parameter_list>(<param><type><name>v1</name></type></param>, <param><type><name>v2</name></type></param>, <param><type><name>v3</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ v1, v2, v3 }</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:elif>
  <cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_BY_EXTRUDERS</name><parameter_list>(<param><type><name>v1</name></type></param>, <param><type><name>v2</name></type></param>, <param><type><name>v3</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ v1, v2 }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>ARRAY_BY_EXTRUDERS</name><parameter_list>(<param><type><name>v1</name></type></param>, <param><type><name>v2</name></type></param>, <param><type><name>v3</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ v1 }</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="line">// Init min and max temp with extreme values to prevent false errors during startup</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>minttemp_raw</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>( <argument><expr><name>HEATER_0_RAW_LO_TEMP</name></expr></argument> , <argument><expr><name>HEATER_1_RAW_LO_TEMP</name></expr></argument> , <argument><expr><name>HEATER_2_RAW_LO_TEMP</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>maxttemp_raw</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>( <argument><expr><name>HEATER_0_RAW_HI_TEMP</name></expr></argument> , <argument><expr><name>HEATER_1_RAW_HI_TEMP</name></expr></argument> , <argument><expr><name>HEATER_2_RAW_HI_TEMP</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>minttemp</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>( <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>maxttemp</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>( <argument><expr>16383</expr></argument>, <argument><expr>16383</expr></argument>, <argument><expr>16383</expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<comment type="line">//static int bed_minttemp_raw = HEATER_BED_RAW_LO_TEMP; /* No bed mintemp error implemented?!? */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BED_MAXTEMP</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>bed_maxttemp_raw</name> <init>= <expr><name>HEATER_BED_RAW_HI_TEMP</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_SENSOR_1_AS_REDUNDANT</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>void</name> *</type><name><name>heater_ttbl_map</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr>(<name>void</name> *)<name>HEATER_0_TEMPTABLE</name></expr>, <expr>(<name>void</name> *)<name>HEATER_1_TEMPTABLE</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name><name>heater_ttbllen_map</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{ <expr><name>HEATER_0_TEMPTABLE_LEN</name></expr>, <expr><name>HEATER_1_TEMPTABLE_LEN</name></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><specifier>static</specifier> <name>void</name> *</type><name><name>heater_ttbl_map</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>( <argument><expr>(<name>void</name> *)<name>HEATER_0_TEMPTABLE</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>HEATER_1_TEMPTABLE</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>HEATER_2_TEMPTABLE</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>uint8_t</name></type> <name><name>heater_ttbllen_map</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>( <argument><expr><name>HEATER_0_TEMPTABLE_LEN</name></expr></argument>, <argument><expr><name>HEATER_1_TEMPTABLE_LEN</name></expr></argument>, <argument><expr><name>HEATER_2_TEMPTABLE_LEN</name></expr></argument> )</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>analog2temp</name><parameter_list>(<param><decl><type><name>int</name></type> <name>raw</name></decl></param>, <param><decl><type><name>uint8_t</name></type> <name>e</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>analog2tempBed</name><parameter_list>(<param><decl><type><name>int</name></type> <name>raw</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updateTemperaturesFromRawValues</name><parameter_list>()</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WATCH_TEMP_PERIOD</name></cpp:ifdef>
<decl_stmt><decl><type><name>int</name></type> <name><name>watch_start_temp</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name><name>watchmillis</name><index>[<expr><name>EXTRUDERS</name></expr>]</index></name> <init>= <expr><call><name>ARRAY_BY_EXTRUDERS</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//WATCH_TEMP_PERIOD</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SOFT_PWM_SCALE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOFT_PWM_SCALE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>meas_shift_index</name></decl>;</decl_stmt>  <comment type="line">//used to point to a delayed sample in buffer for filament width sensor</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="line">//===========================================================================</comment>
<comment type="line">//=============================   functions      ============================</comment>
<comment type="line">//===========================================================================</comment>

<function><type><name>void</name></type> <name>PID_autotune</name><parameter_list>(<param><decl><type><name>float</name></type> <name>temp</name></decl></param>, <param><decl><type><name>int</name></type> <name>extruder</name></decl></param>, <param><decl><type><name>int</name></type> <name>ncycles</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>float</name></type> <name>input</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>cycles</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>heating</name> <init>= <expr>true</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>temp_millis</name> <init>= <expr><call><name>millis</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t1</name><init>=<expr><name>temp_millis</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t2</name><init>=<expr><name>temp_millis</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>t_high</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>long</name></type> <name>t_low</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>long</name></type> <name>bias</name></decl>, <decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>Ku</name></decl>, <decl><type ref="prev"/><name>Tu</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>Kp</name></decl>, <decl><type ref="prev"/><name>Ki</name></decl>, <decl><type ref="prev"/><name>Kd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>max</name> <init>= <expr>0</expr></init>, <name>min</name> <init>= <expr>10000</expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1) || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1) || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1)</expr></cpp:if>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>extruder_autofan_last_check</name> <init>= <expr><call><name>millis</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if>if <condition>(<expr>(<name>extruder</name> &gt;= <name>EXTRUDERS</name>)
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>TEMP_BED_PIN</name> &lt;= -1)</expr></cpp:if>
       ||(<name>extruder</name> &lt; 0)</expr>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       )</condition><then><block>{
          <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"PID Autotune failed. Bad extruder number."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return;</return>
        }</block></then></if>
	
  <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"PID Autotune start"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="line">// switch off all heaters.</comment>

  <if>if <condition>(<expr><name>extruder</name>&lt;0</expr>)</condition><then>
  <block>{
     <expr_stmt><expr><name>soft_pwm_bed</name> = (<name>MAX_BED_POWER</name>)/2</expr>;</expr_stmt>
     <expr_stmt><expr><name>bias</name> = <name>d</name> = (<name>MAX_BED_POWER</name>)/2</expr>;</expr_stmt>
   }</block></then>
   <else>else
   <block>{
     <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr><name>extruder</name></expr>]</index></name> = (<name>PID_MAX</name>)/2</expr>;</expr_stmt>
     <expr_stmt><expr><name>bias</name> = <name>d</name> = (<name>PID_MAX</name>)/2</expr>;</expr_stmt>
  }</block></else></if>




 <for>for(<init>;</init><condition>;</condition><incr/>) <block>{

    <if>if<condition>(<expr><name>temp_meas_ready</name> == true</expr>)</condition><then> <block>{ <comment type="line">// temp sample ready</comment>
      <expr_stmt><expr><call><name>updateTemperaturesFromRawValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>input</name> = (<name>extruder</name>&lt;0)?<name>current_temperature_bed</name>:<name><name>current_temperature</name><index>[<expr><name>extruder</name></expr>]</index></name></expr>;</expr_stmt>

      <expr_stmt><expr><name>max</name>=<call><name>max</name><argument_list>(<argument><expr><name>max</name></expr></argument>,<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>min</name>=<call><name>min</name><argument_list>(<argument><expr><name>min</name></expr></argument>,<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1) || \
          (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1) || \
          (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1)</expr></cpp:if>
      <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>extruder_autofan_last_check</name> &gt; 2500</expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>checkExtruderAutoFans</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>extruder_autofan_last_check</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <if>if<condition>(<expr><name>heating</name> == true &amp;&amp; <name>input</name> &gt; <name>temp</name></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>t2</name> &gt; 5000</expr>)</condition><then> <block>{ 
          <expr_stmt><expr><name>heating</name>=false</expr>;</expr_stmt>
          <if>if <condition>(<expr><name>extruder</name>&lt;0</expr>)</condition><then>
            <expr_stmt><expr><name>soft_pwm_bed</name> = (<name>bias</name> - <name>d</name>) &gt;&gt; 1</expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr><name>extruder</name></expr>]</index></name> = (<name>bias</name> - <name>d</name>) &gt;&gt; 1</expr>;</expr_stmt></else></if>
          <expr_stmt><expr><name>t1</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>t_high</name>=<name>t1</name> - <name>t2</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>max</name>=<name>temp</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if>
      <if>if<condition>(<expr><name>heating</name> == false &amp;&amp; <name>input</name> &lt; <name>temp</name></expr>)</condition><then> <block>{
        <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>t1</name> &gt; 5000</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>heating</name>=true</expr>;</expr_stmt>
          <expr_stmt><expr><name>t2</name>=<call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>t_low</name>=<name>t2</name> - <name>t1</name></expr>;</expr_stmt>
          <if>if<condition>(<expr><name>cycles</name> &gt; 0</expr>)</condition><then> <block>{
            <expr_stmt><expr><name>bias</name> += (<name>d</name>*(<name>t_high</name> - <name>t_low</name>))/(<name>t_low</name> + <name>t_high</name>)</expr>;</expr_stmt>
            <expr_stmt><expr><name>bias</name> = <call><name>constrain</name><argument_list>(<argument><expr><name>bias</name></expr></argument>, <argument><expr>20</expr></argument> ,<argument><expr>(<name>extruder</name>&lt;0?(<name>MAX_BED_POWER</name>):(<name>PID_MAX</name>))-20</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>(<expr><name>bias</name> &gt; (<name>extruder</name>&lt;0?(<name>MAX_BED_POWER</name>):(<name>PID_MAX</name>))/2</expr>)</condition><then> <expr_stmt><expr><name>d</name> = (<name>extruder</name>&lt;0?(<name>MAX_BED_POWER</name>):(<name>PID_MAX</name>)) - 1 - <name>bias</name></expr>;</expr_stmt></then>
            <else>else <expr_stmt><expr><name>d</name> = <name>bias</name></expr>;</expr_stmt></else></if>

            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" bias: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>bias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" d: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" min: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" max: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <if>if<condition>(<expr><name>cycles</name> &gt; 2</expr>)</condition><then> <block>{
              <expr_stmt><expr><name>Ku</name> = (4.0*<name>d</name>)/(3.14159*(<name>max</name>-<name>min</name>)/2.0)</expr>;</expr_stmt>
              <expr_stmt><expr><name>Tu</name> = (<call>(<name>float</name>)<argument_list>(<argument><expr><name>t_low</name> + <name>t_high</name></expr></argument>)</argument_list></call>/1000.0)</expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Ku: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>Ku</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Tu: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>Tu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>Kp</name> = 0.6*<name>Ku</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>Ki</name> = 2*<name>Kp</name>/<name>Tu</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>Kd</name> = <name>Kp</name>*<name>Tu</name>/8</expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>" Classic PID "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Kp: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>Kp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Ki: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>Ki</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" Kd: "</expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>Kd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="block">/*
              Kp = 0.33*Ku;
              Ki = Kp/Tu;
              Kd = Kp*Tu/3;
              SERIAL_PROTOCOLLNPGM(" Some overshoot ");
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              Kp = 0.2*Ku;
              Ki = 2*Kp/Tu;
              Kd = Kp*Tu/3;
              SERIAL_PROTOCOLLNPGM(" No overshoot ");
              SERIAL_PROTOCOLPGM(" Kp: "); SERIAL_PROTOCOLLN(Kp);
              SERIAL_PROTOCOLPGM(" Ki: "); SERIAL_PROTOCOLLN(Ki);
              SERIAL_PROTOCOLPGM(" Kd: "); SERIAL_PROTOCOLLN(Kd);
              */</comment>
            }</block></then></if>
          }</block></then></if>
          <if>if <condition>(<expr><name>extruder</name>&lt;0</expr>)</condition><then>
            <expr_stmt><expr><name>soft_pwm_bed</name> = (<name>bias</name> + <name>d</name>) &gt;&gt; 1</expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr><name>extruder</name></expr>]</index></name> = (<name>bias</name> + <name>d</name>) &gt;&gt; 1</expr>;</expr_stmt></else></if>
          <expr_stmt><expr><name>cycles</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><name>min</name>=<name>temp</name></expr>;</expr_stmt>
        }</block></then></if>
      }</block></then></if> 
    }</block></then></if>
    <if>if<condition>(<expr><name>input</name> &gt; (<name>temp</name> + 20)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>"PID Autotune failed! Temperature too high"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>temp_millis</name> &gt; 2000</expr>)</condition><then> <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>p</name></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>extruder</name>&lt;0</expr>)</condition><then><block>{
        <expr_stmt><expr><name>p</name>=<name>soft_pwm_bed</name></expr>;</expr_stmt>       
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"ok B:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then><else>else<block>{
        <expr_stmt><expr><name>p</name>=<name><name>soft_pwm</name><index>[<expr><name>extruder</name></expr>]</index></name></expr>;</expr_stmt>       
        <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>"ok T:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
			
      <expr_stmt><expr><call><name>SERIAL_PROTOCOL</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLPGM</name><argument_list>(<argument><expr>" @:"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>       

      <expr_stmt><expr><name>temp_millis</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
    <if>if<condition>(<expr>((<call><name>millis</name><argument_list>()</argument_list></call> - <name>t1</name>) + (<call><name>millis</name><argument_list>()</argument_list></call> - <name>t2</name>)) &gt; (10L*60L*1000L*2L)</expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>"PID Autotune failed! timeout"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <if>if<condition>(<expr><name>cycles</name> &gt; <name>ncycles</name></expr>)</condition><then> <block>{
      <expr_stmt><expr><call><name>SERIAL_PROTOCOLLNPGM</name><argument_list>(<argument><expr>"PID Autotune finished! Put the last Kp, Ki and Kd constants from above into Configuration.h"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>
    <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></for>
}</block></function>

<function><type><name>void</name></type> <name>updatePID</name><parameter_list>()</parameter_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
  <for>for(<init><decl><type><name>int</name></type> <name>e</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>e</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>) <block>{ 
     <expr_stmt><expr><name><name>temp_iState_max</name><index>[<expr><name>e</name></expr>]</index></name> = <name>PID_INTEGRAL_DRIVE_MAX</name> / <name>Ki</name></expr>;</expr_stmt>  
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
  <expr_stmt><expr><name>temp_iState_max_bed</name> = <name>PID_INTEGRAL_DRIVE_MAX</name> / <name>bedKi</name></expr>;</expr_stmt>  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
  
<function><type><name>int</name></type> <name>getHeaterPower</name><parameter_list>(<param><decl><type><name>int</name></type> <name>heater</name></decl></param>)</parameter_list> <block>{
	<if>if <condition>(<expr><name>heater</name>&lt;0</expr>)</condition><then>
		<return>return <expr><name>soft_pwm_bed</name></expr>;</return></then></if>
  <return>return <expr><name><name>soft_pwm</name><index>[<expr><name>heater</name></expr>]</index></name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1) || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1) || \
    (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1)</expr></cpp:if>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>FAN_PIN</name> &gt; -1</expr></cpp:if>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDER_0_AUTO_FAN_PIN</name> == <name>FAN_PIN</name></expr></cpp:if> 
       <cpp:error>#<cpp:directive>error</cpp:directive> "You cannot set EXTRUDER_0_AUTO_FAN_PIN equal to FAN_PIN"</cpp:error>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDER_1_AUTO_FAN_PIN</name> == <name>FAN_PIN</name></expr></cpp:if> 
       <cpp:error>#<cpp:directive>error</cpp:directive> "You cannot set EXTRUDER_1_AUTO_FAN_PIN equal to FAN_PIN"</cpp:error>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDER_2_AUTO_FAN_PIN</name> == <name>FAN_PIN</name></expr></cpp:if> 
       <cpp:error>#<cpp:directive>error</cpp:directive> "You cannot set EXTRUDER_2_AUTO_FAN_PIN equal to FAN_PIN"</cpp:error>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>void</name></type> <name>setExtruderAutoFanState</name><parameter_list>(<param><decl><type><name>int</name></type> <name>pin</name></decl></param>, <param><decl><type><name>bool</name></type> <name>state</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>newFanSpeed</name> <init>= <expr>(<name>state</name> != 0) ? <name>EXTRUDER_AUTO_FAN_SPEED</name> : 0</expr></init></decl>;</decl_stmt>
  <comment type="line">// this idiom allows both digital and PWM fan outputs (see M42 handling).</comment>
  <expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>pin</name></expr></argument>, <argument><expr><name>OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>pin</name></expr></argument>, <argument><expr><name>newFanSpeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>analogWrite</name><argument_list>(<argument><expr><name>pin</name></expr></argument>, <argument><expr><name>newFanSpeed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type> <name>checkExtruderAutoFans</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>fanState</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="line">// which fan pins need to be turned on?      </comment>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1</expr></cpp:if>
    <if>if <condition>(<expr><name><name>current_temperature</name><index>[<expr>0</expr>]</index></name> &gt; <name>EXTRUDER_AUTO_FAN_TEMPERATURE</name></expr>)</condition><then> 
      <expr_stmt><expr><name>fanState</name> |= 1</expr>;</expr_stmt></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1</expr></cpp:if>
    <if>if <condition>(<expr><name><name>current_temperature</name><index>[<expr>1</expr>]</index></name> &gt; <name>EXTRUDER_AUTO_FAN_TEMPERATURE</name></expr>)</condition><then> 
    <block>{
      <if>if <condition>(<expr><name>EXTRUDER_1_AUTO_FAN_PIN</name> == <name>EXTRUDER_0_AUTO_FAN_PIN</name></expr>)</condition><then> 
        <expr_stmt><expr><name>fanState</name> |= 1</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>fanState</name> |= 2</expr>;</expr_stmt></else></if>
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1</expr></cpp:if>
    <if>if <condition>(<expr><name><name>current_temperature</name><index>[<expr>2</expr>]</index></name> &gt; <name>EXTRUDER_AUTO_FAN_TEMPERATURE</name></expr>)</condition><then> 
    <block>{
      <if>if <condition>(<expr><name>EXTRUDER_2_AUTO_FAN_PIN</name> == <name>EXTRUDER_0_AUTO_FAN_PIN</name></expr>)</condition><then> 
        <expr_stmt><expr><name>fanState</name> |= 1</expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name>EXTRUDER_2_AUTO_FAN_PIN</name> == <name>EXTRUDER_1_AUTO_FAN_PIN</name></expr>)</condition><then> 
        <expr_stmt><expr><name>fanState</name> |= 2</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>fanState</name> |= 4</expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="line">// update extruder auto fan states</comment>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><call><name>setExtruderAutoFanState</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>, <argument><expr>(<name>fanState</name> &amp; 1) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1</expr></cpp:if>
    <if>if <condition>(<expr><name>EXTRUDER_1_AUTO_FAN_PIN</name> != <name>EXTRUDER_0_AUTO_FAN_PIN</name></expr>)</condition><then> 
      <expr_stmt><expr><call><name>setExtruderAutoFanState</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>, <argument><expr>(<name>fanState</name> &amp; 2) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1</expr></cpp:if>
    <if>if <condition>(<expr><name>EXTRUDER_2_AUTO_FAN_PIN</name> != <name>EXTRUDER_0_AUTO_FAN_PIN</name> 
        &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> != <name>EXTRUDER_1_AUTO_FAN_PIN</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>setExtruderAutoFanState</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>, <argument><expr>(<name>fanState</name> &amp; 4) != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// any extruder auto fan pins set</comment>

<function><type><name>void</name></type> <name>manage_heater</name><parameter_list>()</parameter_list>
<block>{
  <decl_stmt><decl><type><name>float</name></type> <name>pid_input</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>pid_output</name></decl>;</decl_stmt>

  <if>if<condition>(<expr><name>temp_meas_ready</name> != true</expr>)</condition><then>   <comment type="line">//better readability</comment>
    <return>return;</return></then></if> 

  <expr_stmt><expr><call><name>updateTemperaturesFromRawValues</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <for>for(<init><decl><type><name>int</name></type> <name>e</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>e</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>) 
  <block>{

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>THERMAL_RUNAWAY_PROTECTION_PERIOD</name></expr></argument>)</argument_list></call> &amp;&amp; <name>THERMAL_RUNAWAY_PROTECTION_PERIOD</name> &gt; 0</expr></cpp:if>
    <expr_stmt><expr><call><name>thermal_runaway_protection</name><argument_list>(<argument><expr>&amp;<name><name>thermal_runaway_state_machine</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>thermal_runaway_timer</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>current_temperature</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>target_temperature</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>THERMAL_RUNAWAY_PROTECTION_PERIOD</name></expr></argument>, <argument><expr><name>THERMAL_RUNAWAY_PROTECTION_HYSTERESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
    <expr_stmt><expr><name>pid_input</name> = <name><name>current_temperature</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>

    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PID_OPENLOOP</name></cpp:ifndef>
        <expr_stmt><expr><name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name> = <name><name>target_temperature</name><index>[<expr><name>e</name></expr>]</index></name> - <name>pid_input</name></expr>;</expr_stmt>
        <if>if<condition>(<expr><name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name> &gt; <name>PID_FUNCTIONAL_RANGE</name></expr>)</condition><then> <block>{
          <expr_stmt><expr><name>pid_output</name> = <name>BANG_MAX</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pid_reset</name><index>[<expr><name>e</name></expr>]</index></name> = true</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if<condition>(<expr><name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name> &lt; -<name>PID_FUNCTIONAL_RANGE</name> || <name><name>target_temperature</name><index>[<expr><name>e</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>pid_output</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>pid_reset</name><index>[<expr><name>e</name></expr>]</index></name> = true</expr>;</expr_stmt>
        }</block></then>
        <else>else <block>{
          <if>if<condition>(<expr><name><name>pid_reset</name><index>[<expr><name>e</name></expr>]</index></name> == true</expr>)</condition><then> <block>{
            <expr_stmt><expr><name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name> = 0.0</expr>;</expr_stmt>
            <expr_stmt><expr><name><name>pid_reset</name><index>[<expr><name>e</name></expr>]</index></name> = false</expr>;</expr_stmt>
          }</block></then></if>
          <expr_stmt><expr><name><name>pTerm</name><index>[<expr><name>e</name></expr>]</index></name> = <name>Kp</name> * <name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name> += <name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name> = <call><name>constrain</name><argument_list>(<argument><expr><name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>temp_iState_min</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>temp_iState_max</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>iTerm</name><index>[<expr><name>e</name></expr>]</index></name> = <name>Ki</name> * <name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>

          <comment type="line">//K1 defined in Configuration.h in the PID settings</comment>
          <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>K2</name></cpp:macro> <cpp:value>(1.0-K1)</cpp:value></cpp:define>
          <expr_stmt><expr><name><name>dTerm</name><index>[<expr><name>e</name></expr>]</index></name> = (<name>Kd</name> * (<name>pid_input</name> - <name><name>temp_dState</name><index>[<expr><name>e</name></expr>]</index></name>))*<name>K2</name> + (<name>K1</name> * <name><name>dTerm</name><index>[<expr><name>e</name></expr>]</index></name>)</expr>;</expr_stmt>
          <expr_stmt><expr><name>pid_output</name> = <name><name>pTerm</name><index>[<expr><name>e</name></expr>]</index></name> + <name><name>iTerm</name><index>[<expr><name>e</name></expr>]</index></name> - <name><name>dTerm</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>pid_output</name> &gt; <name>PID_MAX</name></expr>)</condition><then> <block>{
            <if>if <condition>(<expr><name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name> &gt; 0</expr> )</condition><then>  <expr_stmt><expr><name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name> -= <name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt></then></if> <comment type="line">// conditional un-integration</comment>
            <expr_stmt><expr><name>pid_output</name>=<name>PID_MAX</name></expr>;</expr_stmt>
          }</block></then> <else>else <if>if <condition>(<expr><name>pid_output</name> &lt; 0</expr>)</condition><then><block>{
            <if>if <condition>(<expr><name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name> &lt; 0</expr> )</condition><then>  <expr_stmt><expr><name><name>temp_iState</name><index>[<expr><name>e</name></expr>]</index></name> -= <name><name>pid_error</name><index>[<expr><name>e</name></expr>]</index></name></expr>;</expr_stmt></then></if> <comment type="line">// conditional un-integration</comment>
            <expr_stmt><expr><name>pid_output</name>=0</expr>;</expr_stmt>
          }</block></then></if></else></if>
        }</block></else></if></else></if>
        <expr_stmt><expr><name><name>temp_dState</name><index>[<expr><name>e</name></expr>]</index></name> = <name>pid_input</name></expr>;</expr_stmt>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
          <expr_stmt><expr><name>pid_output</name> = <call><name>constrain</name><argument_list>(<argument><expr><name><name>target_temperature</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>PID_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PID_OPENLOOP</comment>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PID_DEBUG</name></cpp:ifdef>
    <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" PID_DEBUG "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>": Input "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>pid_input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" Output "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name>pid_output</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" pTerm "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>pTerm</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" iTerm "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr><name><name>iTerm</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHO</name><argument_list>(<argument><expr>" dTerm "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr><name><name>dTerm</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PID_DEBUG</comment>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="block">/* PID off */</comment>
    <expr_stmt><expr><name>pid_output</name> = 0</expr>;</expr_stmt>
    <if>if<condition>(<expr><name><name>current_temperature</name><index>[<expr><name>e</name></expr>]</index></name> &lt; <name><name>target_temperature</name><index>[<expr><name>e</name></expr>]</index></name></expr>)</condition><then> <block>{
      <expr_stmt><expr><name>pid_output</name> = <name>PID_MAX</name></expr>;</expr_stmt>
    }</block></then></if>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="line">// Check if temperature is within the correct range</comment>
    <if>if<condition>(<expr>(<name><name>current_temperature</name><index>[<expr><name>e</name></expr>]</index></name> &gt; <name><name>minttemp</name><index>[<expr><name>e</name></expr>]</index></name>) &amp;&amp; (<name><name>current_temperature</name><index>[<expr><name>e</name></expr>]</index></name> &lt; <name><name>maxttemp</name><index>[<expr><name>e</name></expr>]</index></name>)</expr>)</condition><then> 
    <block>{
      <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr><name>e</name></expr>]</index></name> = (<name>int</name>)<name>pid_output</name> &gt;&gt; 1</expr>;</expr_stmt>
    }</block></then>
    <else>else <block>{
      <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr><name>e</name></expr>]</index></name> = 0</expr>;</expr_stmt>
    }</block></else></if>

    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WATCH_TEMP_PERIOD</name></cpp:ifdef>
    <if>if<condition>(<expr><name><name>watchmillis</name><index>[<expr><name>e</name></expr>]</index></name> &amp;&amp; <call><name>millis</name><argument_list>()</argument_list></call> - <name><name>watchmillis</name><index>[<expr><name>e</name></expr>]</index></name> &gt; <name>WATCH_TEMP_PERIOD</name></expr>)</condition><then>
    <block>{
        <if>if<condition>(<expr><call><name>degHotend</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> &lt; <name><name>watch_start_temp</name><index>[<expr><name>e</name></expr>]</index></name> + <name>WATCH_TEMP_INCREASE</name></expr>)</condition><then>
        <block>{
            <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>LCD_MESSAGEPGM</name><argument_list>(<argument><expr>"Heating failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>SERIAL_ECHO_START</name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SERIAL_ECHOLN</name><argument_list>(<argument><expr>"Heating failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then><else>else<block>{
            <expr_stmt><expr><name><name>watchmillis</name><index>[<expr><name>e</name></expr>]</index></name> = 0</expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_SENSOR_1_AS_REDUNDANT</name></cpp:ifdef>
      <if>if<condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name><name>current_temperature</name><index>[<expr>0</expr>]</index></name> - <name>redundant_temperature</name></expr></argument>)</argument_list></call> &gt; <name>MAX_REDUNDANT_TEMP_SENSOR_DIFF</name></expr>)</condition><then> <block>{
        <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <if>if<condition>(<expr><call><name>IsStopped</name><argument_list>()</argument_list></call> == false</expr>)</condition><then> <block>{
          <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr>"Extruder switched off. Temperature difference between temp sensors is too high !"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr>"Err: REDUNDANT TEMP ERROR"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
        <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</name></cpp:ifndef>
          <expr_stmt><expr><call><name>Stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></for> <comment type="line">// End extruder for loop</comment>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_0_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_0_AUTO_FAN_PIN</name> &gt; -1) || \
      (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_1_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_1_AUTO_FAN_PIN</name> &gt; -1) || \
      (<call><name>defined</name><argument_list>(<argument><expr><name>EXTRUDER_2_AUTO_FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EXTRUDER_2_AUTO_FAN_PIN</name> &gt; -1)</expr></cpp:if>
  <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>extruder_autofan_last_check</name> &gt; 2500</expr>)</condition><then>  <comment type="line">// only need to check fan state very infrequently</comment>
  <block>{
    <expr_stmt><expr><call><name>checkExtruderAutoFans</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>extruder_autofan_last_check</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>  
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>       
  
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifndef>
  <if>if<condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>previous_millis_bed_heater</name> &lt; <name>BED_CHECK_INTERVAL</name></expr>)</condition><then>
    <return>return;</return></then></if>
  <expr_stmt><expr><name>previous_millis_bed_heater</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_SENSOR_BED</name> != 0</expr></cpp:if>
  
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>THERMAL_RUNAWAY_PROTECTION_BED_PERIOD</name> <name>&amp;&amp;</name> <name>THERMAL_RUNAWAY_PROTECTION_BED_PERIOD</name> <name>&gt;</name> <name>0</name></cpp:ifdef>
      <expr_stmt><expr><call><name>thermal_runaway_protection</name><argument_list>(<argument><expr>&amp;<name>thermal_runaway_bed_state_machine</name></expr></argument>, <argument><expr>&amp;<name>thermal_runaway_bed_timer</name></expr></argument>, <argument><expr><name>current_temperature_bed</name></expr></argument>, <argument><expr><name>target_temperature_bed</name></expr></argument>, <argument><expr>9</expr></argument>, <argument><expr><name>THERMAL_RUNAWAY_PROTECTION_BED_PERIOD</name></expr></argument>, <argument><expr><name>THERMAL_RUNAWAY_PROTECTION_BED_HYSTERESIS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
    <expr_stmt><expr><name>pid_input</name> = <name>current_temperature_bed</name></expr>;</expr_stmt>

    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PID_OPENLOOP</name></cpp:ifndef>
		  <expr_stmt><expr><name>pid_error_bed</name> = <name>target_temperature_bed</name> - <name>pid_input</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>pTerm_bed</name> = <name>bedKp</name> * <name>pid_error_bed</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>temp_iState_bed</name> += <name>pid_error_bed</name></expr>;</expr_stmt>
		  <expr_stmt><expr><name>temp_iState_bed</name> = <call><name>constrain</name><argument_list>(<argument><expr><name>temp_iState_bed</name></expr></argument>, <argument><expr><name>temp_iState_min_bed</name></expr></argument>, <argument><expr><name>temp_iState_max_bed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		  <expr_stmt><expr><name>iTerm_bed</name> = <name>bedKi</name> * <name>temp_iState_bed</name></expr>;</expr_stmt>

		  <comment type="line">//K1 defined in Configuration.h in the PID settings</comment>
		  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>K2</name></cpp:macro> <cpp:value>(1.0-K1)</cpp:value></cpp:define>
		  <expr_stmt><expr><name>dTerm_bed</name>= (<name>bedKd</name> * (<name>pid_input</name> - <name>temp_dState_bed</name>))*<name>K2</name> + (<name>K1</name> * <name>dTerm_bed</name>)</expr>;</expr_stmt>
		  <expr_stmt><expr><name>temp_dState_bed</name> = <name>pid_input</name></expr>;</expr_stmt>

		  <expr_stmt><expr><name>pid_output</name> = <name>pTerm_bed</name> + <name>iTerm_bed</name> - <name>dTerm_bed</name></expr>;</expr_stmt>
          	  <if>if <condition>(<expr><name>pid_output</name> &gt; <name>MAX_BED_POWER</name></expr>)</condition><then> <block>{
            	    <if>if <condition>(<expr><name>pid_error_bed</name> &gt; 0</expr> )</condition><then>  <expr_stmt><expr><name>temp_iState_bed</name> -= <name>pid_error_bed</name></expr>;</expr_stmt></then></if> <comment type="line">// conditional un-integration</comment>
                    <expr_stmt><expr><name>pid_output</name>=<name>MAX_BED_POWER</name></expr>;</expr_stmt>
          	  }</block></then> <else>else <if>if <condition>(<expr><name>pid_output</name> &lt; 0</expr>)</condition><then><block>{
            	    <if>if <condition>(<expr><name>pid_error_bed</name> &lt; 0</expr> )</condition><then>  <expr_stmt><expr><name>temp_iState_bed</name> -= <name>pid_error_bed</name></expr>;</expr_stmt></then></if> <comment type="line">// conditional un-integration</comment>
                    <expr_stmt><expr><name>pid_output</name>=0</expr>;</expr_stmt>
                  }</block></then></if></else></if>

    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
      <expr_stmt><expr><name>pid_output</name> = <call><name>constrain</name><argument_list>(<argument><expr><name>target_temperature_bed</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>MAX_BED_POWER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PID_OPENLOOP</comment>

	  <if>if<condition>(<expr>(<name>current_temperature_bed</name> &gt; <name>BED_MINTEMP</name>) &amp;&amp; (<name>current_temperature_bed</name> &lt; <name>BED_MAXTEMP</name>)</expr>)</condition><then> 
	  <block>{
	    <expr_stmt><expr><name>soft_pwm_bed</name> = (<name>int</name>)<name>pid_output</name> &gt;&gt; 1</expr>;</expr_stmt>
	  }</block></then>
	  <else>else <block>{
	    <expr_stmt><expr><name>soft_pwm_bed</name> = 0</expr>;</expr_stmt>
	  }</block></else></if>

    <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>BED_LIMIT_SWITCHING</name></expr></argument>)</argument_list></call></expr></cpp:elif>
      <comment type="line">// Check if temperature is within the correct range</comment>
      <if>if<condition>(<expr>(<name>current_temperature_bed</name> &gt; <name>BED_MINTEMP</name>) &amp;&amp; (<name>current_temperature_bed</name> &lt; <name>BED_MAXTEMP</name>)</expr>)</condition><then>
      <block>{
        <if>if<condition>(<expr><name>current_temperature_bed</name> &gt;= <name>target_temperature_bed</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>soft_pwm_bed</name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else 
        <block>{
          <expr_stmt><expr><name>soft_pwm_bed</name> = <name>MAX_BED_POWER</name>&gt;&gt;1</expr>;</expr_stmt>
        }</block></else></if>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><name>soft_pwm_bed</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">//#ifdef BED_LIMIT_SWITCHING</comment>
      <comment type="line">// Check if temperature is within the correct band</comment>
      <if>if<condition>(<expr>(<name>current_temperature_bed</name> &gt; <name>BED_MINTEMP</name>) &amp;&amp; (<name>current_temperature_bed</name> &lt; <name>BED_MAXTEMP</name>)</expr>)</condition><then>
      <block>{
        <if>if<condition>(<expr><name>current_temperature_bed</name> &gt; <name>target_temperature_bed</name> + <name>BED_HYSTERESIS</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>soft_pwm_bed</name> = 0</expr>;</expr_stmt>
        }</block></then>
        <else>else <if>if<condition>(<expr><name>current_temperature_bed</name> &lt;= <name>target_temperature_bed</name> - <name>BED_HYSTERESIS</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>soft_pwm_bed</name> = <name>MAX_BED_POWER</name>&gt;&gt;1</expr>;</expr_stmt>
        }</block></then></if></else></if>
      }</block></then>
      <else>else
      <block>{
        <expr_stmt><expr><name>soft_pwm_bed</name> = 0</expr>;</expr_stmt>
        <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<comment type="line">//code for controlling the extruder rate based on the width sensor </comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
  <if>if<condition>(<expr><name>filament_sensor</name></expr>)</condition><then> 
	<block>{
	<expr_stmt><expr><name>meas_shift_index</name>=<name>delay_index1</name>-<name>meas_delay_cm</name></expr>;</expr_stmt>
		  <if>if<condition>(<expr><name>meas_shift_index</name>&lt;0</expr>)</condition><then>
			  <expr_stmt><expr><name>meas_shift_index</name> = <name>meas_shift_index</name> + (<name>MAX_MEASUREMENT_DELAY</name>+1)</expr>;</expr_stmt></then></if>  <comment type="line">//loop around buffer if needed</comment>
		  
		  <comment type="line">//get the delayed info and add 100 to reconstitute to a percent of the nominal filament diameter</comment>
		  <comment type="line">//then square it to get an area</comment>
		  
		  <if>if<condition>(<expr><name>meas_shift_index</name>&lt;0</expr>)</condition><then>
			  <expr_stmt><expr><name>meas_shift_index</name>=0</expr>;</expr_stmt></then>
		  <else>else <if>if <condition>(<expr><name>meas_shift_index</name>&gt;<name>MAX_MEASUREMENT_DELAY</name></expr>)</condition><then>
			  <expr_stmt><expr><name>meas_shift_index</name>=<name>MAX_MEASUREMENT_DELAY</name></expr>;</expr_stmt></then></if></else></if>
		  
		     <expr_stmt><expr><name><name>volumetric_multiplier</name><index>[<expr><name>FILAMENT_SENSOR_EXTRUDER_NUM</name></expr>]</index></name> = <call><name>pow</name><argument_list>(<argument><expr><call>(<name>float</name>)<argument_list>(<argument><expr>100+<name><name>measurement_delay</name><index>[<expr><name>meas_shift_index</name></expr>]</index></name></expr></argument>)</argument_list></call>/100.0</expr></argument>,<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
		     <if>if <condition>(<expr><name><name>volumetric_multiplier</name><index>[<expr><name>FILAMENT_SENSOR_EXTRUDER_NUM</name></expr>]</index></name> &lt;0.01</expr>)</condition><then>
		    	 <expr_stmt><expr><name><name>volumetric_multiplier</name><index>[<expr><name>FILAMENT_SENSOR_EXTRUDER_NUM</name></expr>]</index></name>=0.01</expr>;</expr_stmt></then></if>
	}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PGM_RD_W</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>   <cpp:value>(short)pgm_read_word(&amp;x)</cpp:value></cpp:define>
<comment type="line">// Derived from RepRap FiveD extruder::getTemperature()</comment>
<comment type="line">// For hot end temperature measurement.</comment>
<comment type="line">// static float analog2temp(int raw, uint8_t e) {</comment>
<comment type="line">// #ifdef TEMP_SENSOR_1_AS_REDUNDANT</comment>
<comment type="line">//   if(e &gt; EXTRUDERS)</comment>
<comment type="line">// #else</comment>
<comment type="line">//   if(e &gt;= EXTRUDERS)</comment>
<comment type="line">// #endif</comment>
<comment type="line">//   {</comment>
<comment type="line">//       SERIAL_ERROR_START;</comment>
<comment type="line">//       SERIAL_ERROR((int)e);</comment>
<comment type="line">//       SERIAL_ERRORLNPGM(" - Invalid extruder number !");</comment>
<comment type="line">//       kill();</comment>
<comment type="line">//       return 0.0;</comment>
<comment type="line">//   } </comment>
<comment type="line">//   #ifdef HEATER_0_USES_MAX6675</comment>
<comment type="line">//     if (e == 0)</comment>
<comment type="line">//     {</comment>
<comment type="line">//       return 0.25 * raw;</comment>
<comment type="line">//     }</comment>
<comment type="line">//   #endif</comment>

<comment type="line">//   if(heater_ttbl_map[e] != NULL)</comment>
<comment type="line">//   {</comment>
<comment type="line">//     float celsius = 0;</comment>
<comment type="line">//     uint8_t i;</comment>
<comment type="line">//     short (*tt)[][2] = (short (*)[][2])(heater_ttbl_map[e]);</comment>

<comment type="line">//     for (i=1; i&lt;heater_ttbllen_map[e]; i++)</comment>
<comment type="line">//     {</comment>
<comment type="line">//       if (PGM_RD_W((*tt)[i][0]) &gt; raw)</comment>
<comment type="line">//       {</comment>
<comment type="line">//         celsius = PGM_RD_W((*tt)[i-1][1]) + </comment>
<comment type="line">//           (raw - PGM_RD_W((*tt)[i-1][0])) * </comment>
<comment type="line">//           (float)(PGM_RD_W((*tt)[i][1]) - PGM_RD_W((*tt)[i-1][1])) /</comment>
<comment type="line">//           (float)(PGM_RD_W((*tt)[i][0]) - PGM_RD_W((*tt)[i-1][0]));</comment>
<comment type="line">//         break;</comment>
<comment type="line">//       }</comment>
<comment type="line">//     }</comment>

<comment type="line">//     // Overflow: Set to last value in the table</comment>
<comment type="line">//     if (i == heater_ttbllen_map[e]) celsius = PGM_RD_W((*tt)[i-1][1]);</comment>

<comment type="line">//     return celsius;</comment>
<comment type="line">//   }</comment>
<comment type="line">//   return ((raw * ((5.0 * 100.0) / 1024.0) / OVERSAMPLENR) * TEMP_SENSOR_AD595_GAIN) + TEMP_SENSOR_AD595_OFFSET;</comment>
<comment type="line">// }</comment>

<comment type="line">// Derived from RepRap FiveD extruder::getTemperature()</comment>
<comment type="line">// For bed temperature measurement.</comment>
<function><type><specifier>static</specifier> <name>float</name></type> <name>analog2tempBed</name><parameter_list>(<param><decl><type><name>int</name></type> <name>raw</name></decl></param>)</parameter_list> <block>{
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BED_USES_THERMISTOR</name></cpp:ifdef>
    <decl_stmt><decl><type><name>float</name></type> <name>celsius</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>byte</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for (<init><expr><name>i</name>=1</expr>;</init> <condition><expr><name>i</name>&lt;<name>BEDTEMPTABLE_LEN</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> &gt; <name>raw</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>celsius</name>  = <call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name>-1</expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call> + 
          (<name>raw</name> - <call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name>-1</expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>) * 
          <call>(<name>float</name>)<argument_list>(<argument><expr><call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call> - <call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name>-1</expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> /
          <call>(<name>float</name>)<argument_list>(<argument><expr><call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call> - <call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name>-1</expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <break>break;</break>
      }</block></then></if>
    }</block></for>

    <comment type="line">// Overflow: Set to last value in the table</comment>
    <if>if <condition>(<expr><name>i</name> == <name>BEDTEMPTABLE_LEN</name></expr>)</condition><then> <expr_stmt><expr><name>celsius</name> = <call><name>PGM_RD_W</name><argument_list>(<argument><expr><name><name>BEDTEMPTABLE</name><index>[<expr><name>i</name>-1</expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <return>return <expr><name>celsius</name></expr>;</return>
  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>BED_USES_AD595</name></expr></cpp:elif>
    <return>return <expr>((<name>raw</name> * ((5.0 * 100.0) / 1024.0) / <name>OVERSAMPLENR</name>) * <name>TEMP_SENSOR_AD595_GAIN</name>) + <name>TEMP_SENSOR_AD595_OFFSET</name></expr>;</return>
  <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr>0</expr>;</return>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<comment type="block">/* Called to get the raw values into the the actual temperatures. The raw values are created in interrupt context,
    and this function is called from normal context as it is too slow to run in interrupts and will block the stepper routine otherwise */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateTemperaturesFromRawValues</name><parameter_list>()</parameter_list>
<block>{
    <for>for(<init><decl><type><name>uint8_t</name></type> <name>e</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>e</name>&lt;<name>EXTRUDERS</name></expr>;</condition><incr><expr><name>e</name>++</expr></incr>)
    <block>{
        <expr_stmt><expr><name><name>current_temperature</name><index>[<expr><name>e</name></expr>]</index></name> = <call><name>analog2temp</name><argument_list>(<argument><expr><name><name>current_temperature_raw</name><index>[<expr><name>e</name></expr>]</index></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
    <expr_stmt><expr><name>current_temperature_bed</name> = <call><name>analog2tempBed</name><argument_list>(<argument><expr><name>current_temperature_bed_raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_SENSOR_1_AS_REDUNDANT</name></cpp:ifdef>
      <expr_stmt><expr><name>redundant_temperature</name> = <call><name>analog2temp</name><argument_list>(<argument><expr><name>redundant_temperature_raw</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name> <argument_list>(<argument><expr><name>FILAMENT_SENSOR</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>FILWIDTH_PIN</name> &gt; -1)</expr></cpp:if>    <comment type="line">//check if a sensor is supported </comment>
      <expr_stmt><expr><name>filament_width_meas</name> = <call><name>analog2widthFil</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
    <comment type="line">//Reset the watchdog after we know we have a temperature measurement.</comment>
    <expr_stmt><expr><call><name>watchdog_reset</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>CRITICAL_SECTION_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>temp_meas_ready</name> = false</expr>;</expr_stmt>
    <expr_stmt><expr><name>CRITICAL_SECTION_END</name></expr>;</expr_stmt>
}</block></function>


<comment type="line">// For converting raw Filament Width to milimeters </comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
<function><type><name>float</name></type> <name>analog2widthFil</name><parameter_list>()</parameter_list> <block>{ 
<return>return <expr><name>current_raw_filwidth</name>/16383.0*5.0</expr>;</return> 
<comment type="line">//return current_raw_filwidth; </comment>
}</block></function> 
 
<comment type="line">// For converting raw Filament Width to a ratio </comment>
<function><type><name>int</name></type> <name>widthFil_to_size_ratio</name><parameter_list>()</parameter_list> <block>{ 
 
<decl_stmt><decl><type><name>float</name></type> <name>temp</name></decl>;</decl_stmt> 
      
<expr_stmt><expr><name>temp</name>=<name>filament_width_meas</name></expr>;</expr_stmt>
<if>if<condition>(<expr><name>filament_width_meas</name>&lt;<name>MEASURED_LOWER_LIMIT</name></expr>)</condition><then>
	<expr_stmt><expr><name>temp</name>=<name>filament_width_nominal</name></expr>;</expr_stmt></then>  <comment type="line">//assume sensor cut out</comment>
<else>else <if>if <condition>(<expr><name>filament_width_meas</name>&gt;<name>MEASURED_UPPER_LIMIT</name></expr>)</condition><then>
	<expr_stmt><expr><name>temp</name>= <name>MEASURED_UPPER_LIMIT</name></expr>;</expr_stmt></then></if></else></if>


<return>return<expr>(<name>filament_width_nominal</name>/<name>temp</name>*100)</expr>;</return> 


}</block></function> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<function><type><name>void</name></type> <name>tp_init</name><parameter_list>()</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>MB</name><argument_list>(<argument><expr><name>RUMBA</name></expr></argument>)</argument_list></call> &amp;&amp; ((<name>TEMP_SENSOR_0</name>==-1)||(<name>TEMP_SENSOR_1</name>==-1)||(<name>TEMP_SENSOR_2</name>==-1)||(<name>TEMP_SENSOR_BED</name>==-1))</expr></cpp:if>
  <comment type="line">//disable RUMBA JTAG in case the thermocouple extension is plugged on top of JTAG connector</comment>
  <expr_stmt><expr><name>MCUCR</name>=(1&lt;&lt;<name>JTD</name>)</expr>;</expr_stmt> 
  <expr_stmt><expr><name>MCUCR</name>=(1&lt;&lt;<name>JTD</name>)</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="line">// Finish init of mult extruder arrays </comment>
  <for>for(<init><decl><type><name>int</name></type> <name>e</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>e</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>) <block>{
    <comment type="line">// populate with the first value </comment>
    <expr_stmt><expr><name><name>maxttemp</name><index>[<expr><name>e</name></expr>]</index></name> = <name><name>maxttemp</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
    <expr_stmt><expr><name><name>temp_iState_min</name><index>[<expr><name>e</name></expr>]</index></name> = 0.0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>temp_iState_max</name><index>[<expr><name>e</name></expr>]</index></name> = <name>PID_INTEGRAL_DRIVE_MAX</name> / <name>Ki</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMPBED</name></cpp:ifdef>
    <expr_stmt><expr><name>temp_iState_min_bed</name> = 0.0</expr>;</expr_stmt>
    <expr_stmt><expr><name>temp_iState_max_bed</name> = <name>PID_INTEGRAL_DRIVE_MAX</name> / <name>bedKi</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMPBED</comment>
  }</block></for>

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>HEATER_0_PIN</name> &gt; -1)</expr></cpp:if> 
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>HEATER_1_PIN</name> &gt; -1)</expr></cpp:if> 
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>HEATER_2_PIN</name> &gt; -1)</expr></cpp:if> 
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>HEATER_BED_PIN</name> &gt; -1)</expr></cpp:if> 
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>FAN_PIN</name> &gt; -1)</expr></cpp:if> 
    <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAST_PWM_FAN</name></cpp:ifdef>
    <expr_stmt><expr><call><name>setPwmFrequency</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// No prescaling. Pwm frequency = F_CPU/256/8</comment>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
    <expr_stmt><expr><name>soft_pwm_fan</name> = <name>fanSpeedSoftPwm</name> / 2</expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  

  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATER_0_USES_MAX6675</name></cpp:ifdef>
    <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SDSUPPORT</name></cpp:ifndef>
      <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>SCK_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>SCK_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <expr_stmt><expr><call><name>SET_OUTPUT</name><argument_list>(<argument><expr><name>MOSI_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>MOSI_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
      <expr_stmt><expr><call><name>SET_INPUT</name><argument_list>(<argument><expr><name>MISO_PIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>MISO_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <comment type="block">/* Using pinMode and digitalWrite, as that was the only way I could get it to compile */</comment>
    
    <comment type="line">//Have to toggle SD card CS pin to low first, to enable firmware to talk with SD card</comment>
	<expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>SS_PIN</name></expr></argument>, <argument><expr><name>OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>SS_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>  
	<expr_stmt><expr><call><name>pinMode</name><argument_list>(<argument><expr><name>MAX6675_SS</name></expr></argument>, <argument><expr><name>OUTPUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>digitalWrite</name><argument_list>(<argument><expr><name>MAX6675_SS</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="line">// Set analog inputs</comment>
  <expr_stmt><expr><name>ADCSRA</name> = 1&lt;&lt;<name>ADEN</name> | 1&lt;&lt;<name>ADSC</name> | 1&lt;&lt;<name>ADIF</name> | 0x07</expr>;</expr_stmt>
  <expr_stmt><expr><name>DIDR0</name> = 0</expr>;</expr_stmt>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DIDR2</name></cpp:ifdef>
    <expr_stmt><expr><name>DIDR2</name> = 0</expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_0_PIN</name> &gt; -1)</expr></cpp:if>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_0_PIN</name> &lt; 8</expr></cpp:if>
       <expr_stmt><expr><name>DIDR0</name> |= 1 &lt;&lt; <name>TEMP_0_PIN</name></expr>;</expr_stmt> 
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
       <expr_stmt><expr><name>DIDR2</name> |= 1&lt;&lt;(<name>TEMP_0_PIN</name> - 8)</expr>;</expr_stmt> 
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_1_PIN</name> &gt; -1)</expr></cpp:if>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_1_PIN</name> &lt; 8</expr></cpp:if>
       <expr_stmt><expr><name>DIDR0</name> |= 1&lt;&lt;<name>TEMP_1_PIN</name></expr>;</expr_stmt> 
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
       <expr_stmt><expr><name>DIDR2</name> |= 1&lt;&lt;(<name>TEMP_1_PIN</name> - 8)</expr>;</expr_stmt> 
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_2_PIN</name> &gt; -1)</expr></cpp:if>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_2_PIN</name> &lt; 8</expr></cpp:if>
       <expr_stmt><expr><name>DIDR0</name> |= 1 &lt;&lt; <name>TEMP_2_PIN</name></expr>;</expr_stmt> 
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
       <expr_stmt><expr><name>DIDR2</name> |= 1&lt;&lt;(<name>TEMP_2_PIN</name> - 8)</expr>;</expr_stmt> 
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_BED_PIN</name> &gt; -1)</expr></cpp:if>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_BED_PIN</name> &lt; 8</expr></cpp:if>
       <expr_stmt><expr><name>DIDR0</name> |= 1&lt;&lt;<name>TEMP_BED_PIN</name></expr>;</expr_stmt> 
    <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
       <expr_stmt><expr><name>DIDR2</name> |= 1&lt;&lt;(<name>TEMP_BED_PIN</name> - 8)</expr>;</expr_stmt> 
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="line">//Added for Filament Sensor </comment>
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FILAMENT_SENSOR</name></cpp:ifdef>
   <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILWIDTH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>FILWIDTH_PIN</name> &gt; -1)</expr></cpp:if> 
	<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FILWIDTH_PIN</name> &lt; 8</expr></cpp:if> 
       	   <expr_stmt><expr><name>DIDR0</name> |= 1&lt;&lt;<name>FILWIDTH_PIN</name></expr>;</expr_stmt>  
	<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 
       	   <expr_stmt><expr><name>DIDR2</name> |= 1&lt;&lt;(<name>FILWIDTH_PIN</name> - 8)</expr>;</expr_stmt>  
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="line">// Use timer0 for temperature measurement</comment>
  <comment type="line">// Interleave temperature interrupt with millies interrupt</comment>
  <expr_stmt><expr><name>OCR0B</name> = 128</expr>;</expr_stmt>
  <expr_stmt><expr><name>TIMSK0</name> |= (1&lt;&lt;<name>OCIE0B</name>)</expr>;</expr_stmt>  
  
  <comment type="line">// Wait for temperature measurement to settle</comment>
  <expr_stmt><expr><call><name>delay</name><argument_list>(<argument><expr>250</expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATER_0_MINTEMP</name></cpp:ifdef>
  <expr_stmt><expr><name><name>minttemp</name><index>[<expr>0</expr>]</index></name> = <name>HEATER_0_MINTEMP</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>analog2temp</name><argument_list>(<argument><expr><name><name>minttemp_raw</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &lt; <name>HEATER_0_MINTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_0_RAW_LO_TEMP</name> &lt; <name>HEATER_0_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name><name>minttemp_raw</name><index>[<expr>0</expr>]</index></name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>minttemp_raw</name><index>[<expr>0</expr>]</index></name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MINTEMP</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATER_0_MAXTEMP</name></cpp:ifdef>
  <expr_stmt><expr><name><name>maxttemp</name><index>[<expr>0</expr>]</index></name> = <name>HEATER_0_MAXTEMP</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>analog2temp</name><argument_list>(<argument><expr><name><name>maxttemp_raw</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> &gt; <name>HEATER_0_MAXTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_0_RAW_LO_TEMP</name> &lt; <name>HEATER_0_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name><name>maxttemp_raw</name><index>[<expr>0</expr>]</index></name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>maxttemp_raw</name><index>[<expr>0</expr>]</index></name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MAXTEMP</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>EXTRUDERS</name> &gt; 1) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_MINTEMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>minttemp</name><index>[<expr>1</expr>]</index></name> = <name>HEATER_1_MINTEMP</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>analog2temp</name><argument_list>(<argument><expr><name><name>minttemp_raw</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; <name>HEATER_1_MINTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_1_RAW_LO_TEMP</name> &lt; <name>HEATER_1_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name><name>minttemp_raw</name><index>[<expr>1</expr>]</index></name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>minttemp_raw</name><index>[<expr>1</expr>]</index></name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">// MINTEMP 1</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>EXTRUDERS</name> &gt; 1) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_MAXTEMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>maxttemp</name><index>[<expr>1</expr>]</index></name> = <name>HEATER_1_MAXTEMP</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>analog2temp</name><argument_list>(<argument><expr><name><name>maxttemp_raw</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &gt; <name>HEATER_1_MAXTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_1_RAW_LO_TEMP</name> &lt; <name>HEATER_1_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name><name>maxttemp_raw</name><index>[<expr>1</expr>]</index></name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>maxttemp_raw</name><index>[<expr>1</expr>]</index></name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MAXTEMP 1</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>EXTRUDERS</name> &gt; 2) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_MINTEMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>minttemp</name><index>[<expr>2</expr>]</index></name> = <name>HEATER_2_MINTEMP</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>analog2temp</name><argument_list>(<argument><expr><name><name>minttemp_raw</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; <name>HEATER_2_MINTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_2_RAW_LO_TEMP</name> &lt; <name>HEATER_2_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name><name>minttemp_raw</name><index>[<expr>2</expr>]</index></name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>minttemp_raw</name><index>[<expr>2</expr>]</index></name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MINTEMP 2</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>EXTRUDERS</name> &gt; 2) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_MAXTEMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>maxttemp</name><index>[<expr>2</expr>]</index></name> = <name>HEATER_2_MAXTEMP</name></expr>;</expr_stmt>
  <while>while<condition>(<expr><call><name>analog2temp</name><argument_list>(<argument><expr><name><name>maxttemp_raw</name><index>[<expr>2</expr>]</index></name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &gt; <name>HEATER_2_MAXTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_2_RAW_LO_TEMP</name> &lt; <name>HEATER_2_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name><name>maxttemp_raw</name><index>[<expr>2</expr>]</index></name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name><name>maxttemp_raw</name><index>[<expr>2</expr>]</index></name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//MAXTEMP 2</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BED_MINTEMP</name></cpp:ifdef>
  <comment type="block">/* No bed MINTEMP error implemented?!? */</comment> <comment type="block">/*
  while(analog2tempBed(bed_minttemp_raw) &lt; BED_MINTEMP) {
#if HEATER_BED_RAW_LO_TEMP &lt; HEATER_BED_RAW_HI_TEMP
    bed_minttemp_raw += OVERSAMPLENR;
#else
    bed_minttemp_raw -= OVERSAMPLENR;
#endif
  }
  */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//BED_MINTEMP</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BED_MAXTEMP</name></cpp:ifdef>
  <while>while<condition>(<expr><call><name>analog2tempBed</name><argument_list>(<argument><expr><name>bed_maxttemp_raw</name></expr></argument>)</argument_list></call> &gt; <name>BED_MAXTEMP</name></expr>)</condition> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_BED_RAW_LO_TEMP</name> &lt; <name>HEATER_BED_RAW_HI_TEMP</name></expr></cpp:if>
    <expr_stmt><expr><name>bed_maxttemp_raw</name> -= <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>bed_maxttemp_raw</name> += <name>OVERSAMPLENR</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//BED_MAXTEMP</comment>
}</block></function>

<function><type><name>void</name></type> <name>setWatch</name><parameter_list>()</parameter_list> 
<block>{  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WATCH_TEMP_PERIOD</name></cpp:ifdef>
  <for>for (<init><decl><type><name>int</name></type> <name>e</name> <init>= <expr>0</expr></init></decl>;</init> <condition><expr><name>e</name> &lt; <name>EXTRUDERS</name></expr>;</condition> <incr><expr><name>e</name>++</expr></incr>)
  <block>{
    <if>if<condition>(<expr><call><name>degHotend</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> &lt; <call><name>degTargetHotend</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call> - (<name>WATCH_TEMP_INCREASE</name> * 2)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>watch_start_temp</name><index>[<expr><name>e</name></expr>]</index></name> = <call><name>degHotend</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>watchmillis</name><index>[<expr><name>e</name></expr>]</index></name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if> 
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name> <argument_list>(<argument><expr><name>THERMAL_RUNAWAY_PROTECTION_PERIOD</name></expr></argument>)</argument_list></call> &amp;&amp; <name>THERMAL_RUNAWAY_PROTECTION_PERIOD</name> &gt; 0) || (<call><name>defined</name> <argument_list>(<argument><expr><name>THERMAL_RUNAWAY_PROTECTION_BED_PERIOD</name></expr></argument>)</argument_list></call> &amp;&amp; <name>THERMAL_RUNAWAY_PROTECTION_BED_PERIOD</name> &gt; 0)</expr></cpp:if>
<function><type><name>void</name></type> <name>thermal_runaway_protection</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>state</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>timer</name></decl></param>, <param><decl><type><name>float</name></type> <name>temperature</name></decl></param>, <param><decl><type><name>float</name></type> <name>target_temperature</name></decl></param>, <param><decl><type><name>int</name></type> <name>heater_id</name></decl></param>, <param><decl><type><name>int</name></type> <name>period_seconds</name></decl></param>, <param><decl><type><name>int</name></type> <name>hysteresis_degc</name></decl></param>)</parameter_list>
<block>{
<comment type="block">/*
      SERIAL_ECHO_START;
      SERIAL_ECHO("Thermal Thermal Runaway Running. Heater ID:");
      SERIAL_ECHO(heater_id);
      SERIAL_ECHO(" ;  State:");
      SERIAL_ECHO(*state);
      SERIAL_ECHO(" ;  Timer:");
      SERIAL_ECHO(*timer);
      SERIAL_ECHO(" ;  Temperature:");
      SERIAL_ECHO(temperature);
      SERIAL_ECHO(" ;  Target Temp:");
      SERIAL_ECHO(target_temperature);
      SERIAL_ECHOLN("");    
*/</comment>
  <if>if <condition>(<expr>(<name>target_temperature</name> == 0) || <name>thermal_runaway</name></expr>)</condition><then>
  <block>{
    <expr_stmt><expr>*<name>state</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr>*<name>timer</name> = 0</expr>;</expr_stmt>
    <return>return;</return>
  }</block></then></if>
  <switch>switch <condition>(<expr>*<name>state</name></expr>)</condition>
  <block>{
    <case>case <expr>0</expr>: <comment type="line">// "Heater Inactive" state</comment>
      <if>if <condition>(<expr><name>target_temperature</name> &gt; 0</expr>)</condition><then> <expr_stmt><expr>*<name>state</name> = 1</expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr>1</expr>: <comment type="line">// "First Heating" state</comment>
      <if>if <condition>(<expr><name>temperature</name> &gt;= <name>target_temperature</name></expr>)</condition><then> <expr_stmt><expr>*<name>state</name> = 2</expr>;</expr_stmt></then></if>
      <break>break;</break>
    </case><case>case <expr>2</expr>: <comment type="line">// "Temperature Stable" state</comment>
      <if>if <condition>(<expr><name>temperature</name> &gt;= (<name>target_temperature</name> - <name>hysteresis_degc</name>)</expr>)</condition><then>
      <block>{
        <expr_stmt><expr>*<name>timer</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      }</block></then> 
      <else>else <if>if <condition>( <expr>(<call><name>millis</name><argument_list>()</argument_list></call> - *<name>timer</name>) &gt; ((<name>unsigned</name> <name>long</name>) <name>period_seconds</name>) * 1000</expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr>"Thermal Runaway, system stopped! Heater_ID: "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr>(<name>int</name>)<name>heater_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr>"THERMAL RUNAWAY"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>thermal_runaway</name> = true</expr>;</expr_stmt>
        <while>while<condition>(<expr>1</expr>)</condition>
        <block>{
          <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_x</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_y</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_z</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e0</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e1</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>disable_e2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>manage_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>lcd_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
        }</block></while>
      }</block></then></if></else></if>
      <break>break;</break>
  </case>}</block></switch>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>disable_heater</name><parameter_list>()</parameter_list>
<block>{
  <for>for(<init><decl><type><name>int</name></type> <name>i</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>i</name>&lt;<name>EXTRUDERS</name></expr>;</condition><incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><call><name>setTargetHotend</name><argument_list>(<argument><expr>0</expr></argument>,<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
  <expr_stmt><expr><call><name>setTargetBed</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_0_PIN</name> &gt; -1</expr></cpp:if>
  <expr_stmt><expr><name><name>target_temperature</name><index>[<expr>0</expr>]</index></name>=0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr>0</expr>]</index></name>=0</expr>;</expr_stmt>
   <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_0_PIN</name> &gt; -1</expr></cpp:if>  
     <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
     
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_1_PIN</name> &gt; -1 &amp;&amp; <name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    <expr_stmt><expr><name><name>target_temperature</name><index>[<expr>1</expr>]</index></name>=0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr>1</expr>]</index></name>=0</expr>;</expr_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_1_PIN</name> &gt; -1</expr></cpp:if> 
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      
  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_2_PIN</name> &gt; -1 &amp;&amp; <name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
    <expr_stmt><expr><name><name>target_temperature</name><index>[<expr>2</expr>]</index></name>=0</expr>;</expr_stmt>
    <expr_stmt><expr><name><name>soft_pwm</name><index>[<expr>2</expr>]</index></name>=0</expr>;</expr_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_2_PIN</name> &gt; -1</expr></cpp:if>  
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

  <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>TEMP_BED_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><name>target_temperature_bed</name>=0</expr>;</expr_stmt>
    <expr_stmt><expr><name>soft_pwm_bed</name>=0</expr>;</expr_stmt>
    <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>  
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>,<argument><expr><name>LOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
}</block></function>

<function><type><name>void</name></type> <name>max_temp_error</name><parameter_list>(<param><decl><type><name>uint8_t</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(<expr><call><name>IsStopped</name><argument_list>()</argument_list></call> == false</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr>(<name>int</name>)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr>": Extruder switched off. MAXTEMP triggered !"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr>"Err: MAXTEMP"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>Stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>min_temp_error</name><parameter_list>(<param><decl><type><name>uint8_t</name></type> <name>e</name></decl></param>)</parameter_list> <block>{
  <expr_stmt><expr><call><name>disable_heater</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if<condition>(<expr><call><name>IsStopped</name><argument_list>()</argument_list></call> == false</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLN</name><argument_list>(<argument><expr>(<name>int</name>)<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr>": Extruder switched off. MINTEMP triggered !"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr>"Err: MINTEMP"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>Stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<function><type><name>void</name></type> <name>bed_max_temp_error</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
  <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if<condition>(<expr><call><name>IsStopped</name><argument_list>()</argument_list></call> == false</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>SERIAL_ERROR_START</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SERIAL_ERRORLNPGM</name><argument_list>(<argument><expr>"Temperature heated bed switched off. MAXTEMP triggered !!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>LCD_ALERTMESSAGEPGM</name><argument_list>(<argument><expr>"Err: MAXTEMP BED"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>
  <cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BOGUS_TEMPERATURE_FAILSAFE_OVERRIDE</name></cpp:ifndef>
  <expr_stmt><expr><call><name>Stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATER_0_USES_MAX6675</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX6675_HEAT_INTERVAL</name></cpp:macro> <cpp:value>250</cpp:value></cpp:define>
<decl_stmt><decl><type><name>long</name></type> <name>max6675_previous_millis</name> <init>= <expr><name>MAX6675_HEAT_INTERVAL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max6675_temp</name> <init>= <expr>2000</expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type> <name>read_max6675</name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>millis</name><argument_list>()</argument_list></call> - <name>max6675_previous_millis</name> &lt; <name>MAX6675_HEAT_INTERVAL</name></expr>)</condition><then> 
    <return>return <expr><name>max6675_temp</name></expr>;</return></then></if>
  
  <expr_stmt><expr><name>max6675_previous_millis</name> = <call><name>millis</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>max6675_temp</name> = 0</expr>;</expr_stmt>
    
  <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>PRR</name></cpp:ifdef>
    <expr_stmt><expr><name>PRR</name> &amp;= ~(1&lt;&lt;<name>PRSPI</name>)</expr>;</expr_stmt>
  <cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>defined</name> <name>PRR0</name></expr></cpp:elif>
    <expr_stmt><expr><name>PRR0</name> &amp;= ~(1&lt;&lt;<name>PRSPI</name>)</expr>;</expr_stmt>
  <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>SPCR</name> = (1&lt;&lt;<name>MSTR</name>) | (1&lt;&lt;<name>SPE</name>) | (1&lt;&lt;<name>SPR0</name>)</expr>;</expr_stmt>
  
  <comment type="line">// enable TT_MAX6675</comment>
  <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>MAX6675_SS</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="line">// ensure 100ns delay - a bit extra is fine</comment>
  <asm>asm("nop");</asm><comment type="line">//50ns on 20Mhz, 62.5ns on 16Mhz</comment>
  <asm>asm("nop");</asm><comment type="line">//50ns on 20Mhz, 62.5ns on 16Mhz</comment>
  
  <comment type="line">// read MSB</comment>
  <expr_stmt><expr><name>SPDR</name> = 0</expr>;</expr_stmt>
  <for>for (<init>;</init><condition><expr>(<name>SPSR</name> &amp; (1&lt;&lt;<name>SPIF</name>)) == 0</expr>;</condition><incr/>)<empty_stmt>;</empty_stmt></for>
  <expr_stmt><expr><name>max6675_temp</name> = <name>SPDR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>max6675_temp</name> &lt;&lt;= 8</expr>;</expr_stmt>
  
  <comment type="line">// read LSB</comment>
  <expr_stmt><expr><name>SPDR</name> = 0</expr>;</expr_stmt>
  <for>for (<init>;</init><condition><expr>(<name>SPSR</name> &amp; (1&lt;&lt;<name>SPIF</name>)) == 0</expr>;</condition><incr/>)<empty_stmt>;</empty_stmt></for>
  <expr_stmt><expr><name>max6675_temp</name> |= <name>SPDR</name></expr>;</expr_stmt>
  
  <comment type="line">// disable TT_MAX6675</comment>
  <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>MAX6675_SS</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>max6675_temp</name> &amp; 4</expr>)</condition><then> 
  <block>{
    <comment type="line">// thermocouple open</comment>
    <expr_stmt><expr><name>max6675_temp</name> = 2000</expr>;</expr_stmt>
  }</block></then>
  <else>else 
  <block>{
    <expr_stmt><expr><name>max6675_temp</name> = <name>max6675_temp</name> &gt;&gt; 3</expr>;</expr_stmt>
  }</block></else></if>

  <return>return <expr><name>max6675_temp</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="line">// Timer 0 is shared with millies</comment>
<macro><name>ISR</name><argument_list>(<argument>TIMER0_COMPB_vect</argument>)</argument_list></macro>
<block>{
  <comment type="line">//these variables are only accesible from the ISR, but static, so they don't lose their value</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>temp_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>raw_temp_0_value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>raw_temp_1_value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>raw_temp_2_value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>raw_temp_bed_value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>temp_state</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>pwm_count</name> <init>= <expr>(1 &lt;&lt; <name>SOFT_PWM_SCALE</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>soft_pwm_0</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLOW_PWM_HEATERS</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>slow_pwm_count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_heater_0</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_timer_heater_0</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>EXTRUDERS</name> &gt; 1) || <call><name>defined</name><argument_list>(<argument><expr><name>HEATERS_PARALLEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>soft_pwm_1</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLOW_PWM_HEATERS</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_heater_1</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_timer_heater_1</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>soft_pwm_2</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLOW_PWM_HEATERS</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_heater_2</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_timer_heater_2</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>soft_pwm_b</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SLOW_PWM_HEATERS</name></cpp:ifdef>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_heater_b</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name>state_timer_heater_b</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILWIDTH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp;(<name>FILWIDTH_PIN</name> &gt; -1)</expr></cpp:if>
  <decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>raw_filwidth_value</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>  <comment type="line">//added for filament width sensor</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SLOW_PWM_HEATERS</name></cpp:ifndef>
  <comment type="block">/*
   * standard PWM modulation
   */</comment>
  <if>if<condition>(<expr><name>pwm_count</name> == 0</expr>)</condition><then><block>{
    <expr_stmt><expr><name>soft_pwm_0</name> = <name><name>soft_pwm</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>soft_pwm_0</name> &gt; 0</expr>)</condition><then> <block>{ 
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATERS_PARALLEL</name></cpp:ifdef>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then> <else>else <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    <expr_stmt><expr><name>soft_pwm_1</name> = <name><name>soft_pwm</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>soft_pwm_1</name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
    <expr_stmt><expr><name>soft_pwm_2</name> = <name><name>soft_pwm</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>soft_pwm_2</name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
    <expr_stmt><expr><name>soft_pwm_b</name> = <name>soft_pwm_bed</name></expr>;</expr_stmt>
    <if>if<condition>(<expr><name>soft_pwm_b</name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
    <expr_stmt><expr><name>soft_pwm_fan</name> = <name>fanSpeedSoftPwm</name> / 2</expr>;</expr_stmt>
    <if>if<condition>(<expr><name>soft_pwm_fan</name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  <if>if<condition>(<expr><name>soft_pwm_0</name> &lt; <name>pwm_count</name></expr>)</condition><then> <block>{ 
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATERS_PARALLEL</name></cpp:ifdef>
    <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
  <if>if<condition>(<expr><name>soft_pwm_1</name> &lt; <name>pwm_count</name></expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
  <if>if<condition>(<expr><name>soft_pwm_2</name> &lt; <name>pwm_count</name></expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
  <if>if<condition>(<expr><name>soft_pwm_b</name> &lt; <name>pwm_count</name></expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
  <if>if<condition>(<expr><name>soft_pwm_fan</name> &lt; <name>pwm_count</name></expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>pwm_count</name> += (1 &lt;&lt; <name>SOFT_PWM_SCALE</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pwm_count</name> &amp;= 0x7f</expr>;</expr_stmt>
  
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> <comment type="line">//ifndef SLOW_PWM_HEATERS</comment>
  <comment type="block">/*
   * SLOW PWM HEATERS
   *
   * for heaters drived by relay
   */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>MIN_STATE_TIME</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_STATE_TIME</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> <comment type="line">// MIN_STATE_TIME * 65.5 = time in milliseconds</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if>if <condition>(<expr><name>slow_pwm_count</name> == 0</expr>)</condition><then> <block>{
    <comment type="line">// EXTRUDER 0 </comment>
    <expr_stmt><expr><name>soft_pwm_0</name> = <name><name>soft_pwm</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>soft_pwm_0</name> &gt; 0</expr>)</condition><then> <block>{
      <comment type="line">// turn ON heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_0</name> == 0</expr>)</condition><then> <block>{ 
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_0</name> == 0</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_0</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_0</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATERS_PARALLEL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <comment type="line">// turn OFF heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_0</name> == 0</expr>)</condition><then> <block>{
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_0</name> == 1</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_0</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_0</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATERS_PARALLEL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      }</block></then></if>
    }</block></else></if>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    <comment type="line">// EXTRUDER 1</comment>
    <expr_stmt><expr><name>soft_pwm_1</name> = <name><name>soft_pwm</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>soft_pwm_1</name> &gt; 0</expr>)</condition><then> <block>{
      <comment type="line">// turn ON heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_1</name> == 0</expr>)</condition><then> <block>{ 
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_1</name> == 0</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_1</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_1</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <comment type="line">// turn OFF heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_1</name> == 0</expr>)</condition><then> <block>{
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_1</name> == 1</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_1</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_1</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
    <comment type="line">// EXTRUDER 2</comment>
    <expr_stmt><expr><name>soft_pwm_2</name> = <name><name>soft_pwm</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>soft_pwm_2</name> &gt; 0</expr>)</condition><then> <block>{
      <comment type="line">// turn ON heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_2</name> == 0</expr>)</condition><then> <block>{ 
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_2</name> == 0</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_2</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_2</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <comment type="line">// turn OFF heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_2</name> == 0</expr>)</condition><then> <block>{
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_2</name> == 1</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_2</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_2</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
    <comment type="line">// BED</comment>
    <expr_stmt><expr><name>soft_pwm_b</name> = <name>soft_pwm_bed</name></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>soft_pwm_b</name> &gt; 0</expr>)</condition><then> <block>{
      <comment type="line">// turn ON heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_b</name> == 0</expr>)</condition><then> <block>{ 
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_b</name> == 0</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_b</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_b</name> = 1</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></then> <else>else <block>{
      <comment type="line">// turn OFF heather only if the minimum time is up </comment>
      <if>if <condition>(<expr><name>state_timer_heater_b</name> == 0</expr>)</condition><then> <block>{
	<comment type="line">// if change state set timer </comment>
	<if>if <condition>(<expr><name>state_heater_b</name> == 1</expr>)</condition><then> <block>{
	  <expr_stmt><expr><name>state_timer_heater_b</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
	}</block></then></if>
	<expr_stmt><expr><name>state_heater_b</name> = 0</expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></then></if>
    }</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if> <comment type="line">// if (slow_pwm_count == 0)</comment>
  
  <comment type="line">// EXTRUDER 0 </comment>
  <if>if <condition>(<expr><name>soft_pwm_0</name> &lt; <name>slow_pwm_count</name></expr>)</condition><then> <block>{
    <comment type="line">// turn OFF heather only if the minimum time is up </comment>
    <if>if <condition>(<expr><name>state_timer_heater_0</name> == 0</expr>)</condition><then> <block>{ 
      <comment type="line">// if change state set timer </comment>
      <if>if <condition>(<expr><name>state_heater_0</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>state_timer_heater_0</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>state_heater_0</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_0_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATERS_PARALLEL</name></cpp:ifdef>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    }</block></then></if>
  }</block></then></if>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
  <comment type="line">// EXTRUDER 1 </comment>
  <if>if <condition>(<expr><name>soft_pwm_1</name> &lt; <name>slow_pwm_count</name></expr>)</condition><then> <block>{
    <comment type="line">// turn OFF heather only if the minimum time is up </comment>
    <if>if <condition>(<expr><name>state_timer_heater_1</name> == 0</expr>)</condition><then> <block>{ 
      <comment type="line">// if change state set timer </comment>
      <if>if <condition>(<expr><name>state_heater_1</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>state_timer_heater_1</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>state_heater_1</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_1_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
  <comment type="line">// EXTRUDER 2</comment>
  <if>if <condition>(<expr><name>soft_pwm_2</name> &lt; <name>slow_pwm_count</name></expr>)</condition><then> <block>{
    <comment type="line">// turn OFF heather only if the minimum time is up </comment>
    <if>if <condition>(<expr><name>state_timer_heater_2</name> == 0</expr>)</condition><then> <block>{ 
      <comment type="line">// if change state set timer </comment>
      <if>if <condition>(<expr><name>state_heater_2</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>state_timer_heater_2</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>state_heater_2</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_2_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
  <comment type="line">// BED</comment>
  <if>if <condition>(<expr><name>soft_pwm_b</name> &lt; <name>slow_pwm_count</name></expr>)</condition><then> <block>{
    <comment type="line">// turn OFF heather only if the minimum time is up </comment>
    <if>if <condition>(<expr><name>state_timer_heater_b</name> == 0</expr>)</condition><then> <block>{ 
      <comment type="line">// if change state set timer </comment>
      <if>if <condition>(<expr><name>state_heater_b</name> == 1</expr>)</condition><then> <block>{
	<expr_stmt><expr><name>state_timer_heater_b</name> = <name>MIN_STATE_TIME</name></expr>;</expr_stmt>
      }</block></then></if>
      <expr_stmt><expr><name>state_heater_b</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAN_SOFT_PWM</name></cpp:ifdef>
  <if>if <condition>(<expr><name>pwm_count</name> == 0</expr>)</condition><then><block>{
    <expr_stmt><expr><name>soft_pwm_fan</name> = <name>fanSpeedSoftPwm</name> / 2</expr>;</expr_stmt>
    <if>if <condition>(<expr><name>soft_pwm_fan</name> &gt; 0</expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then> <else>else <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  }</block></then></if>
  <if>if <condition>(<expr><name>soft_pwm_fan</name> &lt; <name>pwm_count</name></expr>)</condition><then> <expr_stmt><expr><call><name>WRITE</name><argument_list>(<argument><expr><name>FAN_PIN</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <expr_stmt><expr><name>pwm_count</name> += (1 &lt;&lt; <name>SOFT_PWM_SCALE</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name>pwm_count</name> &amp;= 0x7f</expr>;</expr_stmt>
  
  <comment type="line">// increment slow_pwm_count only every 64 pwm_count circa 65.5ms</comment>
  <if>if <condition>(<expr>(<name>pwm_count</name> % 64) == 0</expr>)</condition><then> <block>{
    <expr_stmt><expr><name>slow_pwm_count</name>++</expr>;</expr_stmt>
    <expr_stmt><expr><name>slow_pwm_count</name> &amp;= 0x7f</expr>;</expr_stmt>
    
    <comment type="line">// Extruder 0</comment>
    <if>if <condition>(<expr><name>state_timer_heater_0</name> &gt; 0</expr>)</condition><then> <block>{
      <expr_stmt><expr><name>state_timer_heater_0</name>--</expr>;</expr_stmt>
    }</block></then></if> 
  
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
    <comment type="line">// Extruder 1</comment>
    <if>if <condition>(<expr><name>state_timer_heater_1</name> &gt; 0</expr>)</condition><then> 
      <expr_stmt><expr><name>state_timer_heater_1</name>--</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
    <comment type="line">// Extruder 2</comment>
    <if>if <condition>(<expr><name>state_timer_heater_2</name> &gt; 0</expr>)</condition><then> 
      <expr_stmt><expr><name>state_timer_heater_2</name>--</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEATER_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>HEATER_BED_PIN</name> &gt; -1</expr></cpp:if>
    <comment type="line">// Bed   </comment>
    <if>if <condition>(<expr><name>state_timer_heater_b</name> &gt; 0</expr>)</condition><then> 
      <expr_stmt><expr><name>state_timer_heater_b</name>--</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if> <comment type="line">//if ((pwm_count % 64) == 0) {</comment>
  
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//ifndef SLOW_PWM_HEATERS</comment>
  
  <switch>switch<condition>(<expr><name>temp_state</name></expr>)</condition> <block>{
    <case>case <expr>0</expr>: <comment type="line">// Prepare TEMP_0</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_0_PIN</name> &gt; -1)</expr></cpp:if>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_0_PIN</name> &gt; 7</expr></cpp:if>
          <expr_stmt><expr><name>ADCSRB</name> = 1&lt;&lt;<name>MUX5</name></expr>;</expr_stmt>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>ADCSRB</name> = 0</expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>ADMUX</name> = ((1 &lt;&lt; <name>REFS0</name>) | (<name>TEMP_0_PIN</name> &amp; 0x07))</expr>;</expr_stmt>
        <expr_stmt><expr><name>ADCSRA</name> |= 1&lt;&lt;<name>ADSC</name></expr>;</expr_stmt> <comment type="line">// Start conversion</comment>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>lcd_buttons_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>temp_state</name> = 1</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>1</expr>: <comment type="line">// Measure TEMP_0</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_0_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_0_PIN</name> &gt; -1)</expr></cpp:if>
        <expr_stmt><expr><name>raw_temp_0_value</name> += <name>ADC</name></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEATER_0_USES_MAX6675</name></cpp:ifdef> <comment type="line">// TODO remove the blocking</comment>
        <expr_stmt><expr><name>raw_temp_0_value</name> = <call><name>read_max6675</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>temp_state</name> = 2</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>2</expr>: <comment type="line">// Prepare TEMP_BED</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_BED_PIN</name> &gt; -1)</expr></cpp:if>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_BED_PIN</name> &gt; 7</expr></cpp:if>
          <expr_stmt><expr><name>ADCSRB</name> = 1&lt;&lt;<name>MUX5</name></expr>;</expr_stmt>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>ADCSRB</name> = 0</expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>ADMUX</name> = ((1 &lt;&lt; <name>REFS0</name>) | (<name>TEMP_BED_PIN</name> &amp; 0x07))</expr>;</expr_stmt>
        <expr_stmt><expr><name>ADCSRA</name> |= 1&lt;&lt;<name>ADSC</name></expr>;</expr_stmt> <comment type="line">// Start conversion</comment>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>lcd_buttons_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>temp_state</name> = 3</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>3</expr>: <comment type="line">// Measure TEMP_BED</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_BED_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_BED_PIN</name> &gt; -1)</expr></cpp:if>
        <expr_stmt><expr><name>raw_temp_bed_value</name> += <name>ADC</name></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>temp_state</name> = 4</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>4</expr>: <comment type="line">// Prepare TEMP_1</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_1_PIN</name> &gt; -1)</expr></cpp:if>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_1_PIN</name> &gt; 7</expr></cpp:if>
          <expr_stmt><expr><name>ADCSRB</name> = 1&lt;&lt;<name>MUX5</name></expr>;</expr_stmt>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>ADCSRB</name> = 0</expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>ADMUX</name> = ((1 &lt;&lt; <name>REFS0</name>) | (<name>TEMP_1_PIN</name> &amp; 0x07))</expr>;</expr_stmt>
        <expr_stmt><expr><name>ADCSRA</name> |= 1&lt;&lt;<name>ADSC</name></expr>;</expr_stmt> <comment type="line">// Start conversion</comment>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>lcd_buttons_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>temp_state</name> = 5</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>5</expr>: <comment type="line">// Measure TEMP_1</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_1_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_1_PIN</name> &gt; -1)</expr></cpp:if>
        <expr_stmt><expr><name>raw_temp_1_value</name> += <name>ADC</name></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>temp_state</name> = 6</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>6</expr>: <comment type="line">// Prepare TEMP_2</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_2_PIN</name> &gt; -1)</expr></cpp:if>
        <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>TEMP_2_PIN</name> &gt; 7</expr></cpp:if>
          <expr_stmt><expr><name>ADCSRB</name> = 1&lt;&lt;<name>MUX5</name></expr>;</expr_stmt>
        <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><name>ADCSRB</name> = 0</expr>;</expr_stmt>
        <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><name>ADMUX</name> = ((1 &lt;&lt; <name>REFS0</name>) | (<name>TEMP_2_PIN</name> &amp; 0x07))</expr>;</expr_stmt>
        <expr_stmt><expr><name>ADCSRA</name> |= 1&lt;&lt;<name>ADSC</name></expr>;</expr_stmt> <comment type="line">// Start conversion</comment>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><call><name>lcd_buttons_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>temp_state</name> = 7</expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>7</expr>: <comment type="line">// Measure TEMP_2</comment>
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TEMP_2_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_2_PIN</name> &gt; -1)</expr></cpp:if>
        <expr_stmt><expr><name>raw_temp_2_value</name> += <name>ADC</name></expr>;</expr_stmt>
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>temp_state</name> = 8</expr>;</expr_stmt><comment type="line">//change so that Filament Width is also measured</comment>
      
      <break>break;</break>
    </case><case>case <expr>8</expr>: <comment type="line">//Prepare FILWIDTH </comment>
     <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILWIDTH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>FILWIDTH_PIN</name>&gt; -1)</expr></cpp:if> 
      <cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FILWIDTH_PIN</name>&gt;7</expr></cpp:if> 
         <expr_stmt><expr><name>ADCSRB</name> = 1&lt;&lt;<name>MUX5</name></expr>;</expr_stmt>
      <cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
         <expr_stmt><expr><name>ADCSRB</name> = 0</expr>;</expr_stmt> 
      <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
      <expr_stmt><expr><name>ADMUX</name> = ((1 &lt;&lt; <name>REFS0</name>) | (<name>FILWIDTH_PIN</name> &amp; 0x07))</expr>;</expr_stmt> 
      <expr_stmt><expr><name>ADCSRA</name> |= 1&lt;&lt;<name>ADSC</name></expr>;</expr_stmt> <comment type="line">// Start conversion </comment>
     <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
     <expr_stmt><expr><call><name>lcd_buttons_update</name><argument_list>()</argument_list></call></expr>;</expr_stmt>       
     <expr_stmt><expr><name>temp_state</name> = 9</expr>;</expr_stmt> 
     <break>break;</break> 
    </case><case>case <expr>9</expr>:   <comment type="line">//Measure FILWIDTH </comment>
     <cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILWIDTH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp;(<name>FILWIDTH_PIN</name> &gt; -1)</expr></cpp:if> 
     <comment type="line">//raw_filwidth_value += ADC;  //remove to use an IIR filter approach </comment>
      <if>if<condition>(<expr><name>ADC</name>&gt;102</expr>)</condition><then>  <comment type="line">//check that ADC is reading a voltage &gt; 0.5 volts, otherwise don't take in the data.</comment>
        <block>{
    	<expr_stmt><expr><name>raw_filwidth_value</name>= <name>raw_filwidth_value</name>-(<name>raw_filwidth_value</name>&gt;&gt;7)</expr>;</expr_stmt>  <comment type="line">//multipliy raw_filwidth_value by 127/128</comment>
        
        <expr_stmt><expr><name>raw_filwidth_value</name>= <name>raw_filwidth_value</name> + ((<name>unsigned</name> <name>long</name>)<name>ADC</name>&lt;&lt;7)</expr>;</expr_stmt>  <comment type="line">//add new ADC reading </comment>
        }</block></then></if>
     <cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
     <expr_stmt><expr><name>temp_state</name> = 0</expr>;</expr_stmt>   
      
     <expr_stmt><expr><name>temp_count</name>++</expr>;</expr_stmt>
     <break>break;</break>      
      
      
    </case><case>case <expr>10</expr>: <comment type="line">//Startup, delay initial temp reading a tiny bit so the hardware can settle.</comment>
      <expr_stmt><expr><name>temp_state</name> = 0</expr>;</expr_stmt>
      <break>break;</break>
<comment type="line">//    default:</comment>
<comment type="line">//      SERIAL_ERROR_START;</comment>
<comment type="line">//      SERIAL_ERRORLNPGM("Temp measurement error!");</comment>
<comment type="line">//      break;</comment>
  </case>}</block></switch>
    
  <if>if<condition>(<expr><name>temp_count</name> &gt;= <name>OVERSAMPLENR</name></expr>)</condition><then> <comment type="line">// 10 * 16 * 1/(16000000/64/256)  = 164ms.</comment>
  <block>{
    <if>if <condition>(<expr>!<name>temp_meas_ready</name></expr>)</condition><then> <comment type="line">//Only update the raw values if they have been read. Else we could be updating them during reading.</comment>
    <block>{
      <expr_stmt><expr><name><name>current_temperature_raw</name><index>[<expr>0</expr>]</index></name> = <name>raw_temp_0_value</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
      <expr_stmt><expr><name><name>current_temperature_raw</name><index>[<expr>1</expr>]</index></name> = <name>raw_temp_1_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TEMP_SENSOR_1_AS_REDUNDANT</name></cpp:ifdef>
      <expr_stmt><expr><name>redundant_temperature_raw</name> = <name>raw_temp_1_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
      <expr_stmt><expr><name><name>current_temperature_raw</name><index>[<expr>2</expr>]</index></name> = <name>raw_temp_2_value</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <expr_stmt><expr><name>current_temperature_bed_raw</name> = <name>raw_temp_bed_value</name></expr>;</expr_stmt>
    }</block></then></if>

<comment type="line">//Add similar code for Filament Sensor - can be read any time since IIR filtering is used </comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FILWIDTH_PIN</name></expr></argument>)</argument_list></call> &amp;&amp;(<name>FILWIDTH_PIN</name> &gt; -1)</expr></cpp:if>
  <expr_stmt><expr><name>current_raw_filwidth</name> = <name>raw_filwidth_value</name>&gt;&gt;10</expr>;</expr_stmt>  <comment type="line">//need to divide to get to 0-16384 range since we used 1/128 IIR filter approach </comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    
    
    <expr_stmt><expr><name>temp_meas_ready</name> = true</expr>;</expr_stmt>
    <expr_stmt><expr><name>temp_count</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>raw_temp_0_value</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>raw_temp_1_value</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>raw_temp_2_value</name> = 0</expr>;</expr_stmt>
    <expr_stmt><expr><name>raw_temp_bed_value</name> = 0</expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_0_RAW_LO_TEMP</name> &gt; <name>HEATER_0_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>0</expr>]</index></name> &lt;= <name><name>maxttemp_raw</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>0</expr>]</index></name> &gt;= <name><name>maxttemp_raw</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>max_temp_error</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_0_RAW_LO_TEMP</name> &gt; <name>HEATER_0_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>0</expr>]</index></name> &gt;= <name><name>minttemp_raw</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>0</expr>]</index></name> &lt;= <name><name>minttemp_raw</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>min_temp_error</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 1</expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_1_RAW_LO_TEMP</name> &gt; <name>HEATER_1_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>1</expr>]</index></name> &lt;= <name><name>maxttemp_raw</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>1</expr>]</index></name> &gt;= <name><name>maxttemp_raw</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>max_temp_error</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_1_RAW_LO_TEMP</name> &gt; <name>HEATER_1_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>1</expr>]</index></name> &gt;= <name><name>minttemp_raw</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>1</expr>]</index></name> &lt;= <name><name>minttemp_raw</name><index>[<expr>1</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>min_temp_error</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>EXTRUDERS</name> &gt; 2</expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_2_RAW_LO_TEMP</name> &gt; <name>HEATER_2_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>2</expr>]</index></name> &lt;= <name><name>maxttemp_raw</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>2</expr>]</index></name> &gt;= <name><name>maxttemp_raw</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>max_temp_error</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HEATER_2_RAW_LO_TEMP</name> &gt; <name>HEATER_2_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>2</expr>]</index></name> &gt;= <name><name>minttemp_raw</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name><name>current_temperature_raw</name><index>[<expr>2</expr>]</index></name> &lt;= <name><name>minttemp_raw</name><index>[<expr>2</expr>]</index></name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        <expr_stmt><expr><call><name>min_temp_error</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  
  <comment type="block">/* No bed MINTEMP error? */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BED_MAXTEMP</name></expr></argument>)</argument_list></call> &amp;&amp; (<name>TEMP_SENSOR_BED</name> != 0)</expr></cpp:if>
<cpp:if># <cpp:directive>if</cpp:directive> <expr><name>HEATER_BED_RAW_LO_TEMP</name> &gt; <name>HEATER_BED_RAW_HI_TEMP</name></expr></cpp:if>
    <if>if<condition>(<expr><name>current_temperature_bed_raw</name> &lt;= <name>bed_maxttemp_raw</name></expr>)</condition><then> <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <if>if<condition>(<expr><name>current_temperature_bed_raw</name> &gt;= <name>bed_maxttemp_raw</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       <expr_stmt><expr><name>target_temperature_bed</name> = 0</expr>;</expr_stmt>
       <expr_stmt><expr><call><name>bed_max_temp_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></then></if>
  
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BABYSTEPPING</name></cpp:ifdef>
  <for>for(<init><decl><type><name>uint8_t</name></type> <name>axis</name><init>=<expr>0</expr></init></decl>;</init><condition><expr><name>axis</name>&lt;3</expr>;</condition><incr><expr><name>axis</name>++</expr></incr>)
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>curTodo</name><init>=<expr><name><name>babystepsTodo</name><index>[<expr><name>axis</name></expr>]</index></name></expr></init></decl>;</decl_stmt> <comment type="line">//get rid of volatile for performance</comment>
   
    <if>if<condition>(<expr><name>curTodo</name>&gt;0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>babystep</name><argument_list>(<argument><expr><name>axis</name></expr></argument>,<comment type="block">/*fwd*/</comment><argument><expr>true</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>babystepsTodo</name><index>[<expr><name>axis</name></expr>]</index></name>--</expr>;</expr_stmt> <comment type="line">//less to do next time</comment>
    }</block></then>
    <else>else
    <if>if<condition>(<expr><name>curTodo</name>&lt;0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>babystep</name><argument_list>(<argument><expr><name>axis</name></expr></argument>,<comment type="block">/*fwd*/</comment><argument><expr>false</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>babystepsTodo</name><index>[<expr><name>axis</name></expr>]</index></name>++</expr>;</expr_stmt> <comment type="line">//less to do next time</comment>
    }</block></then></if></else></if>
  }</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//BABYSTEPPING</comment>
}</block></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PIDTEMP</name></cpp:ifdef>
<comment type="line">// Apply the scale factors to the PID values</comment>


<function><type><name>float</name></type> <name>scalePID_i</name><parameter_list>(<param><decl><type><name>float</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>i</name>*<name>PID_dT</name></expr>;</return>
}</block></function>

<function><type><name>float</name></type> <name>unscalePID_i</name><parameter_list>(<param><decl><type><name>float</name></type> <name>i</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>i</name>/<name>PID_dT</name></expr>;</return>
}</block></function>

<function><type><name>float</name></type> <name>scalePID_d</name><parameter_list>(<param><decl><type><name>float</name></type> <name>d</name></decl></param>)</parameter_list>
<block>{
    <return>return <expr><name>d</name>/<name>PID_dT</name></expr>;</return>
}</block></function>

<function><type><name>float</name></type> <name>unscalePID_d</name><parameter_list>(<param><decl><type><name>float</name></type> <name>d</name></decl></param>)</parameter_list>
<block>{
	<return>return <expr><name>d</name>*<name>PID_dT</name></expr>;</return>
}</block></function></block></then></if></block></then></if></block></then></if></block></then></if></block></then></if></block></then></if></block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="line">//PIDTEMP</comment>


</unit>
